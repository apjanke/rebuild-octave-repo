# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444102969 14400
#      Mon Oct 05 23:42:49 2015 -0400
# Node ID a05a0432dff45d9bf8824051e7f80e3b29474cb8
# Parent  c4159506118610696fb0564161ce0d7874cc42ba
eliminate more simple uses of error_state

* data.cc: Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -408,17 +408,17 @@ hypot (hypot (hypot (@var{x}, @var{y}), 
 
   if (nargin == 2)
     {
       retval = do_hypot (args(0), args(1));
     }
   else if (nargin >= 3)
     {
       retval = args(0);
-      for (int i = 1; i < nargin && ! error_state; i++)
+      for (int i = 1; i < nargin; i++)
         retval = do_hypot (retval, args(i));
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -931,182 +931,166 @@ negative numbers or when the values are 
 */
 
 // FIXME: Need to convert reduction functions of this file for single precision
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM) \
   (arg.is_ ## TYPE ## _type ()) \
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
-      \
-      if (! error_state) \
-        { \
-          retval = tmp.FCN (DIM); \
-        } \
+ \
+      retval = tmp.FCN (DIM); \
     }
 
 #define NATIVE_REDUCTION(FCN, BOOL_FCN) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
   bool isnative = false; \
   bool isdouble = false; \
-  \
+ \
   if (nargin > 1 && args(nargin - 1).is_string ()) \
     { \
       std::string str = args(nargin - 1).string_value (); \
-      \
+ \
       if (str == "native") \
         isnative = true; \
       else if (str == "double") \
         isdouble = true; \
       else \
         error ("sum: unrecognized string argument"); \
       nargin --; \
     } \
-  \
+ \
   if (nargin == 1 || nargin == 2) \
     { \
       octave_value arg = args(0); \
  \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
-      if (! error_state) \
+      if (dim >= -1) \
         { \
-          if (dim >= -1) \
+          if (arg.is_sparse_type ()) \
             { \
-              if (arg.is_sparse_type ()) \
+              if (arg.is_real_type ()) \
                 { \
-                  if (arg.is_real_type ()) \
-                    { \
-                      SparseMatrix tmp = arg.sparse_matrix_value (); \
-                      \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else \
-                    { \
-                      SparseComplexMatrix tmp \
-                        = arg.sparse_complex_matrix_value (); \
-                      \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
+                  SparseMatrix tmp = arg.sparse_matrix_value (); \
+ \
+                  retval = tmp.FCN (dim); \
                 } \
               else \
                 { \
-                  if (isnative) \
+                  SparseComplexMatrix tmp \
+                    = arg.sparse_complex_matrix_value (); \
+ \
+                  retval = tmp.FCN (dim); \
+                } \
+            } \
+          else \
+            { \
+              if (isnative) \
+                { \
+                  if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
+                  else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
+                  else if (arg.is_bool_type ()) \
                     { \
-                      if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
-                      else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
-                      else if (arg.is_bool_type ()) \
-                        { \
-                          boolNDArray tmp = arg.bool_array_value (); \
-                          if (! error_state) \
-                            retval = boolNDArray (tmp.BOOL_FCN (dim)); \
-                        } \
-                      else if (arg.is_char_matrix ()) \
-                        { \
-                          error (#FCN, ": invalid char type"); \
-                        } \
-                      else if (!isdouble && arg.is_single_type ()) \
+                      boolNDArray tmp = arg.bool_array_value (); \
+ \
+                      retval = boolNDArray (tmp.BOOL_FCN (dim)); \
+                    } \
+                  else if (arg.is_char_matrix ()) \
+                    { \
+                      error (#FCN, ": invalid char type"); \
+                    } \
+                  else if (!isdouble && arg.is_single_type ()) \
+                    { \
+                      if (arg.is_complex_type ()) \
                         { \
-                          if (arg.is_complex_type ()) \
-                            { \
-                              FloatComplexNDArray tmp = \
-                                arg.float_complex_array_value (); \
-                              \
-                              if (! error_state) \
-                                retval = tmp.FCN (dim); \
-                            } \
-                          else if (arg.is_real_type ()) \
-                            { \
-                              FloatNDArray tmp = arg.float_array_value (); \
-                              \
-                              if (! error_state) \
-                                retval = tmp.FCN (dim); \
-                            } \
-                        } \
-                      else if (arg.is_complex_type ()) \
-                        { \
-                          ComplexNDArray tmp = arg.complex_array_value (); \
-                          \
-                          if (! error_state) \
-                            retval = tmp.FCN (dim); \
+                          FloatComplexNDArray tmp = \
+                            arg.float_complex_array_value (); \
+ \
+                          retval = tmp.FCN (dim); \
                         } \
                       else if (arg.is_real_type ()) \
                         { \
-                          NDArray tmp = arg.array_value (); \
-                          \
-                          if (! error_state) \
-                            retval = tmp.FCN (dim); \
-                        } \
-                      else \
-                        { \
-                          gripe_wrong_type_arg (#FCN, arg); \
-                          return retval; \
+                          FloatNDArray tmp = arg.float_array_value (); \
+ \
+                          retval = tmp.FCN (dim); \
                         } \
                     } \
-                  else if (arg.is_bool_type ()) \
-                    { \
-                      boolNDArray tmp = arg.bool_array_value (); \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else if (!isdouble && arg.is_single_type ()) \
+                  else if (arg.is_complex_type ()) \
                     { \
-                      if (arg.is_real_type ()) \
-                        { \
-                          FloatNDArray tmp = arg.float_array_value (); \
-                          \
-                          if (! error_state) \
-                            retval = tmp.FCN (dim); \
-                        } \
-                      else if (arg.is_complex_type ()) \
-                        { \
-                          FloatComplexNDArray tmp = \
-                            arg.float_complex_array_value (); \
-                          \
-                          if (! error_state) \
-                            retval = tmp.FCN (dim); \
-                        } \
+                      ComplexNDArray tmp = arg.complex_array_value (); \
+ \
+                      retval = tmp.FCN (dim); \
                     } \
                   else if (arg.is_real_type ()) \
                     { \
                       NDArray tmp = arg.array_value (); \
-                      \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else if (arg.is_complex_type ()) \
-                    { \
-                      ComplexNDArray tmp = arg.complex_array_value (); \
-                      \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
+ \
+                      retval = tmp.FCN (dim); \
                     } \
                   else \
                     { \
                       gripe_wrong_type_arg (#FCN, arg); \
                       return retval; \
                     } \
                 } \
+              else if (arg.is_bool_type ()) \
+                { \
+                  boolNDArray tmp = arg.bool_array_value (); \
+ \
+                  retval = tmp.FCN (dim); \
+                } \
+              else if (!isdouble && arg.is_single_type ()) \
+                { \
+                  if (arg.is_real_type ()) \
+                    { \
+                      FloatNDArray tmp = arg.float_array_value (); \
+ \
+                      retval = tmp.FCN (dim); \
+                    } \
+                  else if (arg.is_complex_type ()) \
+                    { \
+                      FloatComplexNDArray tmp = \
+                        arg.float_complex_array_value (); \
+ \
+                      retval = tmp.FCN (dim); \
+                    } \
+                } \
+              else if (arg.is_real_type ()) \
+                { \
+                  NDArray tmp = arg.array_value (); \
+ \
+                  retval = tmp.FCN (dim); \
+                } \
+              else if (arg.is_complex_type ()) \
+                { \
+                  ComplexNDArray tmp = arg.complex_array_value (); \
+ \
+                  retval = tmp.FCN (dim); \
+                } \
+              else \
+                { \
+                  gripe_wrong_type_arg (#FCN, arg); \
+                  return retval; \
+                } \
             } \
           else \
             error (#FCN ": invalid dimension argument = %d", dim + 1); \
         } \
-      \
+ \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 #define DATA_REDUCTION(FCN) \
  \
@@ -1115,78 +1099,69 @@ negative numbers or when the values are 
   int nargin = args.length (); \
  \
   if (nargin == 1 || nargin == 2) \
     { \
       octave_value arg = args(0); \
  \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
-      if (! error_state) \
+      if (dim >= -1) \
         { \
-          if (dim >= -1) \
+          if (arg.is_real_type ()) \
             { \
-              if (arg.is_real_type ()) \
+              if (arg.is_sparse_type ()) \
                 { \
-                  if (arg.is_sparse_type ()) \
-                    { \
-                      SparseMatrix tmp = arg.sparse_matrix_value (); \
- \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else if (arg.is_single_type ()) \
-                    { \
-                      FloatNDArray tmp = arg.float_array_value (); \
- \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else \
-                    { \
-                      NDArray tmp = arg.array_value (); \
- \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
+                  SparseMatrix tmp = arg.sparse_matrix_value (); \
+\
+                  retval = tmp.FCN (dim); \
                 } \
-              else if (arg.is_complex_type ()) \
+              else if (arg.is_single_type ()) \
                 { \
-                  if (arg.is_sparse_type ()) \
-                    { \
-                      SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
- \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else if (arg.is_single_type ()) \
-                    { \
-                      FloatComplexNDArray tmp \
-                        = arg.float_complex_array_value (); \
- \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
-                  else \
-                    { \
-                      ComplexNDArray tmp = arg.complex_array_value (); \
- \
-                      if (! error_state) \
-                        retval = tmp.FCN (dim); \
-                    } \
+                  FloatNDArray tmp = arg.float_array_value (); \
+\
+                  retval = tmp.FCN (dim); \
                 } \
               else \
                 { \
-                  gripe_wrong_type_arg (#FCN, arg); \
-                  return retval; \
+                  NDArray tmp = arg.array_value (); \
+\
+                  retval = tmp.FCN (dim); \
+                } \
+            } \
+          else if (arg.is_complex_type ()) \
+            { \
+              if (arg.is_sparse_type ()) \
+                { \
+                  SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+\
+                  retval = tmp.FCN (dim); \
+                } \
+              else if (arg.is_single_type ()) \
+                { \
+                  FloatComplexNDArray tmp \
+                    = arg.float_complex_array_value (); \
+\
+                  retval = tmp.FCN (dim); \
+                } \
+              else \
+                { \
+                  ComplexNDArray tmp = arg.complex_array_value (); \
+\
+                  retval = tmp.FCN (dim); \
                 } \
             } \
           else \
-            error (#FCN ": invalid dimension argument = %d", dim + 1); \
+            { \
+              gripe_wrong_type_arg (#FCN, arg); \
+              return retval; \
+            } \
         } \
+      else \
+        error (#FCN ": invalid dimension argument = %d", dim + 1); \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
        "-*- texinfo -*-\n\
@@ -1252,99 +1227,93 @@ See @code{sum} for an explanation of the
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else
         error ("cumsum: unrecognized string argument");
       nargin --;
     }
 
-  if (error_state)
-    return retval;
-
   if (nargin == 1 || nargin == 2)
     {
       octave_value arg = args(0);
 
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value () - 1;
           if (dim < 0)
             error ("cumsum: invalid dimension argument = %d", dim + 1);
         }
 
-      if (! error_state)
+      switch (arg.builtin_type ())
         {
-          switch (arg.builtin_type ())
-            {
-            case btyp_double:
-              if (arg.is_sparse_type ())
-                retval = arg.sparse_matrix_value ().cumsum (dim);
-              else
-                retval = arg.array_value ().cumsum (dim);
-              break;
-            case btyp_complex:
-              if (arg.is_sparse_type ())
-                retval = arg.sparse_complex_matrix_value ().cumsum (dim);
-              else
-                retval = arg.complex_array_value ().cumsum (dim);
-              break;
-            case btyp_float:
-              if (isdouble)
-                retval = arg.array_value ().cumsum (dim);
-              else
-                retval = arg.float_array_value ().cumsum (dim);
-              break;
-            case btyp_float_complex:
-              if (isdouble)
-                retval = arg.complex_array_value ().cumsum (dim);
-              else
-                retval = arg.float_complex_array_value ().cumsum (dim);
-              break;
+        case btyp_double:
+          if (arg.is_sparse_type ())
+            retval = arg.sparse_matrix_value ().cumsum (dim);
+          else
+            retval = arg.array_value ().cumsum (dim);
+          break;
+        case btyp_complex:
+          if (arg.is_sparse_type ())
+            retval = arg.sparse_complex_matrix_value ().cumsum (dim);
+          else
+            retval = arg.complex_array_value ().cumsum (dim);
+          break;
+        case btyp_float:
+          if (isdouble)
+            retval = arg.array_value ().cumsum (dim);
+          else
+            retval = arg.float_array_value ().cumsum (dim);
+          break;
+        case btyp_float_complex:
+          if (isdouble)
+            retval = arg.complex_array_value ().cumsum (dim);
+          else
+            retval = arg.float_complex_array_value ().cumsum (dim);
+          break;
 
 #define MAKE_INT_BRANCH(X) \
-            case btyp_ ## X: \
-              if (isnative) \
-                retval = arg.X ## _array_value ().cumsum (dim); \
-              else \
-                retval = arg.array_value ().cumsum (dim); \
-              break;
-            MAKE_INT_BRANCH (int8);
-            MAKE_INT_BRANCH (int16);
-            MAKE_INT_BRANCH (int32);
-            MAKE_INT_BRANCH (int64);
-            MAKE_INT_BRANCH (uint8);
-            MAKE_INT_BRANCH (uint16);
-            MAKE_INT_BRANCH (uint32);
-            MAKE_INT_BRANCH (uint64);
+          case btyp_ ## X: \
+            if (isnative) \
+              retval = arg.X ## _array_value ().cumsum (dim); \
+            else \
+              retval = arg.array_value ().cumsum (dim); \
+            break;
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
 
-            case btyp_bool:
-              if (arg.is_sparse_type ())
-                {
-                  SparseMatrix cs = arg.sparse_matrix_value ().cumsum (dim);
-                  if (isnative)
-                    retval = cs != 0.0;
-                  else
-                    retval = cs;
-                }
+        case btyp_bool:
+          if (arg.is_sparse_type ())
+            {
+              SparseMatrix cs = arg.sparse_matrix_value ().cumsum (dim);
+              if (isnative)
+                retval = cs != 0.0;
               else
-                {
-                  NDArray cs = arg.bool_array_value ().cumsum (dim);
-                  if (isnative)
-                    retval = cs != 0.0;
-                  else
-                    retval = cs;
-                }
-              break;
-
-            default:
-              gripe_wrong_type_arg ("cumsum", arg);
+                retval = cs;
             }
+          else
+            {
+              NDArray cs = arg.bool_array_value ().cumsum (dim);
+              if (isnative)
+                retval = cs != 0.0;
+              else
+                retval = cs;
+            }
+          break;
+
+        default:
+          gripe_wrong_type_arg ("cumsum", arg);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -1551,98 +1520,92 @@ in double precision even for single prec
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else
         error ("prod: unrecognized type argument '%s'", str.c_str ());
       nargin --;
     }
 
-  if (error_state)
-    return retval;
-
   if (nargin == 1 || nargin == 2)
     {
       octave_value arg = args(0);
 
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value () - 1;
           if (dim < 0)
             error ("prod: invalid dimension DIM = %d", dim + 1);
         }
 
-      if (! error_state)
+      switch (arg.builtin_type ())
         {
-          switch (arg.builtin_type ())
-            {
-            case btyp_double:
-              if (arg.is_sparse_type ())
-                retval = arg.sparse_matrix_value ().prod (dim);
-              else
-                retval = arg.array_value ().prod (dim);
-              break;
-            case btyp_complex:
-              if (arg.is_sparse_type ())
-                retval = arg.sparse_complex_matrix_value ().prod (dim);
-              else
-                retval = arg.complex_array_value ().prod (dim);
-              break;
-            case btyp_float:
-              if (isdouble)
-                retval = arg.float_array_value ().dprod (dim);
-              else
-                retval = arg.float_array_value ().prod (dim);
-              break;
-            case btyp_float_complex:
-              if (isdouble)
-                retval = arg.float_complex_array_value ().dprod (dim);
-              else
-                retval = arg.float_complex_array_value ().prod (dim);
-              break;
+        case btyp_double:
+          if (arg.is_sparse_type ())
+            retval = arg.sparse_matrix_value ().prod (dim);
+          else
+            retval = arg.array_value ().prod (dim);
+          break;
+        case btyp_complex:
+          if (arg.is_sparse_type ())
+            retval = arg.sparse_complex_matrix_value ().prod (dim);
+          else
+            retval = arg.complex_array_value ().prod (dim);
+          break;
+        case btyp_float:
+          if (isdouble)
+            retval = arg.float_array_value ().dprod (dim);
+          else
+            retval = arg.float_array_value ().prod (dim);
+          break;
+        case btyp_float_complex:
+          if (isdouble)
+            retval = arg.float_complex_array_value ().dprod (dim);
+          else
+            retval = arg.float_complex_array_value ().prod (dim);
+          break;
 
 #define MAKE_INT_BRANCH(X) \
-            case btyp_ ## X: \
-              if (isnative) \
-                retval = arg.X ## _array_value ().prod (dim); \
-              else \
-                retval = arg.array_value ().prod (dim); \
-              break;
-            MAKE_INT_BRANCH (int8);
-            MAKE_INT_BRANCH (int16);
-            MAKE_INT_BRANCH (int32);
-            MAKE_INT_BRANCH (int64);
-            MAKE_INT_BRANCH (uint8);
-            MAKE_INT_BRANCH (uint16);
-            MAKE_INT_BRANCH (uint32);
-            MAKE_INT_BRANCH (uint64);
+          case btyp_ ## X: \
+            if (isnative) \
+              retval = arg.X ## _array_value ().prod (dim); \
+            else \
+              retval = arg.array_value ().prod (dim); \
+            break;
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
 
-            // GAGME: Accursed Matlab compatibility...
-            case btyp_char:
-              retval = arg.array_value (true).prod (dim);
-              break;
-            case btyp_bool:
-              if (arg.is_sparse_type ())
-                {
-                  if (isnative)
-                    retval = arg.sparse_bool_matrix_value ().all (dim);
-                  else
-                    retval = arg.sparse_matrix_value ().prod (dim);
-                }
-              else if (isnative)
-                retval = arg.bool_array_value ().all (dim);
+          // GAGME: Accursed Matlab compatibility...
+        case btyp_char:
+          retval = arg.array_value (true).prod (dim);
+          break;
+        case btyp_bool:
+          if (arg.is_sparse_type ())
+            {
+              if (isnative)
+                retval = arg.sparse_bool_matrix_value ().all (dim);
               else
-                retval = NDArray (arg.bool_array_value ().all (dim));
-              break;
-
-            default:
-              gripe_wrong_type_arg ("prod", arg);
+                retval = arg.sparse_matrix_value ().prod (dim);
             }
+          else if (isnative)
+            retval = arg.bool_array_value ().all (dim);
+          else
+            retval = NDArray (arg.bool_array_value ().all (dim));
+          break;
+
+        default:
+          gripe_wrong_type_arg ("prod", arg);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -1741,57 +1704,55 @@ single_type_concat (Array<T>& result,
       if (dim == -1 || dim == -2)
         dim = -dim - 1;
       else if (dim >= 2)
         dv.resize (dim+1, 1);
       dv(dim) = n_args;
 
       result.clear (dv);
 
-      for (int j = 0; j < n_args && ! error_state; j++)
+      for (int j = 0; j < n_args; j++)
         {
           octave_quit ();
 
           result(j) = octave_value_extract<T> (args(j));
         }
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (Array<T>, array_list, n_args);
 
-      for (int j = 0; j < n_args && ! error_state; j++)
+      for (int j = 0; j < n_args; j++)
         {
           octave_quit ();
 
           array_list[j] = octave_value_extract<TYPE> (args(j));
         }
 
-      if (! error_state)
-        result = Array<T>::cat (dim, n_args, array_list);
+      result = Array<T>::cat (dim, n_args, array_list);
     }
 }
 
 template <class TYPE, class T>
 static void
 single_type_concat (Sparse<T>& result,
                     const octave_value_list& args,
                     int dim)
 {
   int n_args = args.length ();
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, n_args);
 
-  for (int j = 0; j < n_args && ! error_state; j++)
+  for (int j = 0; j < n_args; j++)
     {
       octave_quit ();
 
       sparse_list[j] = octave_value_extract<TYPE> (args(j));
     }
 
-  if (! error_state)
-    result = Sparse<T>::cat (dim, n_args, sparse_list);
+  result = Sparse<T>::cat (dim, n_args, sparse_list);
 }
 
 // Dispatcher.
 template<class TYPE>
 static TYPE
 do_single_type_concat (const octave_value_list& args, int dim)
 {
   TYPE result;
@@ -1805,25 +1766,24 @@ template<class MAP>
 static void
 single_type_concat_map (octave_map& result,
                         const octave_value_list& args,
                         int dim)
 {
   int n_args = args.length ();
   OCTAVE_LOCAL_BUFFER (MAP, map_list, n_args);
 
-  for (int j = 0; j < n_args && ! error_state; j++)
+  for (int j = 0; j < n_args; j++)
     {
       octave_quit ();
 
       map_list[j] = octave_value_extract<MAP> (args(j));
     }
 
-  if (! error_state)
-    result = octave_map::cat (dim, n_args, map_list);
+  result = octave_map::cat (dim, n_args, map_list);
 }
 
 static octave_map
 do_single_type_concat_map (const octave_value_list& args,
                            int dim)
 {
   octave_map result;
   if (all_scalar_1x1 (args)) // optimize all scalars case.
@@ -1896,29 +1856,24 @@ do_class_concat (const octave_value_list
 
   if (fcn.is_defined ())
     {
       // Have method for dominant type, so call it and let it handle
       // conversions.
 
       octave_value_list tmp2 = fcn.do_multi_index_op (1, ovl);
 
-      if (! error_state)
+      if (tmp2.length () > 0)
+        retval = tmp2(0);
+      else
         {
-          if (tmp2.length () > 0)
-            retval = tmp2(0);
-          else
-            {
-              error ("%s/%s method did not return a value",
-                     dtype.c_str (), cattype.c_str ());
-              goto done;
-            }
+          error ("%s/%s method did not return a value",
+                 dtype.c_str (), cattype.c_str ());
+          goto done;
         }
-      else
-        goto done;
     }
   else
     {
       // No method for dominant type, so attempt type conversions for
       // all elements that are not of the dominant type, then do the
       // default operation for octave_class values.
 
       octave_idx_type j = 0;
@@ -1928,22 +1883,17 @@ do_class_concat (const octave_value_list
         {
           octave_value elt = ovl(k);
 
           std::string t1_type = elt.class_name ();
 
           if (t1_type == dtype)
             tmp(j++) = elt;
           else if (elt.is_object () || ! elt.is_empty ())
-            {
-              tmp(j++) = attempt_type_conversion (elt, dtype);
-
-              if (error_state)
-                goto done;
-            }
+            tmp(j++) = attempt_type_conversion (elt, dtype);
         }
 
       tmp.resize (j);
 
       octave_map m = do_single_type_concat_map (tmp, dim);
 
       std::string cname = tmp(0).class_name ();
       std::list<std::string> parents = tmp(0).parent_class_name_list ();
@@ -2130,32 +2080,26 @@ do_cat (const octave_value_list& xargs, 
           //   tmp = octave_value_typeinfo::lookup_type
           //                                (args(1).type_name());
           // and then directly resize. However, for some types there might
           // be some additional setup needed, and so this should be avoided.
 
           octave_value tmp = args(0);
           tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
-          if (error_state)
-            return retval;
-
           int dv_len = dv.length ();
           Array<octave_idx_type> ra_idx (dim_vector (dv_len, 1), 0);
 
           for (int j = 0; j < n_args; j++)
             {
               // Can't fast return here to skip empty matrices as something
               // like cat (1,[],single ([])) must return an empty matrix of
               // the right type.
               tmp = do_cat_op (tmp, args(j), ra_idx);
 
-              if (error_state)
-                return retval;
-
               dim_vector dv_tmp = args(j).dims ();
 
               if (dim >= dv_len)
                 {
                   if (j > 1)
                     error ("%s: indexing error", fname.c_str ());
                   break;
                 }
@@ -2630,18 +2574,17 @@ do_permute (const octave_value_list& arg
 
       int n = vec.numel ();
 
       for (int i = 0; i < n; i++)
         vec(i)--;
 
       octave_value ret = args(0).permute (vec, inv);
 
-      if (! error_state)
-        retval = ret;
+      retval = ret;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (permute, args, ,
@@ -3047,113 +2990,107 @@ inputs, @qcode{\"extra\"} is the same as
         isdouble = true;
       else if (str == "extra")
         isextra = true;
       else
         error ("sum: unrecognized type argument '%s'", str.c_str ());
       nargin --;
     }
 
-  if (error_state)
-    return retval;
-
   if (nargin == 1 || nargin == 2)
     {
       octave_value arg = args(0);
 
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value () - 1;
           if (dim < 0)
             error ("sum: invalid dimension DIM = %d", dim + 1);
         }
 
-      if (! error_state)
+      switch (arg.builtin_type ())
         {
-          switch (arg.builtin_type ())
+        case btyp_double:
+          if (arg.is_sparse_type ())
+            {
+              if (isextra)
+                warning ("sum: 'extra' not yet implemented for sparse matrices");
+              retval = arg.sparse_matrix_value ().sum (dim);
+            }
+          else if (isextra)
+            retval = arg.array_value ().xsum (dim);
+          else
+            retval = arg.array_value ().sum (dim);
+          break;
+        case btyp_complex:
+          if (arg.is_sparse_type ())
             {
-            case btyp_double:
-              if (arg.is_sparse_type ())
-                {
-                  if (isextra)
-                    warning ("sum: 'extra' not yet implemented for sparse matrices");
-                  retval = arg.sparse_matrix_value ().sum (dim);
-                }
-              else if (isextra)
-                retval = arg.array_value ().xsum (dim);
-              else
-                retval = arg.array_value ().sum (dim);
-              break;
-            case btyp_complex:
-              if (arg.is_sparse_type ())
-                {
-                  if (isextra)
-                    warning ("sum: 'extra' not yet implemented for sparse matrices");
-                  retval = arg.sparse_complex_matrix_value ().sum (dim);
-                }
-              else if (isextra)
-                retval = arg.complex_array_value ().xsum (dim);
-              else
-                retval = arg.complex_array_value ().sum (dim);
-              break;
-            case btyp_float:
-              if (isdouble || isextra)
-                retval = arg.float_array_value ().dsum (dim);
-              else
-                retval = arg.float_array_value ().sum (dim);
-              break;
-            case btyp_float_complex:
-              if (isdouble || isextra)
-                retval = arg.float_complex_array_value ().dsum (dim);
-              else
-                retval = arg.float_complex_array_value ().sum (dim);
-              break;
+              if (isextra)
+                warning ("sum: 'extra' not yet implemented for sparse matrices");
+              retval = arg.sparse_complex_matrix_value ().sum (dim);
+            }
+          else if (isextra)
+            retval = arg.complex_array_value ().xsum (dim);
+          else
+            retval = arg.complex_array_value ().sum (dim);
+          break;
+        case btyp_float:
+          if (isdouble || isextra)
+            retval = arg.float_array_value ().dsum (dim);
+          else
+            retval = arg.float_array_value ().sum (dim);
+          break;
+        case btyp_float_complex:
+          if (isdouble || isextra)
+            retval = arg.float_complex_array_value ().dsum (dim);
+          else
+            retval = arg.float_complex_array_value ().sum (dim);
+          break;
 
 #define MAKE_INT_BRANCH(X) \
-            case btyp_ ## X: \
-              if (isnative) \
-                retval = arg.X ## _array_value ().sum (dim); \
-              else \
-                retval = arg.X ## _array_value ().dsum (dim); \
-              break;
-            MAKE_INT_BRANCH (int8);
-            MAKE_INT_BRANCH (int16);
-            MAKE_INT_BRANCH (int32);
-            MAKE_INT_BRANCH (int64);
-            MAKE_INT_BRANCH (uint8);
-            MAKE_INT_BRANCH (uint16);
-            MAKE_INT_BRANCH (uint32);
-            MAKE_INT_BRANCH (uint64);
+          case btyp_ ## X: \
+            if (isnative) \
+              retval = arg.X ## _array_value ().sum (dim); \
+            else \
+              retval = arg.X ## _array_value ().dsum (dim); \
+            break;
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
 
-            // GAGME: Accursed Matlab compatibility...
-            case btyp_char:
-              if (isextra)
-                retval = arg.array_value (true).xsum (dim);
+          // GAGME: Accursed Matlab compatibility...
+        case btyp_char:
+          if (isextra)
+            retval = arg.array_value (true).xsum (dim);
+          else
+            retval = arg.array_value (true).sum (dim);
+          break;
+        case btyp_bool:
+          if (arg.is_sparse_type ())
+            {
+              if (isnative)
+                retval = arg.sparse_bool_matrix_value ().any (dim);
               else
-                retval = arg.array_value (true).sum (dim);
-              break;
-            case btyp_bool:
-              if (arg.is_sparse_type ())
-                {
-                  if (isnative)
-                    retval = arg.sparse_bool_matrix_value ().any (dim);
-                  else
-                    retval = arg.sparse_bool_matrix_value ().sum (dim);
-                }
-              else if (isnative)
-                retval = arg.bool_array_value ().any (dim);
-              else
-                retval = arg.bool_array_value ().sum (dim);
-              break;
-
-            default:
-              gripe_wrong_type_arg ("sum", arg);
+                retval = arg.sparse_bool_matrix_value ().sum (dim);
             }
+          else if (isnative)
+            retval = arg.bool_array_value ().any (dim);
+          else
+            retval = arg.bool_array_value ().sum (dim);
+          break;
+
+        default:
+          gripe_wrong_type_arg ("sum", arg);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -3388,51 +3325,46 @@ complex ([1, 2], [3, 4])\n\
       if (arg.is_complex_type ())
         retval = arg;
       else
         {
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix val = arg.sparse_complex_matrix_value ();
 
-              if (! error_state)
-                retval = octave_value (new octave_sparse_complex_matrix (val));
+              retval = octave_value (new octave_sparse_complex_matrix (val));
             }
           else if (arg.is_single_type ())
             {
               if (arg.numel () == 1)
                 {
                   FloatComplex val = arg.float_complex_value ();
 
-                  if (! error_state)
-                    retval = octave_value (new octave_float_complex (val));
+                  retval = octave_value (new octave_float_complex (val));
                 }
               else
                 {
                   FloatComplexNDArray val = arg.float_complex_array_value ();
 
-                  if (! error_state)
-                    retval = octave_value (new octave_float_complex_matrix (val));
+                  retval = octave_value (new octave_float_complex_matrix (val));
                 }
             }
           else
             {
               if (arg.numel () == 1)
                 {
                   Complex val = arg.complex_value ();
 
-                  if (! error_state)
-                    retval = octave_value (new octave_complex (val));
+                  retval = octave_value (new octave_complex (val));
                 }
               else
                 {
                   ComplexNDArray val = arg.complex_array_value ();
 
-                  if (! error_state)
-                    retval = octave_value (new octave_complex_matrix (val));
+                  retval = octave_value (new octave_complex_matrix (val));
                 }
             }
 
           if (error_state)
             error ("complex: invalid conversion");
         }
     }
   else if (nargin == 2)
@@ -3440,218 +3372,194 @@ complex ([1, 2], [3, 4])\n\
       octave_value re = args(0);
       octave_value im = args(1);
 
       if (re.is_sparse_type () && im.is_sparse_type ())
         {
           const SparseMatrix re_val = re.sparse_matrix_value ();
           const SparseMatrix im_val = im.sparse_matrix_value ();
 
-          if (!error_state)
+          if (re.numel () == 1)
             {
-              if (re.numel () == 1)
+              SparseComplexMatrix result;
+              if (re_val.nnz () == 0)
+                result = Complex (0, 1) * SparseComplexMatrix (im_val);
+              else
                 {
-                  SparseComplexMatrix result;
-                  if (re_val.nnz () == 0)
-                    result = Complex (0, 1) * SparseComplexMatrix (im_val);
-                  else
+                  octave_idx_type nr = im_val.rows ();
+                  octave_idx_type nc = im_val.cols ();
+                  result = SparseComplexMatrix (nr, nc, re_val(0));
+
+                  for (octave_idx_type j = 0; j < nc; j++)
                     {
-                      octave_idx_type nr = im_val.rows ();
-                      octave_idx_type nc = im_val.cols ();
-                      result = SparseComplexMatrix (nr, nc, re_val(0));
-
-                      for (octave_idx_type j = 0; j < nc; j++)
-                        {
-                          octave_idx_type off = j * nr;
-                          for (octave_idx_type i = im_val.cidx (j);
-                               i < im_val.cidx (j + 1); i++)
-                            result.data (im_val.ridx (i) + off) +=
-                              Complex (0, im_val.data (i));
-                        }
+                      octave_idx_type off = j * nr;
+                      for (octave_idx_type i = im_val.cidx (j);
+                           i < im_val.cidx (j + 1); i++)
+                        result.data (im_val.ridx (i) + off) +=
+                          Complex (0, im_val.data (i));
                     }
-                  retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
-              else if (im.numel () == 1)
+              retval = octave_value (new octave_sparse_complex_matrix (result));
+            }
+          else if (im.numel () == 1)
+            {
+              SparseComplexMatrix result;
+              if (im_val.nnz () == 0)
+                result = SparseComplexMatrix (re_val);
+              else
+                {
+                  octave_idx_type nr = re_val.rows ();
+                  octave_idx_type nc = re_val.cols ();
+                  result = SparseComplexMatrix (nr, nc,
+                                                Complex (0, im_val(0)));
+
+                  for (octave_idx_type j = 0; j < nc; j++)
+                    {
+                      octave_idx_type off = j * nr;
+                      for (octave_idx_type i = re_val.cidx (j);
+                           i < re_val.cidx (j + 1); i++)
+                        result.data (re_val.ridx (i) + off) +=
+                          re_val.data (i);
+                    }
+                }
+              retval = octave_value (new octave_sparse_complex_matrix (result));
+            }
+          else
+            {
+              if (re_val.dims () == im_val.dims ())
                 {
                   SparseComplexMatrix result;
-                  if (im_val.nnz () == 0)
-                    result = SparseComplexMatrix (re_val);
-                  else
-                    {
-                      octave_idx_type nr = re_val.rows ();
-                      octave_idx_type nc = re_val.cols ();
-                      result = SparseComplexMatrix (nr, nc,
-                                                    Complex (0, im_val(0)));
-
-                      for (octave_idx_type j = 0; j < nc; j++)
-                        {
-                          octave_idx_type off = j * nr;
-                          for (octave_idx_type i = re_val.cidx (j);
-                               i < re_val.cidx (j + 1); i++)
-                            result.data (re_val.ridx (i) + off) +=
-                              re_val.data (i);
-                        }
-                    }
-                  retval = octave_value (new octave_sparse_complex_matrix (result));
+                  result = SparseComplexMatrix (re_val)
+                    + Complex (0, 1) * SparseComplexMatrix (im_val);
+                  retval = octave_value (
+                                         new octave_sparse_complex_matrix (result));
                 }
               else
-                {
-                  if (re_val.dims () == im_val.dims ())
-                    {
-                      SparseComplexMatrix result;
-                      result = SparseComplexMatrix (re_val)
-                               + Complex (0, 1) * SparseComplexMatrix (im_val);
-                      retval = octave_value (
-                                 new octave_sparse_complex_matrix (result));
-                    }
-                  else
-                    error ("complex: dimension mismatch");
-                }
+                error ("complex: dimension mismatch");
             }
         }
       else if (re.is_single_type () || im.is_single_type ())
         {
           if (re.numel () == 1)
             {
               float re_val = re.float_value ();
 
               if (im.numel () == 1)
                 {
                   float im_val = im.double_value ();
 
-                  if (! error_state)
-                    retval = octave_value (
-                               new octave_float_complex (FloatComplex (re_val,
-                                                                       im_val)));
+                  retval = octave_value (new octave_float_complex
+                                         (FloatComplex (re_val, im_val)));
                 }
               else
                 {
                   const FloatNDArray im_val = im.float_array_value ();
 
-                  if (! error_state)
-                    {
-                      FloatComplexNDArray result (im_val.dims (),
-                                                  FloatComplex ());
-
-                      for (octave_idx_type i = 0; i < im_val.numel (); i++)
-                        result.xelem (i) = FloatComplex (re_val, im_val(i));
-
-                      retval = octave_value (
-                                 new octave_float_complex_matrix (result));
-                    }
+                  FloatComplexNDArray result (im_val.dims (),
+                                              FloatComplex ());
+
+                  for (octave_idx_type i = 0; i < im_val.numel (); i++)
+                    result.xelem (i) = FloatComplex (re_val, im_val(i));
+
+                  retval = octave_value (new octave_float_complex_matrix
+                                         (result));
                 }
             }
           else
             {
               const FloatNDArray re_val = re.float_array_value ();
 
               if (im.numel () == 1)
                 {
                   float im_val = im.float_value ();
 
-                  if (! error_state)
+                  FloatComplexNDArray result (re_val.dims (),
+                                              FloatComplex ());
+
+                  for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                    result.xelem (i) = FloatComplex (re_val(i), im_val);
+
+                  retval = octave_value (new octave_float_complex_matrix
+                                         (result));
+                }
+              else
+                {
+                  const FloatNDArray im_val = im.float_array_value ();
+
+                  if (re_val.dims () == im_val.dims ())
                     {
                       FloatComplexNDArray result (re_val.dims (),
                                                   FloatComplex ());
 
                       for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                        result.xelem (i) = FloatComplex (re_val(i), im_val);
-
-                      retval = octave_value (
-                                 new octave_float_complex_matrix (result));
+                        result.xelem (i) = FloatComplex (re_val(i),
+                                                         im_val(i));
+
+                      retval = octave_value (new octave_float_complex_matrix
+                                             (result));
                     }
-                }
-              else
-                {
-                  const FloatNDArray im_val = im.float_array_value ();
-
-                  if (! error_state)
-                    {
-                      if (re_val.dims () == im_val.dims ())
-                        {
-                          FloatComplexNDArray result (re_val.dims (),
-                                                      FloatComplex ());
-
-                          for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                            result.xelem (i) = FloatComplex (re_val(i),
-                                                             im_val(i));
-
-                          retval = octave_value (
-                                     new octave_float_complex_matrix (result));
-                        }
-                      else
-                        error ("complex: dimension mismatch");
-                    }
+                  else
+                    error ("complex: dimension mismatch");
                 }
             }
         }
       else if (re.numel () == 1)
         {
           double re_val = re.double_value ();
 
           if (im.numel () == 1)
             {
               double im_val = im.double_value ();
 
-              if (! error_state)
-                retval = octave_value (new octave_complex (Complex (re_val,
-                                                                    im_val)));
+              retval = octave_value (new octave_complex
+                                     (Complex (re_val, im_val)));
             }
           else
             {
               const NDArray im_val = im.array_value ();
 
-              if (! error_state)
-                {
-                  ComplexNDArray result (im_val.dims (), Complex ());
-
-                  for (octave_idx_type i = 0; i < im_val.numel (); i++)
-                    result.xelem (i) = Complex (re_val, im_val(i));
-
-                  retval = octave_value (new octave_complex_matrix (result));
-                }
+              ComplexNDArray result (im_val.dims (), Complex ());
+
+              for (octave_idx_type i = 0; i < im_val.numel (); i++)
+                result.xelem (i) = Complex (re_val, im_val(i));
+
+              retval = octave_value (new octave_complex_matrix (result));
             }
         }
       else
         {
           const NDArray re_val = re.array_value ();
 
           if (im.numel () == 1)
             {
               double im_val = im.double_value ();
 
-              if (! error_state)
-                {
-                  ComplexNDArray result (re_val.dims (), Complex ());
-
-                  for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                    result.xelem (i) = Complex (re_val(i), im_val);
-
-                  retval = octave_value (new octave_complex_matrix (result));
-                }
+              ComplexNDArray result (re_val.dims (), Complex ());
+
+              for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                result.xelem (i) = Complex (re_val(i), im_val);
+
+              retval = octave_value (new octave_complex_matrix (result));
             }
           else
             {
               const NDArray im_val = im.array_value ();
 
-              if (! error_state)
+              if (re_val.dims () == im_val.dims ())
                 {
-                  if (re_val.dims () == im_val.dims ())
-                    {
-                      ComplexNDArray result (re_val.dims (), Complex ());
-
-                      for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                        result.xelem (i) = Complex (re_val(i), im_val(i));
-
-                      retval = octave_value (
-                                 new octave_complex_matrix (result));
-                    }
-                  else
-                    error ("complex: dimension mismatch");
+                  ComplexNDArray result (re_val.dims (), Complex ());
+
+                  for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                    result.xelem (i) = Complex (re_val(i), im_val(i));
+
+                  retval = octave_value (
+                                         new octave_complex_matrix (result));
                 }
+              else
+                error ("complex: dimension mismatch");
             }
         }
 
       if (error_state)
         error ("complex: invalid conversion");
     }
   else
     print_usage ();
@@ -4017,19 +3925,16 @@ fill_matrix (const octave_value_list& ar
   dim_vector dims (1, 1);
 
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
-
-      if (error_state)
-        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
@@ -4049,87 +3954,81 @@ fill_matrix (const octave_value_list& ar
                 error ("%s: expecting scalar integer arguments", fcn);
                 break;
               }
           }
       }
       break;
     }
 
-  if (! error_state)
+  dims.chop_trailing_singletons ();
+
+  check_dimensions (dims, fcn);
+
+  // FIXME: perhaps this should be made extensible by
+  // using the class name to lookup a function to call to create
+  // the new value.
+
+  // Note that automatic narrowing will handle conversion from
+  // NDArray to scalar.
+
+  switch (dt)
     {
-      dims.chop_trailing_singletons ();
-
-      check_dimensions (dims, fcn);
-
-      // FIXME: perhaps this should be made extensible by
-      // using the class name to lookup a function to call to create
-      // the new value.
-
-      // Note that automatic narrowing will handle conversion from
-      // NDArray to scalar.
-
-      if (! error_state)
-        {
-          switch (dt)
-            {
-            case oct_data_conv::dt_int8:
-              retval = int8NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_uint8:
-              retval = uint8NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_int16:
-              retval = int16NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_uint16:
-              retval = uint16NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_int32:
-              retval = int32NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_uint32:
-              retval = uint32NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_int64:
-              retval = int64NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_uint64:
-              retval = uint64NDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_single:
-              retval = FloatNDArray (dims, val);
-              break;
-
-            case oct_data_conv::dt_double:
-              {
-                if (val == 1 && dims.length () == 2 && dims(0) == 1)
-                  retval = Range (1.0, 0.0, dims(1));  // packed form
-                else
-                  retval = NDArray (dims, val);
-              }
-              break;
-
-            case oct_data_conv::dt_logical:
-              retval = boolNDArray (dims, val);
-              break;
-
-            default:
-              error ("%s: invalid class name", fcn);
-              break;
-            }
-        }
+    case oct_data_conv::dt_int8:
+      retval = int8NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_uint8:
+      retval = uint8NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_int16:
+      retval = int16NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_uint16:
+      retval = uint16NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_int32:
+      retval = int32NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_uint32:
+      retval = uint32NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_int64:
+      retval = int64NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_uint64:
+      retval = uint64NDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_single:
+      retval = FloatNDArray (dims, val);
+      break;
+
+    case oct_data_conv::dt_double:
+      {
+        if (val == 1 && dims.length () == 2 && dims(0) == 1)
+          retval = Range (1.0, 0.0, dims(1));  // packed form
+        else
+          retval = NDArray (dims, val);
+      }
+      break;
+
+    case oct_data_conv::dt_logical:
+      retval = boolNDArray (dims, val);
+      break;
+
+    default:
+      error ("%s: invalid class name", fcn);
+      break;
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, double val, float fval,
              const char *fcn)
@@ -4143,19 +4042,16 @@ fill_matrix (const octave_value_list& ar
   dim_vector dims (1, 1);
 
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
-
-      if (error_state)
-        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
@@ -4175,42 +4071,36 @@ fill_matrix (const octave_value_list& ar
                 error ("%s: expecting scalar integer arguments", fcn);
                 break;
               }
           }
       }
       break;
     }
 
-  if (! error_state)
+  dims.chop_trailing_singletons ();
+
+  check_dimensions (dims, fcn);
+
+  // Note that automatic narrowing will handle conversion from
+  // NDArray to scalar.
+
+  switch (dt)
     {
-      dims.chop_trailing_singletons ();
-
-      check_dimensions (dims, fcn);
-
-      // Note that automatic narrowing will handle conversion from
-      // NDArray to scalar.
-
-      if (! error_state)
-        {
-          switch (dt)
-            {
-            case oct_data_conv::dt_single:
-              retval = FloatNDArray (dims, fval);
-              break;
-
-            case oct_data_conv::dt_double:
-              retval = NDArray (dims, val);
-              break;
-
-            default:
-              error ("%s: invalid class name", fcn);
-              break;
-            }
-        }
+    case oct_data_conv::dt_single:
+      retval = FloatNDArray (dims, fval);
+      break;
+
+    case oct_data_conv::dt_double:
+      retval = NDArray (dims, val);
+      break;
+
+    default:
+      error ("%s: invalid class name", fcn);
+      break;
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, double val, const char *fcn)
 {
@@ -4223,19 +4113,16 @@ fill_matrix (const octave_value_list& ar
   dim_vector dims (1, 1);
 
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
-
-      if (error_state)
-        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
@@ -4255,42 +4142,36 @@ fill_matrix (const octave_value_list& ar
                 error ("%s: expecting scalar integer arguments", fcn);
                 break;
               }
           }
       }
       break;
     }
 
-  if (! error_state)
+  dims.chop_trailing_singletons ();
+
+  check_dimensions (dims, fcn);
+
+  // Note that automatic narrowing will handle conversion from
+  // NDArray to scalar.
+
+  switch (dt)
     {
-      dims.chop_trailing_singletons ();
-
-      check_dimensions (dims, fcn);
-
-      // Note that automatic narrowing will handle conversion from
-      // NDArray to scalar.
-
-      if (! error_state)
-        {
-          switch (dt)
-            {
-            case oct_data_conv::dt_single:
-              retval = FloatNDArray (dims, static_cast<float> (val));
-              break;
-
-            case oct_data_conv::dt_double:
-              retval = NDArray (dims, val);
-              break;
-
-            default:
-              error ("%s: invalid class name", fcn);
-              break;
-            }
-        }
+    case oct_data_conv::dt_single:
+      retval = FloatNDArray (dims, static_cast<float> (val));
+      break;
+
+    case oct_data_conv::dt_double:
+      retval = NDArray (dims, val);
+      break;
+
+    default:
+      error ("%s: invalid class name", fcn);
+      break;
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, const Complex& val,
              const char *fcn)
@@ -4304,19 +4185,16 @@ fill_matrix (const octave_value_list& ar
   dim_vector dims (1, 1);
 
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
-
-      if (error_state)
-        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
@@ -4336,43 +4214,37 @@ fill_matrix (const octave_value_list& ar
                 error ("%s: expecting scalar integer arguments", fcn);
                 break;
               }
           }
       }
       break;
     }
 
-  if (! error_state)
+  dims.chop_trailing_singletons ();
+
+  check_dimensions (dims, fcn);
+
+  // Note that automatic narrowing will handle conversion from
+  // NDArray to scalar.
+
+  switch (dt)
     {
-      dims.chop_trailing_singletons ();
-
-      check_dimensions (dims, fcn);
-
-      // Note that automatic narrowing will handle conversion from
-      // NDArray to scalar.
-
-      if (! error_state)
-        {
-          switch (dt)
-            {
-            case oct_data_conv::dt_single:
-              retval = FloatComplexNDArray (dims,
-                                            static_cast<FloatComplex> (val));
-              break;
-
-            case oct_data_conv::dt_double:
-              retval = ComplexNDArray (dims, val);
-              break;
-
-            default:
-              error ("%s: invalid class name", fcn);
-              break;
-            }
-        }
+    case oct_data_conv::dt_single:
+      retval = FloatComplexNDArray (dims,
+                                    static_cast<FloatComplex> (val));
+      break;
+
+    case oct_data_conv::dt_double:
+      retval = ComplexNDArray (dims, val);
+      break;
+
+    default:
+      error ("%s: invalid class name", fcn);
+      break;
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, bool val, const char *fcn)
 {
@@ -4404,28 +4276,24 @@ fill_matrix (const octave_value_list& ar
                 error ("%s: expecting scalar integer arguments", fcn);
                 break;
               }
           }
       }
       break;
     }
 
-  if (! error_state)
-    {
-      dims.chop_trailing_singletons ();
-
-      check_dimensions (dims, fcn);
-
-      // Note that automatic narrowing will handle conversion from
-      // NDArray to scalar.
-
-      if (! error_state)
-        retval = boolNDArray (dims, val);
-    }
+  dims.chop_trailing_singletons ();
+
+  check_dimensions (dims, fcn);
+
+  // Note that automatic narrowing will handle conversion from
+  // NDArray to scalar.
+
+  retval = boolNDArray (dims, val);
 
   return retval;
 }
 
 DEFUN (ones, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} ones (@var{n})\n\
 @deftypefnx {Built-in Function} {} ones (@var{m}, @var{n})\n\
@@ -4726,62 +4594,58 @@ type and may be either @qcode{\"double\"
   octave_value retval;
 
   if (nargin == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
         {
           Array<float> x = args(0).float_array_value ();
 
-          if (! error_state)
+          Array<float> epsval (x.dims ());
+
+          for (octave_idx_type i = 0; i < x.numel (); i++)
             {
-              Array<float> epsval (x.dims ());
-
-              for (octave_idx_type i = 0; i < x.numel (); i++)
+              float val = ::fabsf (x(i));
+              if (xisnan (val) || xisinf (val))
+                epsval(i) = lo_ieee_nan_value ();
+              else if (val < std::numeric_limits<float>::min ())
+                epsval(i) = powf (2.0, -149e0);
+              else
                 {
-                  float val = ::fabsf (x(i));
-                  if (xisnan (val) || xisinf (val))
-                    epsval(i) = lo_ieee_nan_value ();
-                  else if (val < std::numeric_limits<float>::min ())
-                    epsval(i) = powf (2.0, -149e0);
-                  else
-                    {
-                      int expon;
-                      gnulib::frexpf (val, &expon);
-                      epsval(i) = std::pow (2.0f,
-                                            static_cast<float> (expon - 24));
-                    }
+                  int expon;
+                  gnulib::frexpf (val, &expon);
+                  epsval(i) = std::pow (2.0f,
+                                        static_cast<float> (expon - 24));
                 }
-              retval = epsval;
             }
+
+          retval = epsval;
         }
       else
         {
           Array<double> x = args(0).array_value ();
 
-          if (! error_state)
+          Array<double> epsval (x.dims ());
+
+          for (octave_idx_type i = 0; i < x.numel (); i++)
             {
-              Array<double> epsval (x.dims ());
-
-              for (octave_idx_type i = 0; i < x.numel (); i++)
+              double val = ::fabs (x(i));
+              if (xisnan (val) || xisinf (val))
+                epsval(i) = lo_ieee_nan_value ();
+              else if (val < std::numeric_limits<double>::min ())
+                epsval(i) = pow (2.0, -1074e0);
+              else
                 {
-                  double val = ::fabs (x(i));
-                  if (xisnan (val) || xisinf (val))
-                    epsval(i) = lo_ieee_nan_value ();
-                  else if (val < std::numeric_limits<double>::min ())
-                    epsval(i) = pow (2.0, -1074e0);
-                  else
-                    {
-                      int expon;
-                      gnulib::frexp (val, &expon);
-                      epsval(i) = std::pow (2.0,
-                                            static_cast<double> (expon - 53));
-                    }
-                  retval = epsval;
+                  int expon;
+                  gnulib::frexp (val, &expon);
+                  epsval(i) = std::pow (2.0,
+                                        static_cast<double> (expon - 53));
                 }
+
+              retval = epsval;
             }
         }
     }
   else
     retval = fill_matrix (args, std::numeric_limits<double>::epsilon (),
                           std::numeric_limits<float>::epsilon (), "eps");
 
   return retval;
@@ -5106,68 +4970,65 @@ static octave_value
 identity_matrix (int nr, int nc, oct_data_conv::data_type dt)
 {
   octave_value retval;
 
   // FIXME: perhaps this should be made extensible by using
   // the class name to lookup a function to call to create the new
   // value.
 
-  if (! error_state)
+  switch (dt)
     {
-      switch (dt)
-        {
-        case oct_data_conv::dt_int8:
-          retval = identity_matrix<int8NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_uint8:
-          retval = identity_matrix<uint8NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_int16:
-          retval = identity_matrix<int16NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_uint16:
-          retval = identity_matrix<uint16NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_int32:
-          retval = identity_matrix<int32NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_uint32:
-          retval = identity_matrix<uint32NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_int64:
-          retval = identity_matrix<int64NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_uint64:
-          retval = identity_matrix<uint64NDArray> (nr, nc);
-          break;
-
-        case oct_data_conv::dt_single:
-          retval = FloatDiagMatrix (nr, nc, 1.0f);
-          break;
-
-        case oct_data_conv::dt_double:
-          retval = DiagMatrix (nr, nc, 1.0);
-          break;
-
-        case oct_data_conv::dt_logical:
-          retval = identity_matrix<boolNDArray> (nr, nc);
-          break;
-
-        default:
-          error ("eye: invalid class name");
-          break;
-        }
+    case oct_data_conv::dt_int8:
+      retval = identity_matrix<int8NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_uint8:
+      retval = identity_matrix<uint8NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_int16:
+      retval = identity_matrix<int16NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_uint16:
+      retval = identity_matrix<uint16NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_int32:
+      retval = identity_matrix<int32NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_uint32:
+      retval = identity_matrix<uint32NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_int64:
+      retval = identity_matrix<int64NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_uint64:
+      retval = identity_matrix<uint64NDArray> (nr, nc);
+      break;
+
+    case oct_data_conv::dt_single:
+      retval = FloatDiagMatrix (nr, nc, 1.0f);
+      break;
+
+    case oct_data_conv::dt_double:
+      retval = DiagMatrix (nr, nc, 1.0);
+      break;
+
+    case oct_data_conv::dt_logical:
+      retval = identity_matrix<boolNDArray> (nr, nc);
+      break;
+
+    default:
+      error ("eye: invalid class name");
+      break;
     }
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
@@ -5229,44 +5090,39 @@ definitions are for compatibility with @
   // Check for type information.
 
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
-
-      if (error_state)
-        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       retval = identity_matrix (1, 1, dt);
       break;
 
     case 1:
       {
         octave_idx_type nr, nc;
         get_dimensions (args(0), "eye", nr, nc);
 
-        if (! error_state)
-          retval = identity_matrix (nr, nc, dt);
+        retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     case 2:
       {
         octave_idx_type nr, nc;
         get_dimensions (args(0), args(1), "eye", nr, nc);
 
-        if (! error_state)
-          retval = identity_matrix (nr, nc, dt);
+        retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     default:
       print_usage ();
       break;
     }
 
@@ -5526,25 +5382,23 @@ Resizing an object to fewer dimensions i
         }
     }
   else if (nargin > 2)
     {
       dim_vector dv;
       dv.resize (nargin - 1);
       for (octave_idx_type i = 1; i < nargin; i++)
         dv(i-1) = static_cast<octave_idx_type> (args(i).scalar_value ());
-      if (!error_state)
-        {
-          retval = args(0);
-          retval = retval.resize (dv, true);
-        }
-
+
+      retval = args(0);
+      retval = retval.resize (dv, true);
     }
   else
     print_usage ();
+
   return retval;
 }
 
 // FIXME: should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} reshape (@var{A}, @var{m}, @var{n}, @dots{})\n\
@@ -5627,27 +5481,25 @@ the unspecified dimension.\n\
                   empty_dim = i;
                   new_dims(i-1) = 1;
                 }
             }
           else
             {
               new_dims(i-1) = args(i).idx_type_value ();
 
-              if (error_state)
-                break;
-              else if (new_dims(i-1) < 0)
+              if (new_dims(i-1) < 0)
                 {
                   error ("reshape: SIZE must be non-negative");
                   break;
                 }
             }
         }
 
-      if (! error_state && (empty_dim > 0))
+      if (empty_dim > 0)
         {
           octave_idx_type nel = new_dims.numel ();
 
           if (nel == 0)
             new_dims(empty_dim-1) = 0;
           else
             {
               octave_idx_type a_nel = args(0).numel ();
@@ -5662,18 +5514,17 @@ the unspecified dimension.\n\
         }
     }
   else
     {
       print_usage ();
       return retval;
     }
 
-  if (! error_state)
-    retval = args(0).reshape (new_dims);
+  retval = args(0).reshape (new_dims);
 
   return retval;
 }
 
 /*
 %!assert (size (reshape (ones (4, 4), 2, 8)), [2, 8])
 %!assert (size (reshape (ones (4, 4), 8, 2)), [8, 2])
 %!assert (size (reshape (ones (15, 4), 1, 60)), [1, 60])
@@ -5715,42 +5566,39 @@ with all elements along the last dimensi
   octave_value retval;
   int dim = 1;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage () ;
 
-  if (! error_state && nargin == 2)
+  if (nargin == 2)
     {
       dim = args(1).idx_type_value ();
 
       if (dim < 1)
         error ("vec: DIM must be greater than zero");
     }
 
-  if (! error_state)
+  octave_value colon (octave_value::magic_colon_t);
+  octave_value arg = args(0);
+  retval = arg.single_subsref ("(", colon);
+
+
+  if (dim > 1)
     {
-      octave_value colon (octave_value::magic_colon_t);
-      octave_value arg = args(0);
-      retval = arg.single_subsref ("(", colon);
-
-
-      if (! error_state && dim > 1)
-        {
-          dim_vector new_dims = dim_vector::alloc (dim);
-
-          for (int i = 0; i < dim-1; i++)
-            new_dims(i) = 1;
-
-          new_dims(dim-1) = retval.numel ();
-
-          retval = retval.reshape (new_dims);
-        }
+      dim_vector new_dims = dim_vector::alloc (dim);
+
+      for (int i = 0; i < dim-1; i++)
+        new_dims(i) = 1;
+
+      new_dims(dim-1) = retval.numel ();
+
+      retval = retval.reshape (new_dims);
     }
 
   return retval;
 }
 
 /*
 %!assert (vec ([1, 2; 3, 4]), [1; 3; 2; 4])
 %!assert (vec ([1, 3, 2, 4]), [1; 3; 2; 4])
@@ -5889,63 +5737,57 @@ compute the norms of each column and ret
               else if (str == "inf")
                 strflag = sfinf;
               else
                 error ("norm: unrecognized option: %s", str.c_str ());
               // we've handled the last parameter, so act as if it was removed
               nargin --;
             }
 
-          if (! error_state)
+          octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
+
+          if (p_arg.is_empty ())
+            p_arg = octave_value (2);
+          else if (p_arg.is_string ())
             {
-              octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
-
-              if (p_arg.is_empty ())
-                p_arg = octave_value (2);
-              else if (p_arg.is_string ())
+              std::string str = p_arg.string_value ();
+              if ((strflag == sfcols || strflag == sfrows))
                 {
-                  std::string str = p_arg.string_value ();
-                  if ((strflag == sfcols || strflag == sfrows))
-                    {
-                      if (str == "cols" || str == "columns" || str == "rows")
-                        error ("norm: invalid combination of options");
-                      else if (str == "fro")
-                        p_arg = octave_value (2);
-                      else if (str == "inf")
-                        p_arg = octave_Inf;
-                      else
-                        error ("norm: unrecognized option: %s", str.c_str ());
-                    }
+                  if (str == "cols" || str == "columns" || str == "rows")
+                    error ("norm: invalid combination of options");
+                  else if (str == "fro")
+                    p_arg = octave_value (2);
+                  else if (str == "inf")
+                    p_arg = octave_Inf;
                   else
-                    error ("norm: invalid combination of options");
+                    error ("norm: unrecognized option: %s", str.c_str ());
                 }
-              else if (! p_arg.is_scalar_type ())
-                gripe_wrong_type_arg ("norm", p_arg, true);
-
-              if (! error_state)
-                {
-                  switch (strflag)
-                    {
-                    case sfmatrix:
-                      retval(0) = xnorm (x_arg, p_arg);
-                      break;
-                    case sfcols:
-                      retval(0) = xcolnorms (x_arg, p_arg);
-                      break;
-                    case sfrows:
-                      retval(0) = xrownorms (x_arg, p_arg);
-                      break;
-                    case sffrob:
-                      retval(0) = xfrobnorm (x_arg);
-                      break;
-                    case sfinf:
-                      retval(0) = xnorm (x_arg, octave_Inf);
-                      break;
-                    }
-                }
+              else
+                error ("norm: invalid combination of options");
+            }
+          else if (! p_arg.is_scalar_type ())
+            gripe_wrong_type_arg ("norm", p_arg, true);
+
+          switch (strflag)
+            {
+            case sfmatrix:
+              retval(0) = xnorm (x_arg, p_arg);
+              break;
+            case sfcols:
+              retval(0) = xcolnorms (x_arg, p_arg);
+              break;
+            case sfrows:
+              retval(0) = xrownorms (x_arg, p_arg);
+              break;
+            case sffrob:
+              retval(0) = xfrobnorm (x_arg);
+              break;
+            case sfinf:
+              retval(0) = xnorm (x_arg, octave_Inf);
+              break;
             }
         }
       else
         error ("norm: only valid for 2-D objects");
     }
   else
     print_usage ();
 
@@ -6573,31 +6415,28 @@ DEFUN (toc, args, nargout,
 
               // FIXME: should we also check to see whether the start
               // time is after the beginning of this Octave session?
             }
           else
             error ("toc: invalid ID");
         }
 
-      if (! error_state)
+      if (start_time < 0)
+        error ("toc called before timer set");
+      else
         {
-          if (start_time < 0)
-            error ("toc called before timer set");
+          octave_time now;
+
+          double tmp = now.double_value () - start_time;
+
+          if (nargout > 0)
+            retval = tmp;
           else
-            {
-              octave_time now;
-
-              double tmp = now.double_value () - start_time;
-
-              if (nargout > 0)
-                retval = tmp;
-              else
-                octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
-            }
+            octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
         }
     }
 
   return retval;
 }
 
 /*
 %!shared id
@@ -7137,19 +6976,16 @@ This function does not support sparse ma
           std::string tmp = args(1).string_value ();
           if (tmp == "rows")
             by_rows = true;
           else
             smode = get_sort_mode_option (args(1), "second");
         }
       else
         error ("issorted: second argument must be a string");
-
-      if (error_state)
-        return retval;
     }
 
   octave_value arg = args(0);
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
         error ("issorted: sparse matrices not yet supported");
@@ -7243,19 +7079,16 @@ the ratio K/M is small; otherwise, it ma
         }
       if (dim < 0)
         dim = argx.dims ().first_non_singleton ();
 
       try
         {
           idx_vector n = args(1).index_vector ();
 
-          if (error_state)
-            return retval;
-
           switch (argx.builtin_type ())
             {
             case btyp_double:
               retval = argx.array_value ().nth_element (n, dim);
               break;
             case btyp_float:
               retval = argx.float_array_value ().nth_element (n, dim);
               break;
@@ -7332,53 +7165,51 @@ Undocumented internal function.\n\
     {
       try
         {
           idx_vector idx = args(0).index_vector ();
           octave_idx_type n = -1;
           if (nargin == 3)
             n = args(2).idx_type_value (true);
 
-          if (! error_state)
+          octave_value vals = args(1);
+
+          if (vals.is_range ())
+            {
+              Range r = vals.range_value ();
+              if (r.inc () == 0)
+                vals = r.base ();
+            }
+
+          if (vals.is_single_type ())
             {
-              octave_value vals = args(1);
-              if (vals.is_range ())
-                {
-                  Range r = vals.range_value ();
-                  if (r.inc () == 0)
-                    vals = r.base ();
-                }
-
-              if (vals.is_single_type ())
-                {
-                  if (vals.is_complex_type ())
-                    retval = do_accumarray_sum (idx,
-                                                vals.float_complex_array_value (),
-                                                n);
-                  else
-                    retval = do_accumarray_sum (idx, vals.float_array_value (), n);
-                }
-              else if (vals.is_numeric_type () || vals.is_bool_type ())
-                {
-                  if (vals.is_complex_type ())
-                    retval = do_accumarray_sum (idx,
-                                                vals.complex_array_value (),
-                                                n);
-                  else
-                    retval = do_accumarray_sum (idx, vals.array_value (), n);
-                }
+              if (vals.is_complex_type ())
+                retval = do_accumarray_sum (idx,
+                                            vals.float_complex_array_value (),
+                                            n);
               else
-                gripe_wrong_type_arg ("accumarray", vals);
+                retval = do_accumarray_sum (idx, vals.float_array_value (), n);
             }
-          }
-        catch (index_exception& e)
-          {
-            error ("__accumarray_sum__: invalid IDX %s. %s",
-                                        e.idx(), e.explain ());
-          }
+          else if (vals.is_numeric_type () || vals.is_bool_type ())
+            {
+              if (vals.is_complex_type ())
+                retval = do_accumarray_sum (idx,
+                                            vals.complex_array_value (),
+                                            n);
+              else
+                retval = do_accumarray_sum (idx, vals.array_value (), n);
+            }
+          else
+            gripe_wrong_type_arg ("accumarray", vals);
+        }
+      catch (index_exception& e)
+        {
+          error ("__accumarray_sum__: invalid IDX %s. %s",
+                 e.idx(), e.explain ());
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 template <class NDT>
@@ -7420,64 +7251,61 @@ do_accumarray_minmax_fun (const octave_v
     {
       try
         {
           idx_vector idx = args(0).index_vector ();
           octave_idx_type n = -1;
           if (nargin == 4)
             n = args(3).idx_type_value (true);
 
-          if (! error_state)
+          octave_value vals = args(1);
+          octave_value zero = args(2);
+
+          switch (vals.builtin_type ())
             {
-              octave_value vals = args(1);
-              octave_value zero = args(2);
-
-              switch (vals.builtin_type ())
-                {
-                case btyp_double:
-                  retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
-                                                 zero.double_value ());
-                  break;
-                case btyp_float:
-                  retval = do_accumarray_minmax (idx, vals.float_array_value (), n,
-                                                 ismin, zero.float_value ());
-                  break;
-                case btyp_complex:
-                  retval = do_accumarray_minmax (idx, vals.complex_array_value (),
-                                                 n, ismin, zero.complex_value ());
-                  break;
-                case btyp_float_complex:
-                  retval = do_accumarray_minmax (idx,
-                                                 vals.float_complex_array_value (),
-                                                 n, ismin,
-                                                 zero.float_complex_value ());
-                  break;
+            case btyp_double:
+              retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
+                                             zero.double_value ());
+              break;
+            case btyp_float:
+              retval = do_accumarray_minmax (idx, vals.float_array_value (), n,
+                                             ismin, zero.float_value ());
+              break;
+            case btyp_complex:
+              retval = do_accumarray_minmax (idx, vals.complex_array_value (),
+                                             n, ismin, zero.complex_value ());
+              break;
+            case btyp_float_complex:
+              retval = do_accumarray_minmax (idx,
+                                             vals.float_complex_array_value (),
+                                             n, ismin,
+                                             zero.float_complex_value ());
+              break;
 #define MAKE_INT_BRANCH(X) \
-                case btyp_ ## X: \
-                  retval = do_accumarray_minmax (idx, vals.X ## _array_value (), \
-                                                 n, ismin, \
-                                                 zero.X ## _scalar_value ()); \
-                  break;
-
-                MAKE_INT_BRANCH (int8);
-                MAKE_INT_BRANCH (int16);
-                MAKE_INT_BRANCH (int32);
-                MAKE_INT_BRANCH (int64);
-                MAKE_INT_BRANCH (uint8);
-                MAKE_INT_BRANCH (uint16);
-                MAKE_INT_BRANCH (uint32);
-                MAKE_INT_BRANCH (uint64);
+              case btyp_ ## X: \
+                retval = do_accumarray_minmax (idx, vals.X ## _array_value (), \
+                                               n, ismin, \
+                                               zero.X ## _scalar_value ()); \
+                break;
+
+              MAKE_INT_BRANCH (int8);
+              MAKE_INT_BRANCH (int16);
+              MAKE_INT_BRANCH (int32);
+              MAKE_INT_BRANCH (int64);
+              MAKE_INT_BRANCH (uint8);
+              MAKE_INT_BRANCH (uint16);
+              MAKE_INT_BRANCH (uint32);
+              MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
-                case btyp_bool:
-                  retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
-                                                 zero.bool_value ());
-                  break;
-                default:
-                  gripe_wrong_type_arg ("accumarray", vals);
-                }
+            case btyp_bool:
+              retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
+                                             zero.bool_value ());
+              break;
+            default:
+              gripe_wrong_type_arg ("accumarray", vals);
             }
         }
       catch (index_exception& e)
         {
           error ("do_accumarray_minmax_fun: invalid index %s. %s",
                                         e.idx (), e.explain ());
         }
 
@@ -7553,41 +7381,38 @@ Undocumented internal function.\n\
           int dim = -1;
           if (nargin >= 3)
             dim = args(2).int_value () - 1;
 
           octave_idx_type n = -1;
           if (nargin == 4)
             n = args(3).idx_type_value (true);
 
-          if (! error_state)
+          octave_value vals = args(1);
+
+          if (vals.is_single_type ())
             {
-              octave_value vals = args(1);
-
-              if (vals.is_single_type ())
-                {
-                  if (vals.is_complex_type ())
-                    retval = do_accumdim_sum (idx,
-                                              vals.float_complex_array_value (),
-                                              dim, n);
-                  else
-                    retval = do_accumdim_sum (idx, vals.float_array_value (),
-                                              dim, n);
-                }
-              else if (vals.is_numeric_type () || vals.is_bool_type ())
-                {
-                  if (vals.is_complex_type ())
-                    retval = do_accumdim_sum (idx, vals.complex_array_value (),
-                                              dim, n);
-                  else
-                    retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
-                }
+              if (vals.is_complex_type ())
+                retval = do_accumdim_sum (idx,
+                                          vals.float_complex_array_value (),
+                                          dim, n);
               else
-                gripe_wrong_type_arg ("accumdim", vals);
+                retval = do_accumdim_sum (idx, vals.float_array_value (),
+                                          dim, n);
             }
+          else if (vals.is_numeric_type () || vals.is_bool_type ())
+            {
+              if (vals.is_complex_type ())
+                retval = do_accumdim_sum (idx, vals.complex_array_value (),
+                                          dim, n);
+              else
+                retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
+            }
+          else
+            gripe_wrong_type_arg ("accumdim", vals);
         }
       catch (index_exception& e)
         {
           error ("__accumdim_sum__: invalid IDX %s. %s", e.idx(), e.explain ());
         }
     }
   else
     print_usage ();
@@ -7926,43 +7751,39 @@ an empty matrix is returned.\n\
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   else if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
     error ("diff: X must be numeric or logical");
 
-  if (! error_state)
+  int dim = -1;
+  octave_idx_type order = 1;
+  if (nargin > 1)
     {
-      int dim = -1;
-      octave_idx_type order = 1;
-      if (nargin > 1)
-        {
-          if (args(1).is_scalar_type ())
-            order = args(1).idx_type_value (true, false);
-          else if (! args(1).is_zero_by_zero ())
-            error ("order K must be a scalar or []");
-          if (! error_state && order < 0)
-            error ("order K must be non-negative");
-        }
-
-      if (nargin > 2)
-        {
-          dim = args(2).int_value (true, false);
-          if (! error_state && (dim < 1 || dim > args(0).ndims ()))
-            error ("DIM must be a valid dimension");
-          else
-            dim -= 1;
-        }
-
-      if (! error_state)
-        retval = do_diff (args(0), order, dim);
+      if (args(1).is_scalar_type ())
+        order = args(1).idx_type_value (true, false);
+      else if (! args(1).is_zero_by_zero ())
+        error ("order K must be a scalar or []");
+      if (order < 0)
+        error ("order K must be non-negative");
     }
 
+  if (nargin > 2)
+    {
+      dim = args(2).int_value (true, false);
+      if (dim < 1 || dim > args(0).ndims ())
+        error ("DIM must be a valid dimension");
+      else
+        dim -= 1;
+    }
+
+  retval = do_diff (args(0), order, dim);
+
   return retval;
 }
 
 /*
 %!assert (diff ([1, 2, 3, 4]), [1, 1, 1])
 %!assert (diff ([1, 3, 7, 19], 2), [2, 8])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1]), [4, 2; 3, 3; 1, -1; -6, -5])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1], 3), [-1, -5; -5, 0])
@@ -8036,19 +7857,18 @@ endfor\n\
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       octave_value x = args(0);
 
       const Matrix rm = args(1).matrix_value ();
-      if (error_state)
-        return retval;
-      else if (rm.rows () != 2 || rm.ndims () != 2)
+
+      if (rm.rows () != 2 || rm.ndims () != 2)
         {
           error ("repelems: R must be a matrix with two rows");
           return retval;
         }
       else
         {
           NoAlias< Array<octave_idx_type> > r (rm.dims ());
 
@@ -8120,31 +7940,30 @@ Encode a double matrix or array @var{x} 
     {
       if (! args(0).is_numeric_type ())
         error ("base64_encode: encoding is supported only for numeric arrays");
       else if (args(0).is_complex_type ()
                || args(0).is_sparse_type ())
         error ("base64_encode: encoding complex or sparse data is not supported");
       else if (args(0).is_integer_type ())
         {
-#define MAKE_INT_BRANCH(X)                                              \
-          if (args(0).is_ ## X ## _type ())                             \
-            {                                                           \
-              const X##NDArray in = args(0).  X## _array_value ();      \
-              size_t inlen =                                            \
-                in.numel () * sizeof (X## _t) / sizeof (char);          \
-              const char* inc =                                         \
-                reinterpret_cast<const char*> (in.data ());             \
-              char* out;                                                \
-              if (! error_state                                         \
-                  && octave_base64_encode (inc, inlen, &out))           \
-                {                                                       \
-                  retval(0) = octave_value (out);                       \
-                  ::free (out);                                         \
-                }                                                       \
+#define MAKE_INT_BRANCH(X) \
+          if (args(0).is_ ## X ## _type ()) \
+            { \
+              const X##NDArray in = args(0).  X## _array_value (); \
+              size_t inlen = \
+                in.numel () * sizeof (X## _t) / sizeof (char); \
+              const char* inc = \
+                reinterpret_cast<const char*> (in.data ()); \
+              char* out; \
+              if (octave_base64_encode (inc, inlen, &out)) \
+                { \
+                  retval(0) = octave_value (out); \
+                  ::free (out); \
+                } \
             }
 
           MAKE_INT_BRANCH(int8)
           else MAKE_INT_BRANCH(int16)
           else MAKE_INT_BRANCH(int32)
           else MAKE_INT_BRANCH(int64)
           else MAKE_INT_BRANCH(uint8)
           else MAKE_INT_BRANCH(uint16)
@@ -8158,33 +7977,31 @@ Encode a double matrix or array @var{x} 
       else if (args(0).is_single_type ())
         {
           const Array<float> in = args(0).float_array_value ();
           size_t inlen;
           inlen = in.numel () * sizeof (float) / sizeof (char);
           const char*  inc;
           inc = reinterpret_cast<const char*> (in.data ());
           char* out;
-          if (! error_state
-              && octave_base64_encode (inc, inlen, &out))
+          if (octave_base64_encode (inc, inlen, &out))
             {
               retval(0) = octave_value (out);
               ::free (out);
             }
         }
       else
         {
           const Array<double> in = args(0).array_value ();
           size_t inlen;
           inlen = in.numel () * sizeof (double) / sizeof (char);
           const char*  inc;
           inc = reinterpret_cast<const char*> (in.data ());
           char* out;
-          if (! error_state
-              && octave_base64_encode (inc, inlen, &out))
+          if (octave_base64_encode (inc, inlen, &out))
             {
               retval(0) = octave_value (out);
               ::free (out);
             }
         }
     }
   return retval;
 }
@@ -8226,35 +8043,29 @@ dimensions of the decoded array.\n\
     {
       dim_vector dims;
 
       if (nargin > 1)
         {
           const Array<octave_idx_type> size =
             args(1).octave_idx_type_vector_value ();
 
-          if (! error_state)
-            {
-              dims = dim_vector::alloc (size.numel ());
-              for (octave_idx_type i = 0; i < size.numel (); i++)
-                dims(i) = size(i);
-            }
+          dims = dim_vector::alloc (size.numel ());
+          for (octave_idx_type i = 0; i < size.numel (); i++)
+            dims(i) = size(i);
         }
 
       const std::string str = args(0).string_value ();
 
-      if (! error_state)
-        {
-          Array<double> res = octave_base64_decode (str);
-
-          if (nargin > 1)
-            res = res.reshape (dims);
-
-          retval = res;
-        }
+      Array<double> res = octave_base64_decode (str);
+
+      if (nargin > 1)
+        res = res.reshape (dims);
+
+      retval = res;
     }
 
   return retval;
 }
 
 /*
 %!assert (base64_decode (base64_encode (pi)), pi)
 %!
