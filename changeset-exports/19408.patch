# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1418871377 18000
#      Wed Dec 17 21:56:17 2014 -0500
# Node ID a0c7001cf1a83f320b00f59f27db24373fde352a
# Parent  86e69f51328d437830b5098dafab3b044261a5d5
consistent messages and IDs for singular matrix warnings

* lo-array-gripes.cc, lo-array-gripes.h (gripe_singular_matrix,
warning_id_nearly_singular_matrix, warning_id_singular_matrix):
New warning function and ID strings.
* inv.cc, sparse-xdiv.cc, xdiv.cc, CMatrix.cc, CSparse.cc, dMatrix.cc,
dSparse.cc, fCMatrix.cc, fMatrix.cc: Use gripe_singular_matrix instead
of individual calls to warning.
* warning_ids.m: Update list of IDs.
* NEWS note change.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -189,16 +189,19 @@ Summary of important user-visible change
 
       CC_VERSION  (now GCC_VERSION)
       CXX_VERSION (now GXX_VERSION)
 
     The internal class <Octave_map> was deprecated in Octave 3.8 and has
     been removed from Octave 4.2.  Replacement classes are
     <octave_map> (struct array) or <octave_scalar_map> for a single structure.
 
+ ** The warning ID Octave:singular-matrix-div has been replaced by
+    Octave:nearly-singular-matrix and Octave:singular-matrix.
+
 Summary of important user-visible changes for version 4.0:
 ---------------------------------------------------------
 
  ** For compatibility with Matlab, the "backtrace" warning option is now
     enabled by default.
 
  ** The preference
 
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -222,18 +222,17 @@ of a sparse matrix if possible.\n\
         }
       else
         {
           volatile double xrcond = rcond;
           rcond_plus_one_eq_one = xrcond + 1.0 == 1.0;
         }
 
       if (nargout < 2 && (info == -1 || rcond_plus_one_eq_one))
-        warning ("inverse: matrix singular to machine precision, rcond = %g",
-                 (isfloat ? frcond : rcond));
+        gripe_singular_matrix (isfloat ? frcond : rcond);
     }
 
   return retval;
 }
 
 /*
 %!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
 %!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -23,32 +23,33 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
 
 #include "Array-util.h"
+#include "lo-array-gripes.h"
 #include "oct-cmplx.h"
 #include "quit.h"
 #include "error.h"
 #include "lo-ieee.h"
 
 #include "dSparse.h"
 #include "dDiagMatrix.h"
 #include "CSparse.h"
 #include "CDiagMatrix.h"
 #include "oct-spparms.h"
 #include "sparse-xdiv.h"
 
 static void
 solve_singularity_warning (double rcond)
 {
-  warning ("matrix singular to machine precision, rcond = %g", rcond);
+  gripe_singular_matrix (rcond);
   warning ("attempting to find minimum norm solution");
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nr = a.rows ();
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -37,34 +37,35 @@ along with Octave; see the file COPYING.
 #include "fMatrix.h"
 #include "fCNDArray.h"
 #include "fNDArray.h"
 #include "oct-cmplx.h"
 #include "dDiagMatrix.h"
 #include "fDiagMatrix.h"
 #include "CDiagMatrix.h"
 #include "fCDiagMatrix.h"
+#include "lo-array-gripes.h"
 #include "quit.h"
 
 #include "error.h"
 #include "xdiv.h"
 
 static inline bool
 result_ok (octave_idx_type info)
 {
   assert (info != -1);
 
   return (info != -2);
 }
 
 static void
 solve_singularity_warning (double rcond)
 {
-  warning_with_id ("Octave:singular-matrix-div",
-                   "matrix singular to machine precision, rcond = %g", rcond);
+  gripe_singular_matrix (rcond);
+  warning ("attempting to find minimum norm solution");
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
   octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
@@ -400,17 +401,17 @@ xleftdiv (const ComplexMatrix& a, const 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 static void
 solve_singularity_warning (float rcond)
 {
-  warning ("matrix singular to machine precision, rcond = %g", rcond);
+  gripe_singular_matrix (rcond);
   warning ("attempting to find minimum norm solution");
 }
 
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatComplexMatrix);
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1981,19 +1981,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -2082,19 +2080,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -2188,19 +2184,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -2245,18 +2239,17 @@ ComplexMatrix::fsolve (MatrixType &matty
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -2274,19 +2267,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1799,36 +1799,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2087,36 +2083,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
@@ -2322,36 +2314,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2610,36 +2598,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2866,36 +2850,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3174,36 +3154,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3434,36 +3410,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3741,36 +3713,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3907,18 +3875,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
 
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4005,19 +3972,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx (0) = 0;
@@ -4209,18 +4174,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4305,18 +4269,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
@@ -4475,19 +4438,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4562,18 +4523,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4596,19 +4556,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4722,19 +4680,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4842,19 +4798,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4877,19 +4831,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5042,19 +4994,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5127,18 +5077,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5161,19 +5110,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5289,19 +5236,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5414,19 +5359,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5449,19 +5392,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5604,20 +5545,17 @@ SparseComplexMatrix::factorize (octave_i
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            (*current_liboctave_error_handler)
-              ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-               rcond);
-
+            gripe_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseComplexMatrix::solve numeric factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
@@ -5755,19 +5693,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6008,19 +5944,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6289,19 +6223,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6521,19 +6453,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6652,20 +6582,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               if (status == UMFPACK_WARNING_singular_matrix ||
                   rcond_plus_one == 1.0 || xisnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
-
+                    gripe_singular_matrix (rcond);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1620,19 +1620,17 @@ Matrix::utsolve (MatrixType &mattype, co
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -1720,19 +1718,17 @@ Matrix::ltsolve (MatrixType &mattype, co
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -1824,19 +1820,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -1879,18 +1873,17 @@ Matrix::fsolve (MatrixType &mattype, con
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1908,19 +1901,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1881,36 +1881,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2169,36 +2165,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
@@ -2406,36 +2398,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2696,36 +2684,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2956,36 +2940,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3263,36 +3243,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3524,36 +3500,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3833,36 +3805,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision, rcond = %g",
-                   rcond);
+                gripe_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3999,19 +3967,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4097,19 +4063,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
@@ -4301,18 +4265,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4396,18 +4359,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
@@ -4587,19 +4549,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4674,19 +4634,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4709,19 +4667,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4835,19 +4791,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4955,19 +4909,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4990,19 +4942,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5155,19 +5105,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5271,19 +5219,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5306,19 +5252,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5455,19 +5399,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5601,19 +5543,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
-
+                gripe_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5636,19 +5576,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcond);
+                        gripe_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5800,20 +5738,17 @@ SparseMatrix::factorize (octave_idx_type
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            (*current_liboctave_error_handler)
-              ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-               rcond);
-
+            gripe_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseMatrix::solve numeric factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
@@ -5953,19 +5888,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6179,19 +6112,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6431,19 +6362,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6675,19 +6604,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    (*current_liboctave_error_handler)
-                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-                       rcond);
+                    gripe_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1985,19 +1985,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -2086,19 +2084,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -2192,19 +2188,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -2249,18 +2243,17 @@ FloatComplexMatrix::fsolve (MatrixType &
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -2278,19 +2271,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1632,19 +1632,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -1733,19 +1731,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -1838,19 +1834,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -1893,18 +1887,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                (*current_liboctave_error_handler)
-                  ("matrix singular to machine precision");
+                gripe_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1922,19 +1915,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        (*current_liboctave_error_handler)
-                          ("matrix singular to machine precision, rcond = %g",
-                           rcon);
+                        gripe_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -29,16 +29,20 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 
 const char *error_id_nonconformant_args = "Octave:nonconformant-args";
 
 const char *error_id_index_out_of_bounds = "Octave:index-out-of-bounds";
 
 const char *error_id_invalid_index = "Octave:invalid-index";
 
+const char *warning_id_nearly_singular_matrix = "Octave:nearly-singular-matrix";
+
+const char *warning_id_singular_matrix = "Octave:singular-matrix";
+
 void
 gripe_nan_to_logical_conversion (void)
 {
   (*current_liboctave_error_handler)
     ("invalid conversion from NaN to logical");
 }
 
 void
@@ -161,8 +165,24 @@ gripe_invalid_assignment_size (void)
 
 void
 gripe_assignment_dimension_mismatch (void)
 {
   (*current_liboctave_error_handler)
     ("A(I,J,...) = X: dimensions mismatch");
 }
 
+void
+gripe_singular_matrix (double rcond)
+{
+  if (rcond == 0.0)
+    {
+      (*current_liboctave_warning_with_id_handler)
+        (warning_id_singular_matrix,
+         "matrix singular to machine precision");
+    }
+  else
+    {
+      (*current_liboctave_warning_with_id_handler)
+        (warning_id_nearly_singular_matrix,
+         "matrix singular to machine precision, rcond = %g", rcond);
+    }
+}
diff --git a/liboctave/util/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
--- a/liboctave/util/lo-array-gripes.h
+++ b/liboctave/util/lo-array-gripes.h
@@ -26,16 +26,20 @@ along with Octave; see the file COPYING.
 #include "dim-vector.h"
 
 extern OCTAVE_API const char *error_id_nonconformant_args;
 
 extern OCTAVE_API const char *error_id_index_out_of_bounds;
 
 extern OCTAVE_API const char *error_id_invalid_index;
 
+extern OCTAVE_API const char *warning_id_nearly_singular_matrix;
+
+extern OCTAVE_API const char *warning_id_singular_matrix;
+
 extern void OCTAVE_API
 gripe_nan_to_logical_conversion (void);
 
 extern void OCTAVE_API
 gripe_nan_to_character_conversion (void);
 
 extern void OCTAVE_API
 gripe_nonconformant (const char *op,
@@ -66,9 +70,12 @@ extern void OCTAVE_API
 gripe_invalid_resize (void);
 
 extern void OCTAVE_API
 gripe_invalid_assignment_size (void);
 
 extern void OCTAVE_API
 gripe_assignment_dimension_mismatch (void);
 
+extern void OCTAVE_API
+gripe_singular_matrix (double rcond = 0.0);
+
 #endif
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -294,18 +294,20 @@
 ## @item Octave:shadowed-function
 ## By default, the @code{Octave:shadowed-function} warning is enabled.
 ##
 ## @item Octave:single-quote-string
 ## Print warning if a single quote character is used to introduce a
 ## string constant.
 ## By default, the @code{Octave:single-quote-string} warning is disabled.
 ##
-## @item Octave:singular-matrix-div
-## By default, the @code{Octave:singular-matrix-div} warning is enabled.
+## @item Octave:nearly-singular-matrix
+## @itemx Octave:singular-matrix
+## By default, the @code{Octave:nearly-singular-matrix} and
+## @code{Octave:singular-matrix} warnings are enabled.
 ##
 ## @item Octave:sqrtm:SingularMatrix
 ## By default, the @code{Octave:sqrtm:SingularMatrix} warning is enabled.
 ##
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
 ## for implicit conversions of strings to their numeric ASCII equivalents.
 ## For example,
