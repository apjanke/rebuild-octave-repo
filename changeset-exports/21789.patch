# HG changeset patch
# User mmuetzel <markus.muetzel@gmx.de>
# Date 1464607033 -7200
#      Mon May 30 13:17:13 2016 +0200
# Node ID 6afdf40be5349deb391d97cf3c21e68e31028a44
# Parent  43f613cca3abb8246ebeb563ead0c9aaeb1b6a51
Implement graphics object "light" (patch #8943).

* graphics.in.h (light): New class.
* graphics.in.h (patch, surface): Make default value of facelighting
property compatible with Matlab.
* graphics.cc: Add function default_light_position. Export function
__go_light__.
* gl-render.h (opengl_renderer): Declare opengl_renderer::draw_light.
New private properties "view_vector", "num_lights" and "current_light".
Delete private property "has_light".
* gl-render.cc (opengl_renderer::draw_light): New function.
(opengl_renderer::draw): Handle drawing for light property.  Support for
up to GL_MAX_LIGHTS light sources (at least 8, limited by OpenGL).  Set
view_vector before drawing anything.  Set OpenGL ambient light color
before drawing other axes objects.  Respect setting of
"specularcolorreflectance" on patches and surfaces.  Set normals of
OpenGL faces in patch objects if possible.  Support lighting
modes "reverselit" and "unlit".  Only enable OpenGL lighting if normals
are defined for patch.
* scripts/plot/draw/light.m: New function.
* scripts/plot/draw/module.mk: Update.
* __unimplemented__.m: Remove "light" from list.
* __gnuplot_draw_axes__.m: Do not throw an error if light object is
present.
* doc/interpreter/genpropdoc.m, doc/interpreter/module.mk,
doc/interpreter/plot.txi: Document light and related properties.
* NEWS: Mention new feature.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -53,16 +53,19 @@ Summary of important user-visible change
     points is 0 or a negative number.  This change was made to be
     compatible with Matlab releases newer than 2011.  In addition,
     Octave no longer supports matrix inputs for A or B.
 
  ** The griddata function no longer plots the interpolated mesh if no
     output argument is requested, instead the vector or array of
     interpolated values is always returned for Matlab compatibility.
 
+ ** The new function "light" and corresponding graphics object provide
+    light and shadow effects for patch and surface objects.
+
  ** The surfnorm function now returns unnormalized (magnitude != 1)
     normal vectors for compatibility with Matlab.
 
  ** The quadl function now uses an absolute, rather than relative,
     tolerance for Matlab compatibility.  The default tolerance is 1e-6
     which may result in lower precision results than previous versions
     of Octave which used eps as the relative tolerance.  The quadl
     function has also been extended to return a second output with the
diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -25,17 +25,17 @@
 ## comments in getdoc bellow for instruction on how to document a graphics
 ## property.
 ##
 ## @seealso{}
 ## @end deftypefn
 
 function genpropdoc (objname, fname)
   objnames = {"root", "figure", "axes", "line", ...
-              "text", "image", "patch", "surface", ...
+              "text", "image", "patch", "surface", "light", ...
               "uimenu", "uicontextmenu", "uipanel", ...
               "uicontrol", "uitoolbar", "uipushtool", "uitoggletool"};
 
   ## Base properties
   base = getstructure ("base");
 
   ## Object properties
   if (any (strcmp (objname, objnames)))
@@ -1047,49 +1047,64 @@ of @code{[1 rows(image)]}.";
       case "alphadata"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
 
       case "alphadatamapping"
         s.doc = sprintf (doc_notimpl, "Transparency");
 
       case "ambientstrength"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Strength of the ambient light. Value between 0.0 and 1.0";
+        s.valid = "scalar";
 
       case "backfacelighting"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "@qcode{\"lit\"}: The normals are used as is for lighting. \
+@qcode{\"reverselit\"}: The normals are always oriented towards the point of view. \
+@qcode{\"unlit\"}: Faces with normals pointing away from the point of view are unlit.";
 
       case "cdata"
         s.valid = "matrix";
 
       case "cdatamapping"
       case "cdatasource"
       case "diffusestrength"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Strength of the diffuse reflex. Value between 0.0 (no \
+diffuse reflex) and 1.0 (full diffuse reflex).";
+        s.valid = "scalar";
 
       case "displayname"
         s.doc = "Text for the legend entry corresponding to this surface.";
 
       case "edgealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = "scalar";
 
       case "edgecolor"
       case "edgelighting"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "When set to a value other than @qcode{\"none\"}, the edges \
+of the object are drawn with light and shadow effects.  Supported values are \
+@qcode{\"none\"} (no lighting effects), @qcode{\"flat\"} (facetted look) and \
+@qcode{\"gouraud\"} (linear interpolation of the lighting effects between \
+the vertices). @qcode{\"phong\"} is deprecated and has the same effect as \
+@qcode{\"gouraud\"}.";
 
       case "erasemode"
         s.doc = doc_unused;
       case "facealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
 
       case "facecolor"
       case "facelighting"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "When set to a value other than @qcode{\"none\"}, the faces \
+of the object are drawn with light and shadow effects.  Supported values are \
+@qcode{\"none\"} (no lighting effects), @qcode{\"flat\"} (facetted look) and \
+@qcode{\"gouraud\"} (linear interpolation of the lighting effects between \
+the vertices). @qcode{\"phong\"} is deprecated and has the same effect as \
+@qcode{\"gouraud\"}.";
 
       case "interpreter"
       case "linestyle"
         s.doc = "@xref{Line Styles}.";
 
       case "linewidth"
         s.doc = "@xref{XREFlinelinewidth, , @w{line linewidth property}}.";
 
@@ -1107,23 +1122,29 @@ of @code{[1 rows(image)]}.";
       case "markersize"
         s.doc = "@xref{XREFlinemarkersize, , \
 @w{line markersize property}}.";
         s.valid = "scalar";
 
       case "meshstyle"
       case "normalmode"
       case "specularcolorreflectance"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Reflectance for specular color. Value between 0.0 (color \
+of underlying face) and 1.0 (color of light source).";
+        s.valid = "scalar";
 
       case "specularexponent"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Exponent for the specular reflex. The lower the value, \
+the more the reflex is spread out.";
+        s.valid = "scalar";
 
       case "specularstrength"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Strength of the specular reflex. Value between 0.0 (no \
+specular reflex) and 1.0 (full specular reflex).";
+        s.valid = "scalar";
 
       case "vertexnormals"
       case "xdata"
         s.valid = "matrix";
 
       case "xdatasource"
       case "ydata"
         s.valid = "matrix";
@@ -1142,50 +1163,58 @@ of @code{[1 rows(image)]}.";
       case "children"
         s.doc = doc_unused;
 
       ## Specific properties
       case "alphadatamapping"
         s.doc = sprintf (doc_notimpl, "Transparency");
 
       case "ambientstrength"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Strength of the ambient light. Value between 0.0 and 1.0";
         s.valid = "scalar";
 
       case "backfacelighting"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc =  "@qcode{\"lit\"}: The normals are used as is for lighting. \
+@qcode{\"reverselit\"}: The normals are always oriented towards the point of view. \
+@qcode{\"unlit\"}: Faces with normals pointing away from the point of view are unlit.";
 
       case "cdata"
         s.doc = "Data defining the patch object color.\n\
 Patch color can be defined for faces or for vertices.\n\
 \n\
 If @code{cdata} is a scalar index into the current colormap or a RGB triplet, \
 it defines the color of all faces.\n\
 \n\
 If @code{cdata} is an N-by-1 vector of indices or an N-by-3 (RGB) matrix, \
 it defines the color of each one of the N faces.\n\
 \n\
 If @code{cdata} is an N-by-M or an N-by-M-by-3 (RGB) matrix, \
 it defines the color at each vertex.";
         s.valid = valid_scalmat;
 
       case "diffusestrength"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Strength of the diffuse reflex. Value between 0.0 (no \
+diffuse reflex) and 1.0 (full diffuse reflex).";
         s.valid = "scalar";
 
       case "displayname"
         s.doc = "Text of the legend entry corresponding to this patch.";
 
       case "edgealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
 
       case "edgecolor"
       case "edgelighting"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "When set to a value other than @qcode{\"none\"}, the edges \
+of the object are drawn with light and shadow effects.  Supported values are \
+@qcode{\"none\"} (no lighting effects), @qcode{\"flat\"} (facetted look) and \
+@qcode{\"gouraud\"} (linear interpolation of the lighting effects between \
+the vertices). @qcode{\"phong\"} is deprecated and has the same effect as \
+@qcode{\"gouraud\"}.";
 
       case "erasemode"
         s.doc = doc_unused;
 
       case "facealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
 
@@ -1193,17 +1222,22 @@ it defines the color at each vertex.";
         ## Don't provide a default value, and mark colorspec with
         ## braces, this forces the default rgb triplet to be displayed
         s.valid = packopt ({markdef(valid_color), ...
                             "@qcode{\"none\"}", ...
                             "@qcode{\"flat\"}", ...
                             "@qcode{\"interp\"}"});
 
       case "facelighting"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "When set to a value other than @qcode{\"none\"}, the faces \
+of the object are drawn with light and shadow effects. Supported values are \
+@qcode{\"none\"} (no lighting effects), @qcode{\"flat\"} (facetted look) and \
+@qcode{\"gouraud\"} (linear interpolation of the lighting effects between \
+the vertices). @qcode{\"phong\"} is deprecated and has the same effect as \
+@qcode{\"gouraud\"}.";
 
       case "faces"
       case "xdata"
         s.valid = valid_vecmat;
 
       case "facevertexalphadata"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
@@ -1226,25 +1260,28 @@ it defines the color at each vertex.";
 @w{line markerfacecolor property}}.";
 
       case "markersize"
         s.doc = "@xref{XREFlinemarkersize, , @w{line markersize property}}.";
         s.valid = "scalar";
 
       case "normalmode"
       case "specularcolorreflectance"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Reflectance for specular color.  Value between 0.0 (color \
+of underlying face) and 1.0 (color of light source).";
         s.valid = "scalar";
 
       case "specularexponent"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Exponent for the specular reflex.  The lower the value, \
+the more the reflex is spread out.";
         s.valid = "scalar";
 
       case "specularstrength"
-        s.doc = sprintf (doc_notimpl, "Light");
+        s.doc = "Strength of the specular reflex.  Value between 0.0 (no \
+specular reflex) and 1.0 (full specular reflex).";
         s.valid = "scalar";
 
       case "vertexnormals"
       case "vertices"
         s.valid = valid_vecmat;
 
       case "xdata"
         s.valid = valid_vecmat;
@@ -1252,16 +1289,39 @@ it defines the color at each vertex.";
       case "ydata"
         s.valid = valid_vecmat;
 
       case "zdata"
         s.valid = valid_vecmat;
 
     endswitch
 
+  ## Light properties
+  elseif (strcmp (objname, "light"))
+    switch (field)
+      ## Overridden shared properties
+      case "children"
+        s.doc = doc_unused;
+
+      ## Specific properties
+      case "color"
+        s.doc = "Color of the light source.  @xref{Colors, ,colorspec}.";
+        s.valid = valid_color;
+
+      case "position"
+        s.doc = "Position of the light source.";
+
+      case "style"
+        s.doc = "This string defines whether the light emanates from a \
+light source at infinite distance (@qcode{\"infinite\"}) or from a local \
+point source (@qcode{\"local\"}). Only the default value @qcode{\"infinite\"} \
+is supported.";
+
+    endswitch
+
   ## uimenu properties
   elseif (strcmp (objname, "uimenu"))
     switch (field)
       ## Overridden shared properties
       case "buttondownfcn"
         s.doc = doc_unused;
 
       ## Specific properties
diff --git a/doc/interpreter/module.mk b/doc/interpreter/module.mk
--- a/doc/interpreter/module.mk
+++ b/doc/interpreter/module.mk
@@ -1,14 +1,15 @@
 if AMCOND_BUILD_DOCS
 
 GRAPH_PROP_TEXI_SRC = \
   doc/interpreter/plot-axesproperties.texi \
   doc/interpreter/plot-figureproperties.texi \
   doc/interpreter/plot-imageproperties.texi \
+  doc/interpreter/plot-lightproperties.texi \
   doc/interpreter/plot-lineproperties.texi \
   doc/interpreter/plot-patchproperties.texi \
   doc/interpreter/plot-rootproperties.texi \
   doc/interpreter/plot-surfaceproperties.texi \
   doc/interpreter/plot-textproperties.texi \
   doc/interpreter/plot-uimenuproperties.texi \
   doc/interpreter/plot-uicontextmenuproperties.texi \
   doc/interpreter/plot-uipanelproperties.texi \
@@ -29,16 +30,19 @@ doc/interpreter/plot-axesproperties.texi
 	$(AM_V_GEN)$(call gen-propdoc-texi,axes)
 
 doc/interpreter/plot-figureproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,figure)
 
 doc/interpreter/plot-imageproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,image)
 
+doc/interpreter/plot-lightproperties.texi: doc/interpreter/genpropdoc.m
+	$(AM_V_GEN)$(call gen-propdoc-texi,light)
+
 doc/interpreter/plot-lineproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,line)
 
 doc/interpreter/plot-patchproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,patch)
 
 doc/interpreter/plot-rootproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,root)
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1050,17 +1050,18 @@ at the Octave prompt should display a th
 @cindex introduction to graphics structures
 @anchor{XREFgraphics structures}
 
 The graphics functions use pointers, which are of class graphics_handle, in
 order to address the data structures which control visual display.  A
 graphics handle may point to any one of a number of different base object
 types and these objects are the graphics data structures themselves.  The
 primitive graphic object types are: @code{figure}, @code{axes}, @code{line},
-@code{text}, @code{patch}, @code{surface}, @code{text}, and @code{image}.
+@code{text}, @code{patch}, @code{surface}, @code{text}, @code{image}, and
+@code{light}.
 
 Each of these objects has a function by the same name, and, each of these
 functions returns a graphics handle pointing to an object of the corresponding
 type.  In addition there are several functions which operate on properties of
 the graphics objects and which also return handles: the functions @code{plot}
 and @code{plot3} return a handle pointing to an object of type line, the
 function @code{subplot} returns a handle pointing to an object of type axes,
 the function @code{fill} returns a handle pointing to an object of type patch,
@@ -1076,17 +1077,17 @@ The graphics objects are arranged in a h
 1. The root is at 0.  In other words, @code{get (0)} returns the properties of
 the root object.
 
 2. Below the root are @code{figure} objects.
 
 3. Below the @code{figure} objects are @code{axes} objects.
 
 4. Below the @code{axes} objects are @code{line}, @code{text}, @code{patch},
-@code{surface}, and @code{image} objects.
+@code{surface}, @code{image}, and @code{light} objects.
 
 Graphics handles may be distinguished from function handles
 (@pxref{Function Handles}) by means of the function @code{ishandle}.
 @code{ishandle} returns true if its argument is a handle of a graphics object.
 In addition, a figure or axes object may be tested using @code{isfigure} or
 @code{isaxes} respectively.  The test functions return true only if the
 argument is both a handle and of the correct type (figure or axes).
 
@@ -1180,17 +1181,17 @@ The handle index of the root figure is 0
 @cindex figure graphics object
 @cindex graphics object, figure
 A figure window.
 
 @item axes
 @cindex axes graphics object
 @cindex graphics object, axes
 A set of axes.  This object is a child of a figure object and may be a
-parent of line, text, image, patch, or surface objects.
+parent of line, text, image, patch, surface, or light objects.
 
 @item line
 @cindex line graphics object
 @cindex graphics object, line
 A line in two or three dimensions.
 
 @item text
 @cindex text graphics object
@@ -1206,45 +1207,52 @@ A bitmap image.
 @cindex patch graphics object
 @cindex graphics object, patch
 A filled polygon, currently limited to two dimensions.
 
 @item surface
 @cindex surface graphics object
 @cindex graphics object, surface
 A three-dimensional surface.
+
+@item light
+@cindex light graphics object
+@cindex graphics object, light
+A light object used for lighting effects on patches and surfaces.
 @c @end group
 @end table
 
 @subsubsection Creating Graphics Objects
 @cindex creating graphics objects
 
 You can create any graphics object primitive by calling the function of the
 same name as the object; In other words, @code{figure}, @code{axes},
-@code{line}, @code{text}, @code{image}, @code{patch}, and @code{surface}
-functions.  These fundamental graphic objects automatically become children
-of the current axes object as if @code{hold on} was in place.  Seperately, axes
-will automatically become children of the current figure object and figures
-will become children of the root object 0.
+@code{line}, @code{text}, @code{image}, @code{patch}, @code{surface}, and
+@code{light} functions.  These fundamental graphic objects automatically become
+children of the current axes object as if @code{hold on} was in place.
+Seperately, axes will automatically become children of the current figure
+object and figures will become children of the root object 0.
 
 If this auto-joining feature is not desired then it is important to call
 @code{newplot} first to prepare a new figure and axes for plotting.
 Alternatively, the easier way is to call a high-level graphics routine which
 will both create the plot and then populate it with low-level graphics objects.
 Instead of calling @code{line}, use @code{plot}.  Or use @code{surf} instead of
 @code{surface}.  Or use @code{fill} instead of @code{patch}.
 
 @DOCSTRING(axes)
 
 @DOCSTRING(line)
 
 @DOCSTRING(patch)
 
 @DOCSTRING(surface)
 
+@DOCSTRING(light)
+
 @subsubsection Handle Functions
 @cindex handle functions
 
 To determine whether a variable is a graphics object index, or an index
 to an axes or figure, use the functions @code{ishandle}, @code{isaxes}, and
 @code{isfigure}.
 
 @DOCSTRING(ishandle)
@@ -1373,16 +1381,17 @@ struct2hdl (fig_struct);
 * Root Figure Properties::
 * Figure Properties::
 * Axes Properties::
 * Line Properties::
 * Text Properties::
 * Image Properties::
 * Patch Properties::
 * Surface Properties::
+* Light Properties::
 * Uimenu Properties::
 * Uicontextmenu Properties::
 * Uipanel Properties::
 * Uicontrol Properties::
 * Uitoolbar Properties::
 * Uipushtool Properties::
 * Uitoggletool Properties::
 @end menu
@@ -1465,16 +1474,25 @@ The @code{patch} properties are:
 @node Surface Properties
 @subsubsection Surface Properties
 @cindex surface properties
 
 The @code{surface} properties are:
 
 @include plot-surfaceproperties.texi
 
+
+@node Light Properties
+@subsubsection Light Properties
+@cindex light properties
+
+The @code{light} properties are:
+
+@include plot-lightproperties.texi
+
 @node Uimenu Properties
 @subsubsection Uimenu Properties
 @cindex uimenu properties
 
 The @code{uimenu} properties are:
 
 @include plot-uimenuproperties.texi
 
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -364,29 +364,32 @@ public:
     Matrix coords;
     Matrix color;
     Matrix normal;
     double alpha;
     float ambient;
     float diffuse;
     float specular;
     float specular_exp;
+    float specular_color_refl;
 
     // reference counter
     octave_refcount<int> count;
 
     vertex_data_rep (void)
       : coords (), color (), normal (), alpha (),
-        ambient (), diffuse (), specular (), specular_exp (),count (1) { }
+        ambient (), diffuse (), specular (), specular_exp (),
+        specular_color_refl (), count (1) { }
 
     vertex_data_rep (const Matrix& c, const Matrix& col, const Matrix& n,
-                     double a, float as, float ds, float ss, float se)
+                     double a, float as, float ds, float ss, float se,
+                     float scr)
       : coords (c), color (col), normal (n), alpha (a),
         ambient (as), diffuse (ds), specular (ss), specular_exp (se),
-        count (1) { }
+        specular_color_refl (scr), count (1) { }
   };
 
 private:
   vertex_data_rep *rep;
 
   vertex_data_rep *nil_rep (void) const
   {
     static vertex_data_rep *nr = new vertex_data_rep ();
@@ -397,18 +400,19 @@ private:
 public:
   vertex_data (void) : rep (nil_rep ())
   { rep->count++; }
 
   vertex_data (const vertex_data& v) : rep (v.rep)
   { rep->count++; }
 
   vertex_data (const Matrix& c, const Matrix& col, const Matrix& n,
-               double a, float as, float ds, float ss, float se)
-    : rep (new vertex_data_rep (c, col, n, a, as, ds, ss, se))
+               double a, float as, float ds, float ss, float se,
+                     float scr)
+    : rep (new vertex_data_rep (c, col, n, a, as, ds, ss, se, scr))
   { }
 
   vertex_data (vertex_data_rep *new_rep)
     : rep (new_rep) { }
 
   ~vertex_data (void)
   {
     if (--rep->count == 0)
@@ -485,17 +489,23 @@ protected:
 
                 for (int k = 0; k < 3; k++)
                   buf[k] = (v->ambient * col(k));
                 glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
 
                 for (int k = 0; k < 3; k++)
                   buf[k] = (v->diffuse * col(k));
                 glMaterialfv (LIGHT_MODE, GL_DIFFUSE, buf);
-              }
+
+                for (int k = 0; k < 3; k++)
+                  buf[k] = v->specular * (v->specular_color_refl +
+                           (1 - v->specular_color_refl) * col(k));
+                glMaterialfv (LIGHT_MODE, GL_SPECULAR, buf);
+
+            }
           }
       }
 
     if (light_mode > 0 && (first || light_mode == GOURAUD))
       glNormal3dv (v->normal.data ());
 
     glVertex3dv (v->coords.data ());
 
@@ -540,17 +550,17 @@ protected:
           for (int iv = 0; iv < vmax; iv++)
             nn(in) += (w[iv] * v[iv]->normal (in));
       }
 
     for (int iv = 0; iv < vmax; iv++)
       aa += (w[iv] * v[iv]->alpha);
 
     vertex_data new_v (vv, cc, nn, aa, v[0]->ambient, v[0]->diffuse,
-                       v[0]->specular, v[0]->specular_exp);
+                       v[0]->specular, v[0]->specular_exp, v[0]->specular_color_refl);
     tmp_vdata.push_back (new_v);
 
     *out_data = new_v.get_rep ();
   }
 
 private:
 
   // No copying!
@@ -619,16 +629,18 @@ opengl_renderer::draw (const graphics_ob
   else if (go.isa ("axes"))
     draw_axes (dynamic_cast<const axes::properties&> (props));
   else if (go.isa ("line"))
     draw_line (dynamic_cast<const line::properties&> (props));
   else if (go.isa ("surface"))
     draw_surface (dynamic_cast<const surface::properties&> (props));
   else if (go.isa ("patch"))
     draw_patch (dynamic_cast<const patch::properties&> (props));
+  else if (go.isa ("light"))
+    draw_light (dynamic_cast<const light::properties&> (props));
   else if (go.isa ("hggroup"))
     draw_hggroup (dynamic_cast<const hggroup::properties&> (props));
   else if (go.isa ("text"))
     draw_text (dynamic_cast<const text::properties&> (props));
   else if (go.isa ("image"))
     draw_image (dynamic_cast<const image::properties&> (props));
   else if (go.isa ("uimenu") || go.isa ("uicontrol")
            || go.isa ("uicontextmenu") || go.isa ("uitoolbar")
@@ -1593,33 +1605,53 @@ opengl_renderer::draw_axes_children (con
   std::list<graphics_object> obj_list;
   std::list<graphics_object>::iterator it;
 
   // 1st pass: draw light objects
 
   // Start with the last element of the array of child objects to
   // display them in the order they were added to the array.
 
-  has_light = false;
+  num_lights = 0;
+
   for (octave_idx_type i = children.numel () - 1; i >= 0; i--)
     {
       graphics_object go = gh_manager::get_object (children(i));
 
       if (go.get_properties ().is_visible ())
         {
           if (go.isa ("light"))
             {
-              draw (go);
-              has_light = true;
+              if (num_lights < GL_MAX_LIGHTS)
+                {
+                  current_light = GL_LIGHT0 + num_lights;
+                  set_clipping (go.get_properties ().is_clipping ());
+                  draw (go);
+                  num_lights++;
+                }
             }
           else
             obj_list.push_back (go);
         }
     }
 
+  // disable other OpenGL lights
+  for (int i = num_lights; i < GL_MAX_LIGHTS; i++)
+    glDisable (GL_LIGHT0 + i);
+
+  // save camera position and set ambient light color before drawing
+  // other objects
+  view_vector = props.get_cameraposition ().matrix_value ();
+
+  float cb[4] = { 1.0, 1.0, 1.0, 1.0 };
+  ColumnVector ambient_color = props.get_ambientlightcolor_rgb ();
+  for (int i = 0; i < 3; i++)
+    cb[i] = ambient_color(i);
+  glLightfv (GL_LIGHT0, GL_AMBIENT, cb);
+
   // 2nd pass: draw other objects (with units set to "data")
 
   it = obj_list.begin ();
   while (it != obj_list.end ())
     {
       graphics_object go = (*it);
 
       // FIXME: check whether object has "units" property and it is set
@@ -1897,25 +1929,28 @@ opengl_renderer::draw_surface (const sur
                  (props.facealpha_is ("flat") ? 1 : 2));
   int ec_mode = (props.edgecolor_is_rgb () ? 0 :
                  (props.edgecolor_is ("flat") ? 1 :
                   (props.edgecolor_is ("interp") ? 2 : -1)));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
                  (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
                  (props.edgealpha_is ("flat") ? 1 : 2));
+  int bfl_mode = (props.backfacelighting_is ("lit") ? 0 :
+                  (props.backfacelighting_is ("reverselit") ? 1 : 2));
 
   Matrix fcolor = (fc_mode == TEXTURE ? Matrix (1, 3, 1.0)
                                       : props.get_facecolor_rgb ());
   Matrix ecolor = props.get_edgecolor_rgb ();
 
   float as = props.get_ambientstrength ();
   float ds = props.get_diffusestrength ();
   float ss = props.get_specularstrength ();
-  float se = props.get_specularexponent ();
+  float se = props.get_specularexponent () * 5; // to fit Matlab
+  float scr = props.get_specularcolorreflectance ();
   float cb[4] = { 0.0, 0.0, 0.0, 1.0 };
   double d = 1.0;
 
   opengl_texture tex;
 
   int i1, i2, j1, j2;
   bool x_mat = (x.rows () == z.rows ());
   bool y_mat = (y.columns () == z.columns ());
@@ -1943,22 +1978,17 @@ opengl_renderer::draw_surface (const sur
 
   if (fa_mode > 0 || ea_mode > 0)
     {
       // FIXME: implement alphadata conversion
       //a = props.get_alpha_data ();
     }
 
   if (fl_mode > 0 || el_mode > 0)
-    {
-      float buf[4] = { ss, ss, ss, 1 };
-
-      glMaterialfv (LIGHT_MODE, GL_SPECULAR, buf);
-      glMaterialf (LIGHT_MODE, GL_SHININESS, se);
-    }
+    glMaterialf (LIGHT_MODE, GL_SHININESS, se);
 
   // FIXME: good candidate for caching,
   //        transferring pixel data to OpenGL is time consuming.
   if (fc_mode == TEXTURE)
     tex = opengl_texture::create (props.get_color_data ());
 
   if (! props.facecolor_is ("none"))
     {
@@ -1971,20 +2001,24 @@ opengl_renderer::draw_surface (const sur
                 {
                   for (int i = 0; i < 3; i++)
                     cb[i] = as * fcolor(i);
                   glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                   for (int i = 0; i < 3; i++)
                     cb[i] = ds * fcolor(i);
                   glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ss * (scr + (1-scr) * fcolor(i));
+                  glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                 }
             }
 
-          if ((fl_mode > 0) && has_light)
+          if ((fl_mode > 0) && (num_lights > 0))
             glEnable (GL_LIGHTING);
           glShadeModel ((fc_mode == INTERP || fl_mode == GOURAUD) ? GL_SMOOTH
                                                                   : GL_FLAT);
           set_polygon_offset (true, 1);
           if (fc_mode == TEXTURE)
             glEnable (GL_TEXTURE_2D);
 
           for (int i = 1; i < zc; i++)
@@ -2039,26 +2073,36 @@ opengl_renderer::draw_surface (const sur
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j-1, i-1, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ss * (scr + (1-scr) * c(j-1, i-1, k));
+                          glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                         }
                     }
                   if (fl_mode > 0)
                     {
                       d = sqrt (n(j-1,i-1,0) * n(j-1,i-1,0)
                                 + n(j-1,i-1,1) * n(j-1,i-1,1)
                                 + n(j-1,i-1,2) * n(j-1,i-1,2));
-                      glNormal3d (n(j-1,i-1,0)/d,
-                                  n(j-1,i-1,1)/d,
-                                  n(j-1,i-1,2)/d);
+                      double dir = 1.0;
+                      if (bfl_mode > 0)
+                        dir = (n(j-1,i-1,0) * view_vector(0) + 
+                               n(j-1,i-1,1) * view_vector(1) + 
+                               n(j-1,i-1,2) * view_vector(2) < 0) ? 
+                                ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                      glNormal3d (dir * n(j-1,i-1,0)/d,
+                                  dir * n(j-1,i-1,1)/d,
+                                  dir * n(j-1,i-1,2)/d);
                     }
                   glVertex3d (x(j1,i-1), y(j-1,i1), z(j-1,i-1));
 
                   // Vertex 2
                   if (fc_mode == TEXTURE)
                     tex.tex_coord (double (i) / (zc-1), double (j-1) / (zr-1));
                   else if (fc_mode == INTERP)
                     {
@@ -2070,25 +2114,37 @@ opengl_renderer::draw_surface (const sur
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j-1, i, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ss * (scr + (1-scr) * c(j-1, i, k));
+                          glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                         }
                     }
 
                   if (fl_mode == GOURAUD)
                     {
                       d = sqrt (n(j-1,i,0) * n(j-1,i,0)
                                 + n(j-1,i,1) * n(j-1,i,1)
                                 + n(j-1,i,2) * n(j-1,i,2));
-                      glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
+                      double dir = 1.0;
+                      if (bfl_mode > 0)
+                        dir = (n(j-1,i,0) * view_vector(0) + 
+                               n(j-1,i,1) * view_vector(1) + 
+                               n(j-1,i,2) * view_vector(2) < 0) ? 
+                                ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                      glNormal3d (dir * n(j-1,i,0)/d,
+                                  dir * n(j-1,i,1)/d,
+                                  dir * n(j-1,i,2)/d);
                     }
 
                   glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
 
                   // Vertex 3
                   if (fc_mode == TEXTURE)
                     tex.tex_coord (double (i) / (zc-1), double (j) / (zr-1));
                   else if (fc_mode == INTERP)
@@ -2101,24 +2157,36 @@ opengl_renderer::draw_surface (const sur
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j, i, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ss * (scr + (1-scr) * c(j, i, k));
+                          glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                         }
                     }
                   if (fl_mode == GOURAUD)
                     {
                       d = sqrt (n(j,i,0) * n(j,i,0)
                                 + n(j,i,1) * n(j,i,1)
                                 + n(j,i,2) * n(j,i,2));
-                      glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
+                      double dir = 1.0;
+                      if (bfl_mode > 0)
+                        dir = (n(j,i,0) * view_vector(0) + 
+                               n(j,i,1) * view_vector(1) + 
+                               n(j,i,2) * view_vector(2) < 0) ? 
+                                ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                      glNormal3d (dir * n(j,i,0)/d,
+                                  dir * n(j,i,1)/d,
+                                  dir * n(j,i,2)/d);
                     }
                   glVertex3d (x(j2,i), y(j,i2), z(j,i));
 
                   // Vertex 4
                   if (fc_mode == TEXTURE)
                     tex.tex_coord (double (i-1) / (zc-1), double (j) / (zr-1));
                   else if (fc_mode == INTERP)
                     {
@@ -2130,36 +2198,48 @@ opengl_renderer::draw_surface (const sur
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j, i-1, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ss * (scr + (1-scr) * c(j, i-1, k));
+                          glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                         }
                     }
                   if (fl_mode == GOURAUD)
                     {
                       d = sqrt (n(j,i-1,0) * n(j,i-1,0)
                                 + n(j,i-1,1) * n(j,i-1,1)
                                 + n(j,i-1,2) * n(j,i-1,2));
-                      glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
+                      double dir = 1.0;
+                      if (bfl_mode > 0)
+                        dir = (n(j,i-1,0) * view_vector(0) + 
+                               n(j,i-1,1) * view_vector(1) + 
+                               n(j,i-1,2) * view_vector(2) < 0) ? 
+                                ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                      glNormal3d (dir * n(j,i-1,0)/d,
+                                  dir * n(j,i-1,1)/d,
+                                  dir * n(j,i-1,2)/d);
                     }
                   glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
 
                   glEnd ();
                 }
             }
 
           set_polygon_offset (false);
           if (fc_mode == TEXTURE)
             glDisable (GL_TEXTURE_2D);
 
-          if ((fl_mode > 0) && has_light)
+          if ((fl_mode > 0) && (num_lights > 0))
             glDisable (GL_LIGHTING);
         }
       else
         {
           // FIXME: implement transparency
         }
     }
 
@@ -2174,20 +2254,24 @@ opengl_renderer::draw_surface (const sur
                 {
                   for (int i = 0; i < 3; i++)
                     cb[i] = as * ecolor(i);
                   glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                   for (int i = 0; i < 3; i++)
                     cb[i] = ds * ecolor(i);
                   glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ss * (scr + (1-scr) * ecolor(i));
+                  glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                 }
             }
 
-          if ((el_mode > 0) && has_light)
+          if ((el_mode > 0) && (num_lights > 0))
             glEnable (GL_LIGHTING);
           glShadeModel ((ec_mode == INTERP || el_mode == GOURAUD) ? GL_SMOOTH
                                                                   : GL_FLAT);
 
           set_linestyle (props.get_linestyle (), false);
           set_linewidth (props.get_linewidth ());
 
           // Mesh along Y-axis
@@ -2239,24 +2323,36 @@ opengl_renderer::draw_surface (const sur
                             {
                               for (int k = 0; k < 3; k++)
                                 cb[k] *= as;
                               glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                               for (int k = 0; k < 3; k++)
                                 cb[k] = ds * c(j-1, i, k);
                               glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ss * (scr + (1-scr) * c(j-1, i, k));
+                              glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                             }
                         }
                       if (el_mode > 0)
                         {
                           d = sqrt (n(j-1,i,0) * n(j-1,i,0)
                                     + n(j-1,i,1) * n(j-1,i,1)
                                     + n(j-1,i,2) * n(j-1,i,2));
-                          glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
+                          double dir = 1.0;
+                          if (bfl_mode > 0)
+                            dir = (n(j-1,i,0) * view_vector(0) + 
+                                   n(j-1,i,1) * view_vector(1) + 
+                                   n(j-1,i,2) * view_vector(2) < 0) ? 
+                                    ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                          glNormal3d (dir * n(j-1,i,0)/d,
+                                      dir * n(j-1,i,1)/d,
+                                      dir * n(j-1,i,2)/d);
                         }
                       glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
 
                       // Vertex 2
                       if (ec_mode == INTERP)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] = c(j, i, k);
@@ -2266,24 +2362,36 @@ opengl_renderer::draw_surface (const sur
                             {
                               for (int k = 0; k < 3; k++)
                                 cb[k] *= as;
                               glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                               for (int k = 0; k < 3; k++)
                                 cb[k] = ds * c(j, i, k);
                               glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ss * (scr + (1-scr) * c(j, i, k));
+                              glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                             }
                         }
                       if (el_mode == GOURAUD)
                         {
                           d = sqrt (n(j,i,0) * n(j,i,0)
                                     + n(j,i,1) * n(j,i,1)
                                     + n(j,i,2) * n(j,i,2));
-                          glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
+                          double dir = 1.0;
+                          if (bfl_mode > 0)
+                            dir = (n(j,i,0) * view_vector(0) + 
+                                   n(j,i,1) * view_vector(1) + 
+                                   n(j,i,2) * view_vector(2) < 0) ? 
+                                    ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                          glNormal3d (dir * n(j,i,0)/d,
+                                      dir * n(j,i,1)/d,
+                                      dir * n(j,i,2)/d);
                         }
                       glVertex3d (x(j2,i), y(j,i2), z(j,i));
 
                       glEnd ();
                     }
                 }
             }
 
@@ -2336,24 +2444,36 @@ opengl_renderer::draw_surface (const sur
                             {
                               for (int k = 0; k < 3; k++)
                                 cb[k] *= as;
                               glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                               for (int k = 0; k < 3; k++)
                                 cb[k] = ds * c(j, i-1, k);
                               glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ss * (scr + (1-scr) * c(j, i-1, k));
+                              glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                             }
                         }
                       if (el_mode > 0)
                         {
                           d = sqrt (n(j,i-1,0) * n(j,i-1,0)
                                     + n(j,i-1,1) * n(j,i-1,1)
                                     + n(j,i-1,2) * n(j,i-1,2));
-                          glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
+                          double dir = 1.0;
+                          if (bfl_mode > 0)
+                            dir = (n(j,i-1,0) * view_vector(0) + 
+                                   n(j,i-1,1) * view_vector(1) + 
+                                   n(j,i-1,2) * view_vector(2) < 0) ?
+                                    ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                          glNormal3d (dir * n(j,i-1,0)/d,
+                                      dir * n(j,i-1,1)/d,
+                                      dir * n(j,i-1,2)/d);
                         }
                       glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
 
                       // Vertex 2
                       if (ec_mode == INTERP)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] = c(j, i, k);
@@ -2363,36 +2483,48 @@ opengl_renderer::draw_surface (const sur
                             {
                               for (int k = 0; k < 3; k++)
                                 cb[k] *= as;
                               glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                               for (int k = 0; k < 3; k++)
                                 cb[k] = ds * c(j, i, k);
                               glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ss * (scr + (1-scr) * c(j, i, k));
+                              glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                             }
                         }
                       if (el_mode == GOURAUD)
                         {
                           d = sqrt (n(j,i,0) * n(j,i,0)
                                     + n(j,i,1) * n(j,i,1)
                                     + n(j,i,2) * n(j,i,2));
-                          glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
+                          double dir = 1.0;
+                          if (bfl_mode > 0)
+                            dir = (n(j,i,0) * view_vector(0) + 
+                                   n(j,i,1) * view_vector(1) + 
+                                   n(j,i,2) * view_vector(2) < 0) ? 
+                                    ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+                          glNormal3d (dir * n(j,i,0)/d,
+                                      dir * n(j,i,1)/d,
+                                      dir * n(j,i,2)/d);
                         }
                       glVertex3d (x(j2,i), y(j,i2), z(j,i));
 
                       glEnd ();
                     }
                 }
             }
 
           set_linestyle ("-");
           set_linewidth (0.5);
 
-          if ((el_mode > 0) && has_light)
+          if ((el_mode > 0) && (num_lights > 0))
             glDisable (GL_LIGHTING);
         }
       else
         {
           // FIXME: implement transparency
         }
     }
 
@@ -2499,39 +2631,44 @@ opengl_renderer::draw_patch (const patch
 
   int nv = v.rows ();
   int nf = f.rows ();
   int fcmax = f.columns ();
 
   bool has_z = (v.columns () > 2);
   bool has_facecolor = false;
   bool has_facealpha = false;
+  // FIXME: remove when patch object has normal computation (patch #8951)
+  bool has_normals = (n.rows () == nv);
 
   int fc_mode = ((props.facecolor_is ("none")
                   || props.facecolor_is_rgb ()) ? 0 :
                  (props.facecolor_is ("flat") ? 1 : 2));
   int fl_mode = (props.facelighting_is ("none") ? 0 :
                  (props.facelighting_is ("flat") ? 1 : 2));
   int fa_mode = (props.facealpha_is_double () ? 0 :
                  (props.facealpha_is ("flat") ? 1 : 2));
   int ec_mode = ((props.edgecolor_is ("none")
                   || props.edgecolor_is_rgb ()) ? 0 :
                  (props.edgecolor_is ("flat") ? 1 : 2));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
                  (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
                  (props.edgealpha_is ("flat") ? 1 : 2));
+  int bfl_mode = (props.backfacelighting_is ("lit") ? 0 :
+                  (props.backfacelighting_is ("reverselit") ? 1 : 2));
 
   Matrix fcolor = props.get_facecolor_rgb ();
   Matrix ecolor = props.get_edgecolor_rgb ();
 
   float as = props.get_ambientstrength ();
   float ds = props.get_diffusestrength ();
   float ss = props.get_specularstrength ();
-  float se = props.get_specularexponent ();
+  float se = props.get_specularexponent () * 5; // to fit Matlab
+  float scr = props.get_specularcolorreflectance ();
 
   boolMatrix clip (1, nv, false);
 
   if (has_z)
     for (int i = 0; i < nv; i++)
       clip(i) = is_nan_or_inf (v(i,0), v(i,1), v(i,2));
   else
     for (int i = 0; i < nv; i++)
@@ -2596,68 +2733,77 @@ opengl_renderer::draw_patch (const patch
         Matrix vv (1, 3, 0.0);
         Matrix cc;
         Matrix nn (1, 3, 0.0);
         double aa = 1.0;
 
         vv(0) = v(idx,0); vv(1) = v(idx,1);
         if (has_z)
           vv(2) = v(idx,2);
-        // FIXME: uncomment when patch object has normal computation
-        //nn(0) = n(idx,0); nn(1) = n(idx,1); nn(2) = n(idx,2);
+        if (has_normals)
+          {
+            double dir = 1.0;
+            if (bfl_mode > 0)
+              dir = (n(idx,0) * view_vector(0) + 
+                     n(idx,1) * view_vector(1) + 
+                     n(idx,2) * view_vector(2) < 0) ?
+                      ((bfl_mode > 1) ? 0.0 : -1.0) : 1.0;
+            nn(0) = dir * n(idx,0);
+            nn(1) = dir * n(idx,1);
+            nn(2) = dir * n(idx,2);
+          }
         if (c.numel () > 0)
           {
             cc.resize (1, 3);
             if (has_facecolor)
               cc(0) = c(i,0), cc(1) = c(i,1), cc(2) = c(i,2);
             else
               cc(0) = c(idx,0), cc(1) = c(idx,1), cc(2) = c(idx,2);
           }
         if (a.numel () > 0)
           {
             if (has_facealpha)
               aa = a(i);
             else
               aa = a(idx);
           }
 
-        vdata[i+j*fr] = vertex_data (vv, cc, nn, aa, as, ds, ss, se);
+        vdata[i+j*fr] = vertex_data (vv, cc, nn, aa, as, ds, ss, se, scr);
       }
 
   if (fl_mode > 0 || el_mode > 0)
-    {
-      float buf[4] = { ss, ss, ss, 1 };
-
-      glMaterialfv (LIGHT_MODE, GL_SPECULAR, buf);
-      glMaterialf (LIGHT_MODE, GL_SHININESS, se);
-    }
+    glMaterialf (LIGHT_MODE, GL_SHININESS, se);
 
   if (! props.facecolor_is ("none"))
     {
       // FIXME: adapt to double-radio property
       if (props.get_facealpha_double () == 1)
         {
           if (fc_mode == UNIFORM)
             {
               glColor3dv (fcolor.data ());
               if (fl_mode > 0)
                 {
                   float cb[4] = { 0, 0, 0, 1 };
 
                   for (int i = 0; i < 3; i++)
-                    cb[i] = (as * fcolor(i));
+                    cb[i] = as * fcolor(i);
                   glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                   for (int i = 0; i < 3; i++)
                     cb[i] = ds * fcolor(i);
                   glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ss * (scr + (1-scr) * fcolor(i));
+                  glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                 }
             }
 
-          if ((fl_mode > 0) && has_light)
+          if ((fl_mode > 0) && (num_lights > 0) && has_normals)
             glEnable (GL_LIGHTING);
 
           // NOTE: Push filled part of patch backwards to avoid Z-fighting with
           // tesselator outline.  A value of 1.0 seems to work fine.  Value
           // can't be too large or the patch will be pushed below the axes
           // planes at +2.5.
           patch_tesselator tess (this, fc_mode, fl_mode, 1.0);
 
@@ -2695,28 +2841,33 @@ opengl_renderer::draw_patch (const patch
 
                               for (int k = 0; k < 3; k++)
                                 cb[k] = (vv->ambient * col(k));
                               glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                               for (int k = 0; k < 3; k++)
                                 cb[k] = (vv->diffuse * col(k));
                               glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = vv->specular * (vv->specular_color_refl
+                                    + (1-vv->specular_color_refl) * col(k));
+                              glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                             }
                         }
                     }
 
                   tess.add_vertex (vv->coords.fortran_vec (), vv);
                 }
 
               tess.end_contour ();
               tess.end_polygon ();
             }
 
-          if ((fl_mode > 0) && has_light)
+          if ((fl_mode > 0) && (num_lights > 0) && has_normals)
             glDisable (GL_LIGHTING);
         }
       else
         {
           // FIXME: implement transparency
         }
     }
 
@@ -2734,20 +2885,24 @@ opengl_renderer::draw_patch (const patch
 
                   for (int i = 0; i < 3; i++)
                     cb[i] = (as * ecolor(i));
                   glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
 
                   for (int i = 0; i < 3; i++)
                     cb[i] = ds * ecolor(i);
                   glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ss * (scr + (1-scr) * ecolor(i));
+                  glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                 }
             }
 
-          if ((el_mode > 0) && has_light)
+          if ((el_mode > 0) && (num_lights > 0) && has_normals)
             glEnable (GL_LIGHTING);
 
           set_linestyle (props.get_linestyle (), false);
           set_linewidth (props.get_linewidth ());
 
           // NOTE: patch contour cannot be offset.  Offset must occur with the
           // filled portion of the patch above.  The tesselator uses
           // GLU_TESS_BOUNDARY_ONLY to get the outline of the patch and OpenGL
@@ -2829,17 +2984,17 @@ opengl_renderer::draw_patch (const patch
                   tess.end_contour ();
                   tess.end_polygon ();
                 }
             }
 
           set_linestyle ("-");
           set_linewidth (0.5);
 
-          if ((el_mode > 0) && has_light)
+          if ((el_mode > 0) && (num_lights > 0) && has_normals)
             glDisable (GL_LIGHTING);
         }
       else
         {
           // FIXME: implement transparency
         }
     }
 
@@ -2919,16 +3074,51 @@ opengl_renderer::draw_patch (const patch
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
 
 #endif
 }
 
 void
+opengl_renderer::draw_light (const light::properties &props)
+{
+#if defined (HAVE_OPENGL)
+
+  // enable light source
+  glEnable (current_light);
+
+  // light position
+  float pos[4] = { 0, 0, 0, 0 }; // X,Y,Z,attenuation
+  Matrix lpos = props.get_position ().matrix_value ();
+  for (int i = 0; i < 3; i++)
+    pos[i] = lpos(i);
+  glLightfv (current_light, GL_POSITION, pos);
+
+  // light color
+  float col[4] = { 1, 1, 1, 1 }; // R,G,B,ALPHA (the latter has no meaning)
+  Matrix lcolor = props.get_color ().matrix_value ();
+  for (int i = 0; i < 3; i++)
+    col[i] = lcolor(i);
+  glLightfv (current_light, GL_DIFFUSE,  col);
+  glLightfv (current_light, GL_SPECULAR, col);
+
+#else
+
+  octave_unused_parameter (props);
+
+  // This shouldn't happen because construction of opengl_renderer
+  // objects is supposed to be impossible if OpenGL is not available.
+
+  panic_impossible ();
+
+#endif
+}
+
+void
 opengl_renderer::draw_hggroup (const hggroup::properties &props)
 {
   draw (props.get_children ());
 }
 
 void
 opengl_renderer::draw_text (const text::properties& props)
 {
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -59,16 +59,17 @@ public:
   virtual void finish (void);
 
 protected:
   virtual void draw_figure (const figure::properties& props);
   virtual void draw_axes (const axes::properties& props);
   virtual void draw_line (const line::properties& props);
   virtual void draw_surface (const surface::properties& props);
   virtual void draw_patch (const patch::properties& props);
+  virtual void draw_light (const light::properties& props);
   virtual void draw_hggroup (const hggroup::properties& props);
   virtual void draw_text (const text::properties& props);
   virtual void draw_image (const image::properties& props);
   virtual void draw_uipanel (const uipanel::properties& props,
                              const graphics_object& go);
 
   virtual void init_gl_context (bool enhanced, const Matrix& backgroundColor);
   virtual void setup_opengl_transformation (const axes::properties& props);
@@ -178,24 +179,25 @@ private:
   double zmin, zmax;
 
   // Z projection limits in windows coordinate
   double xZ1, xZ2;
 
   // call lists identifiers for markers
   unsigned int marker_id, filled_marker_id;
 
-  // camera information for primitive sorting
-  ColumnVector camera_pos, camera_dir;
+  // camera information for primitive sorting and lighting
+  ColumnVector camera_pos, camera_dir, view_vector;
 
   // interpreter to be used by text_to_pixels
   caseless_str interpreter;
 
   text_renderer txt_renderer;
 
   // light object present and visible
-  bool has_light;
+  int num_lights;
+  unsigned int current_light;
 
 private:
   class patch_tesselator;
 };
 
 #endif
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -530,16 +530,28 @@ default_panel_position (void)
   retval(0) = 0;
   retval(1) = 0;
   retval(2) = 1;
   retval(3) = 1;
 
   return retval;
 }
 
+static Matrix
+default_light_position (void)
+{
+  Matrix m (1, 3);
+
+  m(0) = 1.0;
+  m(1) = 0.0;
+  m(2) = 1.0;
+
+  return m;
+}
+
 static double
 convert_font_size (double font_size, const caseless_str& from_units,
                    const caseless_str& to_units, double parent_height = 0)
 {
   // Simple case where from_units == to_units
 
   if (from_units.compare (to_units))
     return font_size;
@@ -1092,16 +1104,18 @@ make_graphics_object_from_type (const ca
   else if (type.compare ("axes"))
     go = new axes (h, p);
   else if (type.compare ("line"))
     go = new line (h, p);
   else if (type.compare ("text"))
     go = new text (h, p);
   else if (type.compare ("image"))
     go = new image (h, p);
+  else if (type.compare ("light"))
+    go = new light (h, p);
   else if (type.compare ("patch"))
     go = new patch (h, p);
   else if (type.compare ("surface"))
     go = new surface (h, p);
   else if (type.compare ("hggroup"))
     go = new hggroup (h, p);
   else if (type.compare ("uimenu"))
     go = new uimenu (h, p);
@@ -8085,17 +8099,17 @@ image::properties::get_color_data (void)
 
 octave_value
 patch::properties::get_color_data (void) const
 {
   octave_value fvc = get_facevertexcdata ();
   if (fvc.is_undefined () || fvc.is_empty ())
     return Matrix ();
   else
-    return convert_cdata (*this, fvc,cdatamapping_is ("scaled"), 2);
+    return convert_cdata (*this, fvc, cdatamapping_is ("scaled"), 2);
 }
 
 static bool updating_patch_data = false;
 
 void
 patch::properties::update_fvc (void)
 {
   if (updating_patch_data)
@@ -9516,16 +9530,17 @@ root_figure::init_factory_properties (vo
 
   plist_map["figure"] = figure::properties::factory_defaults ();
   plist_map["axes"] = axes::properties::factory_defaults ();
   plist_map["line"] = line::properties::factory_defaults ();
   plist_map["text"] = text::properties::factory_defaults ();
   plist_map["image"] = image::properties::factory_defaults ();
   plist_map["patch"] = patch::properties::factory_defaults ();
   plist_map["surface"] = surface::properties::factory_defaults ();
+  plist_map["light"] = light::properties::factory_defaults ();
   plist_map["hggroup"] = hggroup::properties::factory_defaults ();
   plist_map["uimenu"] = uimenu::properties::factory_defaults ();
   plist_map["uicontrol"] = uicontrol::properties::factory_defaults ();
   plist_map["uipanel"] = uipanel::properties::factory_defaults ();
   plist_map["uicontextmenu"] = uicontextmenu::properties::factory_defaults ();
   plist_map["uitoolbar"] = uitoolbar::properties::factory_defaults ();
   plist_map["uipushtool"] = uipushtool::properties::factory_defaults ();
   plist_map["uitoggletool"] = uitoggletool::properties::factory_defaults ();
@@ -10339,16 +10354,25 @@ DEFUN (__go_patch__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_patch__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (patch);
 }
 
+DEFUN (__go_light__, args, ,
+       "-*- texinfo -*-\n\
+@deftypefn {} {} __go_light__ (@var{parent})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  GO_BODY (light);
+}
+
 DEFUN (__go_hggroup__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_hggroup__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (hggroup);
 }
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -4810,16 +4810,65 @@ public:
     if (! retval)
       retval = base_properties::has_readonly_property (pname);
     return retval;
   }
 };
 
 // ---------------------------------------------------------------------
 
+class OCTINTERP_API light : public base_graphics_object
+{
+public:
+  class OCTINTERP_API properties : public base_properties
+  {
+    // See the genprops.awk script for an explanation of the
+    // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
+
+    BEGIN_PROPERTIES (light)
+      color_property color , color_values (1, 1, 1)
+      array_property position , default_light_position ()
+      radio_property style , "{infinite}|local"
+    END_PROPERTIES
+
+  protected:
+    void init (void)
+    {
+      position.add_constraint (dim_vector (1, 3));
+    }
+  };
+
+private:
+  properties xproperties;
+
+public:
+  light (const graphics_handle& mh, const graphics_handle& p)
+    : base_graphics_object (), xproperties (mh, p)
+  { }
+
+  ~light (void) { }
+
+  base_properties& get_properties (void) { return xproperties; }
+
+  const base_properties& get_properties (void) const { return xproperties; }
+
+  bool valid_object (void) const { return true; }
+
+  bool has_readonly_property (const caseless_str& pname) const
+  {
+    bool retval = xproperties.has_readonly_property (pname);
+    if (! retval)
+      retval = base_properties::has_readonly_property (pname);
+    return retval;
+  }
+};
+
+// ---------------------------------------------------------------------
+
 class OCTINTERP_API patch : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
@@ -4854,17 +4903,17 @@ public:
       double_property diffusestrength , 0.6
       string_property displayname , ""
       double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
       radio_property edgelighting , "{none}|flat|gouraud|phong"
       radio_property erasemode , "{normal}|background|xor|none"
       double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       color_property facecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
-      radio_property facelighting , "{none}|flat|gouraud|phong"
+      radio_property facelighting , "none|{flat}|gouraud|phong"
       array_property facenormals m , Matrix ()
       radio_property facenormalsmode , "{auto}|manual"
       array_property faces u , default_patch_faces ()
       array_property facevertexalphadata , Matrix ()
       array_property facevertexcdata u , Matrix ()
       // FIXME: interpreter is not a property of a Matlab patch.
       //        Octave uses this for legend() with the string displayname.
       radio_property interpreter , "{tex}|none|latex"
@@ -5057,17 +5106,17 @@ public:
       double_property diffusestrength , 0.6
       string_property displayname , ""
       double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
       radio_property edgelighting , "{none}|flat|gouraud|phong"
       radio_property erasemode , "{normal}|none|xor|background"
       double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp|texturemap"))
       color_property facecolor , color_property (radio_values ("none|{flat}|interp|texturemap"), color_values (0, 0, 0))
-      radio_property facelighting , "{none}|flat|gouraud|phong"
+      radio_property facelighting , "none|{flat}|gouraud|phong"
       array_property facenormals m , Matrix ()
       radio_property facenormalsmode , "{auto}|manual"
       // FIXME: interpreter is not a Matlab surface property
       //        Octave uses this for legend() with the string displayname.
       radio_property interpreter , "{tex}|none|latex"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
       radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -709,17 +709,16 @@ function list = missing_functions ()
   "keys",
   "last",
   "ldl",
   "libfunctions",
   "libfunctionsview",
   "libisloaded",
   "libpointer",
   "libstruct",
-  "light",
   "lightangle",
   "lighting",
   "linkdata",
   "listfonts",
   "loadlibrary",
   "localfunctions",
   "lsqr",
   "makehgtform",
diff --git a/scripts/plot/draw/light.m b/scripts/plot/draw/light.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/draw/light.m
@@ -0,0 +1,415 @@
+## Copyright (C) 2016 Markus Muetzel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {} light ()
+## @deftypefnx {} {} light (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {} {} light (@var{hax}, @dots{})
+## @deftypefnx {} {@var{h} =} light (@dots{})
+## Create light object in the current axes or for axes @var{hax}.
+##
+## When a light object is present in an axes object and the properties
+## @qcode{"EdgeLighting"} or @qcode{"FaceLighting"} of a @command{patch} or
+## @command{surface} object are set to a value other than @qcode{"none"}, these
+## objects are drawn with light and shadow effects.  Supported values for these
+## properties are @qcode{"none"} (no lighting effects), @qcode{"flat"}
+## (facetted look of the objects) and @qcode{"gouraud"} (linear interpolation
+## of the lighting effects between the vertices).
+## For @command{patch} objects, the normals must be set manually (property
+## @qcode{"VertexNormals"}).
+##
+## Up to eight light objects are supported per axes.
+##
+## Lighting is only supported for graphics toolkits supporting OpenGL (i.e.
+## @qcode{"fltk"} and @qcode{"qt"}).
+##
+## The following properties specific to the light object can be passed with
+## their respective values:
+##
+## @table @asis
+## @item @qcode{"Color":} The color of the light object can be passed as an 
+## RGB-vector (e.g. @qcode{[1 0 0]} for red) or as a string (e.g. @qcode{"r"}
+## for red).  The default color is white (@qcode{[1 1 1]}).
+##
+## @item @qcode{"Position":} The direction from which the light emanates as an
+## 1x3-vector.  The default direction is @qcode{[1 0 1]}.
+##
+## @item @qcode{"Style":} This string defines whether the light emanates from a
+## light source at infinite distance (@qcode{"infinite"}) or from a local point
+## source (@qcode{"local"}).  Only the default value @qcode{"infinite"} is
+## supported.
+## @end table
+##
+## If @command{light} is called with an axes handle @var{hax}, it must be passed
+## as the first argument.
+##
+## Optionally, the handle to the light object is returned in @var{h}.
+##
+## @seealso{get, set, patch, surface}
+## @end deftypefn
+
+## Author: mmuetzel
+
+function h = light (varargin)
+
+  [hax, varargin] = __plt_get_axis_arg__ ("light", varargin{:});
+
+  if (isempty (hax))
+    hax = gca ();
+  else
+    hax = hax(1);
+  endif
+
+  htmp = __go_light__ (hax, varargin{:});
+
+  if (nargout > 0)
+    h = htmp;
+  endif
+
+endfunction
+
+
+%!demo
+%! %% Demonstrate effects of lighting
+%! clf;
+%! %% patches
+%! h_axes1 = subplot (2, 2, 1);
+%! [x,y,z] = meshgrid (-2:0.2:2, -2:0.2:2, -2:0.2:2);
+%! val = x.^2 + y.^2 + z.^2;
+%! fv1 = isosurface (x, y, z, val, 1);
+%! h_patch1 = patch (fv1, "FaceColor", "c", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! isonormals (x, y, z, val, h_patch1)
+%! fv2 = isosurface (x, y+3, z, val, 1);
+%! h_patch2 = patch (fv2, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! isonormals (x, y+3, z, val, h_patch2)
+%! axis equal; axis tight
+%! title ("Patch with lighting");
+%! view (3)
+%! h_light1 = light ();
+%!
+%! h_axes2 = subplot(2, 2, 2);
+%! patch (fv1, "FaceColor", "c", "EdgeColor", "none");
+%! patch (fv2, "FaceColor", "r", "EdgeColor", "none");
+%! axis equal; axis tight
+%! title ("Patch without lighting");
+%! view (3)
+%!
+%! %% surfaces
+%! h_axes3 = subplot(2, 2, 3);
+%! h_surf1 = surf (h_axes3, peaks, "LineStyle", "none", "FaceLighting", "Gouraud");
+%! title ("Surface with lighting");
+%! view (3)
+%! h_light2 = light ();
+%!
+%! h_axes3 = subplot(2, 2, 4);
+%! h_surf2 = surf (h_axes3, peaks, "LineStyle", "none");
+%! title ("Surface without lighting");
+%! view (3)
+
+%!demo
+%! %% Lighting modes
+%! clf;
+%! [x,y,z] = meshgrid (-.2:0.05:.2, -.2:0.05:.2, -.2:0.05:.2);
+%! val = (x.^2 + y.^2 + z.^2);
+%!
+%! h_axes1 = axes ();
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "none");
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "flat");
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! isonormals (x+1, y, z, val, h_patch)
+%! axis tight
+%! axis equal
+%! view(2);
+%! light ("Position", [-1 1 1]);
+%! title ("FaceLighting: none - flat - gouraud");
+
+
+%!demo
+%! %% multiple lights
+%! clf;
+%! h_axes = subplot (1, 2, 1);
+%! [x,y,z] = meshgrid (-2:0.1:2, -2:0.1:2, -2:0.1:2);
+%! val = x.^2 + y.^2 + z.^2;
+%! fv = isosurface (x, y, z, val, 1);
+%! h_patch = patch (fv, "FaceColor", "w", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! isonormals (x, y, z, val, h_patch)
+%! axis equal; axis tight
+%! title ("Patch with one light");
+%! view (3)
+%! h_light = light ("Color", "g");
+%!
+%! h_axes2 = subplot (1, 2, 2);
+%! h_patch2 = patch (fv, "FaceColor", "w", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! isonormals (x, y, z, val, h_patch2)
+%! axis equal; axis tight
+%! title ("Patch with three lights");
+%! view (3)
+%! h_light1 = light ("Color", "r");
+%! h_light2 = light ("Position", [0 1 1], "Color", "b");
+%! h_light3 = light ("Position", [-1 -1 2], "Color", "g");
+
+%!demo
+%! %% Diffuse and specular reflex
+%! clf;
+%! h_axes = axes ();
+%! [x,y,z] = meshgrid (-.2:0.02:.2, -.2:0.02:.2, -.2:0.02:.2);
+%! val = (x.^2 + y.^2 + z.^2);
+%!
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 0, "SpecularStrength", 0)
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 0, "SpecularStrength", .5)
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 0, "SpecularStrength", 1)
+%! isonormals (x+1, y, z, val, h_patch)
+%!
+%! fv = isosurface (x, y+.5, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 0.5, "SpecularStrength", 0)
+%! isonormals (x, y+.5, z, val, h_patch)
+%! fv = isosurface (x+.5, y+.5, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 0.5, "SpecularStrength", .5)
+%! isonormals (x+.5, y+.5, z, val, h_patch)
+%! fv = isosurface (x+1, y+.5, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 0.5, "SpecularStrength", 1)
+%! isonormals (x+1, y+.5, z, val, h_patch)
+%!
+%! fv = isosurface (x, y+1, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 1, "SpecularStrength", 0)
+%! isonormals (x, y+1, z, val, h_patch)
+%! fv = isosurface (x+.5, y+1, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 1, "SpecularStrength", .5)
+%! isonormals (x+.5, y+1, z, val, h_patch)
+%! fv = isosurface (x+1, y+1, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "DiffuseStrength", 1, "SpecularStrength", 1)
+%! isonormals (x+1, y+1, z, val, h_patch)
+%!
+%! axis equal
+%! h_light = light ("Position", [-1 1 1]);
+%! view(2);
+%!
+%! xlabel ("SpecularStrength")
+%! ylabel ("DiffuseStrength")
+
+
+%!demo
+%! %% Ambient Strength and Ambient Light Color
+%! clf;
+%! [x,y,z] = meshgrid (-.2:0.05:.2, -.2:0.05:.2, -.2:0.05:.2);
+%! val = (x.^2 + y.^2 + z.^2);
+%!
+%! h_axes1 = subplot (3,1,3);
+%! set (h_axes1, "AmbientLightColor", "g")
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", 0)
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", .7)
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", 1)
+%! isonormals (x+1, y, z, val, h_patch)
+%! h_light = light ("Position", [-1 1 1]);
+%! axis tight
+%! axis equal
+%! view(2);
+%! xlabel ("AmbientStrength")
+%! ylabel ("AmbientLightColor [0 1 0]")
+%!
+%! h_axes2 = subplot (3,1,2);
+%! set (h_axes2, "AmbientLightColor", [.5 0 1])
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", 0)
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", .7)
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", 1)
+%! isonormals (x+1, y, z, val, h_patch)
+%! h_light = light ("Position", [-1 1 1]);
+%! axis tight
+%! axis equal
+%! view(2);
+%! ylabel ("AmbientLightColor [.5 0 1]")
+%!
+%! h_axes3 = subplot (3,1,1);
+%! set (h_axes3, "AmbientLightColor", "w")
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", 0)
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", .7)
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "AmbientStrength", 1)
+%! isonormals (x+1, y, z, val, h_patch)
+%! h_light = light ("Position", [-1 1 1]);
+%! axis tight
+%! axis equal
+%! view(2);
+%! ylabel ("AmbientLightColor [1 1 1]")
+
+%!demo
+%! %% Specular Exponent
+%! clf;
+%! [x,y,z] = meshgrid (-.2:0.01:.2, -.2:0.01:.2, -.2:0.01:.2);
+%! val = (x.^2 + y.^2 + z.^2);
+%!
+%! h_axes = axes ();
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularExponent", 15)
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularExponent", 5)
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularExponent", 1)
+%! isonormals (x+1, y, z, val, h_patch)
+%! h_light = light ("Position", [-1 1 1]);
+%! axis tight
+%! axis equal
+%! view(2);
+%! xlabel ("SpecularExponent")
+
+%!demo
+%! %% SpecularColorReflectance
+%! clf;
+%! [x,y,z] = meshgrid (-.2:0.02:.2, -.2:0.02:.2, -.2:0.02:.2);
+%! val = (x.^2 + y.^2 + z.^2);
+%!
+%! h_axes = axes ();
+%! fv = isosurface (x, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularColorReflectance", 0)
+%! isonormals (x, y, z, val, h_patch)
+%! fv = isosurface (x+.5, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularColorReflectance", 0.5)
+%! isonormals (x+.5, y, z, val, h_patch)
+%! fv = isosurface (x+1, y, z, val, .039);
+%! h_patch = patch (fv, "FaceColor", "r", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularColorReflectance", 1)
+%! isonormals (x+1, y, z, val, h_patch)
+%! h_light = light ("Position", [-1 1 1]);
+%! axis tight
+%! axis equal
+%! view(2);
+%! xlabel ("SpecularColorReflectance")
+
+%!demo
+%! %% BackFaceLighting
+%! [x,y,z] = meshgrid (-.5:0.1:2, -2:0.1:2, -2:0.1:2);
+%! val = x.^2 + y.^2 + z.^2;
+%! fv = isosurface (x, y, z, val, 1);
+%! h_axes1 = subplot (1, 3, 1);
+%! h_patch = patch (fv, "FaceColor", "c", "EdgeColor", "none", "FaceLighting", "Gouraud");
+%! isonormals (x, y, z, val, h_patch)
+%! vn = get (h_patch, "VertexNormals");
+%! set (h_patch, "BackFaceLighting", "reverselit");
+%! h_light = light ();
+%! view (h_axes1, [-50 30])
+%! title ("reverselit")
+%! axis equal
+%!
+%! h_axes2 = subplot (1, 3, 2);
+%! h_patch = patch (fv, "FaceColor", "c", "EdgeColor", "none", ...
+%!           "FaceLighting", "Gouraud", "VertexNormals", vn);
+%! set (h_patch, "BackFaceLighting", "lit");
+%! h_light = light ();
+%! view (h_axes2, [-50 30])
+%! title ("lit")
+%! axis equal
+%!
+%! h_axes3 = subplot (1, 3, 3);
+%! h_patch = patch (fv, "FaceColor", "c", "EdgeColor", "none", ...
+%!           "FaceLighting", "Gouraud", "VertexNormals", vn);
+%! set (h_patch, "BackFaceLighting", "unlit");
+%! h_light = light ();
+%! view (h_axes3, [-50 30])
+%! title ("unlit")
+%! axis equal
+
+%!demo
+%! %% Colored patch
+%! clf;
+%! [x,y,z] = meshgrid (-.2:0.01:.2, -.2:0.01:.2, -.2:0.01:.2);
+%! val = (x.^2 + y.^2 + z.^2);
+%!
+%! h_axes = axes ();
+%! fv = isosurface (x, y, z, val, .039, z);
+%! h_patch = patch (fv, "FaceColor", "flat", "EdgeColor", "none", ...
+%!             "FaceLighting", "Gouraud");
+%! set (h_patch, "SpecularExponent", 15)
+%! isonormals (x, y, z, val, h_patch)
+%! h_light = light ("Position", [-1 1 1]);
+%! axis tight
+%! axis equal
+%! view (3);
+
+
+%!test
+%! hf = figure ("Visible", "off");
+%! unwind_protect
+%!   h = light ();
+%!   assert (findobj (hf, "Type", "light"), h);
+%!   assert (get (h, "Position"), [1, 0, 1]);
+%!   assert (get (h, "Color"), [1, 1, 1]);
+%!   assert (get (h, "Style"), "infinite");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure ("Visible", "off");
+%! ha = gca;
+%! unwind_protect
+%!   h = light (ha, "Position", [1 2 3], "Color", "r");
+%!   assert (get (h, "Position"), [1 2 3]);
+%!   assert (get (h, "Color"), [1 0 0]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/draw/module.mk b/scripts/plot/draw/module.mk
--- a/scripts/plot/draw/module.mk
+++ b/scripts/plot/draw/module.mk
@@ -44,16 +44,17 @@ scripts_plot_draw_FCN_FILES = \
   scripts/plot/draw/ezsurf.m \
   scripts/plot/draw/feather.m \
   scripts/plot/draw/fill.m \
   scripts/plot/draw/fplot.m \
   scripts/plot/draw/hist.m \
   scripts/plot/draw/isocolors.m \
   scripts/plot/draw/isonormals.m \
   scripts/plot/draw/isosurface.m \
+  scripts/plot/draw/light.m \
   scripts/plot/draw/line.m \
   scripts/plot/draw/loglogerr.m \
   scripts/plot/draw/loglog.m \
   scripts/plot/draw/meshc.m \
   scripts/plot/draw/mesh.m \
   scripts/plot/draw/meshz.m \
   scripts/plot/draw/pareto.m \
   scripts/plot/draw/patch.m \
diff --git a/scripts/plot/util/private/__gnuplot_draw_axes__.m b/scripts/plot/util/private/__gnuplot_draw_axes__.m
--- a/scripts/plot/util/private/__gnuplot_draw_axes__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_axes__.m
@@ -1332,16 +1332,19 @@ function __gnuplot_draw_axes__ (h, plot_
       case "hggroup"
         ## Push group children into the kid list.
         if (isempty (kids))
           kids = obj.children;
         elseif (! isempty (obj.children))
           kids = [kids; obj.children];
         endif
 
+      case "light"
+        ## ignore it
+
       otherwise
         error ("__gnuplot_draw_axes__: unknown object class, %s", obj.type);
     endswitch
 
   endwhile
 
   ## This is needed to prevent warnings for rotations in 3D plots, while
   ## allowing colorbars with contours.
