# HG changeset patch
# User CarnÃ« Draug <carandraug@octave.org>
# Date 1432952047 -3600
#      Sat May 30 03:14:07 2015 +0100
# Node ID a9574e3c6e9e7be960eb7afb3150ecb76d33711f
# Parent  83792dd9bcc18bc4559e77998f5d6fe32430078a
Deprecate Array::length() and Sparse::length() in favour of ::numel().

* liboctave/array/Array.h (Array::length): deprecate for ::numel.
* liboctave/array/Sparse.h (Sparse::length): deprecate for ::numel.
* libgui/graphics/QtHandlesUtils.cc, libgui/src/octave-qt-link.cc,
libinterp/corefcn/Cell.cc, libinterp/corefcn/__contourc__.cc,
libinterp/corefcn/__pchip_deriv__.cc, libinterp/corefcn/__qp__.cc,
libinterp/corefcn/cellfun.cc, libinterp/corefcn/daspk.cc,
libinterp/corefcn/dasrt.cc, libinterp/corefcn/dassl.cc,
libinterp/corefcn/data.cc, libinterp/corefcn/filter.cc,
libinterp/corefcn/find.cc, libinterp/corefcn/gl-render.cc,
libinterp/corefcn/gl-render.h, libinterp/corefcn/graphics.cc,
libinterp/corefcn/graphics.in.h, libinterp/corefcn/help.cc,
libinterp/corefcn/hex2num.cc, libinterp/corefcn/input.cc,
libinterp/corefcn/load-path.cc, libinterp/corefcn/load-save.cc,
libinterp/corefcn/ls-oct-ascii.h, libinterp/corefcn/lsode.cc,
libinterp/corefcn/matrix_type.cc, libinterp/corefcn/oct-hist.cc,
libinterp/corefcn/oct-map.cc, libinterp/corefcn/oct-map.h,
libinterp/corefcn/oct-obj.h, libinterp/corefcn/oct-stream.cc,
libinterp/corefcn/oct-stream.h, libinterp/corefcn/pr-output.cc,
libinterp/corefcn/quadcc.cc, libinterp/corefcn/rand.cc,
libinterp/corefcn/regexp.cc, libinterp/corefcn/strfns.cc,
libinterp/corefcn/sub2ind.cc, libinterp/corefcn/symtab.h,
libinterp/corefcn/syscalls.cc, libinterp/corefcn/tsearch.cc,
libinterp/corefcn/urlwrite.cc, libinterp/corefcn/utils.cc,
libinterp/corefcn/variables.cc, libinterp/corefcn/xdiv.cc,
libinterp/corefcn/xpow.cc, libinterp/dldfcn/__glpk__.cc,
libinterp/dldfcn/__init_fltk__.cc, libinterp/dldfcn/__magick_read__.cc,
libinterp/dldfcn/audiodevinfo.cc, libinterp/dldfcn/ccolamd.cc,
libinterp/dldfcn/colamd.cc, libinterp/octave-value/ov-cell.cc,
libinterp/octave-value/ov-class.cc, libinterp/octave-value/ov-class.h,
libinterp/octave-value/ov-fcn-inline.cc, libinterp/octave-value/ov-java.cc,
libinterp/octave-value/ov-perm.cc, libinterp/octave-value/ov-struct.cc,
libinterp/octave-value/ov-typeinfo.cc, libinterp/octave-value/ov.cc,
libinterp/operators/op-int.h, libinterp/parse-tree/pt-pr-code.cc,
liboctave/array/Array-util.cc, liboctave/array/Array.cc,
liboctave/array/CColVector.cc, liboctave/array/CDiagMatrix.cc,
liboctave/array/CMatrix.cc, liboctave/array/CRowVector.cc,
liboctave/array/DiagArray2.cc, liboctave/array/DiagArray2.h,
liboctave/array/MArray.cc, liboctave/array/PermMatrix.cc,
liboctave/array/PermMatrix.h, liboctave/array/Sparse.cc,
liboctave/array/boolMatrix.cc, liboctave/array/chMatrix.cc,
liboctave/array/chNDArray.cc, liboctave/array/dColVector.cc,
liboctave/array/dDiagMatrix.cc, liboctave/array/dMatrix.cc,
liboctave/array/dRowVector.cc, liboctave/array/fCColVector.cc,
liboctave/array/fCDiagMatrix.cc, liboctave/array/fCMatrix.cc,
liboctave/array/fCRowVector.cc, liboctave/array/fColVector.cc,
liboctave/array/fDiagMatrix.cc, liboctave/array/fMatrix.cc,
liboctave/array/fRowVector.cc, liboctave/array/idx-vector.cc,
liboctave/array/intNDArray.cc, liboctave/numeric/CmplxCHOL.cc,
liboctave/numeric/CmplxLU.cc, liboctave/numeric/CmplxQR.cc,
liboctave/numeric/DASPK.cc, liboctave/numeric/DASRT.cc,
liboctave/numeric/DASSL.cc, liboctave/numeric/LSODE.cc,
liboctave/numeric/ODES.cc, liboctave/numeric/ODES.h,
liboctave/numeric/base-dae.h, liboctave/numeric/base-lu.cc,
liboctave/numeric/dbleCHOL.cc, liboctave/numeric/dbleLU.cc,
liboctave/numeric/dbleQR.cc, liboctave/numeric/eigs-base.cc,
liboctave/numeric/fCmplxCHOL.cc, liboctave/numeric/fCmplxLU.cc,
liboctave/numeric/fCmplxQR.cc, liboctave/numeric/floatCHOL.cc,
liboctave/numeric/floatLU.cc, liboctave/numeric/floatQR.cc,
liboctave/numeric/lo-specfun.cc, liboctave/numeric/oct-rand.cc,
liboctave/numeric/oct-spparms.cc, liboctave/numeric/sparse-base-chol.cc,
liboctave/operators/mx-inlines.cc, liboctave/system/file-ops.cc,
liboctave/util/glob-match.h, liboctave/util/kpse.cc,
liboctave/util/lo-regexp.cc, liboctave/util/oct-glob.cc,
liboctave/util/pathsearch.cc, liboctave/util/str-vec.cc,
liboctave/util/str-vec.h, liboctave/util/url-transfer.cc: replace all usage
of Array::length() and Sparse::length() with ::numel().

diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -671,50 +671,50 @@ print_$CLASS_NAME (std::ostream& os)
             {
               $elt_type = "int";
             }
           else
             {
               $elt_type = "octave_idx_type";
             }
           print qq|    Array<$elt_type> val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n|;
-          print qq|    if (val.length () == 1)
+          print qq|    if (val.numel () == 1)
       {
         os << val(0) << "\\n";
       }
     else
       {
         os << "\\n\\n";
-        octave_idx_type len = val.length ();
+        octave_idx_type len = val.numel ();
         Matrix tmp (len, 1);
         for (octave_idx_type i = 0; i < len; i++)
           tmp(i,0) = val(i);
         octave_print_internal (os, tmp, false, 2);
         os << "\\n\\n";
       }\n|;
         }
       elsif ($TYPE[$i] eq "Array<double>")
         {
           print qq|    Array<double> val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n|;
-          print qq|    if (val.length () == 1)
+          print qq|    if (val.numel () == 1)
       {
         os << val(0) << "\\n";
       }
     else
       {
         os << "\\n\\n";
         Matrix tmp = Matrix (ColumnVector (val));
         octave_print_internal (os, tmp, false, 2);
         os << "\\n\\n";
       }\n|;
         }
       elsif ($TYPE[$i] eq "Array<float>")
         {
           print qq|    Array<float> val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n|;
-          print qq|    if (val.length () == 1)
+          print qq|    if (val.numel () == 1)
       {
         os << val(0) << "\\n";
       }
     else
       {
         os << "\\n\\n";
         FloatMatrix tmp = FloatMatrix (FloatColumnVector (val));
         octave_print_internal (os, tmp, false, 2);
@@ -851,45 +851,45 @@ show_$CLASS_NAME (const std::string& key
             {
               $elt_type = "int";
             }
           else
             {
               $elt_type = "octave_idx_type";
             }
           print "      Array<$elt_type> val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n";
-          print "      if (val.length () == 1)
+          print "      if (val.numel () == 1)
         {
           retval = static_cast<double> (val(0));
         }
       else
         {
-          octave_idx_type len = val.length ();
+          octave_idx_type len = val.numel ();
           ColumnVector tmp (len);
           for (octave_idx_type i = 0; i < len; i++)
             tmp(i) = val(i);
           retval = tmp;
         }\n";
         }
       elsif ($TYPE[$i] eq "Array<double>")
         {
           print "      Array<double> val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n";
-          print "      if (val.length () == 1)
+          print "      if (val.numel () == 1)
         {
           retval = val(0);
         }
       else
         {
           retval = ColumnVector (val);
         }\n";
         }
       elsif ($TYPE[$i] eq "Array<float>")
         {
           print "      Array<float> val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n";
-          print "      if (val.length () == 1)
+          print "      if (val.numel () == 1)
         {
           retval = val(0);
         }
       else
         {
           retval = FloatColumnVector (val);
         }\n";
         }
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -56,17 +56,17 @@ toStdString (const QString& s)
 {
   return std::string (s.toLocal8Bit ().data ());
 }
 
 QStringList
 fromStringVector (const string_vector& v)
 {
   QStringList l;
-  octave_idx_type n = v.length ();
+  octave_idx_type n = v.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     l << fromStdString (v[i]);
 
   return l;
 }
 
 string_vector
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -485,17 +485,17 @@ octave_qt_link::do_clear_workspace (void
   emit clear_workspace_signal ();
 }
 
 void
 octave_qt_link::do_set_history (const string_vector& hist)
 {
   QStringList qt_hist;
 
-  for (octave_idx_type i = 0; i < hist.length (); i++)
+  for (octave_idx_type i = 0; i < hist.numel (); i++)
     qt_hist.append (QString::fromStdString (hist[i]));
 
   emit set_history_signal (qt_hist);
 }
 
 void
 octave_qt_link::do_append_history (const std::string& hist_entry)
 {
diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 Cell::Cell (const octave_value_list& ovl)
   : Array<octave_value> (ovl.cell_value ())
 {
 }
 
 Cell::Cell (const string_vector& sv, bool trim)
   : Array<octave_value> ()
 {
-  octave_idx_type n = sv.length ();
+  octave_idx_type n = sv.numel ();
 
   if (n > 0)
     {
       resize (dim_vector (n, 1));
 
       for (octave_idx_type i = 0; i < n; i++)
         {
           std::string s = sv[i];
@@ -94,17 +94,17 @@ Cell::Cell (const Array<std::string>& sa
 }
 
 // Set size to DV, filling with [].  Then fill with as many elements of
 // SV as possible.
 
 Cell::Cell (const dim_vector& dv, const string_vector& sv, bool trim)
   : Array<octave_value> (dv, Matrix ())
 {
-  octave_idx_type n = sv.length ();
+  octave_idx_type n = sv.numel ();
 
   if (n > 0)
     {
       octave_idx_type m = numel ();
 
       octave_idx_type len = n > m ? m : n;
 
       for (octave_idx_type i = 0; i < len; i++)
diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -311,17 +311,17 @@ Undocumented internal function.\n\
       RowVector Y = args(1).row_vector_value ();
       Matrix Z = args(2).matrix_value ();
       RowVector L = args(3).row_vector_value ();
 
       if (! error_state)
         {
           contourc.resize (2, 0);
 
-          for (int i = 0; i < L.length (); i++)
+          for (int i = 0; i < L.numel (); i++)
             cntr (X, Y, Z, L (i));
 
           end_contour ();
 
           retval = contourc;
         }
       else
         error ("__contourc__: invalid argument values");
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -63,17 +63,17 @@ Undocumented internal function.\n\
 
   if (nargin >= 2)
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatColumnVector xvec (args(0).float_vector_value ());
           FloatMatrix ymat (args(1).float_matrix_value ());
 
-          octave_idx_type nx = xvec.length ();
+          octave_idx_type nx = xvec.numel ();
 
           if (nx < 2)
             {
               error ("__pchip_deriv__: X must be at least of length 2");
               return retval;
             }
 
           octave_idx_type nyr = ymat.rows ();
@@ -110,17 +110,17 @@ Undocumented internal function.\n\
 
           retval = dmat;
         }
       else
         {
           ColumnVector xvec (args(0).vector_value ());
           Matrix ymat (args(1).matrix_value ());
 
-          octave_idx_type nx = xvec.length ();
+          octave_idx_type nx = xvec.numel ();
 
           if (nx < 2)
             {
               error ("__pchip_deriv__: X must be at least of length 2");
               return retval;
             }
 
           octave_idx_type nyr = ymat.rows ();
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -57,17 +57,17 @@ null (const Matrix& A, octave_idx_type& 
 
       octave_idx_type A_nr = A.rows ();
       octave_idx_type A_nc = A.cols ();
 
       octave_idx_type tmp = A_nr > A_nc ? A_nr : A_nc;
 
       double tol = tmp * s(0) * std::numeric_limits<double>::epsilon ();
 
-      octave_idx_type n = s.length ();
+      octave_idx_type n = s.numel ();
 
       for (octave_idx_type i = 0; i < n; i++)
         {
           if (s(i) > tol)
             rank++;
         }
 
       if (rank < A_nc)
@@ -92,21 +92,21 @@ qp (const Matrix& H, const ColumnVector&
 {
   int info = 0;
 
   iter = 0;
 
   double rtol = sqrt (std::numeric_limits<double>::epsilon ());
 
   // Problem dimension.
-  octave_idx_type n = x.length ();
+  octave_idx_type n = x.numel ();
 
   // Dimension of constraints.
-  octave_idx_type n_eq = beq.length ();
-  octave_idx_type n_in = bin.length ();
+  octave_idx_type n_eq = beq.numel ();
+  octave_idx_type n_in = bin.numel ();
 
   // Filling the current active set.
 
   octave_idx_type n_act = n_eq;
 
   octave_idx_type n_tot = n_eq + n_in;
 
   // Equality constraints come first.  We won't check the sign of the
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1709,17 +1709,17 @@ arrayfun (@@str2num, [1234],\n\
 */
 
 static void
 do_num2cell_helper (const dim_vector& dv,
                     const Array<int>& dimv,
                     dim_vector& celldv, dim_vector& arraydv,
                     Array<int>& perm)
 {
-  int dvl = dimv.length ();
+  int dvl = dimv.numel ();
   int maxd = dv.length ();
   celldv = dv;
   for (int i = 0; i < dvl; i++)
     maxd = std::max (maxd, dimv(i));
   if (maxd > dv.length ())
     celldv.resize (maxd, 1);
   arraydv = celldv;
 
@@ -1976,17 +1976,17 @@ num2cell ([1,2;3,4],1)\n\
 
 static bool
 mat2cell_mismatch (const dim_vector& dv,
                    const Array<octave_idx_type> *d, int nd)
 {
   for (int i = 0; i < nd; i++)
     {
       octave_idx_type s = 0;
-      for (octave_idx_type j = 0; j < d[i].length (); j++)
+      for (octave_idx_type j = 0; j < d[i].numel (); j++)
         s += d[i](j);
 
       octave_idx_type r = i < dv.length () ? dv(i) : 1;
 
       if (s != r)
         {
           error ("mat2cell: mismatch on %d-th dimension (%d != %d)",
                  i+1, r, s);
@@ -2026,18 +2026,18 @@ do_mat2cell_2d (const Array2D& a, const 
 {
   NoAlias<Cell> retval;
   assert (nd == 1 || nd == 2);
   assert (a.ndims () == 2);
 
   if (mat2cell_mismatch (a.dims (), d, nd))
     return retval;
 
-  octave_idx_type nridx = d[0].length ();
-  octave_idx_type ncidx = nd == 1 ? 1 : d[1].length ();
+  octave_idx_type nridx = d[0].numel ();
+  octave_idx_type ncidx = nd == 1 ? 1 : d[1].numel ();
   retval.clear (nridx, ncidx);
 
   int ivec = -1;
   if (a.rows () > 1 && a.cols () == 1 && ncidx == 1)
     ivec = 0;
   else if (a.rows () == 1 && nridx == 1 && nd == 2)
     ivec = 1;
 
@@ -2087,17 +2087,17 @@ do_mat2cell_nd (const ArrayND& a, const 
   if (mat2cell_mismatch (a.dims (), d, nd))
     return retval;
 
   dim_vector rdv = dim_vector::alloc (nd);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, nidx, nd);
   octave_idx_type idxtot = 0;
   for (int i = 0; i < nd; i++)
     {
-      rdv(i) = nidx[i] = d[i].length ();
+      rdv(i) = nidx[i] = d[i].numel ();
       idxtot += nidx[i];
     }
 
   retval.clear (rdv);
 
   OCTAVE_LOCAL_BUFFER (idx_vector, xidx, idxtot);
   OCTAVE_LOCAL_BUFFER (idx_vector *, idx, nd);
 
@@ -2151,17 +2151,17 @@ do_mat2cell (octave_value& a, const Arra
   if (mat2cell_mismatch (a.dims (), d, nd))
     return retval;
 
   dim_vector rdv = dim_vector::alloc (nd);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, nidx, nd);
   octave_idx_type idxtot = 0;
   for (int i = 0; i < nd; i++)
     {
-      rdv(i) = nidx[i] = d[i].length ();
+      rdv(i) = nidx[i] = d[i].numel ();
       idxtot += nidx[i];
     }
 
   retval.clear (rdv);
 
   OCTAVE_LOCAL_BUFFER (octave_value, xidx, idxtot);
   OCTAVE_LOCAL_BUFFER (octave_value *, idx, nd);
 
@@ -2334,17 +2334,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
 // FIXME: it would be nice to allow ranges being handled without a conversion.
 template <class NDA>
 static Cell
 do_cellslices_nda (const NDA& array,
                    const Array<octave_idx_type>& lb,
                    const Array<octave_idx_type>& ub,
                    int dim = -1)
 {
-  octave_idx_type n = lb.length ();
+  octave_idx_type n = lb.numel ();
   Cell retval (1, n);
   if (array.is_vector () && (dim == -1
                              || (dim == 0 && array.columns () == 1)
                              || (dim == 1 && array.rows () == 1)))
     {
       for (octave_idx_type i = 0; i < n && ! error_state; i++)
         retval(i) = array.index (idx_vector (lb(i) - 1, ub(i)));
     }
@@ -2404,17 +2404,17 @@ slicing is done along the first non-sing
         {
           dim = args(3).int_value () - 1;
           if (dim < 0)
             error ("cellslices: DIM must be a valid dimension");
         }
 
       if (! error_state)
         {
-          if (lb.length () != ub.length ())
+          if (lb.numel () != ub.numel ())
             error ("cellslices: the lengths of LB and UB must match");
           else
             {
               Cell retcell;
               if (! x.is_sparse_type () && x.is_matrix_type ())
                 {
                   // specialize for some dense arrays.
                   if (x.is_bool_type ())
@@ -2467,17 +2467,17 @@ slicing is done along the first non-sing
                       else
                         retcell = do_cellslices_nda (x.array_value (),
                                                      lb, ub, dim);
                     }
                 }
               else
                 {
                   // generic code.
-                  octave_idx_type n = lb.length ();
+                  octave_idx_type n = lb.numel ();
                   retcell = Cell (1, n);
                   const dim_vector dv = x.dims ();
                   int ndims = dv.length ();
                   if (dim < 0)
                     dim = dv.first_non_singleton ();
                   ndims = std::max (ndims, dim + 1);
                   octave_value_list idx (ndims, octave_value::magic_colon_t);
                   for (octave_idx_type i = 0; i < n && ! error_state; i++)
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -90,17 +90,17 @@ daspk_user_function (const ColumnVector&
               warned_fcn_imaginary = true;
             }
 
           retval = ColumnVector (tmp(0).vector_value ());
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("daspk");
         }
       else
         gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
@@ -136,17 +136,17 @@ daspk_user_jacobian (const ColumnVector&
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("daspk");
         }
       else
         gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
@@ -292,19 +292,19 @@ parameters for @code{daspk}.\n\
       daspk_fcn = 0;
       daspk_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length () == 1)
+          if (c.numel () == 1)
             f_arg = c(0);
-          else if (c.length () == 2)
+          else if (c.numel () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 daspk_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__daspk_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -86,17 +86,17 @@ dasrt_user_f (const ColumnVector& x, con
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
           retval = ColumnVector (tmp(0).vector_value ());
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -126,17 +126,17 @@ dasrt_user_cf (const ColumnVector& x, do
           if (! warned_cf_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
               warned_cf_imaginary = true;
             }
 
           retval = ColumnVector (tmp(0).vector_value ());
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -172,17 +172,17 @@ dasrt_user_j (const ColumnVector& x, con
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -380,19 +380,19 @@ parameters for @code{dasrt}.\n\
 
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
       Cell c = f_arg.cell_value ();
-      if (c.length () == 1)
+      if (c.numel () == 1)
         f_arg = c(0);
-      else if (c.length () == 2)
+      else if (c.numel () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             dasrt_f = c(0).function_value ();
           else
             {
               fcn_name = unique_symbol_name ("__dasrt_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -90,17 +90,17 @@ dassl_user_function (const ColumnVector&
               warned_fcn_imaginary = true;
             }
 
           retval = ColumnVector (tmp(0).vector_value ());
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dassl");
         }
       else
         gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
@@ -136,17 +136,17 @@ dassl_user_jacobian (const ColumnVector&
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dassl");
         }
       else
         gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
@@ -293,19 +293,19 @@ parameters for @code{dassl}.\n\
       dassl_fcn = 0;
       dassl_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length () == 1)
+          if (c.numel () == 1)
             f_arg = c(0);
-          else if (c.length () == 2)
+          else if (c.numel () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 dassl_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__dassl_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2578,17 +2578,17 @@ do_permute (const octave_value_list& arg
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
     {
       Array<int> vec = args(1).int_vector_value ();
 
       // FIXME: maybe we should create an idx_vector object
       // here and pass that to permute?
 
-      int n = vec.length ();
+      int n = vec.numel ();
 
       for (int i = 0; i < n; i++)
         vec(i)--;
 
       octave_value ret = args(0).permute (vec, inv);
 
       if (! error_state)
         retval = ret;
@@ -5257,27 +5257,27 @@ do_linspace (const octave_value& base, c
       if (limit.is_scalar_type ())
         {
           T ls = octave_value_extract<T> (limit);
           retval = linspace (bs, ls, n);
         }
       else
         {
           CVT lv = octave_value_extract<CVT> (limit);
-          CVT bv (lv.length (), bs);
+          CVT bv (lv.numel (), bs);
           retval = linspace (bv, lv, n);
         }
     }
   else
     {
       CVT bv = octave_value_extract<CVT> (base);
       if (limit.is_scalar_type ())
         {
           T ls = octave_value_extract<T> (limit);
-          CVT lv (bv.length (), ls);
+          CVT lv (bv.numel (), ls);
           retval = linspace (bv, lv, n);
         }
       else
         {
           CVT lv = octave_value_extract<CVT> (limit);
           retval = linspace (bv, lv, n);
         }
     }
@@ -5427,17 +5427,17 @@ Resizing an object to fewer dimensions i
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       Array<double> vec = args(1).vector_value ();
-      int ndim = vec.length ();
+      int ndim = vec.numel ();
       if (ndim == 1)
         {
           octave_idx_type m = static_cast<octave_idx_type> (vec(0));
           retval = args(0);
           retval = retval.resize (dim_vector (m, m), true);
         }
       else
         {
@@ -5508,25 +5508,25 @@ the unspecified dimension.\n\
   int nargin = args.length ();
 
   dim_vector new_dims;
 
   if (nargin == 2)
     {
       Array<octave_idx_type> new_size = args(1).octave_idx_type_vector_value ();
 
-      if (new_size.length () < 2)
+      if (new_size.numel () < 2)
         {
           error ("reshape: SIZE must have 2 or more dimensions");
           return retval;
         }
 
-      new_dims = dim_vector::alloc (new_size.length ());
-
-      for (octave_idx_type i = 0; i < new_size.length (); i++)
+      new_dims = dim_vector::alloc (new_size.numel ());
+
+      for (octave_idx_type i = 0; i < new_size.numel (); i++)
         {
           if (new_size(i) < 0)
             {
               error ("reshape: SIZE must be non-negative");
               break;
             }
           else
             new_dims(i) = new_size(i);
@@ -8121,18 +8121,18 @@ dimensions of the decoded array.\n\
 
       if (nargin > 1)
         {
           const Array<octave_idx_type> size =
             args(1).octave_idx_type_vector_value ();
 
           if (! error_state)
             {
-              dims = dim_vector::alloc (size.length ());
-              for (octave_idx_type i = 0; i < size.length (); i++)
+              dims = dim_vector::alloc (size.numel ());
+              for (octave_idx_type i = 0; i < size.numel (); i++)
                 dims(i) = size(i);
             }
         }
 
       const std::string str = args(0).string_value ();
 
       if (! error_state)
         {
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -55,18 +55,18 @@ filter (MArray<FloatComplex>&, MArray<Fl
 
 template <class T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si,
         int dim = 0)
 {
   MArray<T> y;
 
-  octave_idx_type a_len  = a.length ();
-  octave_idx_type b_len  = b.length ();
+  octave_idx_type a_len  = a.numel ();
+  octave_idx_type b_len  = b.numel ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
   // FIXME: The two lines below should be unecessary because
   //        this template is called with a and b as column vectors
   //        already.  However the a.resize line is currently (2011/04/26)
   //        necessary to stop bug #33164.
   b.resize (dim_vector (ab_len, 1), 0.0);
@@ -270,18 +270,18 @@ filter (MArray<T>& b, MArray<T>& a, MArr
         dim = 0;
     }
   else if (dim < 0 || dim > x_dims.length ())
     {
       error ("filter: DIM must be a valid dimension");
       return MArray<T> ();
     }
 
-  octave_idx_type a_len = a.length ();
-  octave_idx_type b_len = b.length ();
+  octave_idx_type a_len = a.numel ();
+  octave_idx_type b_len = b.numel ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
 
   MArray<T> si (si_dims, T (0.0));
@@ -446,18 +446,18 @@ H(z) = ---------------------\n\
           FloatComplexNDArray x (args(2).float_complex_array_value ());
 
           if (! error_state)
             {
               FloatComplexNDArray si;
 
               if (nargin == 3 || args(3).is_empty ())
                 {
-                  octave_idx_type a_len = a.length ();
-                  octave_idx_type b_len = b.length ();
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
 
                   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
                   dim_vector si_dims = x.dims ();
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
@@ -494,18 +494,18 @@ H(z) = ---------------------\n\
           ComplexNDArray x (args(2).complex_array_value ());
 
           if (! error_state)
             {
               ComplexNDArray si;
 
               if (nargin == 3 || args(3).is_empty ())
                 {
-                  octave_idx_type a_len = a.length ();
-                  octave_idx_type b_len = b.length ();
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
 
                   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
                   dim_vector si_dims = x.dims ();
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
@@ -545,18 +545,18 @@ H(z) = ---------------------\n\
           FloatNDArray x (args(2).float_array_value ());
 
           if (! error_state)
             {
               FloatNDArray si;
 
               if (nargin == 3 || args(3).is_empty ())
                 {
-                  octave_idx_type a_len = a.length ();
-                  octave_idx_type b_len = b.length ();
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
 
                   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
                   dim_vector si_dims = x.dims ();
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
@@ -593,18 +593,18 @@ H(z) = ---------------------\n\
           NDArray x (args(2).array_value ());
 
           if (! error_state)
             {
               NDArray si;
 
               if (nargin == 3 || args(3).is_empty ())
                 {
-                  octave_idx_type a_len = a.length ();
-                  octave_idx_type b_len = b.length ();
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
 
                   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
                   dim_vector si_dims = x.dims ();
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -56,17 +56,17 @@ find_nonzero_elem_idx (const Array<T>& n
     default:
     case 3:
       retval(2) = Array<T> (nda.index (idx_vector (idx)));
       // Fall through!
 
     case 2:
       {
         Array<octave_idx_type> jdx (idx.dims ());
-        octave_idx_type n = idx.length ();
+        octave_idx_type n = idx.numel ();
         octave_idx_type nr = nda.rows ();
         for (octave_idx_type i = 0; i < n; i++)
           {
             jdx.xelem (i) = idx.xelem (i) / nr;
             idx.xelem (i) %= nr;
           }
         iext = -1;
         retval(1) = idx_vector (jdx, -1);
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -662,17 +662,17 @@ opengl_renderer::init_gl_context (bool e
   else
     {
       glDisable (GL_BLEND);
       glDisable (GL_LINE_SMOOTH);
     }
 
   // Clear background
 
-  if (c.length () >= 3)
+  if (c.numel () >= 3)
     {
       glClearColor (c(0), c(1), c(2), 1);
       glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     }
 }
 
 void
 opengl_renderer::render_grid (const std::string& gridstyle,
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -66,17 +66,17 @@ public:
   { }
 
   virtual ~opengl_renderer (void) { }
 
   virtual void draw (const graphics_object& go, bool toplevel = true);
 
   virtual void draw (const Matrix& hlist, bool toplevel = false)
   {
-    int len = hlist.length ();
+    int len = hlist.numel ();
 
     for (int i = len-1; i >= 0; i--)
       {
         graphics_object obj = gh_manager::get_object (hlist(i));
 
         if (obj)
           draw (obj, toplevel);
       }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9561,17 +9561,17 @@ gh_manager::do_execute_callback (const g
                && (cb.cell_value ()(0).is_function ()
                    || cb.cell_value ()(0).is_function_handle ()))
         {
           Cell c = cb.cell_value ();
 
           fcn = c(0).function_value ();
           if (! error_state)
             {
-              for (int i = 1; i < c.length () ; i++)
+              for (int i = 1; i < c.numel () ; i++)
                 args(1+i) = c(i);
             }
         }
       else
         {
           std::string nm = cb.class_name ();
           error ("trying to execute non-executable object (class = %s)",
                  nm.c_str ());
@@ -9860,17 +9860,17 @@ each individual object will be reset.\n\
   else
     {
       // get vector of graphics handles
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
           // loop over graphics objects
-          for (octave_idx_type n = 0; n < hcv.length (); n++)
+          for (octave_idx_type n = 0; n < hcv.numel (); n++)
             gh_manager::get_object (hcv(n)).reset_default_properties ();
 
           if (! error_state)
             Fdrawnow ();
         }
     }
 
   return octave_value ();
@@ -10075,39 +10075,39 @@ being @qcode{\"portrait\"}.\n\
       // get vector of graphics handles
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
           bool request_drawnow = false;
 
           // loop over graphics objects
-          for (octave_idx_type n = 0; n < hcv.length (); n++)
+          for (octave_idx_type n = 0; n < hcv.numel (); n++)
             {
               graphics_object obj = gh_manager::get_object (hcv(n));
 
               if (obj)
                 {
                   if (nargin == 3 && args(1).is_cellstr ()
                       && args(2).is_cell ())
                     {
                       if (args(2).cell_value ().rows () == 1)
                         {
                           obj.set (args(1).cellstr_value (),
                                    args(2).cell_value (), 0);
                         }
-                      else if (hcv.length () == args(2).cell_value ().rows ())
+                      else if (hcv.numel () == args(2).cell_value ().rows ())
                         {
                           obj.set (args(1).cellstr_value (),
                                    args(2).cell_value (), n);
                         }
                       else
                         {
                           error ("set: number of graphics handles must match number of value rows (%d != %d)",
-                                 hcv.length (), args(2).cell_value ().rows ());
+                                 hcv.numel (), args(2).cell_value ().rows ());
                           break;
 
                         }
                     }
                   else if (nargin == 2 && args(1).is_map ())
                     {
                       obj.set (args(1).map_value ());
                     }
@@ -10227,17 +10227,17 @@ lists respectively.\n\
           retval = Matrix ();
           return retval;
         }
 
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
-          octave_idx_type len = hcv.length ();
+          octave_idx_type len = hcv.numel ();
 
           if (nargin == 1 && len > 1)
             {
               std::string t0 = get_graphics_object_type (hcv(0));
 
               if (! error_state)
                 {
                   for (octave_idx_type n = 1; n < len; n++)
@@ -10391,17 +10391,17 @@ Undocumented internal function.\n\
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
-          octave_idx_type len = hcv.length ();
+          octave_idx_type len = hcv.numel ();
 
           vals.resize (dim_vector (len, 1));
 
           for (octave_idx_type n = 0; n < len; n++)
             {
               graphics_object obj = gh_manager::get_object (hcv(n));
 
               if (obj)
@@ -10625,17 +10625,17 @@ calc_dimensions (const graphics_object& 
     nd = 3;
   else if ((go.isa ("line") || go.isa ("patch"))
            && ! go.get ("zdata").is_empty ())
     nd = 3;
   else
     {
       Matrix kids = go.get_properties ().get_children ();
 
-      for (octave_idx_type i = 0; i < kids.length (); i++)
+      for (octave_idx_type i = 0; i < kids.numel (); i++)
         {
           graphics_handle hnd = gh_manager::lookup (kids(i));
 
           if (hnd.ok ())
             {
               const graphics_object& kid = gh_manager::get_object (hnd);
 
               if (kid.valid_object ())
@@ -11192,17 +11192,17 @@ undocumented.\n\
   frame.protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (args.length () == 0 || args.length () == 1)
         {
           Matrix hlist = gh_manager::figure_handle_list (true);
 
-          for (int i = 0; ! error_state && i < hlist.length (); i++)
+          for (int i = 0; ! error_state && i < hlist.numel (); i++)
             {
               graphics_handle h = gh_manager::lookup (hlist(i));
 
               if (h.ok () && h != 0)
                 {
                   graphics_object go = gh_manager::get_object (h);
                   figure::properties& fprops
                     = dynamic_cast <figure::properties&> (go.get_properties ());
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -531,20 +531,20 @@ public:
     else
       return octave_value (cell_value ());
   }
 
   std::string string_value (void) const
   {
     std::string s;
 
-    for (octave_idx_type i = 0; i < str.length (); i++)
+    for (octave_idx_type i = 0; i < str.numel (); i++)
       {
         s += str[i];
-        if (i != str.length () - 1)
+        if (i != str.numel () - 1)
           s += separator;
       }
 
     return s;
   }
 
   Cell cell_value (void) const {return Cell (str);}
 
@@ -631,19 +631,19 @@ protected:
       }
     else if (val.is_cellstr ())
       {
         bool replace = false;
         Cell new_cell = val.cell_value ();
 
         string_vector strings = new_cell.cellstr_value ();
 
-        octave_idx_type nel = strings.length ();
-
-        if (nel != str.length ())
+        octave_idx_type nel = strings.numel ();
+
+        if (nel != str.numel ())
           replace = true;
         else
           {
             for (octave_idx_type i = 0; i < nel; i++)
               {
                 if (strings[i] != str[i])
                   {
                     replace = true;
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -792,32 +792,32 @@ const static map_type operators_map (ope
 const static map_type keywords_map (keywords, keywords + size (keywords));
 const static string_vector keyword_names = names (keywords_map);
 
 // FIXME: It's not likely that this does the right thing now.
 
 string_vector
 make_name_list (void)
 {
-  const int key_len = keyword_names.length ();
+  const int key_len = keyword_names.numel ();
 
   const string_vector bif = symbol_table::built_in_function_names ();
-  const int bif_len = bif.length ();
+  const int bif_len = bif.numel ();
 
   const string_vector cfl = symbol_table::cmdline_function_names ();
-  const int cfl_len = cfl.length ();
+  const int cfl_len = cfl.numel ();
 
   const string_vector lcl = symbol_table::variable_names ();
-  const int lcl_len = lcl.length ();
+  const int lcl_len = lcl.numel ();
 
   const string_vector ffl = load_path::fcn_names ();
-  const int ffl_len = ffl.length ();
+  const int ffl_len = ffl.numel ();
 
   const string_vector afl = autoloaded_functions ();
-  const int afl_len = afl.length ();
+  const int afl_len = afl.numel ();
 
   const int total_len
     = key_len + bif_len + cfl_len + lcl_len + ffl_len + afl_len;
 
   string_vector list (total_len);
 
   // Put all the symbols in one big list.
 
@@ -1298,17 +1298,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   string_vector argv = args.make_argv ("which");
 
   if (! error_state)
     {
-      int argc = argv.length ();
+      int argc = argv.numel ();
 
       if (argc > 1)
         {
           octave_map m (dim_vector (1, argc-1));
 
           Cell names (1, argc-1);
           Cell files (1, argc-1);
           Cell types (1, argc-1);
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -237,17 +237,17 @@ num2hex (single ([-1, 1, e, Inf]))\n\
     print_usage ();
   else if (args(0).is_single_type ())
     {
       const FloatColumnVector v (args(0).float_vector_value ());
 
       if (! error_state)
         {
           octave_idx_type nchars = 8;
-          octave_idx_type nr = v.length ();
+          octave_idx_type nr = v.numel ();
           charMatrix m (nr, nchars);
           const float *pv = v.fortran_vec ();
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               union
               {
                 uint32_t ival;
@@ -274,17 +274,17 @@ num2hex (single ([-1, 1, e, Inf]))\n\
     }
   else
     {
       const ColumnVector v (args(0).vector_value ());
 
       if (! error_state)
         {
           octave_idx_type nchars = 16;
-          octave_idx_type nr = v.length ();
+          octave_idx_type nr = v.numel ();
           charMatrix m (nr, nchars);
           const double *pv = v.fortran_vec ();
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               union
               {
                 uint64_t ival;
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -403,23 +403,23 @@ generate_completion (const std::string& 
       // No reason to display symbols while completing a
       // file/directory operation.
 
       if (is_completing_dirfns ())
         name_list = string_vector ();
       else
         name_list = generate_possible_completions (text, prefix, hint);
 
-      name_list_len = name_list.length ();
+      name_list_len = name_list.numel ();
 
       file_name_list = command_editor::generate_filename_completions (text);
 
       name_list.append (file_name_list);
 
-      name_list_total_len = name_list.length ();
+      name_list_total_len = name_list.numel ();
 
       hint_len = hint.length ();
 
       matches = 0;
 
       for (int i = 0; i < name_list_len; i++)
         if (hint == name_list[i].substr (0, hint_len))
           matches++;
@@ -1093,17 +1093,17 @@ a feature, not a bug.\n\
                 retval = "";
             }
           else
             {
               // We don't use string_vector::list_in_columns here
               // because it will be easier for Emacs if the names
               // appear in a single column.
 
-              int len = list.length ();
+              int len = list.numel ();
 
               for (int i = 0; i < len; i++)
                 octave_stdout << list[i] << "\n";
             }
 
           octave_completion_matches_called = true;
         }
     }
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -175,17 +175,17 @@ void
 load_path::dir_info::get_file_list (const std::string& d)
 {
   dir_entry dir (d);
 
   if (dir)
     {
       string_vector flist = dir.read ();
 
-      octave_idx_type len = flist.length ();
+      octave_idx_type len = flist.numel ();
 
       all_files.resize (len);
       fcn_files.resize (len);
 
       octave_idx_type all_files_count = 0;
       octave_idx_type fcn_files_count = 0;
 
       for (octave_idx_type i = 0; i < len; i++)
@@ -245,17 +245,17 @@ get_fcn_files (const std::string& d)
   load_path::dir_info::fcn_file_map_type retval;
 
   dir_entry dir (d);
 
   if (dir)
     {
       string_vector flist = dir.read ();
 
-      octave_idx_type len = flist.length ();
+      octave_idx_type len = flist.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string fname = flist[i];
 
           std::string ext;
           std::string base = fname;
 
@@ -403,17 +403,17 @@ load_path::do_contains_canonical (const 
 
   return retval;
 }
 
 void
 load_path::loader::move_fcn_map (const std::string& dir_name,
                                  const string_vector& fcn_files, bool at_end)
 {
-  octave_idx_type len = fcn_files.length ();
+  octave_idx_type len = fcn_files.numel ();
 
   for (octave_idx_type k = 0; k < len; k++)
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
       std::string base = fname;
 
@@ -798,17 +798,17 @@ load_path::do_add (const std::string& di
   if (i != dir_info_list.end ())
     do_move (i, false);
 }
 
 void
 load_path::loader::remove_fcn_map (const std::string& dir,
                                    const string_vector& fcn_files)
 {
-  octave_idx_type len = fcn_files.length ();
+  octave_idx_type len = fcn_files.numel ();
 
   for (octave_idx_type k = 0; k < len; k++)
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
       std::string base = fname;
 
@@ -1368,17 +1368,17 @@ load_path::do_find_file (const std::stri
       // Look in cache.
 
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
           string_vector all_files = p->all_files;
 
-          octave_idx_type len = all_files.length ();
+          octave_idx_type len = all_files.numel ();
 
           for (octave_idx_type i = 0; i < len; i++)
             {
               if (all_files[i] == file)
                 return file_ops::concat (p->dir_name, file);
             }
         }
     }
@@ -1483,17 +1483,17 @@ load_path::do_find_matching_dirs (const 
 std::string
 load_path::do_find_first_of (const string_vector& flist) const
 {
   std::string retval;
 
   std::string dir_name;
   std::string file_name;
 
-  octave_idx_type flen = flist.length ();
+  octave_idx_type flen = flist.numel ();
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
@@ -1529,17 +1529,17 @@ load_path::do_find_first_of (const strin
   rel_flist.resize (rel_flen);
 
   for (const_dir_info_list_iterator p = dir_info_list.begin ();
        p != dir_info_list.end ();
        p++)
     {
       string_vector all_files = p->all_files;
 
-      octave_idx_type len = all_files.length ();
+      octave_idx_type len = all_files.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           for (octave_idx_type j = 0; j < rel_flen; j++)
             {
               if (all_files[i] == rel_flist[j])
                 {
                   dir_name = p->dir_name;
@@ -1562,17 +1562,17 @@ done:
 string_vector
 load_path::do_find_all_first_of (const string_vector& flist) const
 {
   std::list<std::string> retlist;
 
   std::string dir_name;
   std::string file_name;
 
-  octave_idx_type flen = flist.length ();
+  octave_idx_type flen = flist.numel ();
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
@@ -1607,17 +1607,17 @@ load_path::do_find_all_first_of (const s
 
   rel_flist.resize (rel_flen);
 
   for (const_dir_info_list_iterator p = dir_info_list.begin ();
        p != dir_info_list.end (); p++)
     {
       string_vector all_files = p->all_files;
 
-      octave_idx_type len = all_files.length ();
+      octave_idx_type len = all_files.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           for (octave_idx_type j = 0; j < rel_flen; j++)
             {
               if (all_files[i] == rel_flist[j])
                 retlist.push_back (file_ops::concat (p->dir_name,
                                                      rel_flist[j]));
@@ -1665,17 +1665,17 @@ load_path::do_files (const std::string& 
 
   const_dir_info_list_iterator p = find_dir_info (dir);
 
   if (p != dir_info_list.end ())
     retval = p->fcn_files;
 
   if (omit_exts)
     {
-      octave_idx_type len = retval.length ();
+      octave_idx_type len = retval.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string fname = retval[i];
 
           size_t pos = fname.rfind ('.');
 
           if (pos != std::string::npos)
@@ -1711,17 +1711,17 @@ load_path::loader::fcn_names (void) cons
 
 std::string
 load_path::do_path (void) const
 {
   std::string xpath;
 
   string_vector xdirs = load_path::dirs ();
 
-  octave_idx_type len = xdirs.length ();
+  octave_idx_type len = xdirs.numel ();
 
   if (len > 0)
     xpath = xdirs[0];
 
   for (octave_idx_type i = 1; i < len; i++)
     xpath += dir_path::path_sep_str () + xdirs[i];
 
   return xpath;
@@ -1888,17 +1888,17 @@ load_path::add (const dir_info& di, bool
 
 void
 load_path::loader::add_to_fcn_map (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
   string_vector fcn_files = di.fcn_files;
 
-  octave_idx_type len = fcn_files.length ();
+  octave_idx_type len = fcn_files.numel ();
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       std::string fname = fcn_files[i];
 
       std::string ext;
       std::string base = fname;
 
@@ -2145,28 +2145,28 @@ genpath (const std::string& dirname, con
   dir_entry dir (dirname);
 
   if (dir)
     {
       retval = dirname;
 
       string_vector dirlist = dir.read ().sort (false);
 
-      octave_idx_type len = dirlist.length ();
+      octave_idx_type len = dirlist.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string elt = dirlist[i];
 
           bool skip_p = (elt == "." || elt == ".." || elt[0] == '@'
                          || elt[0] == '+');
 
           if (! skip_p)
             {
-              for (octave_idx_type j = 0; j < skip.length (); j++)
+              for (octave_idx_type j = 0; j < skip.numel (); j++)
                 {
                   skip_p = (elt == skip[j]);
                   if (skip_p)
                     break;
                 }
 
               if (! skip_p)
                 {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1047,17 +1047,17 @@ save_vars (std::ostream& os, const std::
 }
 
 static string_vector
 parse_save_options (const string_vector &argv,
                     load_save_format &format, bool &append,
                     bool &save_as_floats, bool &use_zlib)
 {
   string_vector retval;
-  int argc = argv.length ();
+  int argc = argv.numel ();
 
   bool do_double = false;
   bool do_tabs = false;
 
   for (int i = 0; i < argc; i++)
     {
       if (argv[i] == "-append")
         {
@@ -1629,17 +1629,17 @@ the file @file{data} in Octave's binary 
 
   // get default options
   parse_save_options (Vsave_default_options, format, append, save_as_floats,
                       use_zlib);
 
   // override from command line
   argv = parse_save_options (argv, format, append, save_as_floats,
                              use_zlib);
-  int argc = argv.length ();
+  int argc = argv.numel ();
   int i = 0;
 
   if (error_state)
     return retval;
 
   if (i == argc)
     {
       print_usage ();
diff --git a/libinterp/corefcn/ls-oct-ascii.h b/libinterp/corefcn/ls-oct-ascii.h
--- a/libinterp/corefcn/ls-oct-ascii.h
+++ b/libinterp/corefcn/ls-oct-ascii.h
@@ -153,17 +153,17 @@ extract_keyword (std::istream& is, const
           if (isalpha (c))
             buf << c;
 
           while (is.get (c) && isalpha (c))
             buf << c;
 
           std::string tmp = buf.str ();
 
-          for (int i = 0; i < keywords.length (); i++)
+          for (int i = 0; i < keywords.numel (); i++)
             {
               int match = (tmp == keywords[i]);
 
               if (match)
                 {
                   kw = keywords[i];
 
                   while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -83,17 +83,17 @@ lsode_user_function (const ColumnVector&
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
           retval = ColumnVector (tmp(0).vector_value ());
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("lsode");
         }
       else
         gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
@@ -122,17 +122,17 @@ lsode_user_jacobian (const ColumnVector&
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.length () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("lsode");
         }
       else
         gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
@@ -295,19 +295,19 @@ parameters for @code{lsode}.\n\
       lsode_fcn = 0;
       lsode_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length () == 1)
+          if (c.numel () == 1)
             f_arg = c(0);
-          else if (c.length () == 2)
+          else if (c.numel () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 lsode_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__lsode_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -287,17 +287,17 @@ LU@tie{}factorization.  Once the matrix 
                         {
                           const ColumnVector perm =
                             ColumnVector (args(2).vector_value ());
 
                           if (error_state)
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
-                              octave_idx_type len = perm.length ();
+                              octave_idx_type len = perm.numel ();
                               dim_vector dv = args(0).dims ();
 
                               if (len != dv(0))
                                 error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
@@ -460,17 +460,17 @@ LU@tie{}factorization.  Once the matrix 
                         {
                           const ColumnVector perm =
                             ColumnVector (args(2).vector_value ());
 
                           if (error_state)
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
-                              octave_idx_type len = perm.length ();
+                              octave_idx_type len = perm.numel ();
                               dim_vector dv = args(0).dims ();
 
                               if (len != dv(0))
                                 error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -245,17 +245,17 @@ do_history (const octave_value_list& arg
 
               return  hlist;
             }
         }
     }
 
   hlist = command_history::list (limit, numbered_output);
 
-  int len = hlist.length ();
+  int len = hlist.numel ();
 
   if (nargout == 0)
     {
       for (octave_idx_type i = 0; i < len; i++)
         octave_stdout << hlist[i] << "\n";
     }
 
   return hlist;
@@ -355,17 +355,17 @@ get_int_arg (const octave_value& arg, in
 static std::string
 mk_tmp_hist_file (const octave_value_list& args,
                   bool insert_curr, const char *warn_for)
 {
   std::string retval;
 
   string_vector hlist = command_history::list ();
 
-  int hist_count = hlist.length () - 1;  // switch to zero-based indexing
+  int hist_count = hlist.numel () - 1;  // switch to zero-based indexing
 
   // The current command line is already part of the history list by
   // the time we get to this point.  Delete the cmd from the list when
   // executing 'edit_history' so that it doesn't show up in the history
   // but the actual commands performed will.
 
   if (! insert_curr)
     command_history::remove (hist_count);
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -137,17 +137,17 @@ octave_fields::equal_up_to_order (const 
   return retval;
 }
 
 bool
 octave_fields::equal_up_to_order (const octave_fields& other,
                                   Array<octave_idx_type>& perm) const
 {
   octave_idx_type n = nfields ();
-  if (perm.length () != n)
+  if (perm.numel () != n)
     perm.clear (1, n);
 
   return equal_up_to_order (other, perm.fortran_vec ());
 }
 
 string_vector
 octave_fields::fieldnames (void) const
 {
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -156,17 +156,17 @@ octave_scalar_map
 public:
 
   octave_scalar_map (const octave_fields& k)
     : xkeys (k), xvals (k.nfields ()) { }
 
   octave_scalar_map (void) : xkeys (), xvals () { }
 
   octave_scalar_map (const string_vector& k)
-    : xkeys (k), xvals (k.length ()) { }
+    : xkeys (k), xvals (k.numel ()) { }
 
   octave_scalar_map (const octave_scalar_map& m)
     : xkeys (m.xkeys), xvals(m.xvals) { }
 
   octave_scalar_map& operator = (const octave_scalar_map& m)
   {
     xkeys = m.xkeys;
     xvals = m.xvals;
@@ -272,20 +272,20 @@ public:
 
   typedef octave_scalar_map element_type;
 
   octave_map (void) : xkeys (), xvals (), dimensions () { }
 
   octave_map (const dim_vector& dv) : xkeys (), xvals (), dimensions (dv) { }
 
   octave_map (const string_vector& k)
-    : xkeys (k), xvals (k.length (), Cell (1, 1)), dimensions (1, 1) { }
+    : xkeys (k), xvals (k.numel (), Cell (1, 1)), dimensions (1, 1) { }
 
   octave_map (const dim_vector& dv, const string_vector& k)
-    : xkeys (k), xvals (k.length (), Cell (dv)), dimensions (dv) { }
+    : xkeys (k), xvals (k.numel (), Cell (dv)), dimensions (dv) { }
 
   octave_map (const octave_map& m)
     : xkeys (m.xkeys), xvals (m.xvals), dimensions (m.dimensions) { }
 
   octave_map (const octave_scalar_map& m);
 
   octave_map& operator = (const octave_map& m)
   {
diff --git a/libinterp/corefcn/oct-obj.h b/libinterp/corefcn/oct-obj.h
--- a/libinterp/corefcn/oct-obj.h
+++ b/libinterp/corefcn/oct-obj.h
@@ -81,17 +81,17 @@ public:
   Cell cell_value (void) const { return array_value (); }
 
   // Assignment will resize on range errors.
 
   octave_value& operator () (octave_idx_type n) { return elem (n); }
 
   const octave_value& operator () (octave_idx_type n) const { return elem (n); }
 
-  octave_idx_type length (void) const { return data.length (); }
+  octave_idx_type length (void) const { return data.numel (); }
 
   bool empty (void) const { return length () == 0; }
 
   void resize (octave_idx_type n, const octave_value& rfv = octave_value ())
   {
     data.resize (dim_vector (1, n), rfv);
   }
 
@@ -108,19 +108,19 @@ public:
   {
     // linear_slice uses begin/end indices instead of offset and
     // length.  Avoid calling with upper bound out of range.
     // linear_slice handles the case of len < 0.
 
     octave_value_list retval
       = data.linear_slice (offset, std::min (offset + len, length ()));
 
-    if (tags && len > 0 && names.length () > 0)
+    if (tags && len > 0 && names.numel () > 0)
       retval.names = names.linear_slice (offset, std::min (offset + len,
-                                                           names.length ()));
+                                                           names.numel ()));
 
     return retval;
   }
 
   octave_value_list
   splice (octave_idx_type offset, octave_idx_type len,
           const octave_value_list& lst = octave_value_list ()) const;
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -118,17 +118,17 @@ get_size (const Array<double>& size, oct
   nr = -1;
   nc = -1;
 
   one_elt_size_spec = false;
 
   double dnr = -1.0;
   double dnc = -1.0;
 
-  octave_idx_type sz_len = size.length ();
+  octave_idx_type sz_len = size.numel ();
 
   if (sz_len == 1)
     {
       one_elt_size_spec = true;
 
       dnr = size (0);
 
       dnc = (dnr == 0.0) ? 0.0 : 1.0;
@@ -230,17 +230,17 @@ scanf_format_list::scanf_format_list (co
 
   list.resize (dim_vector (num_elts, 1));
 
   delete buf;
 }
 
 scanf_format_list::~scanf_format_list (void)
 {
-  octave_idx_type n = list.length ();
+  octave_idx_type n = list.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       scanf_format_elt *elt = list(i);
       delete elt;
     }
 }
 
@@ -254,17 +254,17 @@ scanf_format_list::add_elt_to_list (int 
       std::string text = buf->str ();
 
       if (! text.empty ())
         {
           scanf_format_elt *elt
             = new scanf_format_elt (text.c_str (), width, discard, type,
                                     modifier, char_class);
 
-          if (num_elts == list.length ())
+          if (num_elts == list.numel ())
             list.resize (dim_vector (2 * num_elts, 1));
 
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
     }
@@ -484,17 +484,17 @@ scanf_format_list::finish_conversion (co
     }
 
   return retval;
 }
 
 void
 scanf_format_list::printme (void) const
 {
-  octave_idx_type n = list.length ();
+  octave_idx_type n = list.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       scanf_format_elt *elt = list(i);
 
       std::cerr
         << "width:      " << elt->width << "\n"
         << "discard:    " << elt->discard << "\n"
@@ -512,17 +512,17 @@ scanf_format_list::printme (void) const
         << "char_class: '" << undo_string_escapes (elt->char_class) << "'\n"
         << "text:       '" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 bool
 scanf_format_list::all_character_conversions (void)
 {
-  octave_idx_type n = list.length ();
+  octave_idx_type n = list.numel ();
 
   if (n > 0)
     {
       for (octave_idx_type i = 0; i < n; i++)
         {
           scanf_format_elt *elt = list(i);
 
           switch (elt->type)
@@ -542,17 +542,17 @@ scanf_format_list::all_character_convers
     }
   else
     return false;
 }
 
 bool
 scanf_format_list::all_numeric_conversions (void)
 {
-  octave_idx_type n = list.length ();
+  octave_idx_type n = list.numel ();
 
   if (n > 0)
     {
       for (octave_idx_type i = 0; i < n; i++)
         {
           scanf_format_elt *elt = list(i);
 
           switch (elt->type)
@@ -659,17 +659,17 @@ printf_format_list::printf_format_list (
       list.resize (dim_vector (num_elts, 1));
 
       delete buf;
     }
 }
 
 printf_format_list::~printf_format_list (void)
 {
-  octave_idx_type n = list.length ();
+  octave_idx_type n = list.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
       delete elt;
     }
 }
 
@@ -683,17 +683,17 @@ printf_format_list::add_elt_to_list (int
       std::string text = buf->str ();
 
       if (! text.empty ())
         {
           printf_format_elt *elt
             = new printf_format_elt (text.c_str (), args, fw, prec, flags,
                                      type, modifier);
 
-          if (num_elts == list.length ())
+          if (num_elts == list.numel ())
             list.resize (dim_vector (2 * num_elts, 1));
 
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
     }
@@ -866,17 +866,17 @@ printf_format_list::finish_conversion (c
       nconv = -1;
       break;
     }
 }
 
 void
 printf_format_list::printme (void) const
 {
-  int n = list.length ();
+  int n = list.numel ();
 
   for (int i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
 
       std::cerr
         << "args:     " << elt->args << "\n"
         << "flags:    '" << elt->flags << "'\n"
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -111,32 +111,32 @@ public:
 
   octave_idx_type num_conversions (void) { return nconv; }
 
   // The length can be different than the number of conversions.
   // For example, "x %d y %d z" has 2 conversions but the length of
   // the list is 3 because of the characters that appear after the
   // last conversion.
 
-  octave_idx_type length (void) { return list.length (); }
+  octave_idx_type length (void) { return list.numel (); }
 
   const scanf_format_elt *first (void)
   {
     curr_idx = 0;
     return current ();
   }
 
   const scanf_format_elt *current (void) const
-  { return list.length () > 0 ? list.elem (curr_idx) : 0; }
+  { return list.numel () > 0 ? list.elem (curr_idx) : 0; }
 
   const scanf_format_elt *next (bool cycle = true)
   {
     curr_idx++;
 
-    if (curr_idx >= list.length ())
+    if (curr_idx >= list.numel ())
       {
         if (cycle)
           curr_idx = 0;
         else
           return 0;
       }
     return current ();
   }
@@ -255,34 +255,34 @@ public:
 
   const printf_format_elt *first (void)
   {
     curr_idx = 0;
     return current ();
   }
 
   const printf_format_elt *current (void) const
-  { return list.length () > 0 ? list.elem (curr_idx) : 0; }
+  { return list.numel () > 0 ? list.elem (curr_idx) : 0; }
 
   const printf_format_elt *next (bool cycle = true)
   {
     curr_idx++;
 
-    if (curr_idx >= list.length ())
+    if (curr_idx >= list.numel ())
       {
         if (cycle)
           curr_idx = 0;
         else
           return 0;
       }
 
     return current ();
   }
 
-  bool last_elt_p (void) { return (curr_idx + 1 == list.length ()); }
+  bool last_elt_p (void) { return (curr_idx + 1 == list.numel ()); }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
   operator bool () const { return ok (); }
 
 private:
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2881,17 +2881,17 @@ void
 octave_print_internal (std::ostream& os, const Array<std::string>& nda,
                        bool pr_as_read_syntax, int /* extra_indent */)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
-  else if (nda.length () == 1)
+  else if (nda.numel () == 1)
     {
       os << nda(0);
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
@@ -3150,17 +3150,17 @@ template <class T>
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
                                 bool pr_as_read_syntax, int extra_indent)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
-  else if (nda.length () == 1)
+  else if (nda.numel () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
 
       Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);
 
       dim_vector dims = nda.dims ();
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1708,17 +1708,17 @@ Mathematical Software, Vol. 37, Issue 3,
       fargs(0) = ex;
       fvals = feval (fcn, fargs, 1);
       if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
         {
           error ("quadcc: integrand F must return a single, real-valued vector");
           return retval;
         }
       Matrix effex = fvals(0).matrix_value ();
-      if (effex.length () != ex.length ())
+      if (effex.numel () != ex.numel ())
         {
           error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
           return retval;
         }
       for (i = 0; i <= n[3]; i++)
         {
           iv->fx[i] = effex(i);
           if (wrap)
@@ -1827,22 +1827,22 @@ Mathematical Software, Vol. 37, Issue 3,
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector");
                 return retval;
               }
             Matrix effex = fvals(0).matrix_value ();
-            if (effex.length () != ex.length ())
+            if (effex.numel () != ex.numel ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
                 return retval;
               }
-            neval += effex.length ();
+            neval += effex.numel ();
             for (i = 0; i < n[d] / 2; i++)
               {
                 j = (2 * i + 1) * skip[d];
                 iv->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
                     iv->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
@@ -1975,22 +1975,22 @@ Mathematical Software, Vol. 37, Issue 3,
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector");
                 return retval;
               }
             Matrix effex = fvals(0).matrix_value ();
-            if (effex.length () != ex.length ())
+            if (effex.numel () != ex.numel ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
                 return retval;
               }
-            neval += effex.length ();
+            neval += effex.numel ();
             for (i = 0; i < n[0] - 1; i++)
               {
                 j = (i + 1) * skip[0];
                 ivl->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
                     ivl->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
@@ -2071,22 +2071,22 @@ Mathematical Software, Vol. 37, Issue 3,
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector");
                 return retval;
               }
             Matrix effex = fvals(0).matrix_value ();
-            if (effex.length () != ex.length ())
+            if (effex.numel () != ex.numel ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
                 return retval;
               }
-            neval += effex.length ();
+            neval += effex.numel ();
             for (i = 0; i < n[0] - 1; i++)
               {
                 j = (i + 1) * skip[0];
                 ivr->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
                     ivr->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -213,17 +213,17 @@ do_rand (const octave_value_list& args, 
                      fcn);
           }
         else if (tmp.is_matrix_type ())
           {
             Array<int> iv = tmp.int_vector_value (true);
 
             if (! error_state)
               {
-                octave_idx_type len = iv.length ();
+                octave_idx_type len = iv.numel ();
 
                 dims.resize (len);
 
                 for (octave_idx_type i = 0; i < len; i++)
                   {
                     //Negative dimensions are treated as zero for Matlab
                     //compatibility
                     octave_idx_type elt = iv(i);
@@ -312,50 +312,50 @@ done:
 gen_matrix:
 
   dims.chop_trailing_singletons ();
 
   if (is_single)
     {
       if (additional_arg)
         {
-          if (a.length () == 1)
+          if (a.numel () == 1)
             return octave_rand::float_nd_array (dims, a(0));
           else
             {
               if (a.dims () != dims)
                 {
                   error ("%s: mismatch in argument size", fcn);
                   return retval;
                 }
-              octave_idx_type len = a.length ();
+              octave_idx_type len = a.numel ();
               FloatNDArray m (dims);
               float *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
                 v[i] = octave_rand::float_scalar (a(i));
               return m;
             }
         }
       else
         return octave_rand::float_nd_array (dims);
     }
   else
     {
       if (additional_arg)
         {
-          if (a.length () == 1)
+          if (a.numel () == 1)
             return octave_rand::nd_array (dims, a(0));
           else
             {
               if (a.dims () != dims)
                 {
                   error ("%s: mismatch in argument size", fcn);
                   return retval;
                 }
-              octave_idx_type len = a.length ();
+              octave_idx_type len = a.numel ();
               NDArray m (dims);
               double *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
                 v[i] = octave_rand::scalar (a(i));
               return m;
             }
         }
       else
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -363,24 +363,24 @@ octregexp (const octave_value_list &args
       octave_scalar_map nmap;
 
       retval.resize (7);
 
       if (sz == 1)
         {
           string_vector named_tokens = rx_lst.begin ()->named_tokens ();
 
-          for (int j = 0; j < named_pats.length (); j++)
+          for (int j = 0; j < named_pats.numel (); j++)
             nmap.assign (named_pats(j), named_tokens(j));
 
           retval(5) = nmap;
         }
       else
         {
-          for (int j = 0; j < named_pats.length (); j++)
+          for (int j = 0; j < named_pats.numel (); j++)
             {
               Cell tmp (dim_vector (1, sz));
 
               i = 0;
               for (regexp::match_data::const_iterator p = rx_lst.begin ();
                    p != rx_lst.end (); p++)
                 {
                   string_vector named_tokens = p->named_tokens ();
@@ -435,17 +435,17 @@ octregexp (const octave_value_list &args
           i = 0;
           for (regexp::match_data::const_iterator p = rx_lst.begin ();
                p != rx_lst.end (); p++)
             {
               double s = p->start ();
               double e = p->end ();
 
               string_vector tmp = p->tokens ();
-              tokens(i) = Cell (dim_vector (1, tmp.length ()), tmp);
+              tokens(i) = Cell (dim_vector (1, tmp.numel ()), tmp);
               match_string(i) = p->match_string ();
               token_extents(i) = p->token_extents ();
               end(i) = e;
               start(i) = s;
               split(i) = buffer.substr (sp_start, s-sp_start-1);
               sp_start = e;
               i++;
             }
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -98,18 +98,18 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
           string_vector s = args(i).all_strings ();
 
           if (error_state)
             {
               error ("char: unable to convert some args to strings");
               return retval;
             }
 
-          if (s.length () > 0)
-            n_elts += s.length ();
+          if (s.numel () > 0)
+            n_elts += s.numel ();
           else
             n_elts += 1;
 
           int s_max_len = s.max_length ();
 
           if (s_max_len > max_len)
             max_len = s_max_len;
 
@@ -120,17 +120,17 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
 
       int k = 0;
 
       for (int i = 0; i < nargin; i++)
         {
           string_vector s = args_as_strings.front ();
           args_as_strings.pop ();
 
-          int n = s.length ();
+          int n = s.numel ();
 
           if (n > 0)
             {
               for (int j = 0; j < n; j++)
                 {
                   std::string t = s[j];
                   int t_len = t.length ();
 
@@ -219,17 +219,17 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
       string_vector s = args(i).all_strings ();
 
       if (error_state)
         {
           error ("strvcat: unable to convert some args to strings");
           return retval;
         }
 
-      size_t n = s.length ();
+      size_t n = s.numel ();
 
       // do not count empty strings in calculation of number of elements
       if (n > 0)
         {
           for (size_t j = 0; j < n; j++)
             {
               if (s[j].length () > 0)
                 n_elts++;
@@ -248,17 +248,17 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
 
   octave_idx_type k = 0;
 
   for (int i = 0; i < nargin; i++)
     {
       string_vector s = args_as_strings.front ();
       args_as_strings.pop ();
 
-      size_t n = s.length ();
+      size_t n = s.numel ();
 
       if (n > 0)
         {
           for (size_t j = 0; j < n; j++)
             {
               std::string t = s[j];
               if (t.length () > 0)
                 {
@@ -360,47 +360,47 @@ do_strcmp_fun (const octave_value& arg0,
       else
         {
           str_val = arg1;
           cell_val = arg0;
         }
 
       const Cell cell = cell_val.cell_value ();
       const string_vector str = str_val.all_strings ();
-      octave_idx_type r = str.length ();
+      octave_idx_type r = str.numel ();
 
       if (r == 0 || r == 1)
         {
           // Broadcast the string.
 
           boolNDArray output (cell_val.dims (), false);
 
           std::string s = r == 0 ? std::string () : str[0];
 
           if (cell_val.is_cellstr ())
             {
               const Array<std::string> cellstr = cell_val.cellstr_value ();
-              for (octave_idx_type i = 0; i < cellstr.length (); i++)
+              for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                 output(i) = str_op (cellstr(i), s, n);
             }
           else
             {
               // FIXME: should we warn here?
-              for (octave_idx_type i = 0; i < cell.length (); i++)
+              for (octave_idx_type i = 0; i < cell.numel (); i++)
                 {
                   if (cell(i).is_string ())
                     output(i) = str_op (cell(i).string_value (), s, n);
                 }
             }
 
           retval = output;
         }
       else if (r > 1)
         {
-          if (cell.length () == 1)
+          if (cell.numel () == 1)
             {
               // Broadcast the cell.
 
               const dim_vector dv (r, 1);
               boolNDArray output (dv, false);
 
               if (cell(0).is_string ())
                 {
@@ -413,23 +413,23 @@ do_strcmp_fun (const octave_value& arg0,
               retval = output;
             }
           else
             {
               // Must match in all dimensions.
 
               boolNDArray output (cell.dims (), false);
 
-              if (cell.length () == r)
+              if (cell.numel () == r)
                 {
                   if (cell_val.is_cellstr ())
                     {
                       const Array<std::string> cellstr
                         = cell_val.cellstr_value ();
-                      for (octave_idx_type i = 0; i < cellstr.length (); i++)
+                      for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                         output(i) = str_op (str[i], cellstr(i), n);
                     }
                   else
                     {
                       // FIXME: should we warn here?
                       for (octave_idx_type i = 0; i < r; i++)
                         {
                           if (cell(i).is_string ())
@@ -479,17 +479,17 @@ do_strcmp_fun (const octave_value& arg0,
 
           if (cell2(0).is_string ())
             {
               const std::string str2 = cell2(0).string_value ();
 
               if (cell1_val.is_cellstr ())
                 {
                   const Array<std::string> cellstr = cell1_val.cellstr_value ();
-                  for (octave_idx_type i = 0; i < cellstr.length (); i++)
+                  for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                     output(i) = str_op (cellstr(i), str2, n);
                 }
               else
                 {
                   // FIXME: should we warn here?
                   for (octave_idx_type i = 0; i < r1; i++)
                     {
                       if (cell1(i).is_string ())
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 
 
 static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
   RowVector dimsv = val.row_vector_value (false, true);
   dim_vector dv;
-  octave_idx_type n = dimsv.length ();
+  octave_idx_type n = dimsv.numel ();
 
   if (n < 1)
     error ("%s: dimension vector DIMS must not be empty", name);
   else
     {
       dv.resize (std::max (n, static_cast<octave_idx_type> (2)));
       dv(1) = 1;
       for (octave_idx_type i = 0; i < n; i++)
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2047,34 +2047,34 @@ public:
 
     return retval;
   }
 
   static std::list<symbol_record> glob_variables (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
-    size_t len = patterns.length ();
+    size_t len = patterns.numel ();
 
     for (size_t i = 0; i < len; i++)
       {
         std::list<symbol_record> tmp = glob_variables (patterns[i]);
 
         retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
     return retval;
   }
 
   static std::list<symbol_record> regexp_variables
     (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
-    size_t len = patterns.length ();
+    size_t len = patterns.numel ();
 
     for (size_t i = 0; i < len; i++)
       {
         std::list<symbol_record> tmp = regexp_variables (patterns[i]);
 
         retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -199,17 +199,17 @@ error message.\n\
           string_vector exec_args;
 
           if (nargin == 2)
             {
               string_vector tmp = args(1).all_strings ();
 
               if (! error_state)
                 {
-                  int len = tmp.length ();
+                  int len = tmp.numel ();
 
                   exec_args.resize (len + 1);
 
                   exec_args[0] = exec_file;
 
                   for (int i = 0; i < len; i++)
                     exec_args[i+1] = tmp[i];
                 }
@@ -311,17 +311,17 @@ exit status, it will linger until Octave
           string_vector arg_list;
 
           if (nargin >= 2)
             {
               string_vector tmp = args(1).all_strings ();
 
               if (! error_state)
                 {
-                  int len = tmp.length ();
+                  int len = tmp.numel ();
 
                   arg_list.resize (len + 1);
 
                   arg_list[0] = exec_file;
 
                   for (int i = 0; i < len; i++)
                     arg_list[i+1] = tmp[i];
                 }
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -98,17 +98,17 @@ convex hull, @var{idx} is NaN.\n\
   for (octave_idx_type k = 0; k < nelem; k++)
     {
       minx(k) = min (REF (x, k, 0), REF (x, k, 1), REF (x, k, 2)) - eps;
       maxx(k) = max (REF (x, k, 0), REF (x, k, 1), REF (x, k, 2)) + eps;
       miny(k) = min (REF (y, k, 0), REF (y, k, 1), REF (y, k, 2)) - eps;
       maxy(k) = max (REF (y, k, 0), REF (y, k, 1), REF (y, k, 2)) + eps;
     }
 
-  const octave_idx_type np = xi.length ();
+  const octave_idx_type np = xi.numel ();
   ColumnVector values (np);
 
   double x0, y0, a11, a12, a21, a22, det;
   x0 = y0 = 0.0;
   a11 = a12 = a21 = a22 = 0.0;
   det = 0.0;
 
   octave_idx_type k = nelem; // k is a counter of elements
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -707,17 +707,17 @@ Undocumented internal function\n\
 
       if (curl.is_valid ())
         {
           if (nargout == 0)
             curl.dir ();
           else
             {
               string_vector sv = curl.list ();
-              octave_idx_type n = sv.length ();
+              octave_idx_type n = sv.numel ();
 
               if (n == 0)
                 {
                   string_vector flds (5);
 
                   flds(0) = "name";
                   flds(1) = "date";
                   flds(2) = "bytes";
@@ -1045,17 +1045,17 @@ Undocumented internal function\n\
 
           if (! error_state)
             {
               string_vector file_list;
 
               glob_match pattern (file_ops::tilde_expand (pat));
               string_vector files = pattern.glob ();
 
-              for (octave_idx_type i = 0; i < files.length (); i++)
+              for (octave_idx_type i = 0; i < files.numel (); i++)
                 {
                   std::string file = files (i);
 
                   file_stat fs (file);
 
                   if (! fs.exists ())
                     {
                       error ("__ftp__mput: file does not exist");
@@ -1140,17 +1140,17 @@ Undocumented internal function\n\
 
           if (! error_state)
             {
               string_vector sv = curl.list ();
               octave_idx_type n = 0;
               glob_match pattern (file);
 
 
-              for (octave_idx_type i = 0; i < sv.length (); i++)
+              for (octave_idx_type i = 0; i < sv.numel (); i++)
                 {
                   if (pattern.match (sv(i)))
                     {
                       n++;
 
                       time_t ftime;
                       bool fisdir;
                       double fsize;
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -262,28 +262,28 @@ search_path_for_file (const std::string&
 
 string_vector
 search_path_for_all_files (const std::string& path, const string_vector& names)
 {
   dir_path p (path);
 
   string_vector sv = p.find_all_first_of (names);
 
-  octave_idx_type len = sv.length ();
+  octave_idx_type len = sv.numel ();
 
   for (octave_idx_type i = 0; i < len; i++)
     sv[i] = octave_env::make_absolute (sv[i]);
 
   return sv;
 }
 
 static string_vector
 make_absolute (const string_vector& sv)
 {
-  octave_idx_type len = sv.length ();
+  octave_idx_type len = sv.numel ();
 
   string_vector retval (len);
 
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = octave_env::make_absolute (sv[i]);
 
   return retval;
 }
@@ -311,17 +311,17 @@ If no files are found, return an empty c
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       string_vector names = args(0).all_strings ();
 
-      if (! error_state && names.length () > 0)
+      if (! error_state && names.numel () > 0)
         {
           if (nargin == 1)
             retval =
               octave_env::make_absolute (load_path::find_first_of (names));
           else if (nargin == 2)
             {
               std::string opt = args(1).string_value ();
 
@@ -394,17 +394,17 @@ If no files are found, return an empty c
   if (nargin == 2 || nargin == 3)
     {
       if (args(0).is_string ())
         {
           std::string path = args(0).string_value ();
 
           string_vector names = args(1).all_strings ();
 
-          if (! error_state && names.length () > 0)
+          if (! error_state && names.numel () > 0)
             {
               if (nargin == 2)
                 retval = search_path_for_file (path, names);
               else if (nargin == 3)
                 {
                   std::string opt = args(2).string_value ();
 
                   if (! error_state && opt == "all")
@@ -1213,17 +1213,17 @@ get_dimensions (const octave_value& a, c
 
       if (nr == 1 || nc == 1)
         {
           Array<double> v = a.vector_value ();
 
           if (error_state)
             return;
 
-          octave_idx_type n = v.length ();
+          octave_idx_type n = v.numel ();
           dim.resize (n);
           for (octave_idx_type i = 0; i < n; i++)
             dim(i) = static_cast<int> (fix (v(i)));
         }
       else
         error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -2212,17 +2212,17 @@ do_clear_functions (const string_vector&
   if (idx == argc)
     symbol_table::clear_functions ();
   else
     {
       if (exclusive)
         {
           string_vector fcns = symbol_table::user_function_names ();
 
-          int fcount = fcns.length ();
+          int fcount = fcns.numel ();
 
           for (int i = 0; i < fcount; i++)
             {
               std::string nm = fcns[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx))
                 symbol_table::clear_function (nm);
             }
@@ -2238,28 +2238,28 @@ do_clear_functions (const string_vector&
 static void
 do_clear_globals (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
   if (idx == argc)
     {
       string_vector gvars = symbol_table::global_variable_names ();
 
-      int gcount = gvars.length ();
+      int gcount = gvars.numel ();
 
       for (int i = 0; i < gcount; i++)
         symbol_table::clear_global (gvars[i]);
     }
   else
     {
       if (exclusive)
         {
           string_vector gvars = symbol_table::global_variable_names ();
 
-          int gcount = gvars.length ();
+          int gcount = gvars.numel ();
 
           for (int i = 0; i < gcount; i++)
             {
               std::string nm = gvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx))
                 symbol_table::clear_global (nm);
             }
@@ -2279,17 +2279,17 @@ do_clear_variables (const string_vector&
   if (idx == argc)
     symbol_table::clear_variables ();
   else
     {
       if (exclusive)
         {
           string_vector lvars = symbol_table::variable_names ();
 
-          int lcount = lvars.length ();
+          int lcount = lvars.numel ();
 
           for (int i = 0; i < lcount; i++)
             {
               std::string nm = lvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx, have_regexp))
                 symbol_table::clear_variable (nm);
             }
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -284,59 +284,59 @@ x_el_div (const Complex a, const Complex
 //   complex N-d array | 2 |  4 |
 //                     +---+----+
 
 NDArray
 x_el_div (double a, const NDArray& b)
 {
   NDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (const Complex a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (const Complex a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
@@ -585,59 +585,59 @@ x_el_div (const FloatComplex a, const Fl
 //   complex N-d array | 2 |  4 |
 //                     +---+----+
 
 FloatNDArray
 x_el_div (float a, const FloatNDArray& b)
 {
   FloatNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 FloatComplexNDArray
 x_el_div (float a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 FloatComplexNDArray
 x_el_div (const FloatComplex a, const FloatNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 FloatComplexNDArray
 x_el_div (const FloatComplex a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result (i) = a / b (i);
     }
 
   return result;
 }
 
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -1116,28 +1116,28 @@ octave_value
 elem_xpow (double a, const NDArray& b)
 {
   octave_value retval;
 
   if (a < 0.0 && ! b.all_integers ())
     {
       Complex atmp (a);
       ComplexNDArray result (b.dims ());
-      for (octave_idx_type i = 0; i < b.length (); i++)
+      for (octave_idx_type i = 0; i < b.numel (); i++)
         {
           octave_quit ();
           result(i) = std::pow (atmp, b(i));
         }
 
       retval = result;
     }
   else
     {
       NDArray result (b.dims ());
-      for (octave_idx_type i = 0; i < b.length (); i++)
+      for (octave_idx_type i = 0; i < b.numel (); i++)
         {
           octave_quit ();
           result (i) = std::pow (a, b(i));
         }
 
       retval = result;
     }
 
@@ -1145,17 +1145,17 @@ elem_xpow (double a, const NDArray& b)
 }
 
 // -*- 2 -*-
 octave_value
 elem_xpow (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
@@ -1166,62 +1166,62 @@ elem_xpow (const NDArray& a, double b)
   octave_value retval;
 
   if (! xisint (b))
     {
       if (a.any_element_is_negative ())
         {
           ComplexNDArray result (a.dims ());
 
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
 
               Complex atmp (a (i));
 
               result(i) = std::pow (atmp, b);
             }
 
           retval = result;
         }
       else
         {
           NDArray result (a.dims ());
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
               result(i) = std::pow (a(i), b);
             }
 
           retval = result;
         }
     }
   else
     {
       NoAlias<NDArray> result (a.dims ());
 
       int ib = static_cast<int> (b);
       if (ib == 2)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result(i) = a(i) * a(i);
         }
       else if (ib == 3)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result(i) = a(i) * a(i) * a(i);
         }
       else if (ib == -1)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result(i) = 1.0 / a(i);
         }
       else
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
               result(i) = std::pow (a(i), ib);
             }
         }
 
       retval = result;
     }
@@ -1252,17 +1252,17 @@ elem_xpow (const NDArray& a, const NDArr
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
-  int len = a.length ();
+  int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       octave_quit ();
       double atmp = a(i);
       double btmp = b(i);
@@ -1305,17 +1305,17 @@ done:
 }
 
 // -*- 5 -*-
 octave_value
 elem_xpow (const NDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
@@ -1336,32 +1336,32 @@ elem_xpow (const NDArray& a, const Compl
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
   ComplexNDArray result (a_dims);
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       double btmp = b(i);
       if (xisint (btmp))
         result(i) = std::pow (a, static_cast<int> (btmp));
       else
         result(i) = std::pow (a, btmp);
     }
@@ -1370,17 +1370,17 @@ elem_xpow (const Complex& a, const NDArr
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
@@ -1389,31 +1389,31 @@ octave_value
 elem_xpow (const ComplexNDArray& a, double b)
 {
   ComplexNDArray result (a.dims ());
 
   if (xisint (b))
     {
       if (b == -1)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result.xelem (i) = 1.0 / a(i);
         }
       else
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
               result(i) = std::pow (a(i), static_cast<int> (b));
             }
         }
     }
   else
     {
-      for (octave_idx_type i = 0; i < a.length (); i++)
+      for (octave_idx_type i = 0; i < a.numel (); i++)
         {
           octave_quit ();
           result(i) = std::pow (a(i), b);
         }
     }
 
   return result;
 }
@@ -1435,17 +1435,17 @@ elem_xpow (const ComplexNDArray& a, cons
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
   ComplexNDArray result (a_dims);
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       double btmp = b(i);
       if (xisint (btmp))
         result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
         result(i) = std::pow (a(i), btmp);
     }
@@ -1454,17 +1454,17 @@ elem_xpow (const ComplexNDArray& a, cons
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
@@ -1485,17 +1485,17 @@ elem_xpow (const ComplexNDArray& a, cons
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
   ComplexNDArray result (a_dims);
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
@@ -2466,28 +2466,28 @@ octave_value
 elem_xpow (float a, const FloatNDArray& b)
 {
   octave_value retval;
 
   if (a < 0.0 && ! b.all_integers ())
     {
       FloatComplex atmp (a);
       FloatComplexNDArray result (b.dims ());
-      for (octave_idx_type i = 0; i < b.length (); i++)
+      for (octave_idx_type i = 0; i < b.numel (); i++)
         {
           octave_quit ();
           result(i) = std::pow (atmp, b(i));
         }
 
       retval = result;
     }
   else
     {
       FloatNDArray result (b.dims ());
-      for (octave_idx_type i = 0; i < b.length (); i++)
+      for (octave_idx_type i = 0; i < b.numel (); i++)
         {
           octave_quit ();
           result (i) = std::pow (a, b(i));
         }
 
       retval = result;
     }
 
@@ -2495,17 +2495,17 @@ elem_xpow (float a, const FloatNDArray& 
 }
 
 // -*- 2 -*-
 octave_value
 elem_xpow (float a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
@@ -2516,62 +2516,62 @@ elem_xpow (const FloatNDArray& a, float 
   octave_value retval;
 
   if (! xisint (b))
     {
       if (a.any_element_is_negative ())
         {
           FloatComplexNDArray result (a.dims ());
 
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
 
               FloatComplex atmp (a (i));
 
               result(i) = std::pow (atmp, b);
             }
 
           retval = result;
         }
       else
         {
           FloatNDArray result (a.dims ());
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
               result(i) = std::pow (a(i), b);
             }
 
           retval = result;
         }
     }
   else
     {
       NoAlias<FloatNDArray> result (a.dims ());
 
       int ib = static_cast<int> (b);
       if (ib == 2)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result(i) = a(i) * a(i);
         }
       else if (ib == 3)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result(i) = a(i) * a(i) * a(i);
         }
       else if (ib == -1)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result(i) = 1.0f / a(i);
         }
       else
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
               result(i) = std::pow (a(i), ib);
             }
         }
 
       retval = result;
     }
@@ -2602,17 +2602,17 @@ elem_xpow (const FloatNDArray& a, const 
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
-  int len = a.length ();
+  int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       octave_quit ();
       float atmp = a(i);
       float btmp = b(i);
@@ -2655,17 +2655,17 @@ done:
 }
 
 // -*- 5 -*-
 octave_value
 elem_xpow (const FloatNDArray& a, const FloatComplex& b)
 {
   FloatComplexNDArray result (a.dims ());
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
@@ -2686,32 +2686,32 @@ elem_xpow (const FloatNDArray& a, const 
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
   FloatComplexNDArray result (a_dims);
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       float btmp = b(i);
       if (xisint (btmp))
         result(i) = std::pow (a, static_cast<int> (btmp));
       else
         result(i) = std::pow (a, btmp);
     }
@@ -2720,17 +2720,17 @@ elem_xpow (const FloatComplex& a, const 
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatComplexNDArray& b)
 {
   FloatComplexNDArray result (b.dims ());
 
-  for (octave_idx_type i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
@@ -2739,31 +2739,31 @@ octave_value
 elem_xpow (const FloatComplexNDArray& a, float b)
 {
   FloatComplexNDArray result (a.dims ());
 
   if (xisint (b))
     {
       if (b == -1)
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             result.xelem (i) = 1.0f / a(i);
         }
       else
         {
-          for (octave_idx_type i = 0; i < a.length (); i++)
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
               octave_quit ();
               result(i) = std::pow (a(i), static_cast<int> (b));
             }
         }
     }
   else
     {
-      for (octave_idx_type i = 0; i < a.length (); i++)
+      for (octave_idx_type i = 0; i < a.numel (); i++)
         {
           octave_quit ();
           result(i) = std::pow (a(i), b);
         }
     }
 
   return result;
 }
@@ -2785,17 +2785,17 @@ elem_xpow (const FloatComplexNDArray& a,
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
   FloatComplexNDArray result (a_dims);
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       float btmp = b(i);
       if (xisint (btmp))
         result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
         result(i) = std::pow (a(i), btmp);
     }
@@ -2804,17 +2804,17 @@ elem_xpow (const FloatComplexNDArray& a,
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplex& b)
 {
   FloatComplexNDArray result (a.dims ());
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
@@ -2835,16 +2835,16 @@ elem_xpow (const FloatComplexNDArray& a,
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
     }
 
   FloatComplexNDArray result (a_dims);
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -465,17 +465,17 @@ Undocumented internal function.\n\
     }
 
   double *b = B.fortran_vec ();
 
   //-- 4th Input. An array of length mrowsc containing the lower
   //--            bound on each of the variables.
   Matrix LB (args(3).matrix_value ());
 
-  if (error_state || LB.length () < mrowsc)
+  if (error_state || LB.numel () < mrowsc)
     {
       error ("__glpk__: invalid value of LB");
       return retval;
     }
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
@@ -490,17 +490,17 @@ Undocumented internal function.\n\
       else
         freeLB(i) = 0;
     }
 
   //-- 5th Input. An array of at least length numcols containing the upper
   //--            bound on each of the variables.
   Matrix UB (args(4).matrix_value ());
 
-  if (error_state || UB.length () < mrowsc)
+  if (error_state || UB.numel () < mrowsc)
     {
       error ("__glpk__: invalid value of UB");
       return retval;
     }
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -558,17 +558,17 @@ public:
         uimenup.set_fltk_label (fltk_label);
       }
   }
 
   void add_to_menu (uimenu::properties& uimenup)
   {
     std::vector<int> delayed_menus;
     Matrix kids = find_uimenu_children (uimenup);
-    int len = kids.length ();
+    int len = kids.numel ();
     std::string fltk_label = uimenup.get_fltk_label ();
     int count = 0;
 
     add_entry (uimenup);
     update_foregroundcolor (uimenup);
     update_callback (uimenup);
     update_accelerator (uimenup);
     update_enable (uimenup);
@@ -608,17 +608,17 @@ public:
           }
       }
   }
 
   void add_to_menu (figure::properties& figp)
   {
     std::vector<int> delayed_menus;
     Matrix kids = find_uimenu_children (figp);
-    int len = kids.length ();
+    int len = kids.numel ();
     int count = 0;
     menubar->clear ();
     for (octave_idx_type ii = 0; ii < len; ii++)
       {
         graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
         if (kgo.valid_object ())
           {
@@ -653,17 +653,17 @@ public:
   }
 
   template <class T_prop>
   void remove_from_menu (T_prop& prop)
   {
     Matrix kids;
     std::string type = prop.get_type ();
     kids = find_uimenu_children (prop);
-    int len = kids.length ();
+    int len = kids.numel ();
 
     for (octave_idx_type ii = 0; ii < len; ii++)
       {
         graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
         if (kgo.valid_object ())
           {
             uimenu::properties kprop = dynamic_cast<uimenu::properties&>
@@ -1108,17 +1108,17 @@ private:
         xx = pp(0);
         yy = pp(1);
       }
   }
 
   graphics_handle pixel2axes_or_ca (int px, int py)
   {
     Matrix kids = fp.get_children ();
-    int len = kids.length ();
+    int len = kids.numel ();
 
     for (int k = 0; k < len; k++)
       {
         graphics_handle hnd = gh_manager::lookup (kids(k));
 
         if (hnd.ok ())
           {
             graphics_object kid = gh_manager::get_object (hnd);
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -211,17 +211,17 @@ read_indexed_images (const std::vector<M
                      const octave_idx_type& nargout,
                      const octave_scalar_map& options)
 {
   typedef typename T::element_type P;
 
   octave_value_list retval (3, Matrix ());
 
   std::map<std::string, octave_idx_type> region = calculate_region (options);
-  const octave_idx_type nFrames = frameidx.length ();
+  const octave_idx_type nFrames = frameidx.numel ();
   const octave_idx_type nRows = region["row_out"];
   const octave_idx_type nCols = region["col_out"];
 
   // imvec has all of the pages of a file, even the ones we are not
   // interested in. We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
 
@@ -306,17 +306,17 @@ read_images (std::vector<Magick::Image>&
              const octave_idx_type& nargout,
              const octave_scalar_map& options)
 {
   typedef typename T::element_type P;
 
   octave_value_list retval (3, Matrix ());
 
   std::map<std::string, octave_idx_type> region = calculate_region (options);
-  const octave_idx_type nFrames = frameidx.length ();
+  const octave_idx_type nFrames = frameidx.numel ();
   const octave_idx_type nRows = region["row_out"];
   const octave_idx_type nCols = region["col_out"];
   T img;
 
   // imvec has all of the pages of a file, even the ones we are not
   // interested in. We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -1081,17 +1081,17 @@ unsigned int
 audioplayer::get_sample_number (void)
 {
   return sample_number;
 }
 
 unsigned int
 audioplayer::get_total_samples (void)
 {
-  return left.length ();
+  return left.numel ();
 }
 
 void
 audioplayer::set_end_sample (unsigned int end_sample_arg)
 {
   end_sample = end_sample_arg;
 }
 
@@ -1099,17 +1099,17 @@ unsigned int
 audioplayer::get_end_sample (void)
 {
   return end_sample;
 }
 
 void
 audioplayer::reset_end_sample (void)
 {
-  set_end_sample (left.length ());
+  set_end_sample (left.numel ());
 }
 
 void
 audioplayer::set_tag (const charMatrix& tag_arg)
 {
   tag = tag_arg;
 }
 
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -157,17 +157,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
       CCOLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
-          int nel_User_knobs = User_knobs.length ();
+          int nel_User_knobs = User_knobs.numel ();
 
           if (nel_User_knobs > 0)
             knobs[CCOLAMD_LU] = (User_knobs(0) != 0);
           if (nel_User_knobs > 1)
             knobs[CCOLAMD_DENSE_ROW] = User_knobs(1);
           if (nel_User_knobs > 2)
             knobs[CCOLAMD_DENSE_COL] = User_knobs(2);
           if (nel_User_knobs > 3)
@@ -268,17 +268,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
       for (octave_idx_type i = 0; i < nnz; i++)
         A[i] = ridx[i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value ();
-          octave_idx_type cslen = in_cmember.length ();
+          octave_idx_type cslen = in_cmember.numel ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
@@ -417,17 +417,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
       CCOLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
-          int nel_User_knobs = User_knobs.length ();
+          int nel_User_knobs = User_knobs.numel ();
 
           if (nel_User_knobs > 0)
             knobs[CCOLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 0)
             knobs[CCOLAMD_AGGRESSIVE] = User_knobs(1);
           if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs(2));
 
@@ -506,17 +506,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value ();
-          octave_idx_type cslen = in_cmember.length ();
+          octave_idx_type cslen = in_cmember.numel ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("csymamd: CMEMBER must be of length equal to #cols of A");
           else if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -292,17 +292,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
-          int nel_User_knobs = User_knobs.length ();
+          int nel_User_knobs = User_knobs.numel ();
 
           if (nel_User_knobs > 0)
             knobs[COLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 1)
             knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
           if (nel_User_knobs > 2)
             spumoni = static_cast<int> (User_knobs(2));
 
@@ -529,17 +529,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
-          int nel_User_knobs = User_knobs.length ();
+          int nel_User_knobs = User_knobs.numel ();
 
           if (nel_User_knobs > 0)
             knobs[COLAMD_DENSE_ROW] = User_knobs(COLAMD_DENSE_ROW);
           if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs (1));
         }
 
       // print knob settings if spumoni is set
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -151,17 +151,17 @@ octave_cell::subsref (const std::string&
     case '{':
       {
         octave_value tmp = do_index_op (idx.front ());
 
         if (! error_state)
           {
             Cell tcell = tmp.cell_value ();
 
-            if (tcell.length () == 1)
+            if (tcell.numel () == 1)
               retval(0) = tcell(0,0);
             else
               retval = octave_value (octave_value_list (tcell), true);
           }
       }
       break;
 
     case '.':
@@ -203,17 +203,17 @@ octave_cell::subsref (const std::string&
     case '{':
       {
         octave_value tmp = do_index_op (idx.front (), auto_add);
 
         if (! error_state)
           {
             const Cell tcell = tmp.cell_value ();
 
-            if (tcell.length () == 1)
+            if (tcell.numel () == 1)
               retval = tcell(0,0);
             else
               retval = octave_value (octave_value_list (tcell), true);
           }
       }
       break;
 
     case '.':
@@ -612,17 +612,17 @@ octave_cell::all_strings (bool pad) cons
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       string_vector s = matrix(i).all_strings ();
 
       if (error_state)
         return retval;
 
-      octave_idx_type s_len = s.length ();
+      octave_idx_type s_len = s.numel ();
 
       n_elts += s_len ? s_len : 1;
 
       octave_idx_type s_max_len = s.max_length ();
 
       if (s_max_len > max_len)
         max_len = s_max_len;
 
@@ -633,17 +633,17 @@ octave_cell::all_strings (bool pad) cons
 
   octave_idx_type k = 0;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       const string_vector s = strvec_queue.front ();
       strvec_queue.pop ();
 
-      octave_idx_type s_len = s.length ();
+      octave_idx_type s_len = s.numel ();
 
       if (s_len)
         {
           for (octave_idx_type j = 0; j < s_len; j++)
             {
               std::string t = s[j];
               int t_len = t.length ();
 
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -401,17 +401,17 @@ octave_class::subsref (const std::string
                 octave_value_list key_idx = *++p;
 
                 Cell tmp = dotref (key_idx);
 
                 if (! error_state)
                   {
                     Cell t = tmp.index (idx.front ());
 
-                    retval(0) = (t.length () == 1) ? t(0)
+                    retval(0) = (t.numel () == 1) ? t(0)
                                                    : octave_value (t, true);
 
                     // We handled two index elements, so tell
                     // next_subsref to skip both of them.
 
                     skip++;
                   }
               }
@@ -422,17 +422,17 @@ octave_class::subsref (const std::string
           break;
 
         case '.':
           {
             if (map.numel () > 0)
               {
                 Cell t = dotref (idx.front ());
 
-                retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+                retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
               }
           }
           break;
 
         case '{':
           gripe_invalid_index_type (type_name (), type[0]);
           break;
 
@@ -503,17 +503,17 @@ octave_class::subsref (const std::string
   return retval;
 }
 
 octave_value
 octave_class::numeric_conv (const Cell& val, const std::string& type)
 {
   octave_value retval;
 
-  if (val.length () == 1)
+  if (val.numel () == 1)
     {
       retval = val(0);
 
       if (type.length () > 0 && type[0] == '.' && ! retval.is_map ())
         retval = octave_map ();
     }
   else
     gripe_invalid_index_for_assignment ();
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -252,17 +252,17 @@ public:
       if (&x != this)
         {
           field_names = x.field_names;
           parent_class_names = x.parent_class_names;
         }
       return *this;
     }
 
-    octave_idx_type nfields (void) const { return field_names.length (); }
+    octave_idx_type nfields (void) const { return field_names.numel (); }
 
     size_t nparents (void) const { return parent_class_names.size (); }
 
     string_vector fields (void) const { return field_names; }
 
     std::list<std::string> parents (void) const { return parent_class_names; }
 
     bool compare (const octave_value& obj) const;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -65,17 +65,17 @@ octave_fcn_inline::octave_fcn_inline (co
   : octave_fcn_handle (n), iftext (f), ifargs (a)
 {
   // Form a string representing the function.
 
   std::ostringstream buf;
 
   buf << "@(";
 
-  for (int i = 0; i < ifargs.length (); i++)
+  for (int i = 0; i < ifargs.numel (); i++)
     {
       if (i > 0)
         buf << ", ";
 
       buf << ifargs(i);
     }
 
   buf << ") " << iftext;
@@ -123,34 +123,34 @@ octave_fcn_inline::map_value (void) cons
   octave_scalar_map m;
 
   m.assign ("version", 1.0);
   m.assign ("isEmpty", 0.0);
   m.assign ("expr", fcn_text ());
 
   string_vector args = fcn_arg_names ();
 
-  m.assign ("numArgs", args.length ());
+  m.assign ("numArgs", args.numel ());
   m.assign ("args", args);
 
   std::ostringstream buf;
 
-  for (int i = 0; i < args.length (); i++)
+  for (int i = 0; i < args.numel (); i++)
     buf << args(i) << " = INLINE_INPUTS_{" << i + 1 << "}; ";
 
   m.assign ("inputExpr", buf.str ());
 
   return m;
 }
 
 bool
 octave_fcn_inline::save_ascii (std::ostream& os)
 {
-  os << "# nargs: " <<  ifargs.length () << "\n";
-  for (int i = 0; i < ifargs.length (); i++)
+  os << "# nargs: " <<  ifargs.numel () << "\n";
+  for (int i = 0; i < ifargs.numel (); i++)
     os << ifargs(i) << "\n";
   if (nm.length () < 1)
     // Write an invalid value to flag empty fcn handle name.
     os << "0\n";
   else
     os << nm << "\n";
   os << iftext << "\n";
   return true;
@@ -190,19 +190,19 @@ octave_fcn_inline::load_ascii (std::istr
     }
   else
     return false;
 }
 
 bool
 octave_fcn_inline::save_binary (std::ostream& os, bool&)
 {
-  int32_t tmp = ifargs.length ();
+  int32_t tmp = ifargs.numel ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i = 0; i < ifargs.length (); i++)
+  for (int i = 0; i < ifargs.numel (); i++)
     {
       tmp = ifargs(i).length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (ifargs(i).c_str (), ifargs(i).length ());
     }
   tmp = nm.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (nm.c_str (), nm.length ());
@@ -286,30 +286,30 @@ octave_fcn_inline::save_hdf5 (octave_hdf
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0) return false;
 
   size_t len = 0;
-  for (int i = 0; i < ifargs.length (); i++)
+  for (int i = 0; i < ifargs.numel (); i++)
     if (len < ifargs(i).length ())
       len = ifargs(i).length ();
 
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
 
   // FIXME: Is there a better way of saving string vectors,
   //        than a null padded matrix?
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
-  hdims[1] = ifargs.length ();
+  hdims[1] = ifargs.numel ();
   hdims[0] = len + 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
@@ -322,20 +322,20 @@ octave_fcn_inline::save_hdf5 (octave_hdf
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  OCTAVE_LOCAL_BUFFER (char, s, ifargs.length () * (len + 1));
+  OCTAVE_LOCAL_BUFFER (char, s, ifargs.numel () * (len + 1));
 
   // Save the args as a null teminated list
-  for (int i = 0; i < ifargs.length (); i++)
+  for (int i = 0; i < ifargs.numel (); i++)
     {
       const char * cptr = ifargs(i).c_str ();
       for (size_t j = 0; j < ifargs(i).length (); j++)
         s[i*(len+1)+j] = *cptr++;
       s[ifargs(i).length ()] = '\0';
     }
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL,
@@ -622,17 +622,17 @@ octave_fcn_inline::print_raw (std::ostre
 {
   std::ostringstream buf;
 
   if (nm.empty ())
     buf << "f(";
   else
     buf << nm << "(";
 
-  for (int i = 0; i < ifargs.length (); i++)
+  for (int i = 0; i < ifargs.numel (); i++)
     {
       if (i)
         buf << ", ";
 
       buf << ifargs(i);
     }
 
   buf << ") = " << iftext;
@@ -746,17 +746,17 @@ functions from strings is through the us
                     {
                       tmp_arg.append (1, c);
                     }
 
                   if (terminate_arg || (i == fun_length && is_arg))
                     {
                       bool have_arg = false;
 
-                      for (int j = 0; j < fargs.length (); j++)
+                      for (int j = 0; j < fargs.numel (); j++)
                         if (tmp_arg == fargs (j))
                           {
                             have_arg = true;
                             break;
                           }
 
                       if (! have_arg && tmp_arg != "i" && tmp_arg != "j"
                           && tmp_arg != "NaN" && tmp_arg != "nan"
@@ -768,17 +768,17 @@ functions from strings is through the us
                       tmp_arg = std::string ();
                       is_arg = false;
                     }
                 }
 
               // Sort the arguments into ascii order.
               fargs.sort ();
 
-              if (fargs.length () == 0)
+              if (fargs.numel () == 0)
                 fargs.append (std::string ("x"));
 
             }
           else if (nargin == 2 && args(1).is_numeric_type ())
             {
               if (! args(1).is_scalar_type ())
                 {
                   error ("inline: N must be an integer");
@@ -915,19 +915,19 @@ arguments of the inline function @var{fu
   if (nargin == 1)
     {
       octave_fcn_inline *fn = args(0).fcn_inline_value (true);
 
       if (fn)
         {
           string_vector t1 = fn->fcn_arg_names ();
 
-          Cell t2 (dim_vector (t1.length (), 1));
+          Cell t2 (dim_vector (t1.numel (), 1));
 
-          for (int i = 0; i < t1.length (); i++)
+          for (int i = 0; i < t1.numel (); i++)
             t2(i) = t1(i);
 
           retval = t2;
         }
       else
         error ("argnames: FUN must be an inline function");
     }
   else
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1092,58 +1092,58 @@ BOX_PRIMITIVE_ARRAY (jdouble,  "[D", Dou
 
               std::string s = jstring_to_string (jni_env, js);
 
               if (s == "double")
                 {
                   NDArray m (dims);
                   mID = jni_env->GetMethodID (cls, "toDouble", "()[D");
                   jdoubleArray_ref dv (jni_env, reinterpret_cast<jdoubleArray> (jni_env->CallObjectMethod (jobj, mID)));
-                  jni_env->GetDoubleArrayRegion (dv, 0, m.length (), m.fortran_vec ());
+                  jni_env->GetDoubleArrayRegion (dv, 0, m.numel (), m.fortran_vec ());
                   retval = m;
                   break;
                 }
               else if (s == "byte")
                 {
                   if (Vjava_unsigned_autoconversion)
                     {
                       uint8NDArray m (dims);
                       mID = jni_env->GetMethodID (cls, "toByte", "()[B");
                       jbyteArray_ref dv (jni_env, reinterpret_cast<jbyteArray> (jni_env->CallObjectMethod (jobj, mID)));
-                      jni_env->GetByteArrayRegion (dv, 0, m.length (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
+                      jni_env->GetByteArrayRegion (dv, 0, m.numel (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
                       retval = m;
                       break;
                     }
                   else
                     {
                       int8NDArray m (dims);
                       mID = jni_env->GetMethodID (cls, "toByte", "()[B");
                       jbyteArray_ref dv (jni_env, reinterpret_cast<jbyteArray> (jni_env->CallObjectMethod (jobj, mID)));
-                      jni_env->GetByteArrayRegion (dv, 0, m.length (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
+                      jni_env->GetByteArrayRegion (dv, 0, m.numel (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
                       retval = m;
                       break;
                     }
                 }
               else if (s == "integer")
                 {
                   if (Vjava_unsigned_autoconversion)
                     {
                       uint32NDArray m (dims);
                       mID = jni_env->GetMethodID (cls, "toInt", "()[I");
                       jintArray_ref dv (jni_env, reinterpret_cast<jintArray> (jni_env->CallObjectMethod (jobj, mID)));
-                      jni_env->GetIntArrayRegion (dv, 0, m.length (), reinterpret_cast<jint *> (m.fortran_vec ()));
+                      jni_env->GetIntArrayRegion (dv, 0, m.numel (), reinterpret_cast<jint *> (m.fortran_vec ()));
                       retval = m;
                       break;
                     }
                   else
                     {
                       int32NDArray m (dims);
                       mID = jni_env->GetMethodID (cls, "toInt", "()[I");
                       jintArray_ref dv (jni_env, reinterpret_cast<jintArray> (jni_env->CallObjectMethod (jobj, mID)));
-                      jni_env->GetIntArrayRegion (dv, 0, m.length (), reinterpret_cast<jint *> (m.fortran_vec ()));
+                      jni_env->GetIntArrayRegion (dv, 0, m.numel (), reinterpret_cast<jint *> (m.fortran_vec ()));
                       retval = m;
                       break;
                     }
                 }
             }
         }
 
       cls = find_octave_class (jni_env, "org/octave/OctaveReference");
@@ -1212,17 +1212,17 @@ box_more (JNIEnv* jni_env, jobject jobj,
                 {
                   Matrix m;
 
                   for (int r = 0; r < rows; r++)
                     {
                       jdoubleArray_ref row (jni_env,
                                             reinterpret_cast<jdoubleArray> (jni_env->GetObjectArrayElement (jarr, r)));
 
-                      if (m.length () == 0)
+                      if (m.numel () == 0)
                         {
                           cols = jni_env->GetArrayLength (row);
                           m.resize (cols, rows);
                         }
                       jni_env->GetDoubleArrayRegion (row, 0, cols, m.fortran_vec () + r * cols);
                     }
                   retval = m.transpose ();
                 }
@@ -1343,18 +1343,18 @@ unbox (JNIEnv* jni_env, const octave_val
       //jcls = jni_env->FindClass ("java/lang/Object");
     }
   else if (!Vjava_matrix_autoconversion
            && ((val.is_real_matrix ()
                 && (val.rows () == 1 || val.columns () == 1))
                || val.is_range ()))
     {
       Matrix m = val.matrix_value ();
-      jdoubleArray dv = jni_env->NewDoubleArray (m.length ());
-      jni_env->SetDoubleArrayRegion (dv, 0, m.length (), m.fortran_vec ());
+      jdoubleArray dv = jni_env->NewDoubleArray (m.numel ());
+      jni_env->SetDoubleArrayRegion (dv, 0, m.numel (), m.fortran_vec ());
       jobj = dv;
       jcls = jni_env->GetObjectClass (jobj);
     }
   else if (Vjava_matrix_autoconversion
            && (val.is_matrix_type () || val.is_range ()) && val.is_real_type ())
     {
       jclass_ref mcls (jni_env, find_octave_class (jni_env, "org/octave/Matrix"));
       dim_vector dims = val.dims ();
@@ -1364,66 +1364,66 @@ unbox (JNIEnv* jni_env, const octave_val
       for (int i = 0; i < dims.length (); i++)
         iv_data[i] = dims(i);
 
       jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
 
       if (val.is_double_type ())
         {
           NDArray m = val.array_value ();
-          jdoubleArray_ref dv (jni_env, jni_env->NewDoubleArray (m.length ()));
-          jni_env->SetDoubleArrayRegion (jdoubleArray (dv), 0, m.length (),
+          jdoubleArray_ref dv (jni_env, jni_env->NewDoubleArray (m.numel ()));
+          jni_env->SetDoubleArrayRegion (jdoubleArray (dv), 0, m.numel (),
                                          m.fortran_vec ());
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([D[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jdoubleArray (dv),
                                      jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else if (val.is_int8_type ())
         {
           int8NDArray m = val.int8_array_value ();
-          jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.length ()));
-          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (),
+          jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.numel ()));
+          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.numel (),
                                        reinterpret_cast <jbyte *> (m.fortran_vec ()));
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([B[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jbyteArray (bv), jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else if (val.is_uint8_type ())
         {
           uint8NDArray m = val.uint8_array_value ();
-          jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.length ()));
-          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (),
+          jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.numel ()));
+          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.numel (),
                                        reinterpret_cast<jbyte *> (m.fortran_vec ()));
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([B[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jbyteArray (bv), jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else if (val.is_int32_type ())
         {
           int32NDArray m = val.int32_array_value ();
-          jintArray_ref v (jni_env, jni_env->NewIntArray (m.length ()));
-          jni_env->SetIntArrayRegion (jintArray (v), 0, m.length (),
+          jintArray_ref v (jni_env, jni_env->NewIntArray (m.numel ()));
+          jni_env->SetIntArrayRegion (jintArray (v), 0, m.numel (),
                                       reinterpret_cast<jint *> (m.fortran_vec ()));
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([I[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jintArray (v), jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else
         {
           found = false;
           error ("cannot convert matrix of type '%s'", val.class_name ().c_str ());
         }
     }
   else if (val.is_cellstr ())
     {
       Cell cellStr = val.cell_value ();
       jclass_ref scls (jni_env, jni_env->FindClass ("java/lang/String"));
-      jobjectArray array = jni_env->NewObjectArray (cellStr.length (), scls, 0);
-      for (int i = 0; i < cellStr.length (); i++)
+      jobjectArray array = jni_env->NewObjectArray (cellStr.numel (), scls, 0);
+      for (int i = 0; i < cellStr.numel (); i++)
         {
           jstring_ref jstr (jni_env,
                             jni_env->NewStringUTF (cellStr(i).string_value().c_str ()));
           jni_env->SetObjectArrayElement (array, i, jstr);
         }
       jobj = array;
       jcls = jni_env->GetObjectClass (jobj);
     }
@@ -1597,17 +1597,17 @@ Java_org_octave_Octave_doInvoke (JNIEnv 
             }
           else if (val.is_cell () && val.length () > 0
                    && (val.rows () == 1 || val.columns () == 1)
                    && val.cell_value()(0).is_function_handle ())
             {
               Cell c = val.cell_value ();
               octave_function *fcn = c(0).function_value ();
 
-              for (int i=1; i<c.length (); i++)
+              for (int i=1; i<c.numel (); i++)
                 oct_args(len+i-1) = c(i);
 
               if (! error_state)
                 feval (fcn, oct_args);
             }
           else
             error ("trying to invoke non-invocable object");
 
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -256,17 +256,17 @@ octave_perm_matrix::convert_to_str_inter
 
 bool
 octave_perm_matrix::save_ascii (std::ostream& os)
 {
   os << "# size: " << matrix.rows () << "\n";
   os << "# orient: c\n";
 
   Array<octave_idx_type> pvec = matrix.col_perm_vec ();
-  octave_idx_type n = pvec.length ();
+  octave_idx_type n = pvec.numel ();
   ColumnVector tmp (n);
   for (octave_idx_type i = 0; i < n; i++) tmp(i) = pvec(i) + 1;
   os << tmp;
 
   return true;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -152,17 +152,17 @@ octave_struct::subsref (const std::strin
             octave_value_list key_idx = *++p;
 
             const Cell tmp = dotref (key_idx);
 
             if (! error_state)
               {
                 const Cell t = tmp.index (idx.front ());
 
-                retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+                retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
 
                 // We handled two index elements, so tell
                 // next_subsref to skip both of them.
 
                 skip++;
               }
           }
         else
@@ -171,17 +171,17 @@ octave_struct::subsref (const std::strin
       break;
 
     case '.':
       {
         if (map.numel () > 0)
           {
             const Cell t = dotref (idx.front ());
 
-            retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+            retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
@@ -218,17 +218,17 @@ octave_struct::subsref (const std::strin
             octave_value_list key_idx = *++p;
 
             const Cell tmp = dotref (key_idx, auto_add);
 
             if (! error_state)
               {
                 const Cell t = tmp.index (idx.front (), auto_add);
 
-                retval = (t.length () == 1) ? t(0) : octave_value (t, true);
+                retval = (t.numel () == 1) ? t(0) : octave_value (t, true);
 
                 // We handled two index elements, so tell
                 // next_subsref to skip both of them.
 
                 skip++;
               }
           }
         else
@@ -237,17 +237,17 @@ octave_struct::subsref (const std::strin
       break;
 
     case '.':
       {
         if (map.numel () > 0)
           {
             const Cell t = dotref (idx.front (), auto_add);
 
-            retval = (t.length () == 1) ? t(0) : octave_value (t, true);
+            retval = (t.numel () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
@@ -674,17 +674,17 @@ octave_struct::print_raw (std::ostream& 
       dim_vector dv = dims ();
       os << dv.str () << " struct array containing the fields:";
       newline (os);
 
       increment_indent_level ();
 
       string_vector key_list = map.fieldnames ();
 
-      for (octave_idx_type i = 0; i < key_list.length (); i++)
+      for (octave_idx_type i = 0; i < key_list.numel (); i++)
         {
           std::string key = key_list[i];
 
           Cell val = map.contents (key);
 
           newline (os);
 
           if (print_fieldnames_only)
@@ -1395,17 +1395,17 @@ octave_scalar_struct::print_raw (std::os
       newline (os);
       if (! Vcompact_format)
         newline (os);
 
       increment_indent_level ();
 
       string_vector key_list = map.fieldnames ();
 
-      for (octave_idx_type i = 0; i < key_list.length (); i++)
+      for (octave_idx_type i = 0; i < key_list.numel (); i++)
         {
           std::string key = key_list[i];
 
           octave_value val = map.contents (key);
 
           if (print_fieldnames_only)
             {
               indent (os);
@@ -2012,17 +2012,17 @@ Implements @code{fieldnames()} for struc
 
   // Input validation has already been done in fieldnames.m.
   octave_value arg = args(0);
 
   octave_map m = arg.map_value ();
 
   string_vector keys = m.fieldnames ();
 
-  if (keys.length () == 0)
+  if (keys.numel () == 0)
     retval = Cell (0, 1);
   else
     retval = Cell (keys);
 
   return retval;
 }
 
 DEFUN (isfield, args, ,
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -188,17 +188,17 @@ octave_value_typeinfo::do_register_type 
                                          const octave_value& val)
 {
   int i = 0;
 
   for (i = 0; i < num_types; i++)
     if (t_name == types (i))
       return i;
 
-  int len = types.length ();
+  int len = types.numel ();
 
   if (i == len)
     {
       len *= 2;
 
       types.resize (dim_vector (len, 1), std::string ());
 
       vals.resize (dim_vector (len, 1), octave_value ());
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2993,17 +2993,17 @@ decode_subscripts (const char* name, con
           octave_value_list idx_item;
 
           if (subs(k).is_string ())
             idx_item(0) = subs(k);
           else if (subs(k).is_cell ())
             {
               Cell subs_cell = subs(k).cell_value ();
 
-              for (int n = 0; n < subs_cell.length (); n++)
+              for (int n = 0; n < subs_cell.numel (); n++)
                 {
                   if (subs_cell(n).is_string ()
                       && subs_cell(n).string_value () == ":")
                     idx_item(n) = octave_value(octave_value::magic_colon_t);
                   else
                     idx_item(n) = subs_cell(n);
                 }
             }
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -365,65 +365,65 @@ along with Octave; see the file COPYING.
   DEFNDBINOP_FN (PFX ## _el_and_not, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_and_not) \
   DEFNDBINOP_FN (PFX ## _el_or_not,  TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_or_not)
 
 #define OCTAVE_SM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const octave_ ## T1& a, const T2 ## NDArray& b) \
   { \
     T2 ## NDArray result (b.dims ()); \
-    for (int i = 0; i < b.length (); i++) \
+    for (int i = 0; i < b.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a, b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const octave_ ## T1& a, const NDArray& b) \
   { \
     T1 ## NDArray result (b.dims ()); \
-    for (int i = 0; i < b.length (); i++) \
+    for (int i = 0; i < b.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a, b(i)); \
       } \
     return octave_value (result); \
   } \
  \
   octave_value \
   elem_xpow (double a, const T2 ## NDArray& b) \
   { \
     T2 ## NDArray result (b.dims ()); \
-    for (int i = 0; i < b.length (); i++) \
+    for (int i = 0; i < b.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a, b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const octave_ ## T1& a, const FloatNDArray& b) \
   { \
     T1 ## NDArray result (b.dims ()); \
-    for (int i = 0; i < b.length (); i++) \
+    for (int i = 0; i < b.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a, b(i)); \
       } \
     return octave_value (result); \
   } \
  \
   octave_value \
   elem_xpow (float a, const T2 ## NDArray& b) \
   { \
     T2 ## NDArray result (b.dims ()); \
-    for (int i = 0; i < b.length (); i++) \
+    for (int i = 0; i < b.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a, b(i)); \
       } \
     return octave_value (result); \
   }
 
 
@@ -531,61 +531,61 @@ along with Octave; see the file COPYING.
   DEFNDASSIGNOP_OP (PFX ## _assign_sub, TM ## matrix, TM ## scalar, TM ## scalar, -=) \
   DEFNDASSIGNOP_OP (PFX ## _assign_mul, TM ## matrix, TM ## scalar, TM ## scalar, *=) \
   DEFNDASSIGNOP_OP (PFX ## _assign_div, TM ## matrix, TM ## scalar, TM ## scalar, /=)
 
 #define OCTAVE_MS_POW_OPS(T1, T2) \
 octave_value elem_xpow (T1 ## NDArray a, octave_ ## T2  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
-  for (int i = 0; i < a.length (); i++) \
+  for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (T1 ## NDArray a, double  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
-  for (int i = 0; i < a.length (); i++) \
+  for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (NDArray a, octave_ ## T2  b) \
 { \
   T2 ## NDArray result (a.dims ()); \
-  for (int i = 0; i < a.length (); i++) \
+  for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (T1 ## NDArray a, float  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
-  for (int i = 0; i < a.length (); i++) \
+  for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = powf (a(i), b);              \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (FloatNDArray a, octave_ ## T2  b) \
 { \
   T2 ## NDArray result (a.dims ()); \
-  for (int i = 0; i < a.length (); i++) \
+  for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = powf (a(i), b);              \
     } \
   return octave_value (result); \
 }
 
 
@@ -710,17 +710,17 @@ octave_value elem_xpow (FloatNDArray a, 
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T1 ## NDArray result (a_dims); \
-    for (int i = 0; i < a.length (); i++) \
+    for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
@@ -736,17 +736,17 @@ octave_value elem_xpow (FloatNDArray a, 
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T1 ## NDArray result (a_dims); \
-    for (int i = 0; i < a.length (); i++) \
+    for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
@@ -762,17 +762,17 @@ octave_value elem_xpow (FloatNDArray a, 
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T2 ## NDArray result (a_dims); \
-    for (int i = 0; i < a.length (); i++) \
+    for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
@@ -788,17 +788,17 @@ octave_value elem_xpow (FloatNDArray a, 
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T1 ## NDArray result (a_dims); \
-    for (int i = 0; i < a.length (); i++) \
+    for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
@@ -814,17 +814,17 @@ octave_value elem_xpow (FloatNDArray a, 
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T2 ## NDArray result (a_dims); \
-    for (int i = 0; i < a.length (); i++) \
+    for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
   }
 
 
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -595,17 +595,17 @@ tree_print_code::visit_index_expression 
             nesting.pop ();
             os << "}";
           }
           break;
 
         case '.':
           {
             string_vector nm = *p_arg_names;
-            assert (nm.length () == 1);
+            assert (nm.numel () == 1);
             os << "." << nm(0);
           }
           break;
 
         default:
           panic_impossible ();
         }
 
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 
 bool
 index_in_bounds (const Array<octave_idx_type>& ra_idx,
                  const dim_vector& dimensions)
 {
   bool retval = true;
 
-  int n = ra_idx.length ();
+  int n = ra_idx.numel ();
 
   if (n == dimensions.length ())
     {
       for (int i = 0; i < n; i++)
         {
           if (ra_idx(i) < 0 || ra_idx(i) >= dimensions(i))
             {
               retval = false;
@@ -56,17 +56,17 @@ index_in_bounds (const Array<octave_idx_
 }
 
 void
 increment_index (Array<octave_idx_type>& ra_idx, const dim_vector& dimensions,
                  int start_dimension)
 {
   ra_idx(start_dimension)++;
 
-  int n = ra_idx.length () - 1;
+  int n = ra_idx.numel () - 1;
   int nda = dimensions.length ();
 
   for (int i = start_dimension; i < n; i++)
     {
       if (ra_idx(i) < (i < nda ? dimensions(i) : 1))
         break;
       else
         {
@@ -76,17 +76,17 @@ increment_index (Array<octave_idx_type>&
     }
 }
 
 octave_idx_type
 get_scalar_idx (Array<octave_idx_type>& idx, dim_vector& dims)
 {
   octave_idx_type retval (-1);
 
-  int n = idx.length ();
+  int n = idx.numel ();
 
   if (n > 0)
     {
       retval = idx(--n);
 
       while (--n >= 0)
         {
           retval *= dims(n);
@@ -97,17 +97,17 @@ get_scalar_idx (Array<octave_idx_type>& 
   return retval;
 }
 
 octave_idx_type
 num_ones (const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type retval = 0;
 
-  for (octave_idx_type i = 0; i < ra_idx.length (); i++)
+  for (octave_idx_type i = 0; i < ra_idx.numel (); i++)
     {
       if (ra_idx(i) == 1)
         retval++;
     }
 
   return retval;
 }
 
@@ -157,17 +157,17 @@ is_vector (const dim_vector& dim)
   return (m < 2);
 }
 
 bool
 any_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = false;
 
-  for (octave_idx_type i = 0; i < arr.length (); i++)
+  for (octave_idx_type i = 0; i < arr.numel (); i++)
     {
       if (arr (i) == 1)
         {
           retval = true;
 
           break;
         }
     }
@@ -212,17 +212,17 @@ compute_index (octave_idx_type i, octave
     gripe_index_out_of_range (3, 3, k+1, dims.numel (2));
 
   return (k*dims(1) + j)*dims(0) + i;
 }
 
 octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims)
 {
-  int nd = ra_idx.length ();
+  int nd = ra_idx.numel ();
   const dim_vector dv = dims.redim (nd);
   for (int d = 0; d < nd; d++)
     {
       if (ra_idx(d) < 0)
         gripe_invalid_index ();
       if (ra_idx(d) >= dv(d))
         gripe_index_out_of_range (nd, d+1, ra_idx(d)+1, dv(d));
     }
@@ -230,17 +230,17 @@ compute_index (const Array<octave_idx_ty
   return dv.compute_index (ra_idx.data ());
 }
 
 Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
   Array<octave_idx_type> retval (a.dims ());
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     retval(i) = a(i).elem (0);
 
   return retval;
 }
 
 Array<idx_vector>
 conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
@@ -252,17 +252,17 @@ conv_to_array (const idx_vector *tmp, co
   return retval;
 }
 
 dim_vector
 freeze (Array<idx_vector>& ra_idx, const dim_vector& dimensions, int resize_ok)
 {
   dim_vector retval;
 
-  int n = ra_idx.length ();
+  int n = ra_idx.numel ();
 
   assert (n == dimensions.length ());
 
   retval.resize (n);
 
   static const char *tag[3] = { "row", "column", 0 };
 
   for (int i = 0; i < n; i++)
@@ -293,17 +293,17 @@ vector_equivalent (const dim_vector& dv)
   return true;
 }
 
 bool
 all_ok (const Array<idx_vector>& ra_idx)
 {
   bool retval = true;
 
-  octave_idx_type n = ra_idx.length ();
+  octave_idx_type n = ra_idx.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i))
         {
           retval = false;
           break;
         }
@@ -312,17 +312,17 @@ all_ok (const Array<idx_vector>& ra_idx)
   return retval;
 }
 
 bool
 any_orig_empty (const Array<idx_vector>& ra_idx)
 {
   bool retval = false;
 
-  octave_idx_type n = ra_idx.length ();
+  octave_idx_type n = ra_idx.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (ra_idx(i).orig_empty ())
         {
           retval = true;
           break;
         }
@@ -332,17 +332,17 @@ any_orig_empty (const Array<idx_vector>&
 }
 
 bool
 all_colon_equiv (const Array<idx_vector>& ra_idx,
                  const dim_vector& frozen_lengths)
 {
   bool retval = true;
 
-  octave_idx_type idx_n = ra_idx.length ();
+  octave_idx_type idx_n = ra_idx.numel ();
 
   int n = frozen_lengths.length ();
 
   assert (idx_n == n);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i).is_colon_equiv (frozen_lengths(i)))
@@ -355,33 +355,33 @@ all_colon_equiv (const Array<idx_vector>
   return retval;
 }
 
 bool
 all_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = true;
 
-  for (octave_idx_type i = 0; i < arr.length (); i++)
+  for (octave_idx_type i = 0; i < arr.numel (); i++)
     {
       if (arr(i) != 1)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
 
 Array<octave_idx_type>
 get_elt_idx (const Array<idx_vector>& ra_idx,
              const Array<octave_idx_type>& result_idx)
 {
-  octave_idx_type n = ra_idx.length ();
+  octave_idx_type n = ra_idx.numel ();
 
   Array<octave_idx_type> retval (dim_vector (n, 1));
 
   for (octave_idx_type i = 0; i < n; i++)
     retval(i) = ra_idx(i).elem (result_idx(i));
 
   return retval;
 }
@@ -418,17 +418,17 @@ get_ra_idx (octave_idx_type idx, const d
 #endif
 
   return retval;
 }
 
 dim_vector
 zero_dims_inquire (const Array<idx_vector>& ia, const dim_vector& rhdv)
 {
-  int ial = ia.length ();
+  int ial = ia.numel ();
   int rhdvl = rhdv.length ();
   dim_vector rdv = dim_vector::alloc (ial);
   bool *scalar = new bool [ial];
   bool *colon = new bool [ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
@@ -525,17 +525,17 @@ struct sub2ind_helper
 
   void operator ()(octave_idx_type k) { (*ind++ *= n) += k; }
 };
 
 idx_vector
 sub2ind (const dim_vector& dv, const Array<idx_vector>& idxa)
 {
   idx_vector retval;
-  octave_idx_type len = idxa.length ();
+  octave_idx_type len = idxa.numel ();
 
   if (len >= 1)
     {
       const dim_vector dvx = dv.redim (len);
       bool all_ranges = true;
       octave_idx_type clen = -1;
 
       for (octave_idx_type i = 0; i < len; i++)
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -67,17 +67,17 @@ Array<T>::Array (const Array<T>& a, cons
 
 template <class T>
 void
 Array<T>::fill (const T& val)
 {
   if (rep->count > 1)
     {
       --rep->count;
-      rep = new ArrayRep (length (), val);
+      rep = new ArrayRep (numel (), val);
       slice_data = rep->data;
     }
   else
     std::fill_n (slice_data, slice_len, val);
 }
 
 template <class T>
 void
@@ -308,17 +308,17 @@ class rec_permute_helper
   bool use_blk;
 
 public:
   rec_permute_helper (const dim_vector& dv, const Array<octave_idx_type>& perm)
 
     : n (dv.length ()), top (0), dim (new octave_idx_type [2*n]),
       stride (dim + n), use_blk (false)
   {
-    assert (n == perm.length ());
+    assert (n == perm.numel ());
 
     // Get cumulative dimensions.
     OCTAVE_LOCAL_BUFFER (octave_idx_type, cdim, n+1);
     cdim[0] = 1;
     for (int i = 1; i < n+1; i++) cdim[i] = cdim[i-1] * dv(i-1);
 
     // Setup the permuted strides.
     for (int k = 0; k < n; k++)
@@ -441,17 +441,17 @@ Array<T>
 Array<T>::permute (const Array<octave_idx_type>& perm_vec_arg, bool inv) const
 {
   Array<T> retval;
 
   Array<octave_idx_type> perm_vec = perm_vec_arg;
 
   dim_vector dv = dims ();
 
-  int perm_vec_len = perm_vec_arg.length ();
+  int perm_vec_len = perm_vec_arg.numel ();
 
   if (perm_vec_len < dv.length ())
     (*current_liboctave_error_handler)
       ("%s: invalid permutation vector", inv ? "ipermute" : "permute");
 
   dim_vector dv_new = dim_vector::alloc (perm_vec_len);
 
   // Append singleton dimensions as needed.
@@ -527,17 +527,17 @@ class rec_index_helper
   int n;
   int top;
   octave_idx_type *dim;
   octave_idx_type *cdim;
   idx_vector *idx;
 
 public:
   rec_index_helper (const dim_vector& dv, const Array<idx_vector>& ia)
-    : n (ia.length ()), top (0), dim (new octave_idx_type [2*n]),
+    : n (ia.numel ()), top (0), dim (new octave_idx_type [2*n]),
       cdim (dim + n), idx (new idx_vector [n])
   {
     assert (n > 0 && (dv.length () == std::max (n, 2)));
 
     dim[0] = dv(0);
     cdim[0] = 1;
     idx[0] = ia(0);
 
@@ -832,17 +832,17 @@ Array<T>::index (const idx_vector& i, co
 
   return retval;
 }
 
 template <class T>
 Array<T>
 Array<T>::index (const Array<idx_vector>& ia) const
 {
-  int ial = ia.length ();
+  int ial = ia.numel ();
   Array<T> retval;
 
   // FIXME: is this dispatching necessary?
   if (ial == 1)
     retval = index (ia(0));
   else if (ial == 2)
     retval = index (ia(0), ia(1));
   else if (ial > 0)
@@ -1107,17 +1107,17 @@ Array<T>::index (const idx_vector& i, co
 template <class T>
 Array<T>
 Array<T>::index (const Array<idx_vector>& ia,
                  bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
-      int ial = ia.length ();
+      int ial = ia.numel ();
       dim_vector dv = dimensions.redim (ial);
       dim_vector dvx = dim_vector::alloc (ial);
       for (int i = 0; i < ial; i++) dvx(i) = ia(i).extent (dv(i));
       if (! (dvx == dv))
         {
           bool all_scalars = true;
           for (int i = 0; i < ial; i++)
             all_scalars = all_scalars && ia(i).is_scalar ();
@@ -1285,17 +1285,17 @@ Array<T>::assign (const idx_vector& i, c
     gripe_assignment_dimension_mismatch ();
 }
 
 template <class T>
 void
 Array<T>::assign (const Array<idx_vector>& ia,
                   const Array<T>& rhs, const T& rfv)
 {
-  int ial = ia.length ();
+  int ial = ia.numel ();
 
   // FIXME: is this dispatching necessary / desirable?
   if (ial == 1)
     assign (ia(0), rhs, rfv);
   else if (ial == 2)
     assign (ia(0), ia(1), rhs, rfv);
   else if (ial > 0)
     {
@@ -1487,17 +1487,17 @@ Array<T>::delete_elements (int dim, cons
         }
     }
 }
 
 template <class T>
 void
 Array<T>::delete_elements (const Array<idx_vector>& ia)
 {
-  int ial = ia.length ();
+  int ial = ia.numel ();
 
   if (ial == 1)
     delete_elements (ia(0));
   else
     {
       int k, dim = -1;
       for (k = 0; k < ial; k++)
         {
@@ -1585,17 +1585,17 @@ Array<T>::insert (const Array<T>& a, oct
 
   return *this;
 }
 
 template <class T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, const Array<octave_idx_type>& ra_idx)
 {
-  octave_idx_type n = ra_idx.length ();
+  octave_idx_type n = ra_idx.numel ();
   Array<idx_vector> idx (dim_vector (n, 1));
   const dim_vector dva = a.dims ().redim (n);
   for (octave_idx_type k = 0; k < n; k++)
     idx(k) = idx_vector (ra_idx(k), ra_idx(k) + dva(k));
 
   assign (idx, a);
 
   return *this;
@@ -1771,17 +1771,17 @@ Array<T>::sort (int dim, sortmode mode) 
         ("sort: invalid dimension");
       return Array<T> ();
     }
 
   Array<T> m (dims ());
 
   dim_vector dv = m.dims ();
 
-  if (m.length () < 1)
+  if (m.numel () < 1)
     return m;
 
   if (dim >= dv.length ())
     dv.resize (dim+1, 1);
 
   octave_idx_type ns = dv(dim);
   octave_idx_type iter = dv.numel () / ns;
   octave_idx_type stride = 1;
@@ -1892,17 +1892,17 @@ Array<T>::sort (Array<octave_idx_type> &
         ("sort: invalid dimension");
       return Array<T> ();
     }
 
   Array<T> m (dims ());
 
   dim_vector dv = m.dims ();
 
-  if (m.length () < 1)
+  if (m.numel () < 1)
     {
       sidx = Array<octave_idx_type> (dv);
       return m;
     }
 
   octave_idx_type ns = dv(dim);
   octave_idx_type iter = dv.numel () / ns;
   octave_idx_type stride = 1;
@@ -2312,17 +2312,17 @@ Array<T>::find (octave_idx_type n, bool 
   // find (zeros (1,1)) -> zeros (0,0) !!!! WHY?
   // find (zeros (0,1,0)) -> zeros (0,0)
   // find (zeros (0,1,0,1)) -> zeros (0,0) etc
 
   if ((numel () == 1 && retval.is_empty ())
       || (rows () == 0 && dims ().numel (1) == 0))
     retval.dimensions = dim_vector ();
   else if (rows () == 1 && ndims () == 2)
-    retval.dimensions = dim_vector (1, retval.length ());
+    retval.dimensions = dim_vector (1, retval.numel ());
 
   return retval;
 }
 
 template <class T>
 Array<T>
 Array<T>::nth_element (const idx_vector& n, int dim) const
 {
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -83,17 +83,17 @@ protected:
     ArrayRep (const ArrayRep& a)
       : data (new T [a.len]), len (a.len), count (1)
     {
       std::copy (a.data, a.data + a.len, data);
     }
 
     ~ArrayRep (void) { delete [] data; }
 
-    octave_idx_type length (void) const { return len; }
+    octave_idx_type numel (void) const { return len; }
 
   private:
 
     // No assignment!
 
     ArrayRep& operator = (const ArrayRep& a);
   };
 
@@ -198,17 +198,17 @@ public:
 
   //! Reshape constructor.
   Array (const Array<T>& a, const dim_vector& dv);
 
   //! Type conversion case.
   template <class U>
   Array (const Array<U>& a)
     : dimensions (a.dims ()),
-      rep (new typename Array<T>::ArrayRep (a.data (), a.length ())),
+      rep (new typename Array<T>::ArrayRep (a.data (), a.numel ())),
       slice_data (rep->data), slice_len (rep->len)
   { }
 
   //! No type conversion case.
   Array (const Array<T>& a)
     : dimensions (a.dimensions), rep (a.rep), slice_data (a.slice_data),
       slice_len (a.slice_len)
   {
@@ -261,17 +261,17 @@ public:
       @note This method is deprecated in favour of numel().
 
       @note
       This is @em not the same as @c %length() at the Octave interpreter.
       At the Octave interpreter, the function @c %length() returns the
       length of the greatest dimension.  This method returns the total
       number of elements.
    */
-  octave_idx_type length (void) const { return numel (); }
+  GCC_ATTR_DEPRECATED octave_idx_type length (void) const { return numel (); }
 
   //! Number of elements in the array.
   //! Synonymous with numel().
   //! @note This method is deprecated in favour of numel().
   GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return numel (); }
 
   //! Number of elements in the array.
   octave_idx_type numel (void) const { return slice_len; }
@@ -343,17 +343,17 @@ public:
 
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j) const;
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j,
                                  octave_idx_type k) const;
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
   octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx)
   const
-  { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
+  { return dimensions.compute_index (ra_idx.data (), ra_idx.numel ()); }
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n) { return slice_data[n]; }
   crefT xelem (octave_idx_type n) const { return slice_data[n]; }
 
   T& xelem (octave_idx_type i, octave_idx_type j)
   { return xelem (dim1 ()*j+i); }
@@ -655,17 +655,17 @@ public:
   cat (int dim, octave_idx_type n, const Array<T> *array_list);
 
   //! Apply function fcn to each element of the Array<T>. This function
   //! is optimised with a manually unrolled loop.
   template <class U, class F>
   Array<U>
   map (F fcn) const
   {
-    octave_idx_type len = length ();
+    octave_idx_type len = numel ();
 
     const T *m = data ();
 
     Array<U> result (dims ());
     U *p = result.fortran_vec ();
 
     octave_idx_type i;
     for (i = 0; i < len - 3; i += 4)
@@ -698,17 +698,17 @@ public:
   map (U (&fcn) (const T&)) const
   { return map<U, U (&) (const T&)> (fcn); }
   //@}
 
   //! Generic any/all test functionality with arbitrary predicate.
   template <class F, bool zero>
   bool test (F fcn) const
   {
-    return any_all_test<F, T, zero> (fcn, data (), length ());
+    return any_all_test<F, T, zero> (fcn, data (), numel ());
   }
 
   //@{
   //! Simpler calls.
   template <class F>
   bool test_any (F fcn) const
   { return test<F, false> (fcn); }
 
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -55,36 +55,36 @@ extern "C"
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
   : MArray<Complex> (a)
 {
 }
 
 bool
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 ComplexColumnVector::operator != (const ComplexColumnVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ColumnVector& a, octave_idx_type r)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (r < 0 || r + a_len > length ())
+  if (r < 0 || r + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -94,19 +94,19 @@ ComplexColumnVector::insert (const Colum
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ComplexColumnVector& a, octave_idx_type r)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (r < 0 || r + a_len > length ())
+  if (r < 0 || r + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -116,50 +116,50 @@ ComplexColumnVector::insert (const Compl
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { std::swap (r1, r2); }
@@ -174,17 +174,17 @@ ComplexColumnVector::fill (double val, o
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val,
                            octave_idx_type r1, octave_idx_type r2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { std::swap (r1, r2); }
@@ -198,30 +198,30 @@ ComplexColumnVector::fill (const Complex
     }
 
   return *this;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ColumnVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nr_insert = len;
-  ComplexColumnVector retval (len + a.length ());
+  ComplexColumnVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ComplexColumnVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nr_insert = len;
-  ComplexColumnVector retval (len + a.length ());
+  ComplexColumnVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 ComplexRowVector
 ComplexColumnVector::hermitian (void) const
 {
@@ -274,19 +274,19 @@ ComplexColumnVector::extract_n (octave_i
   return result;
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -296,19 +296,19 @@ ComplexColumnVector::operator += (const 
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -332,17 +332,17 @@ operator * (const ComplexMatrix& m, cons
 ComplexColumnVector
 operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
 {
   ComplexColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
@@ -377,17 +377,17 @@ operator * (const Matrix& m, const Compl
 // diagonal matrix by column vector -> column vector operations
 
 ComplexColumnVector
 operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
@@ -405,17 +405,17 @@ operator * (const DiagMatrix& m, const C
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
@@ -433,17 +433,17 @@ operator * (const ComplexDiagMatrix& m, 
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
@@ -460,17 +460,17 @@ operator * (const ComplexDiagMatrix& m, 
   return result;
 }
 
 // other operations
 
 Complex
 ComplexColumnVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
@@ -480,17 +480,17 @@ ComplexColumnVector::min (void) const
       }
 
   return res;
 }
 
 Complex
 ComplexColumnVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
@@ -503,25 +503,25 @@ ComplexColumnVector::max (void) const
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexColumnVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -105,128 +105,128 @@ ComplexDiagMatrix::fill (const Complex& 
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -361,17 +361,17 @@ ComplexMatrix::ComplexMatrix (const Matr
 }
 
 bool
 ComplexMatrix::operator == (const ComplexMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return false;
 
-  return mx_inline_equal (length (), data (), a.data ());
+  return mx_inline_equal (numel (), data (), a.data ());
 }
 
 bool
 ComplexMatrix::operator != (const ComplexMatrix& a) const
 {
   return !(*this == a);
 }
 
@@ -418,17 +418,17 @@ ComplexMatrix::insert (const Matrix& a, 
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -441,17 +441,17 @@ ComplexMatrix::insert (const RowVector& 
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ColumnVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -500,34 +500,34 @@ ComplexMatrix::insert (const ComplexMatr
   ComplexNDArray::insert (a, r, c);
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexRowVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexColumnVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -688,28 +688,28 @@ ComplexMatrix::append (const RowVector& 
   octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.length ());
+  ComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nr != a.length ())
+  if (nr != a.numel ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
@@ -760,28 +760,28 @@ ComplexMatrix::append (const ComplexRowV
   octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.length ());
+  ComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nr != a.length ())
+  if (nr != a.numel ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
@@ -826,17 +826,17 @@ ComplexMatrix::stack (const Matrix& a) c
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nc != a.length ())
+  if (nc != a.numel ())
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
@@ -853,17 +853,17 @@ ComplexMatrix::stack (const ColumnVector
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
-  ComplexMatrix retval (nr + a.length (), nc);
+  ComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const DiagMatrix& a) const
 {
@@ -902,17 +902,17 @@ ComplexMatrix::stack (const ComplexMatri
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nc != a.length ())
+  if (nc != a.numel ())
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
@@ -929,17 +929,17 @@ ComplexMatrix::stack (const ComplexColum
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
-  ComplexMatrix retval (nr + a.length (), nc);
+  ComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexDiagMatrix& a) const
 {
@@ -1224,17 +1224,17 @@ ComplexMatrix::pseudo_inverse (double to
   ComplexSVD result (*this, SVD::economy);
 
   DiagMatrix S = result.singular_values ();
   ComplexMatrix U = result.left_singular_matrix ();
   ComplexMatrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.extract_diag ();
 
-  octave_idx_type r = sigma.length () - 1;
+  octave_idx_type r = sigma.numel () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
         tol = nr * sigma.elem (0) * std::numeric_limits<double>::epsilon ();
       else
@@ -2839,17 +2839,17 @@ ComplexMatrix::lssolve (const ComplexCol
 {
   ComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m != b.length ())
+  if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
@@ -2952,21 +2952,21 @@ operator * (const ComplexColumnVector& a
   return a * tmp;
 }
 
 ComplexMatrix
 operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
 {
   ComplexMatrix retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.length ();
+      octave_idx_type a_len = a.numel ();
 
       retval = ComplexMatrix (len, a_len);
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -3080,17 +3080,17 @@ ComplexMatrix::operator += (const Matrix
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  mx_inline_add2 (length (), d, a.data ());
+  mx_inline_add2 (numel (), d, a.data ());
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const Matrix& a)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3104,17 +3104,17 @@ ComplexMatrix::operator -= (const Matrix
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  mx_inline_sub2 (length (), d, a.data ());
+  mx_inline_sub2 (numel (), d, a.data ());
   return *this;
 }
 
 // other operations
 
 boolMatrix
 ComplexMatrix::all (int dim) const
 {
@@ -3996,19 +3996,19 @@ max (const ComplexMatrix& a, const Compl
 
 ComplexMatrix linspace (const ComplexColumnVector& x1,
                         const ComplexColumnVector& x2,
                         octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
-  octave_idx_type m = x1.length ();
-
-  if (x2.length () != m)
+  octave_idx_type m = x1.numel ();
+
+  if (x2.numel () != m)
     (*current_liboctave_error_handler)
       ("linspace: vectors must be of equal length");
 
   NoAlias<ComplexMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -54,36 +54,36 @@ extern "C"
                              const octave_idx_type&, Complex&);
 }
 
 // Complex Row Vector class
 
 bool
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 ComplexRowVector::operator != (const ComplexRowVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexRowVector&
 ComplexRowVector::insert (const RowVector& a, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (c < 0 || c + a_len > length ())
+  if (c < 0 || c + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -93,19 +93,19 @@ ComplexRowVector::insert (const RowVecto
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::insert (const ComplexRowVector& a, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (c < 0 || c + a_len > length ())
+  if (c < 0 || c + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -115,49 +115,49 @@ ComplexRowVector::insert (const ComplexR
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { std::swap (c1, c2); }
@@ -172,17 +172,17 @@ ComplexRowVector::fill (double val, octa
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val,
                         octave_idx_type c1, octave_idx_type c2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { std::swap (c1, c2); }
@@ -196,30 +196,30 @@ ComplexRowVector::fill (const Complex& v
     }
 
   return *this;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const RowVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nc_insert = len;
-  ComplexRowVector retval (len + a.length ());
+  ComplexRowVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const ComplexRowVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nc_insert = len;
-  ComplexRowVector retval (len + a.length ());
+  ComplexRowVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ComplexColumnVector
 ComplexRowVector::hermitian (void) const
 {
@@ -266,19 +266,19 @@ ComplexRowVector::extract_n (octave_idx_
   return result;
 }
 
 // row vector by row vector -> row vector operations
 
 ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -288,19 +288,19 @@ ComplexRowVector::operator += (const Row
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -314,17 +314,17 @@ ComplexRowVector::operator -= (const Row
 
 // row vector by matrix -> row vector
 
 ComplexRowVector
 operator * (const ComplexRowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
@@ -356,17 +356,17 @@ operator * (const RowVector& v, const Co
   return tmp * a;
 }
 
 // other operations
 
 Complex
 ComplexRowVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
@@ -376,17 +376,17 @@ ComplexRowVector::min (void) const
       }
 
   return res;
 }
 
 Complex
 ComplexRowVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
@@ -399,25 +399,25 @@ ComplexRowVector::max (void) const
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexRowVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
@@ -440,19 +440,19 @@ operator * (const ComplexRowVector& v, c
   return v * tmp;
 }
 
 Complex
 operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
 {
   Complex retval (0.0, 0.0);
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     gripe_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xzdotu, XZDOTU) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 
 template <class T>
 DiagArray2<T>::DiagArray2 (const Array<T>& a, octave_idx_type r,
                            octave_idx_type c)
   : Array<T> (a.as_column ()), d1 (r), d2 (c)
 {
   octave_idx_type rcmin = std::min (r, c);
-  if (rcmin != a.length ())
+  if (rcmin != a.numel ())
     Array<T>::resize (dim_vector (rcmin, 1));
 }
 
 template <class T>
 Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
   return extract_diag (k);
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -82,19 +82,19 @@ public:
 
   octave_idx_type dim1 (void) const { return d1; }
   octave_idx_type dim2 (void) const { return d2; }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
-  octave_idx_type diag_length (void) const { return Array<T>::length (); }
+  octave_idx_type diag_length (void) const { return Array<T>::numel (); }
   // FIXME: a dangerous ambiguity?
-  octave_idx_type length (void) const { return Array<T>::length (); }
+  octave_idx_type length (void) const { return Array<T>::numel (); }
   octave_idx_type nelem (void) const { return dim1 () * dim2 (); }
   octave_idx_type numel (void) const { return nelem (); }
 
   size_t byte_size (void) const { return Array<T>::byte_size (); }
 
   dim_vector dims (void) const { return dim_vector (d1, d2); }
 
   Array<T> diag (octave_idx_type k = 0) const GCC_ATTR_DEPRECATED;
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -51,17 +51,17 @@ struct _idxadda_helper
   void operator () (octave_idx_type i)
   { array[i] += *vals++; }
 };
 
 template <class T>
 void
 MArray<T>::idx_add (const idx_vector& idx, T val)
 {
-  octave_idx_type n = this->length ();
+  octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
       n = ext;
     }
 
   octave_quit ();
@@ -69,27 +69,27 @@ MArray<T>::idx_add (const idx_vector& id
   octave_idx_type len = idx.length (n);
   idx.loop (len, _idxadds_helper<T> (this->fortran_vec (), val));
 }
 
 template <class T>
 void
 MArray<T>::idx_add (const idx_vector& idx, const MArray<T>& vals)
 {
-  octave_idx_type n = this->length ();
+  octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
       n = ext;
     }
 
   octave_quit ();
 
-  octave_idx_type len = std::min (idx.length (n), vals.length ());
+  octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
 }
 
 template <class T, T op (typename ref_param<T>::type,
                          typename ref_param<T>::type)>
 struct _idxbinop_helper
 {
   T *array;
@@ -98,46 +98,46 @@ struct _idxbinop_helper
   void operator () (octave_idx_type i)
   { array[i] = op (array[i], *vals++); }
 };
 
 template <class T>
 void
 MArray<T>::idx_min (const idx_vector& idx, const MArray<T>& vals)
 {
-  octave_idx_type n = this->length ();
+  octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
       n = ext;
     }
 
   octave_quit ();
 
-  octave_idx_type len = std::min (idx.length (n), vals.length ());
+  octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxbinop_helper<T, xmin> (this->fortran_vec (),
                                             vals.data ()));
 }
 
 template <class T>
 void
 MArray<T>::idx_max (const idx_vector& idx, const MArray<T>& vals)
 {
-  octave_idx_type n = this->length ();
+  octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
       n = ext;
     }
 
   octave_quit ();
 
-  octave_idx_type len = std::min (idx.length (n), vals.length ());
+  octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxbinop_helper<T, xmax> (this->fortran_vec (),
                                             vals.data ()));
 }
 
 #include <iostream>
 
 template <class T>
 void MArray<T>::idx_add_nd (const idx_vector& idx, const MArray<T>& vals,
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -36,17 +36,17 @@ gripe_invalid_permutation (void)
     ("PermMatrix: invalid permutation vector");
 }
 
 void
 PermMatrix::setup (const Array<octave_idx_type>& p, bool colp, bool check)
 {
   if (check)
     {
-      if (! idx_vector (p).is_permutation (p.length ()))
+      if (! idx_vector (p).is_permutation (p.numel ()))
         {
           gripe_invalid_permutation ();
           Array<octave_idx_type>::operator = (Array<octave_idx_type> ());
         }
     }
 
   if (!colp)
     *this = this->transpose ();
@@ -99,31 +99,31 @@ PermMatrix::PermMatrix (octave_idx_type 
 {
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = i;
 }
 
 octave_idx_type
 PermMatrix::checkelem (octave_idx_type i, octave_idx_type j) const
 {
-  octave_idx_type len = Array<octave_idx_type>::length ();
+  octave_idx_type len = Array<octave_idx_type>::numel ();
   if (i < 0 || j < 0 || i > len || j > len)
     {
       (*current_liboctave_error_handler) ("index out of range");
       return 0;
     }
   else
     return elem (i, j);
 }
 
 
 PermMatrix
 PermMatrix::transpose (void) const
 {
-  octave_idx_type len = Array<octave_idx_type>::length ();
+  octave_idx_type len = Array<octave_idx_type>::numel ();
 
   PermMatrix retval (len);
 
   for (octave_idx_type i = 0; i < len; ++i)
     retval.xelem (xelem (i)) = i;
 
   return retval;
 }
diff --git a/liboctave/array/PermMatrix.h b/liboctave/array/PermMatrix.h
--- a/liboctave/array/PermMatrix.h
+++ b/liboctave/array/PermMatrix.h
@@ -43,26 +43,26 @@ public:
 
   PermMatrix (const PermMatrix& m) : Array<octave_idx_type> (m) { }
 
   PermMatrix (const idx_vector& idx) GCC_ATTR_DEPRECATED;
 
   PermMatrix (const idx_vector& idx, bool colp, octave_idx_type n = 0);
 
   octave_idx_type dim1 (void) const
-  { return Array<octave_idx_type>::length (); }
+  { return Array<octave_idx_type>::numel (); }
   octave_idx_type dim2 (void) const
-  { return Array<octave_idx_type>::length (); }
+  { return Array<octave_idx_type>::numel (); }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
   octave_idx_type perm_length (void) const
-  { return Array<octave_idx_type>::length (); }
+  { return Array<octave_idx_type>::numel (); }
   // FIXME: a dangerous ambiguity?
   octave_idx_type length (void) const
   { return perm_length (); }
   GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return numel (); }
   octave_idx_type numel (void) const { return dim1 () * dim2 (); }
 
   size_t byte_size (void) const
   { return Array<octave_idx_type>::byte_size (); }
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -641,17 +641,17 @@ Sparse<T>::Sparse (const Array<T>& a)
 {
   if (dimensions.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
   else
     {
       octave_idx_type nr = rows ();
       octave_idx_type nc = cols ();
-      octave_idx_type len = a.length ();
+      octave_idx_type len = a.numel ();
       octave_idx_type new_nzmx = 0;
 
       // First count the number of nonzero terms
       for (octave_idx_type i = 0; i < len; i++)
         if (a(i) != T ())
           new_nzmx++;
 
       rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
@@ -699,17 +699,17 @@ Sparse<T>::operator = (const Sparse<T>& 
 template <class T>
 octave_idx_type
 Sparse<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
   octave_idx_type retval = -1;
 
   octave_idx_type n = dimensions.length ();
 
-  if (n > 0 && n == ra_idx.length ())
+  if (n > 0 && n == ra_idx.numel ())
     {
       retval = ra_idx(--n);
 
       while (--n >= 0)
         {
           retval *= dimensions(n);
           retval += ra_idx(n);
         }
@@ -762,17 +762,17 @@ template <class T>
 T
 Sparse<T>::range_error (const char *fcn,
                         const Array<octave_idx_type>& ra_idx) const
 {
   std::ostringstream buf;
 
   buf << fcn << " (";
 
-  octave_idx_type n = ra_idx.length ();
+  octave_idx_type n = ra_idx.numel ();
 
   if (n > 0)
     buf << ra_idx(0);
 
   for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
@@ -787,17 +787,17 @@ Sparse<T>::range_error (const char *fcn,
 template <class T>
 T&
 Sparse<T>::range_error (const char *fcn, const Array<octave_idx_type>& ra_idx)
 {
   std::ostringstream buf;
 
   buf << fcn << " (";
 
-  octave_idx_type n = ra_idx.length ();
+  octave_idx_type n = ra_idx.numel ();
 
   if (n > 0)
     buf << ra_idx(0);
 
   for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
@@ -881,17 +881,17 @@ template <class T>
 Sparse<T>
 Sparse<T>::permute (const Array<octave_idx_type>& perm_vec, bool) const
 {
   // The only valid permutations of a sparse array are [1, 2] and [2, 1].
 
   bool fail = false;
   bool trans = false;
 
-  if (perm_vec.length () == 2)
+  if (perm_vec.numel () == 2)
     {
       if (perm_vec(0) == 0 && perm_vec(1) == 1)
         /* do nothing */;
       else if (perm_vec(0) == 1 && perm_vec(1) == 0)
         trans = true;
       else
         fail = true;
     }
@@ -1077,17 +1077,17 @@ Sparse<T>::insert (const Sparse<T>& a, o
   return *this;
 }
 
 template <class T>
 Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, const Array<octave_idx_type>& ra_idx)
 {
 
-  if (ra_idx.length () != 2)
+  if (ra_idx.numel () != 2)
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   return insert (a, ra_idx(0), ra_idx(1));
 }
 
@@ -2239,17 +2239,17 @@ template <class T>
 Sparse<T>
 Sparse<T>::sort (octave_idx_type dim, sortmode mode) const
 {
   Sparse<T> m = *this;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
-  if (m.length () < 1 || dim > 1)
+  if (m.numel () < 1 || dim > 1)
     return m;
 
   if (dim > 0)
     {
       m = m.transpose ();
       nr = m.rows ();
       nc = m.columns ();
     }
@@ -2305,17 +2305,17 @@ Sparse<T>
 Sparse<T>::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                  sortmode mode) const
 {
   Sparse<T> m = *this;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
-  if (m.length () < 1 || dim > 1)
+  if (m.numel () < 1 || dim > 1)
     {
       sidx = Array<octave_idx_type> (dim_vector (nr, nc), 1);
       return m;
     }
 
   if (dim > 0)
     {
       m = m.transpose ();
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -252,17 +252,17 @@ public:
   // Querying the number of elements (incl. zeros) may overflow the index type,
   // so don't do it unless you really need it.
   octave_idx_type numel (void) const
   {
     return dimensions.safe_numel ();
   }
 
   GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return nzmax (); }
-  octave_idx_type length (void) const { return numel (); }
+  GCC_ATTR_DEPRECATED octave_idx_type length (void) const { return numel (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
diff --git a/liboctave/array/boolMatrix.cc b/liboctave/array/boolMatrix.cc
--- a/liboctave/array/boolMatrix.cc
+++ b/liboctave/array/boolMatrix.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // boolMatrix class.
 
 bool
 boolMatrix::operator == (const boolMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
-  return mx_inline_equal (length (), data (), a.data ());
+  return mx_inline_equal (numel (), data (), a.data ());
 }
 
 bool
 boolMatrix::operator != (const boolMatrix& a) const
 {
   return !(*this == a);
 }
 
diff --git a/liboctave/array/chMatrix.cc b/liboctave/array/chMatrix.cc
--- a/liboctave/array/chMatrix.cc
+++ b/liboctave/array/chMatrix.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 // charMatrix class.
 
 bool
 charMatrix::operator == (const charMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
-  return mx_inline_equal (length (), data (), a.data ());
+  return mx_inline_equal (numel (), data (), a.data ());
 }
 
 bool
 charMatrix::operator != (const charMatrix& a) const
 {
   return !(*this == a);
 }
 
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -65,17 +65,17 @@ charNDArray::charNDArray (const std::str
 
   resize1 (n);
 
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 charNDArray::charNDArray (const string_vector& s, char fill_value)
-  : Array<char> (dim_vector (s.length (), s.max_length ()), fill_value)
+  : Array<char> (dim_vector (s.numel (), s.max_length ()), fill_value)
 {
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       const std::string si = s(i);
       octave_idx_type nc = si.length ();
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -50,34 +50,34 @@ extern "C"
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 // Column Vector class.
 
 bool
 ColumnVector::operator == (const ColumnVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 ColumnVector::operator != (const ColumnVector& a) const
 {
   return !(*this == a);
 }
 
 ColumnVector&
 ColumnVector::insert (const ColumnVector& a, octave_idx_type r)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (r < 0 || r + a_len > length ())
+  if (r < 0 || r + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -87,33 +87,33 @@ ColumnVector::insert (const ColumnVector
     }
 
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { std::swap (r1, r2); }
@@ -127,19 +127,19 @@ ColumnVector::fill (double val, octave_i
     }
 
   return *this;
 }
 
 ColumnVector
 ColumnVector::stack (const ColumnVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nr_insert = len;
-  ColumnVector retval (len + a.length ());
+  ColumnVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 RowVector
 ColumnVector::transpose (void) const
 {
@@ -197,17 +197,17 @@ ColumnVector::extract_n (octave_idx_type
 ColumnVector
 operator * (const Matrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
@@ -234,17 +234,17 @@ operator * (const Matrix& m, const Colum
 ColumnVector
 operator * (const DiagMatrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
         retval.resize (nr, 0.0);
       else
@@ -262,58 +262,58 @@ operator * (const DiagMatrix& m, const C
   return retval;
 }
 
 // other operations
 
 double
 ColumnVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   double res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) < res)
       res = elem (i);
 
   return res;
 }
 
 double
 ColumnVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   double res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
 
   return res;
 }
 
 std::ostream&
 operator << (std::ostream& os, const ColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ColumnVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -73,64 +73,64 @@ DiagMatrix::fill (double val, octave_idx
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -301,17 +301,17 @@ Matrix::Matrix (const charMatrix& a)
 }
 
 bool
 Matrix::operator == (const Matrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return false;
 
-  return mx_inline_equal (length (), data (), a.data ());
+  return mx_inline_equal (numel (), data (), a.data ());
 }
 
 bool
 Matrix::operator != (const Matrix& a) const
 {
   return !(*this == a);
 }
 
@@ -336,17 +336,17 @@ Matrix::insert (const Matrix& a, octave_
 {
   Array<double>::insert (a, r, c);
   return *this;
 }
 
 Matrix&
 Matrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -358,17 +358,17 @@ Matrix::insert (const RowVector& a, octa
     }
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -481,28 +481,28 @@ Matrix::append (const RowVector& a) cons
   octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
   octave_idx_type nc_insert = nc;
-  Matrix retval (nr, nc + a.length ());
+  Matrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nr != a.length ())
+  if (nr != a.numel ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
   octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
@@ -547,17 +547,17 @@ Matrix::stack (const Matrix& a) const
   return retval;
 }
 
 Matrix
 Matrix::stack (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nc != a.length ())
+  if (nc != a.numel ())
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return Matrix ();
     }
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + 1, nc);
@@ -574,17 +574,17 @@ Matrix::stack (const ColumnVector& a) co
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return Matrix ();
     }
 
   octave_idx_type nr_insert = nr;
-  Matrix retval (nr + a.length (), nc);
+  Matrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const DiagMatrix& a) const
 {
@@ -872,17 +872,17 @@ Matrix::pseudo_inverse (double tol) cons
   SVD result (*this, SVD::economy);
 
   DiagMatrix S = result.singular_values ();
   Matrix U = result.left_singular_matrix ();
   Matrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.extract_diag ();
 
-  octave_idx_type r = sigma.length () - 1;
+  octave_idx_type r = sigma.numel () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
         tol = nr * sigma.elem (0) * std::numeric_limits<double>::epsilon ();
       else
@@ -2462,17 +2462,17 @@ Matrix::lssolve (const ColumnVector& b, 
 {
   ColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m != b.length ())
+  if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
@@ -2631,21 +2631,21 @@ Matrix::operator -= (const DiagMatrix& a
 
 // column vector by row vector -> matrix operations
 
 Matrix
 operator * (const ColumnVector& v, const RowVector& a)
 {
   Matrix retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.length ();
+      octave_idx_type a_len = a.numel ();
 
       retval = Matrix (len, a_len);
       double *c = retval.fortran_vec ();
 
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -3327,19 +3327,19 @@ max (const Matrix& a, const Matrix& b)
 
 Matrix linspace (const ColumnVector& x1,
                  const ColumnVector& x2,
                  octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
-  octave_idx_type m = x1.length ();
-
-  if (x2.length () != m)
+  octave_idx_type m = x1.numel ();
+
+  if (x2.numel () != m)
     (*current_liboctave_error_handler)
       ("linspace: vectors must be of equal length");
 
   NoAlias<Matrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -53,34 +53,34 @@ extern "C"
                            const octave_idx_type&, double&);
 }
 
 // Row Vector class.
 
 bool
 RowVector::operator == (const RowVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 RowVector::operator != (const RowVector& a) const
 {
   return !(*this == a);
 }
 
 RowVector&
 RowVector::insert (const RowVector& a, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (c < 0 || c + a_len > length ())
+  if (c < 0 || c + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -90,33 +90,33 @@ RowVector::insert (const RowVector& a, o
     }
 
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { std::swap (c1, c2); }
@@ -130,19 +130,19 @@ RowVector::fill (double val, octave_idx_
     }
 
   return *this;
 }
 
 RowVector
 RowVector::append (const RowVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nc_insert = len;
-  RowVector retval (len + a.length ());
+  RowVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ColumnVector
 RowVector::transpose (void) const
 {
@@ -189,17 +189,17 @@ RowVector::extract_n (octave_idx_type r1
 
 // row vector by matrix -> row vector
 
 RowVector
 operator * (const RowVector& v, const Matrix& a)
 {
   RowVector retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
@@ -224,33 +224,33 @@ operator * (const RowVector& v, const Ma
   return retval;
 }
 
 // other operations
 
 double
 RowVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0;
 
   double res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) < res)
       res = elem (i);
 
   return res;
 }
 
 double
 RowVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0;
 
   double res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
@@ -258,25 +258,25 @@ RowVector::max (void) const
   return res;
 }
 
 std::ostream&
 operator << (std::ostream& os, const RowVector& a)
 {
 //  int field_width = os.precision () + 7;
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, RowVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
@@ -308,19 +308,19 @@ linspace (double x1, double x2, octave_i
 
 // row vector by column vector -> scalar
 
 double
 operator * (const RowVector& v, const ColumnVector& a)
 {
   double retval = 0.0;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     gripe_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xddot, XDDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -55,36 +55,36 @@ extern "C"
 FloatComplexColumnVector::FloatComplexColumnVector (const FloatColumnVector& a)
   : MArray<FloatComplex> (a)
 {
 }
 
 bool
 FloatComplexColumnVector::operator == (const FloatComplexColumnVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 FloatComplexColumnVector::operator != (const FloatComplexColumnVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::insert (const FloatColumnVector& a, octave_idx_type r)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (r < 0 || r + a_len > length ())
+  if (r < 0 || r + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -95,19 +95,19 @@ FloatComplexColumnVector::insert (const 
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::insert (const FloatComplexColumnVector& a,
                                   octave_idx_type r)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (r < 0 || r + a_len > length ())
+  if (r < 0 || r + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -117,33 +117,33 @@ FloatComplexColumnVector::insert (const 
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (float val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (const FloatComplex& val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
@@ -151,17 +151,17 @@ FloatComplexColumnVector::fill (const Fl
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (float val,
                                 octave_idx_type r1, octave_idx_type r2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { std::swap (r1, r2); }
@@ -176,17 +176,17 @@ FloatComplexColumnVector::fill (float va
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (const FloatComplex& val,
                                 octave_idx_type r1, octave_idx_type r2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { std::swap (r1, r2); }
@@ -200,30 +200,30 @@ FloatComplexColumnVector::fill (const Fl
     }
 
   return *this;
 }
 
 FloatComplexColumnVector
 FloatComplexColumnVector::stack (const FloatColumnVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nr_insert = len;
-  FloatComplexColumnVector retval (len + a.length ());
+  FloatComplexColumnVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexColumnVector::stack (const FloatComplexColumnVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nr_insert = len;
-  FloatComplexColumnVector retval (len + a.length ());
+  FloatComplexColumnVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 FloatComplexRowVector
 FloatComplexColumnVector::hermitian (void) const
 {
@@ -277,19 +277,19 @@ FloatComplexColumnVector::extract_n (oct
   return result;
 }
 
 // column vector by column vector -> column vector operations
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator += (const FloatColumnVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -299,19 +299,19 @@ FloatComplexColumnVector::operator += (c
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator -= (const FloatColumnVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -335,17 +335,17 @@ operator * (const FloatComplexMatrix& m,
 FloatComplexColumnVector
 operator * (const FloatComplexMatrix& m, const FloatComplexColumnVector& a)
 {
   FloatComplexColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
@@ -379,17 +379,17 @@ operator * (const FloatMatrix& m, const 
 // diagonal matrix by column vector -> column vector operations
 
 FloatComplexColumnVector
 operator * (const FloatDiagMatrix& m, const FloatComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return FloatComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
@@ -407,17 +407,17 @@ operator * (const FloatDiagMatrix& m, co
 }
 
 FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return FloatComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
@@ -435,17 +435,17 @@ operator * (const FloatComplexDiagMatrix
 }
 
 FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return FloatComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
@@ -462,17 +462,17 @@ operator * (const FloatComplexDiagMatrix
   return result;
 }
 
 // other operations
 
 FloatComplex
 FloatComplexColumnVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
@@ -482,17 +482,17 @@ FloatComplexColumnVector::min (void) con
       }
 
   return res;
 }
 
 FloatComplex
 FloatComplexColumnVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
@@ -505,25 +505,25 @@ FloatComplexColumnVector::max (void) con
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexColumnVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -106,130 +106,130 @@ FloatComplexDiagMatrix::fill (const Floa
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatColumnVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexColumnVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatRowVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexRowVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatColumnVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexColumnVector& a,
                               octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatRowVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexRowVector& a,
                               octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -364,17 +364,17 @@ FloatComplexMatrix::FloatComplexMatrix (
 }
 
 bool
 FloatComplexMatrix::operator == (const FloatComplexMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return false;
 
-  return mx_inline_equal (length (), data (), a.data ());
+  return mx_inline_equal (numel (), data (), a.data ());
 }
 
 bool
 FloatComplexMatrix::operator != (const FloatComplexMatrix& a) const
 {
   return !(*this == a);
 }
 
@@ -423,17 +423,17 @@ FloatComplexMatrix::insert (const FloatM
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatRowVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -446,17 +446,17 @@ FloatComplexMatrix::insert (const FloatR
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatColumnVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -505,34 +505,34 @@ FloatComplexMatrix::insert (const FloatC
   Array<FloatComplex>::insert (a, r, c);
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexRowVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexColumnVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -694,28 +694,28 @@ FloatComplexMatrix::append (const FloatR
   octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
-  FloatComplexMatrix retval (nr, nc + a.length ());
+  FloatComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nr != a.length ())
+  if (nr != a.numel ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
@@ -766,28 +766,28 @@ FloatComplexMatrix::append (const FloatC
   octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
-  FloatComplexMatrix retval (nr, nc + a.length ());
+  FloatComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nr != a.length ())
+  if (nr != a.numel ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
@@ -832,17 +832,17 @@ FloatComplexMatrix::stack (const FloatMa
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nc != a.length ())
+  if (nc != a.numel ())
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + 1, nc);
@@ -859,17 +859,17 @@ FloatComplexMatrix::stack (const FloatCo
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
-  FloatComplexMatrix retval (nr + a.length (), nc);
+  FloatComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatDiagMatrix& a) const
 {
@@ -908,17 +908,17 @@ FloatComplexMatrix::stack (const FloatCo
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nc != a.length ())
+  if (nc != a.numel ())
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + 1, nc);
@@ -935,17 +935,17 @@ FloatComplexMatrix::stack (const FloatCo
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
-  FloatComplexMatrix retval (nr + a.length (), nc);
+  FloatComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexDiagMatrix& a) const
 {
@@ -1231,17 +1231,17 @@ FloatComplexMatrix::pseudo_inverse (floa
   FloatComplexSVD result (*this, SVD::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatComplexMatrix U = result.left_singular_matrix ();
   FloatComplexMatrix V = result.right_singular_matrix ();
 
   FloatColumnVector sigma = S.extract_diag ();
 
-  octave_idx_type r = sigma.length () - 1;
+  octave_idx_type r = sigma.numel () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
         tol = nr * sigma.elem (0) * std::numeric_limits<double>::epsilon ();
       else
@@ -2857,17 +2857,17 @@ FloatComplexMatrix::lssolve (const Float
 {
   FloatComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m != b.length ())
+  if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
@@ -2970,21 +2970,21 @@ operator * (const FloatComplexColumnVect
   return a * tmp;
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexColumnVector& v, const FloatComplexRowVector& a)
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.length ();
+      octave_idx_type a_len = a.numel ();
 
       retval = FloatComplexMatrix (len, a_len);
       FloatComplex *c = retval.fortran_vec ();
 
       F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -3098,17 +3098,17 @@ FloatComplexMatrix::operator += (const F
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
-  mx_inline_add2 (length (), d, a.data ());
+  mx_inline_add2 (numel (), d, a.data ());
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::operator -= (const FloatMatrix& a)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3122,17 +3122,17 @@ FloatComplexMatrix::operator -= (const F
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
-  mx_inline_sub2 (length (), d, a.data ());
+  mx_inline_sub2 (numel (), d, a.data ());
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 FloatComplexMatrix::all (int dim) const
 {
@@ -4016,19 +4016,19 @@ max (const FloatComplexMatrix& a, const 
 
 FloatComplexMatrix linspace (const FloatComplexColumnVector& x1,
                              const FloatComplexColumnVector& x2,
                              octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
-  octave_idx_type m = x1.length ();
-
-  if (x2.length () != m)
+  octave_idx_type m = x1.numel ();
+
+  if (x2.numel () != m)
     (*current_liboctave_error_handler)
       ("linspace: vectors must be of equal length");
 
   NoAlias<FloatComplexMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -54,36 +54,36 @@ extern "C"
                              const octave_idx_type&, FloatComplex&);
 }
 
 // FloatComplex Row Vector class
 
 bool
 FloatComplexRowVector::operator == (const FloatComplexRowVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 FloatComplexRowVector::operator != (const FloatComplexRowVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 FloatComplexRowVector&
 FloatComplexRowVector::insert (const FloatRowVector& a, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (c < 0 || c + a_len > length ())
+  if (c < 0 || c + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -94,19 +94,19 @@ FloatComplexRowVector::insert (const Flo
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::insert (const FloatComplexRowVector& a,
                                octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (c < 0 || c + a_len > length ())
+  if (c < 0 || c + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -116,49 +116,49 @@ FloatComplexRowVector::insert (const Flo
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (float val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (const FloatComplex& val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (float val, octave_idx_type c1, octave_idx_type c2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { std::swap (c1, c2); }
@@ -173,17 +173,17 @@ FloatComplexRowVector::fill (float val, 
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (const FloatComplex& val,
                              octave_idx_type c1, octave_idx_type c2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { std::swap (c1, c2); }
@@ -197,30 +197,30 @@ FloatComplexRowVector::fill (const Float
     }
 
   return *this;
 }
 
 FloatComplexRowVector
 FloatComplexRowVector::append (const FloatRowVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nc_insert = len;
-  FloatComplexRowVector retval (len + a.length ());
+  FloatComplexRowVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 FloatComplexRowVector
 FloatComplexRowVector::append (const FloatComplexRowVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nc_insert = len;
-  FloatComplexRowVector retval (len + a.length ());
+  FloatComplexRowVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexRowVector::hermitian (void) const
 {
@@ -267,19 +267,19 @@ FloatComplexRowVector::extract_n (octave
   return result;
 }
 
 // row vector by row vector -> row vector operations
 
 FloatComplexRowVector&
 FloatComplexRowVector::operator += (const FloatRowVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -289,19 +289,19 @@ FloatComplexRowVector::operator += (cons
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::operator -= (const FloatRowVector& a)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -315,17 +315,17 @@ FloatComplexRowVector::operator -= (cons
 
 // row vector by matrix -> row vector
 
 FloatComplexRowVector
 operator * (const FloatComplexRowVector& v, const FloatComplexMatrix& a)
 {
   FloatComplexRowVector retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
@@ -357,17 +357,17 @@ operator * (const FloatRowVector& v, con
   return tmp * a;
 }
 
 // other operations
 
 FloatComplex
 FloatComplexRowVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return FloatComplex (0.0);
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
@@ -377,17 +377,17 @@ FloatComplexRowVector::min (void) const
       }
 
   return res;
 }
 
 FloatComplex
 FloatComplexRowVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return FloatComplex (0.0);
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
@@ -400,25 +400,25 @@ FloatComplexRowVector::max (void) const
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexRowVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
@@ -441,19 +441,19 @@ operator * (const FloatComplexRowVector&
   return v * tmp;
 }
 
 FloatComplex
 operator * (const FloatComplexRowVector& v, const FloatComplexColumnVector& a)
 {
   FloatComplex retval (0.0, 0.0);
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     gripe_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xcdotu, XCDOTU) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -49,34 +49,34 @@ extern "C"
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 // Column Vector class.
 
 bool
 FloatColumnVector::operator == (const FloatColumnVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 FloatColumnVector::operator != (const FloatColumnVector& a) const
 {
   return !(*this == a);
 }
 
 FloatColumnVector&
 FloatColumnVector::insert (const FloatColumnVector& a, octave_idx_type r)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (r < 0 || r + a_len > length ())
+  if (r < 0 || r + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -86,33 +86,33 @@ FloatColumnVector::insert (const FloatCo
     }
 
   return *this;
 }
 
 FloatColumnVector&
 FloatColumnVector::fill (float val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatColumnVector&
 FloatColumnVector::fill (float val, octave_idx_type r1, octave_idx_type r2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { std::swap (r1, r2); }
@@ -126,19 +126,19 @@ FloatColumnVector::fill (float val, octa
     }
 
   return *this;
 }
 
 FloatColumnVector
 FloatColumnVector::stack (const FloatColumnVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nr_insert = len;
-  FloatColumnVector retval (len + a.length ());
+  FloatColumnVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 FloatRowVector
 FloatColumnVector::transpose (void) const
 {
@@ -196,17 +196,17 @@ FloatColumnVector::extract_n (octave_idx
 FloatColumnVector
 operator * (const FloatMatrix& m, const FloatColumnVector& a)
 {
   FloatColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
@@ -233,17 +233,17 @@ operator * (const FloatMatrix& m, const 
 FloatColumnVector
 operator * (const FloatDiagMatrix& m, const FloatColumnVector& a)
 {
   FloatColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
         retval.resize (nr, 0.0);
       else
@@ -261,58 +261,58 @@ operator * (const FloatDiagMatrix& m, co
   return retval;
 }
 
 // other operations
 
 float
 FloatColumnVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   float res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) < res)
       res = elem (i);
 
   return res;
 }
 
 float
 FloatColumnVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0.0;
 
   float res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
 
   return res;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatColumnVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -73,64 +73,64 @@ FloatDiagMatrix::fill (float val, octave
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatColumnVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatRowVector& a)
 {
   octave_idx_type len = length ();
-  if (a.length () != len)
+  if (a.numel () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatColumnVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatRowVector& a, octave_idx_type beg)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -304,17 +304,17 @@ FloatMatrix::FloatMatrix (const charMatr
 }
 
 bool
 FloatMatrix::operator == (const FloatMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return false;
 
-  return mx_inline_equal (length (), data (), a.data ());
+  return mx_inline_equal (numel (), data (), a.data ());
 }
 
 bool
 FloatMatrix::operator != (const FloatMatrix& a) const
 {
   return !(*this == a);
 }
 
@@ -341,17 +341,17 @@ FloatMatrix::insert (const FloatMatrix& 
   FloatNDArray::insert (a, r, c);
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::insert (const FloatRowVector& a,
                      octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -364,17 +364,17 @@ FloatMatrix::insert (const FloatRowVecto
 
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::insert (const FloatColumnVector& a,
                      octave_idx_type r, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
@@ -488,28 +488,28 @@ FloatMatrix::append (const FloatRowVecto
   octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return FloatMatrix ();
     }
 
   octave_idx_type nc_insert = nc;
-  FloatMatrix retval (nr, nc + a.length ());
+  FloatMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::append (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nr != a.length ())
+  if (nr != a.numel ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return FloatMatrix ();
     }
 
   octave_idx_type nc_insert = nc;
   FloatMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
@@ -554,17 +554,17 @@ FloatMatrix::stack (const FloatMatrix& a
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::stack (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  if (nc != a.length ())
+  if (nc != a.numel ())
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return FloatMatrix ();
     }
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + 1, nc);
@@ -581,17 +581,17 @@ FloatMatrix::stack (const FloatColumnVec
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
         ("column dimension mismatch for stack");
       return FloatMatrix ();
     }
 
   octave_idx_type nr_insert = nr;
-  FloatMatrix retval (nr + a.length (), nc);
+  FloatMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::stack (const FloatDiagMatrix& a) const
 {
@@ -879,17 +879,17 @@ FloatMatrix::pseudo_inverse (float tol) 
   FloatSVD result (*this, SVD::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatMatrix U = result.left_singular_matrix ();
   FloatMatrix V = result.right_singular_matrix ();
 
   FloatColumnVector sigma = S.extract_diag ();
 
-  octave_idx_type r = sigma.length () - 1;
+  octave_idx_type r = sigma.numel () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
         tol = nr * sigma.elem (0) * std::numeric_limits<double>::epsilon ();
       else
@@ -2486,17 +2486,17 @@ FloatMatrix::lssolve (const FloatColumnV
 {
   FloatColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
-  if (m != b.length ())
+  if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
@@ -2654,21 +2654,21 @@ FloatMatrix::operator -= (const FloatDia
 
 // column vector by row vector -> matrix operations
 
 FloatMatrix
 operator * (const FloatColumnVector& v, const FloatRowVector& a)
 {
   FloatMatrix retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.length ();
+      octave_idx_type a_len = a.numel ();
 
       retval = FloatMatrix (len, a_len);
       float *c = retval.fortran_vec ();
 
       F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -3332,19 +3332,19 @@ max (const FloatMatrix& a, const FloatMa
 
 FloatMatrix linspace (const FloatColumnVector& x1,
                       const FloatColumnVector& x2,
                       octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
-  octave_idx_type m = x1.length ();
-
-  if (x2.length () != m)
+  octave_idx_type m = x1.numel ();
+
+  if (x2.numel () != m)
     (*current_liboctave_error_handler)
       ("linspace: vectors must be of equal length");
 
   NoAlias<FloatMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -53,34 +53,34 @@ extern "C"
                            const octave_idx_type&, float&);
 }
 
 // Row Vector class.
 
 bool
 FloatRowVector::operator == (const FloatRowVector& a) const
 {
-  octave_idx_type len = length ();
-  if (len != a.length ())
+  octave_idx_type len = numel ();
+  if (len != a.numel ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
 
 bool
 FloatRowVector::operator != (const FloatRowVector& a) const
 {
   return !(*this == a);
 }
 
 FloatRowVector&
 FloatRowVector::insert (const FloatRowVector& a, octave_idx_type c)
 {
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
-  if (c < 0 || c + a_len > length ())
+  if (c < 0 || c + a_len > numel ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
@@ -90,33 +90,33 @@ FloatRowVector::insert (const FloatRowVe
     }
 
   return *this;
 }
 
 FloatRowVector&
 FloatRowVector::fill (float val)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatRowVector&
 FloatRowVector::fill (float val, octave_idx_type c1, octave_idx_type c2)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { std::swap (c1, c2); }
@@ -130,19 +130,19 @@ FloatRowVector::fill (float val, octave_
     }
 
   return *this;
 }
 
 FloatRowVector
 FloatRowVector::append (const FloatRowVector& a) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   octave_idx_type nc_insert = len;
-  FloatRowVector retval (len + a.length ());
+  FloatRowVector retval (len + a.numel ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 FloatColumnVector
 FloatRowVector::transpose (void) const
 {
@@ -189,17 +189,17 @@ FloatRowVector::extract_n (octave_idx_ty
 
 // row vector by matrix -> row vector
 
 FloatRowVector
 operator * (const FloatRowVector& v, const FloatMatrix& a)
 {
   FloatRowVector retval;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
@@ -224,33 +224,33 @@ operator * (const FloatRowVector& v, con
   return retval;
 }
 
 // other operations
 
 float
 FloatRowVector::min (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0;
 
   float res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) < res)
       res = elem (i);
 
   return res;
 }
 
 float
 FloatRowVector::max (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
   if (len == 0)
     return 0;
 
   float res = elem (0);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
@@ -258,25 +258,25 @@ FloatRowVector::max (void) const
   return res;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatRowVector& a)
 {
 //  int field_width = os.precision () + 7;
 
-  for (octave_idx_type i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.numel (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatRowVector& a)
 {
-  octave_idx_type len = a.length ();
+  octave_idx_type len = a.numel ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
@@ -308,19 +308,19 @@ linspace (float x1, float x2, octave_idx
 
 // row vector by column vector -> scalar
 
 float
 operator * (const FloatRowVector& v, const FloatColumnVector& a)
 {
   float retval = 0.0;
 
-  octave_idx_type len = v.length ();
+  octave_idx_type len = v.numel ();
 
-  octave_idx_type a_len = a.length ();
+  octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     gripe_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xsdot, XSDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -400,17 +400,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (! dv.all_zero ())
     orig_dims = ((dv.length () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
-      octave_idx_type ntot = bnda.length ();
+      octave_idx_type ntot = bnda.numel ();
 
       octave_idx_type k = 0;
       for (octave_idx_type i = 0; i < ntot; i++)
         if (bnda.xelem (i))
           d[k++] = i;
 
       data = d;
 
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 // unary operations
 
 template <class T>
 boolNDArray
 intNDArray<T>::operator ! (void) const
 {
   boolNDArray b (this->dims ());
 
-  for (octave_idx_type i = 0; i < this->length (); i++)
+  for (octave_idx_type i = 0; i < this->numel (); i++)
     b.elem (i) = ! this->elem (i);
 
   return b;
 }
 
 template <class T>
 bool
 intNDArray<T>::any_element_not_one_or_zero (void) const
diff --git a/liboctave/numeric/CmplxCHOL.cc b/liboctave/numeric/CmplxCHOL.cc
--- a/liboctave/numeric/CmplxCHOL.cc
+++ b/liboctave/numeric/CmplxCHOL.cc
@@ -195,17 +195,17 @@ ComplexCHOL::set (const ComplexMatrix& R
 
 #ifdef HAVE_QRUPDATE
 
 void
 ComplexCHOL::update (const ComplexColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zch1up, ZCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), rw));
     }
@@ -215,17 +215,17 @@ ComplexCHOL::update (const ComplexColumn
 
 octave_idx_type
 ComplexCHOL::downdate (const ComplexColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zch1dn, ZCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), rw, info));
     }
@@ -237,17 +237,17 @@ ComplexCHOL::downdate (const ComplexColu
 
 octave_idx_type
 ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
@@ -300,17 +300,17 @@ ComplexCHOL::shift_sym (octave_idx_type 
 
 void
 ComplexCHOL::update (const ComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       init (chol_mat.hermitian () * chol_mat
             + ComplexMatrix (u) * ComplexMatrix (u).hermitian (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
@@ -326,17 +326,17 @@ octave_idx_type
 ComplexCHOL::downdate (const ComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.hermitian () * chol_mat
                        - ComplexMatrix (u) * ComplexMatrix (u).hermitian (),
                        false);
@@ -353,17 +353,17 @@ octave_idx_type
 ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       if (singular (chol_mat))
         info = 2;
       else if (u(j).imag () != 0.0)
diff --git a/liboctave/numeric/CmplxLU.cc b/liboctave/numeric/CmplxLU.cc
--- a/liboctave/numeric/CmplxLU.cc
+++ b/liboctave/numeric/CmplxLU.cc
@@ -93,17 +93,17 @@ void ComplexLU::update (const ComplexCol
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
@@ -144,17 +144,17 @@ void ComplexLU::update_piv (const Comple
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
                                    m, r.fortran_vec (), k,
                                    ipvt.fortran_vec (),
diff --git a/liboctave/numeric/CmplxQR.cc b/liboctave/numeric/CmplxQR.cc
--- a/liboctave/numeric/CmplxQR.cc
+++ b/liboctave/numeric/CmplxQR.cc
@@ -207,17 +207,17 @@ void ComplexQR::form (octave_idx_type n,
 
 void
 ComplexQR::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
                                  m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec (),
@@ -254,17 +254,17 @@ ComplexQR::update (const ComplexMatrix& 
 
 void
 ComplexQR::insert_col (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
@@ -287,24 +287,24 @@ void
 ComplexQR::insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
@@ -312,17 +312,17 @@ ComplexQR::insert_col (const ComplexMatr
           r.resize (kmax, n + nj);
         }
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (double, rw, kmax);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           ComplexColumnVector utmp = u.column (jsi(i));
           F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1,
                                      utmp.data (), rw));
         }
@@ -360,29 +360,29 @@ void
 ComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
                                      js(ii) + 1, rw));
         }
       if (k < m)
@@ -400,17 +400,17 @@ ComplexQR::delete_col (const Array<octav
 
 void
 ComplexQR::insert_row (const ComplexRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       ComplexRowVector utmp = u;
@@ -472,17 +472,17 @@ ComplexQR::shift_cols (octave_idx_type i
 void
 ComplexQR::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (),
             get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
@@ -568,17 +568,17 @@ ComplexMatrix shift_cols (const ComplexM
 void
 ComplexQR::insert_col (const ComplexColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
@@ -588,31 +588,31 @@ ComplexQR::insert_col (const ComplexMatr
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       ComplexMatrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
 void
 ComplexQR::delete_col (octave_idx_type j)
 {
@@ -632,43 +632,43 @@ void
 ComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       ComplexMatrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
 void
 ComplexQR::insert_row (const ComplexRowVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -86,17 +86,17 @@ ddaspk_f (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
-      if (tmp_delta.length () == 0)
+      if (tmp_delta.numel () == 0)
         ires = -2;
       else
         {
           for (octave_idx_type i = 0; i < nn; i++)
             delta[i] = tmp_delta.elem (i);
         }
     }
 
@@ -191,17 +191,17 @@ DASPK::do_integrate (double tout)
       user_jac = DAEFunc::jacobian_function ();
 
       if (user_fun)
         {
           octave_idx_type ires = 0;
 
           ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
-          if (res.length () != x.length ())
+          if (res.numel () != x.numel ())
             {
               (*current_liboctave_error_handler)
                 ("daspk: inconsistent sizes for state and residual vectors");
 
               integration_error = true;
               return retval;
             }
         }
@@ -235,18 +235,18 @@ DASPK::do_integrate (double tout)
       iwork.resize (dim_vector (liw, 1));
       rwork.resize (dim_vector (lrw, 1));
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.length ();
-      octave_idx_type rel_tol_len = rel_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.numel ();
+      octave_idx_type rel_tol_len = rel_tol.numel ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
@@ -297,17 +297,17 @@ DASPK::do_integrate (double tout)
 
       switch (eiq)
         {
         case 1:
         case 3:
           {
             Array<octave_idx_type> ict = inequality_constraint_types ();
 
-            if (ict.length () == n)
+            if (ict.numel () == n)
               {
                 for (octave_idx_type i = 0; i < n; i++)
                   {
                     octave_idx_type val = ict(i);
                     if (val < -2 || val > 2)
                       {
                         (*current_liboctave_error_handler)
                           ("daspk: invalid value for inequality constraint type");
@@ -342,17 +342,17 @@ DASPK::do_integrate (double tout)
       if (ccic)
         {
           if (ccic == 1)
             {
               // FIXME: this code is duplicated below.
 
               Array<octave_idx_type> av = algebraic_variables ();
 
-              if (av.length () == n)
+              if (av.numel () == n)
                 {
                   octave_idx_type lid;
                   if (eiq == 0 || eiq == 2)
                     lid = 40;
                   else if (eiq == 1 || eiq == 3)
                     lid = 40 + n;
                   else
                     abort ();
@@ -382,17 +382,17 @@ DASPK::do_integrate (double tout)
       if (eavfet)
         {
           info(15) = 1;
 
           // FIXME: this code is duplicated above.
 
           Array<octave_idx_type> av = algebraic_variables ();
 
-          if (av.length () == n)
+          if (av.numel () == n)
             {
               octave_idx_type lid;
               if (eiq == 0 || eiq == 2)
                 lid = 40;
               else if (eiq == 1 || eiq == 3)
                 lid = 40 + n;
               else
                 abort ();
@@ -401,17 +401,17 @@ DASPK::do_integrate (double tout)
                 iwork(lid+i) = av(i) ? -1 : 1;
             }
         }
 
       if (use_initial_condition_heuristics ())
         {
           Array<double> ich = initial_condition_heuristics ();
 
-          if (ich.length () == 6)
+          if (ich.numel () == 6)
             {
               iwork(31) = NINTbig (ich(0));
               iwork(32) = NINTbig (ich(1));
               iwork(33) = NINTbig (ich(2));
               iwork(34) = NINTbig (ich(3));
 
               rwork(13) = ich(4);
               rwork(14) = ich(5);
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -82,17 +82,17 @@ ddasrt_f (const double& t, const double 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_state(i) = state[i];
       tmp_deriv(i) = deriv[i];
     }
 
   ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, ires);
 
-  if (tmp_fval.length () == 0)
+  if (tmp_fval.numel () == 0)
     ires = -2;
   else
     {
       for (octave_idx_type i = 0; i < nn; i++)
         delta[i] = tmp_fval(i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
@@ -177,17 +177,17 @@ DASRT::integrate (double tout)
 
       // DAERTFunc
 
       user_csub = DAERTFunc::constraint_function ();
 
       if (user_csub)
         {
           ColumnVector tmp = (*user_csub) (x, t);
-          ng = tmp.length ();
+          ng = tmp.numel ();
         }
       else
         ng = 0;
 
       octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
@@ -228,17 +228,17 @@ DASRT::integrate (double tout)
       user_jsub = DAEFunc::jacobian_function ();
 
       if (user_fsub)
         {
           octave_idx_type ires = 0;
 
           ColumnVector fval = (*user_fsub) (x, xdot, t, ires);
 
-          if (fval.length () != x.length ())
+          if (fval.numel () != x.numel ())
             {
               (*current_liboctave_error_handler)
                 ("dasrt: inconsistent sizes for state and residual vectors");
 
               integration_error = true;
               return;
             }
         }
@@ -285,18 +285,18 @@ DASRT::integrate (double tout)
           iwork(20) = step_limit ();
         }
       else
         info(11) = 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.length ();
-      octave_idx_type rel_tol_len = rel_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.numel ();
+      octave_idx_type rel_tol_len = rel_tol.numel ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info.elem (1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info.elem (1) = 1;
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -79,17 +79,17 @@ ddassl_f (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
-      if (tmp_delta.length () == 0)
+      if (tmp_delta.numel () == 0)
         ires = -2;
       else
         {
           for (octave_idx_type i = 0; i < nn; i++)
             delta[i] = tmp_delta.elem (i);
         }
     }
 
@@ -170,17 +170,17 @@ DASSL::do_integrate (double tout)
       user_jac = DAEFunc::jacobian_function ();
 
       if (user_fun)
         {
           octave_idx_type ires = 0;
 
           ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
-          if (res.length () != x.length ())
+          if (res.numel () != x.numel ())
             {
               (*current_liboctave_error_handler)
                 ("dassl: inconsistent sizes for state and residual vectors");
 
               integration_error = true;
               return retval;
             }
         }
@@ -246,18 +246,18 @@ DASSL::do_integrate (double tout)
       info(9) = enc ? 1 : 0;
 
       octave_idx_type ccic = compute_consistent_initial_condition ();
       info(10) = ccic ? 1 : 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.length ();
-      octave_idx_type rel_tol_len = rel_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.numel ();
+      octave_idx_type rel_tol_len = rel_tol.numel ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -69,17 +69,17 @@ lsode_f (const octave_idx_type& neq, con
   ColumnVector tmp_deriv;
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
-  if (tmp_deriv.length () == 0)
+  if (tmp_deriv.numel () == 0)
     ierr = -1;
   else
     {
       for (octave_idx_type i = 0; i < neq; i++)
         deriv[i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
@@ -203,33 +203,33 @@ LSODE::do_integrate (double tout)
 
       tmp_x = &x;
 
       user_fun = function ();
       user_jac = jacobian_function ();
 
       ColumnVector xdot = (*user_fun) (x, t);
 
-      if (x.length () != xdot.length ())
+      if (x.numel () != xdot.numel ())
         {
           (*current_liboctave_error_handler)
             ("lsode: inconsistent sizes for state and derivative vectors");
 
           integration_error = true;
           return retval;
         }
 
       ODEFunc::reset = false;
 
       // LSODE_options
 
       rel_tol = relative_tolerance ();
       abs_tol = absolute_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.numel ();
 
       if (abs_tol_len == 1)
         itol = 1;
       else if (abs_tol_len == n)
         itol = 2;
       else
         {
           (*current_liboctave_error_handler)
diff --git a/liboctave/numeric/ODES.cc b/liboctave/numeric/ODES.cc
--- a/liboctave/numeric/ODES.cc
+++ b/liboctave/numeric/ODES.cc
@@ -26,19 +26,19 @@ along with Octave; see the file COPYING.
 
 #include "ODES.h"
 #include "lo-error.h"
 
 void
 ODES::initialize (const ColumnVector& xx, double tt)
 {
   base_diff_eqn::initialize (xx, tt);
-  xdot = ColumnVector (xx.length (), 0.0);
+  xdot = ColumnVector (xx.numel (), 0.0);
 }
 
 void
 ODES::initialize (const ColumnVector& xx, double tt,
                   const ColumnVector& xtheta)
 {
   base_diff_eqn::initialize (xx, tt);
-  xdot = ColumnVector (xx.length (), 0.0);
+  xdot = ColumnVector (xx.numel (), 0.0);
   theta = xtheta;
 }
diff --git a/liboctave/numeric/ODES.h b/liboctave/numeric/ODES.h
--- a/liboctave/numeric/ODES.h
+++ b/liboctave/numeric/ODES.h
@@ -30,21 +30,21 @@ class
 ODES : public base_diff_eqn, public ODESFunc
 {
 public:
 
   ODES (void)
     : base_diff_eqn (), ODESFunc (), xdot (), theta () { }
 
   ODES (const ColumnVector& s, double tm, ODESFunc& f)
-    : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0), theta () { }
+    : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.numel (), 0.0), theta () { }
 
   ODES (const ColumnVector& s, const ColumnVector& xtheta, double tm,
         ODESFunc& f)
-    : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0),
+    : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.numel (), 0.0),
       theta (xtheta) { }
 
   ODES (const ODES& a)
     : base_diff_eqn (a), ODESFunc (a), xdot (a.xdot), theta (a.theta) { }
 
   ODES& operator = (const ODES& a)
   {
     if (this != &a)
diff --git a/liboctave/numeric/base-dae.h b/liboctave/numeric/base-dae.h
--- a/liboctave/numeric/base-dae.h
+++ b/liboctave/numeric/base-dae.h
@@ -29,17 +29,17 @@ class
 base_diff_alg_eqn : public base_diff_eqn
 {
 public:
 
   base_diff_alg_eqn (void)
     : base_diff_eqn (), xdot () { }
 
   base_diff_alg_eqn (const ColumnVector& xx, double tt)
-    : base_diff_eqn (xx, tt), xdot (xx.length (), 0.0) { }
+    : base_diff_eqn (xx, tt), xdot (xx.numel (), 0.0) { }
 
   base_diff_alg_eqn (const ColumnVector& xx, const ColumnVector& xxdot,
                      double tt)
     : base_diff_eqn (xx, tt), xdot (xxdot) { }
 
   base_diff_alg_eqn (const base_diff_alg_eqn& a)
     : base_diff_eqn (a), xdot (a.xdot) { }
 
@@ -53,17 +53,17 @@ public:
         xdot = a.xdot;
       }
     return *this;
   }
 
   void initialize (const ColumnVector& x0, double t0)
   {
     base_diff_eqn::initialize (x0, t0);
-    xdot = ColumnVector (x0.length (), 0.0);
+    xdot = ColumnVector (x0.numel (), 0.0);
   }
 
   void initialize (const ColumnVector& x0, const ColumnVector& xdot0,
                    double t0)
   {
     base_diff_eqn::initialize (x0, t0);
     xdot = xdot0;
   }
diff --git a/liboctave/numeric/base-lu.cc b/liboctave/numeric/base-lu.cc
--- a/liboctave/numeric/base-lu.cc
+++ b/liboctave/numeric/base-lu.cc
@@ -124,17 +124,17 @@ base_lu <lu_type> :: getp (void) const
     {
       octave_idx_type a_nr = a_fact.rows ();
 
       Array<octave_idx_type> pvt (dim_vector (a_nr, 1));
 
       for (octave_idx_type i = 0; i < a_nr; i++)
         pvt.xelem (i) = i;
 
-      for (octave_idx_type i = 0; i < ipvt.length (); i++)
+      for (octave_idx_type i = 0; i < ipvt.numel (); i++)
         {
           octave_idx_type k = ipvt.xelem (i);
 
           if (k != i)
             {
               octave_idx_type tmp = pvt.xelem (k);
               pvt.xelem (k) = pvt.xelem (i);
               pvt.xelem (i) = tmp;
diff --git a/liboctave/numeric/dbleCHOL.cc b/liboctave/numeric/dbleCHOL.cc
--- a/liboctave/numeric/dbleCHOL.cc
+++ b/liboctave/numeric/dbleCHOL.cc
@@ -200,17 +200,17 @@ CHOL::set (const Matrix& R)
 
 #ifdef HAVE_QRUPDATE
 
 void
 CHOL::update (const ColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
       F77_XFCN (dch1up, DCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), w));
     }
@@ -220,17 +220,17 @@ CHOL::update (const ColumnVector& u)
 
 octave_idx_type
 CHOL::downdate (const ColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
       F77_XFCN (dch1dn, DCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), w, info));
     }
@@ -242,17 +242,17 @@ CHOL::downdate (const ColumnVector& u)
 
 octave_idx_type
 CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
@@ -304,17 +304,17 @@ CHOL::shift_sym (octave_idx_type i, octa
 
 void
 CHOL::update (const ColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       init (chol_mat.transpose () * chol_mat
             + Matrix (u) * Matrix (u).transpose (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
@@ -330,17 +330,17 @@ octave_idx_type
 CHOL::downdate (const ColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.transpose () * chol_mat
                        - Matrix (u) * Matrix (u).transpose (), false);
           if (info) info = 1;
@@ -356,17 +356,17 @@ octave_idx_type
 CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       if (singular (chol_mat))
         info = 2;
       else
diff --git a/liboctave/numeric/dbleLU.cc b/liboctave/numeric/dbleLU.cc
--- a/liboctave/numeric/dbleLU.cc
+++ b/liboctave/numeric/dbleLU.cc
@@ -92,17 +92,17 @@ void LU::update (const ColumnVector& u, 
 
   Matrix& l = l_fact;
   Matrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
@@ -142,17 +142,17 @@ void LU::update_piv (const ColumnVector&
 
   Matrix& l = l_fact;
   Matrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
                                    m, r.fortran_vec (), k,
                                    ipvt.fortran_vec (),
diff --git a/liboctave/numeric/dbleQR.cc b/liboctave/numeric/dbleQR.cc
--- a/liboctave/numeric/dbleQR.cc
+++ b/liboctave/numeric/dbleQR.cc
@@ -208,17 +208,17 @@ void QR::form (octave_idx_type n, Matrix
 
 void
 QR::update (const ColumnVector& u, const ColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
                                  m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec (), w));
     }
@@ -252,17 +252,17 @@ QR::update (const Matrix& u, const Matri
 
 void
 QR::insert_col (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
@@ -285,24 +285,24 @@ void
 QR::insert_col (const Matrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
@@ -310,17 +310,17 @@ QR::insert_col (const Matrix& u, const A
           r.resize (kmax, n + nj);
         }
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (double, w, kmax);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           ColumnVector utmp = u.column (jsi(i));
           F77_XFCN (dqrinc, DQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1,
                                      utmp.data (), w));
         }
@@ -358,29 +358,29 @@ void
 QR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
                                      js(ii) + 1, w));
         }
       if (k < m)
@@ -398,17 +398,17 @@ QR::delete_col (const Array<octave_idx_t
 
 void
 QR::insert_row (const RowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       RowVector utmp = u;
@@ -468,17 +468,17 @@ QR::shift_cols (octave_idx_type i, octav
 void
 QR::update (const ColumnVector& u, const ColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       init (q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
@@ -563,17 +563,17 @@ Matrix shift_cols (const Matrix& a,
 void
 QR::insert_col (const ColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
@@ -583,31 +583,31 @@ QR::insert_col (const Matrix& u, const A
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       Matrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
 void
 QR::delete_col (octave_idx_type j)
 {
@@ -627,43 +627,43 @@ void
 QR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       Matrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
 void
 QR::insert_row (const RowVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -440,17 +440,17 @@ LuAminusSigmaB (const SparseMatrix &m, c
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          if (permB.length ())
+          if (permB.numel ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx (i) = i;
                   tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata (i) = 1;
@@ -536,17 +536,17 @@ LuAminusSigmaB (const Matrix &m, const M
   if (have_b)
     {
       if (cholB)
         {
           Matrix tmp = sigma * b.transpose () * b;
           const double *pB = permB.fortran_vec ();
           double *p = AminusSigmaB.fortran_vec ();
 
-          if (permB.length ())
+          if (permB.numel ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
                   *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                      static_cast<octave_idx_type>(pB[j]));
             }
@@ -604,17 +604,17 @@ LuAminusSigmaB (const SparseComplexMatri
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          if (permB.length ())
+          if (permB.numel ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx (i) = i;
                   tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata (i) = 1;
@@ -700,17 +700,17 @@ LuAminusSigmaB (const ComplexMatrix &m, 
   if (have_b)
     {
       if (cholB)
         {
           ComplexMatrix tmp = sigma * b.hermitian () * b;
           const double *pB = permB.fortran_vec ();
           Complex *p = AminusSigmaB.fortran_vec ();
 
-          if (permB.length ())
+          if (permB.numel ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
                   *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                      static_cast<octave_idx_type>(pB[j]));
             }
@@ -824,20 +824,20 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length () != 0)
+  if (have_b && cholB && permB.numel () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length () != n)
+      if (permB.numel () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -875,17 +875,17 @@ EigsRealSymmetricMatrix (const M& m, con
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
-          if (permB.length () == 0)
+          if (permB.numel () == 0)
             {
               permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -1148,20 +1148,20 @@ EigsRealSymmetricMatrixShift (const M& m
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length () != 0)
+  if (have_b && cholB && permB.numel () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length () != n)
+      if (permB.numel () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -1738,20 +1738,20 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length () != 0)
+  if (have_b && cholB && permB.numel () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length () != n)
+      if (permB.numel () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -1789,17 +1789,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
-          if (permB.length () == 0)
+          if (permB.numel () == 0)
             {
               permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -2111,20 +2111,20 @@ EigsRealNonSymmetricMatrixShift (const M
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length () != 0)
+  if (have_b && cholB && permB.numel () != 0)
     {
       // Check that we really have a permutation vector
-      if (permB.length () != n)
+      if (permB.numel () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -2806,20 +2806,20 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length () != 0)
+  if (have_b && cholB && permB.numel () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length () != n)
+      if (permB.numel () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -2857,17 +2857,17 @@ EigsComplexNonSymmetricMatrix (const M& 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.hermitian ();
-          if (permB.length () == 0)
+          if (permB.numel () == 0)
             {
               permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -3131,20 +3131,20 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length () != 0)
+  if (have_b && cholB && permB.numel () != 0)
     {
       // Check that we really have a permutation vector
-      if (permB.length () != n)
+      if (permB.numel () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
diff --git a/liboctave/numeric/fCmplxCHOL.cc b/liboctave/numeric/fCmplxCHOL.cc
--- a/liboctave/numeric/fCmplxCHOL.cc
+++ b/liboctave/numeric/fCmplxCHOL.cc
@@ -195,17 +195,17 @@ FloatComplexCHOL::set (const FloatComple
 
 #ifdef HAVE_QRUPDATE
 
 void
 FloatComplexCHOL::update (const FloatComplexColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cch1up, CCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), rw));
     }
@@ -215,17 +215,17 @@ FloatComplexCHOL::update (const FloatCom
 
 octave_idx_type
 FloatComplexCHOL::downdate (const FloatComplexColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cch1dn, CCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), rw, info));
     }
@@ -238,17 +238,17 @@ FloatComplexCHOL::downdate (const FloatC
 octave_idx_type
 FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
                               octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
diff --git a/liboctave/numeric/fCmplxLU.cc b/liboctave/numeric/fCmplxLU.cc
--- a/liboctave/numeric/fCmplxLU.cc
+++ b/liboctave/numeric/fCmplxLU.cc
@@ -93,17 +93,17 @@ void FloatComplexLU::update (const Float
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
@@ -145,17 +145,17 @@ void FloatComplexLU::update_piv (const F
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
                                    m, r.fortran_vec (), k,
                                    ipvt.fortran_vec (),
diff --git a/liboctave/numeric/fCmplxQR.cc b/liboctave/numeric/fCmplxQR.cc
--- a/liboctave/numeric/fCmplxQR.cc
+++ b/liboctave/numeric/fCmplxQR.cc
@@ -211,17 +211,17 @@ void FloatComplexQR::form (octave_idx_ty
 void
 FloatComplexQR::update (const FloatComplexColumnVector& u,
                         const FloatComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
                                  m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec (),
@@ -260,17 +260,17 @@ FloatComplexQR::update (const FloatCompl
 void
 FloatComplexQR::insert_col (const FloatComplexColumnVector& u,
                             octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
@@ -294,24 +294,24 @@ FloatComplexQR::insert_col (const FloatC
                             const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
@@ -319,17 +319,17 @@ FloatComplexQR::insert_col (const FloatC
           r.resize (kmax, n + nj);
         }
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, rw, kmax);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1,
                                      u.column (jsi(i)).data (), rw));
         }
     }
@@ -366,29 +366,29 @@ void
 FloatComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
                                      js(ii) + 1, rw));
         }
       if (k < m)
@@ -406,17 +406,17 @@ FloatComplexQR::delete_col (const Array<
 
 void
 FloatComplexQR::insert_row (const FloatComplexRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       FloatComplexRowVector utmp = u;
@@ -479,17 +479,17 @@ void
 FloatComplexQR::update (const FloatComplexColumnVector& u,
                         const FloatComplexColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (),
             get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
@@ -577,17 +577,17 @@ void
 FloatComplexQR::insert_col (const FloatComplexColumnVector& u,
                             octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
@@ -598,31 +598,31 @@ FloatComplexQR::insert_col (const FloatC
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       FloatComplexMatrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
 void
 FloatComplexQR::delete_col (octave_idx_type j)
 {
@@ -642,43 +642,43 @@ void
 FloatComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       FloatComplexMatrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
 void
 FloatComplexQR::insert_row (const FloatComplexRowVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
diff --git a/liboctave/numeric/floatCHOL.cc b/liboctave/numeric/floatCHOL.cc
--- a/liboctave/numeric/floatCHOL.cc
+++ b/liboctave/numeric/floatCHOL.cc
@@ -200,17 +200,17 @@ FloatCHOL::set (const FloatMatrix& R)
 
 #ifdef HAVE_QRUPDATE
 
 void
 FloatCHOL::update (const FloatColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
       F77_XFCN (sch1up, SCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), w));
     }
@@ -220,17 +220,17 @@ FloatCHOL::update (const FloatColumnVect
 
 octave_idx_type
 FloatCHOL::downdate (const FloatColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
       F77_XFCN (sch1dn, SCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  utmp.fortran_vec (), w, info));
     }
@@ -242,17 +242,17 @@ FloatCHOL::downdate (const FloatColumnVe
 
 octave_idx_type
 FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
@@ -304,17 +304,17 @@ FloatCHOL::shift_sym (octave_idx_type i,
 
 void
 FloatCHOL::update (const FloatColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       init (chol_mat.transpose () * chol_mat
             + FloatMatrix (u) * FloatMatrix (u).transpose (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
@@ -330,17 +330,17 @@ octave_idx_type
 FloatCHOL::downdate (const FloatColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.numel () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.transpose () * chol_mat
                        - FloatMatrix (u) * FloatMatrix (u).transpose (), false);
           if (info) info = 1;
@@ -356,17 +356,17 @@ octave_idx_type
 FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () != n + 1)
+  if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       if (singular (chol_mat))
         info = 2;
       else
diff --git a/liboctave/numeric/floatLU.cc b/liboctave/numeric/floatLU.cc
--- a/liboctave/numeric/floatLU.cc
+++ b/liboctave/numeric/floatLU.cc
@@ -92,17 +92,17 @@ void FloatLU::update (const FloatColumnV
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
                                  m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
   else
@@ -144,17 +144,17 @@ void FloatLU::update_piv (const FloatCol
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
                                    m, r.fortran_vec (), k,
                                    ipvt.fortran_vec (),
diff --git a/liboctave/numeric/floatQR.cc b/liboctave/numeric/floatQR.cc
--- a/liboctave/numeric/floatQR.cc
+++ b/liboctave/numeric/floatQR.cc
@@ -206,17 +206,17 @@ void FloatQR::form (octave_idx_type n, F
 
 void
 FloatQR::update (const FloatColumnVector& u, const FloatColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
                                  m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec (), w));
     }
@@ -250,17 +250,17 @@ FloatQR::update (const FloatMatrix& u, c
 
 void
 FloatQR::insert_col (const FloatColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
@@ -283,24 +283,24 @@ void
 FloatQR::insert_col (const FloatMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
@@ -308,17 +308,17 @@ FloatQR::insert_col (const FloatMatrix& 
           r.resize (kmax, n + nj);
         }
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, w, kmax);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           FloatColumnVector utmp = u.column (jsi(i));
           F77_XFCN (sqrinc, SQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1,
                                      utmp.data (), w));
         }
@@ -356,29 +356,29 @@ void
 FloatQR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
-      for (volatile octave_idx_type i = 0; i < js.length (); i++)
+      for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
                                      js(ii) + 1, w));
         }
       if (k < m)
@@ -396,17 +396,17 @@ FloatQR::delete_col (const Array<octave_
 
 void
 FloatQR::insert_row (const FloatRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       FloatRowVector utmp = u;
@@ -466,17 +466,17 @@ FloatQR::shift_cols (octave_idx_type i, 
 void
 FloatQR::update (const FloatColumnVector& u, const FloatColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () == m && v.length () == n)
+  if (u.numel () == m && v.numel () == n)
     {
       init (q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
@@ -561,17 +561,17 @@ FloatMatrix shift_cols (const FloatMatri
 void
 FloatQR::insert_col (const FloatColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.length () != m)
+  if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
@@ -581,31 +581,31 @@ FloatQR::insert_col (const FloatMatrix& 
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.length () != m || u.columns () != nj)
+  else if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       FloatMatrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
 void
 FloatQR::delete_col (octave_idx_type j)
 {
@@ -625,43 +625,43 @@ void
 FloatQR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-  octave_idx_type nj = js.length ();
+  octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       FloatMatrix a = q*r;
-      for (octave_idx_type i = 0; i < js.length (); i++)
+      for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
 void
 FloatQR::insert_row (const FloatRowVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (! q.is_square () || u.length () != n)
+  if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -1272,18 +1272,18 @@ do_bessel (dptr f, const char *fn, const
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const RowVector& alpha,
            const ComplexColumnVector& x, bool scaled,
            Array<octave_idx_type>& ierr)
 {
-  octave_idx_type nr = x.length ();
-  octave_idx_type nc = alpha.length ();
+  octave_idx_type nr = x.numel ();
+  octave_idx_type nc = alpha.numel ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
@@ -1883,18 +1883,18 @@ do_bessel (fptr f, const char *fn, const
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatRowVector& alpha,
            const FloatComplexColumnVector& x, bool scaled,
            Array<octave_idx_type>& ierr)
 {
-  octave_idx_type nr = x.length ();
-  octave_idx_type nc = alpha.length ();
+  octave_idx_type nr = x.numel ();
+  octave_idx_type nc = alpha.numel ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -685,17 +685,17 @@ double2uint32 (double d)
     }
 
   return u;
 }
 
 void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
-  octave_idx_type len = s.length ();
+  octave_idx_type len = s.numel ();
   octave_idx_type n = len < MT_N + 1 ? len : MT_N + 1;
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   for (octave_idx_type i = 0; i < n; i++)
     tmp[i] = double2uint32 (s.elem (i));
 
   if (len == MT_N + 1 && tmp[MT_N] <= MT_N && tmp[MT_N] > 0)
diff --git a/liboctave/numeric/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
--- a/liboctave/numeric/oct-spparms.cc
+++ b/liboctave/numeric/oct-spparms.cc
@@ -172,17 +172,17 @@ double
 octave_sparse_params::do_get_bandden (void)
 {
   return params(10);
 }
 
 bool
 octave_sparse_params::do_set_vals (const NDArray& vals)
 {
-  octave_idx_type len = vals.length ();
+  octave_idx_type len = vals.numel ();
 
   if (len > OCTAVE_SPARSE_CONTROLS_SIZE)
     {
       (*current_liboctave_error_handler)
         ("octave_sparse_params::do_set_vals: too many values");
 
       return false;
     }
diff --git a/liboctave/numeric/sparse-base-chol.cc b/liboctave/numeric/sparse-base-chol.cc
--- a/liboctave/numeric/sparse-base-chol.cc
+++ b/liboctave/numeric/sparse-base-chol.cc
@@ -275,17 +275,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm ();
   chol_type ret;
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
   chol_type linv = L ().hermitian ().inverse (mattype, info, rcond2, 1, 0);
 
-  if (perms.length () == n)
+  if (perms.numel () == n)
     {
       p_type Qc = Q ();
       retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
 #endif
   return retval;
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -366,17 +366,17 @@ do_mm_binary_op (const Array<X>& x, cons
                  void (*op2) (size_t, R *, const X *, Y) throw (),
                  const char *opname)
 {
   dim_vector dx = x.dims ();
   dim_vector dy = y.dims ();
   if (dx == dy)
     {
       Array<R> r (dx);
-      op (r.length (), r.fortran_vec (), x.data (), y.data ());
+      op (r.numel (), r.fortran_vec (), x.data (), y.data ());
       return r;
     }
   else if (is_valid_bsxfun (opname, dx, dy))
     {
       return do_bsxfun_op (x, y, op, op1, op2);
     }
   else
     {
@@ -386,58 +386,58 @@ do_mm_binary_op (const Array<X>& x, cons
 }
 
 template <class R, class X, class Y>
 inline Array<R>
 do_ms_binary_op (const Array<X>& x, const Y& y,
                  void (*op) (size_t, R *, const X *, Y) throw ())
 {
   Array<R> r (x.dims ());
-  op (r.length (), r.fortran_vec (), x.data (), y);
+  op (r.numel (), r.fortran_vec (), x.data (), y);
   return r;
 }
 
 template <class R, class X, class Y>
 inline Array<R>
 do_sm_binary_op (const X& x, const Array<Y>& y,
                  void (*op) (size_t, R *, X, const Y *) throw ())
 {
   Array<R> r (y.dims ());
-  op (r.length (), r.fortran_vec (), x, y.data ());
+  op (r.numel (), r.fortran_vec (), x, y.data ());
   return r;
 }
 
 template <class R, class X>
 inline Array<R>&
 do_mm_inplace_op (Array<R>& r, const Array<X>& x,
                   void (*op) (size_t, R *, const X *) throw (),
                   void (*op1) (size_t, R *, X) throw (),
                   const char *opname)
 {
   dim_vector dr = r.dims ();
   dim_vector dx = x.dims ();
   if (dr == dx)
     {
-      op (r.length (), r.fortran_vec (), x.data ());
+      op (r.numel (), r.fortran_vec (), x.data ());
     }
   else if (is_valid_inplace_bsxfun (opname, dr, dx))
     {
       do_inplace_bsxfun_op (r, x, op, op1);
     }
   else
     gripe_nonconformant (opname, dr, dx);
   return r;
 }
 
 template <class R, class X>
 inline Array<R>&
 do_ms_inplace_op (Array<R>& r, const X& x,
                   void (*op) (size_t, R *, X) throw ())
 {
-  op (r.length (), r.fortran_vec (), x);
+  op (r.numel (), r.fortran_vec (), x);
   return r;
 }
 
 template <class T1, class T2>
 inline bool
 mx_inline_equal (size_t n, const T1 *x, const T2 *y) throw ()
 {
   for (size_t i = 0; i < n; i++)
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -147,17 +147,17 @@ tilde_find_prefix (const std::string& s,
     return 0;
 
   string_vector prefixes = file_ops::tilde_additional_prefixes;
 
   if (! prefixes.empty ())
     {
       for (size_t i = 0; i < s_len; i++)
         {
-          for (int j = 0; j < prefixes.length (); j++)
+          for (int j = 0; j < prefixes.numel (); j++)
             {
               size_t pfx_len = prefixes[j].length ();
 
               if (prefixes[j].compare (s.substr (i, pfx_len)) == 0)
                 {
                   len = pfx_len - 1;
                   return i + len;
                 }
@@ -182,17 +182,17 @@ tilde_find_suffix (const std::string& s)
 
   for ( ; i < s_len; i++)
     {
       if (file_ops::is_dir_sep (s[i]))
         break;
 
       if (! suffixes.empty ())
         {
-          for (int j = 0; j < suffixes.length (); j++)
+          for (int j = 0; j < suffixes.numel (); j++)
             {
               size_t sfx_len = suffixes[j].length ();
 
               if (suffixes[j].compare (s.substr (i, sfx_len)) == 0)
                 return i;
             }
         }
     }
@@ -341,17 +341,17 @@ file_ops::tilde_expand (const std::strin
 
 // A vector version of the above.
 
 string_vector
 file_ops::tilde_expand (const string_vector& names)
 {
   string_vector retval;
 
-  int n = names.length ();
+  int n = names.numel ();
 
   retval.resize (n);
 
   for (int i = 0; i < n; i++)
     retval[i] = tilde_expand (names[i]);
 
   return retval;
 }
@@ -575,17 +575,17 @@ octave_recursive_rmdir (const std::strin
   int status = 0;
 
   dir_entry dir (name);
 
   if (dir)
     {
       string_vector dirlist = dir.read ();
 
-      for (octave_idx_type i = 0; i < dirlist.length (); i++)
+      for (octave_idx_type i = 0; i < dirlist.numel (); i++)
         {
           octave_quit ();
 
           std::string nm = dirlist[i];
 
           // Skip current directory and parent.
           if (nm == "." || nm == "..")
             continue;
diff --git a/liboctave/util/glob-match.h b/liboctave/util/glob-match.h
--- a/liboctave/util/glob-match.h
+++ b/liboctave/util/glob-match.h
@@ -67,17 +67,17 @@ public:
   void set_pattern (const std::string& p) { pat = p; }
 
   void set_pattern (const string_vector& p) { pat = p; }
 
   bool match (const std::string& str) const;
 
   Array<bool> match (const string_vector& str) const
   {
-    int n = str.length ();
+    int n = str.numel ();
 
     Array<bool> retval (dim_vector (n, 1));
 
     for (int i = 0; i < n; i++)
       retval(i) = match (str[i]);
 
     return retval;
   }
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -422,17 +422,17 @@ hash_lookup (hash_table_type table, cons
 #ifdef KPSE_DEBUG
   if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
     {
       DEBUGF1 ("hash_lookup (%s) =>", key.c_str ());
       if (ret.empty ())
         gnulib::fputs (" (nil)\n", stderr);
       else
         {
-          int len = ret.length ();
+          int len = ret.numel ();
           for (int i = 0; i < len; i++)
             {
               gnulib::putc (' ', stderr);
               gnulib::fputs (ret[i].c_str (), stderr);
             }
           gnulib::putc ('\n', stderr);
         }
       gnulib::fflush (stderr);
@@ -699,17 +699,17 @@ log_search (const string_vector& filenam
           if (! log_file)
             perror (log_name.c_str ());
         }
     }
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH) || log_file)
     {
       /* FILENAMES should never be null, but safety doesn't hurt.  */
-      for (int e = 0; e < filenames.length () && ! filenames[e].empty (); e++)
+      for (int e = 0; e < filenames.numel () && ! filenames[e].empty (); e++)
         {
           std::string filename = filenames[e];
 
           /* Only record absolute filenames, for privacy.  */
           if (log_file && kpse_absolute_p (filename.c_str (), false))
             gnulib::fprintf (log_file, "%lu %s\n",
                              static_cast<unsigned long> (time (0)),
                              filename.c_str ());
@@ -1005,17 +1005,17 @@ path_find_first_of (const std::string& p
         }
 
       /* We have to search one directory at a time.  */
       dirs = kpse_element_dirs (elt);
       for (dirs_elt = *dirs; dirs_elt; dirs_elt = STR_LLIST_NEXT (*dirs_elt))
         {
           const std::string dir = STR_LLIST (*dirs_elt);
 
-          int len = names.length ();
+          int len = names.numel ();
           for (int i = 0; i < len && !done; i++)
             {
               std::string name = names[i];
 
               /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
                  (find_first_of), also tests first_search, and does the
                  resetting.  */
               found = first_search ? string_vector ()
@@ -1071,31 +1071,31 @@ find_first_of (const std::string& path, 
                bool must_exist, bool all)
 {
   string_vector ret_list;
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
     {
       gnulib::fputs ("start find_first_of ((", stderr);
 
-      int len = names.length ();
+      int len = names.numel ();
 
       for (int i = 0; i < len; i++)
         {
           if (i == 0)
             gnulib::fputs (names[i].c_str (), stderr);
           else
             gnulib::fprintf (stderr, ", %s", names[i].c_str ());
         }
 
       gnulib::fprintf (stderr, "), path=%s, must_exist=%d).\n",
                        path.c_str (), must_exist);
     }
 
-  for (int i = 0; i < names.length (); i++)
+  for (int i = 0; i < names.numel (); i++)
     {
       std::string name = names[i];
 
       if (kpse_absolute_p (name, true))
         {
           /* If the name is absolute or explicitly relative, no need
              to consider PATH at all.  If we find something, then we
              are done.  */
@@ -1120,17 +1120,17 @@ find_first_of (const std::string& path, 
     {
       /* Record the filenames we found, if desired.  And wrap them in a
          debugging line if we're doing that.  */
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
         {
           gnulib::fputs ("find_first_of (", stderr);
 
-          int len = names.length ();
+          int len = names.numel ();
 
           for (int i = 0; i < len; i++)
             {
               if (i == 0)
                 gnulib::fputs (names[i].c_str (), stderr);
               else
                 gnulib::fprintf (stderr, ", %s", names[i].c_str ());
             }
@@ -1332,17 +1332,17 @@ kpse_expand_kpse_dot (const std::string&
 
 static std::string
 kpse_brace_expand_element (const std::string& elt)
 {
   std::string ret;
 
   string_vector expansions = brace_expand (elt);
 
-  for (int i = 0; i < expansions.length (); i++)
+  for (int i = 0; i < expansions.numel (); i++)
     {
       /* Do $ and ~ expansion on each element.  */
       std::string x = kpse_expand (expansions[i]);
 
       if (x != expansions[i])
         {
           /* If we did any expansions, do brace expansion again.  Since
              recursive variable definitions are not allowed, this recursion
@@ -1506,18 +1506,18 @@ array_concat (const string_vector& arr1,
   string_vector result;
 
   if (arr1.empty ())
     result = arr2;
   else if (arr2.empty ())
     result = arr1;
   else
     {
-      int len1 = arr1.length ();
-      int len2 = arr2.length ();
+      int len1 = arr1.numel ();
+      int len2 = arr2.numel ();
 
       result = string_vector (len1 * len2);
 
       int k = 0;
       for (int i = 0; i < len2; i++)
         for (int j = 0; j < len1; j++)
           result[k++] = arr1[j] + arr2[i];
     }
@@ -1881,47 +1881,47 @@ kpse_db_search (const std::string& name_
   else
     path_elt = orig_path_elt;
 
   /* Don't bother doing any lookups if this 'path_elt' isn't covered by
      any of database directories.  We do this not so much because the
      extra couple of hash lookups matter -- they don't -- but rather
      because we want to return NULL in this case, so path_search can
      know to do a disk search.  */
-  for (int e = 0; ! relevant && e < db_dir_list.length (); e++)
+  for (int e = 0; ! relevant && e < db_dir_list.numel (); e++)
     relevant = elt_in_db (db_dir_list[e], path_elt);
 
   if (! relevant)
     return ret;
 
   /* If we have aliases for this name, use them.  */
   if (alias_db.buckets)
     aliases = hash_lookup (alias_db, name);
 
   /* Push aliases up by one and insert the original name at the front.  */
-  int len = aliases.length ();
+  int len = aliases.numel ();
   aliases.resize (len+1);
   for (int i = len; i > 0; i--)
     aliases[i] = aliases[i - 1];
   aliases[0] = name;
 
   done = false;
-  len = aliases.length ();
+  len = aliases.numel ();
   for (int i = 0; i < len && !done; i++)
     {
       std::string atry = aliases[i];
 
       /* We have an ls-R db.  Look up 'atry'.  */
       string_vector db_dirs = hash_lookup (db, atry);
 
       /* For each filename found, see if it matches the path element.  For
          example, if we have .../cx/cmr10.300pk and .../ricoh/cmr10.300pk,
          and the path looks like .../cx, we don't want the ricoh file.  */
 
-      int db_dirs_len = db_dirs.length ();
+      int db_dirs_len = db_dirs.numel ();
       for (int j = 0; j < db_dirs_len && !done; j++)
         {
           std::string db_file = db_dirs[j] + atry;
           bool matched = match (db_file, path_elt);
 
 #ifdef KPSE_DEBUG
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
             DEBUGF3 ("db:match (%s,%s) = %d\n",
@@ -1941,17 +1941,17 @@ kpse_db_search (const std::string& name_
                   /* The hit in the DB doesn't exist in disk.  Now try
                      all its aliases.  For example, suppose we have a
                      hierarchy on CD, thus 'mf.bas', but ls-R contains
                      'mf.base'.  Find it anyway.  Could probably work
                      around this with aliases, but this is pretty easy
                      and shouldn't hurt.  The upshot is that if one of
                      the aliases actually exists, we use that.  */
 
-                  int aliases_len = aliases.length ();
+                  int aliases_len = aliases.numel ();
 
                   for (int k = 1; k < aliases_len && found.empty (); k++)
                     {
                       std::string aatry = db_dirs[j] + aliases[k];
                       tmp = kpse_readable_file (aatry);
                       if (! tmp.empty ())
                         found = aatry;
                     }
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -429,21 +429,21 @@ regexp::is_match (const std::string& buf
   regexp::match_data rx_lst = match (buffer);
 
   return rx_lst.size () > 0;
 }
 
 Array<bool>
 regexp::is_match (const string_vector& buffer)
 {
-  octave_idx_type len = buffer.length ();
+  octave_idx_type len = buffer.numel ();
 
   Array<bool> retval (dim_vector (len, 1));
 
-  for (octave_idx_type i = 0; i < buffer.length (); i++)
+  for (octave_idx_type i = 0; i < buffer.numel (); i++)
     retval(i) = is_match (buffer(i));
 
   return retval;
 }
 
 // Declare rep_token_t used in processing replacement string
 typedef struct
 {
diff --git a/liboctave/util/oct-glob.cc b/liboctave/util/oct-glob.cc
--- a/liboctave/util/oct-glob.cc
+++ b/liboctave/util/oct-glob.cc
@@ -46,33 +46,33 @@ single_match_exists (const std::string& 
 
   return s.exists ();
 }
 
 bool
 octave_fnmatch (const string_vector& pat, const std::string& str,
                 int fnmatch_flags)
 {
-  int npat = pat.length ();
+  int npat = pat.numel ();
 
   const char *cstr = str.c_str ();
 
   for (int i = 0; i < npat; i++)
     if (fnmatch (pat(i).c_str (), cstr, fnmatch_flags) != FNM_NOMATCH)
       return true;
 
   return false;
 }
 
 string_vector
 octave_glob (const string_vector& pat)
 {
   string_vector retval;
 
-  int npat = pat.length ();
+  int npat = pat.numel ();
 
   int k = 0;
 
   for (int i = 0; i < npat; i++)
     {
       std::string xpat = pat(i);
 
       if (! xpat.empty ())
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -74,17 +74,17 @@ dir_path::elements (void)
 string_vector
 dir_path::all_directories (void)
 {
   int count = 0;
   string_vector retval;
 
   if (initialized)
     {
-      int len = pv.length ();
+      int len = pv.numel ();
 
       int nmax = len > 32 ? len : 32;
 
       retval.resize (len);
 
       for (int i = 0; i < len; i++)
         {
           str_llist_type *elt_dirs = kpse_element_dirs (pv[i]);
diff --git a/liboctave/util/str-vec.cc b/liboctave/util/str-vec.cc
--- a/liboctave/util/str-vec.cc
+++ b/liboctave/util/str-vec.cc
@@ -103,27 +103,27 @@ string_vector::string_vector (const char
     elem (i) = s[i];
 }
 
 string_vector&
 string_vector::sort (bool make_uniq)
 {
   // Don't use Array<std::string>::sort () to allow sorting in place.
   octave_sort<std::string> lsort;
-  lsort.sort (Array<std::string>::fortran_vec (), length ());
+  lsort.sort (Array<std::string>::fortran_vec (), numel ());
 
   if (make_uniq)
     uniq ();
 
   return *this;
 }
 string_vector&
 string_vector::uniq (void)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       octave_idx_type k = 0;
 
       for (octave_idx_type i = 1; i < len; i++)
         if (elem (i) != elem (k))
           if (++k != i)
@@ -134,46 +134,46 @@ string_vector::uniq (void)
     }
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const std::string& s)
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   resize (len + 1);
 
   elem (len) = s;
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const string_vector& sv)
 {
-  octave_idx_type len = length ();
-  octave_idx_type sv_len = sv.length ();
+  octave_idx_type len = numel ();
+  octave_idx_type sv_len = sv.numel ();
   octave_idx_type new_len = len + sv_len;
 
   resize (new_len);
 
   for (octave_idx_type i = 0; i < sv_len; i++)
     elem (len + i) = sv[i];
 
   return *this;
 }
 
 std::string
 string_vector::join (const std::string& sep) const
 {
   std::string retval;
 
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   if (len > 0)
     {
       octave_idx_type i;
 
       for (i = 0; i < len - 1; i++)
         retval += elem (i) + sep;
 
@@ -181,17 +181,17 @@ string_vector::join (const std::string& 
     }
 
   return retval;
 }
 
 char **
 string_vector::c_str_vec (void) const
 {
-  octave_idx_type len = length ();
+  octave_idx_type len = numel ();
 
   char **retval = new char * [len + 1];
 
   retval[len] = 0;
 
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = strsave (elem (i).c_str ());
 
@@ -213,17 +213,17 @@ string_vector::delete_c_str_vec (const c
 
 std::ostream&
 string_vector::list_in_columns (std::ostream& os, int width,
                                 const std::string& prefix) const
 {
   // Compute the maximum name length.
 
   octave_idx_type max_name_length = 0;
-  octave_idx_type total_names = length ();
+  octave_idx_type total_names = numel ();
 
   if (total_names == 0)
     {
       // List empty, remember to end output with a newline.
 
       os << "\n";
       return os;
     }
diff --git a/liboctave/util/str-vec.h b/liboctave/util/str-vec.h
--- a/liboctave/util/str-vec.h
+++ b/liboctave/util/str-vec.h
@@ -65,21 +65,21 @@ public:
     if (this != &s)
       Array<std::string>::operator = (s);
 
     return *this;
   }
 
   ~string_vector (void) { }
 
-  bool empty (void) const { return length () == 0; }
+  bool empty (void) const { return numel () == 0; }
 
   octave_idx_type max_length (void) const
   {
-    octave_idx_type n = length ();
+    octave_idx_type n = numel ();
     octave_idx_type longest = 0;
 
     for (octave_idx_type i = 0; i < n; i++)
       {
         octave_idx_type tmp = elem (i).length ();
 
         if (tmp > longest)
           longest = tmp;
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -77,17 +77,17 @@ base_url_transfer::mget_directory (const
   if (good ())
     {
       unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, this);
 
       string_vector sv = list ();
 
-      for (octave_idx_type i = 0; i < sv.length (); i++)
+      for (octave_idx_type i = 0; i < sv.numel (); i++)
         {
           time_t ftime;
           bool fisdir;
           double fsize;
 
           get_fileinfo (sv(i), fsize, ftime, fisdir);
 
           if (fisdir)
@@ -148,17 +148,17 @@ base_url_transfer::mput_directory (const
       frame.add_fcn (reset_path, this);
 
       dir_entry dirlist (realdir);
 
       if (dirlist)
         {
           string_vector files = dirlist.read ();
 
-          for (octave_idx_type i = 0; i < files.length (); i++)
+          for (octave_idx_type i = 0; i < files.numel (); i++)
             {
               std::string file = files (i);
 
               if (file == "." || file == "..")
                 continue;
 
               std::string realfile = realdir + file_ops::dir_sep_str () + file;
               file_stat fs (realfile);
