# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1478190916 14400
#      Thu Nov 03 12:35:16 2016 -0400
# Node ID dc073ccde64e915f7198aa5fee189e558cb017aa
# Parent  fc6081e9607b6e52b6e0f2ae4471d0d5974f3cc8
eliminate more zero args in macros and type definitions for operators

diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -7521,71 +7521,71 @@ SparseComplexMatrix
 operator * (const SparseComplexMatrix& m, const SparseComplexMatrix& a)
 {
   SPARSE_SPARSE_MUL (SparseComplexMatrix, Complex, Complex);
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const SparseMatrix& a)
 {
-  FULL_SPARSE_MUL (ComplexMatrix, double, Complex (0.,0.));
+  FULL_SPARSE_MUL (ComplexMatrix, double);
 }
 
 ComplexMatrix
 operator * (const Matrix& m, const SparseComplexMatrix& a)
 {
-  FULL_SPARSE_MUL (ComplexMatrix, Complex, Complex (0.,0.));
+  FULL_SPARSE_MUL (ComplexMatrix, Complex);
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const SparseComplexMatrix& a)
 {
-  FULL_SPARSE_MUL (ComplexMatrix, Complex, Complex (0.,0.));
+  FULL_SPARSE_MUL (ComplexMatrix, Complex);
 }
 
 ComplexMatrix
 mul_trans (const ComplexMatrix& m, const SparseComplexMatrix& a)
 {
-  FULL_SPARSE_MUL_TRANS (ComplexMatrix, Complex, Complex (0.,0.), );
+  FULL_SPARSE_MUL_TRANS (ComplexMatrix, Complex, );
 }
 
 ComplexMatrix
 mul_herm (const ComplexMatrix& m, const SparseComplexMatrix& a)
 {
-  FULL_SPARSE_MUL_TRANS (ComplexMatrix, Complex, Complex (0.,0.), conj);
+  FULL_SPARSE_MUL_TRANS (ComplexMatrix, Complex, conj);
 }
 
 ComplexMatrix
 operator * (const SparseComplexMatrix& m, const Matrix& a)
 {
-  SPARSE_FULL_MUL (ComplexMatrix, double, Complex (0.,0.));
+  SPARSE_FULL_MUL (ComplexMatrix, double);
 }
 
 ComplexMatrix
 operator * (const SparseMatrix& m, const ComplexMatrix& a)
 {
-  SPARSE_FULL_MUL (ComplexMatrix, Complex, Complex (0.,0.));
+  SPARSE_FULL_MUL (ComplexMatrix, Complex);
 }
 
 ComplexMatrix
 operator * (const SparseComplexMatrix& m, const ComplexMatrix& a)
 {
-  SPARSE_FULL_MUL (ComplexMatrix, Complex, Complex (0.,0.));
+  SPARSE_FULL_MUL (ComplexMatrix, Complex);
 }
 
 ComplexMatrix
 trans_mul (const SparseComplexMatrix& m, const ComplexMatrix& a)
 {
-  SPARSE_FULL_TRANS_MUL (ComplexMatrix, Complex, Complex (0.,0.), );
+  SPARSE_FULL_TRANS_MUL (ComplexMatrix, Complex, );
 }
 
 ComplexMatrix
 herm_mul (const SparseComplexMatrix& m, const ComplexMatrix& a)
 {
-  SPARSE_FULL_TRANS_MUL (ComplexMatrix, Complex, Complex (0.,0.), conj);
+  SPARSE_FULL_TRANS_MUL (ComplexMatrix, Complex, conj);
 }
 
 // diag * sparse and sparse * diag
 SparseComplexMatrix
 operator * (const DiagMatrix& d, const SparseComplexMatrix& a)
 {
   return do_mul_dm_sm<SparseComplexMatrix> (d, a);
 }
@@ -7928,16 +7928,16 @@ max (const SparseComplexMatrix& a, const
         r.resize (b_nr, b_nc);
       else
         octave::err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
-SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, Complex, 0.0)
+SPARSE_SMS_CMP_OPS (SparseComplexMatrix, Complex)
 SPARSE_SMS_BOOL_OPS (SparseComplexMatrix, Complex)
 
-SPARSE_SSM_CMP_OPS (Complex, 0.0, SparseComplexMatrix, 0.0)
+SPARSE_SSM_CMP_OPS (Complex, SparseComplexMatrix)
 SPARSE_SSM_BOOL_OPS (Complex, SparseComplexMatrix)
 
-SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, 0.0, SparseComplexMatrix, 0.0)
+SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, SparseComplexMatrix)
 SPARSE_SMSM_BOOL_OPS (SparseComplexMatrix, SparseComplexMatrix)
diff --git a/liboctave/array/boolSparse.cc b/liboctave/array/boolSparse.cc
--- a/liboctave/array/boolSparse.cc
+++ b/liboctave/array/boolSparse.cc
@@ -316,16 +316,16 @@ SparseBoolMatrix::permute (const Array<o
 }
 
 SparseBoolMatrix
 SparseBoolMatrix::ipermute (const Array<octave_idx_type>& vec) const
 {
   return Sparse<bool>::ipermute (vec);
 }
 
-SPARSE_SMS_EQNE_OPS (SparseBoolMatrix, false, bool, false)
+SPARSE_SMS_EQNE_OPS (SparseBoolMatrix, bool)
 SPARSE_SMS_BOOL_OPS (SparseBoolMatrix, bool)
 
-SPARSE_SSM_EQNE_OPS (bool, false, SparseBoolMatrix, false)
+SPARSE_SSM_EQNE_OPS (bool, SparseBoolMatrix)
 SPARSE_SSM_BOOL_OPS (bool, SparseBoolMatrix)
 
-SPARSE_SMSM_EQNE_OPS (SparseBoolMatrix, false, SparseBoolMatrix, false)
+SPARSE_SMSM_EQNE_OPS (SparseBoolMatrix, SparseBoolMatrix)
 SPARSE_SMSM_BOOL_OPS (SparseBoolMatrix, SparseBoolMatrix)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -7540,35 +7540,35 @@ SparseMatrix
 operator * (const SparseMatrix& m, const SparseMatrix& a)
 {
   SPARSE_SPARSE_MUL (SparseMatrix, double, double);
 }
 
 Matrix
 operator * (const Matrix& m, const SparseMatrix& a)
 {
-  FULL_SPARSE_MUL (Matrix, double, 0.);
+  FULL_SPARSE_MUL (Matrix, double);
 }
 
 Matrix
 mul_trans (const Matrix& m, const SparseMatrix& a)
 {
-  FULL_SPARSE_MUL_TRANS (Matrix, double, 0., );
+  FULL_SPARSE_MUL_TRANS (Matrix, double, );
 }
 
 Matrix
 operator * (const SparseMatrix& m, const Matrix& a)
 {
-  SPARSE_FULL_MUL (Matrix, double, 0.);
+  SPARSE_FULL_MUL (Matrix, double);
 }
 
 Matrix
 trans_mul (const SparseMatrix& m, const Matrix& a)
 {
-  SPARSE_FULL_TRANS_MUL (Matrix, double, 0., );
+  SPARSE_FULL_TRANS_MUL (Matrix, double, );
 }
 
 // diag * sparse and sparse * diag
 
 SparseMatrix
 operator * (const DiagMatrix& d, const SparseMatrix& a)
 {
   return do_mul_dm_sm<SparseMatrix> (d, a);
@@ -7919,16 +7919,16 @@ max (const SparseMatrix& a, const Sparse
         r.resize (b_nr, b_nc);
       else
         octave::err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
-SPARSE_SMS_CMP_OPS (SparseMatrix, 0.0, double, 0.0)
+SPARSE_SMS_CMP_OPS (SparseMatrix, double)
 SPARSE_SMS_BOOL_OPS (SparseMatrix, double)
 
-SPARSE_SSM_CMP_OPS (double, 0.0, SparseMatrix, 0.0)
+SPARSE_SSM_CMP_OPS (double, SparseMatrix)
 SPARSE_SSM_BOOL_OPS (double, SparseMatrix)
 
-SPARSE_SMSM_CMP_OPS (SparseMatrix, 0.0, SparseMatrix, 0.0)
+SPARSE_SMSM_CMP_OPS (SparseMatrix, SparseMatrix)
 SPARSE_SMSM_BOOL_OPS (SparseMatrix, SparseMatrix)
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -72,25 +72,27 @@ along with Octave; see the file COPYING.
   }
 
 #define SPARSE_SMS_BIN_OPS(R1, R2, M, S)        \
   SPARSE_SMS_BIN_OP_1 (R1, operator +, +, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator -, -, M, S) \
   SPARSE_SMS_BIN_OP_2 (R2, operator *, *, M, S) \
   SPARSE_SMS_BIN_OP_2 (R2, operator /, /, M, S)
 
-#define SPARSE_SMS_CMP_OP(F, OP, M, MZ, S, SZ)                          \
+#define SPARSE_SMS_CMP_OP(F, OP, M, S)                                  \
   SparseBoolMatrix                                                      \
   F (const M& m, const S& s)                                            \
   {                                                                     \
     octave_idx_type nr = m.rows ();                                     \
     octave_idx_type nc = m.cols ();                                     \
     SparseBoolMatrix r;                                                 \
                                                                         \
-    if (MZ OP s)                                                        \
+    M::element_type m_zero = M::element_type ();                        \
+                                                                        \
+    if (m_zero OP s)                                                    \
       {                                                                 \
         r = SparseBoolMatrix (nr, nc, true);                            \
         for (octave_idx_type j = 0; j < nc; j++)                        \
           for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)   \
             if (! (m.data (i) OP s))                                    \
               r.data (m.ridx (i) + j * nr) = false;                     \
         r.maybe_compress (true);                                        \
       }                                                                 \
@@ -109,27 +111,27 @@ along with Octave; see the file COPYING.
                 }                                                       \
             r.cidx (j + 1) = nel;                                       \
           }                                                             \
         r.maybe_compress (false);                                       \
       }                                                                 \
     return r;                                                           \
   }
 
-#define SPARSE_SMS_CMP_OPS(M, MZ, S, SZ)                \
-  SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, MZ, S, SZ)        \
-  SPARSE_SMS_CMP_OP (mx_el_le, <=, M, MZ, S, SZ)        \
-  SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, MZ, S, SZ)        \
-  SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ, S, SZ)        \
-  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ, S, SZ)        \
-  SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ, S, SZ)
+#define SPARSE_SMS_CMP_OPS(M, S)                \
+  SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, S)        \
+  SPARSE_SMS_CMP_OP (mx_el_le, <=, M, S)        \
+  SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, S)        \
+  SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, S)        \
+  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, S)        \
+  SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, S)
 
-#define SPARSE_SMS_EQNE_OPS(M, MZ, S, SZ)               \
-  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ, S, SZ)        \
-  SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ, S, SZ)
+#define SPARSE_SMS_EQNE_OPS(M, S)               \
+  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, S)        \
+  SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, S)
 
 #define SPARSE_SMS_BOOL_OR_OP(M, S)                                     \
   SparseBoolMatrix                                                      \
   mx_el_or (const M& m, const S& s)                                     \
   {                                                                     \
     octave_idx_type nr = m.rows ();                                     \
     octave_idx_type nc = m.cols ();                                     \
     SparseBoolMatrix r;                                                 \
@@ -243,25 +245,27 @@ along with Octave; see the file COPYING.
   }
 
 #define SPARSE_SSM_BIN_OPS(R1, R2, S, M)        \
   SPARSE_SSM_BIN_OP_1 (R1, operator +, +, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator -, -, S, M) \
   SPARSE_SSM_BIN_OP_2 (R2, operator *, *, S, M) \
   SPARSE_SSM_BIN_OP_2 (R2, operator /, /, S, M)
 
-#define SPARSE_SSM_CMP_OP(F, OP, S, SZ, M, MZ)                          \
+#define SPARSE_SSM_CMP_OP(F, OP, S, M)                                  \
   SparseBoolMatrix                                                      \
   F (const S& s, const M& m)                                            \
   {                                                                     \
     octave_idx_type nr = m.rows ();                                     \
     octave_idx_type nc = m.cols ();                                     \
     SparseBoolMatrix r;                                                 \
                                                                         \
-    if (s OP MZ)                                                        \
+    M::element_type m_zero = M::element_type ();                        \
+                                                                        \
+    if (s OP m_zero)                                                    \
       {                                                                 \
         r = SparseBoolMatrix (nr, nc, true);                            \
         for (octave_idx_type j = 0; j < nc; j++)                        \
           for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)   \
             if (! (s OP m.data (i)))                                    \
               r.data (m.ridx (i) + j * nr) = false;                     \
         r.maybe_compress (true);                                        \
       }                                                                 \
@@ -280,27 +284,27 @@ along with Octave; see the file COPYING.
                 }                                                       \
             r.cidx (j + 1) = nel;                                       \
           }                                                             \
         r.maybe_compress (false);                                       \
       }                                                                 \
     return r;                                                           \
   }
 
-#define SPARSE_SSM_CMP_OPS(S, SZ, M, MZ)                \
-  SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, SZ, M, MZ)        \
-  SPARSE_SSM_CMP_OP (mx_el_le, <=, S, SZ, M, MZ)        \
-  SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, SZ, M, MZ)        \
-  SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ, M, MZ)        \
-  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ, M, MZ)        \
-  SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ, M, MZ)
+#define SPARSE_SSM_CMP_OPS(S, M)                \
+  SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, M)        \
+  SPARSE_SSM_CMP_OP (mx_el_le, <=, S, M)        \
+  SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, M)        \
+  SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, M)        \
+  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, M)        \
+  SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, M)
 
-#define SPARSE_SSM_EQNE_OPS(S, SZ, M, MZ)               \
-  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ, M, MZ)        \
-  SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ, M, MZ)
+#define SPARSE_SSM_EQNE_OPS(S, M)               \
+  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, M)        \
+  SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, M)
 
 #define SPARSE_SSM_BOOL_OR_OP(S, M)                                     \
   SparseBoolMatrix                                                      \
   mx_el_or (const S& s, const M& m)                                     \
   {                                                                     \
     octave_idx_type nr = m.rows ();                                     \
     octave_idx_type nc = m.cols ();                                     \
     SparseBoolMatrix r;                                                 \
@@ -713,28 +717,31 @@ along with Octave; see the file COPYING.
   SPARSE_SMSM_BIN_OP_1 (R1, operator +,  +, M1, M2)     \
   SPARSE_SMSM_BIN_OP_1 (R1, operator -,  -, M1, M2)     \
   SPARSE_SMSM_BIN_OP_2 (R2, product,     *, M1, M2)     \
   SPARSE_SMSM_BIN_OP_3 (R2, quotient,    /, M1, M2)
 
 // FIXME: this macro duplicates the bodies of the template functions
 // defined in the SPARSE_SSM_CMP_OP and SPARSE_SMS_CMP_OP macros.
 
-#define SPARSE_SMSM_CMP_OP(F, OP, M1, Z1, M2, Z2)                       \
+#define SPARSE_SMSM_CMP_OP(F, OP, M1, M2)                               \
   SparseBoolMatrix                                                      \
   F (const M1& m1, const M2& m2)                                        \
   {                                                                     \
     SparseBoolMatrix r;                                                 \
                                                                         \
     octave_idx_type m1_nr = m1.rows ();                                 \
     octave_idx_type m1_nc = m1.cols ();                                 \
                                                                         \
     octave_idx_type m2_nr = m2.rows ();                                 \
     octave_idx_type m2_nc = m2.cols ();                                 \
                                                                         \
+    M1::element_type Z1 = M1::element_type ();                          \
+    M2::element_type Z2 = M2::element_type ();                          \
+                                                                        \
     if (m1_nr == 1 && m1_nc == 1)                                       \
       {                                                                 \
         if (m1.elem (0,0) OP Z2)                                        \
           {                                                             \
             r = SparseBoolMatrix (m2_nr, m2_nc, true);                  \
             for (octave_idx_type j = 0; j < m2_nc; j++)                 \
               for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
                 if (! (m1.elem (0,0) OP m2.data (i)))                   \
@@ -877,27 +884,27 @@ along with Octave; see the file COPYING.
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
           octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
-#define SPARSE_SMSM_CMP_OPS(M1, Z1, M2, Z2)             \
-  SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1, M2, Z2)     \
-  SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1, M2, Z2)     \
-  SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1, M2, Z2)     \
-  SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, Z1, M2, Z2)     \
-  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1, M2, Z2)     \
-  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1, M2, Z2)
+#define SPARSE_SMSM_CMP_OPS(M1, M2)             \
+  SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, M2)     \
+  SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, M2)     \
+  SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, M2)     \
+  SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, M2)     \
+  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, M2)     \
+  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, M2)
 
-#define SPARSE_SMSM_EQNE_OPS(M1, Z1, M2, Z2)            \
-  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1, M2, Z2)     \
-  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1, M2, Z2)
+#define SPARSE_SMSM_EQNE_OPS(M1, M2)            \
+  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, M2)     \
+  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, M2)
 
 #define SPARSE_SMSM_BOOL_AND_OP(M1, M2)                                 \
   extern SparseBoolMatrix mx_el_and (const M1&, const M2::element_type&); \
   extern SparseBoolMatrix mx_el_and (const M1::element_type&, const M2&); \
   SparseBoolMatrix                                                      \
   mx_el_and (const M1& m1, const M2& m2)                                \
   {                                                                     \
     SparseBoolMatrix r;                                                 \
@@ -1109,17 +1116,16 @@ along with Octave; see the file COPYING.
           }                                                             \
         else                                                            \
           r = R (F (m1, m2.matrix_value ()));                           \
       }                                                                 \
                                                                         \
     return r;                                                           \
   }
 
-// FIXME: Pass a specific ZERO value
 #define SPARSE_MSM_BIN_OPS(R1, R2, M1, M2)              \
   SPARSE_MSM_BIN_OP_1 (R1, operator +,  +, M1, M2)      \
   SPARSE_MSM_BIN_OP_1 (R1, operator -,  -, M1, M2)      \
   SPARSE_MSM_BIN_OP_2 (R2, product,     *, M1, M2)      \
   SPARSE_MSM_BIN_OP_1 (R2, quotient,    /, M1, M2)
 
 #define SPARSE_MSM_CMP_OP(F, OP, M1, M2)                                \
   SparseBoolMatrix                                                      \
@@ -1168,25 +1174,25 @@ along with Octave; see the file COPYING.
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
           octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
-#define SPARSE_MSM_CMP_OPS(M1, Z1, M2, Z2)      \
+#define SPARSE_MSM_CMP_OPS(M1, M2)              \
   SPARSE_MSM_CMP_OP (mx_el_lt, <,  M1, M2)      \
   SPARSE_MSM_CMP_OP (mx_el_le, <=, M1, M2)      \
   SPARSE_MSM_CMP_OP (mx_el_ge, >=, M1, M2)      \
   SPARSE_MSM_CMP_OP (mx_el_gt, >,  M1, M2)      \
   SPARSE_MSM_CMP_OP (mx_el_eq, ==, M1, M2)      \
   SPARSE_MSM_CMP_OP (mx_el_ne, !=, M1, M2)
 
-#define SPARSE_MSM_EQNE_OPS(M1, Z1, M2, Z2)     \
+#define SPARSE_MSM_EQNE_OPS(M1, M2)             \
   SPARSE_MSM_CMP_OP (mx_el_eq, ==, M1, M2)      \
   SPARSE_MSM_CMP_OP (mx_el_ne, !=, M1, M2)
 
 #define SPARSE_MSM_BOOL_OP(F, OP, M1, M2)                               \
   SparseBoolMatrix                                                      \
   F (const M1& m1, const M2& m2)                                        \
   {                                                                     \
     SparseBoolMatrix r;                                                 \
@@ -1381,25 +1387,25 @@ along with Octave; see the file COPYING.
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
           octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
-#define SPARSE_SMM_CMP_OPS(M1, Z1, M2, Z2)      \
+#define SPARSE_SMM_CMP_OPS(M1, M2)              \
   SPARSE_SMM_CMP_OP (mx_el_lt, <,  M1, M2)      \
   SPARSE_SMM_CMP_OP (mx_el_le, <=, M1, M2)      \
   SPARSE_SMM_CMP_OP (mx_el_ge, >=, M1, M2)      \
   SPARSE_SMM_CMP_OP (mx_el_gt, >,  M1, M2)      \
   SPARSE_SMM_CMP_OP (mx_el_eq, ==, M1, M2)      \
   SPARSE_SMM_CMP_OP (mx_el_ne, !=, M1, M2)
 
-#define SPARSE_SMM_EQNE_OPS(M1, Z1, M2, Z2)     \
+#define SPARSE_SMM_EQNE_OPS(M1, M2)             \
   SPARSE_SMM_CMP_OP (mx_el_eq, ==, M1, M2)      \
   SPARSE_SMM_CMP_OP (mx_el_ne, !=, M1, M2)
 
 #define SPARSE_SMM_BOOL_OP(F, OP, M1, M2)                               \
   SparseBoolMatrix                                                      \
   F (const M1& m1, const M2& m2)                                        \
   {                                                                     \
     SparseBoolMatrix r;                                                 \
@@ -1914,49 +1920,51 @@ along with Octave; see the file COPYING.
                     retval.xdata (k) = Xcol[retval.xridx (k)];          \
                 }                                                       \
             }                                                           \
           retval.maybe_compress (true);                                 \
           return retval;                                                \
         }                                                               \
     }
 
-#define SPARSE_FULL_MUL(RET_TYPE, EL_TYPE, ZERO)                        \
+#define SPARSE_FULL_MUL(RET_TYPE, EL_TYPE)                              \
   octave_idx_type nr = m.rows ();                                       \
   octave_idx_type nc = m.cols ();                                       \
                                                                         \
   octave_idx_type a_nr = a.rows ();                                     \
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (nr == 1 && nc == 1)                                               \
     {                                                                   \
       RET_TYPE retval = m.elem (0,0) * a;                               \
       return retval;                                                    \
     }                                                                   \
   else if (nc != a_nr)                                                  \
     octave::err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
   else                                                                  \
     {                                                                   \
-      RET_TYPE retval (nr, a_nc, ZERO);                                 \
+      RET_TYPE::element_type zero = RET_TYPE::element_type ();          \
+                                                                        \
+      RET_TYPE retval (nr, a_nc, zero);                                 \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           for (octave_idx_type j = 0; j < a_nr; j++)                    \
             {                                                           \
               octave_quit ();                                           \
                                                                         \
               EL_TYPE tmpval = a.elem (j,i);                            \
               for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
                 retval.elem (m.ridx (k),i) += tmpval * m.data (k);      \
             }                                                           \
         }                                                               \
       return retval;                                                    \
     }
 
-#define SPARSE_FULL_TRANS_MUL(RET_TYPE, EL_TYPE, ZERO, CONJ_OP)         \
+#define SPARSE_FULL_TRANS_MUL(RET_TYPE, EL_TYPE, CONJ_OP)               \
   octave_idx_type nr = m.rows ();                                       \
   octave_idx_type nc = m.cols ();                                       \
                                                                         \
   octave_idx_type a_nr = a.rows ();                                     \
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (nr == 1 && nc == 1)                                               \
     {                                                                   \
@@ -1970,75 +1978,79 @@ along with Octave; see the file COPYING.
       RET_TYPE retval (nc, a_nc);                                       \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           for (octave_idx_type j = 0; j < nc; j++)                      \
             {                                                           \
               octave_quit ();                                           \
                                                                         \
-              EL_TYPE acc = ZERO;                                       \
+              EL_TYPE acc = EL_TYPE ();                                 \
               for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
                 acc += a.elem (m.ridx (k),i) * CONJ_OP (m.data (k));    \
               retval.xelem (j,i) = acc;                                 \
             }                                                           \
         }                                                               \
       return retval;                                                    \
     }
 
-#define FULL_SPARSE_MUL(RET_TYPE, EL_TYPE, ZERO)                        \
+#define FULL_SPARSE_MUL(RET_TYPE, EL_TYPE)                              \
   octave_idx_type nr = m.rows ();                                       \
   octave_idx_type nc = m.cols ();                                       \
                                                                         \
   octave_idx_type a_nr = a.rows ();                                     \
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (a_nr == 1 && a_nc == 1)                                           \
     {                                                                   \
       RET_TYPE retval = m * a.elem (0,0);                               \
       return retval;                                                    \
     }                                                                   \
   else if (nc != a_nr)                                                  \
     octave::err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
   else                                                                  \
     {                                                                   \
-      RET_TYPE retval (nr, a_nc, ZERO);                                 \
+      RET_TYPE::element_type zero = RET_TYPE::element_type ();          \
+                                                                        \
+      RET_TYPE retval (nr, a_nc, zero);                                 \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           octave_quit ();                                               \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)   \
             {                                                           \
               octave_idx_type col = a.ridx (j);                         \
               EL_TYPE tmpval = a.data (j);                              \
                                                                         \
               for (octave_idx_type k = 0 ; k < nr; k++)                 \
                 retval.xelem (k,i) += tmpval * m.elem (k,col);          \
             }                                                           \
         }                                                               \
       return retval;                                                    \
     }
 
-#define FULL_SPARSE_MUL_TRANS(RET_TYPE, EL_TYPE, ZERO, CONJ_OP)         \
+#define FULL_SPARSE_MUL_TRANS(RET_TYPE, EL_TYPE, CONJ_OP)               \
   octave_idx_type nr = m.rows ();                                       \
   octave_idx_type nc = m.cols ();                                       \
                                                                         \
   octave_idx_type a_nr = a.rows ();                                     \
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (a_nr == 1 && a_nc == 1)                                           \
     {                                                                   \
       RET_TYPE retval = m * CONJ_OP (a.elem (0,0));                     \
       return retval;                                                    \
     }                                                                   \
   else if (nc != a_nc)                                                  \
     octave::err_nonconformant ("operator *", nr, nc, a_nc, a_nr);               \
   else                                                                  \
     {                                                                   \
-      RET_TYPE retval (nr, a_nr, ZERO);                                 \
+      RET_TYPE::element_type zero = RET_TYPE::element_type ();          \
+                                                                        \
+      RET_TYPE retval (nr, a_nr, zero);                                 \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           octave_quit ();                                               \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)   \
             {                                                           \
               octave_idx_type col = a.ridx (j);                         \
               EL_TYPE tmpval = CONJ_OP (a.data (j));                    \
diff --git a/liboctave/operators/mk-ops.awk b/liboctave/operators/mk-ops.awk
--- a/liboctave/operators/mk-ops.awk
+++ b/liboctave/operators/mk-ops.awk
@@ -84,22 +84,21 @@ BEGIN {
         }
     }
   next;
 } {
   if (declare_types)
     {
       ntypes++;
 
-      if (NF == 6 || NF == 7)
+      if (NF == 5 || NF == 6)
         {
-          if (NF == 7)
-            core_type[ntypes] = $7;
+          if (NF == 6)
+            core_type[ntypes] = $6;
 
-          scalar_zero_val[ntypes] = $6;
           fwd_decl_ok[ntypes] = $5 == "YES";
           header[ntypes] = $4 == "NONE" ? "" : $4;
           class[ntypes] = $3;
           type[ntypes] = $2;
           tag[ntypes] = $1;
           rev_tag[$1] = ntypes;
         }
       else
@@ -163,19 +162,16 @@ BEGIN {
           if (sparse)
             result_type_2 = type[result_num_2];
           lhs_type = type[lhs_num];
           rhs_type = type[rhs_num];
 
           lhs_core_type = core_type[lhs_num];
           rhs_core_type = core_type[rhs_num];
 
-          lhs_scalar_zero_val = scalar_zero_val[lhs_num];
-          rhs_scalar_zero_val = scalar_zero_val[rhs_num];
-
           result_header_1 = header[result_num_1];
           if (sparse)
             result_header_2 = header[result_num_2];
           lhs_header = header[lhs_num];
           rhs_header = header[rhs_num];
 
           lhs_class = class[lhs_num];
           rhs_class = class[rhs_num];
@@ -375,24 +371,21 @@ BEGIN {
               if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header_1 || rhs_header == result_header_2))
                 printf ("#include \"%s\"\n", rhs_header);
 
               if (bin_ops)
                 emit_bin_ops(sparse, lhs_class, rhs_class,
                              result_type_1, result_type_2, lhs_type, rhs_type);
 
               if (cmp_ops)
-                emit_cmp_ops(sparse, lhs_class, rhs_class,
-                             lhs_type, rhs_type,
-                             lhs_scalar_zero_val, rhs_scalar_zero_val);
+                emit_cmp_ops(sparse, lhs_class, rhs_class, lhs_type, rhs_type);
 
               if (eqne_ops)
                 emit_eqne_ops(sparse, lhs_class, rhs_class,
-                              lhs_type, rhs_type,
-                              lhs_scalar_zero_val, rhs_scalar_zero_val);
+                              lhs_type, rhs_type);
 
               if (bool_ops)
                 emit_bool_ops(sparse, lhs_class, rhs_class,
                               lhs_type, rhs_type);
 
               exit (0);
             }
         }
@@ -640,38 +633,31 @@ function emit_bin_ops (sparse, lhs_class
                     lhs_type, rhs_type);
   else if (lhs_class == "M" && rhs_class == "M")
     emit_mm_bin_ops(result_type_1, lhs_type, rhs_type);
   else
     printf ("%s%s_BIN_OPS (%s, %s, %s)\n",
             lhs_class, rhs_class, result_type_1, lhs_type, rhs_type);
 }
 
-function emit_cmp_ops (sparse, lhs_class, rhs_class,
-                       lhs_type, rhs_type,
-                       lhs_scalar_zero_val, rhs_scalar_zero_val)
+function emit_cmp_ops (sparse, lhs_class, rhs_class, lhs_type, rhs_type)
 {
   if (sparse)
-    printf ("SPARSE_%s%s_CMP_OPS (%s, %s, %s, %s)\n",
-            lhs_class, rhs_class, lhs_type,
-            lhs_scalar_zero_val, rhs_type,
-            rhs_scalar_zero_val);
+    printf ("SPARSE_%s%s_CMP_OPS (%s, %s)\n",
+            lhs_class, rhs_class, lhs_type, rhs_type);
   else
     printf ("%s%s_CMP_OPS (%s, %s)\n",
             lhs_class, rhs_class, lhs_type, rhs_type);
 }
 
-function emit_eqne_ops (sparse, lhs_class, rhs_class, lhs_type, rhs_type,
-                        lhs_scalar_zero_val, rhs_scalar_zero_val)
+function emit_eqne_ops (sparse, lhs_class, rhs_class, lhs_type, rhs_type)
 {
   if (sparse)
-    printf ("SPARSE_%s%s_EQNE_OPS (%s, %s, %s, %s)\n",
-            lhs_class, rhs_class, lhs_type,
-            lhs_scalar_zero_val, rhs_type,
-            rhs_scalar_zero_val);
+    printf ("SPARSE_%s%s_EQNE_OPS (%s, %s)\n",
+            lhs_class, rhs_class, lhs_type, rhs_type);
 
   ## No separate eqne ops for full-matrix or vector.
 }
 
 function emit_bool_ops (sparse, lhs_class, rhs_class, lhs_type, rhs_type)
 {
   if (sparse)
     printf ("SPARSE_%s%s_BOOL_OPS (%s, %s)\n",
diff --git a/liboctave/operators/mx-ops b/liboctave/operators/mx-ops
--- a/liboctave/operators/mx-ops
+++ b/liboctave/operators/mx-ops
@@ -16,69 +16,69 @@
 # along with Octave; see the file COPYING.  If not, see
 # <https://www.gnu.org/licenses/>.
 
 # NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
 #
-# key typename object-type header fwd-decl-ok scalar-zero core-type
+# key typename object-type header fwd-decl-ok core-type
 #
 # object-type is one of
 #
 #   S:  scalar
 #   M:  matrix
 #   DM: diagonal matrix
 #   ND: N-d array
 #   FS:  scalar
 #   FM:  matrix
 #   FDM: diagonal matrix
 #   FND: N-d array
 #
 # core-type is only used for the octave_int types, and is the template
 # parameter: octave_int8 is octave_int<int8_t>
 #
-x NONE NONE NONE NO 0
-b bool S NONE NO false
-bm boolMatrix ND boolMatrix.h YES false
-bnda boolNDArray ND boolNDArray.h YES false
-cdm ComplexDiagMatrix DM CDiagMatrix.h YES 0.0
-cm ComplexMatrix M CMatrix.h YES 0.0
-cnda ComplexNDArray ND CNDArray.h YES 0.0
-cs Complex S oct-cmplx.h NO 0.0
-dm DiagMatrix DM dDiagMatrix.h YES 0.0
-m Matrix M dMatrix.h YES 0.0
-nda NDArray ND dNDArray.h YES 0.0
-s double S NONE NO 0.0
-fcdm FloatComplexDiagMatrix DM fCDiagMatrix.h YES 0.0f
-fcm FloatComplexMatrix M fCMatrix.h YES 0.0f
-fcnda FloatComplexNDArray ND fCNDArray.h YES 0.0f
-fcs FloatComplex S oct-cmplx.h NO 0.0f
-fdm FloatDiagMatrix DM fDiagMatrix.h YES 0.0f
-fm FloatMatrix M fMatrix.h YES 0.0f
-fnda FloatNDArray ND fNDArray.h YES 0.0f
-fs float S NONE NO 0.0f
-i8 octave_int8 S oct-inttypes.h YES octave_int8::zero int8_t
-ui8 octave_uint8 S oct-inttypes.h YES octave_uint8::zero uint8_t
-i16 octave_int16 S oct-inttypes.h YES octave_int16::zero int16_t
-ui16 octave_uint16 S oct-inttypes.h YES octave_uint16::zero uint16_t
-i32 octave_int32 S oct-inttypes.h YES octave_int32::zero int32_t
-ui32 octave_uint32 S oct-inttypes.h YES octave_uint32::zero uint32_t
-i64 octave_int64 S oct-inttypes.h YES octave_int64::zero int64_t
-ui64 octave_uint64 S oct-inttypes.h YES octave_uint64::zero uint64_t
-i8nda int8NDArray ND int8NDArray.h YES octave_int8::zero int8_t
-ui8nda uint8NDArray ND uint8NDArray.h YES octave_uint8::zero uint8_t
-i16nda int16NDArray ND int16NDArray.h YES octave_int16::zero int16_t
-ui16nda uint16NDArray ND uint16NDArray.h YES octave_uint16::zero uint16_t
-i32nda int32NDArray ND int32NDArray.h YES octave_int32::zero int32_t
-ui32nda uint32NDArray ND uint32NDArray.h YES octave_uint32::zero uint32_t
-i64nda int64NDArray ND int64NDArray.h YES octave_int64::zero int64_t
-ui64nda uint64NDArray ND uint64NDArray.h YES octave_uint64::zero uint64_t
-pm PermMatrix PM PermMatrix.h YES static_cast<octave_idx_type>(0)
+x NONE NONE NONE NO
+b bool S NONE NO
+bm boolMatrix ND boolMatrix.h YES
+bnda boolNDArray ND boolNDArray.h YES
+cdm ComplexDiagMatrix DM CDiagMatrix.h YES
+cm ComplexMatrix M CMatrix.h YES
+cnda ComplexNDArray ND CNDArray.h YES
+cs Complex S oct-cmplx.h NO
+dm DiagMatrix DM dDiagMatrix.h YES
+m Matrix M dMatrix.h YES
+nda NDArray ND dNDArray.h YES
+s double S NONE NO
+fcdm FloatComplexDiagMatrix DM fCDiagMatrix.h YES
+fcm FloatComplexMatrix M fCMatrix.h YES
+fcnda FloatComplexNDArray ND fCNDArray.h YES
+fcs FloatComplex S oct-cmplx.h NO
+fdm FloatDiagMatrix DM fDiagMatrix.h YES
+fm FloatMatrix M fMatrix.h YES
+fnda FloatNDArray ND fNDArray.h YES
+fs float S NONE NO
+i8 octave_int8 S oct-inttypes.h YES int8_t
+ui8 octave_uint8 S oct-inttypes.h YES uint8_t
+i16 octave_int16 S oct-inttypes.h YES int16_t
+ui16 octave_uint16 S oct-inttypes.h YES uint16_t
+i32 octave_int32 S oct-inttypes.h YES int32_t
+ui32 octave_uint32 S oct-inttypes.h YES uint32_t
+i64 octave_int64 S oct-inttypes.h YES int64_t
+ui64 octave_uint64 S oct-inttypes.h YES uint64_t
+i8nda int8NDArray ND int8NDArray.h YES int8_t
+ui8nda uint8NDArray ND uint8NDArray.h YES uint8_t
+i16nda int16NDArray ND int16NDArray.h YES int16_t
+ui16nda uint16NDArray ND uint16NDArray.h YES uint16_t
+i32nda int32NDArray ND int32NDArray.h YES int32_t
+ui32nda uint32NDArray ND uint32NDArray.h YES uint32_t
+i64nda int64NDArray ND int64NDArray.h YES int64_t
+ui64nda uint64NDArray ND uint64NDArray.h YES uint64_t
+pm PermMatrix PM PermMatrix.h YES
 #
 # full-matrix operators
 #
 # result_t lhs_t rhs_t op-type headers ...
 #
 # op-type is one of
 #
 #   B: binary ops, + - * /
diff --git a/liboctave/operators/smx-ops b/liboctave/operators/smx-ops
--- a/liboctave/operators/smx-ops
+++ b/liboctave/operators/smx-ops
@@ -16,33 +16,33 @@
 # along with Octave; see the file COPYING.  If not, see
 # <https://www.gnu.org/licenses/>.
 
 # NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
 #
-# key typename object-type header fwd-decl-ok scalar-zero
+# key typename object-type header fwd-decl-ok
 #
 #   S:  scalar
 #   M:  matrix
 #   DM: diagonal matrix
 #   ND: N-d array
 #   SM: sparse matrix
 #
-sm SparseMatrix SM dSparse.h YES 0.0
-scm SparseComplexMatrix SM CSparse.h YES 0.0
-sbm SparseBoolMatrix SM boolSparse.h YES false
-b bool S NONE NO false
-bm boolMatrix M boolMatrix.h YES false
-s double S NONE NO 0.0
-cs Complex S oct-cmplx.h NO 0.0
-m Matrix M dMatrix.h YES 0.0
-cm ComplexMatrix M CMatrix.h YES 0.0
+sm SparseMatrix SM dSparse.h YES
+scm SparseComplexMatrix SM CSparse.h YES
+sbm SparseBoolMatrix SM boolSparse.h YES
+b bool S NONE NO
+bm boolMatrix M boolMatrix.h YES
+s double S NONE NO
+cs Complex S oct-cmplx.h NO
+m Matrix M dMatrix.h YES
+cm ComplexMatrix M CMatrix.h YES
 #
 # sparse-matrix operators
 #
 # result_t_1 result_t_2 lhs_t rhs_t op-type headers ...
 #
 # op-type is one of
 #
 #   B: binary ops, + - * /
