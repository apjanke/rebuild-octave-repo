# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493312671 25200
#      Thu Apr 27 10:04:31 2017 -0700
# Node ID db1fdf4384ddd4b287df4cb1a548326564e7d7c3
# Parent  cd4e1ee2871654f5c5c6000f14b49a375098e7e2
maint: Use convention "static_cast<void *>" for casting of pointers.

* Backend.cc, BaseControl.cc, ButtonControl.cc, ButtonGroup.cc, Canvas.cc,
Container.cc, ContextMenu.cc, Figure.cc, ListBoxControl.cc, Menu.cc,
MouseModeActionGroup.cc, Object.cc, Object.h, Panel.cc, RadioButtonControl.cc,
ToggleButtonControl.cc, ToolBar.cc, ToolBarButton.cc, annotation-dialog.cc,
file-editor-tab.cc, main-window.cc, webinfo.cc, data.cc, ft-text-renderer.cc,
graphics.in.h, zfstream.h, __init_fltk__.cc, __osmesa_print__.cc, gzip.cc,
ov-java.cc, bp-table.cc, oct-time.cc, lo-utils.cc, oct-base64.cc,
url-transfer.cc:
Use convention "static_cast<void *>" for casting of pointers.

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -212,16 +212,16 @@ namespace QtHandles
     if (go)
       {
         octave_value ov = go.get (toolkitObjectProperty (go));
 
         if (ov.is_defined () && ! ov.is_empty ())
           {
             OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
 
-            return reinterpret_cast<ObjectProxy*> (ptr);
+            return reinterpret_cast<ObjectProxy *> (ptr);
           }
       }
 
     return 0;
   }
 
 };
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -190,17 +190,17 @@ namespace QtHandles
                                           (properties<uicontrol> ()));
           }
         break;
 
       case QEvent::MouseButtonPress:
         {
           gh_manager::auto_lock lock;
 
-          QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+          QMouseEvent *m = dynamic_cast<QMouseEvent *> (xevent);
           graphics_object go = object ();
           uicontrol::properties& up = Utils::properties<uicontrol> (go);
           graphics_object fig = go.get_ancestor ("figure");
 
           if (m->button () != Qt::LeftButton
               || ! up.enable_is ("on"))
             {
               gh_manager::post_set (fig.get_handle (), "selectiontype",
@@ -227,33 +227,33 @@ namespace QtHandles
         }
         break;
 
       case QEvent::MouseMove:
         if (qWidget<QWidget> ()->hasMouseTracking ())
           {
             gh_manager::auto_lock lock;
 
-            QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+            QMouseEvent *m = dynamic_cast<QMouseEvent *> (xevent);
             graphics_object go = object ();
             graphics_object fig = go.get_ancestor ("figure");
 
             gh_manager::post_set (fig.get_handle (), "currentpoint",
                                   Utils::figureCurrentPoint (fig, m), false);
             gh_manager::post_callback (fig.get_handle (), "windowbuttonmotionfcn");
           }
         break;
 
       case QEvent::KeyPress:
         if (m_keyPressHandlerDefined)
           {
             gh_manager::auto_lock lock;
 
             octave_scalar_map keyData =
-              Utils::makeKeyEventStruct (dynamic_cast<QKeyEvent*> (xevent));
+              Utils::makeKeyEventStruct (dynamic_cast<QKeyEvent *> (xevent));
             graphics_object fig = object ().get_ancestor ("figure");
 
             gh_manager::post_set (fig.get_handle (), "currentcharacter",
                                   keyData.getfield ("Character"), false);
             gh_manager::post_callback (m_handle, "keypressfcn", keyData);
           }
         break;
 
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -89,17 +89,17 @@ namespace QtHandles
                   warning ("button value not within valid display range");
                 else if (dValue == up.get_min () && btn->isChecked ())
                   {
                     btn->setChecked (false);
                     if (up.style_is ("radiobutton") || up.style_is ("togglebutton"))
                       {
                         Object* parent = Object::parentObject (gh_manager::get_object (
                             up.get___myhandle__ ()));
-                        ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+                        ButtonGroup* btnGroup = dynamic_cast<ButtonGroup *>(parent);
                         if (btnGroup)
                           btnGroup->selectNothing ();
                       }
                   }
                 else if (dValue == up.get_max () && ! btn->isChecked ())
                   btn->setChecked (true);
               }
           }
diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -204,17 +204,17 @@ namespace QtHandles
                         }
                       updateLayout ();
                     }
                 }
                 break;
 
               case QEvent::MouseButtonPress:
                 {
-                  QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+                  QMouseEvent* m = dynamic_cast<QMouseEvent *> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       ContextMenu::executeAt (properties (), m->globalPos ());
                     }
                 }
@@ -345,19 +345,19 @@ namespace QtHandles
         break;
 
       case uibuttongroup::properties::ID_SELECTEDOBJECT:
         {
           graphics_handle h = pp.get_selectedobject ();
           gh_manager::auto_lock lock;
           graphics_object go = gh_manager::get_object (h);
           Object* selectedObject = Backend::toolkitObject (go);
-          ToggleButtonControl* toggle = static_cast<ToggleButtonControl*>
+          ToggleButtonControl* toggle = static_cast<ToggleButtonControl *>
                                         (selectedObject);
-          RadioButtonControl* radio = static_cast<RadioButtonControl*>(selectedObject);
+          RadioButtonControl* radio = static_cast<RadioButtonControl *>(selectedObject);
           if (toggle)
             {
               go.get_properties ().set ("value", 1);
             }
           else if (radio)
             {
               go.get_properties ().set ("value", 1);
             }
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -558,17 +558,17 @@ namespace QtHandles
         std::vector<std::string> omit = {"legend", "colorbar", "scribeoverlay"};
         select_object (obj, event, currentObj, axesObj, true, omit);
 
         if (axesObj.valid_object ())
           {
             // FIXME: should we use signal/slot mechanism instead of
             //        directly calling parent fig methods
             Figure* fig =
-              dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
+              dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
             axes::properties& ap = Utils::properties<axes> (axesObj);
 
             if (fig)
               fig->updateStatusBar (ap.pixel2coord (event->x (), event->y ()));
           }
       }
   }
 
@@ -644,17 +644,17 @@ namespace QtHandles
 
         if (currentObj.get_properties ().handlevisibility_is ("on"))
           Utils::properties<figure> (figObj)
           .set_currentobject (currentObj.get_handle ().as_octave_value ());
         else
           Utils::properties<figure> (figObj).set_currentobject (
             octave::numeric_limits<double>::NaN ());
 
-        Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
+        Figure* fig = dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
 
         MouseMode newMouseMode = NoMode;
 
         if (fig)
           newMouseMode = fig->mouseMode ();
 
         switch (newMouseMode)
           {
@@ -924,17 +924,17 @@ namespace QtHandles
           }
 
         if (axesObj)
           {
             MouseMode newMouseMode = NoMode;
 
             graphics_object figObj (obj.get_ancestor ("figure"));
 
-            Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
+            Figure* fig = dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
 
             if (fig)
               newMouseMode = fig->mouseMode ();
 
             if (axesObj.get_properties ().handlevisibility_is ("on"))
               {
                 Utils::properties<figure> (figObj)
                 .set_currentaxes (axesObj.get_handle ().as_octave_value ());
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -111,16 +111,16 @@ namespace QtHandles
     // do this when child objects are removed.
 
     if (xevent->added ())
       {
         QObject *obj = xevent->child ();
 
         if (obj && obj->isWidgetType ())
           {
-            QWidget *widget = qobject_cast<QWidget*> (obj);
+            QWidget *widget = qobject_cast<QWidget *> (obj);
 
             if (widget)
               widget->setMouseTracking (hasMouseTracking ());
           }
       }
   }
 }
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -117,17 +117,17 @@ namespace QtHandles
     if (h.ok ())
       {
         gh_manager::auto_lock lock;
         graphics_object go = gh_manager::get_object (h);
 
         if (go.valid_object ())
           {
             ContextMenu* cMenu =
-              dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
+              dynamic_cast<ContextMenu *> (Backend::toolkitObject (go));
 
             if (cMenu)
               {
                 QMenu* menu = cMenu->qWidget<QMenu> ();
 
                 if (menu)
                   menu->popup (pt);
               }
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -601,17 +601,17 @@ namespace QtHandles
     Figure* m_figure;
   };
 
   void
   Figure::updateBoundingBoxHelper (void* data)
   {
     gh_manager::auto_lock lock;
 
-    UpdateBoundingBoxData* d = reinterpret_cast<UpdateBoundingBoxData*> (data);
+    UpdateBoundingBoxData* d = reinterpret_cast<UpdateBoundingBoxData *> (data);
     graphics_object go = gh_manager::get_object (d->m_handle);
 
     if (go.valid_object ())
       {
         figure::properties& fp = Utils::properties<figure> (go);
 
         fp.set_boundingbox (d->m_bbox, d->m_internal, false);
       }
@@ -691,17 +691,17 @@ namespace QtHandles
           {
             switch (xevent->type ())
               {
               case QEvent::ActionChanged:
                 m_previousHeight = m_menuBar->sizeHint ().height ();
                 break;
               case QEvent::ActionRemoved:
                 {
-                  QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
+                  QAction* a = dynamic_cast<QActionEvent *> (xevent)->action ();
 
                   if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu")
                     updateMenuBar ();
                 }
                 break;
 
               default:
@@ -735,27 +735,27 @@ namespace QtHandles
           {
             switch (xevent->type ())
               {
               case QEvent::Resize:
                 updateBoundingBox (true, UpdateBoundingBoxSize);
                 break;
 
               case QEvent::ChildAdded:
-                if (dynamic_cast<QChildEvent*> (xevent)->child
+                if (dynamic_cast<QChildEvent *> (xevent)->child
                     ()->isWidgetType())
                   {
                     gh_manager::auto_lock lock;
                     update (figure::properties::ID_TOOLBAR);
 
                     enableMouseTracking ();
                   }
 
               case QEvent::ChildRemoved:
-                if (dynamic_cast<QChildEvent*> (xevent)->child
+                if (dynamic_cast<QChildEvent *> (xevent)->child
                     ()->isWidgetType())
                   {
                     gh_manager::auto_lock lock;
                     update (figure::properties::ID_TOOLBAR);
                   }
 
               default:
                 break;
@@ -763,26 +763,26 @@ namespace QtHandles
           }
         else if (watched == m_menuBar)
           {
             switch (xevent->type ())
               {
               case QEvent::ActionChanged:
                 // The menubar may have been resized if no action is visible
                 {
-                  QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
+                  QAction* a = dynamic_cast<QActionEvent *> (xevent)->action ();
                   if (m_menuBar->sizeHint ().height () != m_previousHeight
                       && a->objectName () != "builtinMenu"
                       && ! a->isSeparator ())
                     updateMenuBar (m_previousHeight);
                 }
                 break;
               case QEvent::ActionAdded:
                 {
-                  QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
+                  QAction* a = dynamic_cast<QActionEvent *> (xevent)->action ();
 
                   if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu"
                       && a->isVisible ())
                     updateMenuBar ();
                 }
                 break;
 
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -225,31 +225,31 @@ namespace QtHandles
       {
         bool override_return = false;
         QListWidget* list = qWidget<QListWidget> ();
 
         switch (e->type ())
           {
             case QEvent::MouseButtonPress:
               {
-                QMouseEvent* m = dynamic_cast<QMouseEvent*> (e);
+                QMouseEvent* m = dynamic_cast<QMouseEvent *> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
                 else
                   {
                     if (! list->indexAt (m->pos ()).isValid ())
                       override_return = true;
                     m_selectionChanged = true;
                   }
                 break;
               }
             case QEvent::MouseButtonRelease:
               {
-                QMouseEvent* m = dynamic_cast<QMouseEvent*> (e);
+                QMouseEvent* m = dynamic_cast<QMouseEvent *> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
 
                 else if (! list->indexAt (m->pos ()).isValid ())
                   {
                     list->setCurrentRow (list->count () - 1);
                     override_return = true;
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -92,17 +92,17 @@ namespace QtHandles
 
     if (up.is_separator ())
       {
         m_separator = new QAction (action);
         m_separator->setSeparator (true);
         m_separator->setVisible (up.is_visible ());
       }
 
-    MenuContainer* menuContainer = dynamic_cast<MenuContainer*> (xparent);
+    MenuContainer* menuContainer = dynamic_cast<MenuContainer *> (xparent);
 
     if (menuContainer)
       m_parent = menuContainer->menu ();
 
     if (m_parent)
       {
         int pos = static_cast<int> (up.get_position ());
 
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -71,17 +71,17 @@ namespace QtHandles
         if (sender () == m_current)
           {
             m_current = 0;
             emit modeChanged (NoMode);
           }
       }
     else
       {
-        int i = m_actions.indexOf (qobject_cast<QAction*> (sender ()));
+        int i = m_actions.indexOf (qobject_cast<QAction *> (sender ()));
 
         if (i >= 0)
           {
             m_current = m_actions[i];
             for (int j = 0; j < m_actions.size (); j++)
               {
                 // SelectMode cancels all the others but the button
                 // doesn't remain highlighed.
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -173,14 +173,14 @@ namespace QtHandles
   }
 
   Object*
   Object::fromQObject (QObject* obj)
   {
     QVariant v = obj->property ("QtHandles::Object");
 
     if (v.isValid ())
-      return reinterpret_cast<Object*> (qvariant_cast<void*> (v));
+      return reinterpret_cast<Object *> (qvariant_cast<void*> (v));
 
     return 0;
   }
 
 }
diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -66,17 +66,17 @@ namespace QtHandles
              (object ().get_properties ());
     }
 
     graphics_object object (void) const;
 
     virtual QObject* qObject (void) { return m_qobject; }
 
     template <typename T>
-    T* qWidget (void) { return qobject_cast<T*>(qObject ()); }
+    T* qWidget (void) { return qobject_cast<T *>(qObject ()); }
 
     virtual Container* innerContainer (void) = 0;
 
     static Object* fromQObject (QObject* obj);
 
   public slots:
     void slotUpdate (int pId);
     void slotFinalize (void);
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -179,17 +179,17 @@ namespace QtHandles
                         }
                       updateLayout ();
                     }
                 }
                 break;
 
               case QEvent::MouseButtonPress:
                 {
-                  QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+                  QMouseEvent* m = dynamic_cast<QMouseEvent *> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       graphics_object go = object ();
 
                       if (go.valid_object ())
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -50,17 +50,17 @@ namespace QtHandles
     return 0;
   }
 
   RadioButtonControl::RadioButtonControl (const graphics_object& go,
                                           QRadioButton* radio)
     : ButtonControl (go, radio)
   {
     Object* parent = Object::parentObject (go);
-    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup *>(parent);
     if (btnGroup)
       btnGroup->addButton (radio);
 
     radio->setAutoFillBackground (true);
     radio->setAutoExclusive (false);
   }
 
   RadioButtonControl::~RadioButtonControl (void)
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -50,17 +50,17 @@ namespace QtHandles
     return 0;
   }
 
   ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
       QPushButton* btn)
     : ButtonControl (go, btn)
   {
     Object* parent = Object::parentObject (go);
-    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup *>(parent);
     if (btnGroup)
       btnGroup->addButton (btn);
 
     btn->setCheckable (true);
     btn->setAutoFillBackground (true);
   }
 
   ToggleButtonControl::~ToggleButtonControl (void)
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -86,17 +86,17 @@ namespace QtHandles
 
     bar->setFloatable (false);
     bar->setMovable (false);
     bar->setVisible (tp.is_visible ());
 
     m_empty = addEmptyAction (bar);
 
     m_figure =
-      dynamic_cast<Figure*> (Object::fromQObject (bar->parentWidget ()));
+      dynamic_cast<Figure *> (Object::fromQObject (bar->parentWidget ()));
 
     if (m_figure)
       m_figure->addCustomToolBar (bar, tp.is_visible ());
 
     bar->installEventFilter (this);
   }
 
   ToolBar::~ToolBar (void)
@@ -126,17 +126,17 @@ namespace QtHandles
   {
     if (watched == qObject ())
       {
         switch (xevent->type ())
           {
           case QEvent::ActionAdded:
           case QEvent::ActionRemoved:
             {
-              QActionEvent* ae = dynamic_cast<QActionEvent*> (xevent);
+              QActionEvent* ae = dynamic_cast<QActionEvent *> (xevent);
               QToolBar* bar = qWidget<QToolBar> ();
 
               if (ae->action () != m_empty)
                 {
                   if (xevent->type () == QEvent::ActionAdded)
                     {
                       if (bar->actions ().size () == 2)
                         QTimer::singleShot (0, this, SLOT (hideEmpty (void)));
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -46,17 +46,17 @@ namespace QtHandles
     if (tp.is_separator ())
       {
         m_separator = new QAction (action);
         m_separator->setSeparator (true);
         m_separator->setVisible (tp.is_visible ());
       }
     action->setEnabled (tp.is_enable ());
 
-    QWidget* w = qobject_cast<QWidget*> (action->parent ());
+    QWidget* w = qobject_cast<QWidget *> (action->parent ());
 
     w->insertAction (w->actions ().back (), action);
     if (m_separator)
       w->insertAction (action, m_separator);
   }
 
   template <typename T>
   ToolBarButton<T>::~ToolBarButton (void)
@@ -93,17 +93,17 @@ namespace QtHandles
         if (tp.is_separator ())
           {
             if (! m_separator)
               {
                 m_separator = new QAction (action);
                 m_separator->setSeparator (true);
                 m_separator->setVisible (tp.is_visible ());
 
-                QWidget* w = qobject_cast<QWidget*> (action->parent ());
+                QWidget* w = qobject_cast<QWidget *> (action->parent ());
 
                 w->insertAction (action, m_separator);
               }
           }
         else
           {
             if (m_separator)
               delete m_separator;
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -260,17 +260,17 @@ void
 annotation_dialog::edit_string_changed (const QString& str)
 {
   ui->button_box->button (QDialogButtonBox::Ok)->setEnabled (str.length () > 0);
 }
 
 void
 annotation_dialog::prompt_for_color ()
 {
-  QWidget *widg = dynamic_cast<QWidget*> (sender ());
+  QWidget *widg = dynamic_cast<QWidget *> (sender ());
   if (widg)
     {
       QColor color = widg->palette ().color (QPalette::Button);
 
       color = QColorDialog::getColor (color, this);
 
       if (color.isValid ())
         {
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1998,17 +1998,17 @@ file_editor_tab::save_file_as (bool remo
   extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Fixed,
                                           QSizePolicy::Fixed), 1,2);
   extra->addWidget (label_enc,1,3);
   extra->addWidget (combo_enc,1,4);
   extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Expanding,
                                           QSizePolicy::Fixed), 1,5);
 
   // and add the extra grid layout to the dialog's layout
-  QGridLayout *dialog_layout = dynamic_cast<QGridLayout*> (fileDialog->layout ());
+  QGridLayout *dialog_layout = dynamic_cast<QGridLayout *> (fileDialog->layout ());
   dialog_layout->addLayout (extra,dialog_layout->rowCount (),0,
                                   1,dialog_layout->columnCount ());
 
   // add the possible filters and the default suffix
   QStringList filters;
   filters << tr ("Octave Files (*.m)")
           << tr ("All Files (*)");
   fileDialog->setNameFilters (filters);
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1449,17 +1449,17 @@ main_window::request_open_file (void)
       // build the extra grid layout
       extra->addWidget (separator,0,0,1,3);
       extra->addWidget (label_enc,1,0);
       extra->addWidget (combo_enc,1,1);
       extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Expanding,
                                         QSizePolicy::Fixed), 1,2);
 
       // and add the extra grid layout to the dialog's layout
-      QGridLayout *dialog_layout = dynamic_cast<QGridLayout*> (
+      QGridLayout *dialog_layout = dynamic_cast<QGridLayout *> (
                                    fileDialog->layout ());
       dialog_layout->addLayout (extra,dialog_layout->rowCount (),0,
                                 1,dialog_layout->columnCount ());
     }
 
   fileDialog->setAcceptMode (QFileDialog::AcceptOpen);
   fileDialog->setViewMode (QFileDialog::Detail);
   fileDialog->setFileMode (QFileDialog::ExistingFiles);
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -220,17 +220,17 @@ webinfo::tab_state_changed ()
   _close_others_action->setEnabled (_tab_bar->count () > 1);
   setFocusProxy (_stacked_widget->currentWidget ());
 }
 
 void
 webinfo::current_tab_changed (int index)
 {
   QVariant tab_data = _tab_bar->tabData (index);
-  _text_browser = static_cast<QTextBrowser*> (tab_data.value<void*> ());
+  _text_browser = static_cast<QTextBrowser *> (tab_data.value<void*> ());
 
   _stacked_widget->setCurrentIndex (_stacked_widget->indexOf (_text_browser));
 
   if (_text_browser->font () != _font_web)
     {
       _text_browser->setFont (_font_web);
     }
 
@@ -250,17 +250,17 @@ webinfo::addNewTab (const QString& name)
               SLOT (current_tab_changed (int)));
 
   int ns = _stacked_widget->addWidget (_text_browser);
   _stacked_widget->setCurrentIndex (ns);
 
   int nt = _tab_bar->addTab (name);
   _tab_bar->setCurrentIndex (nt);
   QVariant tab_data;
-  tab_data.setValue (static_cast<void*> (_text_browser));
+  tab_data.setValue (static_cast<void *> (_text_browser));
   _tab_bar->setTabData (nt, tab_data);
 
   connect (_tab_bar, SIGNAL (currentChanged (int)), this,
            SLOT (current_tab_changed (int)));
 
   tab_state_changed ();
 
   if (_text_browser->font () != _font_web)
@@ -271,17 +271,17 @@ webinfo::addNewTab (const QString& name)
 }
 
 void
 webinfo::close_tab (int index)
 {
   if (_tab_bar->count () > 1)
     {
       QVariant tab_data = _tab_bar->tabData (index);
-      QWidget *w = static_cast<QWidget*> (tab_data.value<void*> ());
+      QWidget *w = static_cast<QWidget *> (tab_data.value<void*> ());
       _stacked_widget->removeWidget (w);
       delete w;
 
       _tab_bar->removeTab (index);
     }
 
   tab_state_changed ();
 }
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -7735,28 +7735,28 @@ Encode a double matrix or array @var{x} 
 
   if (args(0).is_complex_type () || args(0).is_sparse_type ())
     error ("base64_encode: encoding complex or sparse data is not supported");
 
   octave_value_list retval;
 
   if (args(0).is_integer_type ())
     {
-#define MAKE_INT_BRANCH(X)                                              \
-      if (args(0).is_ ## X ## _type ())                                 \
-        {                                                               \
-          const X##NDArray in = args(0).  X## _array_value ();          \
-          size_t inlen = in.numel () * sizeof (X## _t) / sizeof (char); \
-          const char* inc = reinterpret_cast<const char*> (in.data ()); \
-          char* out;                                                    \
-          if (octave_base64_encode (inc, inlen, &out))                  \
-            {                                                           \
-              retval(0) = octave_value (out);                           \
-              ::free (out);                                             \
-            }                                                           \
+#define MAKE_INT_BRANCH(X)                                               \
+      if (args(0).is_ ## X ## _type ())                                  \
+        {                                                                \
+          const X##NDArray in = args(0).  X## _array_value ();           \
+          size_t inlen = in.numel () * sizeof (X## _t) / sizeof (char);  \
+          const char* inc = reinterpret_cast<const char *> (in.data ()); \
+          char* out;                                                     \
+          if (octave_base64_encode (inc, inlen, &out))                   \
+            {                                                            \
+              retval(0) = octave_value (out);                            \
+              ::free (out);                                              \
+            }                                                            \
         }
 
       MAKE_INT_BRANCH(int8)
       else MAKE_INT_BRANCH(int16)
       else MAKE_INT_BRANCH(int32)
       else MAKE_INT_BRANCH(int64)
       else MAKE_INT_BRANCH(uint8)
       else MAKE_INT_BRANCH(uint16)
@@ -7769,31 +7769,31 @@ Encode a double matrix or array @var{x} 
         panic_impossible ();
     }
   else if (args(0).is_single_type ())
     {
       const Array<float> in = args(0).float_array_value ();
       size_t inlen;
       inlen = in.numel () * sizeof (float) / sizeof (char);
       const char*  inc;
-      inc = reinterpret_cast<const char*> (in.data ());
+      inc = reinterpret_cast<const char *> (in.data ());
       char* out;
       if (octave_base64_encode (inc, inlen, &out))
         {
           retval(0) = octave_value (out);
           ::free (out);
         }
     }
   else  // double_type
     {
       const Array<double> in = args(0).array_value ();
       size_t inlen;
       inlen = in.numel () * sizeof (double) / sizeof (char);
       const char*  inc;
-      inc = reinterpret_cast<const char*> (in.data ());
+      inc = reinterpret_cast<const char *> (in.data ());
       char* out;
       if (octave_base64_encode (inc, inlen, &out))
         {
           retval(0) = octave_value (out);
           ::free (out);
         }
     }
 
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -223,17 +223,17 @@ namespace octave
           else if (angle == "oblique")
             fc_angle = FC_SLANT_OBLIQUE;
           else
             fc_angle = FC_SLANT_ROMAN;
 
           FcPattern *pat = FcPatternCreate ();
 
           FcPatternAddString (pat, FC_FAMILY,
-                              (reinterpret_cast<const FcChar8*>
+                              (reinterpret_cast<const FcChar8 *>
                                (name == "*" ? "sans" : name.c_str ())));
 
           FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
           FcPatternAddInteger (pat, FC_SLANT, fc_angle);
           FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
 
           if (FcConfigSubstitute (0, pat, FcMatchPattern))
             {
@@ -245,17 +245,17 @@ namespace octave
 
               // FIXME: originally, this test also required that
               // res != FcResultNoMatch.  Is that really needed?
               if (match)
                 {
                   unsigned char *tmp;
 
                   FcPatternGetString (match, FC_FILE, 0, &tmp);
-                  file = reinterpret_cast<char*> (tmp);
+                  file = reinterpret_cast<char *> (tmp);
                 }
               else
                 ::warning ("could not match any font: %s-%s-%s-%g",
                            name.c_str (), weight.c_str (), angle.c_str (),
                            size);
 
               if (match)
                 FcPatternDestroy (match);
@@ -297,17 +297,17 @@ namespace octave
 
       return retval;
     }
 
     void do_font_destroyed (FT_Face face)
     {
       if (face->generic.data)
         {
-          ft_key *pkey = reinterpret_cast<ft_key*> (face->generic.data);
+          ft_key *pkey = reinterpret_cast<ft_key *> (face->generic.data);
 
           cache.erase (*pkey);
           delete pkey;
           face->generic.data = 0;
         }
     }
 
   private:
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2029,32 +2029,32 @@ public:
                    const caseless_str& type,
                    const octave_value_list& args);
 
   property clone (void) const
   { return property (rep->clone ()); }
 
 #if 0
   const string_property& as_string_property (void) const
-  { return *(dynamic_cast<string_property*> (rep)); }
+  { return *(dynamic_cast<string_property *> (rep)); }
 
   const radio_property& as_radio_property (void) const
-  { return *(dynamic_cast<radio_property*> (rep)); }
+  { return *(dynamic_cast<radio_property *> (rep)); }
 
   const color_property& as_color_property (void) const
-  { return *(dynamic_cast<color_property*> (rep)); }
+  { return *(dynamic_cast<color_property *> (rep)); }
 
   const double_property& as_double_property (void) const
-  { return *(dynamic_cast<double_property*> (rep)); }
+  { return *(dynamic_cast<double_property *> (rep)); }
 
   const bool_property& as_bool_property (void) const
-  { return *(dynamic_cast<bool_property*> (rep)); }
+  { return *(dynamic_cast<bool_property *> (rep)); }
 
   const handle_property& as_handle_property (void) const
-  { return *(dynamic_cast<handle_property*> (rep)); }
+  { return *(dynamic_cast<handle_property *> (rep)); }
 #endif
 
 private:
   base_property *rep;
 };
 
 // ---------------------------------------------------------------------
 
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -299,17 +299,17 @@ public:
   gzifstream (int fd,
               std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
   rdbuf () const
-  { return const_cast<gzfilebuf*>(&sb); }
+  { return const_cast<gzfilebuf *>(&sb); }
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
   is_open () { return sb.is_open (); }
 
@@ -386,17 +386,17 @@ public:
   gzofstream (int fd,
               std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
   rdbuf () const
-  { return const_cast<gzfilebuf*>(&sb); }
+  { return const_cast<gzfilebuf *>(&sb); }
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
   is_open () { return sb.is_open (); }
 
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -296,17 +296,17 @@ private:
 
     panic_impossible ();
 #endif
   }
 };
 
 void script_cb (Fl_Widget*, void* data)
 {
-  static_cast<uimenu::properties*> (data)->execute_callback ();
+  static_cast<uimenu::properties *> (data)->execute_callback ();
 }
 
 class fltk_uimenu
 {
 public:
 
   fltk_uimenu (int xx, int yy, int ww, int hh)
     : m_menubar (new Fl_Menu_Bar (xx, yy, ww, hh))
@@ -315,17 +315,17 @@ public:
   int items_to_show (void)
   {
     //returns the number of visible menu items
     int len = m_menubar->size ();
     int n = 0;
     for (int t = 0; t < len; t++)
       {
         const Fl_Menu_Item *m
-          = static_cast<const Fl_Menu_Item*> (&(m_menubar->menu ()[t]));
+          = static_cast<const Fl_Menu_Item *> (&(m_menubar->menu ()[t]));
 
         if (m->label () && m->visible ())
           n++;
       }
 
     return n;
   }
 
@@ -352,17 +352,17 @@ public:
     // int GetIndexByName(...), see:
     // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
     // He agreed via PM that it can be included in octave using GPLv3
     // Kai Habel (14.10.2010)
 
     std::string menupath;
     for (int t = 0; t < m_menubar->size (); t++)
       {
-        Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(m_menubar->menu ()[t]));
+        Fl_Menu_Item *m = const_cast<Fl_Menu_Item *> (&(m_menubar->menu ()[t]));
         if (m->submenu ())
           {
             // item has submenu
             if (! menupath.empty ())
               menupath += "/";
             menupath += m->label ();
 
             if (menupath == findname)
@@ -448,17 +448,17 @@ public:
   }
 
   void update_accelerator (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item =
-          const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
+          const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             std::string acc = uimenup.get_accelerator ();
             if (acc.length () > 0)
               {
                 int key = FL_CTRL + acc[0];
                 item->shortcut (key);
               }
@@ -467,52 +467,52 @@ public:
   }
 
   void update_callback (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item
-          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
+          = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (! uimenup.get_callback ().is_empty ())
-              item->callback (static_cast<Fl_Callback*> (script_cb),
-                              static_cast<void*> (&uimenup));
+              item->callback (static_cast<Fl_Callback *> (script_cb),
+                              static_cast<void *> (&uimenup));
             else
-              item->callback (0, static_cast<void*> (0));
+              item->callback (0, static_cast<void *> (0));
           }
       }
   }
 
   void update_enable (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item
-          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
+          = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_enable ())
               item->activate ();
             else
               item->deactivate ();
           }
       }
   }
 
   void update_foregroundcolor (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item
-          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
+          = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
             uchar r = static_cast<uchar> (std::floor (rgb (0) * 255));
             uchar g = static_cast<uchar> (std::floor (rgb (1) * 255));
             uchar b = static_cast<uchar> (std::floor (rgb (2) * 255));
 
@@ -530,17 +530,17 @@ public:
     if (! fltk_label.empty ())
       {
         int itemflags = 0, idx;
         int curr_idx = find_index_by_name (fltk_label.c_str ());
 
         for (idx = curr_idx - 1; idx >= 0; idx--)
           {
             Fl_Menu_Item* item
-              = const_cast<Fl_Menu_Item*> (&m_menubar->menu () [idx]);
+              = const_cast<Fl_Menu_Item *> (&m_menubar->menu () [idx]);
             itemflags = item->flags;
             if (item->label ())
               break;
           }
 
         if (idx >= 0 && idx < m_menubar->size ())
           {
             if (uimenup.is_separator ())
@@ -555,17 +555,17 @@ public:
   }
 
   void update_visible (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item
-          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
+          = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_visible ())
               item->show ();
             else
               item->hide ();
           }
       }
@@ -779,17 +779,17 @@ public:
   plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp,
                bool internal)
     : Fl_Window (xx, yy, ww, hh + m_menu_h + m_status_h + 2, "octave"),
       m_window_label (), m_fp (xfp), m_uimenu (0), m_canvas (0),
       m_autoscale (0), m_togglegrid (0), m_panzoom (0), m_rotate (0),
       m_help (0), m_status (0), m_resize_dummy (0), m_ax_obj (),
       m_pos_x (0), m_pos_y (0)
   {
-    callback (window_close, static_cast<void*> (this));
+    callback (window_close, static_cast<void *> (this));
 
     // The size of the resize_dummy box also determines the minimum
     // window size.
     m_resize_dummy = new Fl_Box (5 * m_status_h, m_menu_h,
                                  ww - 5 * m_status_h, hh);
 
     // See http://fltk.org/articles.php?L415+I0+T+M1000+P1
     // for how resizable works
@@ -816,33 +816,33 @@ public:
 
     m_status->textcolor (FL_BLACK);
     m_status->color (FL_GRAY);
     m_status->textfont (FL_COURIER);
     m_status->textsize (10);
     m_status->box (FL_ENGRAVED_BOX);
 
     m_autoscale = new Fl_Button (0, toolbar_y, m_status_h, m_status_h, "A");
-    m_autoscale->callback (button_callback, static_cast<void*> (this));
+    m_autoscale->callback (button_callback, static_cast<void *> (this));
     m_autoscale->tooltip ("Autoscale");
 
     m_togglegrid = new Fl_Button (m_status_h, toolbar_y, m_status_h, m_status_h, "G");
-    m_togglegrid->callback (button_callback, static_cast<void*> (this));
+    m_togglegrid->callback (button_callback, static_cast<void *> (this));
     m_togglegrid->tooltip ("Toggle Grid");
 
     m_panzoom = new Fl_Button (2* m_status_h, toolbar_y, m_status_h, m_status_h, "P");
-    m_panzoom->callback (button_callback, static_cast<void*> (this));
+    m_panzoom->callback (button_callback, static_cast<void *> (this));
     m_panzoom->tooltip ("Mouse Pan/Zoom");
 
     m_rotate = new Fl_Button (3 * m_status_h, toolbar_y, m_status_h, m_status_h, "R");
-    m_rotate->callback (button_callback, static_cast<void*> (this));
+    m_rotate->callback (button_callback, static_cast<void *> (this));
     m_rotate->tooltip ("Mouse Rotate");
 
     m_help = new Fl_Button (4 * m_status_h, toolbar_y, m_status_h, m_status_h, "?");
-    m_help->callback (button_callback, static_cast<void*> (this));
+    m_help->callback (button_callback, static_cast<void *> (this));
     m_help->tooltip ("Help");
 
     end ();
 
     set_name ();
     m_uimenu->add_to_menu (m_fp);
     if (m_fp.menubar_is ("none") || ! m_uimenu->items_to_show ())
       hide_menubar ();
@@ -1092,24 +1092,24 @@ private:
 
   int m_pos_x;
   int m_pos_y;
 
   // Window callback.
   static void window_close (Fl_Widget*, void* data)
   {
     octave_value_list args;
-    args(0) = static_cast<plot_window*> (data)->number ();
+    args(0) = static_cast<plot_window *> (data)->number ();
     octave::feval ("close", args);
   }
 
   // Button callbacks.
   static void button_callback (Fl_Widget* ww, void* data)
   {
-    static_cast<plot_window*> (data)->button_press (ww, data);
+    static_cast<plot_window *> (data)->button_press (ww, data);
   }
 
   void button_press (Fl_Widget* widg, void*)
   {
     if (widg == m_autoscale)
       axis_auto ();
     else if (widg == m_togglegrid)
       toggle_grid ();
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -175,17 +175,17 @@ instead.
       rend.finish ();
 
       dim_vector dv (4, Width, Height);
 
       // FIXME: We expect that GLubyte is 1 Byte long.
       // Adapt code if this isn't always true
       assert (sizeof (GLubyte) == 1);
       uint8NDArray img (dv);
-      unsigned char *p = reinterpret_cast<unsigned char*>(img.fortran_vec ());
+      unsigned char *p = reinterpret_cast<unsigned char *>(img.fortran_vec ());
       memcpy (p, buffer, (4 * Width * Height));
 
       Array<octave_idx_type> perm (dim_vector (3, 1));
       perm(0) = 2;
       perm(1) = 1;
       perm(2) = 0;
 
       Array<idx_vector> idx (dim_vector (3, 1));
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -262,17 +262,17 @@ namespace octave
       // Bytef is a typedef for unsigned char
       unsigned char* p;
 
       uchar_array (void) = delete;
 
       uchar_array (const std::string& str)
       {
         p = new Bytef[str.length () +1];
-        std::strcpy (reinterpret_cast<char*> (p), str.c_str ());
+        std::strcpy (reinterpret_cast<char *> (p), str.c_str ());
       }
 
       uchar_array (const uchar_array&) = delete;
 
       uchar_array& operator = (const uchar_array&) = delete;
 
       ~uchar_array (void) { delete[] p; }
     };
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1128,17 +1128,17 @@ convert_to_string (JNIEnv *jni_env, jobj
         error ("unable to convert Java object to string");
 
       octave_set_default_fpucw ();
     }
 
   return retval;
 }
 
-#define TO_JAVA(obj) dynamic_cast<octave_java*> ((obj).internal_rep ())
+#define TO_JAVA(obj) dynamic_cast<octave_java *> ((obj).internal_rep ())
 
 //! Return whether @c jobj shall be automatically converted to an Octave
 //! numeric value.
 //!
 //! If @c jobj is an instance of any of the numeric wrapper classes @c Byte,
 //! @c Integer, @c Long, @c Short, @c Float, or @c Double, then it will be
 //! converted using the @c java.lang.Number.doubleValue() method.
 //!
@@ -1526,17 +1526,17 @@ unbox (JNIEnv *jni_env, const octave_val
       // FIXME: Is there any way to avoid code duplication here without
       // using a macro?
 
 #define UNBOX_PRIMITIVE_ARRAY(METHOD_T, OCTAVE_T, JAVA_T, JAVA_T_CAP) \
   do \
     { \
       const OCTAVE_T ## NDArray v = val.METHOD_T ## array_value (); \
       JAVA_T ## Array jarr = jni_env->New ## JAVA_T_CAP ## Array (v.numel ()); \
-      const JAVA_T *jv = reinterpret_cast<const JAVA_T*> (v.data ()); \
+      const JAVA_T *jv = reinterpret_cast<const JAVA_T *> (v.data ()); \
       jni_env->Set ## JAVA_T_CAP ## ArrayRegion (jarr, 0, v.numel (), jv); \
       jobj = reinterpret_cast<jobject> (jarr); \
       jcls = jni_env->GetObjectClass (jobj); \
     } \
   while (0)
 
       // Note that we do NOT handle char here because they are unboxed
       // into a String[], not into a char array
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -679,17 +679,17 @@ find_fcn_by_line (octave_user_code *main
             next_fcn = dbg_subfcn;
         }
     }
 
   // The breakpoint is either in the subfunction found above,
   // or in the main function, which we check now.
   if (main_fcn->is_user_function ())
     {
-      int e = dynamic_cast<octave_user_function*> (main_fcn)->ending_line ();
+      int e = dynamic_cast<octave_user_function *> (main_fcn)->ending_line ();
       if (e >= lineno && e < earliest_end)
         retval = main_fcn;
 
       if (! retval)
         retval = next_fcn;
     }
   else  // main_fcn is a script.
     {
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -202,17 +202,17 @@ namespace octave
     }
 
     void
     base_tm::init (void *p)
     {
       if (! p)
         return;
 
-      struct ::tm *t = static_cast<struct ::tm*> (p);
+      struct ::tm *t = static_cast<struct ::tm *> (p);
 
       m_sec = t->tm_sec;
       m_min = t->tm_min;
       m_hour = t->tm_hour;
       m_mday = t->tm_mday;
       m_mon = t->tm_mon;
       m_year = t->tm_year;
       m_wday = t->tm_wday;
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -91,17 +91,17 @@ strsave (const char *s)
 void
 octave_putenv (const std::string& name, const std::string& value)
 {
   int new_len = name.length () + value.length () + 2;
 
   // FIXME: This leaks memory, but so would a call to setenv.
   // Short of extreme measures to track memory, altering the environment
   // always leaks memory, but the saving grace is that the leaks are small.
-  char *new_item = static_cast<char*> (std::malloc (new_len));
+  char *new_item = static_cast<char *> (std::malloc (new_len));
 
   sprintf (new_item, "%s=%s", name.c_str (), value.c_str ());
 
   // As far as I can see there's no way to distinguish between the
   // various errors; putenv doesn't have errno values.
 
   if (octave_putenv_wrapper (new_item) < 0)
     (*current_liboctave_error_handler) ("putenv (%s) failed", new_item);
diff --git a/liboctave/util/oct-base64.cc b/liboctave/util/oct-base64.cc
--- a/liboctave/util/oct-base64.cc
+++ b/liboctave/util/oct-base64.cc
@@ -75,15 +75,15 @@ octave_base64_decode (const std::string&
       ::free (out);
       (*current_liboctave_error_handler)
         ("base64_decode: incorrect input size");
     }
   else
     {
       octave_idx_type len = (outlen * sizeof (char)) / sizeof (double);
       retval.resize (dim_vector (1, len));
-      double *dout = reinterpret_cast<double*> (out);
+      double *dout = reinterpret_cast<double *> (out);
       std::copy (dout, dout + len, retval.fortran_vec ());
       ::free (out);
     }
 
   return retval;
 }
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -216,26 +216,26 @@ namespace octave
     return file_list;
   }
 
 #if defined (HAVE_CURL)
 
   static int
   write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
   {
-    std::ostream& stream = *(static_cast<std::ostream*> (streamp));
-    stream.write (static_cast<const char*> (buffer), size*nmemb);
+    std::ostream& stream = *(static_cast<std::ostream *> (streamp));
+    stream.write (static_cast<const char *> (buffer), size*nmemb);
     return (stream.fail () ? 0 : size * nmemb);
   }
 
   static int
   read_data (void *buffer, size_t size, size_t nmemb, void *streamp)
   {
-    std::istream& stream = *(static_cast<std::istream*> (streamp));
-    stream.read (static_cast<char*> (buffer), size*nmemb);
+    std::istream& stream = *(static_cast<std::istream *> (streamp));
+    stream.read (static_cast<char *> (buffer), size*nmemb);
     if (stream.eof ())
       return stream.gcount ();
     else
       return (stream.fail () ? 0 : size * nmemb);
   }
 
   static size_t
   throw_away (void *, size_t size, size_t nmemb, void *)
@@ -363,25 +363,25 @@ namespace octave
     {
       return std::string (curl_easy_strerror (errnum));
     }
 
     std::ostream& set_ostream (std::ostream& os)
     {
       std::ostream& retval = *curr_ostream;
       curr_ostream = &os;
-      SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
+      SETOPTR (CURLOPT_WRITEDATA, static_cast<void *> (curr_ostream));
       return retval;
     }
 
     std::istream& set_istream (std::istream& is)
     {
       std::istream& retval = *curr_istream;
       curr_istream = &is;
-      SETOPTR (CURLOPT_READDATA, static_cast<void*> (curr_istream));
+      SETOPTR (CURLOPT_READDATA, static_cast<void *> (curr_istream));
       return retval;
     }
 
     void ascii (void)
     {
       ascii_mode = true;
       SETOPT (CURLOPT_TRANSFERTEXT, 1);
     }
@@ -484,28 +484,28 @@ namespace octave
     }
 
     string_vector list (void)
     {
       string_vector retval;
 
       std::ostringstream buf;
       url = "ftp://" + host_or_url + "/";
-      SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
+      SETOPTR (CURLOPT_WRITEDATA, static_cast<void *> (&buf));
       SETOPTR (CURLOPT_URL, url.c_str ());
       SETOPTR (CURLOPT_DIRLISTONLY, 1);
       SETOPTR (CURLOPT_NOBODY, 0);
 
       perform ();
       if (! good ())
         return retval;
 
       SETOPTR (CURLOPT_NOBODY, 1);
       url = "ftp://" + host_or_url;
-      SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
+      SETOPTR (CURLOPT_WRITEDATA, static_cast<void *> (curr_ostream));
       SETOPTR (CURLOPT_DIRLISTONLY, 0);
       SETOPTR (CURLOPT_URL, url.c_str ());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
@@ -686,23 +686,23 @@ namespace octave
         userpwd += ":" + passwd;
       if (! userpwd.empty ())
         SETOPT (CURLOPT_USERPWD, userpwd.c_str ());
 
       // Define our callback to get called when there's data to be written.
       SETOPT (CURLOPT_WRITEFUNCTION, write_data);
 
       // Set a pointer to our struct to pass to the callback.
-      SETOPT (CURLOPT_WRITEDATA, static_cast<void*> (&os));
+      SETOPT (CURLOPT_WRITEDATA, static_cast<void *> (&os));
 
       // Define our callback to get called when there's data to be read
       SETOPT (CURLOPT_READFUNCTION, read_data);
 
       // Set a pointer to our struct to pass to the callback.
-      SETOPT (CURLOPT_READDATA, static_cast<void*> (&is));
+      SETOPT (CURLOPT_READDATA, static_cast<void *> (&is));
 
       // Follow redirects.
       SETOPT (CURLOPT_FOLLOWLOCATION, true);
 
       // Don't use EPSV since connecting to sites that don't support it
       // will hang for some time (3 minutes?) before moving on to try PASV
       // instead.
       SETOPT (CURLOPT_FTP_USE_EPSV, false);
