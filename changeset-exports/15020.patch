# HG changeset patch
# User Rik <rik@octave.org>
# Date 1343319947 25200
#      Thu Jul 26 09:25:47 2012 -0700
# Node ID 560317fd5977cd1e473a7f053bc9ee3e3502ab39
# Parent  ae3670d4df292e2bbbc245a3c5d5224bf0eef37b
maint: Cuddle open bracket used for indexing C++ arrays in source code.

* Array-util.cc, Array.cc, DASPK.cc, DASRT.cc, DASSL.cc, LSODE.cc,
MatrixType.cc, Sparse.cc, Sparse.h, dim-vector.h, eigs-base.cc, idx-vector.cc,
oct-alloc.cc, oct-locbuf.cc, oct-locbuf.h, oct-mem.h, oct-sort.cc, oct-time.cc,
sparse-base-chol.cc, sparse-dmsolve.cc, ccolamd.cc, colamd.cc, spparms.cc,
symbfact.cc, symrcm.cc, help.cc, ls-mat5.cc, pt-idx.cc, utils.cc, variables.cc,
zfstream.cc: Cuddle open bracket used for indexing C++ arrays in source code.

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -421,17 +421,17 @@ get_ra_idx (octave_idx_type idx, const d
   return retval;
 }
 
 dim_vector
 zero_dims_inquire (const Array<idx_vector>& ia, const dim_vector& rhdv)
 {
   int ial = ia.length (), rhdvl = rhdv.length ();
   dim_vector rdv = dim_vector::alloc (ial);
-  bool *scalar = new bool[ial], *colon = new bool[ial];
+  bool *scalar = new bool [ial], *colon = new bool [ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
       // FIXME -- should we check for length() instead?
       scalar[i] = ia(i).is_scalar ();
       colon[i] = ia(i).is_colon ();
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -644,17 +644,17 @@ public:
     : cext (0), sext (0), dext (0), n (0)
     {
       int l = ndv.length ();
       assert (odv.length () == l);
       octave_idx_type ld = 1;
       int i = 0;
       for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
       n = l - i;
-      cext = new octave_idx_type[3*n];
+      cext = new octave_idx_type [3*n];
       // Trick to avoid three allocations
       sext = cext + n;
       dext = sext + n;
 
       octave_idx_type sld = ld, dld = ld;
       for (int j = 0; j < n; j++)
         {
           cext[j] = std::min (ndv(i+j), odv(i+j));
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -140,17 +140,17 @@ ddaspk_j (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASPK::do_integrate (double tout)
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -116,17 +116,17 @@ ddasrt_j (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = (*user_jsub) (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -114,17 +114,17 @@ ddassl_j (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASSL::do_integrate (double tout)
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -98,17 +98,17 @@ lsode_j (const octave_idx_type& neq, con
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_jac = (*user_jac) (*tmp_x, time);
 
   for (octave_idx_type j = 0; j < neq; j++)
     for (octave_idx_type i = 0; i < neq; i++)
-      pd [nrowpd * j + i] = tmp_jac (i, j);
+      pd[nrowpd * j + i] = tmp_jac (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 LSODE::do_integrate (double tout)
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -46,17 +46,17 @@ MatrixType::MatrixType (void)
 
 MatrixType::MatrixType (const MatrixType &a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
 {
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
 
 template<class T>
 MatrixType::matrix_type
 matrix_real_probe (const MArray<T>& a)
@@ -250,22 +250,22 @@ MatrixType::MatrixType (const SparseMatr
           for (octave_idx_type j = 0; j < i; j++)
             found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
               if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
-                  ((a.cidx (j+1) == a.cidx (j) + 1) && found [a.ridx (j)]))
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx (j)] = true;
+              found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -343,17 +343,17 @@ MatrixType::MatrixType (const SparseMatr
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
-          perm = new octave_idx_type[ncols];
+          perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
             perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
@@ -382,28 +382,28 @@ MatrixType::MatrixType (const SparseMatr
                     if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
           else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
-              perm = new octave_idx_type[nrows];
+              perm = new octave_idx_type [nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
                   perm[i] = -1;
                   tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-                    perm [a.ridx (i)] = j;
+                    perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -571,22 +571,22 @@ MatrixType::MatrixType (const SparseComp
           for (octave_idx_type j = 0; j < i; j++)
             found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
               if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
-                  ((a.cidx (j+1) == a.cidx (j) + 1) && found [a.ridx (j)]))
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx (j)] = true;
+              found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -664,17 +664,17 @@ MatrixType::MatrixType (const SparseComp
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
-          perm = new octave_idx_type[ncols];
+          perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
             perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
@@ -703,28 +703,28 @@ MatrixType::MatrixType (const SparseComp
                     if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
           else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
-              perm = new octave_idx_type[nrows];
+              perm = new octave_idx_type [nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
                   perm[i] = -1;
                   tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-                    perm [a.ridx (i)] = j;
+                    perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -871,17 +871,17 @@ MatrixType::MatrixType (const matrix_typ
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
       np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = p[i];
     }
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
@@ -984,17 +984,17 @@ MatrixType::type (const SparseMatrix &a)
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1017,17 +1017,17 @@ MatrixType::type (const SparseComplexMat
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1044,17 +1044,17 @@ MatrixType::type (const Matrix &a)
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1071,17 +1071,17 @@ MatrixType::type (const ComplexMatrix &a
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1098,17 +1098,17 @@ MatrixType::type (const FloatMatrix &a)
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1125,17 +1125,17 @@ MatrixType::type (const FloatComplexMatr
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type[nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 void
@@ -1220,17 +1220,17 @@ MatrixType::mark_as_unsymmetric (void)
            typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
 MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
 {
   nperm = np;
-  perm = new octave_idx_type[nperm];
+  perm = new octave_idx_type [nperm];
   for (octave_idx_type i = 0; i < nperm; i++)
     perm[i] = p[i];
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     typ = MatrixType::Permuted_Diagonal;
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     typ = MatrixType::Permuted_Upper;
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -171,23 +171,23 @@ Sparse<T>::SparseRep::change_length (oct
   // We shall skip reallocation if we have less than 1/frac extra elements to
   // discard.
   static const int frac = 5;
   if (nz > nzmx || nz < nzmx - nzmx/frac)
     {
       // Reallocate.
       octave_idx_type min_nzmx = std::min (nz, nzmx);
 
-      octave_idx_type * new_ridx = new octave_idx_type[nz];
+      octave_idx_type * new_ridx = new octave_idx_type [nz];
       copy_or_memcpy (min_nzmx, r, new_ridx);
 
       delete [] r;
       r = new_ridx;
 
-      T * new_data = new T[nz];
+      T * new_data = new T [nz];
       copy_or_memcpy (min_nzmx, d, new_data);
 
       delete [] d;
       d = new_data;
 
       nzmx = nz;
     }
 }
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -67,32 +67,32 @@ protected:
     octave_idx_type *r;
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     octave_refcount<int> count;
 
     SparseRep (void)
-      : d (0), r (0), c (new octave_idx_type[1]), nzmx (0), nrows (0),
+      : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
       ncols (0), count (1)
       {
         c[0] = 0;
       }
 
     SparseRep (octave_idx_type n)
       : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       {
         for (octave_idx_type i = 0; i < n + 1; i++)
           c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
-      : d (new T[nz]), r (new octave_idx_type[nz]),
+      : d (new T [nz]), r (new octave_idx_type [nz]),
       c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
       ncols (nc), count (1)
       {
         c[nc] = nz;
         for (octave_idx_type i = 0; i < nc; i++)
           c[i] = 0;
       }
 
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -61,31 +61,31 @@ private:
   octave_idx_type& ndims (void) const { return rep[-1]; }
 
   octave_idx_type& count (void) const { return rep[-2]; }
 
   // Construct a new rep with count = 1 and ndims given.
 
   static octave_idx_type *newrep (int ndims)
   {
-    octave_idx_type *r = new octave_idx_type[ndims + 2];
+    octave_idx_type *r = new octave_idx_type [ndims + 2];
 
     *r++ = 1;
     *r++ = ndims;
 
     return r;
   }
 
   // Clone this->rep.
 
   octave_idx_type *clonerep (void)
   {
     int l = ndims ();
 
-    octave_idx_type *r = new octave_idx_type[l + 2];
+    octave_idx_type *r = new octave_idx_type [l + 2];
 
     *r++ = 1;
     *r++ = l;
 
     for (int i = 0; i < l; i++)
       r[i] = rep[i];
 
     return r;
@@ -95,17 +95,17 @@ private:
 
   octave_idx_type *resizerep (int n, octave_idx_type fill_value)
   {
     int l = ndims ();
 
     if (n < 2)
       n = 2;
 
-    octave_idx_type *r = new octave_idx_type[n + 2];
+    octave_idx_type *r = new octave_idx_type [n + 2];
 
     *r++ = 1;
     *r++ = n;
 
     if (l > n)
       l = n;
 
     int j;
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -1964,17 +1964,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
@@ -2350,17 +2350,17 @@ EigsRealNonSymmetricMatrixShift (const M
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
@@ -2662,17 +2662,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -320,17 +320,17 @@ idx_vector::idx_scalar_rep::as_array (vo
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_vector_rep);
 
 template <class T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
   : data (0), len (nda.numel ()), ext (0), aowner (0), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
       if (err)
       {
         delete [] data;
         gripe_invalid_index ();
@@ -380,17 +380,17 @@ idx_vector::idx_vector_rep::idx_vector_r
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[1];
+      octave_idx_type *d = new octave_idx_type [1];
       d[0] = 0;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<bool>& bnda,
                                             octave_idx_type nnz)
@@ -402,17 +402,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
     orig_dims = ((dv.length () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type ntot = bnda.length ();
 
       octave_idx_type k = 0;
       for (octave_idx_type i = 0; i < ntot; i++)
         if (bnda.xelem (i))
           d[k++] = i;
 
@@ -430,17 +430,17 @@ idx_vector::idx_vector_rep::idx_vector_r
 
   dim_vector dv = bnda.dims ();
 
   orig_dims = ((dv.length () == 2 && dv(0) == 1)
                ? dim_vector (1, len) : orig_dims = dim_vector (len, 1));
 
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type nnz = bnda.nnz ();
 
       octave_idx_type k = 0;
       // FIXME: I hope this is OK, i.e. the element iterated this way are correctly ordered.
       for (octave_idx_type i = 0; i < nnz; i++)
         {
           if (bnda.data (i))
@@ -484,17 +484,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
 
   // This is wrapped in auto_ptr so that we don't leak on out-of-memory.
   std::auto_ptr<idx_vector_rep> new_rep (
     new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
 
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       std::copy (data, data + len, new_data);
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, len);
 
       if (uniq)
@@ -519,31 +519,31 @@ idx_vector::idx_vector_rep::sort_uniq_cl
         new_len += has[i];
 
       new_rep->len = new_len;
       if (new_rep->orig_dims.length () == 2 && new_rep->orig_dims(0) == 1)
         new_rep->orig_dims = dim_vector (1, new_len);
       else
         new_rep->orig_dims = dim_vector (new_len, 1);
 
-      octave_idx_type *new_data = new octave_idx_type[new_len];
+      octave_idx_type *new_data = new octave_idx_type [new_len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (has[i])
           new_data[j++] = i;
     }
   else
     {
       // Use two-pass bucket sort.
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, cnt, ext, 0);
       for (octave_idx_type i = 0; i < len; i++)
         cnt[data[i]]++;
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         {
           for (octave_idx_type k = 0; k < cnt[i]; k++)
             new_data[j++] = i;
         }
     }
@@ -561,17 +561,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
       for (octave_idx_type i = 0; i < len; i++)
         idx_data[i] = i;
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
       std::copy (data, data + len, new_data);
 
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, idx_data, len);
     }
   else
@@ -580,17 +580,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, cnt, ext, 0);
 
       for (octave_idx_type i = 0; i < len; i++)
         cnt[data[i]]++;
 
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, k = 0; i < ext; i++)
         {
           octave_idx_type j = cnt[i];
           cnt[i] = k;
           k += j;
         }
@@ -649,17 +649,17 @@ idx_vector::idx_vector_rep::as_array (vo
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_mask_rep);
 
 idx_vector::idx_mask_rep::idx_mask_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), lsti (-1), lste (-1),
     aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
-      bool *d = new bool[1];
+      bool *d = new bool [1];
       d[0] = true;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (const Array<bool>& bnda,
                                         octave_idx_type nnz)
@@ -1205,17 +1205,17 @@ idx_vector::inverse_permutation (octave_
 idx_vector
 idx_vector::unmask (void) const
 {
   if (idx_class () == class_mask)
     {
       idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
       const bool *data = r->get_data ();
       octave_idx_type ext = r->extent (0), len = r->length (0);
-      octave_idx_type *idata = new octave_idx_type[len];
+      octave_idx_type *idata = new octave_idx_type [len];
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (data[i])
           idata[j++] = i;
 
       ext = len > 0 ? idata[len - 1] + 1 : 0;
 
       return new idx_vector_rep (idata, len, ext, r->orig_dimensions (),
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <new>
 
 #include "oct-alloc.h"
 
 void *
 octave_allocator::alloc (size_t size)
 {
   if (size != item_size)
-    return ::new char[size];
+    return ::new char [size];
 
   if (! head)
     {
       if (! grow ())
         return 0;
     }
 
   link *tmp = head;
diff --git a/liboctave/oct-locbuf.cc b/liboctave/oct-locbuf.cc
--- a/liboctave/oct-locbuf.cc
+++ b/liboctave/oct-locbuf.cc
@@ -69,21 +69,21 @@ octave_chunk_buffer::octave_chunk_buffer
     {
       // Big buffers (> 1/8 chunk) will be allocated as stand-alone and
       // won't disrupt the chain.
 
       if (size > chunk_size >> 3)
         {
           // Use new [] to get std::bad_alloc if out of memory.
 
-          dat = new char[size];
+          dat = new char [size];
           return;
         }
 
-      dat = new char[chunk_size];
+      dat = new char [chunk_size];
       chunk = top = dat;
       left = chunk_size;
     }
 
   // Now allocate memory from the chunk and update state.
 
   cnk = chunk;
   dat = top;
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 template <class T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : data (0)
     {
       if (size)
-        data = new T[size];
+        data = new T [size];
     }
   ~octave_local_buffer (void) { delete [] data; }
   operator T *() const { return data; }
 
 private:
   T *data;
 
   // No copying!
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -123,26 +123,26 @@ DEFINE_POD_FILL (octave_int<T>)
 // Uninitialized allocation. Will not initialize memory for complex and octave_int.
 // Memory allocated by octave_new should be freed by octave_delete.
 template <class T>
 inline T *no_ctor_new (size_t n)
 {
   // Some systems let us allocate > 2GB memory even though size_t, which is either
   // buggy or completely cuckoo, so let's check here to stay safe.
   safe_size_comp (n, sizeof (T));
-  return new T[n];
+  return new T [n];
 }
 template <class T>
 inline void no_ctor_delete (T *ptr)
 { delete [] ptr; }
 
 #define DEFINE_POD_NEW_DELETE(T) \
 template <> \
 inline T *no_ctor_new<T > (size_t n) \
-{ return reinterpret_cast<T *> (new char[safe_size_comp (n, sizeof (T))]); } \
+{ return reinterpret_cast<T *> (new char [safe_size_comp (n, sizeof (T))]); } \
 template <> \
 inline void no_ctor_delete<T > (T *ptr) \
 { delete [] reinterpret_cast<char *> (ptr); }
 
 DEFINE_POD_NEW_DELETE (Complex)
 DEFINE_POD_NEW_DELETE (FloatComplex)
 
 DEFINE_POD_NEW_DELETE (octave_int8)
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -537,17 +537,17 @@ octave_sort<T>::MergeState::getmem (octa
     return;
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia; // Must do this or fool possible next getmemi.
-  a = new T[need];
+  a = new T [need];
   alloced = need;
 
 }
 
 template <class T>
 void
 octave_sort<T>::MergeState::getmemi (octave_idx_type need)
 {
@@ -556,18 +556,18 @@ octave_sort<T>::MergeState::getmemi (oct
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia;
 
-  a = new T[need];
-  ia = new octave_idx_type[need];
+  a = new T [need];
+  ia = new octave_idx_type [need];
   alloced = need;
 }
 
 /* Merge the na elements starting at pa with the nb elements starting at pb
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na <= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -170,17 +170,17 @@ octave_base_tm::strftime (const std::str
 
       char *buf = 0;
       size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
       size_t chars_written = 0;
 
       while (chars_written == 0)
         {
           delete [] buf;
-          buf = new char[bufsize];
+          buf = new char [bufsize];
           buf[0] = '\0';
 
           chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
 
           bufsize *= 2;
         }
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -52,17 +52,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   Si = static_cast<octave_idx_type *>(S->i);
   Sx = static_cast<chol_elt *>(S->x);
   pdest = 0;
   ncol = S->ncol;
 
   for (k = 0; k < ncol; k++)
     {
       p = Sp[k];
-      pend = Sp [k+1];
+      pend = Sp[k+1];
       Sp[k] = pdest;
       for (; p < pend; p++)
         {
           sik = Sx[p];
           if (CHOLMOD_IS_NONZERO (sik))
             {
               if (p != pdest)
                 {
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -54,17 +54,17 @@ dmsolve_extract (const MSparse<T> &A, co
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
           for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
-              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
                   B.xdata (nz) = A.data (p);
                   B.xridx (nz++) = r - rst ;
                 }
             }
         }
       B.xcidx (cend - cst) = nz ;
@@ -77,26 +77,26 @@ dmsolve_extract (const MSparse<T> &A, co
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
           for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
-              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
-                  X [r-rst] = A.data (p);
+                  X[r-rst] = A.data (p);
                   B.xridx (nz++) = r - rst ;
                 }
             }
           sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
           for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
-            B.xdata (p) = X [B.xridx (p)];
+            B.xdata (p) = X[B.xridx (p)];
         }
       B.xcidx (cend - cst) = nz ;
     }
 
   return B;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
@@ -165,17 +165,17 @@ dmsolve_insert (MArray<T> &a, const MArr
   octave_idx_type nc = b.cols ();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          ax [Q [r + i] + aoff] = bx [i + boff];
+          ax[Q[r + i] + aoff] = bx[i + boff];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MArray<double> &a, const MArray<double> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
@@ -202,17 +202,17 @@ dmsolve_insert (MSparse<T> &a, const MSp
   // First count the number of elements in the final array
   octave_idx_type nel = a.xcidx (c) + b.nnz ();
 
   if (c + b_cols < nc)
     nel += a.xcidx (nc) - a.xcidx (c + b_cols);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     for (octave_idx_type j = a.xcidx (i); j < a.xcidx (i+1); j++)
-      if (Qinv [a.xridx (j)] < r || Qinv [a.xridx (j)] >= r + b_rows)
+      if (Qinv[a.xridx (j)] < r || Qinv[a.xridx (j)] >= r + b_rows)
         nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
   octave_idx_type *ri = a.xridx ();
 
@@ -226,33 +226,33 @@ dmsolve_insert (MSparse<T> &a, const MSp
 
   octave_idx_type ii = a.xcidx (c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
       octave_quit ();
 
       for (octave_idx_type j = tmp.xcidx (i); j < tmp.xcidx (i+1); j++)
-        if (Qinv [tmp.xridx (j)] < r ||  Qinv [tmp.xridx (j)] >= r + b_rows)
+        if (Qinv[tmp.xridx (j)] < r ||  Qinv[tmp.xridx (j)] >= r + b_rows)
           {
-            X [tmp.xridx (j)] = tmp.xdata (j);
+            X[tmp.xridx (j)] = tmp.xdata (j);
             a.xridx (ii++) = tmp.xridx (j);
           }
 
       octave_quit ();
 
       for (octave_idx_type j = b.cidx (i-c); j < b.cidx (i-c+1); j++)
         {
-          X [Q [r + b.ridx (j)]] = b.data (j);
-          a.xridx (ii++) = Q [r + b.ridx (j)];
+          X[Q[r + b.ridx (j)]] = b.data (j);
+          a.xridx (ii++) = Q[r + b.ridx (j)];
         }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
-        a.xdata (p) = X [a.xridx (p)];
+        a.xdata (p) = X[a.xridx (p)];
       a.xcidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
       for (octave_idx_type j = tmp.xcidx (i); j < tmp.cidx (i+1); j++)
         {
           a.xdata (ii) = tmp.xdata (j);
@@ -327,17 +327,17 @@ dmsolve_permute (MSparse<RT> &a, const M
           octave_idx_type r = p[b.ridx (i)];
           X[r] = b.data (i);
           a.xridx (nz++) = p[b.ridx (i)];
         }
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
         {
           octave_quit ();
-          a.xdata (i) = X [a.xridx (i)];
+          a.xdata (i) = X[a.xridx (i)];
         }
       a.xcidx (j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MSparse<double> &a, const MSparse<double>& b,
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -159,56 +159,56 @@ colamd, symamd, and other related orderi
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
+            knobs[CCOLAMD_LU] = (User_knobs(0) != 0);
           if (nel_User_knobs > 1)
-            knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
+            knobs[CCOLAMD_DENSE_ROW] = User_knobs(1);
           if (nel_User_knobs > 2)
-            knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
+            knobs[CCOLAMD_DENSE_COL] = User_knobs(2);
           if (nel_User_knobs > 3)
-            knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
+            knobs[CCOLAMD_AGGRESSIVE] = (User_knobs(3) != 0);
           if (nel_User_knobs > 4)
-            spumoni = (User_knobs (4) != 0);
+            spumoni = (User_knobs(4) != 0);
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
                             << ":\nknobs(1): " << User_knobs (0) << ", order for ";
-              if ( knobs [CCOLAMD_LU] != 0)
+              if (knobs[CCOLAMD_LU] != 0)
                 octave_stdout << "lu (A)\n";
               else
                 octave_stdout << "chol (A'*A)\n";
 
-              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
+              if (knobs[CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", rows with > max (16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", no dense rows removed\n";
 
-              if (knobs [CCOLAMD_DENSE_COL] >= 0)
+              if (knobs[CCOLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", cols with > max (16,"
-                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                              << knobs[CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", no dense columns removed\n";
 
-              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+              if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
               else
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: no";
 
               octave_stdout << "knobs(5): " << User_knobs (4)
                             << ", statistics and knobs printed\n";
@@ -254,22 +254,22 @@ colamd, symamd, and other related orderi
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       // Allocate workspace for ccolamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx [i];
+        p[i] = cidx[i];
 
       octave_idx_type Alen = CCOLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx [i];
+        A[i] = ridx[i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value ();
           octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
@@ -310,17 +310,17 @@ colamd, symamd, and other related orderi
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
@@ -414,38 +414,38 @@ colamd, symamd, and other related orderi
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
+            knobs[CCOLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
+            knobs[CCOLAMD_AGGRESSIVE] = User_knobs(1);
           if (nel_User_knobs > 1)
-            spumoni = static_cast<int> (User_knobs (2));
+            spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
-              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
+              if (knobs[CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows/cols with > max (16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", no dense rows/cols removed\n";
 
-              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+              if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
               else
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: no";
 
 
               octave_stdout << "knobs(3): " << User_knobs (2)
@@ -538,17 +538,17 @@ colamd, symamd, and other related orderi
 
       retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
@@ -557,17 +557,17 @@ colamd, symamd, and other related orderi
       if (spumoni > 0)
         CSYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -58,38 +58,38 @@ static void
 symetree (const octave_idx_type *ridx, const octave_idx_type *cidx,
           octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Flag, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Pinv, (P ? n : 0));
   if (P)
     // If P is present then compute Pinv, the inverse of P
     for (octave_idx_type k = 0 ; k < n ; k++)
-      Pinv [P [k]] = k ;
+      Pinv[P[k]] = k ;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
-      Parent [k] = n ;                // parent of k is not yet known
-      Flag [k] = k ;                  // mark node k as visited
-      octave_idx_type kk = (P) ? (P [k]) : (k) ;  // kth original, or permuted, column
-      octave_idx_type p2 = cidx [kk+1] ;
-      for (octave_idx_type p = cidx [kk] ; p < p2 ; p++)
+      Parent[k] = n ;                // parent of k is not yet known
+      Flag[k] = k ;                  // mark node k as visited
+      octave_idx_type kk = (P) ? (P[k]) : (k) ;  // kth original, or permuted, column
+      octave_idx_type p2 = cidx[kk+1] ;
+      for (octave_idx_type p = cidx[kk] ; p < p2 ; p++)
         {
           // A (i,k) is nonzero (original or permuted A)
-          octave_idx_type i = (Pinv) ? (Pinv [ridx [p]]) : (ridx [p]) ;
+          octave_idx_type i = (Pinv) ? (Pinv[ridx[p]]) : (ridx[p]) ;
           if (i < k)
             {
               // follow path from i to root of etree, stop at flagged node
-              for ( ; Flag [i] != k ; i = Parent [i])
+              for ( ; Flag[i] != k ; i = Parent[i])
                 {
                   // find parent of i if not yet determined
-                  if (Parent [i] == n)
-                    Parent [i] = k ;
-                  Flag [i] = k ;        // mark i as visited
+                  if (Parent[i] == n)
+                    Parent[i] = k ;
+                  Flag[i] = k ;        // mark i as visited
                 }
             }
         }
     }
 }
 
 // The elimination tree post-ordering code below is taken from SuperLU
 static inline octave_idx_type
@@ -294,42 +294,42 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [COLAMD_DENSE_ROW] = User_knobs (0);
+            knobs[COLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 1)
-            knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
+            knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
           if (nel_User_knobs > 2)
-            spumoni = static_cast<int> (User_knobs (2));
+            spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
-              if (knobs [COLAMD_DENSE_ROW] >= 0)
+              if (knobs[COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows with > max (16,"
-                              << knobs [COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
-              if (knobs [COLAMD_DENSE_COL] >= 0)
+              if (knobs[COLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", cols with > max (16,"
-                              << knobs [COLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                              << knobs[COLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
               octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
@@ -375,22 +375,22 @@ Ng, Oak Ridge National Laboratory.  (see
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       // Allocate workspace for colamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx [i];
+        p[i] = cidx[i];
 
       octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx [i];
+        A[i] = ridx[i];
 
       // Order the columns (destroys A)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
       if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
         {
           COLAMD_NAME (_report) (stats) ;
           error ("colamd: internal error!");
           return retval;
@@ -410,30 +410,30 @@ Ng, Oak Ridge National Laboratory.  (see
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p[colbeg [i]] + 1;
+        out_perm(i) = p[colbeg[i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (COLAMD_INFO1) ++ ;
           out_stats (COLAMD_INFO2) ++ ;
         }
@@ -529,25 +529,25 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
+            knobs[COLAMD_DENSE_ROW] = User_knobs(COLAMD_DENSE_ROW);
           if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs (1));
         }
 
       // print knob settings if spumoni is set
       if (spumoni > 0)
         octave_stdout << "symamd: dense row/col fraction: "
-                      << knobs [COLAMD_DENSE_ROW] << std::endl;
+                      << knobs[COLAMD_DENSE_ROW] << std::endl;
 
       octave_idx_type n_row, n_col;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
         {
@@ -603,30 +603,30 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm[post [i]] + 1;
+        out_perm(i) = perm[post[i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (COLAMD_INFO1) ++ ;
           out_stats (COLAMD_INFO2) ++ ;
         }
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -121,17 +121,17 @@ running time.\n\
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string str = args(0).string_value ();
           int len = str.length ();
           for (int i = 0; i < len; i++)
-            str [i] = tolower (str [i]);
+            str[i] = tolower (str[i]);
 
           if (str == "defaults")
             octave_sparse_params::defaults ();
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -265,28 +265,28 @@ factorization as determined by @var{typ}
             {
               A1 = A;
               A2 = F;
             }
 
           // count the total number of entries in L
           octave_idx_type lnz = 0 ;
           for (octave_idx_type j = 0 ; j < n ; j++)
-            lnz += ColCount [j] ;
+            lnz += ColCount[j];
 
 
           // allocate the output matrix L (pattern-only)
           SparseBoolMatrix L (n, n, lnz);
 
           // initialize column pointers
           lnz = 0;
           for (octave_idx_type j = 0 ; j < n ; j++)
             {
               L.xcidx(j) = lnz;
-              lnz += ColCount [j];
+              lnz += ColCount[j];
             }
           L.xcidx(n) = lnz;
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
             W[j] = L.xcidx (j);
@@ -297,21 +297,21 @@ factorization as determined by @var{typ}
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
           for (octave_idx_type k = 0 ; k < n ; k++)
             {
               // get the kth row of L and store in the columns of L
               CHOLMOD_NAME (row_subtree) (A1, A2, k, Parent, R, cm) ;
-              for (octave_idx_type p = 0 ; p < Rp [1] ; p++)
-                L.xridx (W [Ri [p]]++) = k ;
+              for (octave_idx_type p = 0 ; p < Rp[1] ; p++)
+                L.xridx (W[Ri[p]]++) = k ;
 
               // add the diagonal entry
-              L.xridx (W [k]++) = k ;
+              L.xridx (W[k]++) = k ;
             }
 
           // free workspace
           cholmod_free_sparse (&R, cm) ;
 
 
           // transpose L to get R, or leave as is
           if (nargin < 3)
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -400,17 +400,17 @@ transpose (octave_idx_type N, const octa
     }
   cidx2[N] = nz;
   w[N] = nz;
 
   for (octave_idx_type j = 0; j < N; j++)
     for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
       {
         OCTAVE_QUIT;
-        octave_idx_type q = w [ridx[k]]++;
+        octave_idx_type q = w[ridx[k]]++;
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -757,17 +757,17 @@ Begin a while loop.\n\
 
 // Return a copy of the operator or keyword names.
 static string_vector
 names (const map_type& lst)
 {
   string_vector retval (lst.size ());
   int j = 0;
   for (map_iter iter = lst.begin (); iter != lst.end (); iter ++)
-    retval [j++] = iter->first;
+    retval[j++] = iter->first;
   return retval;
 }
 
 const static map_type operators_map (operators, operators + size (operators));
 const static map_type keywords_map (keywords, keywords + size (keywords));
 const static string_vector keyword_names = names (keywords_map);
 
 // FIXME -- It's not likely that this does the right thing now.
@@ -1213,21 +1213,21 @@ Undocumented internal function.\n\
 // FIXME -- Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
-      const int max_allowed_seps = file_ops::is_dir_sep (dir [dir_len-1]) ? 0 : 1;
+      const int max_allowed_seps = file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1;
 
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
-        if (file_ops::is_dir_sep (filename [i]))
+        if (file_ops::is_dir_sep (filename[i]))
           num_seps ++;
 
       return (num_seps <= max_allowed_seps);
     }
   else
     return false;
 }
 
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1931,17 +1931,17 @@ save_mat5_array_length (const double* va
     {
       int size = 8;
 
       if (save_as_floats)
         {
           bool too_large_for_float = false;
           for (octave_idx_type i = 0; i < nel; i++)
             {
-              double tmp = val [i];
+              double tmp = val[i];
 
               if (! (xisnan (tmp) || xisinf (tmp))
                   && fabs (tmp) > FLT_MAX)
                 {
                   too_large_for_float = true;
                   break;
                 }
             }
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -527,17 +527,17 @@ tree_index_expression::lvalue (void)
                 octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
                 if (error_state)
                   break;
 
                 bool autoconv = (tmp.is_zero_by_zero ()
                                  && (tmp.is_matrix_type () || tmp.is_string ()
                                      || tmp.is_cell ()));
 
-                if (i > 0 && type [i-1] == '(')
+                if (i > 0 && type[i-1] == '(')
                   {
                     octave_value_list pidx = idx.back ();
 
                     // Use octave_map, not octave_scalar_map so that the
                     // dimensions are 0x0, not 1x1.
                     if (tmp.is_undefined ())
                       {
                         if (pidx.has_magic_colon ())
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -465,17 +465,17 @@ fcn_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
+      else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
         retval = load_path::find_fcn_file (name.substr (0, len-2));
       else
         {
           std::string fname = name;
           size_t pos = name.find_first_of (Vfilemarker);
           if (pos != std::string::npos)
             fname = name.substr (0, pos);
 
@@ -522,18 +522,18 @@ oct_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'o'
-               && name [len - 2] == 'c' && name [len - 1] == 't')
+      else if (len > 4 && name[len - 4] == '.' && name[len - 3] == 'o'
+               && name[len - 2] == 'c' && name[len - 1] == 't')
         retval = load_path::find_oct_file (name.substr (0, len-4));
       else
         retval = load_path::find_oct_file (name);
     }
 
   return retval;
 }
 
@@ -551,18 +551,18 @@ mex_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'm'
-               && name [len - 2] == 'e' && name [len - 1] == 'x')
+      else if (len > 4 && name[len - 4] == '.' && name[len - 3] == 'm'
+               && name[len - 2] == 'e' && name[len - 1] == 'x')
         retval = load_path::find_mex_file (name.substr (0, len-4));
       else
         retval = load_path::find_mex_file (name);
     }
 
   return retval;
 }
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1554,17 +1554,17 @@ do_who (int argc, const string_vector& a
           // It would be better to refecat symbol_info_list to not store the
           // symbol records and then use it in load-save.cc (do_load) to
           // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
             error ("whos: -file argument must be followed by a file name");
           else
             {
-              std::string nm = argv [i + 1];
+              std::string nm = argv[i + 1];
 
               unwind_protect frame;
 
               // Set up temporary scope.
 
               symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
               frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -398,30 +398,30 @@ gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
   if (own_buffer && !buffer)
   {
     // Check for buffered vs. "unbuffered"
     if (buffer_size > 0)
     {
       // Allocate internal buffer
-      buffer = new char_type[buffer_size];
+      buffer = new char_type [buffer_size];
       // Get area starts empty and will be expanded by underflow as need arises
       this->setg (buffer, buffer, buffer);
       // Setup entire internal buffer as put area.
       // The one-past-end pointer actually points to the last element of the buffer,
       // so that overflow(c) can safely add the extra character c to the sequence.
       // These pointers remain in place for the duration of the buffer
       this->setp (buffer, buffer + buffer_size - 1);
     }
     else
     {
       // Even in "unbuffered" case, (small?) get buffer is still required
       buffer_size = SMALLBUFSIZE;
-      buffer = new char_type[buffer_size];
+      buffer = new char_type [buffer_size];
       this->setg (buffer, buffer, buffer);
       // "Unbuffered" means no put buffer
       this->setp (0, 0);
     }
   }
   else
   {
     // If buffer already allocated, reset buffer pointers just to make sure no
