# HG changeset patch
# User Rik <rik@octave.org>
# Date 1431447721 25200
#      Tue May 12 09:22:01 2015 -0700
# Branch stable
# Node ID aa36fb998a4dc4ae6cfbb674a495dfbb7ec3fc35
# Parent  cc5ffacb15ab399684d5172688ce6ba0615dfa5a
maint: Remove unnecessary whitespace at end of lines.

* libgui/Makefile.am, libgui/graphics/Canvas.cc,
libgui/graphics/EditControl.cc, libgui/graphics/Figure.cc,
libgui/graphics/MouseModeActionGroup.cc, libgui/graphics/annotation-dialog.cc,
libgui/graphics/annotation-dialog.h, libgui/graphics/gl-select.cc,
libgui/graphics/module.mk, libgui/kb-layouts/default.keytab,
libgui/kb-layouts/linux.keytab, libgui/kb-layouts/vt420pc.keytab,
libgui/src/m-editor/find-dialog.cc, libgui/src/main-window.cc,
libgui/src/octave-qt-link.cc, libgui/src/octave-qt-link.h,
libgui/src/shortcut-manager.h, libinterp/corefcn/error.cc,
libinterp/corefcn/find.cc, libinterp/corefcn/gl2ps-renderer.cc,
libinterp/corefcn/graphics.cc, libinterp/corefcn/graphics.in.h,
libinterp/corefcn/octave-link.cc, libinterp/corefcn/quadcc.cc,
libinterp/corefcn/strfns.cc, libinterp/corefcn/syscalls.cc,
libinterp/corefcn/sysdep.cc, libinterp/corefcn/urlwrite.cc,
libinterp/corefcn/utils.cc, libinterp/corefcn/variables.cc,
libinterp/dldfcn/__init_fltk__.cc, libinterp/dldfcn/ccolamd.cc,
libinterp/dldfcn/colamd.cc, libinterp/octave-value/ov-bool-sparse.cc,
libinterp/octave-value/ov-classdef.cc, libinterp/octave-value/ov-re-sparse.cc,
libinterp/octave-value/ov-struct.cc, libinterp/parse-tree/pt-arg-list.cc,
scripts/audio/@audiorecorder/play.m, scripts/audio/wavwrite.m,
scripts/general/cart2sph.m, scripts/geometry/inpolygon.m,
scripts/gui/listdlg.m, scripts/gui/msgbox.m,
scripts/gui/private/message_dialog.m, scripts/help/get_first_help_sentence.m,
scripts/help/lookfor.m, scripts/image/imshow.m, scripts/io/strread.m,
scripts/java/javamem.m, scripts/miscellaneous/dir.m,
scripts/miscellaneous/edit.m, scripts/miscellaneous/genvarname.m,
scripts/miscellaneous/gzip.m, scripts/miscellaneous/private/__w2mpth__.m,
scripts/plot/appearance/annotation.m, scripts/plot/draw/colorbar.m,
scripts/plot/draw/quiver3.m, scripts/plot/util/hold.m,
scripts/plot/util/print.m, scripts/polynomial/mkpp.m,
scripts/polynomial/polyder.m, scripts/polynomial/spline.m,
scripts/polynomial/unmkpp.m, scripts/signal/arma_rnd.m, scripts/sparse/gplot.m,
scripts/statistics/tests/t_test.m,
scripts/statistics/tests/t_test_regression.m, scripts/strings/mat2str.m,
scripts/strings/strsplit.m, scripts/strings/strtrunc.m,
scripts/strings/untabify.m, scripts/testfun/assert.m:
maint: Remove unnecessary whitespace at end of lines.

diff --git a/libgui/Makefile.am b/libgui/Makefile.am
--- a/libgui/Makefile.am
+++ b/libgui/Makefile.am
@@ -121,17 +121,17 @@ ui-%.h: %.ui
 	$(AM_V_GEN)$(UIC) -o $@ $<
 
 qrc-%.cc: %.qrc
 	$(AM_V_GEN)$(rcc-command)
 
 AM_V_lrelease = $(am__v_lrelease_$(V))
 am__v_lrelease_ = $(am__v_lrelease_$(AM_DEFAULT_VERBOSITY))
 am__v_lrelease_0 = -silent
-am__v_lrelease_1 = 
+am__v_lrelease_1 =
 
 %.qm: %.ts
 	$(AM_V_GEN)$(MKDIR_P) languages && \
 	$(LRELEASE) $(AM_V_lrelease) -qm $@ $<
 
 DISTCLEANFILES = \
   default-qt-settings \
   $(LOCALES)
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -199,17 +199,17 @@ Canvas::updateCurrentPoint(const graphic
 
 void
 Canvas::annotation_callback (const octave_value_list& args)
 {
   Ffeval (ovl ("annotation").append (args));
 
   redraw ();
 }
-  
+
 void
 Canvas::canvasToggleAxes (const graphics_handle& handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go = gh_manager::get_object (handle);
 
   if (go.valid_object ())
@@ -780,34 +780,34 @@ Canvas::canvasMouseReleaseEvent (QMouseE
           updateCurrentPoint (figObj, obj, event);
           gh_manager::post_callback (figObj.get_handle (),
                                      "windowbuttonupfcn");
         }
     }
   else if (m_mouseMode == TextMode)
     {
       gh_manager::auto_lock lock;
-      
-      graphics_object figObj = 
+
+      graphics_object figObj =
         gh_manager::get_object (m_handle).get_ancestor ("figure");
       if (figObj.valid_object ())
-        {          
+        {
           QWidget *w = qWidget ();
           if (w)
             {
               Matrix bb = figObj.get ("position").matrix_value ();
               bb(0) = m_mouseAnchor.x () / bb(2);
               bb(1) = 1.0 - (m_mouseAnchor.y () / bb(3));
               bb(2) = (event->x () - m_mouseAnchor.x ()) / bb(2);
               bb(3) = (m_mouseAnchor.y () - event->y ()) / bb(3);
 
               octave_value_list props = ovl("textbox", bb);
 
               annotation_dialog anno_dlg (w, props);
-            
+
               if (anno_dlg.exec () == QDialog::Accepted)
                 {
                   props = anno_dlg.get_properties ();
 
                   octave_link::post_event (this, &Canvas::annotation_callback,
                                            props);
                 }
             }
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -212,17 +212,17 @@ EditControl::updateMultiLine (int pId)
 }
 
 void
 EditControl::textChanged (void)
 {
   m_textChanged = true;
 }
 
-void 
+void
 EditControl::returnPressed (void)
 {
   QString txt = (m_multiLine
                  ? qWidget<TextEdit> ()->toPlainText ()
                  : qWidget<QLineEdit> ()->text ());
 
   if (m_textChanged)
     {
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -130,17 +130,17 @@ Figure::Figure (const graphics_object& g
   m_container = new Container (win);
   win->setCentralWidget (m_container);
 
   figure::properties& fp = properties<figure> ();
 
   createFigureToolBarAndMenuBar ();
 
   int offset = 0;
-  if (fp.toolbar_is ("figure") || 
+  if (fp.toolbar_is ("figure") ||
       (fp.toolbar_is ("auto") && fp.menubar_is ("figure") &&
        ! hasUiControlChildren (fp)))
     offset += m_figureToolBar->sizeHint ().height ();
   else
     m_figureToolBar->hide ();
   if (fp.menubar_is ("figure") || hasUiMenuChildren (fp))
     offset += m_menuBar->sizeHint ().height () + 1;
   else
@@ -270,17 +270,17 @@ Figure::mouseMode (void)
 
   if (mode == "zoom")
     {
       octave_scalar_map zm = fp.get___zoom_mode__ ().scalar_map_value ();
 
       std::string direction = zm.getfield ("Direction").string_value ();
 
       mode += " " + direction;
-    }    
+    }
 
   return mouse_mode_from_string (mode);
 }
 
 void
 Figure::createFigureToolBarAndMenuBar (void)
 {
   QMainWindow* win = qWidget<QMainWindow> ();
@@ -830,17 +830,17 @@ Figure::copy_figure_callback (const std:
     }
 
   std::string device = "-d" + format;
 
   Ffeval (ovl ("print", file, device));
 
   octave_link::copy_image_to_clipboard (file);
 }
-  
+
 void
 Figure::fileSaveFigureAs (void)
 {
   fileSaveFigure (true);
 }
 
 void
 Figure::fileCloseFigure (void)
@@ -931,28 +931,28 @@ Figure::updateContainer (void)
 void
 Figure::toggleAxes (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->toggleAxes (m_handle);
 }
-  
+
 void
 Figure::toggleGrid (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->toggleGrid (m_handle);
 }
-  
+
 void
 Figure::autoAxes (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->autoAxes (m_handle);
 }
-  
+
 }; // namespace QtHandles
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -34,21 +34,21 @@ namespace QtHandles
 {
 
 MouseModeActionGroup::MouseModeActionGroup (QObject* xparent)
   : QObject (xparent), m_current (0)
 {
   m_actions.append (new QAction (QIcon (":/images/rotate.png"),
                                  tr ("Rotate"), this));
   QAction *zoom_in = new QAction ("Z+", this);
-  zoom_in->setToolTip (tr ("Zoom In")); 
+  zoom_in->setToolTip (tr ("Zoom In"));
   m_actions.append (zoom_in);
 
   QAction *zoom_out = new QAction ("Z-", this);
-  zoom_out->setToolTip (tr ("Zoom Out")); 
+  zoom_out->setToolTip (tr ("Zoom Out"));
   m_actions.append (zoom_out);
 
   m_actions.append (new QAction (QIcon (":/images/pan.png"),
                                  tr ("Pan"), this));
   m_actions.append (new QAction (QIcon::fromTheme ("insert-text"),
                                  tr ("Insert Text"), this));
   m_actions.append (new QAction (QIcon (":/images/select.png"),
                                  tr ("Select"), this));
@@ -103,10 +103,10 @@ MouseModeActionGroup::setMode (MouseMode
     m_actions[i]->setChecked (i+1 == mode);
 
   // SelectMode cancels all the others but the button doesn't remain
   // highlighed.
 
   if (mode == SelectMode)
     m_actions[SelectMode-1]->setChecked (false);
 }
-  
+
 };
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -55,17 +55,17 @@ annotation_dialog::init ()
   // restore last geometry
   restoreGeometry (settings->value("annotation/geometry").toByteArray ());
 
   // connect signals
   connect (ui->button_box, SIGNAL (clicked (QAbstractButton *)),
            this, SLOT (button_clicked (QAbstractButton *)));
 
 
-  connect (ui->edit_string, SIGNAL (textChanged (const QString&)), 
+  connect (ui->edit_string, SIGNAL (textChanged (const QString&)),
            this, SLOT (edit_string_changed (const QString&)));
 
   connect (ui->btn_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
   connect (ui->btn_background_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
@@ -122,17 +122,17 @@ annotation_dialog::get_gui_props ()
   props = octave_value_list ();
 
   Matrix position(1,4);
   position(0) = ui->sb_x->value ();
   position(1) = ui->sb_y->value ();
   position(2) = ui->sb_width->value ();
   position(3) = ui->sb_height->value ();
   props.append (ovl ("textbox", position));
- 
+
   props.append (ovl ("string", ui->edit_string->text ().toStdString ()));
   props.append (ovl ("fitboxtotext", ui->cb_fit_box_to_text->isChecked() ? "on" : "off" ));
   props.append (ovl ("units", ui->cb_units->currentText ().toStdString () ));
   props.append (ovl ("horizontalalignment", ui->cb_horz_align->currentText ().toStdString () ));
   props.append (ovl ("verticalalignment", ui->cb_vert_align->currentText ().toStdString () ));
   props.append (ovl ("fontname", ui->cb_font_name->currentText ().toStdString()));
   props.append (ovl ("fontsize", ui->sb_font_size->value ()));
   props.append (ovl ("fontweight", ui->cb_font_bold->isChecked() ? "bold" : "normal" ));
@@ -174,24 +174,24 @@ annotation_dialog::set_gui_props ()
             {
               ui->sb_width->setValue (position(2));
               ui->sb_height->setValue (position(3));
             }
         }
       else if (name == "string")
         {
           // FIXME: handle if is array of strings ?
-          ui->edit_string->setText (props(2*i +1).string_value ().c_str ()); 
+          ui->edit_string->setText (props(2*i +1).string_value ().c_str ());
         }
       else if (name == "fitboxtotext")
         {
           ui->cb_fit_box_to_text->setChecked ( props(1*i +1).string_value () == "on" );
         }
       else if (name == "units")
-        { 
+        {
           ui->cb_units->setCurrentIndex ( ui->cb_units->findText(props(1*i +1).string_value ().c_str ()) );
         }
       else if (name == "horizontalalignment")
         {
           ui->cb_horz_align->setCurrentIndex ( ui->cb_horz_align->findText(props(1*i +1).string_value ().c_str ()) );
         }
       else if (name == "verticalalignment")
         {
@@ -224,39 +224,39 @@ annotation_dialog::set_gui_props ()
           if (color.isValid ())
             ui->btn_color->setPalette (QPalette (color));
         }
 
     }
 
   edit_string_changed (ui->edit_string->text ());
 }
- 
+
 void
 annotation_dialog::edit_string_changed (const QString &str)
 {
   ui->button_box->button (QDialogButtonBox::Ok)->setEnabled (str.length () > 0);
 }
 
 void
 annotation_dialog::prompt_for_color ()
 {
   QWidget *widg = dynamic_cast<QWidget*> (sender ());
   if (widg)
     {
       QColor color = widg->palette ().color (QPalette::Button);
- 
+
       color = QColorDialog::getColor(color, this);
 
       if (color.isValid ())
       {
         widg->setPalette (QPalette (color));
 
         QString css = QString ("background-color: %1; border: 1px solid %2;")
                 .arg (color.name ())
                 .arg ("#000000");
-  
+
         widg->setStyleSheet (css);
         widg->update ();
       }
     }
 }
 
diff --git a/libgui/graphics/annotation-dialog.h b/libgui/graphics/annotation-dialog.h
--- a/libgui/graphics/annotation-dialog.h
+++ b/libgui/graphics/annotation-dialog.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 namespace Ui
 {
   class annotation_dialog;
 }
 
 class annotation_dialog : public QDialog
 {
-  Q_OBJECT 
+  Q_OBJECT
 public:
   explicit annotation_dialog (QWidget * parent, const octave_value_list &pr);
   ~annotation_dialog ();
 
   octave_value_list get_properties() const;
 
 private slots:
   // slots for dialog's buttons
diff --git a/libgui/graphics/gl-select.cc b/libgui/graphics/gl-select.cc
--- a/libgui/graphics/gl-select.cc
+++ b/libgui/graphics/gl-select.cc
@@ -220,16 +220,16 @@ opengl_selector::draw_image (const image
   p2(0) = xd(1) + x_pix_size/2;
   p2(1) = yd(0) - y_pix_size/2;
 
   p3(0) = xd(1) + x_pix_size/2;
   p3(1) = yd(1) + y_pix_size/2;
 
   p4(0) = xd(0) - x_pix_size/2;
   p4(1) = yd(1) + y_pix_size/2;
-  
+
   glBegin (GL_QUADS);
   glVertex3dv (p1.data ());
   glVertex3dv (p2.data ());
   glVertex3dv (p3.data ());
   glVertex3dv (p4.data ());
   glEnd ();
 }
diff --git a/libgui/graphics/module.mk b/libgui/graphics/module.mk
--- a/libgui/graphics/module.mk
+++ b/libgui/graphics/module.mk
@@ -2,17 +2,17 @@ EXTRA_DIST += \
   graphics/module.mk \
   graphics/qthandles.qrc \
   graphics/images/README \
   graphics/images/pan.png \
   graphics/images/rotate.png \
   graphics/images/select.png \
   graphics/images/zoom-in.png \
   graphics/images/zoom-out.png \
-  $(octave_gui_graphics_UI) 
+  $(octave_gui_graphics_UI)
 
 octave_gui_MOC += \
   graphics/moc-annotation-dialog.cc \
   graphics/moc-Backend.cc \
   graphics/moc-ButtonControl.cc \
   graphics/moc-ContextMenu.cc \
   graphics/moc-EditControl.cc \
   graphics/moc-Figure.cc \
diff --git a/libgui/kb-layouts/default.keytab b/libgui/kb-layouts/default.keytab
--- a/libgui/kb-layouts/default.keytab
+++ b/libgui/kb-layouts/default.keytab
@@ -62,20 +62,20 @@ key Down  -Shift+AnyMod+Ansi            
 key Right -Shift+AnyMod+Ansi                     : "\E[1;*C"
 key Left  -Shift+AnyMod+Ansi                     : "\E[1;*D"
 
 # other grey PC keys
 
 key Enter+NewLine : "\r\n"
 key Enter-NewLine : "\r"
 
-key Home        -AnyMod     -AppCuKeys           : "\E[H"  
-key End         -AnyMod     -AppCuKeys           : "\E[F"  
-key Home        -AnyMod     +AppCuKeys           : "\EOH"  
-key End         -AnyMod     +AppCuKeys           : "\EOF"  
+key Home        -AnyMod     -AppCuKeys           : "\E[H"
+key End         -AnyMod     -AppCuKeys           : "\E[F"
+key Home        -AnyMod     +AppCuKeys           : "\EOH"
+key End         -AnyMod     +AppCuKeys           : "\EOF"
 key Home        +AnyMod                          : "\E[1;*H"
 key End         +AnyMod                          : "\E[1;*F"
 
 key Insert      -AnyMod                          : "\E[2~"
 key Delete      -AnyMod                          : "\E[3~"
 key Insert      +AnyMod                          : "\E[2;*~"
 key Delete      +AnyMod                          : "\E[3;*~"
 
diff --git a/libgui/kb-layouts/linux.keytab b/libgui/kb-layouts/linux.keytab
--- a/libgui/kb-layouts/linux.keytab
+++ b/libgui/kb-layouts/linux.keytab
@@ -5,33 +5,33 @@
 # NOT TESTED, MAY NEED SOME CLEANUPS
 keyboard "Linux console"
 
 # --------------------------------------------------------------
 #
 # This configuration table allows to customize the
 # meaning of the keys.
 #
-# The syntax is that each entry has the form : 
+# The syntax is that each entry has the form :
 #
 #   "key" Keyname { ("+"|"-") Modename } ":" (String|Operation)
 #
 # Keynames are those defined in <qnamespace.h> with the
 # "Qt::Key_" removed. (We'd better insert the list here)
 #
-# Mode names are : 
+# Mode names are :
 #
 # - Shift
 # - Alt
 # - Control
 #
 #   The VT100 emulation has two modes that can affect the
 #   sequences emitted by certain keys. These modes are
 #   under control of the client program.
-#   
+#
 # - Newline     : effects Return and Enter key.
 # - Application : effects Up and Down key.
 #
 # - Ansi        : effects Up and Down key (This is for VT52, really).
 #
 # Operations are
 #
 # - scrollUpLine
@@ -48,17 +48,17 @@ keyboard "Linux console"
 # --------------------------------------------------------------
 
 key Escape : "\E"
 key Tab    : "\t"
 
 # VT100 can add an extra \n after return.
 # The NewLine mode is set by an escape sequence.
 
-key Return-NewLine : "\r"  
+key Return-NewLine : "\r"
 key Return+NewLine : "\r\n"
 
 # Some desperately try to save the ^H.
 
 key Backspace : "\x7f"
 key Delete    : "\E[3~"
 
 # These codes are for the VT52 mode of VT100
@@ -81,41 +81,41 @@ key Left -Shift+Ansi+AppCuKeys : "\EOD"
 
 key Up   -Shift+Ansi-AppCuKeys : "\E[A"
 key Down -Shift+Ansi-AppCuKeys : "\E[B"
 key Right-Shift+Ansi-AppCuKeys : "\E[C"
 key Left -Shift+Ansi-AppCuKeys : "\E[D"
 
 # linux functions keys F1-F5 differ from xterm
 
-key F1 : "\E[[A" 
-key F2 : "\E[[B" 
-key F3 : "\E[[C" 
-key F4 : "\E[[D" 
-key F5 : "\E[[E" 
+key F1 : "\E[[A"
+key F2 : "\E[[B"
+key F3 : "\E[[C"
+key F4 : "\E[[D"
+key F5 : "\E[[E"
 
-key F6     : "\E[17~" 
-key F7     : "\E[18~" 
-key F8     : "\E[19~" 
-key F9     : "\E[20~" 
-key F10    : "\E[21~" 
-key F11    : "\E[23~" 
-key F12    : "\E[24~" 
+key F6     : "\E[17~"
+key F7     : "\E[18~"
+key F8     : "\E[19~"
+key F9     : "\E[20~"
+key F10    : "\E[21~"
+key F11    : "\E[23~"
+key F12    : "\E[24~"
 
-key Home   : "\E[1~"  
-key End    : "\E[4~"  
+key Home   : "\E[1~"
+key End    : "\E[4~"
 
-key Prior -Shift : "\E[5~"  
-key Next  -Shift : "\E[6~"  
-key Insert-Shift : "\E[2~"  
+key Prior -Shift : "\E[5~"
+key Next  -Shift : "\E[6~"
+key Insert-Shift : "\E[2~"
 
 # Keypad-Enter. See comment on Return above.
 
 key Enter+NewLine : "\r\n"
-key Enter-NewLine : "\r"  
+key Enter-NewLine : "\r"
 
 key Space +Control : "\x00"
 
 # some of keys are used by konsole.
 
 key Up    +Shift   : scrollLineUp
 key Prior +Shift   : scrollPageUp
 key Down  +Shift   : scrollLineDown
diff --git a/libgui/kb-layouts/vt420pc.keytab b/libgui/kb-layouts/vt420pc.keytab
--- a/libgui/kb-layouts/vt420pc.keytab
+++ b/libgui/kb-layouts/vt420pc.keytab
@@ -1,51 +1,51 @@
 # [vt420pc.keytab] Konsole Keyboard Table (VT420pc keys)
 # adapted by ferdinand gassauer f.gassauer@aon.at
 # Nov 2000
 #
 ################################################################
 #
-# The escape sequences emmited by the 
+# The escape sequences emmited by the
 # keys Shift+F1 to Shift+F12 might not fit your needs
 #
 ################# IMPORTANT NOTICE #############################
-# the key bindings (Kcontrol -> look and feel -> keybindgs) 
-# overrule the settings in this file. The key bindings might be 
+# the key bindings (Kcontrol -> look and feel -> keybindgs)
+# overrule the settings in this file. The key bindings might be
 # changed by the user WITHOUT notification of the maintainer of
-# the keytab file. Konsole will not work as expected by 
+# the keytab file. Konsole will not work as expected by
 # the maintainer of the keytab file.
 ################################################################
 #
 # --------------------------------------------------------------
 
 keyboard "DEC VT420 Terminal"
 
 # --------------------------------------------------------------
 #
 # This configuration table allows to customize the
 # meaning of the keys.
 #
-# The syntax is that each entry has the form : 
+# The syntax is that each entry has the form :
 #
 #   "key" Keyname { ("+"|"-") Modename } ":" (String|Operation)
 #
 # Keynames are those defined in <qnamespace.h> with the
 # "Qt::Key_" removed. (We'd better insert the list here)
 #
-# Mode names are : 
+# Mode names are :
 #
 # - Shift
 # - Alt
 # - Control
 #
 #   The VT100 emulation has two modes that can affect the
 #   sequences emitted by certain keys. These modes are
 #   under control of the client program.
-#   
+#
 # - Newline     : effects Return and Enter key.
 # - Application : effects Up and Down key.
 #
 # - Ansi        : effects Up and Down key (This is for VT52, really).
 #
 # Operations are
 #
 # - scrollUpLine
@@ -63,17 +63,17 @@ keyboard "DEC VT420 Terminal"
 
 key Escape : "\E"
 key Tab    : "\t"
 key Backtab: "\E[Z"
 
 # VT100 can add an extra \n after return.
 # The NewLine mode is set by an escape sequence.
 
-key Return-NewLine : "\r"  
+key Return-NewLine : "\r"
 key Return+NewLine : "\r\n"
 
 # Some desperately try to save the ^H.
 # may be not everyone wants this
 
 key Backspace : "\x08"  # Control H
 key Delete    : "\x7f"
 
@@ -95,57 +95,57 @@ key Down -Shift+Ansi+AppCuKeys : "\EOB"
 key Right-Shift+Ansi+AppCuKeys : "\EOC"
 key Left -Shift+Ansi+AppCuKeys : "\EOD"
 
 key Up   -Shift+Ansi-AppCuKeys : "\E[A"
 key Down -Shift+Ansi-AppCuKeys : "\E[B"
 key Right-Shift+Ansi-AppCuKeys : "\E[C"
 key Left -Shift+Ansi-AppCuKeys : "\E[D"
 
-# function keys 
+# function keys
 
-key F1 -Shift    : "\E[11~"  
+key F1 -Shift    : "\E[11~"
 key F2 -Shift    : "\E[12~"
 key F3 -Shift    : "\E[13~"
 key F4 -Shift    : "\E[14~"
 key F5 -Shift    : "\E[15~"
 key F6 -Shift    : "\E[17~"
 key F7 -Shift    : "\E[18~"
 key F8 -Shift    : "\E[19~"
 key F9 -Shift    : "\E[20~"
 key F10-Shift    : "\E[21~"
 key F11-Shift    : "\E[23~"
-key F12-Shift    : "\E[24~"  
+key F12-Shift    : "\E[24~"
 #
 # Shift F1-F12
 #
 key F1 +Shift    : "\E[11;2~"
 key F2 +Shift    : "\E[12;2~"
 key F3 +Shift    : "\E[13;2~"
 key F4 +Shift    : "\E[14;2~"
 key F5 +Shift    : "\E[15;2~"
-key F6 +Shift    : "\E[17;2~" 
-key F7 +Shift    : "\E[18;2~" 
-key F8 +Shift    : "\E[19;2~" 
-key F9 +Shift    : "\E[20;2~" 
-key F10+Shift    : "\E[21;2~" 
-key F11+Shift    : "\E[23;2~" 
-key F12+Shift    : "\E[24;2~" 
+key F6 +Shift    : "\E[17;2~"
+key F7 +Shift    : "\E[18;2~"
+key F8 +Shift    : "\E[19;2~"
+key F9 +Shift    : "\E[20;2~"
+key F10+Shift    : "\E[21;2~"
+key F11+Shift    : "\E[23;2~"
+key F12+Shift    : "\E[24;2~"
 
-key Home   : "\E[H"  
-key End    : "\E[F"  
+key Home   : "\E[H"
+key End    : "\E[F"
 
-key Prior -Shift : "\E[5~"  
-key Next  -Shift : "\E[6~"  
-key Insert-Shift : "\E[2~"  
+key Prior -Shift : "\E[5~"
+key Next  -Shift : "\E[6~"
+key Insert-Shift : "\E[2~"
 
 # Keypad-Enter. See comment on Return above.
 
 key Enter+NewLine : "\r\n"
-key Enter-NewLine : "\r"  
+key Enter-NewLine : "\r"
 
 key Space +Control : "\x00"
 
 # some of keys are used by konsole.
 
 key Up    +Shift   : scrollLineUp
 key Prior +Shift   : scrollPageUp
 key Down  +Shift   : scrollLineDown
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -292,17 +292,17 @@ find_dialog::find (bool forward)
         {
            // search from position before search characters text length
            // if search backward on existing results,
            _edit_area->getCursorPosition (&line,&col);
            if (_find_result_available && _edit_area->hasSelectedText ())
              {
                int currpos = _edit_area->positionFromLineIndex(line,col);
                currpos -= (_search_line_edit->text ().length ());
-               if (currpos < 0) 
+               if (currpos < 0)
                  currpos = 0;
                _edit_area->lineIndexFromPosition(currpos, &line,&col);
              }
         }
     }
 
   if (_edit_area)
     {
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1755,17 +1755,17 @@ main_window::construct_edit_menu (QMenuB
     = edit_menu->addAction (tr ("Select All"), this, SLOT (selectAll ()));
 
   _clear_clipboard_action
     = edit_menu->addAction (tr ("Clear Clipboard"), this,
                             SLOT (clear_clipboard ()));
 
   edit_menu->addSeparator ();
 
-  _find_files_action 
+  _find_files_action
     = edit_menu->addAction (resource_manager::icon ("edit-find"),
                              tr ("Find Files..."));
 
   edit_menu->addSeparator ();
 
   _clear_command_window_action
     = edit_menu->addAction (tr ("Clear Command Window"));
 
@@ -1800,18 +1800,18 @@ main_window::construct_edit_menu (QMenuB
   connect (_preferences_action, SIGNAL (triggered ()),
            this, SLOT (process_settings_dialog_request ()));
 }
 
 QAction *
 main_window::construct_debug_menu_item (const char *icon, const QString& item,
                                         const char *member)
 {
-  QAction *action = add_action (_debug_menu, 
-                                  resource_manager::icon (QString (icon)), 
+  QAction *action = add_action (_debug_menu,
+                                  resource_manager::icon (QString (icon)),
                                 item, member);
 
   action->setEnabled (false);
 
 #ifdef HAVE_QSCINTILLA
   editor_window->debug_menu ()->addAction (action);
   editor_window->toolbar ()->addAction (action);
 #endif
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -443,17 +443,17 @@ octave_qt_link::update_directory ()
 
 void
 octave_qt_link::do_execute_command_in_terminal (const std::string& command)
 {
   emit execute_command_in_terminal_signal (QString::fromStdString (command));
 }
 
 void
-octave_qt_link::do_set_workspace (bool top_level, bool debug, 
+octave_qt_link::do_set_workspace (bool top_level, bool debug,
                                   const std::list<workspace_element>& ws)
 {
   if (! top_level && ! debug)
     return;
 
   if (_new_dir)
     update_directory ();
 
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -103,17 +103,17 @@ public:
   do_debug_cd_or_addpath_error (const std::string& file,
                                 const std::string& dir,
                                 bool addpath_option);
 
   void do_change_directory (const std::string& dir);
 
   void do_execute_command_in_terminal (const std::string& command);
 
-  void do_set_workspace (bool top_level, bool debug, 
+  void do_set_workspace (bool top_level, bool debug,
                          const std::list<workspace_element>& ws);
 
   void do_clear_workspace (void);
 
   void do_set_history (const string_vector& hist);
   void do_append_history (const std::string& hist_entry);
   void do_clear_history (void);
 
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -132,17 +132,17 @@ private:
       actual_sc[1] = QKeySequence ();
 
       default_sc[0] = QKeySequence ();
       default_sc[1] = QKeySequence ();
     }
 
     shortcut_t (const shortcut_t& x)
       : tree_item (x.tree_item), description (x.description),
-        settings_key (x.settings_key), 
+        settings_key (x.settings_key),
         actual_sc (new QKeySequence[2]), default_sc (new QKeySequence[2])
     {
       actual_sc[0] = x.actual_sc[0];
       actual_sc[1] = x.actual_sc[1];
 
       default_sc[0] = x.default_sc[0];
       default_sc[1] = x.default_sc[1];
     }
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -164,17 +164,17 @@ vwarning (const char *name, const char *
   //        formatting goop attached to it.  We probably also want just the
   //        message, not the traceback information.
 
   std::string base_msg = output_buf.str ();
   std::string msg_string;
 
   if (name)
     msg_string = std::string (name) + ": ";
-  
+
   msg_string += base_msg + "\n";
 
   Vlast_warning_id = id;
   Vlast_warning_message = base_msg;
 
   if (! Vquiet_warning)
     {
       octave_diary << msg_string;
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -331,17 +331,17 @@ DEFUN (find, args, nargout,
 @deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
 @deftypefnx {Built-in Function} {[i, j] =} find (@dots{})\n\
 @deftypefnx {Built-in Function} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.\n\
 \n\
 To obtain a single index for each matrix element, Octave pretends that the\n\
-columns of a matrix form one long vector (like Fortran arrays are stored). \n\
+columns of a matrix form one long vector (like Fortran arrays are stored).\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
   @result{} [ 1; 4 ]\n\
 @end group\n\
 @end example\n\
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -223,19 +223,19 @@ glps_renderer::render_text (const std::s
 void
 glps_renderer::set_font (const base_properties& props)
 {
   opengl_renderer::set_font (props);
 
   fontsize = props.get ("fontsize_points").double_value ();
 
   caseless_str fn = props.get ("fontname").xtolower ().string_value ();
-  bool isbold = 
+  bool isbold =
     (props.get ("fontweight").xtolower ().string_value () == "bold");
-  bool isitalic = 
+  bool isitalic =
     (props.get ("fontangle").xtolower ().string_value () == "italic");
 
   fontname = "";
   if (fn == "times" || fn == "times-roman")
     {
       if (isitalic && isbold)
         fontname = "Times-BoldItalic";
       else if (isitalic)
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -3097,17 +3097,17 @@ base_properties::update_axis_limits (con
     obj.update_axis_limits (axis_type, h);
 }
 
 void
 base_properties::update_uicontextmenu (void) const
 {
   if (uicontextmenu.get ().is_empty ())
     return;
-  
+
   graphics_object obj = gh_manager::get_object (uicontextmenu.get ());
   if (obj && obj.isa ("uicontextmenu"))
     {
       uicontextmenu::properties& props =
         reinterpret_cast<uicontextmenu::properties&> (obj.get_properties ());
       props.add_dependent_obj (__myhandle__);
     }
 }
@@ -3228,17 +3228,17 @@ base_graphics_object::remove_all_listene
 
       property p = get_properties ().get_property (pa->first);
 
       if (! error_state && p.ok ())
         p.delete_listener ();
     }
 }
 
-void 
+void
 base_graphics_object::build_user_defaults_map (property_list::pval_map_type &def, const std::string go_name) const
 {
   property_list local_defaults = get_defaults_list ();
   property_list::plist_map_const_iterator p =
     local_defaults.find (go_name);
 
   if (p != local_defaults.end ())
     {
@@ -8836,24 +8836,24 @@ hggroup::update_axis_limits (const std::
     }
 
   base_graphics_object::update_axis_limits (axis_type);
 }
 
 // ---------------------------------------------------------------------
 
 uicontextmenu::~uicontextmenu (void)
-{ 
+{
   std::list<graphics_handle> lst = xproperties.get_dependent_obj_list ();
   std::list<graphics_handle>::const_iterator it;
-  
+
   for (it = lst.begin (); it != lst.end (); it++)
     {
       graphics_object go = gh_manager::get_object (*it);
-      
+
       if (go.valid_object () &&
           go.get ("uicontextmenu") == xproperties.get___myhandle__ ())
         go.set ("uicontextmenu", Matrix ());
     }
 }
 
 
 /*
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -5352,23 +5352,23 @@ public:
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API uicontextmenu : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
-  
-    void add_dependent_obj (graphics_handle gh) 
+
+    void add_dependent_obj (graphics_handle gh)
     { dependent_obj_list.push_back (gh); }
 
-    // FIXME: the list may contain duplicates. 
-    //        Should we return only unique elements? 
-    const std::list<graphics_handle> get_dependent_obj_list (void) 
+    // FIXME: the list may contain duplicates.
+    //        Should we return only unique elements?
+    const std::list<graphics_handle> get_dependent_obj_list (void)
     { return dependent_obj_list; }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uicontextmenu)
       any_property __object__ , Matrix ()
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -56,17 +56,17 @@ octave_link::octave_link (void)
 }
 
 void
 octave_link::set_workspace (void)
 {
   if (enabled ())
     instance->do_set_workspace ((symbol_table::current_scope ()
                                  == symbol_table::top_scope ()),
-                                instance->debugging, 
+                                instance->debugging,
                                 symbol_table::workspace_info ());
 }
 
 // OBJ should be an object of a class that is derived from the base
 // class octave_link, or 0 to disconnect the link.  It is the
 // responsibility of the caller to delete obj.
 
 void
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1491,17 +1491,17 @@ DEFUN (quadcc, args, nargout,
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 @deftypefnx {Function File} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b}\n\
 using doubly-adaptive @nospell{Clenshaw-Curtis} quadrature.\n\
 \n\
 @var{f} is a function handle, inline function, or string containing the name\n\
 of the function to evaluate.  The function @var{f} must be vectorized and\n\
-must return a vector of output values if given a vector of input values. \n\
+must return a vector of output values if given a vector of input values.\n\
 For example,\n\
 \n\
 @example\n\
 f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
 @noindent\n\
 which uses the element-by-element ``dot'' form for all operators.\n\
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -45,17 +45,17 @@ DEFUN (char, args, ,
 @deftypefn  {Built-in Function} {} char (@var{x})\n\
 @deftypefnx {Built-in Function} {} char (@var{x}, @dots{})\n\
 @deftypefnx {Built-in Function} {} char (@var{s1}, @var{s2}, @dots{})\n\
 @deftypefnx {Built-in Function} {} char (@var{cell_array})\n\
 Create a string array from one or more numeric matrices, character\n\
 matrices, or cell arrays.\n\
 \n\
 Arguments are concatenated vertically.  The returned values are padded with\n\
-blanks as needed to make each row of the string array have the same length. \n\
+blanks as needed to make each row of the string array have the same length.\n\
 Empty input strings are significant and will concatenated in the output.\n\
 \n\
 For numerical input, each element is converted to the corresponding ASCII\n\
 character.  A range error results if an input is outside the ASCII range\n\
 (0-255).\n\
 \n\
 For cell arrays, each element is concatenated separately.  Cell arrays\n\
 converted through @code{char} can mostly be converted back with\n\
@@ -176,17 +176,17 @@ DEFUN (strvcat, args, ,
 @deftypefn  {Built-in Function} {} strvcat (@var{x})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{x}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{s1}, @var{s2}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{cell_array})\n\
 Create a character array from one or more numeric matrices, character\n\
 matrices, or cell arrays.\n\
 \n\
 Arguments are concatenated vertically.  The returned values are padded with\n\
-blanks as needed to make each row of the string array have the same length. \n\
+blanks as needed to make each row of the string array have the same length.\n\
 Unlike @code{char}, empty strings are removed and will not appear in the\n\
 output.\n\
 \n\
 For numerical input, each element is converted to the corresponding ASCII\n\
 character.  A range error results if an input is outside the ASCII range\n\
 (0-255).\n\
 \n\
 For cell arrays, each element is concatenated separately.  Cell arrays\n\
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -163,17 +163,17 @@ error message.\n\
 }
 
 DEFUNX ("exec", Fexec, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
 Replace current process with a new process.\n\
 \n\
 Calling @code{exec} without first calling @code{fork} will terminate your\n\
-current Octave process and replace it with the program named by @var{file}. \n\
+current Octave process and replace it with the program named by @var{file}.\n\
 For example,\n\
 \n\
 @example\n\
 exec (\"ls\" \"-l\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will run @code{ls} and return you to your shell prompt.\n\
@@ -1381,17 +1381,17 @@ has not yet been reported since they sto
 \n\
 @item WCONTINUE\n\
 Return if a stopped child has been resumed by delivery of @code{SIGCONT}.\n\
 This value may not be meaningful on all systems.\n\
 @end table\n\
 \n\
 If the returned value of @var{pid} is greater than 0, it is the process ID\n\
 of the child process that exited.  If an error occurs, @var{pid} will be\n\
-less than zero and @var{msg} will contain a system-dependent error message. \n\
+less than zero and @var{msg} will contain a system-dependent error message.\n\
 The value of @var{status} contains additional system-dependent information\n\
 about the subprocess that exited.\n\
 @seealso{WCONTINUE, WCOREDUMP, WEXITSTATUS, WIFCONTINUED, WIFSIGNALED, WIFSTOPPED, WNOHANG, WSTOPSIG, WTERMSIG, WUNTRACED}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
@@ -1533,17 +1533,17 @@ This function should only be employed if
 }
 
 DEFUNX ("WCOREDUMP", FWCOREDUMP, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WCOREDUMP (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child produced a core dump.\n\
 \n\
-This function should only be employed if @code{WIFSIGNALED} returned true. \n\
+This function should only be employed if @code{WIFSIGNALED} returned true.\n\
 The macro used to implement this function is not specified in POSIX.1-2001\n\
 and is not available on some Unix implementations (e.g., AIX, SunOS).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -1035,17 +1035,17 @@ equivalent to\n\
 @end deftypefn")
 {
   return octave_value (octave_env::get_home_directory ());
 }
 
 /*
 %!test
 %! if (! ispc ())
-%!   assert (get_home_directory (), getenv ("HOME")); 
+%!   assert (get_home_directory (), getenv ("HOME"));
 %! endif
 */
 
 // This function really belongs in display.cc, but including defun.h in
 // that file results in conflicts with symbols from headers that are
 // needed for X11 and Carbon functions.
 
 DEFUN (have_window_system, , ,
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -305,17 +305,17 @@ urlwrite (\"ftp://ftp.octave.org/pub/REA
           \"README.txt\");\n\
 @end group\n\
 @end example\n\
 \n\
 The full path of the downloaded file is returned in @var{f}.\n\
 \n\
 The variable @var{success} is 1 if the download was successful,\n\
 otherwise it is 0 in which case @var{message} contains an error message.\n\
- \n\
+\n\
 If no output argument is specified and an error occurs, then the error is\n\
 signaled through Octave's error handling mechanism.\n\
 \n\
 This function uses libcurl.  Curl supports, among others, the HTTP, FTP and\n\
 FILE protocols.  Username and password may be specified in the URL, for\n\
 example:\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -298,17 +298,17 @@ the list of directories specified by @co
 \n\
 If no file is found, return an empty character string.\n\
 \n\
 If the first argument is a cell array of strings, search each directory of\n\
 the loadpath for element of the cell array and return the first that\n\
 matches.\n\
 \n\
 If the second optional argument @qcode{\"all\"} is supplied, return a cell\n\
-array containing the list of all files that have the same name in the path. \n\
+array containing the list of all files that have the same name in the path.\n\
 If no files are found, return an empty cell array.\n\
 @seealso{file_in_path, dir_in_loadpath, path}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -377,17 +377,17 @@ file_in_path (EXEC_PATH, \"sh\")\n\
      @result{} \"/bin/sh\"\n\
 @end group\n\
 @end example\n\
 \n\
 If the second argument is a cell array of strings, search each directory of\n\
 the path for element of the cell array and return the first that matches.\n\
 \n\
 If the third optional argument @qcode{\"all\"} is supplied, return a cell\n\
-array containing the list of all files that have the same name in the path. \n\
+array containing the list of all files that have the same name in the path.\n\
 If no files are found, return an empty cell array.\n\
 @seealso{file_in_loadpath, dir_in_loadpath, path}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -643,20 +643,20 @@ not on the search path you should use so
 %!assert (exist ("print_usage", "file"), 2)
 %!assert (exist ("print_usage", "dir"), 0)
 
 ## Don't search path for rooted relative file names
 %!assert (exist ("plot.m", "file"), 2);
 %!assert (exist ("./plot.m", "file"), 0);
 %!assert (exist ("./%nonexistentfile%", "file"), 0);
 %!assert (exist ("%nonexistentfile%", "file"), 0);
- 
+
 ## Don't search path for absolute file names
 %!test
-%! tname = tempname (pwd ()); 
+%! tname = tempname (pwd ());
 %! unwind_protect
 %!   ## open/close file to create it, equivalent of touch
 %!   fid = fopen (tname, "w");
 %!   fclose (fid);
 %!   [~, fname] = fileparts (tname);
 %!   assert (exist (fullfile (pwd (), fname), "file"), 2);
 %! unwind_protect_cleanup
 %!   unlink (tname);
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -581,17 +581,17 @@ public:
         if (kgo.valid_object ())
           {
             uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
                                         (kgo.get_properties ());
 
             // if no pos yet, delay adding menu until after other menus
             int pos = kprop.get_position ();
             if (pos <= 0)
-              delayed_menus.push_back ((len - (ii + 1))); 
+              delayed_menus.push_back ((len - (ii + 1)));
             else
              {
                add_to_menu (kprop);
              }
           }
       }
 
     // create any delayed menus
@@ -623,17 +623,17 @@ public:
         if (kgo.valid_object ())
           {
             uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
                                         (kgo.get_properties ());
 
             // if no pos yet, delay adding menu until after other menus
             int pos = kprop.get_position ();
             if (pos <= 0)
-              delayed_menus.push_back ((len - (ii + 1))); 
+              delayed_menus.push_back ((len - (ii + 1)));
             else
              {
                add_to_menu (kprop);
                update_position (kprop, ++count);
              }
           }
       }
 
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -344,17 +344,17 @@ DEFUN_DLD (csymamd, args, nargout,
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, return the permutation\n\
 vector @var{p} such that @code{@var{S}(@var{p},@var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.\n\
 \n\
-Sometimes @code{csymamd} works well for symmetric indefinite matrices too.  \n\
+Sometimes @code{csymamd} works well for symmetric indefinite matrices too. \n\
 The matrix @var{S} is assumed to be symmetric; only the strictly lower\n\
 triangular part is referenced.  @var{S} must be square.  The ordering is\n\
 followed by an elimination tree post-ordering.\n\
 \n\
 @var{knobs} is an optional 1-element to 3-element input vector, with a\n\
 default value of @code{[10 1 0]}.  Entries not present are set to their\n\
 defaults.\n\
 \n\
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -456,17 +456,17 @@ DEFUN_DLD (symamd, args, nargout,
 @deftypefnx {Loadable Function} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, returns the permutation\n\
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.\n\
 \n\
-Sometimes @code{symamd} works well for symmetric indefinite matrices too.  \n\
+Sometimes @code{symamd} works well for symmetric indefinite matrices too. \n\
 The matrix @var{S} is assumed to be symmetric; only the strictly lower\n\
 triangular part is referenced.  @var{S} must be square.\n\
 \n\
 @var{knobs} is an optional one- to two-element input vector.  If @var{S} is\n\
 n-by-n, then rows and columns with more than\n\
 @code{max (16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
 and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -546,17 +546,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
                      H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
 #else
   gripe_save ("hdf5");
 #endif
-  
+
   return retval;
 }
 
 bool
 octave_sparse_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3076,17 +3076,17 @@ cdef_class::make_meta_class (tree_classd
                   // the property accessors so we can do validationby using
                   // cdef_property methods.
 
                   for (std::map<std::string, octave_value>::iterator ait = amap.begin ();
                        ait != amap.end (); ++ait)
                     prop.put (ait->first, ait->second);
 
                   // Install property access methods, if any. Remove the
-                  // accessor methods from the temporary storage map, so we can 
+                  // accessor methods from the temporary storage map, so we can
                   // detect which ones are invalid and do not correspond to a
                   // defined property.
 
                   std::map<std::string, octave_value>::iterator git =
                     get_methods.find (prop_name);
 
                   if (git != get_methods.end ())
                     {
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -860,17 +860,17 @@ octave_sparse_matrix::load_hdf5 (octave_
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
   gripe_load ("hdf5");
 #endif
-  
+
   return retval;
 }
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
   mwSize nr = rows ();
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1787,17 +1787,17 @@ DEFUN (struct, args, ,
 Create a scalar or array structure and initialize its values.\n\
 \n\
 The @var{field1}, @var{field2}, @dots{} variables are strings specifying the\n\
 names of the fields and the @var{value1}, @var{value2}, @dots{} variables\n\
 can be of any type.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize its\n\
 values.  The dimensions of each cell array of values must match.  Singleton\n\
-cells and non-cell values are repeated so that they fill the entire array.  \n\
+cells and non-cell values are repeated so that they fill the entire array. \n\
 If the cells are empty, create an empty structure array with the specified\n\
 field names.\n\
 \n\
 If the argument is an object, return the underlying struct.\n\
 \n\
 Observe that the syntax is optimized for struct @strong{arrays}.  Consider\n\
 the following examples:\n\
 \n\
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -131,17 +131,17 @@ DEFCONSTFUN (end, , ,
 @deftypefn {Built-in Function} {} end\n\
 The magic index @qcode{\"end\"} refers to the last valid entry in an indexing\n\
 operation.\n\
 \n\
 Example:\n\
 \n\
 @example\n\
 @group\n\
-@var{x} = [ 1 2 3 \n\
+@var{x} = [ 1 2 3\n\
       4 5 6 ];\n\
 @var{x}(1,end)\n\
     @result{} 3\n\
 @var{x}(end,1)\n\
     @result{} 4\n\
 @var{x}(end,end)\n\
     @result{} 6\n\
 @end group\n\
diff --git a/scripts/audio/@audiorecorder/play.m b/scripts/audio/@audiorecorder/play.m
--- a/scripts/audio/@audiorecorder/play.m
+++ b/scripts/audio/@audiorecorder/play.m
@@ -17,20 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{player} =} play (@var{recorder})
 ## @deftypefnx {Function File} {@var{player} =} play (@var{recorder}, @var{start})
 ## @deftypefnx {Function File} {@var{player} =} play (@var{recorder}, [@var{start}, @var{end}])
 ## Play the audio recorded in @var{recorder} and return a corresponding
 ## audioplayer object.
-## 
+##
 ## If the optional argument @var{start} is provided, begin playing
 ## @var{start} seconds in to the recording.
-## 
+##
 ## If the optional argument @var{end} is provided, stop playing at
 ## @var{end} seconds in the recording.
 ## @end deftypefn
 
 function player = play (varargin)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{fs}, @var{filename})
 ## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{fs}, @var{nbits}, @var{filename})
 ## Write the audio signal @var{y} to the RIFF/WAVE sound file @var{filename}.
 ##
 ## If @var{y} is a matrix, the columns represent multiple audio channels.
 ##
 ## The optional argument @var{fs} specifies the sample rate of the audio signal
 ## in Hz.
-## 
+##
 ## The optional argument @var{nbits} specifies the number of bits per sample
 ## to write to @var{filename}.
 ##
 ## The default sample rate is 8000 Hz and the default bit depth is 16 bits
 ## per sample.
 ##
 ## @seealso{audiowrite, audioread, wavread}
 ## @end deftypefn
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{C})
 ## @deftypefnx {Function File} {@var{S} =} cart2sph (@dots{})
 ## Transform Cartesian coordinates to spherical coordinates.
 ##
 ## The inputs @var{x}, @var{y}, and @var{z} must be the same shape, or scalar.
 ## If called with a single matrix argument then each row of @var{C} represents
 ## the Cartesian coordinate (@var{x}, @var{y}, @var{z}).
-## 
+##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ##
 ## @var{phi} is the angle relative to the xy-plane.
 ##
 ## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ##
 ## If only a single return argument is requested then return a matrix @var{S}
 ## where each row represents one spherical coordinate
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -76,17 +76,17 @@ function [in, on] = inpolygon (x, y, xv,
     idx2 = (((yv(i) <= y & y <= yv(j)) | (yv(j) <= y & y <= yv(i)))
             & ((xv(i) <= x & x <= xv(j)) | (xv(j) <= x & x <= xv(i)))
             & (0 == distance | !delta_xv));
     on(idx2) = true;
 
     j = i;
   endfor
 
-  ## Matlab definition include both in polygon and on polygon points. 
+  ## Matlab definition include both in polygon and on polygon points.
   in |= on;
 
 endfunction
 
 
 %!demo
 %! xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
 %!        1.94545, 2.16477, 1.87639, 1.18218, 0.27615, ...
diff --git a/scripts/gui/listdlg.m b/scripts/gui/listdlg.m
--- a/scripts/gui/listdlg.m
+++ b/scripts/gui/listdlg.m
@@ -117,17 +117,17 @@ function [sel, ok] = listdlg (varargin)
   ## make sure prompt strings are a cell array
   if (! iscell (prompt))
     prompt = {prompt};
   endif
 
   ## make sure listcell strings are a cell array
   if (! iscell (listcell))
     listcell = {listcell};
-  elseif (iscellstr (listcell{1})) 
+  elseif (iscellstr (listcell{1}))
     listcell = listcell{1};
   endif
 
   ## make sure valid selection mode
   if (! strcmpi (selmode, "multiple") && ! strcmpi (selmode, "single"))
     error ("listdlg: invalid SelectionMode");
   endif
 
diff --git a/scripts/gui/msgbox.m b/scripts/gui/msgbox.m
--- a/scripts/gui/msgbox.m
+++ b/scripts/gui/msgbox.m
@@ -32,17 +32,17 @@
 ## The optional argument @var{icon} selects a dialog icon.
 ## It can be one of @qcode{"none"} (default), @qcode{"error"}, @qcode{"help"},
 ## or @qcode{"warn"}.
 ##
 ## The return value is always 1.
 ##
 ## Compatibility Note: The optional argument @var{createmode} is accepted for
 ## @sc{matlab} compatibility, but is not implemented.
-## 
+##
 ## @seealso{errordlg, helpdlg, inputdlg, listdlg, questdlg, warndlg}
 ## @end deftypefn
 
 function retval = msgbox (msg, title = "", varargin)
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
diff --git a/scripts/gui/private/message_dialog.m b/scripts/gui/private/message_dialog.m
--- a/scripts/gui/private/message_dialog.m
+++ b/scripts/gui/private/message_dialog.m
@@ -63,17 +63,17 @@ function retval = message_dialog (caller
     endif
     switch (createmode)
       case {"nonmodal", "non-modal", "modal", "replace"}
         warning ("%s: %s is not yet supported", caller, createmode);
       otherwise
         error ("%s: CREATEMODE is not a valid type", caller);
     endswitch
   endif
-  
+
   if (__octave_link_enabled__ ())
     retval = __octave_link_message_dialog__ (icon, msg, title);
   elseif (__have_feature__ ("JAVA"))
     retval = javaMethod (dlg, "org.octave.JDialogBox", msg, title);
   else
     error ("%s is not available in this version of Octave", dlg);
   endif
 
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{text} =} get_first_help_sentence (@var{name})
 ## @deftypefnx {Function File} {@var{text} =} get_first_help_sentence (@var{name}, @var{max_len})
 ## @deftypefnx {Function File} {[@var{text}, @var{status}] =} get_first_help_sentence (@dots{})
 ## Return the first sentence of a function's help text.
 ##
 ## The first sentence is defined as the text after the function declaration
 ## until either the first period (".") or the first appearance of two
-## consecutive newlines ("\n\n").  The text is truncated to a maximum length of 
+## consecutive newlines ("\n\n").  The text is truncated to a maximum length of
 ## @var{max_len}, which defaults to 80.
 ##
 ## The optional output argument @var{status} returns the status reported by
 ## @code{makeinfo}.  If only one output argument is requested, and @var{status}
 ## is nonzero, a warning is displayed.
 ##
 ## As an example, the first sentence of this help text is
 ##
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Command} {} lookfor -all @var{str}
 ## @deftypefnx {Function File} {[@var{fcn}, @var{help1str}] =} lookfor (@var{str})
 ## @deftypefnx {Function File} {[@var{fcn}, @var{help1str}] =} lookfor ("-all", @var{str})
 ## Search for the string @var{str} in the documentation of all functions in the
 ## current function search path.
 ##
 ## By default, @code{lookfor} looks for @var{str} in just the first sentence of
 ## the help string for each function found.  The entire help text of each
-## function can be searched by using the @qcode{"-all"} argument.  All searches 
+## function can be searched by using the @qcode{"-all"} argument.  All searches
 ## are case insensitive.
 ##
 ## When called with no output arguments, @code{lookfor} prints the list of
 ## matching functions to the terminal.  Otherwise, the output argument
 ## @var{fcns} contains the function names and @var{help1str} contains the first
 ## sentence from the help string of each function.
 ##
 ## Programming Note: The ability of @code{lookfor} to correctly identify the
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -32,17 +32,17 @@
 ## an empty matrix is passed for @var{limits}, the display range is computed
 ## as the range between the minimal and the maximal value in the image.
 ##
 ## If @var{map} is a valid color map, the image will be shown as an indexed
 ## image using the supplied color map.
 ##
 ## If a file name is given instead of an image, the file will be read and shown.
 ##
-## If given, the parameter @var{string_param1} has value @var{value1}.  
+## If given, the parameter @var{string_param1} has value @var{value1}.
 ## @var{string_param1} can be any of the following:
 ##
 ## @table @asis
 ## @item @qcode{"displayrange"}
 ## @var{value1} is the display range as described above.
 ##
 ## @item @qcode{"colormap"}
 ## @var{value1} is the colormap to use when displaying an indexed image.
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -144,17 +144,17 @@
 ## If false (0), return an error.
 ##
 ## @item @qcode{"whitespace"}
 ## Any character in @var{value} will be interpreted as whitespace and trimmed;
 ## the string defining whitespace must be enclosed in double quotes for proper
 ## processing of special characters like @qcode{"@xbackslashchar{}t"}.  The
 ## default value for whitespace is
 ## @c Note: the next line specifically has a newline which generates a space
-## @c       in the output of qcode, but keeps the next line < 80 characters. 
+## @c       in the output of qcode, but keeps the next line < 80 characters.
 ## @qcode{"
 ## @xbackslashchar{}b@xbackslashchar{}r@xbackslashchar{}n@xbackslashchar{}t"}
 ## (note the space).  Unless whitespace is set to @qcode{""} (empty) AND at
 ## least one @qcode{"%s"} format conversion specifier is supplied, a space is
 ## always part of whitespace.
 ##
 ## @end table
 ##
diff --git a/scripts/java/javamem.m b/scripts/java/javamem.m
--- a/scripts/java/javamem.m
+++ b/scripts/java/javamem.m
@@ -45,17 +45,17 @@
 ##
 ## @nospell{-Xmx512m}
 ##
 ## (in megabytes in this example).
 ## You can adapt these values to your own requirements if your system has
 ## limited available physical memory or if you get Java memory errors.
 ##
 ## @qcode{"Total memory"} is what the operating system has currently assigned
-## to the JVM and depends on actual and active memory usage.  
+## to the JVM and depends on actual and active memory usage.
 ## @qcode{"Free memory"} is self-explanatory.  During operation of Java-based
 ## Octave functions the amount of Total and Free memory will vary, due to
 ## Java's own cleaning up and your operating system's memory management.
 ## @end deftypefn
 
 ## Author: Philip Nienhuis
 ## Created: 2010-03-25
 ## Updates:
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -51,17 +51,17 @@
 ## than a single directory or file.
 ##
 ## @var{directory} is subject to shell expansion if it contains any wildcard
 ## characters @samp{*}, @samp{?}, @samp{[]}.  To find a literal example of a
 ## wildcard character the wildcard must be escaped using the backslash operator
 ## @samp{\}.
 ##
 ## Note that for symbolic links, @code{dir} returns information about the
-## file that the symbolic link points to rather than the link itself. 
+## file that the symbolic link points to rather than the link itself.
 ## However, if the link points to a nonexistent file, @code{dir} returns
 ## information about the link.
 ## @seealso{ls, readdir, glob, what, stat, lstat}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## FIXME: This is quite slow for large directories.
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -57,26 +57,26 @@
 ## is available.  If you are editing a .cc file, you will need to execute
 ## @code{mkoctfile @file{@var{name}.cc}} before the definition will be
 ## available.
 ## @end itemize
 ##
 ## If @code{edit} is called with @var{field} and @var{value} variables, the
 ## value of the control field @var{field} will be set to @var{value}.  If an
 ## output argument is requested and the first input argument is @code{get}
-## then @code{edit} will return the value of the control field @var{field}. 
+## then @code{edit} will return the value of the control field @var{field}.
 ## If the control field does not exist, edit will return a structure
 ## containing all fields and values.  Thus, @code{edit get all} returns a
 ## complete control structure.
 ##
 ## The following control fields are used:
 ##
 ## @table @samp
 ## @item home
-## This is the location of user local m-files.  Be sure it is in your path. 
+## This is the location of user local m-files.  Be sure it is in your path.
 ## The default is @file{~/octave}.
 ##
 ## @item author
 ## This is the name to put after the "## Author:" field of new functions.  By
 ## default it guesses from the @code{gecos} field of the password database.
 ##
 ## @item email
 ## This is the e-mail address to list after the name in the author field.  By
diff --git a/scripts/miscellaneous/genvarname.m b/scripts/miscellaneous/genvarname.m
--- a/scripts/miscellaneous/genvarname.m
+++ b/scripts/miscellaneous/genvarname.m
@@ -43,17 +43,17 @@
 ## @group
 ## x = 3.141;
 ## genvarname ("x", who ())
 ##   @result{} x1
 ## @end group
 ## @end example
 ##
 ## Note that the result is a char array or cell array of strings, not the
-## variables themselves.  To define a variable, @code{eval()} can be used. 
+## variables themselves.  To define a variable, @code{eval()} can be used.
 ## The following trivial example sets @code{x} to @code{42}.
 ##
 ## @example
 ## @group
 ## name = genvarname ("x");
 ## eval ([name " = 42"]);
 ##   @result{} x =  42
 ## @end group
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -25,17 +25,17 @@
 ## in the filename such as @samp{*} or @samp{?} are accepted and expanded.
 ## Each file is compressed separately and a new file with a @file{".gz"}
 ## extension is created.  The original files are not modified, but existing
 ## compressed files will be silently overwritten.  If a directory is
 ## specified then @code{gzip} recursively compresses all files in the
 ## directory.
 ##
 ## If @var{dir} is defined the compressed files are placed in this directory,
-## rather than the original directory where the uncompressed file resides. 
+## rather than the original directory where the uncompressed file resides.
 ## If @var{dir} does not exist it is created.
 ##
 ## The optional output @var{filelist} is a list of the compressed files.
 ## @seealso{gunzip, unpack, bzip2, zip, tar}
 ## @end deftypefn
 
 function filelist = gzip (varargin)
 
diff --git a/scripts/miscellaneous/private/__w2mpth__.m b/scripts/miscellaneous/private/__w2mpth__.m
--- a/scripts/miscellaneous/private/__w2mpth__.m
+++ b/scripts/miscellaneous/private/__w2mpth__.m
@@ -11,17 +11,17 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{mingwpath} =} __w2mpth__ (@var{winpath})
 ## Convert a Windows-style relative or full path name to MinGW style.
 ##
 ## @strong{Caution:} __w2mpth__ does not check the validity of the path.
 ##
 ## Examples:
 ##
 ## @example
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -362,41 +362,41 @@ function h = buildannot (hax, objtype, p
       hli = line ([pos(1); (pos(1) + pos(3))],
                   [pos(2); (pos(2) + pos(4))],
                   "parent", h, "color", get (h, "color"),
                   "linestyle", get (h, "linestyle"),
                   "linewidth", get (h, "linewidth"));
 
       linemenu (hui, h);
       set (hli, "uicontextmenu", hui);
-      
+
       ## create patch(s) and text
       if (strcmp (objtype, "arrow"))
         [x, y] = arrowcoordinates (h);
         hpa = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
         update_arrow (h, {}, "position", hpa);
-        
+
         arrowmenu (hui, h);
         set (hpa, "uicontextmenu", hui);
-        
+
       elseif (strcmp (objtype, "doublearrow"))
         [x, y] = arrowcoordinates (h, 1);
         hpa = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
 
         [x, y] = arrowcoordinates (h, 2);
         hpa(2) = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
 
         update_arrow (h, {}, "position", hpa);
-        
+
         dblarrowmenu (hui, h);
         set (hpa, "uicontextmenu", hui);
-        
+
       elseif (strcmp (objtype, "textarrow"))
         [x, y] = arrowcoordinates (h);
         hpa = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
         update_arrow (h, {}, "position", hpa);
 
         hte = text (get (h, "position")(1), ...
                    get (h, "position")(2), ...
@@ -407,17 +407,17 @@ function h = buildannot (hax, objtype, p
           update_text (h, {}, propnames{ii}, hte);
         endfor
         update_text (h, {}, "position", hte);
 
         arrowmenu (hui, h);
         textmenu (hui, h);
         set (hpa, "uicontextmenu", hui);
         set (hte, "uicontextmenu", hui);
-        
+
       endif
 
       ## updaters
       addlistener (h, "color", {@update_line, "color", hli});
       addlistener (h, "linestyle", {@update_line, "linestyle", hli});
       addlistener (h, "linewidth", {@update_line, "linewidth", hli});
       addlistener (h, "x", {@update_line, "x", hli});
       addlistener (h, "y", {@update_line, "y", hli});
@@ -508,17 +508,17 @@ function h = buildannot (hax, objtype, p
       hte = text (pos(1), pos(2), get (h, "string"), "parent", h, ...
                  "color", get (h, "color"));
       update_textbox (h, {}, "position", [hte hpa]);
 
       propnames = textboxprops ("names");
       for ii = 1:numel (propnames)
         update_textbox (h, {}, propnames{ii}, [hte hpa]);
       endfor
-      
+
       textboxmenu (hui, h);
       set (hpa, "uicontextmenu", hui);
       set (hte, "uicontextmenu", hui);
 
       ## Updaters
       addlistener (h, "position", {@update_textbox, "position", [hte hpa]});
       for ii = 1:numel (propnames)
         addlistener (h, propnames{ii},
@@ -529,17 +529,17 @@ function h = buildannot (hax, objtype, p
       addlistener (h, "verticalalignment",
                    {@update_textbox, "position", [hte hpa]});
 
   endswitch
 
 endfunction
 
 function props = lineprops (varargin)
-  ## FIXME: Use "axesx(y)lim" instead of "linex(y)data" 
+  ## FIXME: Use "axesx(y)lim" instead of "linex(y)data"
   props = {"color", "color", [0 0 0], ...
            "linestyle",  "linelinestyle", "-", ...
            "linewidth", "linelinewidth", 0.5, ...
            "x", "linexdata", [0.3 0.4], ...
            "y", "lineydata", [0.3 0.4]};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
@@ -547,21 +547,21 @@ endfunction
 
 function col = basecolors ()
   col = {"blue", "black", "cyan", "green", "magenta", "red", ...
          "white", "yellow", "none"};
 endfunction
 
 function linemenu (hui, hpar)
   hm = uimenu ("parent", hui, "label", "Line");
-  
+
   ## Color
   vals = basecolors ();
   addbasemenu (hm, hpar, "Color", vals);
-  
+
 
   ## Linestyle
   vals = set (hpar, "linestyle");
   addbasemenu (hm, hpar, "Linestyle", vals);
 
   ## Linewidth
   vals = [0.5 1 1.5 2];
   addbasemenu (hm, hpar, "Linewidth", vals);
@@ -573,17 +573,17 @@ function props = arrowprops (varargin)
            "headwidth",  "data", 10};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
 endfunction
 
 function arrowmenu (hui, hpar)
   hm = uimenu ("parent", hui, "label", "Arrowhead");
-  
+
   ## Headlength/width
   vals = 6:2:16;
   addbasemenu (hm, hpar, "headlength", vals, "Length");
   addbasemenu (hm, hpar, "headwidth", vals, "Width");
 
   ## Headstyle
   vals = set (hpar, "headstyle");
   addbasemenu (hm, hpar, "Headstyle", vals);
@@ -599,17 +599,17 @@ function props = dblarrowprops (varargin
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
 endfunction
 
 function dblarrowmenu (hui, hpar)
   hm1 = uimenu ("parent", hui, "label", "Arrowhead #1");
   hm2 = uimenu ("parent", hui, "label", "Arrowhead #2");
-  
+
   ## Headlength/width
   vals = 6:2:16;
   addbasemenu (hm1, hpar, "head1length", vals, "Length");
   addbasemenu (hm1, hpar, "head1width", vals, "Width");
   addbasemenu (hm2, hpar, "head2length", vals, "Length");
   addbasemenu (hm2, hpar, "head2width", vals, "Width");
 
   ## Headstyle
@@ -643,59 +643,59 @@ function stringdlg (hpar, prop)
   def = get (hpar, prop);
   if (iscell (def))
     prompt = arrayfun (@(n) sprintf ("Line #%d:", n), 1:numel (def),
                        "uniformoutput", false);
   else
     prompt = "";
     def = {def};
   endif
-  
+
   cstr = inputdlg (prompt, prop, 1, def);
-  
+
   if (! isempty (cstr))
     set (hpar, prop, cstr)
   endif
 endfunction
 
 function textmenu (hui, hpar)
   hm = uimenu ("parent", hui, "label", "Text");
 
   ## String;
   prop = "String";
   fcn = @() stringdlg (hpar, prop);
   uimenu (hm, "label", prop, "callback", fcn);
-  
+
   ## Font properties
   prop = "textcolor";
   vals = basecolors ();
   addbasemenu (hm, hpar, prop, vals, "Color");
   prop = "fontsize";
   vals = 8:2:20;
   addbasemenu (hm, hpar, prop, vals, "Size");
   prop = "fontangle";
   vals = set (hpar, prop);
   addbasemenu (hm, hpar, prop, vals, "Angle");
   prop = "fontweight";
   vals = set (hpar, prop);
   addbasemenu (hm, hpar, prop, vals, "Weight");
   prop = "textrotation";
   vals = 0:90:270;
   addbasemenu (hm, hpar, prop, vals, "Rotation");
-  
+
   prop = "horizontalalignment";
   vals = set (hpar, prop);
   addbasemenu (hm, hpar, prop, vals, "Horizontal Alignment", ...
                "separator", "on");
   prop = "verticalalignment";
   vals = set (hpar, prop);
   addbasemenu (hm, hpar, prop, vals, "Vertical Alignment");
 
   ## FIXME: Add text background properties when they are supported
-  
+
   prop = "interpreter";
   vals = set (hpar, prop);
   addbasemenu (hm, hpar, prop, vals, "Interpreter", ...
                "separator", "on");
 
 endfunction
 
 function props = textboxprops (varargin)
@@ -719,53 +719,53 @@ function props = textboxprops (varargin)
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
 endfunction
 
 function textboxmenu (hui, hpar)
   ## Text properties
   hm1 = uimenu ("parent", hui, "label", "Text");
-  
+
   prop = "String";
   fcn = @() stringdlg (hpar, prop);
   uimenu (hm1, "label", prop, "callback", fcn);
-  
+
   prop = "Color";
   vals = basecolors ();
   addbasemenu (hm1, hpar, prop, vals);
   prop = "fontsize";
   vals = 8:2:20;
   addbasemenu (hm1, hpar, prop, vals, "Size");
   prop = "fontangle";
   vals = set (hpar, prop);
   addbasemenu (hm1, hpar, prop, vals, "Angle");
   prop = "fontweight";
   vals = set (hpar, prop);
   addbasemenu (hm1, hpar, prop, vals, "Weight");
-  
+
   prop = "horizontalalignment";
   vals = set (hpar, prop);
   addbasemenu (hm1, hpar, prop, vals, "Horizontal Alignment", ...
                "separator", "on");
   prop = "verticalalignment";
   vals = set (hpar, prop);
   addbasemenu (hm1, hpar, prop, vals, "Vertical Alignment");
   prop = "Margin";
   vals = 2:2:10;
   addbasemenu (hm1, hpar, prop, vals);
-  
+
   prop = "interpreter";
   vals = set (hpar, prop);
   addbasemenu (hm1, hpar, prop, vals, "Interpreter", ...
                "separator", "on");
 
   ## Background properties
   hm2 = uimenu ("parent", hui, "label", "Background");
-  
+
   prop = "fitboxtotext";
   vals = set (hpar, prop);
   addbasemenu (hm2, hpar, prop, vals, "Fit box to text");
   prop = "backgroundcolor";
   vals = basecolors ();
   addbasemenu (hm2, hpar, prop, vals, "Face Color");
   prop = "edgecolor";
   vals = basecolors ();
@@ -808,44 +808,44 @@ function addbaseprops (h, proptable)
   cellfun (@(pname, ptype, parg) addproperty (pname, h, ptype, parg),
            proptable(1:3:end), proptable(2:3:end), proptable(3:3:end));
 endfunction
 
 function addbasemenu (hm, hpar, pname, vals, mainlabel = "" )
   if (isempty (mainlabel))
     mainlabel = pname;
   endif
-  
+
   h = uimenu ("parent", hm, "label", mainlabel);
 
   is_numeric = ! iscell (vals);
   nv = numel (vals);
   htmp = zeros (1, nv);
   for ii = 1:nv
     if (! is_numeric)
       val = label = vals{ii};
     else
       val = vals(ii);
       label = num2str (val);
     endif
-    
+
     fcn = @() set (hpar, pname, val);
     htmp(ii) = uimenu (h, "label", label, "callback", fcn);
   endfor
   handle_check (hpar, {}, htmp, pname, is_numeric);
   addlistener (hpar, pname, {@handle_check, htmp, pname, is_numeric})
 endfunction
 
 function handle_check (h, dummy, hmenus, prop, is_numeric)
   vals = get (hmenus, "label");
   current = get (h, prop);
   if (is_numeric)
     current = num2str (current);
   endif
-  
+
   idx = strcmp (vals, current);
   set (hmenus(idx), "checked", "on");
   set (hmenus(! idx), "checked", "off");
 endfunction
 
 function update_position (h1, dummy, h, force = false)
   if (! force)
     pos = convertposition (h, getappdata (h, "__former_units__"),
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -175,17 +175,17 @@ function h = colorbar (varargin)
   if (! deleting)
     ## FIXME: Matlab does not require the "position" property to be active.
     ##        Is there a way to determine the plotbox position for the
     ##        gnuplot graphics toolkit with the outerposition is active?
     set (ax, "activepositionproperty", "position");
     obj = get (ax);
     obj.__cbar_hax__ = ax;
     position = obj.position;
-    
+
     hpar = ancestor (ax, "figure");
     clen = rows (get (hpar, "colormap"));
     cext = get (ax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     [pos, cpos, vertical, mirror] = ...
diff --git a/scripts/plot/draw/quiver3.m b/scripts/plot/draw/quiver3.m
--- a/scripts/plot/draw/quiver3.m
+++ b/scripts/plot/draw/quiver3.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {} quiver3 (@var{x}, @var{y}, @var{z}, @var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, "filled")
 ## @deftypefnx {Function File} {} quiver3 (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver3 (@dots{})
 ##
 ## Plot a 3-D vector field with arrows.
-## 
+##
 ## Plot the (@var{u}, @var{v}, @var{w}) components of a vector field in
 ## an (@var{x}, @var{y}, @var{z}) meshgrid.  If the grid is uniform then
 ## @var{x}, @var{y}, and @var{z} can be specified as vectors.
 ##
 ## If @var{x}, @var{y}, and @var{z} are undefined they are assumed to be
 ## @code{(1:@var{m}, 1:@var{n}, 1:@var{p})} where @code{[@var{m}, @var{n}] =
 ## size (@var{u})} and @code{@var{p} = max (size (@var{w}))}.
 ##
diff --git a/scripts/plot/util/hold.m b/scripts/plot/util/hold.m
--- a/scripts/plot/util/hold.m
+++ b/scripts/plot/util/hold.m
@@ -51,17 +51,17 @@
 ## @seealso{ishold, cla, clf, newplot}
 ## @end deftypefn
 
 function hold (varargin)
 
   if (nargin > 0 && isscalar (varargin{1}) && isaxes (varargin{1}))
     hax = varargin{1};
     varargin(1) = [];
-    nargs = numel (varargin);    
+    nargs = numel (varargin);
     hfig = ancestor (hax, "figure");
   elseif (nargin > 0 && numel (varargin{1}) > 1 && ishandle (varargin{1}))
     print_usage ();
   else
     hax = gca ();
     hfig = gcf ();
     nargs = numel (varargin);
   endif
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -74,17 +74,17 @@
 ## orientation specified.  This option is equivalent to changing the figure's
 ## @qcode{"paperorientation"} property.
 ##
 ## @item  -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
 ## vector formats by using Ghostscript.  For bitmap and printer output
 ## anti-aliasing is applied using Ghostscript's TextAlphaBits and
-## GraphicsAlphaBits options.  The default number of bits for each is 4. 
+## GraphicsAlphaBits options.  The default number of bits for each is 4.
 ## Allowed values for @var{N} are 1, 2, or 4.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device}, and
 ## is one of:
 ##
 ##   @table @code
 ##   @item  ps
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs}, @var{d})
 ##
 ## Construct a piecewise polynomial (pp) structure from sample points
 ## @var{breaks} and coefficients @var{coefs}.
 ##
 ## @var{breaks} must be a vector of strictly increasing values.  The number of
 ## intervals is given by @code{@var{ni} = length (@var{breaks}) - 1}.
-## 
+##
 ## When @var{m} is the polynomial order @var{coefs} must be of size:
 ## @var{ni} x @var{m} + 1.
 ##
 ## The i-th row of @var{coefs}, @code{@var{coefs} (@var{i},:)}, contains the
 ## coefficients for the polynomial over the @var{i}-th interval, ordered from
 ## highest (@var{m}) to lowest (@var{0}).
 ##
 ## @var{coefs} may also be a multi-dimensional array, specifying a vector-valued
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} polyder (@var{p})
 ## @deftypefnx {Function File} {[@var{k}] =} polyder (@var{a}, @var{b})
 ## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyder (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by the vector @var{p}.
 ##
 ## If a pair of polynomials is given, return the derivative of the product
 ## @math{@var{a}*@var{b}}.
-## 
+##
 ## If two inputs and two outputs are given, return the derivative of the
 ## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
 ## in @var{q} and the denominator in @var{d}.
 ## @seealso{polyint, polyval, polyreduce}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -30,17 +30,17 @@
 ## at the points @var{xi}.  The third calling form
 ## @code{spline (@var{x}, @var{y}, @var{xi})} is equivalent to
 ## @code{ppval (spline (@var{x}, @var{y}), @var{xi})}.
 ##
 ## The variable @var{x} must be a vector of length @var{n}.
 ##
 ## @var{y} can be either a vector or array.  If @var{y} is a vector it must
 ## have a length of either @var{n} or @code{@var{n} + 2}.  If the length of
-## @var{y} is @var{n}, then the @qcode{"not-a-knot"} end condition is used. 
+## @var{y} is @var{n}, then the @qcode{"not-a-knot"} end condition is used.
 ## If the length of @var{y} is @code{@var{n} + 2}, then the first and last
 ## values of the vector @var{y} are the values of the first derivative of the
 ## cubic spline at the endpoints.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -24,17 +24,17 @@
 ## The components are:
 ##
 ## @table @asis
 ## @item @var{x}
 ## Sample points.
 ##
 ## @item @var{p}
 ## Polynomial coefficients for points in sample interval.
-## @code{@var{p} (@var{i}, :)} contains the coefficients for the polynomial 
+## @code{@var{p} (@var{i}, :)} contains the coefficients for the polynomial
 ## over interval @var{i} ordered from highest to lowest.  If
 ## @code{@var{d} > 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the
 ## coefficients for the r-th polynomial defined on interval @var{i}.
 ##
 ## @item @var{n}
 ## Number of polynomial pieces.
 ##
 ## @item @var{k}
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -26,17 +26,17 @@
 ## @group
 ## x(n) = a(1) * x(n-1) + @dots{} + a(k) * x(n-k)
 ##      + e(n) + b(1) * e(n-1) + @dots{} + b(l) * e(n-l)
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## in which @var{k} is the length of vector @var{a}, @var{l} is the length of
-## vector @var{b} and @var{e} is Gaussian white noise with variance @var{v}. 
+## vector @var{b} and @var{e} is Gaussian white noise with variance @var{v}.
 ## The function returns a vector of length @var{t}.
 ##
 ## The optional parameter @var{n} gives the number of dummy @var{x}(@var{i})
 ## used for initialization, i.e., a sequence of length @var{t}+@var{n} is
 ## generated and @var{x}(@var{n}+1:@var{t}+@var{n}) is returned.  If @var{n}
 ## is omitted, @var{n} = 100 is used.
 ## @end deftypefn
 
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {} gplot (@var{A}, @var{xy}, @var{line_style})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}] =} gplot (@var{A}, @var{xy})
 ## Plot a graph defined by @var{A} and @var{xy} in the graph theory sense.
 ##
 ## @var{A} is the adjacency matrix of the array to be plotted and @var{xy} is
 ## an @var{n}-by-2 matrix containing the coordinates of the nodes of the graph.
 ##
 ## The optional parameter @var{line_style} defines the output style for the
-## plot.  Called with no output arguments the graph is plotted directly. 
+## plot.  Called with no output arguments the graph is plotted directly.
 ## Otherwise, return the coordinates of the plot in @var{x} and @var{y}.
 ## @seealso{treeplot, etreeplot, spy}
 ## @end deftypefn
 
 function [x, y] = gplot (A, xy, line_style)
 
   if (nargin < 2 || nargin > 3 || nargout > 2)
     print_usage ();
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -25,17 +25,17 @@
 ## Under the null, the test statistic @var{t} follows a Student distribution
 ## with @code{@var{df} = length (@var{x}) - 1} degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of interest
 ## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
 ## is tested against the two-sided alternative @code{mean (@var{x}) !=
 ## @var{m}}.  If @var{alt} is @qcode{">"}, the one-sided alternative
 ## @code{mean (@var{x}) > @var{m}} is considered.  Similarly for @var{"<"},
-## the one-sided alternative @code{mean (@var{x}) < @var{m}} is considered. 
+## the one-sided alternative @code{mean (@var{x}) < @var{m}} is considered.
 ## The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -26,17 +26,17 @@
 ## with @var{df} degrees of freedom.
 ##
 ## If @var{r} is omitted, a value of 0 is assumed.
 ##
 ## With the optional argument string @var{alt}, the alternative of interest
 ## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
 ## is tested against the two-sided alternative @nospell{@code{@var{rr} *
 ## @var{b} != @var{r}}}.  If @var{alt} is @qcode{">"}, the one-sided
-## alternative @nospell{@code{@var{rr} * @var{b} > @var{r}}} is used. 
+## alternative @nospell{@code{@var{rr} * @var{b} > @var{r}}} is used.
 ## Similarly for @var{"<"}, the one-sided alternative @nospell{@code{@var{rr}
 ## * @var{b} < @var{r}}} is used.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -22,17 +22,17 @@
 ## Format real, complex, and logical matrices as strings.
 ##
 ## The returned string may be used to reconstruct the original matrix by using
 ## the @code{eval} function.
 ##
 ## The precision of the values is given by @var{n}.  If @var{n} is a scalar
 ## then both real and imaginary parts of the matrix are printed to the same
 ## precision.  Otherwise @code{@var{n}(1)} defines the precision of the real
-## part and @code{@var{n}(2)} defines the precision of the imaginary part. 
+## part and @code{@var{n}(2)} defines the precision of the imaginary part.
 ## The default for @var{n} is 15.
 ##
 ## If the argument @qcode{"class"} is given then the class of @var{x} is
 ## included in the string in such a way that @code{eval} will result in the
 ## construction of a matrix of the same class.
 ##
 ## @example
 ## @group
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -177,19 +177,19 @@ function [cstr, matches] = strsplit (str
 
   if (! ischar (str) || (! ischar (del) && ! iscellstr (del)))
     error ("strsplit: S and DEL must be string values");
   elseif (! isscalar (args.collapsedelimiters))
     error ("strsplit: COLLAPSEDELIMITERS must be a scalar value");
   endif
 
   if (strncmpi (args.delimitertype, "simple", length_deltype))
-    is_simple = true; 
+    is_simple = true;
   elseif (strncmpi (args.delimitertype, "regularexpression", length_deltype))
-    is_simple = false; 
+    is_simple = false;
   else
     error ("strsplit:invalid_delimitertype", "strsplit: Invalid DELIMITERTYPE");
   endif
 
   if (is_simple)
     if (iscellstr (del))
       del = cellfun (@do_string_escapes, del, "uniformoutput", false);
     else
@@ -293,18 +293,18 @@ endfunction
 
 ## Compatibility
 %! assert (strsplit ("", "a"), {""})
 %! assert (strsplit ("a", "a"), {"", ""})
 %! assert (strsplit ("aa", "a"), {"", ""})
 %! assert (strsplit ("aaa", "a"), {"", ""})
 
 ## Bug #44641
-%!assert (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"}) 
-%!assert (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"}) 
+%!assert (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
+%!assert (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
 
 ## Test input validation
 %!error strsplit ()
 %!error strsplit ("abc", "b", true, 4)
 %!error <invalid parameter name, 'foo'> strsplit ("abc", "b", "foo", "true")
 %!error <S and DEL must be string values> strsplit (123, "b")
 %!error <COLLAPSEDELIMITERS must be a scalar value> strsplit ("abc", "def", "collapsedelimiters", ones (3,3))
 %!error <Invalid DELIMITERTYPE> strsplit ("abc", "b", "delimitertype", "foobar")
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strtrunc (@var{s}, @var{n})
 ## Truncate the character string @var{s} to length @var{n}.
 ##
 ## If @var{s} is a character matrix, then the number of columns is adjusted.
-## 
+##
 ## If @var{s} is a cell array of strings, then the operation is performed
 ## on each cell element and the new cell array is returned.
 ## @end deftypefn
 
 function s = strtrunc (s, n)
 
   if (nargin != 2)
     print_usage ();
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} untabify (@var{t})
 ## @deftypefnx {Function File} {} untabify (@var{t}, @var{tw})
 ## @deftypefnx {Function File} {} untabify (@var{t}, @var{tw}, @var{deblank})
 ## Replace TAB characters in @var{t} with spaces.
 ##
 ## The input, @var{t}, may be either a 2-D character array, or a cell array of
 ## character strings.  The output is the same class as the input.
-## 
+##
 ## The tab width is specified by @var{tw}, and defaults to eight.
 ##
 ## If the optional argument @var{deblank} is true, then the spaces will be
 ## removed from the end of the character data.
 ##
 ## The following example reads a file and writes an untabified version of the
 ## same file with trailing spaces stripped.
 ##
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -43,20 +43,20 @@
 ## Produce an error if observed is not the same as expected.
 ##
 ## Note that @var{observed} and @var{expected} can be scalars, vectors,
 ## matrices, strings, cell arrays, or structures.
 ##
 ## @item assert (@var{observed}, @var{expected}, @var{tol})
 ## Produce an error if observed is not the same as expected but equality
 ## comparison for numeric data uses a tolerance @var{tol}.
-## 
+##
 ## If @var{tol} is positive then it is an absolute tolerance which will produce
 ## an error if @code{abs (@var{observed} - @var{expected}) > abs (@var{tol})}.
-## 
+##
 ## If @var{tol} is negative then it is a relative tolerance which will produce
 ## an error if @code{abs (@var{observed} - @var{expected}) >
 ## abs (@var{tol} * @var{expected})}.
 ##
 ## If @var{expected} is zero @var{tol} will always be interpreted as an
 ## absolute tolerance.
 ##
 ## If @var{tol} is not scalar its dimensions must agree with those of
