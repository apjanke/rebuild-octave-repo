# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453246998 28800
#      Tue Jan 19 15:43:18 2016 -0800
# Node ID 358aa7fcbd33a75258035afdc0c74ce4acc4f1c4
# Parent  7bb96a8df9122fd4ed12fdf092b3aa0b28d9c7db
Rename errwarn_singular_matrix to warn_singular_matrix.

* inv.cc, sparse-xdiv.cc, xdiv.cc, CMatrix.cc, CSparse.cc, dMatrix.cc,
dSparse.cc, fCMatrix.cc, fMatrix.cc, lo-array-errwarn.cc, lo-array-errwarn.h:
Rename errwarn_singular_matrix to warn_singular_matrix.

diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -201,17 +201,17 @@ sparse matrix if possible.\n\
     }
   else
     {
       volatile double xrcond = rcond;
       rcond_plus_one_eq_one = xrcond + 1.0 == 1.0;
     }
 
   if (nargout < 2 && (info == -1 || rcond_plus_one_eq_one))
-    errwarn_singular_matrix (isfloat ? frcond : rcond);
+    warn_singular_matrix (isfloat ? frcond : rcond);
 
   return retval;
 }
 
 /*
 %!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
 %!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
 
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "CSparse.h"
 #include "CDiagMatrix.h"
 #include "oct-spparms.h"
 #include "sparse-xdiv.h"
 
 static void
 solve_singularity_warning (double rcond)
 {
-  errwarn_singular_matrix (rcond);
+  warn_singular_matrix (rcond);
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -54,17 +54,17 @@ result_ok (octave_idx_type info)
   assert (info != -1);
 
   return (info != -2);
 }
 
 static void
 solve_singularity_warning (double rcond)
 {
-  errwarn_singular_matrix (rcond);
+  warn_singular_matrix (rcond);
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
   octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
@@ -398,17 +398,17 @@ xleftdiv (const ComplexMatrix& a, const 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 static void
 solve_singularity_warning (float rcond)
 {
-  errwarn_singular_matrix (rcond);
+  warn_singular_matrix (rcond);
 }
 
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatComplexMatrix);
 
 INSTANTIATE_MX_DIV_CONFORM (FloatMatrix, FloatMatrix);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -2008,17 +2008,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2103,17 +2103,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2188,17 +2188,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -2247,17 +2247,17 @@ ComplexMatrix::fsolve (MatrixType &matty
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -2275,17 +2275,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1794,32 +1794,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2077,32 +2077,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
@@ -2307,32 +2307,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2590,32 +2590,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2840,32 +2840,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3142,32 +3142,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3396,32 +3396,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3697,32 +3697,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3859,17 +3859,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
 
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -3956,17 +3956,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx (0) = 0;
@@ -4158,17 +4158,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4253,17 +4253,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
@@ -4422,17 +4422,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4507,17 +4507,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4540,17 +4540,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4664,17 +4664,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4782,17 +4782,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4815,17 +4815,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -4978,17 +4978,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5061,17 +5061,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5094,17 +5094,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5220,17 +5220,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5343,17 +5343,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5376,17 +5376,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5529,17 +5529,17 @@ SparseComplexMatrix::factorize (octave_i
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            errwarn_singular_matrix (rcond);
+            warn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseComplexMatrix::solve numeric factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
@@ -5679,17 +5679,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -5934,17 +5934,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6217,17 +6217,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6451,17 +6451,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6582,17 +6582,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               if (status == UMFPACK_WARNING_singular_matrix
                   || rcond_plus_one == 1.0 || xisnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1635,17 +1635,17 @@ Matrix::utsolve (MatrixType &mattype, co
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1729,17 +1729,17 @@ Matrix::ltsolve (MatrixType &mattype, co
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1812,17 +1812,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -1865,17 +1865,17 @@ Matrix::fsolve (MatrixType &mattype, con
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1893,17 +1893,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1878,32 +1878,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2161,32 +2161,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
@@ -2393,32 +2393,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2678,32 +2678,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2932,32 +2932,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3233,32 +3233,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3488,32 +3488,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3791,32 +3791,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix (rcond);
+                warn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3953,17 +3953,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4049,17 +4049,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
@@ -4251,17 +4251,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4345,17 +4345,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
@@ -4535,17 +4535,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4620,17 +4620,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4653,17 +4653,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4777,17 +4777,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4895,17 +4895,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4928,17 +4928,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5091,17 +5091,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5205,17 +5205,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5238,17 +5238,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5385,17 +5385,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5529,17 +5529,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5562,17 +5562,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        errwarn_singular_matrix (rcond);
+                        warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5724,17 +5724,17 @@ SparseMatrix::factorize (octave_idx_type
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            errwarn_singular_matrix (rcond);
+            warn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseMatrix::solve numeric factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
@@ -5876,17 +5876,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6104,17 +6104,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6358,17 +6358,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6604,17 +6604,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    errwarn_singular_matrix (rcond);
+                    warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -2000,17 +2000,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2095,17 +2095,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2180,17 +2180,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -2235,17 +2235,17 @@ FloatComplexMatrix::fsolve (MatrixType &
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -2263,17 +2263,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1647,17 +1647,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -1743,17 +1743,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1827,17 +1827,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -1880,17 +1880,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                errwarn_singular_matrix ();
+                warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1908,17 +1908,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        errwarn_singular_matrix (rcon);
+                        warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -304,17 +304,17 @@ void
 err_invalid_resize (void)
 {
   (*current_liboctave_error_with_id_handler)
     ("Octave:invalid-resize",
      "Invalid resizing operation or ambiguous assignment to an out-of-bounds array element");
 }
 
 void
-errwarn_singular_matrix (double rcond)
+warn_singular_matrix (double rcond)
 {
   if (rcond == 0.0)
     {
       (*current_liboctave_warning_with_id_handler)
         (warning_id_singular_matrix,
          "matrix singular to machine precision");
     }
   else
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
--- a/liboctave/util/lo-array-errwarn.h
+++ b/liboctave/util/lo-array-errwarn.h
@@ -147,11 +147,11 @@ OCTAVE_NORETURN OCTAVE_API extern
 void err_invalid_index (const std::string& idx, octave_idx_type nd = 0,
                         octave_idx_type dim = 0,
                         const std::string& var = "");
 
 OCTAVE_NORETURN OCTAVE_API extern
 void err_invalid_resize (void);
 
 OCTAVE_API extern
-void errwarn_singular_matrix (double rcond = 0.0);
+void warn_singular_matrix (double rcond = 0.0);
 
 #endif
