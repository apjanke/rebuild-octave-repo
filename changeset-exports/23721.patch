# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1498781814 14400
#      Thu Jun 29 20:16:54 2017 -0400
# Node ID b2d55b52ee5173b7b0b122e89036082881a2bfc8
# Parent  d3a9ffc9fdbd3a0645f310a19cd8d962fc44991c
new class to manage help system and associated variables

* help.h, help.cc (help_system): New class.  Handle
built_in_docstrings_file, doc_cache_file, info_file, info_program,
makeinfo_program, suppress_verbose_help_message, and texi_macros_file
variables.  Move most static and global functions inside class.
Change all uses.

* interpreter.h, interpreter.cc (interpreter::m_help_system):
New member variable.
(interpreter::get_help_system): New function.

* interpreter-private.h, interpreter-private.cc (__get_help_system__):
New function.

* defaults.h, defaults.cc (Vbuilt_in_docstrings_file, VEXEC_PATH,
VIMAGE_PATH): Delete.
(config::prepend_octave_home, config::prepend_octave_exec_home):
Define here instead of as static functions in defaults.cc.
(init_defaults): Now static.
(set_default_info_file, set_default_info_prog,
set_default_texi_macros_file, set_default_doc_cache_file,
set_built_in_docstrings_file, install_defaults):
Delete.

* toplev.cc (F__octave_config_info__): Don't include "infofile"
in the struct.

* octave.cc (application::init): Don't call install_defaults.
* documentation-dock-widget.h, documentation-dock-widget.cc
(documentation_dock_widget::load_info_file): New slot.

* main-window.cc (main_window::main_window):
Connect m_interpreter::octave_ready_signal to
doc_browser_window::load_info_file.

* octave-gui.cc (gui_application::gui_application): Don't call
install_defaults here.

* webinfo.h, webinfo.cc (webinfo::load_info_file): New function to set
file for info browser after interpreter is ready instead of doing that
in the webinfo constructor.

diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -21,16 +21,19 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "documentation-dock-widget.h"
 
+#include "help.h"
+#include "interpreter-private.h"
+
 documentation_dock_widget::documentation_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("DocumentationDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Documentation"));
   setStatusTip (tr ("See the documentation for help."));
 
@@ -70,8 +73,19 @@ documentation_dock_widget::showDoc (cons
 
 }
 
 void
 documentation_dock_widget::notice_settings (const QSettings *settings)
 {
   _webinfo->notice_settings (settings);
 }
+
+void
+documentation_dock_widget::load_info_file ()
+{
+  octave::help_system& help_sys
+    = octave::__get_help_system__ ("doc widget: load_info_file");
+
+  QString info_file = QString::fromStdString (help_sys.info_file ());
+
+  _webinfo->load_info_file (info_file);
+}
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -34,16 +34,18 @@ class documentation_dock_widget : public
 public:
 
   documentation_dock_widget (QWidget *parent = nullptr);
 
 public slots:
 
   void notice_settings (const QSettings *settings);
 
+  void load_info_file ();
+
 protected slots:
   void copyClipboard ();
   void pasteClipboard ();
   void selectAll ();
 
   void showDoc (const QString & name);
 
 private:
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -685,26 +685,24 @@ file_editor_tab::update_lexer ()
           if (_is_octave_file)
             {
               // octave: get keywords from internal informations depending on
               //         user preferences
 
               // keywords are always used
               add_octave_apis (Fiskeyword ());            // add new entries
 
+              octave::interpreter& interp
+                = octave::__get_interpreter__ ("file_editor_tab::update_lexer");
+
               if (octave_builtins)
-                {
-                  octave::interpreter& interp
-                    = octave::__get_interpreter__ ("file_editor_tab::update_lexer");
-
-                  add_octave_apis (F__builtins__ (interp));       // add new entries
-                }
+                add_octave_apis (F__builtins__ (interp));       // add new entries
 
               if (octave_functions)
-                add_octave_apis (F__list_functions__ ()); // add new entries
+                add_octave_apis (F__list_functions__ (interp)); // add new entries
 
             }
           else
             {
 
               _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
 
               for (i=1; i<=3; i++) // test the first 5 keyword sets
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -203,16 +203,19 @@ main_window::main_window (QWidget *p, oc
     load_and_display_community_news (serial);
 
   // We have to set up all our windows, before we finally launch octave.
   construct ();
 
   connect (m_interpreter, SIGNAL (octave_ready_signal ()),
            this, SLOT (handle_octave_ready ()));
 
+  connect (m_interpreter, SIGNAL (octave_ready_signal ()),
+           doc_browser_window, SLOT (load_info_file ()));
+
   m_interpreter->moveToThread (m_main_thread);
 
   m_main_thread->start ();
 }
 
 main_window::~main_window (void)
 {
   // Destroy the terminal first so that STDERR stream is redirected back
@@ -1502,18 +1505,21 @@ main_window::request_open_files (const Q
     emit open_file_signal (open_file_names.at (i), _file_encoding, -1);
 }
 
 void
 main_window::handle_edit_mfile_request (const QString& fname,
                                         const QString& ffile,
                                         const QString& curr_dir, int line)
 {
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("main_window::clear_workspace_callback");
+
   // Is it a regular function within the search path? (Call __which__)
-  octave_value_list fct = F__which__ (ovl (fname.toStdString ()),0);
+  octave_value_list fct = F__which__ (interp, ovl (fname.toStdString ()),0);
   octave_map map = fct(0).map_value ();
 
   QString type = QString::fromStdString (
                          map.contents ("type").data ()[0].string_value ());
   QString name = QString::fromStdString (
                          map.contents ("name").data ()[0].string_value ());
 
   QString message = QString ();
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -70,19 +70,16 @@ message_handler (QtMsgType, const QMessa
 namespace octave
 {
   gui_application::gui_application (int argc, char **argv)
     : application (argc, argv), m_argc (argc), m_argv (argv),
       m_gui_running (false)
   {
     // This should probably happen early.
     sysdep_init ();
-
-    // Need to have global Vfoo variables defined early.
-    install_defaults ();
   }
 
   bool gui_application::start_gui_p (void) const
   {
     if (m_options.no_window_system ())
       return false;
 
     std::string err_msg;
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -101,30 +101,16 @@ webinfo::webinfo (QWidget *p)
            SLOT (close_tab (int)));
   connect (_tab_bar, SIGNAL (currentChanged (int)), this,
            SLOT (current_tab_changed (int)));
   connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
   connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
   connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
   resize (500, 300);
-
-  if (! set_info_path (QString::fromStdString (Vinfo_file)))
-    {
-      // Info file does not exist
-      _search_check_box->setEnabled (false);
-      _search_line_edit->setEnabled (false);
-
-      QTextBrowser *msg = addNewTab (tr ("Error"));
-      QString msg_text = QString (
-          "<html><body><br><br><center><b>%1</b></center></body></html>").
-          arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
-          arg (QString::fromStdString (Vinfo_file)));
-      msg->setHtml (msg_text);
-    }
 }
 
 // Add an action to a menu or the widget itself
 QAction*
 webinfo::add_action (QMenu *menu, const QIcon& icon, const QString& text,
                          const char *member)
 {
   QAction *a;
@@ -158,16 +144,34 @@ webinfo::request_close_other_tabs (bool)
 
   for (int index = _tab_bar->count ()-1; index >= 0; index--)
   {
     if (current != index)
       close_tab (index);
   }
 }
 
+void
+webinfo::load_info_file (const QString& info_file)
+{
+  if (! set_info_path (info_file))
+    {
+      // Info file does not exist
+      _search_check_box->setEnabled (false);
+      _search_line_edit->setEnabled (false);
+
+      QTextBrowser *msg = addNewTab (tr ("Error"));
+      QString msg_text = QString (
+          "<html><body><br><br><center><b>%1</b></center></body></html>").
+          arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
+          arg (info_file));
+      msg->setHtml (msg_text);
+    }
+}
+
 bool
 webinfo::set_info_path (const QString& info_path)
 {
   if (_parser.set_info_path (info_path))
     {
       load_node ("Top");
       return true;
     }
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -67,21 +67,24 @@ private:
 // The webinfo class
 class webinfo : public QWidget
 {
   Q_OBJECT
 
 public:
 
   webinfo (QWidget *parent = nullptr);
+
   bool set_info_path (const QString& info_path);
   void load_node (const QString& node_name);
   void load_ref (const QString& ref_name);
   void notice_settings (const QSettings *settings);
 
+  void load_info_file (const QString& info_file);
+
 public slots:
 
   void link_clicked (const QUrl& link);
   void current_tab_changed (int index);
   void close_tab (int index);
   void search ();
   void zoom_in ();
   void zoom_out ();
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -311,18 +311,18 @@ files.
     {
       if (symbol_name != "")
         bp_table::remove_breakpoint (symbol_name, lines);
     }
 
   return ovl ();
 }
 
-DEFUN (dbstatus, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (dbstatus, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} dbstatus
 @deftypefnx {} {} dbstatus @var{func}
 @deftypefnx {} {@var{bp_list} =} dbstatus @dots{}
 Report the location of active breakpoints.
 
 When called with no input or output arguments, print the list of all
 functions with breakpoints and the line numbers where those breakpoints are
 set.
@@ -442,16 +442,18 @@ The @qcode{"warn"} field is set similarl
         }
 
       bp_table::stop_on_err_warn_status (true);
 
       return ovl ();
     }
   else
     {
+      octave::help_system& help_sys = interp.get_help_system ();
+
       // Fill in an array for return.
       int i = 0;
       octave_map retmap;
       octave_value retval;
 
       // count the number of breakpoints in all files
       int count = 0;
       for (const auto& fnm_bp_p : bp_list)
@@ -464,17 +466,18 @@ The @qcode{"warn"} field is set similarl
 
       for (const auto& fnm_bp_p : bp_list)
         {
           std::string filename = fnm_bp_p.first;
           const char *sub_fun = strchr (filename.c_str (), Vfilemarker);
           if (sub_fun)
             filename = filename.substr(0, sub_fun - filename.c_str ());
           octave_value path_name;
-          path_name = octave::sys::canonicalize_file_name (do_which (filename));
+          path_name
+            = octave::sys::canonicalize_file_name (help_sys.which (filename));
 
           for (const auto& bp : fnm_bp_p.second)
             {
               names(i) = fnm_bp_p.first;
               file(i) = path_name;
               line(i) = octave_value (bp.line);
               cond(i) = octave_value (bp.cond);
               i++;
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -26,34 +26,25 @@ along with Octave; see the file COPYING.
 
 #include <cstdlib>
 
 #include <algorithm>
 #include <iostream>
 #include <string>
 
 #include "dir-ops.h"
+#include "file-ops.h"
 #include "oct-env.h"
-#include "file-stat.h"
-#include "pathsearch.h"
-#include "str-vec.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "file-ops.h"
-#include "errwarn.h"
-#include "help.h"
-#include "input.h"
-#include "load-path.h"
 #include "ovl.h"
 #include "ov.h"
-#include "parse.h"
-#include "interpreter.h"
-#include "unwind-prot.h"
 #include "variables.h"
 #include "version.h"
 
 #include "default-defs.h"
 
 static bool initialized = false;
 
 static std::string Voctave_home;
@@ -97,30 +88,16 @@ static std::string Vman1_ext;
 static std::string Vimage_dir;
 
 static std::string Vlocal_startupfile_dir;
 static std::string Vstartupfile_dir;
 
 static std::string Vlocal_site_defaults_file;
 static std::string Vsite_defaults_file;
 
-// FIXME: these may be changed by users.  Maybe they should be defined
-// somewhere else?
-
-std::string Vbuilt_in_docstrings_file;
-
-// The path that will be searched for programs that we execute.
-// (--exec-path path)
-std::string VEXEC_PATH;
-
-// Name of the editor to be invoked by the edit_history command.
-std::string VEDITOR;
-
-std::string VIMAGE_PATH;
-
 // Variables that name directories or files are substituted into source
 // files with "${prefix}/" stripped from the beginning of the string.
 
 // All configure variables of this form should be specified as absolute
 // directory names.  The only ones that should not be absolute here are
 // ones that have had "${prefix}/" or "${exec_prefix} stripped.
 
 static std::string
@@ -134,28 +111,16 @@ prepend_home_dir (const std::string& hd,
     retval = hd + dir_sep_char + s;
 
   if (dir_sep_char != '/')
     std::replace (retval.begin (), retval.end (), '/', dir_sep_char);
 
   return retval;
 }
 
-static std::string
-prepend_octave_home (const std::string& s)
-{
-  return prepend_home_dir (Voctave_home, s);
-}
-
-static std::string
-prepend_octave_exec_home (const std::string& s)
-{
-  return prepend_home_dir (Voctave_exec_home, s);
-}
-
 static void
 set_octave_home (void)
 {
   std::string op = OCTAVE_PREFIX;
   std::string oep = OCTAVE_EXEC_PREFIX;
 
   std::string oh = octave::sys::env::getenv ("OCTAVE_HOME");
   std::string oeh = octave::sys::env::getenv ("OCTAVE_EXEC_HOME");
@@ -198,167 +163,105 @@ set_site_defaults_file (void)
   std::string sf = octave::sys::env::getenv ("OCTAVE_VERSION_INITFILE");
 
   if (sf.empty ())
     Vsite_defaults_file = Vstartupfile_dir + "/octaverc";
   else
     Vsite_defaults_file = sf;
 }
 
-void
+static void
 init_defaults (void)
 {
   if (initialized)
     return;
 
   // OCTAVE_HOME must be set first!
 
   set_octave_home ();
 
-  Vbin_dir = prepend_octave_exec_home (OCTAVE_BINDIR);
-  Vdata_dir = prepend_octave_home (OCTAVE_DATADIR);
-  Vdataroot_dir = prepend_octave_home (OCTAVE_DATAROOTDIR);
-  Vinclude_dir = prepend_octave_home (OCTAVE_INCLUDEDIR);
-  Vlib_dir = prepend_octave_exec_home (OCTAVE_LIBDIR);
-  Vlibexec_dir = prepend_octave_exec_home (OCTAVE_LIBEXECDIR);
+  Vbin_dir = octave::config::prepend_octave_exec_home (OCTAVE_BINDIR);
+  Vdata_dir = octave::config::prepend_octave_home (OCTAVE_DATADIR);
+  Vdataroot_dir = octave::config::prepend_octave_home (OCTAVE_DATAROOTDIR);
+  Vinclude_dir = octave::config::prepend_octave_home (OCTAVE_INCLUDEDIR);
+  Vlib_dir = octave::config::prepend_octave_exec_home (OCTAVE_LIBDIR);
+  Vlibexec_dir = octave::config::prepend_octave_exec_home (OCTAVE_LIBEXECDIR);
 
-  Vlocal_ver_arch_lib_dir = prepend_octave_exec_home (OCTAVE_LOCALVERARCHLIBDIR);
-  Vlocal_api_arch_lib_dir = prepend_octave_exec_home (OCTAVE_LOCALAPIARCHLIBDIR);
-  Vlocal_arch_lib_dir = prepend_octave_exec_home (OCTAVE_LOCALARCHLIBDIR);
-  Varch_lib_dir = prepend_octave_exec_home (OCTAVE_ARCHLIBDIR);
-
-  Vlocal_ver_oct_file_dir = prepend_octave_exec_home (OCTAVE_LOCALVEROCTFILEDIR);
-  Vlocal_api_oct_file_dir = prepend_octave_exec_home (OCTAVE_LOCALAPIOCTFILEDIR);
-  Vlocal_oct_file_dir = prepend_octave_exec_home (OCTAVE_LOCALOCTFILEDIR);
-  Voct_file_dir = prepend_octave_exec_home (OCTAVE_OCTFILEDIR);
+  Vlocal_ver_arch_lib_dir
+    = octave::config::prepend_octave_exec_home (OCTAVE_LOCALVERARCHLIBDIR);
+  Vlocal_api_arch_lib_dir
+    = octave::config::prepend_octave_exec_home (OCTAVE_LOCALAPIARCHLIBDIR);
+  Vlocal_arch_lib_dir
+    = octave::config::prepend_octave_exec_home (OCTAVE_LOCALARCHLIBDIR);
+  Varch_lib_dir = octave::config::prepend_octave_exec_home (OCTAVE_ARCHLIBDIR);
 
-  Vlocal_ver_fcn_file_dir = prepend_octave_home (OCTAVE_LOCALVERFCNFILEDIR);
-  Vlocal_api_fcn_file_dir = prepend_octave_home (OCTAVE_LOCALAPIFCNFILEDIR);
-  Vlocal_fcn_file_dir = prepend_octave_home (OCTAVE_LOCALFCNFILEDIR);
-  Vfcn_file_dir = prepend_octave_home (OCTAVE_FCNFILEDIR);
+  Vlocal_ver_oct_file_dir
+    = octave::config::prepend_octave_exec_home (OCTAVE_LOCALVEROCTFILEDIR);
+  Vlocal_api_oct_file_dir
+    = octave::config::prepend_octave_exec_home (OCTAVE_LOCALAPIOCTFILEDIR);
+  Vlocal_oct_file_dir
+    = octave::config::prepend_octave_exec_home (OCTAVE_LOCALOCTFILEDIR);
+  Voct_file_dir = octave::config::prepend_octave_exec_home (OCTAVE_OCTFILEDIR);
 
-  Voct_data_dir = prepend_octave_home (OCTAVE_OCTDATADIR);
-  Voct_etc_dir = prepend_octave_home (OCTAVE_OCTETCDIR);
-  Voct_include_dir = prepend_octave_home (OCTAVE_OCTINCLUDEDIR);
-  Voct_lib_dir = prepend_octave_exec_home (OCTAVE_OCTLIBDIR);
-  Voct_locale_dir = prepend_octave_home (OCTAVE_OCTLOCALEDIR);
-  Voct_tests_dir = prepend_octave_home (OCTAVE_OCTTESTSDIR);
+  Vlocal_ver_fcn_file_dir
+    = octave::config::prepend_octave_home (OCTAVE_LOCALVERFCNFILEDIR);
+  Vlocal_api_fcn_file_dir
+    = octave::config::prepend_octave_home (OCTAVE_LOCALAPIFCNFILEDIR);
+  Vlocal_fcn_file_dir
+    = octave::config::prepend_octave_home (OCTAVE_LOCALFCNFILEDIR);
+  Vfcn_file_dir = octave::config::prepend_octave_home (OCTAVE_FCNFILEDIR);
 
-  Vinfo_dir = prepend_octave_home (OCTAVE_INFODIR);
+  Voct_data_dir = octave::config::prepend_octave_home (OCTAVE_OCTDATADIR);
+  Voct_etc_dir = octave::config::prepend_octave_home (OCTAVE_OCTETCDIR);
+  Voct_include_dir = octave::config::prepend_octave_home (OCTAVE_OCTINCLUDEDIR);
+  Voct_lib_dir = octave::config::prepend_octave_exec_home (OCTAVE_OCTLIBDIR);
+  Voct_locale_dir = octave::config::prepend_octave_home (OCTAVE_OCTLOCALEDIR);
+  Voct_tests_dir = octave::config::prepend_octave_home (OCTAVE_OCTTESTSDIR);
 
-  Vman_dir = prepend_octave_home (OCTAVE_MANDIR);
-  Vman1_dir = prepend_octave_home (OCTAVE_MAN1DIR);
+  Vinfo_dir = octave::config::prepend_octave_home (OCTAVE_INFODIR);
+
+  Vman_dir = octave::config::prepend_octave_home (OCTAVE_MANDIR);
+  Vman1_dir = octave::config::prepend_octave_home (OCTAVE_MAN1DIR);
   Vman1_ext = OCTAVE_MAN1EXT;
 
-  Vimage_dir = prepend_octave_home (OCTAVE_IMAGEDIR);
+  Vimage_dir = octave::config::prepend_octave_home (OCTAVE_IMAGEDIR);
 
-  Vlocal_startupfile_dir = prepend_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
-  Vstartupfile_dir = prepend_octave_home (OCTAVE_STARTUPFILEDIR);
+  Vlocal_startupfile_dir
+    = octave::config::prepend_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
+  Vstartupfile_dir
+    = octave::config::prepend_octave_home (OCTAVE_STARTUPFILEDIR);
 
   set_local_site_defaults_file ();
 
   set_site_defaults_file ();
 
   initialized = true;
 }
 
-static void
-set_default_info_file (void)
-{
-  if (Vinfo_file.empty ())
-    {
-      std::string std_info_file = prepend_octave_home (OCTAVE_INFOFILE);
-
-      std::string oct_info_file = octave::sys::env::getenv ("OCTAVE_INFO_FILE");
-
-      Vinfo_file = (oct_info_file.empty () ? std_info_file : oct_info_file);
-    }
-}
-
-static void
-set_default_info_prog (void)
-{
-  if (Vinfo_program.empty ())
-    {
-      std::string oct_info_prog = octave::sys::env::getenv ("OCTAVE_INFO_PROGRAM");
-
-      if (oct_info_prog.empty ())
-        Vinfo_program = "info";
-      else
-        Vinfo_program = std::string (oct_info_prog);
-    }
-}
-
-static void
-set_default_texi_macros_file (void)
-{
-  if (Vtexi_macros_file.empty ())
-    {
-      std::string def_file = prepend_octave_home (OCTAVE_TEXI_MACROS_FILE);
-
-      std::string env_file = octave::sys::env::getenv ("OCTAVE_TEXI_MACROS_FILE");
-
-      Vtexi_macros_file = (env_file.empty () ? def_file : env_file);
-    }
-}
-
-static void
-set_default_doc_cache_file (void)
-{
-  if (Vdoc_cache_file.empty ())
-    {
-      std::string def_file = prepend_octave_home (OCTAVE_DOC_CACHE_FILE);
-
-      std::string env_file = octave::sys::env::getenv ("OCTAVE_DOC_CACHE_FILE");
-
-      Vdoc_cache_file = (env_file.empty () ? def_file : env_file);
-    }
-}
-
-static void
-set_built_in_docstrings_file (void)
-{
-  if (Vbuilt_in_docstrings_file.empty ())
-    {
-      std::string df = octave::sys::env::getenv ("OCTAVE_BUILT_IN_DOCSTRINGS_FILE");
-
-      if (df.empty ())
-        Vbuilt_in_docstrings_file
-          = Voct_etc_dir + octave::sys::file_ops::dir_sep_str () + "built-in-docstrings";
-      else
-        Vbuilt_in_docstrings_file = df;
-    }
-}
-
-void
-install_defaults (void)
-{
-  // In case this hasn't been done yet...
-  init_defaults ();
-
-  set_default_info_file ();
-
-  set_default_info_prog ();
-
-  set_default_texi_macros_file ();
-
-  set_default_doc_cache_file ();
-
-  set_built_in_docstrings_file ();
-}
-
 #define RETURN(VAR)                             \
   if (! initialized)                            \
     init_defaults ();                           \
   return VAR;
 
 namespace octave
 {
   namespace config
   {
+    std::string
+    prepend_octave_home (const std::string& s)
+    {
+      return prepend_home_dir (Voctave_home, s);
+    }
+
+    std::string
+    prepend_octave_exec_home (const std::string& s)
+    {
+      return prepend_home_dir (Voctave_exec_home, s);
+    }
+
     std::string canonical_host_type (void) { return OCTAVE_CANONICAL_HOST_TYPE; }
 
     std::string release (void) { return OCTAVE_RELEASE; }
 
     std::string default_pager (void) { return OCTAVE_DEFAULT_PAGER; }
 
     std::string octave_home (void) { RETURN (Voctave_home); }
     std::string octave_exec_home (void) { RETURN (Voctave_exec_home); }
diff --git a/libinterp/corefcn/defaults.h b/libinterp/corefcn/defaults.h
--- a/libinterp/corefcn/defaults.h
+++ b/libinterp/corefcn/defaults.h
@@ -28,16 +28,22 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "pathsearch.h"
 
 namespace octave
 {
   namespace config
   {
+    extern OCTINTERP_API std::string
+    prepend_octave_home (const std::string& s);
+
+    extern OCTINTERP_API std::string
+    prepend_octave_exec_home (const std::string& s);
+
     // These could be defined as pure constants, but we'll use
     // functions to be consistent with the values that require
     // initialization.
 
     extern OCTINTERP_API std::string canonical_host_type (void);
     extern OCTINTERP_API std::string release (void);
     extern OCTINTERP_API std::string default_pager (void);
 
@@ -88,16 +94,9 @@ namespace octave
     extern OCTINTERP_API std::string local_startupfile_dir (void);
     extern OCTINTERP_API std::string startupfile_dir (void);
 
     extern OCTINTERP_API std::string local_site_defaults_file (void);
     extern OCTINTERP_API std::string site_defaults_file (void);
   }
 }
 
-// FIXME: these may be changed by users.  Maybe they should be defined
-// somewhere else?
-
-extern OCTINTERP_API std::string Vbuilt_in_docstrings_file;
-
-extern OCTINTERP_API void install_defaults (void);
-
 #endif
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -65,39 +65,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 
-// Name of the doc cache file specified on the command line.
-// (--doc-cache-file file)
-std::string Vdoc_cache_file;
-
-// Name of the file containing local Texinfo macros that are prepended
-// to doc strings before processing.
-// (--texi-macros-file)
-std::string Vtexi_macros_file;
-
-// Name of the info file specified on command line.
-// (--info-file file)
-std::string Vinfo_file;
-
-// Name of the info reader we'd like to use.
-// (--info-program program)
-std::string Vinfo_program;
-
-// Name of the makeinfo program to run.
-static std::string Vmakeinfo_program = "makeinfo";
-
-// If TRUE, don't print additional help message in help and usage
-// functions.
-static bool Vsuppress_verbose_help_message = false;
+#include "default-defs.h"
 
 const static char * const operators[] =
 {
   "!",
   "~",
   "!=",
   "~=",
   "\"",
@@ -141,115 +119,16 @@ const static char * const operators[] =
   "]",
   "|",
   "||",
   0
 };
 
 const static string_vector operator_names (operators);
 
-// Return a vector of all functions from this file,
-// for use in command line auto-completion.
-static string_vector
-local_functions (void)
-{
-  string_vector retval;
-
-  octave::call_stack& cs = octave::__get_call_stack__ ("local_functions");
-
-  octave_user_code *curr_fcn = cs.caller_user_code ();
-
-  if (! curr_fcn)
-    return retval;
-
-  // All subfunctions are listed in the top-level function of this file.
-  while (curr_fcn->is_subfunction ())
-    {
-      octave::symbol_table::scope *pscope = curr_fcn->parent_fcn_scope ();
-      curr_fcn = pscope->function ();
-    }
-
-  // Get subfunctions.
-  const std::list<std::string> names = curr_fcn->subfunction_names ();
-
-  size_t sz = names.size ();
-  retval.resize (sz);
-
-  // Loop over them.
-  size_t i = 0;
-  for (const auto& nm : names)
-    retval(i++) = nm;
-
-  return retval;
-}
-
-// FIXME: It's not likely that this does the right thing now.
-
-string_vector
-make_name_list (void)
-{
-  const static string_vector keywords = Fiskeyword ()(0).string_vector_value ();
-  const static int key_len = keywords.numel ();
-
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("make_name_list");
-
-  const string_vector bif = symtab.built_in_function_names ();
-  const int bif_len = bif.numel ();
-
-  const string_vector cfl = symtab.cmdline_function_names ();
-  const int cfl_len = cfl.numel ();
-
-  const string_vector lcl = symtab.variable_names ();
-  const int lcl_len = lcl.numel ();
-
-  octave::load_path& lp = octave::__get_load_path__ ("make_name_list");
-
-  const string_vector ffl = lp.fcn_names ();
-  const int ffl_len = ffl.numel ();
-
-  const string_vector afl = octave::autoloaded_functions ();
-  const int afl_len = afl.numel ();
-
-  const string_vector lfl = local_functions ();
-  const int lfl_len = lfl.numel ();
-
-  const int total_len
-    = key_len + bif_len + cfl_len + lcl_len + ffl_len + afl_len + lfl_len;
-
-  string_vector list (total_len);
-
-  // Put all the symbols in one big list.
-
-  int j = 0;
-  int i = 0;
-
-  for (i = 0; i < key_len; i++)
-    list[j++] = keywords[i];
-
-  for (i = 0; i < bif_len; i++)
-    list[j++] = bif[i];
-
-  for (i = 0; i < cfl_len; i++)
-    list[j++] = cfl[i];
-
-  for (i = 0; i < lcl_len; i++)
-    list[j++] = lcl[i];
-
-  for (i = 0; i < ffl_len; i++)
-    list[j++] = ffl[i];
-
-  for (i = 0; i < afl_len; i++)
-    list[j++] = afl[i];
-
-  for (i = 0; i < lfl_len; i++)
-    list[j++] = lfl[i];
-
-  return list;
-}
-
 static bool
 looks_like_html (const std::string& msg)
 {
   const size_t p1 = msg.find ('\n');
   std::string t = msg.substr (0, p1);
   // FIXME: this comparison should be case-insensitive
   const size_t p2 = t.find ("<html");
 
@@ -266,348 +145,632 @@ looks_like_texinfo (const std::string& m
   if (p1 == std::string::npos)
     p1 = 0;
 
   size_t p2 = t.find ("-*- texinfo -*-");
 
   return (p2 != std::string::npos);
 }
 
-static bool
-raw_help_from_symbol_table (const std::string& nm, std::string& h,
-                            std::string& w, bool& symbol_found)
+// FIXME: Are we sure this function always does the right thing?
+static inline bool
+file_is_in_dir (const std::string filename, const std::string dir)
 {
-  bool retval = false;
-
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("raw_help_from_symbol_table");
-
-  octave_value val = symtab.find_function (nm);
-
-  if (val.is_defined ())
+  if (filename.find (dir) == 0)
     {
-      octave_function *fcn = val.function_value ();
-
-      if (fcn)
-        {
-          symbol_found = true;
-
-          h = fcn->doc_string ();
-
-          retval = true;
+      const int dir_len = dir.size ();
+      const int filename_len = filename.size ();
+      const int max_allowed_seps =
+        (octave::sys::file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1);
 
-          w = fcn->fcn_file_name ();
-
-          if (w.empty ())
-            w = fcn->is_user_function ()
-                ? "command-line function" : "built-in function";
-        }
-    }
-
-  return retval;
-}
+      int num_seps = 0;
+      for (int i = dir_len; i < filename_len; i++)
+        if (octave::sys::file_ops::is_dir_sep (filename[i]))
+          num_seps++;
 
-static bool
-raw_help_from_file (const std::string& nm, std::string& h,
-                    std::string& file, bool& symbol_found)
-{
-  bool retval = false;
-
-  h = octave::get_help_from_file (nm, symbol_found, file);
-
-  if (h.length () > 0)
-    retval = true;
-
-  return retval;
+      return (num_seps <= max_allowed_seps);
+    }
+  else
+    return false;
 }
 
-static bool
-raw_help_from_docstrings_file (const std::string& nm, std::string& h,
-                               bool& symbol_found)
+namespace octave
 {
-  typedef std::pair<std::streampos, std::streamoff> txt_limits_type;
-  typedef std::map<std::string, txt_limits_type> help_txt_map_type;
+  octave_value
+  help_system::built_in_docstrings_file (const octave_value_list& args,
+                                         int nargout)
+  {
+    return set_internal_variable (m_built_in_docstrings_file, args, nargout,
+                                  "built_in_docstrings_file", false);
+  }
+
+  octave_value
+  help_system::doc_cache_file (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_doc_cache_file, args, nargout,
+                                  "doc_cache_file", false);
+  }
+
+  octave_value
+  help_system::info_file (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_info_file, args, nargout,
+                                  "info_file", false);
+  }
+
+  octave_value
+  help_system::info_program (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_info_program, args, nargout,
+                                  "info_program", false);
+  }
 
-  static help_txt_map_type help_txt_map;
-  static bool initialized = false;
+  octave_value
+  help_system::makeinfo_program (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_makeinfo_program, args, nargout,
+                                  "makeinfo_program", false);
+  }
+
+  octave_value
+  help_system::suppress_verbose_help_message (const octave_value_list& args,
+                                              int nargout)
+  {
+    return set_internal_variable (m_suppress_verbose_help_message, args,
+                                  nargout, "suppress_verbose_help_message");
+  }
 
-  h = "";
-  symbol_found = false;
+  octave_value
+  help_system::texi_macros_file (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_texi_macros_file, args, nargout,
+                                  "texi_macros_file", false);
+  }
+
+  std::string
+  help_system::raw_help (const std::string& nm, bool& symbol_found) const
+  {
+    std::string h;
+    std::string w;
+    std::string f;
+
+    bool found;
 
-  // FIXME: Should we cache the timestamp of the file and reload the
-  // offsets if it changes?  Or just warn about that?  Or just ignore
-  // it, and assume it won't change?
+    found = raw_help_from_symbol_table (nm, h, w, symbol_found);
+
+    if (! found)
+      found = raw_help_from_file (nm, h, f, symbol_found);
+
+    bool external_doc = h.compare (0, 12, "external-doc") == 0;
+
+    if (! found || external_doc)
+      {
+        std::string tmp_nm = nm;
+
+        if (external_doc && h.length () > 12 && h[12] == ':')
+          tmp_nm = h.substr (13);
 
-  if (! initialized)
-    {
-      std::string fname = Vbuilt_in_docstrings_file;
+        raw_help_from_docstrings_file (tmp_nm, h, symbol_found);
+      }
+
+    return h;
+  }
+
+  std::string help_system::which (const std::string& name,
+                                  std::string& type) const
+  {
+    std::string file;
+
+    type = "";
+
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    octave_value val = symtab.find_function (name);
 
-      std::ifstream file (fname.c_str (), std::ios::in | std::ios::binary);
+    if (name.find_first_of ('.') == std::string::npos)
+      {
+        if (val.is_defined ())
+          {
+            octave_function *fcn = val.function_value ();
+
+            if (fcn)
+              {
+                file = fcn->fcn_file_name ();
 
-      if (! file)
-        error ("failed to open docstrings file: %s", fname.c_str ());
+                if (file.empty ())
+                  {
+                    if (fcn->is_user_function ())
+                      type = "command-line function";
+                    else
+                      {
+                        file = fcn->src_file_name ();
+                        type = "built-in function";
+                      }
+                  }
+                else
+                  type = val.is_user_script ()
+                    ? std::string ("script") : std::string ("function");
+              }
+          }
+        else
+          {
+            // We might find a file that contains only a doc string.
 
-      // Ignore header;
-      file.ignore (std::numeric_limits<std::streamsize>::max(), 0x1d);
+            load_path& lp = m_interpreter.get_load_path ();
 
-      if (file.eof ())
-        error ("invalid built-in-docstrings file!");
+            file = lp.find_fcn_file (name);
+          }
+      }
+    else
+      {
+        // File query.
+
+        load_path& lp = m_interpreter.get_load_path ();
+
+        // For compatibility: "file." queries "file".
+        if (name.size () > 1 && name[name.size () - 1] == '.')
+          file = lp.find_file (name.substr (0, name.size () - 1));
+        else
+          file = lp.find_file (name);
+
+        file = sys::env::make_absolute (file);
+      }
+
+    return file;
+  }
+
+  std::string help_system::which (const std::string& name) const
+  {
+    std::string type;
+
+    return which (name, type);
+  }
 
-      // FIXME: eliminate fixed buffer size.
-      size_t bufsize = 1000;
-      OCTAVE_LOCAL_BUFFER (char, buf, bufsize);
+  string_vector help_system::make_name_list (void) const
+  {
+    const static string_vector keywords
+      = Fiskeyword ()(0).string_vector_value ();
+
+    const static int key_len = keywords.numel ();
+
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    const string_vector bif = symtab.built_in_function_names ();
+    const int bif_len = bif.numel ();
+
+    const string_vector cfl = symtab.cmdline_function_names ();
+    const int cfl_len = cfl.numel ();
+
+    const string_vector lcl = symtab.variable_names ();
+    const int lcl_len = lcl.numel ();
+
+    load_path& lp = m_interpreter.get_load_path ();
+
+    const string_vector ffl = lp.fcn_names ();
+    const int ffl_len = ffl.numel ();
+
+    const string_vector afl = autoloaded_functions ();
+    const int afl_len = afl.numel ();
+
+    const string_vector lfl = local_functions ();
+    const int lfl_len = lfl.numel ();
+
+    const int total_len
+      = key_len + bif_len + cfl_len + lcl_len + ffl_len + afl_len + lfl_len;
+
+    string_vector list (total_len);
+
+    // Put all the symbols in one big list.
 
-      while (! file.eof ())
-        {
-          std::string name;
-          int i = 0;
-          int c;
-          while (file && (c = file.get ()) != std::istream::traits_type::eof ())
-            {
-              if (c == '\n' || c == '\r')
-                {
-                  buf[i] = '\0';
-                  name = buf;
-                  break;
-                }
-              else
-                buf[i++] = c;
-            }
+    int j = 0;
+    int i = 0;
+
+    for (i = 0; i < key_len; i++)
+      list[j++] = keywords[i];
+
+    for (i = 0; i < bif_len; i++)
+      list[j++] = bif[i];
+
+    for (i = 0; i < cfl_len; i++)
+      list[j++] = cfl[i];
+
+    for (i = 0; i < lcl_len; i++)
+      list[j++] = lcl[i];
+
+    for (i = 0; i < ffl_len; i++)
+      list[j++] = ffl[i];
+
+    for (i = 0; i < afl_len; i++)
+      list[j++] = afl[i];
+
+    for (i = 0; i < lfl_len; i++)
+      list[j++] = lfl[i];
+
+    return list;
+  }
+
+  void help_system::get_help_text (const std::string& name, std::string& text,
+                                   std::string& format) const
+  {
+    bool symbol_found = false;
+    text = raw_help (name, symbol_found);
 
-          // Skip @c FILENAME which is part of current DOCSTRINGS
-          // syntax.  This may disappear if a specific format for
-          // docstring files is developed.
-          while (file
-                 && (c = file.get ()) != std::istream::traits_type::eof ()
-                 && c != '\n' && c != '\r')
-            ; // skip text
+    format = "Not found";
+    if (symbol_found)
+      {
+        size_t idx = -1;
+        if (text.empty ())
+          {
+            format = "Not documented";
+          }
+        else if (looks_like_texinfo (text, idx))
+          {
+            format = "texinfo";
+            text.erase (0, idx);
+          }
+        else if (looks_like_html (text))
+          {
+            format = "html";
+          }
+        else
+          {
+            format = "plain text";
+          }
+      }
+  }
+
+  void help_system::get_help_text_from_file (const std::string& fname,
+                                             std::string& text,
+                                             std::string& format) const
+  {
+    bool symbol_found = false;
+
+    std::string f;
+
+    raw_help_from_file (fname, text, f, symbol_found);
 
-          // skip newline characters
-          while (file
-                 && (c = file.get ()) != std::istream::traits_type::eof ()
-                 && c == '\n' && c == '\r')
-            ; // skip text
+    format = "Not found";
+    if (symbol_found)
+      {
+        size_t idx = -1;
+        if (text.empty ())
+          {
+            format = "Not documented";
+          }
+        else if (looks_like_texinfo (text, idx))
+          {
+            format = "texinfo";
+            text.erase (0, idx);
+          }
+        else if (looks_like_html (text))
+          {
+            format = "html";
+          }
+        else
+          {
+            format = "plain text";
+          }
+      }
+  }
+
+  std::string help_system::init_built_in_docstrings_file (void)
+  {
+    std::string df = sys::env::getenv ("OCTAVE_BUILT_IN_DOCSTRINGS_FILE");
+
+    std::string dir_sep = sys::file_ops::dir_sep_str ();
+
+    if (df.empty ())
+      df = config::oct_etc_dir () + dir_sep + "built-in-docstrings";
 
-          file.unget ();
+    return df;
+  }
+
+  std::string help_system::init_doc_cache_file (void)
+  {
+    std::string def_file = config::prepend_octave_home (OCTAVE_DOC_CACHE_FILE);
+
+    std::string env_file = sys::env::getenv ("OCTAVE_DOC_CACHE_FILE");
+
+    return (env_file.empty () ? def_file : env_file);
+  }
+
+  std::string help_system::init_info_file (void)
+  {
+    std::string std_info_file = config::prepend_octave_home (OCTAVE_INFOFILE);
+
+    std::string oct_info_file = sys::env::getenv ("OCTAVE_INFO_FILE");
 
-          // Position of beginning of help text.
-          std::streampos beg = file.tellg ();
+    return (oct_info_file.empty () ? std_info_file : oct_info_file);
+  }
+
+  std::string help_system::init_info_program (void)
+  {
+    std::string info_prog = sys::env::getenv ("OCTAVE_INFO_PROGRAM");
 
-          // Skip help text.
-          file.ignore (std::numeric_limits<std::streamsize>::max(), 0x1d);
+    if (info_prog.empty ())
+      info_prog = "info";
+
+    return info_prog;
+  }
+
+  std::string help_system::init_texi_macros_file (void)
+  {
+    std::string def_file
+      = config::prepend_octave_home (OCTAVE_TEXI_MACROS_FILE);
 
-          // Position of end of help text.
-          std::streamoff len;
+    std::string env_file = sys::env::getenv ("OCTAVE_TEXI_MACROS_FILE");
+
+    return (env_file.empty () ? def_file : env_file);
+  }
+
+  // Return a vector of all functions from this file,
+  // for use in command line auto-completion.
+  string_vector help_system::local_functions (void) const
+  {
+    string_vector retval;
+
+    call_stack& cs = m_interpreter.get_call_stack ();
+
+    octave_user_code *curr_fcn = cs.caller_user_code ();
+
+    if (! curr_fcn)
+      return retval;
+
+    // All subfunctions are listed in the top-level function of this file.
+    while (curr_fcn->is_subfunction ())
+      {
+        symbol_table::scope *pscope = curr_fcn->parent_fcn_scope ();
+        curr_fcn = pscope->function ();
+      }
+
+    // Get subfunctions.
+    const std::list<std::string> names = curr_fcn->subfunction_names ();
+
+    size_t sz = names.size ();
+    retval.resize (sz);
+
+    // Loop over them.
+    size_t i = 0;
+    for (const auto& nm : names)
+      retval(i++) = nm;
 
-          if (! file.eof ())
-            len = file.tellg () - beg - 1;
-          else
-            {
-              file.seekg (0, file.end);
-              len = file.tellg () - beg - 1;
-              file.setstate (file.eofbit);  // reset eof flag
-            }
+    return retval;
+  }
+
+  bool help_system::raw_help_from_symbol_table (const std::string& nm,
+                                                std::string& h, std::string& w,
+                                                bool& symbol_found) const
+  {
+    bool retval = false;
+
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    octave_value val = symtab.find_function (nm);
+
+    if (val.is_defined ())
+      {
+        octave_function *fcn = val.function_value ();
 
-          help_txt_map[name] = txt_limits_type (beg, len);
-        }
+        if (fcn)
+          {
+            symbol_found = true;
+
+            h = fcn->doc_string ();
+
+            retval = true;
 
-      initialized = true;
-    }
+            w = fcn->fcn_file_name ();
+
+            if (w.empty ())
+              w = fcn->is_user_function ()
+                ? "command-line function" : "built-in function";
+          }
+      }
+
+    return retval;
+  }
 
-  help_txt_map_type::const_iterator it = help_txt_map.find (nm);
+  bool help_system::raw_help_from_file (const std::string& nm,
+                                        std::string& h, std::string& file,
+                                        bool& symbol_found) const
+  {
+    bool retval = false;
+
+    h = octave::get_help_from_file (nm, symbol_found, file);
+
+    if (h.length () > 0)
+      retval = true;
+
+    return retval;
+  }
 
-  if (it != help_txt_map.end ())
-    {
-      txt_limits_type txt_limits = it->second;
+  bool
+  help_system::raw_help_from_docstrings_file (const std::string& nm,
+                                              std::string& h,
+                                              bool& symbol_found) const
+  {
+    typedef std::pair<std::streampos, std::streamoff> txt_limits_type;
+    typedef std::map<std::string, txt_limits_type> help_txt_map_type;
+
+    static help_txt_map_type help_txt_map;
+    static bool initialized = false;
+
+    h = "";
+    symbol_found = false;
+
+    // FIXME: Should we cache the timestamp of the file and reload the
+    // offsets if it changes?  Or just warn about that?  Or just ignore
+    // it, and assume it won't change?
 
-      std::streampos beg = txt_limits.first;
-      std::streamoff len = txt_limits.second;
+    if (! initialized)
+      {
+        std::ifstream file (m_built_in_docstrings_file.c_str (),
+                            std::ios::in | std::ios::binary);
 
-      std::string fname = Vbuilt_in_docstrings_file;
+        if (! file)
+          error ("failed to open docstrings file: %s",
+                 m_built_in_docstrings_file.c_str ());
+
+        // Ignore header;
+        file.ignore (std::numeric_limits<std::streamsize>::max(), 0x1d);
+
+        if (file.eof ())
+          error ("invalid built-in-docstrings file!");
 
-      std::ifstream file (fname.c_str (), std::ios::in | std::ios::binary);
+        // FIXME: eliminate fixed buffer size.
+        size_t bufsize = 1000;
+        OCTAVE_LOCAL_BUFFER (char, buf, bufsize);
 
-      if (! file)
-        error ("failed to open docstrings file: %s", fname.c_str ());
+        while (! file.eof ())
+          {
+            std::string name;
+            int i = 0;
+            int c;
+            while (file && (c = file.get ()) != std::istream::traits_type::eof ())
+              {
+                if (c == '\n' || c == '\r')
+                  {
+                    buf[i] = '\0';
+                    name = buf;
+                    break;
+                  }
+                else
+                  buf[i++] = c;
+              }
 
-      file.seekg (beg);
+            // Skip @c FILENAME which is part of current DOCSTRINGS
+            // syntax.  This may disappear if a specific format for
+            // docstring files is developed.
+            while (file
+                   && (c = file.get ()) != std::istream::traits_type::eof ()
+                   && c != '\n' && c != '\r')
+              ; // skip text
+
+            // skip newline characters
+            while (file
+                   && (c = file.get ()) != std::istream::traits_type::eof ()
+                   && c == '\n' && c == '\r')
+              ; // skip text
+
+            file.unget ();
+
+            // Position of beginning of help text.
+            std::streampos beg = file.tellg ();
 
-      size_t txt_len = len;
-      OCTAVE_LOCAL_BUFFER (char, buf, txt_len + 1);
+            // Skip help text.
+            file.ignore (std::numeric_limits<std::streamsize>::max(), 0x1d);
+
+            // Position of end of help text.
+            std::streamoff len;
 
-      file.read (buf, txt_len);
+            if (! file.eof ())
+              len = file.tellg () - beg - 1;
+            else
+              {
+                file.seekg (0, file.end);
+                len = file.tellg () - beg - 1;
+                file.setstate (file.eofbit);  // reset eof flag
+              }
+
+            help_txt_map[name] = txt_limits_type (beg, len);
+          }
+
+        initialized = true;
+      }
 
-      buf[txt_len] = '\0';
+    help_txt_map_type::const_iterator it = help_txt_map.find (nm);
+
+    if (it != help_txt_map.end ())
+      {
+        txt_limits_type txt_limits = it->second;
+
+        std::streampos beg = txt_limits.first;
+        std::streamoff len = txt_limits.second;
 
-      h = buf;
+        std::ifstream file (m_built_in_docstrings_file.c_str (),
+                            std::ios::in | std::ios::binary);
+
+        if (! file)
+          error ("failed to open docstrings file: %s",
+                 m_built_in_docstrings_file.c_str ());
+
+        file.seekg (beg);
+
+        size_t txt_len = len;
+        OCTAVE_LOCAL_BUFFER (char, buf, txt_len + 1);
 
-      symbol_found = true;
-    }
+        file.read (buf, txt_len);
+
+        buf[txt_len] = '\0';
+
+        h = buf;
+
+        symbol_found = true;
+      }
 
-  return symbol_found;
+    return symbol_found;
+  }
+
+  // FIXME: It's not likely that this does the right thing now.
+
+  string_vector make_name_list (void)
+  {
+    octave::help_system& help_sys
+      = octave::__get_help_system__ ("make_name_list");
+
+    return help_sys.make_name_list ();
+  }
 }
 
-std::string
-raw_help (const std::string& nm, bool& symbol_found)
-{
-  std::string h;
-  std::string w;
-  std::string f;
-
-  bool found;
-
-  found = raw_help_from_symbol_table (nm, h, w, symbol_found);
-
-  if (! found)
-    found = raw_help_from_file (nm, h, f, symbol_found);
-
-  bool external_doc = h.compare (0, 12, "external-doc") == 0;
-
-  if (! found || external_doc)
-    {
-      std::string tmp_nm = nm;
-
-      if (external_doc && h.length () > 12 && h[12] == ':')
-        tmp_nm = h.substr (13);
-
-      raw_help_from_docstrings_file (tmp_nm, h, symbol_found);
-    }
-
-  return h;
-}
-
-DEFUN (built_in_docstrings_file, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} built_in_docstrings_file ()
-@deftypefnx {} {@var{old_val} =} built_in_docstrings_file (@var{new_val})
-@deftypefnx {} {} built_in_docstrings_file (@var{new_val}, "local")
-Query or set the internal variable that specifies the name of the
-file containing docstrings for built-in Octave functions.
-
-The default value is
-@file{@var{octave-home}/share/octave/@var{version}/etc/built-in-docstrings},
-in which @var{octave-home} is the root directory of the Octave installation,
-and @var{version} is the Octave version number.  The default value may be
-overridden by the environment variable
-@w{@env{OCTAVE_BUILT_IN_DOCSTRINGS_FILE}}, or the command line argument
-@option{--built-in-docstrings-file FNAME}.
-
-Note: This variable is only used when Octave is initializing itself.
-Modifying it during a running session of Octave will have no effect.
-@end deftypefn */)
-{
-  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (built_in_docstrings_file);
-}
-
-static void
-do_get_help_text (const std::string& name, std::string& text,
-                  std::string& format)
-{
-  bool symbol_found = false;
-  text = raw_help (name, symbol_found);
-
-  format = "Not found";
-  if (symbol_found)
-    {
-      size_t idx = -1;
-      if (text.empty ())
-        {
-          format = "Not documented";
-        }
-      else if (looks_like_texinfo (text, idx))
-        {
-          format = "texinfo";
-          text.erase (0, idx);
-        }
-      else if (looks_like_html (text))
-        {
-          format = "html";
-        }
-      else
-        {
-          format = "plain text";
-        }
-    }
-}
-
-DEFUN (get_help_text, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (get_help_text, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{text}, @var{format}] =} get_help_text (@var{name})
 Return the raw help text of function @var{name}.
 
 The raw help text is returned in @var{text} and the format in @var{format}
 The format is a string which is one of @qcode{"texinfo"},
 @qcode{"html"}, or @qcode{"plain text"}.
 @seealso{get_help_text_from_file}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   const std::string name = args(0).xstring_value ("get_help_text: NAME must be a string");
 
+  octave::help_system& help_sys = interp.get_help_system ();
+
   std::string text, format;
 
-  do_get_help_text (name, text, format);
+  help_sys.get_help_text (name, text, format);
 
   return ovl (text, format);
 }
 
-static void
-do_get_help_text_from_file (const std::string& fname, std::string& text,
-                            std::string& format)
-{
-  bool symbol_found = false;
-
-  std::string f;
-
-  raw_help_from_file (fname, text, f, symbol_found);
-
-  format = "Not found";
-  if (symbol_found)
-    {
-      size_t idx = -1;
-      if (text.empty ())
-        {
-          format = "Not documented";
-        }
-      else if (looks_like_texinfo (text, idx))
-        {
-          format = "texinfo";
-          text.erase (0, idx);
-        }
-      else if (looks_like_html (text))
-        {
-          format = "html";
-        }
-      else
-        {
-          format = "plain text";
-        }
-    }
-}
-
-DEFUN (get_help_text_from_file, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (get_help_text_from_file, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})
 Return the raw help text from the file @var{fname}.
 
 The raw help text is returned in @var{text} and the format in @var{format}
 The format is a string which is one of @qcode{"texinfo"},
 @qcode{"html"}, or @qcode{"plain text"}.
 @seealso{get_help_text}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   const std::string fname = args(0).xstring_value ("get_help_text_from_file: NAME must be a string");
 
+  octave::help_system& help_sys = interp.get_help_system ();
+
   std::string text, format;
 
-  do_get_help_text_from_file (fname, text, format);
+  help_sys.get_help_text_from_file (fname, text, format);
 
   return ovl (text, format);
 }
 
 // Return a cell array of strings containing the names of all operators.
 
 DEFUN (__operators__, , ,
        doc: /* -*- texinfo -*-
@@ -703,167 +866,72 @@ the return value is an empty cell array.
 %!   assert (size (d), [2, 1]);
 %!   assert (d{1} (3), 4);
 %!   assert (d{2} (3), 6);
 %! unwind_protect_cleanup
 %!   unlink (f);
 %! end_unwind_protect
 */
 
-static std::string
-do_which (const std::string& name, std::string& type)
-{
-  std::string file;
-
-  type = "";
-
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_which");
-
-  octave_value val = symtab.find_function (name);
-
-  if (name.find_first_of ('.') == std::string::npos)
-    {
-      if (val.is_defined ())
-        {
-          octave_function *fcn = val.function_value ();
-
-          if (fcn)
-            {
-              file = fcn->fcn_file_name ();
-
-              if (file.empty ())
-                {
-                  if (fcn->is_user_function ())
-                    type = "command-line function";
-                  else
-                    {
-                      file = fcn->src_file_name ();
-                      type = "built-in function";
-                    }
-                }
-              else
-                type = val.is_user_script ()
-                       ? std::string ("script") : std::string ("function");
-            }
-        }
-      else
-        {
-          // We might find a file that contains only a doc string.
-
-          octave::load_path& lp = octave::__get_load_path__ ("do_which");
-
-          file = lp.find_fcn_file (name);
-        }
-    }
-  else
-    {
-      // File query.
-
-      octave::load_path& lp = octave::__get_load_path__ ("do_which");
-
-      // For compatibility: "file." queries "file".
-      if (name.size () > 1 && name[name.size () - 1] == '.')
-        file = lp.find_file (name.substr (0, name.size () - 1));
-      else
-        file = lp.find_file (name);
-
-      file = octave::sys::env::make_absolute (file);
-    }
-
-  return file;
-}
-
-std::string
-do_which (const std::string& name)
-{
-  std::string retval;
-
-  std::string type;
-
-  retval = do_which (name, type);
-
-  return retval;
-}
-
-DEFUN (__which__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__which__, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} __which__ (@var{name}, @dots{})
 Undocumented internal function.
 @end deftypefn */)
 {
+  octave::help_system& help_sys = interp.get_help_system ();
+
   string_vector argv = args.make_argv ();
 
   int nargin = argv.numel ();
 
   octave_map m (dim_vector (1, nargin));
 
   Cell names (1, nargin);
   Cell files (1, nargin);
   Cell types (1, nargin);
 
   for (int i = 0; i < nargin; i++)
     {
       std::string name = argv[i];
 
       std::string type;
 
-      std::string file = do_which (name, type);
+      std::string file = help_sys.which (name, type);
 
       names(i) = name;
       files(i) = file;
       types(i) = type;
     }
 
   m.assign ("name", names);
   m.assign ("file", files);
   m.assign ("type", types);
 
   return ovl (m);
 }
 
-// FIXME: Are we sure this function always does the right thing?
-inline bool
-file_is_in_dir (const std::string filename, const std::string dir)
-{
-  if (filename.find (dir) == 0)
-    {
-      const int dir_len = dir.size ();
-      const int filename_len = filename.size ();
-      const int max_allowed_seps =
-        (octave::sys::file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1);
-
-      int num_seps = 0;
-      for (int i = dir_len; i < filename_len; i++)
-        if (octave::sys::file_ops::is_dir_sep (filename[i]))
-          num_seps++;
-
-      return (num_seps <= max_allowed_seps);
-    }
-  else
-    return false;
-}
-
 // Return a cell array of strings containing the names of all
 // functions available in DIRECTORY.  If no directory is given, search
 // the current path.
 
-DEFUN (__list_functions__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__list_functions__, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{retval} =} __list_functions__ ()
 @deftypefnx {} {@var{retval} =} __list_functions__ (@var{directory})
 Return a list of all functions (.m and .oct functions) in the load path.
 
 If the optional argument @var{directory} is given then list only the functions
 in that directory.
 @seealso{path}
 @end deftypefn */)
 {
   octave_value retval;
 
-  octave::load_path& lp = octave::__get_load_path__ ("__list_functions__");
+  octave::load_path& lp = interp.get_load_path ();
 
   if (args.length () == 0)
     {
       // Get list of all functions
       string_vector ffl = lp.fcn_names ();
       string_vector afl = octave::autoloaded_functions ();
 
       retval = Cell (ffl.append (afl));
@@ -879,18 +947,43 @@ in that directory.
       fl.sort (true);
 
       retval = Cell (fl);
     }
 
   return retval;
 }
 
-DEFUN (doc_cache_file, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (built_in_docstrings_file, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {@var{val} =} built_in_docstrings_file ()
+@deftypefnx {} {@var{old_val} =} built_in_docstrings_file (@var{new_val})
+@deftypefnx {} {} built_in_docstrings_file (@var{new_val}, "local")
+Query or set the internal variable that specifies the name of the
+file containing docstrings for built-in Octave functions.
+
+The default value is
+@file{@var{octave-home}/share/octave/@var{version}/etc/built-in-docstrings},
+in which @var{octave-home} is the root directory of the Octave installation,
+and @var{version} is the Octave version number.  The default value may be
+overridden by the environment variable
+@w{@env{OCTAVE_BUILT_IN_DOCSTRINGS_FILE}}, or the command line argument
+@option{--built-in-docstrings-file FNAME}.
+
+Note: This variable is only used when Octave is initializing itself.
+Modifying it during a running session of Octave will have no effect.
+@end deftypefn */)
+{
+  octave::help_system& help_sys = interp.get_help_system ();
+
+  return help_sys.built_in_docstrings_file (args, nargout);
+}
+
+DEFMETHOD (doc_cache_file, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} doc_cache_file ()
 @deftypefnx {} {@var{old_val} =} doc_cache_file (@var{new_val})
 @deftypefnx {} {} doc_cache_file (@var{new_val}, "local")
 Query or set the internal variable that specifies the name of the
 Octave documentation cache file.
 
 A cache file significantly improves the performance of the @code{lookfor}
 command.  The default value is
@@ -903,21 +996,118 @@ The default value may be overridden by t
 
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{doc_cache_create, lookfor, info_program, doc, help, makeinfo_program}
 @seealso{lookfor}
 @end deftypefn */)
 {
-  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
+  octave::help_system& help_sys = interp.get_help_system ();
+
+  return help_sys.doc_cache_file (args, nargout);
+}
+
+DEFMETHOD (info_file, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {@var{val} =} info_file ()
+@deftypefnx {} {@var{old_val} =} info_file (@var{new_val})
+@deftypefnx {} {} info_file (@var{new_val}, "local")
+Query or set the internal variable that specifies the name of the
+Octave info file.
+
+The default value is
+@file{@var{octave-home}/info/octave.info}, in
+which @var{octave-home} is the root directory of the Octave installation.
+The default value may be overridden by the environment variable
+@w{@env{OCTAVE_INFO_FILE}}, or the command line argument
+@option{--info-file FNAME}.
+
+When called from inside a function with the @qcode{"local"} option, the
+variable is changed locally for the function and any subroutines it calls.
+The original variable value is restored when exiting the function.
+@seealso{info_program, doc, help, makeinfo_program}
+@end deftypefn */)
+{
+  octave::help_system& help_sys = interp.get_help_system ();
+
+  return help_sys.info_file (args, nargout);
 }
 
-DEFUN (texi_macros_file, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (info_program, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {@var{val} =} info_program ()
+@deftypefnx {} {@var{old_val} =} info_program (@var{new_val})
+@deftypefnx {} {} info_program (@var{new_val}, "local")
+Query or set the internal variable that specifies the name of the
+info program to run.
+
+The default value is
+@file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}
+in which @var{octave-home} is the root directory of the Octave installation,
+@var{version} is the Octave version number, and @var{arch} is the system
+type (for example, @code{i686-pc-linux-gnu}).  The default value may be
+overridden by the environment variable
+@w{@env{OCTAVE_INFO_PROGRAM}}, or the command line argument
+@option{--info-program NAME}.
+
+When called from inside a function with the @qcode{"local"} option, the
+variable is changed locally for the function and any subroutines it calls.
+The original variable value is restored when exiting the function.
+@seealso{info_file, doc, help, makeinfo_program}
+@end deftypefn */)
+{
+  octave::help_system& help_sys = interp.get_help_system ();
+
+  return help_sys.info_program (args, nargout);
+}
+
+DEFMETHOD (makeinfo_program, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {@var{val} =} makeinfo_program ()
+@deftypefnx {} {@var{old_val} =} makeinfo_program (@var{new_val})
+@deftypefnx {} {} makeinfo_program (@var{new_val}, "local")
+Query or set the internal variable that specifies the name of the
+program that Octave runs to format help text containing
+Texinfo markup commands.
+
+The default value is @code{makeinfo}.
+
+When called from inside a function with the @qcode{"local"} option, the
+variable is changed locally for the function and any subroutines it calls.
+The original variable value is restored when exiting the function.
+@seealso{texi_macros_file, info_file, info_program, doc, help}
+@end deftypefn */)
+{
+  octave::help_system& help_sys = interp.get_help_system ();
+
+  return help_sys.makeinfo_program (args, nargout);
+}
+
+DEFMETHOD (suppress_verbose_help_message, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {@var{val} =} suppress_verbose_help_message ()
+@deftypefnx {} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})
+@deftypefnx {} {} suppress_verbose_help_message (@var{new_val}, "local")
+Query or set the internal variable that controls whether Octave
+will add additional help information to the end of the output from
+the @code{help} command and usage messages for built-in commands.
+
+When called from inside a function with the @qcode{"local"} option, the
+variable is changed locally for the function and any subroutines it calls.
+The original variable value is restored when exiting the function.
+@end deftypefn */)
+{
+  octave::help_system& help_sys = interp.get_help_system ();
+
+  return help_sys.suppress_verbose_help_message (args, nargout);
+}
+
+DEFMETHOD (texi_macros_file, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} texi_macros_file ()
 @deftypefnx {} {@var{old_val} =} texi_macros_file (@var{new_val})
 @deftypefnx {} {} texi_macros_file (@var{new_val}, "local")
 Query or set the internal variable that specifies the name of the
 file containing Texinfo macros that are prepended to documentation strings
 before they are passed to makeinfo.
 
 The default value is
@@ -929,97 +1119,12 @@ The default value may be overridden by t
 @option{--texi-macros-file FNAME}.
 
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{makeinfo_program}
 @end deftypefn */)
 {
-  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (texi_macros_file);
-}
-
-DEFUN (info_file, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} info_file ()
-@deftypefnx {} {@var{old_val} =} info_file (@var{new_val})
-@deftypefnx {} {} info_file (@var{new_val}, "local")
-Query or set the internal variable that specifies the name of the
-Octave info file.
-
-The default value is
-@file{@var{octave-home}/info/octave.info}, in
-which @var{octave-home} is the root directory of the Octave installation.
-The default value may be overridden by the environment variable
-@w{@env{OCTAVE_INFO_FILE}}, or the command line argument
-@option{--info-file FNAME}.
-
-When called from inside a function with the @qcode{"local"} option, the
-variable is changed locally for the function and any subroutines it calls.
-The original variable value is restored when exiting the function.
-@seealso{info_program, doc, help, makeinfo_program}
-@end deftypefn */)
-{
-  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
-}
-
-DEFUN (info_program, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} info_program ()
-@deftypefnx {} {@var{old_val} =} info_program (@var{new_val})
-@deftypefnx {} {} info_program (@var{new_val}, "local")
-Query or set the internal variable that specifies the name of the
-info program to run.
-
-The default value is
-@file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}
-in which @var{octave-home} is the root directory of the Octave installation,
-@var{version} is the Octave version number, and @var{arch} is the system
-type (for example, @code{i686-pc-linux-gnu}).  The default value may be
-overridden by the environment variable
-@w{@env{OCTAVE_INFO_PROGRAM}}, or the command line argument
-@option{--info-program NAME}.
+  octave::help_system& help_sys = interp.get_help_system ();
 
-When called from inside a function with the @qcode{"local"} option, the
-variable is changed locally for the function and any subroutines it calls.
-The original variable value is restored when exiting the function.
-@seealso{info_file, doc, help, makeinfo_program}
-@end deftypefn */)
-{
-  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
+  return help_sys.texi_macros_file (args, nargout);
 }
-
-DEFUN (makeinfo_program, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} makeinfo_program ()
-@deftypefnx {} {@var{old_val} =} makeinfo_program (@var{new_val})
-@deftypefnx {} {} makeinfo_program (@var{new_val}, "local")
-Query or set the internal variable that specifies the name of the
-program that Octave runs to format help text containing
-Texinfo markup commands.
-
-The default value is @code{makeinfo}.
-
-When called from inside a function with the @qcode{"local"} option, the
-variable is changed locally for the function and any subroutines it calls.
-The original variable value is restored when exiting the function.
-@seealso{texi_macros_file, info_file, info_program, doc, help}
-@end deftypefn */)
-{
-  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
-}
-
-DEFUN (suppress_verbose_help_message, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} suppress_verbose_help_message ()
-@deftypefnx {} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})
-@deftypefnx {} {} suppress_verbose_help_message (@var{new_val}, "local")
-Query or set the internal variable that controls whether Octave
-will add additional help information to the end of the output from
-the @code{help} command and usage messages for built-in commands.
-
-When called from inside a function with the @qcode{"local"} option, the
-variable is changed locally for the function and any subroutines it calls.
-The original variable value is restored when exiting the function.
-@end deftypefn */)
-{
-  return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
-}
diff --git a/libinterp/corefcn/help.h b/libinterp/corefcn/help.h
--- a/libinterp/corefcn/help.h
+++ b/libinterp/corefcn/help.h
@@ -25,32 +25,179 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <string>
 
 class string_vector;
 
-extern string_vector make_name_list (void);
+class interpreter;
+class octave_value;
+class octave_value_list;
+
+namespace octave
+{
+  class help_system
+  {
+  public:
 
-extern OCTINTERP_API std::string raw_help (const std::string&, bool&);
+    help_system (interpreter& interp)
+      : m_interpreter (interp),
+        m_built_in_docstrings_file (init_built_in_docstrings_file ()),
+        m_doc_cache_file (init_doc_cache_file ()),
+        m_info_file (init_info_file ()),
+        m_info_program (init_info_program ()),
+        m_makeinfo_program ("makeinfo"),
+        m_suppress_verbose_help_message (false),
+        m_texi_macros_file (init_texi_macros_file ())
+    { }
+
+    octave_value
+    built_in_docstrings_file (const octave_value_list& args, int nargout);
+
+    std::string
+    built_in_docstrings_file (void) const { return m_built_in_docstrings_file; }
+
+    std::string built_in_docstrings_file (const std::string& file)
+    {
+      return set (m_built_in_docstrings_file, file);
+    }
+
+    octave_value doc_cache_file (const octave_value_list& args, int nargout);
+
+    std::string doc_cache_file (void) const { return m_doc_cache_file; }
+
+    std::string doc_cache_file (const std::string& file)
+    {
+      return set (m_doc_cache_file, file);
+    }
 
-// Name of the doc cache file specified on the command line.
-// (--doc-cache-file file)
-extern OCTINTERP_API std::string Vdoc_cache_file;
+    octave_value info_file (const octave_value_list& args, int nargout);
+
+    std::string info_file (void) const { return m_info_file; }
+
+    std::string info_file (const std::string& file)
+    {
+      return set (m_info_file, file);
+    }
+
+    octave_value info_program (const octave_value_list& args, int nargout);
+
+    std::string info_program (void) const { return m_info_program; }
+
+    std::string info_program (const std::string& file)
+    {
+      return set (m_info_program, file);
+    }
+
+    octave_value makeinfo_program (const octave_value_list& args, int nargout);
+
+    std::string makeinfo_program (void) const { return m_makeinfo_program; }
+
+    std::string makeinfo_program (const std::string& file)
+    {
+      return set (m_makeinfo_program, file);
+    }
+
+    octave_value
+    suppress_verbose_help_message (const octave_value_list& args, int nargout);
+
+    bool suppress_verbose_help_message (void) const
+    {
+      return m_suppress_verbose_help_message;
+    }
+
+    bool suppress_verbose_help_message (bool flag)
+    {
+      return set (m_suppress_verbose_help_message, flag);
+    }
+
+    octave_value texi_macros_file (const octave_value_list& args, int nargout);
+
+    std::string texi_macros_file (void) const { return m_texi_macros_file; }
 
-// Name of the file containing local Texinfo macros that are prepended
-// to doc strings before processing.
-// (--texi-macros-file)
-extern OCTINTERP_API std::string Vtexi_macros_file;
+    std::string texi_macros_file (const std::string& file)
+    {
+      return set (m_texi_macros_file, file);
+    }
+
+    std::string raw_help (const std::string&, bool&) const;
+
+    std::string which (const std::string& name) const;
+    std::string which (const std::string& name, std::string& type) const;
+
+    string_vector make_name_list (void) const;
+
+    void get_help_text (const std::string& name, std::string& text,
+                        std::string& format) const;
+
+    void get_help_text_from_file (const std::string& fname, std::string& text,
+                                  std::string& format) const;
+
+  private:
+
+    interpreter& m_interpreter;
+
+    // Name of the file containing doc strings for built-in functions.
+    // (--built-in-docstrings-file file)
+    std::string m_built_in_docstrings_file;
+
+    // Name of the doc cache file specified on the command line.
+    // (--doc-cache-file file)
+    std::string m_doc_cache_file;
+
+    // Name of the info file specified on command line.
+    // (--info-file file)
+    std::string m_info_file;
+
+    // Name of the info reader we'd like to use.
+    // (--info-program program)
+    std::string m_info_program;
+
+    // Name of the makeinfo program to run.
+    std::string m_makeinfo_program;
 
-// Name of the info file specified on command line.
-// (--info-file file)
-extern OCTINTERP_API std::string Vinfo_file;
+    // If TRUE, don't print additional help message in help and usage
+    // functions.
+    bool m_suppress_verbose_help_message;
+
+    // Name of the file containing local Texinfo macros that are prepended
+    // to doc strings before processing.
+    // (--texi-macros-file)
+    std::string m_texi_macros_file;
+
+    static std::string init_built_in_docstrings_file (void);
+
+    static std::string init_doc_cache_file (void);
+
+    static std::string init_info_file (void);
+
+    static std::string init_info_program (void);
+
+    static std::string init_texi_macros_file (void);
 
-// Name of the info reader we'd like to use.
-// (--info-program program)
-extern OCTINTERP_API std::string Vinfo_program;
+    template <typename T>
+    T set (T& var, const T& new_val)
+    {
+      T old_val = var;
+      var = new_val;
+      return old_val;
+    }
+
+    string_vector local_functions (void) const;
 
-extern OCTINTERP_API std::string do_which (const std::string& name);
+    bool raw_help_from_symbol_table (const std::string& nm,
+                                     std::string& h, std::string& w,
+                                     bool& symbol_found) const;
+
+    bool raw_help_from_file (const std::string& nm,
+                             std::string& h, std::string& file,
+                             bool& symbol_found) const;
+
+    bool raw_help_from_docstrings_file (const std::string& nm, std::string& h,
+                                        bool& symbol_found) const;
+  };
+
+  extern string_vector make_name_list (void);
+}
 
 #endif
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -364,17 +364,17 @@ generate_possible_completions (const std
   prefix = "";
 
   char prev_char = octave::command_editor::get_prev_char (text.length ());
   deemed_struct = looks_like_struct (text, prev_char);
 
   if (deemed_struct)
     names = generate_struct_completions (text, prefix, hint);
   else
-    names = make_name_list ();
+    names = octave::make_name_list ();
 
   // Sort and remove duplicates.
 
   names.sort (true);
 
   return names;
 }
 
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <string>
 
 #include "call-stack.h"
 #include "error.h"
+#include "help.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ov-classdef.h"
 #include "symtab.h"
 
 namespace octave
 {
@@ -51,16 +52,23 @@ namespace octave
 
   dynamic_loader& __get_dynamic_loader__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_dynamic_loader ();
   }
 
+  help_system& __get_help_system__ (const std::string& who)
+  {
+    interpreter& interp = __get_interpreter__ (who);
+
+    return interp.get_help_system ();
+  }
+
   load_path& __get_load_path__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_load_path ();
   }
 
   symbol_table& __get_symbol_table__ (const std::string& who)
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -30,24 +30,27 @@ along with Octave; see the file COPYING.
 #include "symtab.h"
 
 class cdef_manager;
 
 namespace octave
 {
   class interpreter;
   class dynamic_loader;
+  class help_system;
   class load_path;
   class tree_evaluator;
   class call_stack;
 
   extern interpreter& __get_interpreter__ (const std::string& who);
 
   extern dynamic_loader& __get_dynamic_loader__ (const std::string& who);
 
+  extern help_system& __get_help_system__ (const std::string& who);
+
   extern load_path& __get_load_path__ (const std::string& who);
 
   extern symbol_table& __get_symbol_table__ (const std::string& who);
 
   extern symbol_table::scope *__get_current_scope__ (const std::string& who);
 
   extern symbol_table::scope *
   __require_current_scope__ (const std::string& who);
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -44,16 +44,17 @@ along with Octave; see the file COPYING.
 #include "defaults.h"
 #include "Cell.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "file-io.h"
 #include "graphics.h"
+#include "help.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "load-save.h"
 #include "octave-link.h"
 #include "octave.h"
 #include "oct-hist.h"
 #include "oct-map.h"
@@ -370,16 +371,17 @@ namespace octave
 {
   // Create an interpreter object and perform initialization up to the
   // point of setting reading command history and setting the load
   // path.
 
   interpreter::interpreter (application *app_context)
     : m_app_context (app_context),
       m_environment (),
+      m_help_system (*this),
       m_dynamic_loader (*this),
       m_load_path (),
       m_symbol_table (),
       m_evaluator (*this),
       m_cdef_manager (*this),
       m_interactive (false),
       m_read_site_files (true),
       m_read_init_files (m_app_context != 0),
@@ -505,39 +507,39 @@ namespace octave
         if (options.echo_commands ())
           {
             int val = ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE;
             Fecho_executing_commands (octave_value (val));
           }
 
         std::string docstrings_file = options.docstrings_file ();
         if (! docstrings_file.empty ())
-          Fbuilt_in_docstrings_file (octave_value (docstrings_file));
+          Fbuilt_in_docstrings_file (*this, octave_value (docstrings_file));
 
         std::string doc_cache_file = options.doc_cache_file ();
         if (! doc_cache_file.empty ())
-          Fdoc_cache_file (octave_value (doc_cache_file));
+          Fdoc_cache_file (*this, octave_value (doc_cache_file));
 
         std::string info_file = options.info_file ();
         if (! info_file.empty ())
-          Finfo_file (octave_value (info_file));
+          Finfo_file (*this, octave_value (info_file));
 
         std::string info_program = options.info_program ();
         if (! info_program.empty ())
-          Finfo_program (octave_value (info_program));
+          Finfo_program (*this, octave_value (info_program));
 
         if (options.debug_jit ())
           Fdebug_jit (octave_value (true));
 
         if (options.jit_compiler ())
           Fjit_enable (octave_value (true));
 
         std::string texi_macros_file = options.texi_macros_file ();
         if (! texi_macros_file.empty ())
-          Ftexi_macros_file (octave_value (texi_macros_file));
+          Ftexi_macros_file (*this, octave_value (texi_macros_file));
       }
 
     // Force default line editor if we don't want readline editing.
     if (line_editing)
       initialize_command_input ();
     else
       command_editor::force_default_editor ();
 
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "quit.h"
 #include "str-vec.h"
 
 #include "dynamic-ld.h"
 #include "environment.h"
+#include "help.h"
 #include "load-path.h"
 #include "ov-classdef.h"
 #include "pt-eval.h"
 #include "symtab.h"
 
 extern OCTINTERP_API bool quit_allowed;
 
 // TRUE means we are ready to interpret commands, but not everything
@@ -138,16 +139,21 @@ namespace octave
       return m_initialized;
     }
 
     environment& get_environment (void)
     {
       return m_environment;
     }
 
+    help_system& get_help_system (void)
+    {
+      return m_help_system;
+    }
+
     dynamic_loader& get_dynamic_loader (void)
     {
       return m_dynamic_loader;
     }
 
     load_path& get_load_path (void)
     {
       return m_load_path;
@@ -203,16 +209,18 @@ namespace octave
     int main_loop (void);
 
     void cleanup (void);
 
     application *m_app_context;
 
     environment m_environment;
 
+    help_system m_help_system;
+
     dynamic_loader m_dynamic_loader;
 
     load_path m_load_path;
 
     symbol_table m_symbol_table;
 
     tree_evaluator m_evaluator;
 
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_oct_map_h)
 #define octave_oct_map_h 1
 
 #include "octave-config.h"
 
 #include <algorithm>
 #include <map>
 
+#include "oct-refcount.h"
+
 #include "Cell.h"
 #include "ovl.h"
 
 class string_vector;
 
 // A class holding a map field->index.  Supports reference-counting.
 class OCTINTERP_API
 octave_fields
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -374,17 +374,16 @@ specified option.
            { "datadir", octave::config::data_dir () },
            { "datarootdir", octave::config::dataroot_dir () },
            { "fcnfiledir", octave::config::fcn_file_dir () },
            { "fftw_version", octave::fftw_version () },
            { "fftwf_version", octave::fftwf_version () },
            { "imagedir", octave::config::image_dir () },
            { "includedir", octave::config::include_dir () },
            { "infodir", octave::config::info_dir () },
-           { "infofile", Vinfo_file },
            { "libdir", octave::config::lib_dir () },
            { "libexecdir", octave::config::libexec_dir () },
            // Each library and executable has its own definition of the hg
            // id.  We check for consistency when Octave starts so we just
            // store and report one of them here.
            { "hg_id", liboctinterp_hg_id () },
            { "localapiarchlibdir", octave::config::local_api_arch_lib_dir () },
            { "localapifcnfiledir", octave::config::local_api_fcn_file_dir () },
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -24,18 +24,19 @@ along with Octave; see the file COPYING.
 #define octave_classdef_h 1
 
 #include "octave-config.h"
 
 #include <map>
 #include <set>
 #include <string>
 
+#include "oct-refcount.h"
+
 #include "oct-map.h"
-#include "oct-refcount.h"
 #include "ov-base.h"
 
 class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -366,19 +366,16 @@ namespace octave
       }
 
     m_is_octave_program = ((m_have_script_file || m_have_eval_option_code)
                            && ! m_options.persist ()
                            && ! m_options.traditional ());
 
     // This should probably happen early.
     sysdep_init ();
-
-    // Need to have global Vfoo variables defined early.
-    install_defaults ();
   }
 
   int cli_application::execute (void)
   {
     create_interpreter ();
 
     int status = execute_interpreter ();
 
