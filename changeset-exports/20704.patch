# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1447532285 18000
#      Sat Nov 14 15:18:05 2015 -0500
# Node ID 571508c1ed0659556d569409dc8a5962f0ca4781
# Parent  85e5efae848af849f1232ba1cee4fc9d88f59728
eliminate more uses of error_state

* ov.h, ov.cc (octave_value::xall_strings): New extractor.

* bitfcns.cc, data.cc, ellipj.cc, fftn.cc, file-io.cc, filter.cc,
find.cc, graphics.cc, input.cc, load-path.cc, luinc.cc,
matrix_type.cc, oct-stream.cc, ordschur.cc, psi.cc, rand.cc,
spparms.cc, strfns.cc, symtab.cc, syscalls.cc, sysdep.cc, time.cc,
utils.cc, variables.cc, __glpk__.cc, __magick_read__.cc, amd.cc,
ov-cell.cc, ov-fcn-inline.cc, ov-struct.cc:
Eliminate more uses of error_state.

* system.tst: Update tests.

diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -569,37 +569,30 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       int nbits = 64;
 
-      NDArray n = args(1).array_value ();
+      NDArray n = args(1).xarray_value ("bitshift: expecting integer as second argument");
 
-      if (error_state)
-        error ("bitshift: expecting integer as second argument");
-      else
+      if (nargin == 3)
         {
-          if (nargin == 3)
+          // FIXME: for compatibility, we should accept an array
+          // or a scalar as the third argument.
+          if (args(2).numel () > 1)
+            error ("bitshift: N must be a scalar integer");
+          else
             {
-              // FIXME: for compatibility, we should accept an array
-              // or a scalar as the third argument.
-              if (args(2).numel () > 1)
-                error ("bitshift: N must be a scalar integer");
-              else
-                {
-                  nbits = args(2).int_value ();
+              nbits = args(2).xint_value ("bitshift: N must be an integer");
 
-                  if (error_state)
-                    error ("bitshift: N must be an integer");
-                  else if (nbits < 0)
-                    error ("bitshift: N must be positive");
-                }
+              if (nbits < 0)
+                error ("bitshift: N must be positive");
             }
         }
 
       octave_value m_arg = args(0);
       std::string cname = m_arg.class_name ();
 
       if (cname == "uint8")
         DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -91,27 +91,22 @@ index_error (const char *fmt, const std:
 #define ANY_ALL(FCN) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
   if (nargin == 1 || nargin == 2) \
     { \
-      int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
+      int dim = (nargin == 1 ? -1 : args(1).int_value (#FCN ": expecting dimension argument to be an integer") - 1); \
  \
-      if (! error_state) \
-        { \
-          if (dim >= -1) \
-            retval = args(0).FCN (dim); \
-          else \
-            error (#FCN ": invalid dimension argument = %d", dim + 1); \
-        } \
+      if (dim >= -1) \
+        retval = args(0).FCN (dim); \
       else \
-        error (#FCN ": expecting dimension argument to be an integer"); \
+        error (#FCN ": invalid dimension argument = %d", dim + 1); \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (all, args, ,
        "-*- texinfo -*-\n\
@@ -1379,36 +1374,30 @@ Given a matrix argument, instead of a ve
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).diag ();
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
-      octave_idx_type k = args(1).int_value ();
-
-      if (error_state)
-        error ("diag: invalid argument K");
-      else
-        retval = args(0).diag (k);
+      octave_idx_type k = args(1).xint_value ("diag: invalid argument K");
+
+      retval = args(0).diag (k);
     }
   else if (nargin == 3)
     {
       octave_value arg0 = args(0);
 
       if (arg0.ndims () == 2 && (arg0.rows () == 1 || arg0.columns () == 1))
         {
-          octave_idx_type m = args(1).int_value ();
-          octave_idx_type n = args(2).int_value ();
-
-          if (! error_state)
-            retval = arg0.diag (m, n);
-          else
-            error ("diag: invalid dimensions");
+          octave_idx_type m = args(1).xint_value ("diag: invalid dimensions");
+          octave_idx_type n = args(2).xint_value ("diag: invalid dimensions");
+
+          retval = arg0.diag (m, n);
         }
       else
         error ("diag: V must be a vector");
     }
   else
     print_usage ();
 
   return retval;
@@ -2400,27 +2389,22 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () > 0)
     {
-      int dim = args(0).int_value () - 1;
-
-      if (! error_state)
-        {
-          if (dim >= 0)
-            retval = do_cat (args.slice (1, args.length () - 1), dim, "cat");
-          else
-            error ("cat: DIM must be a valid dimension");
-        }
+      int dim = args(0).xint_value ("cat: DIM must be an integer") - 1;
+
+      if (dim >= 0)
+        retval = do_cat (args.slice (1, args.length () - 1), dim, "cat");
       else
-        error ("cat: DIM must be an integer");
+        error ("cat: DIM must be a valid dimension");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -2815,34 +2799,29 @@ returns the number of columns in the giv
           for (int i = 0; i < ndims; i++)
             m(i) = dimensions(i);
 
           retval(0) = m;
         }
     }
   else if (nargin == 2 && nargout < 2)
     {
-      octave_idx_type nd = args(1).int_value (true);
-
-      if (error_state)
-        error ("size: DIM must be a scalar");
-      else
+      octave_idx_type nd = args(1).xint_value ("size: DIM must be an integer");
+
+      const dim_vector dv = args(0).dims ();
+
+      if (nd > 0)
         {
-          const dim_vector dv = args(0).dims ();
-
-          if (nd > 0)
-            {
-              if (nd <= dv.length ())
-                retval(0) = dv(nd-1);
-              else
-                retval(0) = 1;
-            }
+          if (nd <= dv.length ())
+            retval(0) = dv(nd-1);
           else
-            error ("size: requested dimension DIM (= %d) out of range", nd);
+            retval(0) = 1;
         }
+      else
+        error ("size: requested dimension DIM (= %d) out of range", nd);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size_equal, args, ,
@@ -3342,53 +3321,50 @@ complex ([1, 2], [3, 4])\n\
       octave_value arg = args(0);
 
       if (arg.is_complex_type ())
         retval = arg;
       else
         {
           if (arg.is_sparse_type ())
             {
-              SparseComplexMatrix val = arg.sparse_complex_matrix_value ();
+              SparseComplexMatrix val = arg.xsparse_complex_matrix_value ("complex: invalid conversion");
 
               retval = octave_value (new octave_sparse_complex_matrix (val));
             }
           else if (arg.is_single_type ())
             {
               if (arg.numel () == 1)
                 {
-                  FloatComplex val = arg.float_complex_value ();
+                  FloatComplex val = arg.xfloat_complex_value ("complex: invalid conversion");
 
                   retval = octave_value (new octave_float_complex (val));
                 }
               else
                 {
-                  FloatComplexNDArray val = arg.float_complex_array_value ();
+                  FloatComplexNDArray val = arg.xfloat_complex_array_value ("complex: invalid conversion");
 
                   retval = octave_value (new octave_float_complex_matrix (val));
                 }
             }
           else
             {
               if (arg.numel () == 1)
                 {
-                  Complex val = arg.complex_value ();
+                  Complex val = arg.xcomplex_value ("complex: invalid conversion");
 
                   retval = octave_value (new octave_complex (val));
                 }
               else
                 {
-                  ComplexNDArray val = arg.complex_array_value ();
+                  ComplexNDArray val = arg.xcomplex_array_value ("complex: invalid conversion");
 
                   retval = octave_value (new octave_complex_matrix (val));
                 }
             }
-
-          if (error_state)
-            error ("complex: invalid conversion");
         }
     }
   else if (nargin == 2)
     {
       octave_value re = args(0);
       octave_value im = args(1);
 
       if (re.is_sparse_type () && im.is_sparse_type ())
@@ -3571,19 +3547,16 @@ complex ([1, 2], [3, 4])\n\
 
                   retval = octave_value (
                                          new octave_complex_matrix (result));
                 }
               else
                 error ("complex: dimension mismatch");
             }
         }
-
-      if (error_state)
-        error ("complex: invalid conversion");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isreal, args, ,
@@ -3960,25 +3933,18 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          {
-            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-            if (error_state)
-              {
-                error ("%s: expecting scalar integer arguments", fcn);
-                break;
-              }
-          }
+          dims(i) = (args(i).is_empty ()
+                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4077,25 +4043,18 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          {
-            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-            if (error_state)
-              {
-                error ("%s: expecting scalar integer arguments", fcn);
-                break;
-              }
-          }
+          dims(i) = (args(i).is_empty ()
+                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4148,25 +4107,18 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          {
-            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-            if (error_state)
-              {
-                error ("%s: expecting scalar integer arguments", fcn);
-                break;
-              }
-          }
+          dims(i) = (args(i).is_empty ()
+                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4220,25 +4172,18 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          {
-            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-            if (error_state)
-              {
-                error ("%s: expecting scalar integer arguments", fcn);
-                break;
-              }
-          }
+          dims(i) = (args(i).is_empty ()
+                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4282,25 +4227,18 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          {
-            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-            if (error_state)
-              {
-                error ("%s: expecting scalar integer arguments", fcn);
-                break;
-              }
-          }
+          dims(i) = (args(i).is_empty ()
+                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -6428,32 +6366,27 @@ DEFUN (toc, args, nargout,
   double start_time = tic_toc_timestamp;
 
   if (nargin > 1)
     print_usage ();
   else
     {
       if (nargin == 1)
         {
-          octave_uint64 id = args(0).uint64_scalar_value ();
-
-          if (! error_state)
-            {
-              uint64_t val = id.value ();
-
-              start_time
-                = (static_cast<double> (val / CLOCKS_PER_SEC)
-                   + static_cast<double> (val % CLOCKS_PER_SEC)
-                   / CLOCKS_PER_SEC);
-
-              // FIXME: should we also check to see whether the start
-              // time is after the beginning of this Octave session?
-            }
-          else
-            error ("toc: invalid ID");
+          octave_uint64 id = args(0).xuint64_scalar_value ("toc: invalid ID");
+
+          uint64_t val = id.value ();
+
+          start_time
+            = (static_cast<double> (val / CLOCKS_PER_SEC)
+               + static_cast<double> (val % CLOCKS_PER_SEC)
+               / CLOCKS_PER_SEC);
+
+          // FIXME: should we also check to see whether the start
+          // time is after the beginning of this Octave session?
         }
 
       if (start_time < 0)
         error ("toc called before timer set");
       else
         {
           octave_time now;
 
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -23,22 +23,16 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
 #include "lo-specfun.h"
 
-static void
-gripe_ellipj_arg (const char *arg)
-{
-  error ("ellipj: expecting scalar or matrix as %s argument", arg);
-}
-
 DEFUN (ellipj, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m})\n\
 @deftypefnx {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m}, @var{tol})\n\
 Compute the Jacobi elliptic functions @var{sn}, @var{cn}, and @var{dn}\n\
 of complex argument @var{u} and real parameter @var{m}.\n\
 \n\
 If @var{m} is a scalar, the results are the same size as @var{u}.\n\
@@ -84,81 +78,57 @@ and 16.15), Dover, 1965.\n\
       return retval;
     }
 
   octave_value u_arg = args(0);
   octave_value m_arg = args(1);
 
   if (m_arg.is_scalar_type ())
     {
-      double m = args(1).double_value ();
-
-      if (error_state)
-        {
-          gripe_ellipj_arg ("second");
-          return retval;
-        }
+      double m = args(1).xdouble_value ("ellipj: expecting scalar or matrix as second argument");
 
       if (u_arg.is_scalar_type ())
         {
           if (u_arg.is_real_type ())
             {
               // u real, m scalar
-              double u = args(0).double_value ();
-
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("first");
-                  return retval;
-                }
+              double u = args(0).xdouble_value ("ellipj: expecting scalar or matrix as first argument");
 
               double sn, cn, dn;
               double err = 0;
 
               ellipj (u, m, sn, cn, dn, err);
 
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
           else
             {
               // u complex, m scalar
-              Complex u = u_arg.complex_value ();
-
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("first");
-                  return retval;
-                }
+              Complex u = u_arg.xcomplex_value ("ellipj: expecting scalar or matrix as first argument");
 
               Complex sn, cn, dn;
               double err = 0;
 
               ellipj (u, m, sn, cn, dn, err);
 
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
         }
       else
         {
           // u is matrix, m is scalar
-          ComplexNDArray u = u_arg.complex_array_value ();
-
-          if (error_state)
-            {
-              gripe_ellipj_arg ("first");
-              return retval;
-            }
+          ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: expecting scalar or matrix as first argument");
 
           dim_vector sz_u = u.dims ();
 
           ComplexNDArray sn (sz_u), cn (sz_u), dn (sz_u);
           NDArray err (sz_u);
 
           const Complex *pu = u.data ();
           Complex *psn = sn.fortran_vec ();
@@ -174,39 +144,27 @@ and 16.15), Dover, 1965.\n\
             retval(3) = err;
           retval(2) = dn;
           retval(1) = cn;
           retval(0) = sn;
         }
     }
   else
     {
-      NDArray m = args(1).array_value ();
-
-      if (error_state)
-        {
-          gripe_ellipj_arg ("second");
-          return retval;
-        }
+      NDArray m = args(1).xarray_value ("ellipj: expecting scalar or matrix as second argument");
 
       dim_vector sz_m = m.dims ();
 
       if (u_arg.is_scalar_type ())
         {
           // u is scalar, m is array
           if (u_arg.is_real_type ())
             {
               // u is real scalar, m is array
-              double u = u_arg.double_value ();
-
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("first");
-                  return retval;
-                }
+              double u = u_arg.xdouble_value ("ellipj: expecting scalar or matrix as first argument");
 
               NDArray sn (sz_m), cn (sz_m), dn (sz_m);
               NDArray err (sz_m);
 
               const double *pm = m.data ();
               double *psn = sn.fortran_vec ();
               double *pcn = cn.fortran_vec ();
               double *pdn = dn.fortran_vec ();
@@ -220,23 +178,17 @@ and 16.15), Dover, 1965.\n\
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
           else
             {
               // u is complex scalar, m is array
-              Complex u = u_arg.complex_value ();
-
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("first");
-                  return retval;
-                }
+              Complex u = u_arg.xcomplex_value ("ellipj: expecting scalar or matrix as first argument");
 
               ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
               NDArray err (sz_m);
 
               const double *pm = m.data ();
               Complex *psn = sn.fortran_vec ();
               Complex *pcn = cn.fortran_vec ();
               Complex *pdn = dn.fortran_vec ();
@@ -254,23 +206,17 @@ and 16.15), Dover, 1965.\n\
             }
         }
       else
         {
           // u is array, m is array
           if (u_arg.is_real_type ())
             {
               // u is real array, m is array
-              NDArray u = u_arg.array_value ();
-
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("first");
-                  return retval;
-                }
+              NDArray u = u_arg.xarray_value ("ellipj: expecting scalar or matrix as first argument");
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.length () == 2 && sz_m.length () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
                 {
                   // u is real column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
@@ -317,23 +263,17 @@ and 16.15), Dover, 1965.\n\
                   retval(0) = sn;
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
           else
             {
               // u is complex array, m is array
-              ComplexNDArray u = u_arg.complex_array_value ();
-
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("second");
-                  return retval;
-                }
+              ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: expecting scalar or matrix as second argument");
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.length () == 2 && sz_m.length () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
                 {
                   // u is complex column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -57,21 +57,22 @@ do_fftn (const octave_value_list &args, 
   dim_vector dims = arg.dims ();
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (nargin > 1)
     {
-      Matrix val = args(1).matrix_value ();
+      Matrix val = args(1).xmatrix_value ("%s: SIZE must be a vector of length dim", fcn);
+
       if (val.rows () > val.columns ())
         val = val.transpose ();
 
-      if (error_state || val.columns () != dims.length () || val.rows () != 1)
+      if (val.columns () != dims.length () || val.rows () != 1)
         error ("%s: SIZE must be a vector of length dim", fcn);
       else
         {
           for (int i = 0; i < dims.length (); i++)
             {
               if (xisnan (val(i,0)))
                 error ("%s: SIZE has invalid NaN entries", fcn);
               else if (NINTbig (val(i,0)) < 0)
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -2118,36 +2118,28 @@ for the new object are @code{@var{mode} 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
-      int mask = args(0).int_value (true);
+      int mask = args(0).xint_value ("umask: MASK must be an integer");
 
-      if (! error_state)
+      if (mask < 0)
         {
-          if (mask < 0)
-            {
-              status = -1;
-              error ("umask: MASK must be a positive integer value");
-            }
-          else
-            {
-              int oct_mask = convert (mask, 8, 10);
-
-              status = convert (octave_umask (oct_mask), 10, 8);
-            }
+          status = -1;
+          error ("umask: MASK must be a positive integer value");
         }
       else
         {
-          status = -1;
-          error ("umask: MASK must be an integer");
+          int oct_mask = convert (mask, 8, 10);
+
+          status = convert (octave_umask (oct_mask), 10, 8);
         }
     }
   else
     print_usage ();
 
   if (status >= 0)
     retval(0) = status;
 
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -397,17 +397,18 @@ H(z) = ---------------------\n\
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 5)
     {
       print_usage ();
       return retval;
     }
 
-  const char *errmsg = "filter: arguments a and b must be vectors";
+  const char *a_b_errmsg = "filter: A and B must be vectors";
+  const char *x_si_errmsg = "filter: X and SI must be arrays";
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
       dim = args(4).nint_value () - 1;
       if (dim < 0 || dim >= x_dims.length ())
@@ -435,208 +436,167 @@ H(z) = ---------------------\n\
 
   if (args(0).is_complex_type ()
       || args(1).is_complex_type ()
       || args(2).is_complex_type ()
       || (nargin >= 4 && args(3).is_complex_type ()))
     {
       if (isfloat)
         {
-          FloatComplexColumnVector b (args(0).float_complex_vector_value ());
-          FloatComplexColumnVector a (args(1).float_complex_vector_value ());
-
-          FloatComplexNDArray x (args(2).float_complex_array_value ());
-
-          if (! error_state)
-            {
-              FloatComplexNDArray si;
+          FloatComplexColumnVector b = args(0).xfloat_complex_vector_value (a_b_errmsg);
+          FloatComplexColumnVector a = args(1).xfloat_complex_vector_value (a_b_errmsg);
+          FloatComplexNDArray x = args(2).xfloat_complex_array_value (x_si_errmsg);
 
-              if (nargin == 3 || args(3).is_empty ())
-                {
-                  octave_idx_type a_len = a.numel ();
-                  octave_idx_type b_len = b.numel ();
-
-                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-                  dim_vector si_dims = x.dims ();
-                  for (int i = dim; i > 0; i--)
-                    si_dims(i) = si_dims(i-1);
-                  si_dims(0) = si_len;
+          FloatComplexNDArray si;
 
-                  si.resize (si_dims, 0.0);
-                }
-              else
-                {
-                  si = args(3).float_complex_array_value ();
+          if (nargin == 3 || args(3).is_empty ())
+            {
+              octave_idx_type a_len = a.numel ();
+              octave_idx_type b_len = b.numel ();
 
-                  if (si.is_vector () && x.is_vector ())
-                    si = si.reshape (dim_vector (si.numel (), 1));
-                }
+              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-              if (! error_state)
-                {
-                  FloatComplexNDArray y (filter (b, a, x, si, dim));
+              dim_vector si_dims = x.dims ();
+              for (int i = dim; i > 0; i--)
+                si_dims(i) = si_dims(i-1);
+              si_dims(0) = si_len;
 
-                  if (nargout == 2)
-                    retval(1) = si;
-
-                  retval(0) = y;
-                }
-              else
-                error (errmsg);
+              si.resize (si_dims, 0.0);
             }
           else
-            error (errmsg);
+            {
+              si = args(3).xfloat_complex_array_value (x_si_errmsg);
+
+              if (si.is_vector () && x.is_vector ())
+                si = si.reshape (dim_vector (si.numel (), 1));
+            }
+
+          FloatComplexNDArray y (filter (b, a, x, si, dim));
+
+          if (nargout == 2)
+            retval(1) = si;
+
+          retval(0) = y;
         }
       else
         {
-          ComplexColumnVector b (args(0).complex_vector_value ());
-          ComplexColumnVector a (args(1).complex_vector_value ());
-
-          ComplexNDArray x (args(2).complex_array_value ());
-
-          if (! error_state)
-            {
-              ComplexNDArray si;
+          ComplexColumnVector b = args(0).xcomplex_vector_value (a_b_errmsg);
+          ComplexColumnVector a = args(1).xcomplex_vector_value (a_b_errmsg);
 
-              if (nargin == 3 || args(3).is_empty ())
-                {
-                  octave_idx_type a_len = a.numel ();
-                  octave_idx_type b_len = b.numel ();
+          ComplexNDArray x = args(2).xcomplex_array_value (x_si_errmsg);
 
-                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-                  dim_vector si_dims = x.dims ();
-                  for (int i = dim; i > 0; i--)
-                    si_dims(i) = si_dims(i-1);
-                  si_dims(0) = si_len;
+          ComplexNDArray si;
 
-                  si.resize (si_dims, 0.0);
-                }
-              else
-                {
-                  si = args(3).complex_array_value ();
+          if (nargin == 3 || args(3).is_empty ())
+            {
+              octave_idx_type a_len = a.numel ();
+              octave_idx_type b_len = b.numel ();
 
-                  if (si.is_vector () && x.is_vector ())
-                    si = si.reshape (dim_vector (si.numel (), 1));
-                }
+              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-              if (! error_state)
-                {
-                  ComplexNDArray y (filter (b, a, x, si, dim));
+              dim_vector si_dims = x.dims ();
+              for (int i = dim; i > 0; i--)
+                si_dims(i) = si_dims(i-1);
+              si_dims(0) = si_len;
 
-                  if (nargout == 2)
-                    retval(1) = si;
-
-                  retval(0) = y;
-                }
-              else
-                error (errmsg);
+              si.resize (si_dims, 0.0);
             }
           else
-            error (errmsg);
+            {
+              si = args(3).xcomplex_array_value (x_si_errmsg);
+
+              if (si.is_vector () && x.is_vector ())
+                si = si.reshape (dim_vector (si.numel (), 1));
+            }
+
+          ComplexNDArray y (filter (b, a, x, si, dim));
+
+          if (nargout == 2)
+            retval(1) = si;
+
+          retval(0) = y;
         }
     }
   else
     {
       if (isfloat)
         {
-          FloatColumnVector b (args(0).float_vector_value ());
-          FloatColumnVector a (args(1).float_vector_value ());
-
-          FloatNDArray x (args(2).float_array_value ());
-
-          if (! error_state)
-            {
-              FloatNDArray si;
+          FloatColumnVector b = args(0).xfloat_vector_value (a_b_errmsg);
+          FloatColumnVector a = args(1).xfloat_vector_value (a_b_errmsg);
 
-              if (nargin == 3 || args(3).is_empty ())
-                {
-                  octave_idx_type a_len = a.numel ();
-                  octave_idx_type b_len = b.numel ();
+          FloatNDArray x = args(2).xfloat_array_value (x_si_errmsg);
 
-                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-                  dim_vector si_dims = x.dims ();
-                  for (int i = dim; i > 0; i--)
-                    si_dims(i) = si_dims(i-1);
-                  si_dims(0) = si_len;
+          FloatNDArray si;
 
-                  si.resize (si_dims, 0.0);
-                }
-              else
-                {
-                  si = args(3).float_array_value ();
+          if (nargin == 3 || args(3).is_empty ())
+            {
+              octave_idx_type a_len = a.numel ();
+              octave_idx_type b_len = b.numel ();
 
-                  if (si.is_vector () && x.is_vector ())
-                    si = si.reshape (dim_vector (si.numel (), 1));
-                }
+              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-              if (! error_state)
-                {
-                  FloatNDArray y (filter (b, a, x, si, dim));
+              dim_vector si_dims = x.dims ();
+              for (int i = dim; i > 0; i--)
+                si_dims(i) = si_dims(i-1);
+              si_dims(0) = si_len;
 
-                  if (nargout == 2)
-                    retval(1) = si;
-
-                  retval(0) = y;
-                }
-              else
-                error (errmsg);
+              si.resize (si_dims, 0.0);
             }
           else
-            error (errmsg);
+            {
+              si = args(3).xfloat_array_value (x_si_errmsg);
+
+              if (si.is_vector () && x.is_vector ())
+                si = si.reshape (dim_vector (si.numel (), 1));
+            }
+
+          FloatNDArray y (filter (b, a, x, si, dim));
+
+          if (nargout == 2)
+            retval(1) = si;
+
+          retval(0) = y;
         }
       else
         {
-          ColumnVector b (args(0).vector_value ());
-          ColumnVector a (args(1).vector_value ());
-
-          NDArray x (args(2).array_value ());
-
-          if (! error_state)
-            {
-              NDArray si;
+          ColumnVector b = args(0).xvector_value (a_b_errmsg);
+          ColumnVector a = args(1).xvector_value (a_b_errmsg);
 
-              if (nargin == 3 || args(3).is_empty ())
-                {
-                  octave_idx_type a_len = a.numel ();
-                  octave_idx_type b_len = b.numel ();
+          NDArray x = args(2).xarray_value (x_si_errmsg);
 
-                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-                  dim_vector si_dims = x.dims ();
-                  for (int i = dim; i > 0; i--)
-                    si_dims(i) = si_dims(i-1);
-                  si_dims(0) = si_len;
+          NDArray si;
 
-                  si.resize (si_dims, 0.0);
-                }
-              else
-                {
-                  si = args(3).array_value ();
+          if (nargin == 3 || args(3).is_empty ())
+            {
+              octave_idx_type a_len = a.numel ();
+              octave_idx_type b_len = b.numel ();
 
-                  if (si.is_vector () && x.is_vector ())
-                    si = si.reshape (dim_vector (si.numel (), 1));
-                }
+              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-              if (! error_state)
-                {
-                  NDArray y (filter (b, a, x, si, dim));
+              dim_vector si_dims = x.dims ();
+              for (int i = dim; i > 0; i--)
+                si_dims(i) = si_dims(i-1);
+              si_dims(0) = si_len;
 
-                  if (nargout == 2)
-                    retval(1) = si;
-
-                  retval(0) = y;
-                }
-              else
-                error (errmsg);
+              si.resize (si_dims, 0.0);
             }
           else
-            error (errmsg);
+            {
+              si = args(3).xarray_value (x_si_errmsg);
+
+              if (si.is_vector () && x.is_vector ())
+                si = si.reshape (dim_vector (si.numel (), 1));
+            }
+
+          NDArray y (filter (b, a, x, si, dim));
+
+          if (nargout == 2)
+            retval(1) = si;
+
+          retval(0) = y;
         }
     }
 
   return retval;
 }
 
 template MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&,
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -400,23 +400,20 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
       print_usage ();
       return retval;
     }
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
-      double val = args(1).scalar_value ();
+      double val = args(1).xscalar_value ("find: N must be an integer");
 
-      if (error_state || (val < 0 || (! xisinf (val) && val != xround (val))))
-        {
-          error ("find: N must be a non-negative integer");
-          return retval;
-        }
+      if (val < 0 || (! xisinf (val) && val != xround (val)))
+        error ("find: N must be a non-negative integer");
       else if (! xisinf (val))
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
   if (nargin > 2)
     {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1508,37 +1508,32 @@ handle_property::do_set (const octave_va
         {
           current_val = graphics_handle ();
           return true;
         }
       else
         return false;
     }
 
-  double dv = v.double_value ();
-
-  if (! error_state)
-    {
-      graphics_handle gh = gh_manager::lookup (dv);
-
-      if (xisnan (gh.value ()) || gh.ok ())
-        {
-          if (current_val != gh)
-            {
-              current_val = gh;
-              return true;
-            }
-        }
-      else
-        error ("set: invalid graphics handle (= %g) for property \"%s\"",
-               dv, get_name ().c_str ());
-    }
-  else
-    error ("set: invalid graphics handle for property \"%s\"",
-           get_name ().c_str ());
+  double dv = v.xdouble_value ("set: invalid graphics handle for property \"%s\"",
+                              get_name ().c_str ());
+
+  graphics_handle gh = gh_manager::lookup (dv);
+
+  if (xisnan (gh.value ()) || gh.ok ())
+    {
+      if (current_val != gh)
+        {
+          current_val = gh;
+          return true;
+        }
+    }
+  else
+    error ("set: invalid graphics handle (= %g) for property \"%s\"",
+           dv, get_name ().c_str ());
 
   return false;
 }
 
 Matrix
 children_property::do_get_children (bool return_hidden) const
 {
   Matrix retval (children_list.size (), 1);
@@ -2552,44 +2547,39 @@ xget (const graphics_handle& h, const ca
 
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
           const std::string& pname, const graphics_handle& new_parent,
           bool adopt = true)
 {
   graphics_handle h = octave_NaN;
 
-  double hv = ov.double_value ();
-
-  if (! error_state)
-    {
-      h = gh_manager::lookup (hv);
-
-      if (h.ok ())
-        {
-          graphics_object go = gh_manager::get_object (h);
-
-          graphics_handle parent_h = go.get_parent ();
-
-          graphics_object parent_go = gh_manager::get_object (parent_h);
-
-          parent_go.remove_child (h);
-
-          if (adopt)
-            go.set ("parent", new_parent.value ());
-          else
-            go.reparent (new_parent);
-        }
+  double hv = ov.xdouble_value ("%s: expecting %s to be a graphics handle",
+                               who.c_str (), pname.c_str ());
+
+  h = gh_manager::lookup (hv);
+
+  if (h.ok ())
+    {
+      graphics_object go = gh_manager::get_object (h);
+
+      graphics_handle parent_h = go.get_parent ();
+
+      graphics_object parent_go = gh_manager::get_object (parent_h);
+
+      parent_go.remove_child (h);
+
+      if (adopt)
+        go.set ("parent", new_parent.value ());
       else
-        error ("%s: invalid graphics handle (= %g) for %s",
-               who.c_str (), hv, pname.c_str ());
-    }
-  else
-    error ("%s: expecting %s to be a graphics handle",
-           who.c_str (), pname.c_str ());
+        go.reparent (new_parent);
+    }
+  else
+    error ("%s: invalid graphics handle (= %g) for %s",
+           who.c_str (), hv, pname.c_str ());
 
   return h;
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
@@ -2970,58 +2960,53 @@ base_properties::get_property_dynamic (c
     }
   else
     return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
-  double hp = val.double_value ();
+  double hp = val.xdouble_value ("set: expecting parent to be a graphics handle");
 
   graphics_handle new_parent = octave_NaN;
 
-  if (! error_state)
-    {
-      if (hp == __myhandle__)
-        error ("set: can not set object parent to be object itself");
+  if (hp == __myhandle__)
+    error ("set: can not set object parent to be object itself");
+  else
+    {
+      new_parent = gh_manager::lookup (hp);
+
+      if (new_parent.ok ())
+        {
+          // Remove child from current parent
+          graphics_object old_parent_go;
+          old_parent_go = gh_manager::get_object (get_parent ());
+
+          if (old_parent_go.get_handle () != hp)
+            old_parent_go.remove_child (__myhandle__);
+          else
+            return;  // Do nothing more
+
+          // Check new parent's parent is not this child to avoid recursion
+          graphics_object new_parent_go;
+          new_parent_go = gh_manager::get_object (new_parent);
+          if (new_parent_go.get_parent () == __myhandle__)
+            {
+              // new parent's parent gets child's original parent
+              new_parent_go.get_properties ().set_parent (get_parent ().as_octave_value ());
+            }
+
+          // Set parent property to new_parent and do adoption
+          parent = new_parent.as_octave_value ();
+          ::adopt (parent.handle_value (), __myhandle__);
+        }
       else
-        {
-          new_parent = gh_manager::lookup (hp);
-
-          if (new_parent.ok ())
-            {
-              // Remove child from current parent
-              graphics_object old_parent_go;
-              old_parent_go = gh_manager::get_object (get_parent ());
-
-              if (old_parent_go.get_handle () != hp)
-                old_parent_go.remove_child (__myhandle__);
-              else
-                return;  // Do nothing more
-
-              // Check new parent's parent is not this child to avoid recursion
-              graphics_object new_parent_go;
-              new_parent_go = gh_manager::get_object (new_parent);
-              if (new_parent_go.get_parent () == __myhandle__)
-                {
-                  // new parent's parent gets child's original parent
-                  new_parent_go.get_properties ().set_parent (get_parent ().as_octave_value ());
-                }
-
-              // Set parent property to new_parent and do adoption
-              parent = new_parent.as_octave_value ();
-              ::adopt (parent.handle_value (), __myhandle__);
-            }
-          else
-            error ("set: invalid graphics handle (= %g) for parent", hp);
-        }
-    }
-  else
-    error ("set: expecting parent to be a graphics handle");
+        error ("set: invalid graphics handle (= %g) for parent", hp);
+    }
 }
 
 /*
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = gca ();
 %!   set (hax, "parent", gcf ())
@@ -10167,62 +10152,59 @@ make_graphics_object (const std::string&
 
   double val = octave_NaN;
 
   octave_value_list xargs = args.splice (0, 1);
 
   caseless_str p ("parent");
 
   for (int i = 0; i < xargs.length (); i++)
-    if (xargs(i).is_string () && p.compare (xargs(i).string_value ()))
-      {
-        if (i < (xargs.length () - 1))
-          {
-            val = xargs(i+1).double_value ();
-
-            xargs = xargs.splice (i, 2);
-            break;
-          }
-        else
-          error ("__go_%s__: missing value for parent property",
-                 go_name.c_str ());
-      }
+    {
+      if (xargs(i).is_string () && p.compare (xargs(i).string_value ()))
+        {
+          if (i < (xargs.length () - 1))
+            {
+              val = xargs(i+1).double_value ();
+
+              xargs = xargs.splice (i, 2);
+              break;
+            }
+          else
+            error ("__go_%s__: missing value for parent property",
+                   go_name.c_str ());
+        }
+    }
 
   if (xisnan (val))
-    val = args(0).double_value ();
-
-  if (! error_state)
-    {
-      graphics_handle parent = gh_manager::lookup (val);
-
-      if (parent.ok ())
-        {
-          graphics_handle h
-            = gh_manager::make_graphics_handle (go_name, parent,
-                                                integer_figure_handle,
-                                                false, false);
-
-          if (! error_state)
-            {
-              adopt (parent, h);
-
-              xset (h, xargs);
-              xcreatefcn (h);
-              xinitialize (h);
-
-              retval = h.value ();
-
-              Vdrawnow_requested = true;
-            }
-          else
-            error ("__go%s__: unable to create graphics handle",
-                   go_name.c_str ());
+    val = args(0).xdouble_value ("__go_%s__: invalid parent", go_name.c_str ());
+
+  graphics_handle parent = gh_manager::lookup (val);
+
+  if (parent.ok ())
+    {
+      graphics_handle h
+        = gh_manager::make_graphics_handle (go_name, parent,
+                                            integer_figure_handle,
+                                            false, false);
+
+      if (! error_state)
+        {
+          adopt (parent, h);
+
+          xset (h, xargs);
+          xcreatefcn (h);
+          xinitialize (h);
+
+          retval = h.value ();
+
+          Vdrawnow_requested = true;
         }
       else
-        error ("__go_%s__: invalid parent", go_name.c_str ());
+        error ("__go%s__: unable to create graphics handle",
+               go_name.c_str ());
     }
   else
     error ("__go_%s__: invalid parent", go_name.c_str ());
 
   return retval;
 }
 
 DEFUN (__go_figure__, args, ,
@@ -10232,93 +10214,88 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () > 0)
     {
-      double val = args(0).double_value ();
-
-      if (! error_state)
-        {
-          if (is_figure (val))
-            {
-              graphics_handle h = gh_manager::lookup (val);
-
-              xset (h, args.splice (0, 1));
+      double val = args(0).xdouble_value ("__go_figure__: expecting figure number to be double value");
+
+      if (is_figure (val))
+        {
+          graphics_handle h = gh_manager::lookup (val);
+
+          xset (h, args.splice (0, 1));
+
+          retval = h.value ();
+        }
+      else
+        {
+          bool int_fig_handle = true;
+
+          octave_value_list xargs = args.splice (0, 1);
+
+          graphics_handle h = octave_NaN;
+
+          if (xisnan (val))
+            {
+              caseless_str pname ("integerhandle");
+
+              for (int i = 0; i < xargs.length (); i++)
+                {
+                  if (xargs(i).is_string ()
+                      && pname.compare (xargs(i).string_value ()))
+                    {
+                      if (i < (xargs.length () - 1))
+                        {
+                          std::string pval = xargs(i+1).string_value ();
+
+                          caseless_str on ("on");
+                          int_fig_handle = on.compare (pval);
+                          xargs = xargs.splice (i, 2);
+
+                          break;
+                        }
+                    }
+                }
+
+              h = gh_manager::make_graphics_handle ("figure", 0,
+                                                    int_fig_handle,
+                                                    false, false);
+
+              if (! int_fig_handle)
+                {
+                  // We need to initialize the integerhandle property
+                  // without calling the set_integerhandle method,
+                  // because doing that will generate a new handle value...
+
+                  graphics_object go = gh_manager::get_object (h);
+                  go.get_properties ().init_integerhandle ("off");
+                }
+            }
+          else if (val > 0 && D_NINT (val) == val)
+            h = gh_manager::make_figure_handle (val, false);
+
+          if (! error_state && h.ok ())
+            {
+              adopt (0, h);
+
+              gh_manager::push_figure (h);
+
+              xset (h, xargs);
+              xcreatefcn (h);
+              xinitialize (h);
 
               retval = h.value ();
             }
           else
-            {
-              bool int_fig_handle = true;
-
-              octave_value_list xargs = args.splice (0, 1);
-
-              graphics_handle h = octave_NaN;
-
-              if (xisnan (val))
-                {
-                  caseless_str pname ("integerhandle");
-
-                  for (int i = 0; i < xargs.length (); i++)
-                    {
-                      if (xargs(i).is_string ()
-                          && pname.compare (xargs(i).string_value ()))
-                        {
-                          if (i < (xargs.length () - 1))
-                            {
-                              std::string pval = xargs(i+1).string_value ();
-
-                              caseless_str on ("on");
-                              int_fig_handle = on.compare (pval);
-                              xargs = xargs.splice (i, 2);
-
-                              break;
-                            }
-                        }
-                    }
-
-                  h = gh_manager::make_graphics_handle ("figure", 0,
-                                                        int_fig_handle,
-                                                        false, false);
-
-                  if (! int_fig_handle)
-                    {
-                      // We need to initialize the integerhandle property
-                      // without calling the set_integerhandle method,
-                      // because doing that will generate a new handle value...
-
-                      graphics_object go = gh_manager::get_object (h);
-                      go.get_properties ().init_integerhandle ("off");
-                    }
-                }
-              else if (val > 0 && D_NINT (val) == val)
-                h = gh_manager::make_figure_handle (val, false);
-
-              if (! error_state && h.ok ())
-                {
-                  adopt (0, h);
-
-                  gh_manager::push_figure (h);
-
-                  xset (h, xargs);
-                  xcreatefcn (h);
-                  xinitialize (h);
-
-                  retval = h.value ();
-                }
-              else
-                error ("__go_figure__: failed to create figure handle");
-            }
-        }
-      else
-        error ("__go_figure__: expecting figure number to be double value");
+            error ("__go_figure__: failed to create figure handle");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #define GO_BODY(TYPE) \
@@ -10378,21 +10355,19 @@ Determine the number of dimensions in a 
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      double h = args(0).double_value ();
-      if (! error_state)
-        retval = calc_dimensions (gh_manager::get_object (h));
-      else
-        error ("__calc_dimensions__: expecting graphics handle as only argument");
+      double h = args(0).xdouble_value ("__calc_dimensions__: expecting graphics handle as only argument");
+
+      retval = calc_dimensions (gh_manager::get_object (h));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_axes__, args, ,
@@ -10530,37 +10505,32 @@ Undocumented internal function.\n\
   gh_manager::auto_lock guard;
 
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       graphics_handle h = octave_NaN;
 
-      const NDArray vals = args(0).array_value ();
-
-      if (! error_state)
-        {
-          // Check all the handles to delete are valid first, as callbacks
-          // might delete one of the handles we later want to delete
-          for (octave_idx_type i = 0; i < vals.numel (); i++)
-            {
-              h = gh_manager::lookup (vals(i));
-
-              if (! h.ok ())
-                {
-                  error ("delete: invalid graphics object (= %g)", vals(i));
-                  break;
-                }
-            }
-
-          delete_graphics_objects (vals);
-        }
-      else
-        error ("delete: invalid graphics object");
+      const NDArray vals = args(0).xarray_value ("delete: invalid graphics object");
+
+      // Check all the handles to delete are valid first, as callbacks
+      // might delete one of the handles we later want to delete
+      for (octave_idx_type i = 0; i < vals.numel (); i++)
+        {
+          h = gh_manager::lookup (vals(i));
+
+          if (! h.ok ())
+            {
+              error ("delete: invalid graphics object (= %g)", vals(i));
+              break;
+            }
+        }
+
+      delete_graphics_objects (vals);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_axes_init__, args, ,
@@ -10579,38 +10549,33 @@ Undocumented internal function.\n\
 
   if (nargin == 2)
     mode = args(1).string_value ();
 
   if (nargin == 1 || nargin == 2)
     {
       graphics_handle h = octave_NaN;
 
-      double val = args(0).double_value ();
-
-      if (! error_state)
-        {
+      double val = args(0).xdouble_value ("__go_axes_init__: invalid graphics object");
+
+      h = gh_manager::lookup (val);
+
+      if (h.ok ())
+        {
+          graphics_object go = gh_manager::get_object (h);
+
+          go.set_defaults (mode);
+
           h = gh_manager::lookup (val);
-
-          if (h.ok ())
-            {
-              graphics_object go = gh_manager::get_object (h);
-
-              go.set_defaults (mode);
-
-              h = gh_manager::lookup (val);
-              if (! h.ok ())
-                error ("__go_axes_init__: axis deleted during initialization (= %g)",
-                       val);
-            }
-          else
-            error ("__go_axes_init__: invalid graphics object (= %g)", val);
+          if (! h.ok ())
+            error ("__go_axes_init__: axis deleted during initialization (= %g)",
+                   val);
         }
       else
-        error ("__go_axes_init__: invalid graphics object");
+        error ("__go_axes_init__: invalid graphics object (= %g)", val);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_handles__, args, ,
@@ -10653,37 +10618,32 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
-      double val = args(0).double_value ();
-
-      if (! error_state)
-        {
-          graphics_handle h = gh_manager::lookup (val);
-
-          if (h.ok ())
-            {
-              std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
-
-              if (nargin == 2)
-                gh_manager::execute_callback (h, name);
-              else
-                gh_manager::execute_callback (h, name, args(2));
-            }
+      double val = args(0).xdouble_value ("__go_execute_callback__: invalid graphics object");
+
+      graphics_handle h = gh_manager::lookup (val);
+
+      if (h.ok ())
+        {
+          std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
+
+          if (nargin == 2)
+            gh_manager::execute_callback (h, name);
           else
-            error ("__go_execute_callback__: invalid graphics object (= %g)",
-                   val);
+            gh_manager::execute_callback (h, name, args(2));
         }
       else
-        error ("__go_execute_callback__: invalid graphics object");
+        error ("__go_execute_callback__: invalid graphics object (= %g)",
+               val);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__image_pixel_size__, args, ,
@@ -10693,36 +10653,31 @@ Internal function: returns the pixel siz
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      double h = args(0).double_value ();
-
-      if (! error_state)
-        {
-          graphics_object go = gh_manager::get_object (h);
-          if (go && go.isa ("image"))
-            {
-              image::properties& ip =
-                dynamic_cast<image::properties&> (go.get_properties ());
-
-              Matrix dp = Matrix (1, 2);
-              dp(0) = ip.pixel_xsize ();
-              dp(1) = ip.pixel_ysize ();
-              retval = dp;
-            }
-          else
-            error ("__image_pixel_size__: object is not an image");
+      double h = args(0).xdouble_value ("__image_pixel_size__: argument is not a handle");
+
+      graphics_object go = gh_manager::get_object (h);
+      if (go && go.isa ("image"))
+        {
+          image::properties& ip =
+            dynamic_cast<image::properties&> (go.get_properties ());
+
+          Matrix dp = Matrix (1, 2);
+          dp(0) = ip.pixel_xsize ();
+          dp(1) = ip.pixel_ysize ();
+          retval = dp;
         }
       else
-        error ("__image_pixel_size__: argument is not a handle");
+        error ("__image_pixel_size__: object is not an image");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 gtk_manager *gtk_manager::instance = 0;
@@ -10921,19 +10876,19 @@ undocumented.\n\
                     }
                 }
             }
 
           bool do_events = true;
 
           if (args.length () == 1)
             {
-              caseless_str val (args(0).string_value ());
-
-              if (! error_state && val.compare ("expose"))
+              caseless_str val (args(0).xstring_value ("drawnow: expecting argument to be a string"));
+
+              if (val.compare ("expose"))
                 do_events = false;
               else
                 {
                   error ("drawnow: invalid argument, expected 'expose' as argument");
 
                   gh_manager::unlock ();
 
                   return retval;
@@ -11000,40 +10955,35 @@ undocumented.\n\
 
                       gh_manager::unlock ();
 
                       return retval;
                     }
                 }
             }
 
-          mono = (args.length () >= 3 ? args(2).bool_value () : false);
-
-          if (! error_state)
-            {
-              debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: invalid DEBUG_FILE, expected a string value") : "");
-
-              graphics_handle h = gcf ();
-
-              if (h.ok ())
-                {
-                  graphics_object go = gh_manager::get_object (h);
-
-                  gh_manager::unlock ();
-
-                  go.get_toolkit ().print_figure (go, term, file,
-                                                  mono, debug_file);
-
-                  gh_manager::lock ();
-                }
-              else
-                error ("drawnow: nothing to draw");
+          mono = (args.length () >= 3 ? args(2).xbool_value ("drawnow: invalid colormode MONO, expected a boolean value") : false);
+
+          debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: invalid DEBUG_FILE, expected a string value") : "");
+
+          graphics_handle h = gcf ();
+
+          if (h.ok ())
+            {
+              graphics_object go = gh_manager::get_object (h);
+
+              gh_manager::unlock ();
+
+              go.get_toolkit ().print_figure (go, term, file,
+                                              mono, debug_file);
+
+              gh_manager::lock ();
             }
           else
-            error ("drawnow: invalid colormode MONO, expected a boolean value");
+            error ("drawnow: nothing to draw");
         }
       else
         print_usage ();
     }
 
   gh_manager::unlock ();
 
   return retval;
@@ -11075,42 +11025,37 @@ addlistener (gcf, \"position\", @{@@my_l
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3 && args.length () <= 4)
     {
-      double h = args(0).double_value ();
-
-      if (! error_state)
-        {
-          std::string pname = args(1).xstring_value ("addlistener: invalid property name, expected a string value");
-
-          graphics_handle gh = gh_manager::lookup (h);
-
-          if (gh.ok ())
-            {
-              graphics_object go = gh_manager::get_object (gh);
-
-              go.add_property_listener (pname, args(2), POSTSET);
-
-              if (args.length () == 4)
-                {
-                  caseless_str persistent = args(3).string_value ();
-                  if (persistent.compare ("persistent"))
-                    go.add_property_listener (pname, args(2), PERSISTENT);
-                }
-            }
-          else
-            error ("addlistener: invalid graphics object (= %g)", h);
+      double h = args(0).xdouble_value ("addlistener: invalid handle");
+
+      std::string pname = args(1).xstring_value ("addlistener: invalid property name, expected a string value");
+
+      graphics_handle gh = gh_manager::lookup (h);
+
+      if (gh.ok ())
+        {
+          graphics_object go = gh_manager::get_object (gh);
+
+          go.add_property_listener (pname, args(2), POSTSET);
+
+          if (args.length () == 4)
+            {
+              caseless_str persistent = args(3).string_value ();
+              if (persistent.compare ("persistent"))
+                go.add_property_listener (pname, args(2), PERSISTENT);
+            }
         }
       else
-        error ("addlistener: invalid handle");
+        error ("addlistener: invalid graphics object (= %g)", h);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (dellistener, args, ,
@@ -11142,49 +11087,44 @@ dellistener (gcf, \"position\", c);\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () == 3 || args.length () == 2)
     {
-      double h = args(0).double_value ();
-
-      if (! error_state)
-        {
-          std::string pname = args(1).xstring_value ("dellistener: invalid property name, expected a string value");
-
-          graphics_handle gh = gh_manager::lookup (h);
-
-          if (gh.ok ())
-            {
-              graphics_object go = gh_manager::get_object (gh);
-
-              if (args.length () == 2)
-                go.delete_property_listener (pname, octave_value (), POSTSET);
+      double h = args(0).xdouble_value ("dellistener: invalid handle");
+
+      std::string pname = args(1).xstring_value ("dellistener: invalid property name, expected a string value");
+
+      graphics_handle gh = gh_manager::lookup (h);
+
+      if (gh.ok ())
+        {
+          graphics_object go = gh_manager::get_object (gh);
+
+          if (args.length () == 2)
+            go.delete_property_listener (pname, octave_value (), POSTSET);
+          else
+            {
+              if (args(2).is_string ()
+                  && args(2).string_value () == "persistent")
+                {
+                  go.delete_property_listener (pname, octave_value (),
+                                               PERSISTENT);
+                  go.delete_property_listener (pname, octave_value (),
+                                               POSTSET);
+                }
               else
-                {
-                  if (args(2).is_string ()
-                      && args(2).string_value () == "persistent")
-                    {
-                      go.delete_property_listener (pname, octave_value (),
-                                                   PERSISTENT);
-                      go.delete_property_listener (pname, octave_value (),
-                                                   POSTSET);
-                    }
-                  else
-                    go.delete_property_listener (pname, args(2), POSTSET);
-                }
-            }
-          else
-            error ("dellistener: invalid graphics object (= %g)", h);
+                go.delete_property_listener (pname, args(2), POSTSET);
+            }
         }
       else
-        error ("dellistener: invalid handle");
+        error ("dellistener: invalid graphics object (= %g)", h);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (addproperty, args, ,
@@ -11262,44 +11202,39 @@ addproperty (\"my_style\", gcf, \"lineli
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
       std::string name = args(0).xstring_value ("addproperty: invalid property NAME, expected a string value");
 
-      double h = args(1).double_value ();
-
-      if (! error_state)
-        {
-          graphics_handle gh = gh_manager::lookup (h);
-
-          if (gh.ok ())
-            {
-              graphics_object go = gh_manager::get_object (gh);
-
-              std::string type = args(2).xstring_value ("addproperty: invalid property TYPE, expected a string value");
-
-              if (! go.get_properties ().has_property (name))
-                {
-                  property p = property::create (name, gh, type,
-                                                 args.splice (0, 3));
-
-                  go.get_properties ().insert_property (name, p);
-                }
-              else
-                error ("addproperty: a '%s' property already exists in the graphics object",
-                       name.c_str ());
+      double h = args(1).xdouble_value ("addproperty: invalid handle value");
+
+      graphics_handle gh = gh_manager::lookup (h);
+
+      if (gh.ok ())
+        {
+          graphics_object go = gh_manager::get_object (gh);
+
+          std::string type = args(2).xstring_value ("addproperty: invalid property TYPE, expected a string value");
+
+          if (! go.get_properties ().has_property (name))
+            {
+              property p = property::create (name, gh, type,
+                                             args.splice (0, 3));
+
+              go.get_properties ().insert_property (name, p);
             }
           else
-            error ("addproperty: invalid graphics object (= %g)", h);
+            error ("addproperty: a '%s' property already exists in the graphics object",
+                   name.c_str ());
         }
       else
-        error ("addproperty: invalid handle value");
+        error ("addproperty: invalid graphics object (= %g)", h);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -11489,224 +11424,214 @@ To define a condition on a property name
 @code{\\timeout} instead.\n\
 \n\
 In all cases, typing CTRL-C stops program execution immediately.\n\
 @seealso{waitforbuttonpress, isequal}\n\
 @end deftypefn")
 {
   if (args.length () > 0)
     {
-      double h = args(0).double_value ();
-
-      if (! error_state)
-        {
-          caseless_str pname;
-
-          unwind_protect frame;
-
-          static uint32_t id_counter = 0;
-          uint32_t id = 0;
-
-          int max_arg_index = 0;
-          int timeout_index = -1;
-
-          int timeout = 0;
-
-          if (args.length () > 1)
-            {
-              pname = args(1).string_value ();
-
-              if (! error_state
-                  && ! pname.empty () && ! pname.compare ("timeout"))
+      double h = args(0).xdouble_value ("waitfor: invalid handle value");
+
+      caseless_str pname;
+
+      unwind_protect frame;
+
+      static uint32_t id_counter = 0;
+      uint32_t id = 0;
+
+      int max_arg_index = 0;
+      int timeout_index = -1;
+
+      int timeout = 0;
+
+      if (args.length () > 1)
+        {
+          pname = args(1).string_value ();
+
+          if (! error_state
+              && ! pname.empty () && ! pname.compare ("timeout"))
+            {
+              if (pname.compare ("\\timeout"))
+                pname = "timeout";
+
+              static octave_value wf_listener;
+
+              if (! wf_listener.is_defined ())
+                wf_listener =
+                  octave_value (new octave_builtin (waitfor_listener,
+                                                    "waitfor_listener"));
+
+              max_arg_index++;
+              if (args.length () > 2)
                 {
-                  if (pname.compare ("\\timeout"))
-                    pname = "timeout";
-
-                  static octave_value wf_listener;
-
-                  if (! wf_listener.is_defined ())
-                    wf_listener =
-                      octave_value (new octave_builtin (waitfor_listener,
-                                                        "waitfor_listener"));
-
-                  max_arg_index++;
-                  if (args.length () > 2)
+                  if (args(2).is_string ())
                     {
-                      if (args(2).is_string ())
-                        {
-                          caseless_str s = args(2).string_value ();
-
-                          if (s.compare ("timeout"))
-                            timeout_index = 2;
-                          else
-                            max_arg_index++;
-                        }
+                      caseless_str s = args(2).string_value ();
+
+                      if (s.compare ("timeout"))
+                        timeout_index = 2;
                       else
                         max_arg_index++;
                     }
-
-                  Cell listener (1, max_arg_index >= 2 ? 5 : 4);
-
-                  id = id_counter++;
-                  frame.add_fcn (cleanup_waitfor_id, id);
-                  waitfor_results[id] = false;
-
-                  listener(0) = wf_listener;
-                  listener(1) = octave_uint32 (id);
-                  listener(2) = h;
-                  listener(3) = pname;
-
-                  if (max_arg_index >= 2)
-                    listener(4) = args(2);
-
-                  octave_value ov_listener (listener);
-
-                  gh_manager::auto_lock guard;
-
-                  graphics_handle gh = gh_manager::lookup (h);
-
-                  if (gh.ok ())
+                  else
+                    max_arg_index++;
+                }
+
+              Cell listener (1, max_arg_index >= 2 ? 5 : 4);
+
+              id = id_counter++;
+              frame.add_fcn (cleanup_waitfor_id, id);
+              waitfor_results[id] = false;
+
+              listener(0) = wf_listener;
+              listener(1) = octave_uint32 (id);
+              listener(2) = h;
+              listener(3) = pname;
+
+              if (max_arg_index >= 2)
+                listener(4) = args(2);
+
+              octave_value ov_listener (listener);
+
+              gh_manager::auto_lock guard;
+
+              graphics_handle gh = gh_manager::lookup (h);
+
+              if (gh.ok ())
+                {
+                  graphics_object go = gh_manager::get_object (gh);
+
+                  if (max_arg_index >= 2
+                      && compare_property_values (go.get (pname),
+                                                  args(2)))
+                    waitfor_results[id] = true;
+                  else
                     {
-                      graphics_object go = gh_manager::get_object (gh);
-
-                      if (max_arg_index >= 2
-                          && compare_property_values (go.get (pname),
-                                                      args(2)))
-                        waitfor_results[id] = true;
-                      else
+
+                      frame.add_fcn (cleanup_waitfor_postset_listener,
+                                     ov_listener);
+                      go.add_property_listener (pname, ov_listener,
+                                                POSTSET);
+                      go.add_property_listener (pname, ov_listener,
+                                                PERSISTENT);
+
+                      if (go.get_properties ()
+                          .has_dynamic_property (pname))
                         {
-
-                          frame.add_fcn (cleanup_waitfor_postset_listener,
-                                         ov_listener);
-                          go.add_property_listener (pname, ov_listener,
-                                                    POSTSET);
-                          go.add_property_listener (pname, ov_listener,
-                                                    PERSISTENT);
-
-                          if (go.get_properties ()
-                              .has_dynamic_property (pname))
-                            {
-                              static octave_value wf_del_listener;
-
-                              if (! wf_del_listener.is_defined ())
-                                wf_del_listener =
-                                  octave_value (new octave_builtin
-                                                (waitfor_del_listener,
-                                                 "waitfor_del_listener"));
-
-                              Cell del_listener (1, 4);
-
-                              del_listener(0) = wf_del_listener;
-                              del_listener(1) = octave_uint32 (id);
-                              del_listener(2) = h;
-                              del_listener(3) = pname;
-
-                              octave_value ov_del_listener (del_listener);
-
-                              frame.add_fcn (cleanup_waitfor_predelete_listener,
-                                             ov_del_listener);
-                              go.add_property_listener (pname, ov_del_listener,
-                                                        PREDELETE);
-                            }
+                          static octave_value wf_del_listener;
+
+                          if (! wf_del_listener.is_defined ())
+                            wf_del_listener =
+                              octave_value (new octave_builtin
+                                            (waitfor_del_listener,
+                                             "waitfor_del_listener"));
+
+                          Cell del_listener (1, 4);
+
+                          del_listener(0) = wf_del_listener;
+                          del_listener(1) = octave_uint32 (id);
+                          del_listener(2) = h;
+                          del_listener(3) = pname;
+
+                          octave_value ov_del_listener (del_listener);
+
+                          frame.add_fcn (cleanup_waitfor_predelete_listener,
+                                         ov_del_listener);
+                          go.add_property_listener (pname, ov_del_listener,
+                                                    PREDELETE);
                         }
                     }
                 }
-              else if (error_state || pname.empty ())
-                error ("waitfor: invalid property name, expected a non-empty string value");
-            }
-
-          if (timeout_index < 0 && args.length () > (max_arg_index + 1))
-            {
-              caseless_str s = args(max_arg_index + 1).string_value ();
-
-              if (! error_state)
-                {
-                  if (s.compare ("timeout"))
-                    timeout_index = max_arg_index + 1;
-                  else
-                    error ("waitfor: invalid parameter '%s'", s.c_str ());
-                }
+            }
+          else if (error_state || pname.empty ())
+            error ("waitfor: invalid property name, expected a non-empty string value");
+        }
+
+      if (timeout_index < 0 && args.length () > (max_arg_index + 1))
+        {
+          caseless_str s = args(max_arg_index + 1).string_value ();
+
+          if (! error_state)
+            {
+              if (s.compare ("timeout"))
+                timeout_index = max_arg_index + 1;
               else
-                error ("waitfor: invalid parameter, expected 'timeout'");
-            }
-
-          if (timeout_index >= 0)
-            {
-              if (args.length () > (timeout_index + 1))
+                error ("waitfor: invalid parameter '%s'", s.c_str ());
+            }
+          else
+            error ("waitfor: invalid parameter, expected 'timeout'");
+        }
+
+      if (timeout_index >= 0)
+        {
+          if (args.length () > (timeout_index + 1))
+            {
+              timeout = static_cast<int>
+                (args(timeout_index + 1).xscalar_value ("waitfor: invalid timeout value, expected a value >= 1"));
+
+              if (timeout < 1)
                 {
-                  timeout = static_cast<int>
-                            (args(timeout_index + 1).scalar_value ());
-
-                  if (! error_state)
-                    {
-                      if (timeout < 1)
-                        {
-                          warning ("waitfor: the timeout value must be >= 1, using 1 instead");
-                          timeout = 1;
-                        }
-                    }
-                  else
-                    error ("waitfor: invalid timeout value, expected a value >= 1");
+                  warning ("waitfor: the timeout value must be >= 1, using 1 instead");
+                  timeout = 1;
+                }
+            }
+          else
+            error ("waitfor: missing timeout value");
+        }
+
+      // FIXME: There is still a "hole" in the following loop. The code
+      //        assumes that an object handle is unique, which is a fair
+      //        assumption, except for figures.  If a figure is destroyed
+      //        then recreated with the same figure ID, within the same
+      //        run of event hooks, then the figure destruction won't be
+      //        caught and the loop will not stop.  This is an unlikely
+      //        possibility in practice, though.
+      //
+      //        Using deletefcn callback is also unreliable as it could be
+      //        modified during a callback execution and the waitfor loop
+      //        would not stop.
+      //
+      //        The only "good" implementation would require object
+      //        listeners, similar to property listeners.
+
+      time_t start = 0;
+
+      if (timeout > 0)
+        start = time (0);
+
+      while (true)
+        {
+          if (true)
+            {
+              gh_manager::auto_lock guard;
+
+              graphics_handle gh = gh_manager::lookup (h);
+
+              if (gh.ok ())
+                {
+                  if (! pname.empty () && waitfor_results[id])
+                    break;
                 }
               else
-                error ("waitfor: missing timeout value");
-            }
-
-          // FIXME: There is still a "hole" in the following loop. The code
-          //        assumes that an object handle is unique, which is a fair
-          //        assumption, except for figures.  If a figure is destroyed
-          //        then recreated with the same figure ID, within the same
-          //        run of event hooks, then the figure destruction won't be
-          //        caught and the loop will not stop.  This is an unlikely
-          //        possibility in practice, though.
-          //
-          //        Using deletefcn callback is also unreliable as it could be
-          //        modified during a callback execution and the waitfor loop
-          //        would not stop.
-          //
-          //        The only "good" implementation would require object
-          //        listeners, similar to property listeners.
-
-          time_t start = 0;
+                break;
+            }
+
+          octave_usleep (100000);
+
+          OCTAVE_QUIT;
+
+          command_editor::run_event_hooks ();
 
           if (timeout > 0)
-            start = time (0);
-
-          while (true)
-            {
-              if (true)
-                {
-                  gh_manager::auto_lock guard;
-
-                  graphics_handle gh = gh_manager::lookup (h);
-
-                  if (gh.ok ())
-                    {
-                      if (! pname.empty () && waitfor_results[id])
-                        break;
-                    }
-                  else
-                    break;
-                }
-
-              octave_usleep (100000);
-
-              OCTAVE_QUIT;
-
-              command_editor::run_event_hooks ();
-
-              if (timeout > 0)
-                {
-                  if (start + timeout < time (0))
-                    break;
-                }
-            }
-        }
-      else
-        error ("waitfor: invalid handle value.");
+            {
+              if (start + timeout < time (0))
+                break;
+            }
+        }
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 DEFUN (__zoom__, args, ,
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -1283,36 +1283,31 @@ for input.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string hook_fcn_id = args(0).string_value ();
+      std::string hook_fcn_id = args(0).string_value ("remove_input_event_hook: argument not valid as a hook function name or id");
 
       bool warn = (nargin < 2);
 
-      if (! error_state)
-        {
-          hook_function_list::iterator p
-            = input_event_hook_functions.find (hook_fcn_id);
+      hook_function_list::iterator p
+        = input_event_hook_functions.find (hook_fcn_id);
 
-          if (p != input_event_hook_functions.end ())
-            input_event_hook_functions.erase (p);
-          else if (warn)
-            warning ("remove_input_event_hook: %s not found in list",
-                     hook_fcn_id.c_str ());
+      if (p != input_event_hook_functions.end ())
+        input_event_hook_functions.erase (p);
+      else if (warn)
+        warning ("remove_input_event_hook: %s not found in list",
+                 hook_fcn_id.c_str ());
 
-          if (input_event_hook_functions.empty ())
-            command_editor::remove_event_hook (internal_input_event_hook_fcn);
-        }
-      else
-        error ("remove_input_event_hook: argument not valid as a hook function name or id");
+      if (input_event_hook_functions.empty ())
+        command_editor::remove_event_hook (internal_input_event_hook_fcn);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2422,32 +2422,24 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
               append = true;
               nargin--;
             }
           else if (option == "-begin")
             nargin--;
         }
       else if (option_arg.is_numeric_type ())
         {
-          int val = option_arg.int_value ();
-
-          if (! error_state)
+          int val = option_arg.xint_value ("addpath: expecting final argument to be 1 or 0");
+
+          if (val == 0)
+            nargin--;
+          else if (val == 1)
             {
-              if (val == 0)
-                nargin--;
-              else if (val == 1)
-                {
-                  append = true;
-                  nargin--;
-                }
-              else
-                {
-                  error ("addpath: expecting final argument to be 1 or 0");
-                  return retval;
-                }
+              append = true;
+              nargin--;
             }
           else
             {
               error ("addpath: expecting final argument to be 1 or 0");
               return retval;
             }
         }
 
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -118,63 +118,55 @@ values of @var{p} @var{q} as vector valu
         {
           if (args(1).string_value () == "0")
             zero_level = true;
           else
             error ("luinc: unrecognized string argument");
         }
       else if (args(1).is_map ())
         {
-          octave_scalar_map map = args(1).scalar_map_value ();
+          octave_scalar_map map = args(1).xscalar_map_value ("luinc: OPTS must be a scalar structure");
+
+          octave_value tmp;
 
-          if (! error_state)
-            {
-              octave_value tmp;
-
-              tmp = map.getfield ("droptol");
-              if (tmp.is_defined ())
-                droptol = tmp.double_value ();
+          tmp = map.getfield ("droptol");
+          if (tmp.is_defined ())
+            droptol = tmp.double_value ();
 
-              tmp = map.getfield ("milu");
-              if (tmp.is_defined ())
-                {
-                  double val = tmp.double_value ();
+          tmp = map.getfield ("milu");
+          if (tmp.is_defined ())
+            {
+              double val = tmp.double_value ();
 
-                  milu = (val == 0. ? false : true);
-                }
-
-              tmp = map.getfield ("udiag");
-              if (tmp.is_defined ())
-                {
-                  double val = tmp.double_value ();
+              milu = (val == 0. ? false : true);
+            }
 
-                  udiag = (val == 0. ? false : true);
-                }
+          tmp = map.getfield ("udiag");
+          if (tmp.is_defined ())
+            {
+              double val = tmp.double_value ();
 
-              tmp = map.getfield ("thresh");
-              if (tmp.is_defined ())
-                {
-                  thresh = tmp.matrix_value ();
+              udiag = (val == 0. ? false : true);
+            }
 
-                  if (thresh.numel () == 1)
-                    {
-                      thresh.resize (1,2);
-                      thresh(1) = thresh(0);
-                    }
-                  else if (thresh.numel () != 2)
-                    {
-                      error ("luinc: expecting 2-element vector for thresh");
-                      return retval;
-                    }
+          tmp = map.getfield ("thresh");
+          if (tmp.is_defined ())
+            {
+              thresh = tmp.matrix_value ();
+
+              if (thresh.numel () == 1)
+                {
+                  thresh.resize (1,2);
+                  thresh(1) = thresh(0);
                 }
-            }
-          else
-            {
-              error ("luinc: OPTS must be a scalar structure");
-              return retval;
+              else if (thresh.numel () != 2)
+                {
+                  error ("luinc: expecting 2-element vector for thresh");
+                  return retval;
+                }
             }
         }
       else
         droptol = args(1).double_value ();
 
       if (nargin == 3)
         {
           std::string tmp = args(2).string_value ();
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -237,31 +237,26 @@ LU@tie{}factorization.  Once the matrix 
                 mattyp.mark_as_lower_triangular ();
               else if (str_typ == "banded"
                        || str_typ == "banded positive definite")
                 {
                   if (nargin != 4)
                     error ("matrix_type: banded matrix type requires 4 arguments");
                   else
                     {
-                      nl = args(2).nint_value ();
-                      nu = args(3).nint_value ();
+                      nl = args(2).xnint_value ("matrix_type: band size NL, NU must be integers");
+                      nu = args(3).xnint_value ("matrix_type: band size NL, NU must be integers");
 
-                      if (error_state)
-                        error ("matrix_type: band size NL, NU must be integers");
+                      if (nl == 1 && nu == 1)
+                        mattyp.mark_as_tridiagonal ();
                       else
-                        {
-                          if (nl == 1 && nu == 1)
-                            mattyp.mark_as_tridiagonal ();
-                          else
-                            mattyp.mark_as_banded (nu, nl);
+                        mattyp.mark_as_banded (nu, nl);
 
-                          if (str_typ == "banded positive definite")
-                            mattyp.mark_as_symmetric ();
-                        }
+                      if (str_typ == "banded positive definite")
+                        mattyp.mark_as_symmetric ();
                     }
                 }
               else if (str_typ == "positive definite")
                 {
                   mattyp.mark_as_full ();
                   mattyp.mark_as_symmetric ();
                 }
               else if (str_typ == "singular")
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2354,23 +2354,20 @@ int
 printf_value_cache::int_value (void)
 {
   int retval = 0;
 
   octave_value val = get_next_value ();
 
   double dval = val.double_value (true);
 
-  if (! error_state)
-    {
-      if (D_NINT (dval) == dval)
-        retval = NINT (dval);
-      else
-        curr_state = conversion_error;
-    }
+  if (D_NINT (dval) == dval)
+    retval = NINT (dval);
+  else
+    curr_state = conversion_error;
 
   return retval;
 }
 
 // Ugh again and again.
 
 template <class T>
 int
@@ -3063,67 +3060,62 @@ octave_stream::seek (off_t offset, int o
 
 int
 octave_stream::seek (const octave_value& tc_offset,
                      const octave_value& tc_origin)
 {
   int retval = -1;
 
   // FIXME: should we have octave_value methods that handle off_t explicitly?
-  octave_int64 val = tc_offset.int64_scalar_value ();
+  octave_int64 val = tc_offset.xint64_scalar_value ("fseek: invalid value for offset");
   off_t xoffset = val.value ();
 
-  if (! error_state)
+  int conv_err = 0;
+
+  int origin = SEEK_SET;
+
+  if (tc_origin.is_string ())
     {
-      int conv_err = 0;
-
-      int origin = SEEK_SET;
-
-      if (tc_origin.is_string ())
+      std::string xorigin = tc_origin.string_value ("fseek: invalid value for origin");
+
+      if (xorigin == "bof")
+        origin = SEEK_SET;
+      else if (xorigin == "cof")
+        origin = SEEK_CUR;
+      else if (xorigin == "eof")
+        origin = SEEK_END;
+      else
+        conv_err = -1;
+    }
+  else
+    {
+      int xorigin = convert_to_valid_int (tc_origin, conv_err);
+
+      if (! conv_err)
         {
-          std::string xorigin = tc_origin.string_value ();
-
-          if (xorigin == "bof")
+          if (xorigin == -1)
             origin = SEEK_SET;
-          else if (xorigin == "cof")
+          else if (xorigin == 0)
             origin = SEEK_CUR;
-          else if (xorigin == "eof")
+          else if (xorigin == 1)
             origin = SEEK_END;
           else
             conv_err = -1;
         }
-      else
-        {
-          int xorigin = convert_to_valid_int (tc_origin, conv_err);
-
-          if (! conv_err)
-            {
-              if (xorigin == -1)
-                origin = SEEK_SET;
-              else if (xorigin == 0)
-                origin = SEEK_CUR;
-              else if (xorigin == 1)
-                origin = SEEK_END;
-              else
-                conv_err = -1;
-            }
-        }
-
-      if (! conv_err)
-        {
-          retval = seek (xoffset, origin);
-
-          if (retval != 0)
-            error ("fseek: failed to seek to requested position");
-        }
-      else
-        error ("fseek: invalid value for origin");
+    }
+
+  if (! conv_err)
+    {
+      retval = seek (xoffset, origin);
+
+      if (retval != 0)
+        error ("fseek: failed to seek to requested position");
     }
   else
-    error ("fseek: invalid value for offset");
+    error ("fseek: invalid value for origin");
 
   return retval;
 }
 
 off_t
 octave_stream::tell (void)
 {
   off_t retval = -1;
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -134,23 +134,18 @@ is in the upper left corner, by doing:\n
     }
 
   const bool double_type  = args(0).is_double_type ()
                             || args(1).is_double_type ();
   const bool complex_type = args(0).is_complex_type ()
                             || args(1).is_complex_type ();
 
 #define PREPARE_ARGS(TYPE, TYPE_M, TYPE_COND) \
-          TYPE ## Matrix U = args(0).TYPE_M ## _value (); \
-          TYPE ## Matrix S = args(1).TYPE_M ## _value (); \
-          if (error_state) \
-            { \
-              error ("ordschur: U and S must be real or complex floating point matrices"); \
-              return retval; \
-            } \
+          TYPE ## Matrix U = args(0).x ## TYPE_M ## _value ("ordschur: U and S must be real or complex floating point matrices"); \
+          TYPE ## Matrix S = args(1).x ## TYPE_M ## _value ("ordschur: U and S must be real or complex floating point matrices"); \
           TYPE ## Matrix w (dim_vector (n, 1)); \
           TYPE ## Matrix work (dim_vector (n, 1)); \
           octave_idx_type m; \
           octave_idx_type info; \
           TYPE_COND cond1, cond2;
 
 #define PREPARE_OUTPUT()\
           if (info != 0) \
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -70,20 +70,20 @@ can have any value real or complex value
   const octave_idx_type nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
   const octave_value oct_z = (nargin == 1) ? args(0) : args(1);
-  const octave_idx_type k = (nargin == 1) ? 0 : args(0).idx_type_value ();
-  if (error_state || k < 0)
+  const octave_idx_type k = (nargin == 1) ? 0 : args(0).idx_type_value ("psi: K must be an integer");
+  if (k < 0)
     {
-      error ("psi: K must be a non-negative integer");
+      error ("psi: K must be non-negative");
       return retval;
     }
   else if (k == 0)
     {
 #define FLOAT_BRANCH(T, A, M, E) \
       if (oct_z.is_ ## T ##_type ()) \
         { \
           const A ## NDArray z = oct_z.M ## array_value (); \
@@ -227,14 +227,15 @@ can have any value real or complex value
 %!   ## our precision goes down really quick when computing n is too high,
 %!   assert (psi (n, z+1), psi (n, z) + ((-1)^n) * factorial (n) * (z.^(-n-1)), 0.1)
 %! endfor
 
 ## Test input validation
 %!error psi ()
 %!error psi (1, 2, 3)
 %!error <Z must be> psi ("non numeric")
-%!error <K must be a non-negative integer> psi (-5, 1)
+%!error <conversion of 5.3 to int value failed> psi (5.3, 1)
+%!error <K must be non-negative> psi (-5, 1)
 %!error <Z must be non-negative for polygamma> psi (5, -1)
 %!error <Z must be a floating point> psi (5, uint8 (-1))
 %!error <Z must be real value for polygamma> psi (5, 5i)
 
 */
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -89,22 +89,18 @@ do_rand (const octave_value_list& args, 
         {
           error ("%s: expecting at least one argument", fcn);
           goto done;
         }
       else if (args(0).is_string ())
         additional_arg = false;
       else
         {
-          a = args(0).array_value ();
-          if (error_state)
-            {
-              error ("%s: expecting scalar or matrix arguments", fcn);
-              goto done;
-            }
+          a = args(0).xarray_value ("%s: expecting scalar or matrix arguments", fcn);
+
           idx++;
           nargin--;
         }
     }
 
   switch (nargin)
     {
     case 0:
@@ -281,22 +277,18 @@ do_rand (const octave_value_list& args, 
               error ("%s: unrecognized string argument", fcn);
           }
         else
           {
             dims.resize (nargin);
 
             for (int i = 0; i < nargin; i++)
               {
-                octave_idx_type elt = args(idx+i).int_value ();
-                if (error_state)
-                  {
-                    error ("%s: expecting integer arguments", fcn);
-                    goto done;
-                  }
+                octave_idx_type elt = args(idx+i).xint_value ("%s: expecting integer arguments", fcn);
+
                 //Negative is zero for Matlab compatibility
                 dims(i) = elt >= 0 ? elt : 0;
               }
 
             goto gen_matrix;
           }
       }
       break;
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -150,35 +150,31 @@ longer running time.\n\
               if (xisnan (val))
                 error ("spparms: KEY not recognized");
               else
                 retval(0) = val;
             }
         }
       else
         {
-          NDArray vals = args(0).array_value ();
+          NDArray vals = args(0).xarray_value ("spparms: input must be a string or a vector");
 
-          if (error_state)
-            error ("spparms: input must be a string or a vector");
-          else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
+          if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
             error ("spparms: too many elements in vector VALS");
           else
             octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
       std::string str = args(0).xstring_value ("spparms: first argument must be a string");
 
-      double val = args(1).double_value ();
+      double val = args(1).xdouble_value ("spparms: second argument must be a real scalar");
 
-      if (error_state)
-        error ("spparms: second argument must be a real scalar");
-      else if (str == "umfpack")
+      if (str == "umfpack")
         warning ("spparms: request to disable umfpack solvers ignored");
       else if (!octave_sparse_params::set_key (str, val))
         error ("spparms: KEY not found");
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -90,23 +90,17 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
       int n_elts = 0;
 
       int max_len = 0;
 
       std::queue<string_vector> args_as_strings;
 
       for (int i = 0; i < nargin; i++)
         {
-          string_vector s = args(i).all_strings ();
-
-          if (error_state)
-            {
-              error ("char: unable to convert some args to strings");
-              return retval;
-            }
+          string_vector s = args(i).xall_strings ("char: unable to convert some args to strings");
 
           if (s.numel () > 0)
             n_elts += s.numel ();
           else
             n_elts += 1;
 
           int s_max_len = s.max_length ();
 
@@ -211,23 +205,17 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
 
   int nargin = args.length ();
   int n_elts = 0;
   size_t max_len = 0;
   std::queue<string_vector> args_as_strings;
 
   for (int i = 0; i < nargin; i++)
     {
-      string_vector s = args(i).all_strings ();
-
-      if (error_state)
-        {
-          error ("strvcat: unable to convert some args to strings");
-          return retval;
-        }
+      string_vector s = args(i).xall_strings ("strvcat: unable to convert some args to strings");
 
       size_t n = s.numel ();
 
       // do not count empty strings in calculation of number of elements
       if (n > 0)
         {
           for (size_t j = 0; j < n; j++)
             {
@@ -894,36 +882,22 @@ whos ans\n\
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
 
-  string_vector s = args(0).all_strings ();
-
-  if (error_state)
-    {
-      error ("list_in_columns: ARG must be a cellstr or char array");
-      return retval;
-    }
+  string_vector s = args(0).xall_strings ("list_in_columns: ARG must be a cellstr or char array");
 
   int width = -1;
 
   if (nargin > 1 && ! args(1).is_empty ())
-    {
-      width = args(1).int_value ();
-
-      if (error_state)
-        {
-          error ("list_in_columns: WIDTH must be an integer");
-          return retval;
-        }
-    }
+    width = args(1).xint_value ("list_in_columns: WIDTH must be an integer");
 
   std::string prefix;
 
   if (nargin > 2)
     prefix = args(2).xstring_value ("list_in_columns: PREFIX must be a string");
 
   std::ostringstream buf;
 
@@ -946,10 +920,10 @@ whos ans\n\
 %!test
 %! input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
 %! result = "  abc     mnop  \n  def     qrs   \n  ghijkl  tuv   \n";
 %! assert (list_in_columns (input, 20, "  "), result);
 
 %!error list_in_columns ()
 %!error list_in_columns (["abc", "def"], 20, 2)
 %!error list_in_columns (["abc", "def"], 20, "  ", 3)
-%!error <invalid conversion from string to real scalar> list_in_columns (["abc", "def"], "a")
+%!error <list_in_columns: WIDTH must be an integer> list_in_columns (["abc", "def"], "a")
 */
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1790,22 +1790,19 @@ Undocumented internal function.\n\
             {
               symbol_table::dump_functions (octave_stdout);
             }
           else
             error ("__dump_symtab_info__: expecting \"functions\" or \"scopes\"");
         }
       else
         {
-          int s = arg.int_value ();
+          int s = arg.xint_value ("__dump_symtab_info__: expecting string or scope id");
 
-          if (! error_state)
-            symbol_table::dump (octave_stdout, s);
-          else
-            error ("__dump_symtab_info__: expecting string or scope id");
+          symbol_table::dump (octave_stdout, s);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -190,31 +190,26 @@ error message.\n\
   if (nargin == 1 || nargin == 2)
     {
       std::string exec_file = args(0).xstring_value ("exec: FILE must be a string");
 
       string_vector exec_args;
 
       if (nargin == 2)
         {
-          string_vector tmp = args(1).all_strings ();
+          string_vector tmp = args(1).xall_strings ("exec: all arguments must be strings");
 
-          if (! error_state)
-            {
-              int len = tmp.numel ();
-
-              exec_args.resize (len + 1);
+          int len = tmp.numel ();
 
-              exec_args[0] = exec_file;
+          exec_args.resize (len + 1);
 
-              for (int i = 0; i < len; i++)
-                exec_args[i+1] = tmp[i];
-            }
-          else
-            error ("exec: all arguments must be strings");
+          exec_args[0] = exec_file;
+
+          for (int i = 0; i < len; i++)
+            exec_args[i+1] = tmp[i];
         }
       else
         {
           exec_args.resize (1);
 
           exec_args[0] = exec_file;
         }
 
@@ -294,73 +289,63 @@ exit status, it will linger until Octave
   if (nargin >= 1 && nargin <= 3)
     {
       std::string exec_file = args(0).xstring_value ("popen2: COMMAND argument must be a string");
 
       string_vector arg_list;
 
       if (nargin >= 2)
         {
-          string_vector tmp = args(1).all_strings ();
+          string_vector tmp = args(1).xall_strings ("popen2: all arguments must be strings");
 
-          if (! error_state)
-            {
-              int len = tmp.numel ();
-
-              arg_list.resize (len + 1);
+          int len = tmp.numel ();
 
-              arg_list[0] = exec_file;
+          arg_list.resize (len + 1);
 
-              for (int i = 0; i < len; i++)
-                arg_list[i+1] = tmp[i];
-            }
-          else
-            error ("popen2: all arguments must be strings");
+          arg_list[0] = exec_file;
+
+          for (int i = 0; i < len; i++)
+            arg_list[i+1] = tmp[i];
         }
       else
         {
           arg_list.resize (1);
 
           arg_list[0] = exec_file;
         }
 
-      if (! error_state)
-        {
-          bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
+      bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
+
+      int fildes[2];
+      std::string msg;
+      pid_t pid;
 
-          int fildes[2];
-          std::string msg;
-          pid_t pid;
-
-          pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
-                                         fildes, msg, interactive);
-          if (pid >= 0)
-            {
-              FILE *ifile = fdopen (fildes[1], "r");
-              FILE *ofile = fdopen (fildes[0], "w");
+      pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
+                                     fildes, msg, interactive);
+      if (pid >= 0)
+        {
+          FILE *ifile = fdopen (fildes[1], "r");
+          FILE *ofile = fdopen (fildes[0], "w");
 
-              std::string nm;
+          std::string nm;
 
-              octave_stream is = octave_stdiostream::create (nm, ifile,
-                                                             std::ios::in);
-
-              octave_stream os = octave_stdiostream::create (nm, ofile,
-                                                             std::ios::out);
+          octave_stream is = octave_stdiostream::create (nm, ifile,
+                                                         std::ios::in);
 
-              Cell file_ids (1, 2);
+          octave_stream os = octave_stdiostream::create (nm, ofile,
+                                                         std::ios::out);
 
-              retval(2) = pid;
-              retval(1) = octave_stream_list::insert (is);
-              retval(0) = octave_stream_list::insert (os);
-            }
-          else
-            error (msg.c_str ());
+          Cell file_ids (1, 2);
+
+          retval(2) = pid;
+          retval(1) = octave_stream_list::insert (is);
+          retval(0) = octave_stream_list::insert (os);
         }
       else
-        error ("popen2: all arguments must be strings");
+        error (msg.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -840,38 +825,33 @@ error message.\n\
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       std::string name = args(0).xstring_value ("mkfifo: FILE must be a string");
 
-      int octal_mode = args(1).int_value ();
+      int octal_mode = args(1).xint_value ("mkfifo: MODE must be an integer");
 
-      if (! error_state)
+      if (octal_mode < 0)
+        error ("mkfifo: MODE must be a positive integer value");
+      else
         {
-          if (octal_mode < 0)
-            error ("mkfifo: MODE must be a positive integer value");
-          else
-            {
-              int mode = convert (octal_mode, 8, 10);
+          int mode = convert (octal_mode, 8, 10);
 
-              std::string msg;
+          std::string msg;
 
-              int status = octave_mkfifo (name, mode, msg);
-
-              retval(0) = status;
+          int status = octave_mkfifo (name, mode, msg);
 
-              if (status < 0)
-                retval(1) = msg;
-            }
+          retval(0) = status;
+
+          if (status < 0)
+            retval(1) = msg;
         }
-      else
-        error ("mkfifo: MODE must be an integer");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1073,22 +1053,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISREG: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_reg (static_cast<mode_t> (mode));
-      else
-        error ("S_ISREG: invalid MODE value");
+      retval = file_stat::is_reg (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
@@ -1099,22 +1076,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISDIR: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_dir (static_cast<mode_t> (mode));
-      else
-        error ("S_ISDIR: invalid MODE value");
+      retval = file_stat::is_dir (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
@@ -1125,22 +1099,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISCHR: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_chr (static_cast<mode_t> (mode));
-      else
-        error ("S_ISCHR: invalid MODE value");
+      retval = file_stat::is_chr (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
@@ -1151,22 +1122,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISBLK: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_blk (static_cast<mode_t> (mode));
-      else
-        error ("S_ISBLK: invalid MODE value");
+      retval = file_stat::is_blk (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
@@ -1177,22 +1145,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISFIFO: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_fifo (static_cast<mode_t> (mode));
-      else
-        error ("S_ISFIFO: invalid MODE value");
+      retval = file_stat::is_fifo (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
@@ -1203,22 +1168,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISLNK: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_lnk (static_cast<mode_t> (mode));
-      else
-        error ("S_ISLNK: invalid MODE value");
+      retval = file_stat::is_lnk (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
@@ -1229,22 +1191,19 @@ Return true if @var{mode} corresponds to
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      double mode = args(0).double_value ();
+      double mode = args(0).xdouble_value ("S_ISSOCK: invalid MODE value");
 
-      if (! error_state)
-        retval = file_stat::is_sock (static_cast<mode_t> (mode));
-      else
-        error ("S_ISSOCK: invalid MODE value");
+      retval = file_stat::is_sock (static_cast<mode_t> (mode));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (gethostname, args, ,
@@ -1399,43 +1358,33 @@ about the subprocess that exited.\n\
   retval(2) = std::string ();
   retval(1) = 0;
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      pid_t pid = args(0).int_value (true);
+      pid_t pid = args(0).xint_value ("waitpid: OPTIONS must be an integer");
 
-      if (! error_state)
-        {
-          int options = 0;
+      int options = 0;
 
-          if (args.length () == 2)
-            options = args(1).int_value (true);
+      if (args.length () == 2)
+        options = args(1).xint_value ("waitpid: PID must be an integer value");
 
-          if (! error_state)
-            {
-              std::string msg;
+      std::string msg;
 
-              int status = 0;
-
-              pid_t result = octave_syscalls::waitpid (pid, &status,
-                                                       options, msg);
+      int status = 0;
 
-              retval(2) = msg;
-              retval(1) = status;
-              retval(0) = result;
-            }
-          else
-            error ("waitpid: OPTIONS must be an integer");
-        }
-      else
-        error ("waitpid: PID must be an integer value");
+      pid_t result = octave_syscalls::waitpid (pid, &status,
+                                               options, msg);
+
+      retval(2) = msg;
+      retval(1) = status;
+      retval(0) = result;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFEXITED", FWIFEXITED, args, ,
@@ -1445,23 +1394,22 @@ Given @var{status} from a call to @code{
 true if the child terminated normally.\n\
 @seealso{waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WIFEXITED: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::ifexited (status);
-      else
-        error ("WIFEXITED: STATUS must be an integer");
+      retval = octave_wait::ifexited (status);
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WEXITSTATUS", FWEXITSTATUS, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WEXITSTATUS (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
@@ -1470,22 +1418,19 @@ the exit status of the child.\n\
 This function should only be employed if @code{WIFEXITED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WEXITSTATUS: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::exitstatus (status);
-      else
-        error ("WEXITSTATUS: STATUS must be an integer");
+      retval = octave_wait::exitstatus (status);
     }
 
   return retval;
 }
 
 DEFUNX ("WIFSIGNALED", FWIFSIGNALED, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFSIGNALED (@var{status})\n\
@@ -1493,23 +1438,22 @@ Given @var{status} from a call to @code{
 true if the child process was terminated by a signal.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WIFSIGNALED: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::ifsignaled (status);
-      else
-        error ("WIFSIGNALED: STATUS must be an integer");
+      retval = octave_wait::ifsignaled (status);
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WTERMSIG", FWTERMSIG, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WTERMSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
@@ -1518,23 +1462,22 @@ the number of the signal that caused the
 This function should only be employed if @code{WIFSIGNALED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WTERMSIG: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::termsig (status);
-      else
-        error ("WTERMSIG: STATUS must be an integer");
+      retval = octave_wait::termsig (status);
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WCOREDUMP", FWCOREDUMP, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WCOREDUMP (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
@@ -1545,23 +1488,22 @@ The macro used to implement this functio
 and is not available on some Unix implementations (e.g., AIX, SunOS).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WCOREDUMP: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::coredump (status);
-      else
-        error ("WCOREDUMP: STATUS must be an integer");
+      retval = octave_wait::coredump (status);
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFSTOPPED", FWIFSTOPPED, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFSTOPPED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
@@ -1571,23 +1513,22 @@ This is only possible if the call was do
 the child is being traced (see ptrace(2)).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WIFSTOPPED: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::ifstopped (status);
-      else
-        error ("WIFSTOPPED: STATUS must be an integer");
+      retval = octave_wait::ifstopped (status);
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WSTOPSIG", FWSTOPSIG, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WSTOPSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
@@ -1596,46 +1537,44 @@ the number of the signal which caused th
 This function should only be employed if @code{WIFSTOPPED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WSTOPSIG: STATUS must be an integer");
 
-      if (! error_state)
         retval = octave_wait::stopsig (status);
-      else
-        error ("WSTOPSIG: STATUS must be an integer");
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFCONTINUED", FWIFCONTINUED, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFCONTINUED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was resumed by delivery of @code{SIGCONT}.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
-      int status = args(0).int_value ();
+      int status = args(0).xint_value ("WIFCONTINUED: STATUS must be an integer");
 
-      if (! error_state)
-        retval = octave_wait::ifcontinued (status);
-      else
-        error ("WIFCONTINUED: STATUS must be an integer");
+      retval = octave_wait::ifcontinued (status);
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("canonicalize_file_name", Fcanonicalize_file_name, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{cname}, @var{status}, @var{msg}] =} canonicalize_file_name (@var{fname})\n\
 Return the canonical name of file @var{fname}.\n\
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -963,29 +963,24 @@ tilde_expand (\"~/bin\")\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
-      string_vector sv = arg.all_strings ();
+      string_vector sv = arg.all_strings ("tilde_expand: expecting argument to be char or cellstr object");
 
-      if (! error_state)
-        {
-          sv = file_ops::tilde_expand (sv);
+      sv = file_ops::tilde_expand (sv);
 
-          if (arg.is_cellstr ())
-            retval = Cell (arg.dims (), sv);
-          else
-            retval = sv;
-        }
+      if (arg.is_cellstr ())
+        retval = Cell (arg.dims (), sv);
       else
-        error ("tilde_expand: expecting argument to be char or cellstr object");
+        retval = sv;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -52,58 +52,58 @@ mk_tm_map (const octave_base_tm& t)
   m.assign ("isdst", static_cast<double> (t.isdst ()));
   m.assign ("gmtoff", static_cast<double> (t.gmtoff ()));
   m.assign ("zone", t.zone ());
 
   return m;
 }
 
 static inline int
-intfield (const octave_scalar_map& m, const std::string& k)
+intfield (const octave_scalar_map& m, const std::string& k, const char *who)
 {
   int retval = 0;
 
   octave_value v = m.getfield (k);
 
   if (! v.is_empty ())
-    retval = v.int_value ();
+    retval = v.xint_value ("%s: invalid TM_STRUCT argument", who);
 
   return retval;
 }
 
 static inline std::string
-stringfield (const octave_scalar_map& m, const std::string& k)
+stringfield (const octave_scalar_map& m, const std::string& k, const char *who)
 {
   std::string retval;
 
   octave_value v = m.getfield (k);
 
   if (! v.is_empty ())
-    retval = v.string_value ();
+    retval = v.xstring_value ("%s: invalid TM_STRUCT argument", who);
 
   return retval;
 }
 
 static octave_base_tm
-extract_tm (const octave_scalar_map& m)
+extract_tm (const octave_scalar_map& m, const char *who)
 {
   octave_base_tm tm;
 
-  tm.usec (intfield (m, "usec"));
-  tm.sec (intfield (m, "sec"));
-  tm.min (intfield (m, "min"));
-  tm.hour (intfield (m, "hour"));
-  tm.mday (intfield (m, "mday"));
-  tm.mon (intfield (m, "mon"));
-  tm.year (intfield (m, "year"));
-  tm.wday (intfield (m, "wday"));
-  tm.yday (intfield (m, "yday"));
-  tm.isdst (intfield (m, "isdst"));
-  tm.gmtoff (intfield (m, "gmtoff"));
-  tm.zone (stringfield (m, "zone"));
+  tm.usec (intfield (m, "usec", who));
+  tm.sec (intfield (m, "sec", who));
+  tm.min (intfield (m, "min", who));
+  tm.hour (intfield (m, "hour", who));
+  tm.mday (intfield (m, "mday", who));
+  tm.mon (intfield (m, "mon", who));
+  tm.year (intfield (m, "year", who));
+  tm.wday (intfield (m, "wday", who));
+  tm.yday (intfield (m, "yday", who));
+  tm.isdst (intfield (m, "isdst", who));
+  tm.gmtoff (intfield (m, "gmtoff", who));
+  tm.zone (stringfield (m, "zone", who));
 
   return tm;
 }
 
 DEFUN (time, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{seconds} =} time ()\n\
 Return the current time as the number of seconds since the epoch.\n\
@@ -270,29 +270,21 @@ mktime (localtime (time ()))\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, gmtime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      octave_scalar_map map = args(0).scalar_map_value ();
-
-      if (! error_state)
-        {
-          octave_base_tm tm = extract_tm (map);
+      octave_scalar_map map = args(0).xscalar_map_value ("mktime: TM_STRUCT argument must be a structure");
 
-          if (! error_state)
-            retval = octave_time (tm);
-          else
-            error ("mktime: invalid TM_STRUCT argument");
-        }
-      else
-        error ("mktime: TM_STRUCT argument must be a structure");
+      octave_base_tm tm = extract_tm (map, "mktime");
+
+      retval = octave_time (tm);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -470,29 +462,21 @@ Year (1970-).\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       std::string fmt = args(0).xstring_value ("strftime: FMT must be a string");
 
-      octave_scalar_map map = args(1).scalar_map_value ();
-
-      if (! error_state)
-        {
-          octave_base_tm tm = extract_tm (map);
+      octave_scalar_map map = args(1).xscalar_map_value ("strftime: TM_STRUCT must be a structure");
 
-          if (! error_state)
-            retval = tm.strftime (fmt);
-          else
-            error ("strftime: invalid TM_STRUCT argument");
-        }
-      else
-        error ("strftime: TM_STRUCT must be a structure");
+      octave_base_tm tm = extract_tm (map, "strftime");
+
+      retval = tm.strftime (fmt);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -309,36 +309,36 @@ If no files are found, return an empty c
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      string_vector names = args(0).all_strings ();
+      string_vector names = args(0).xall_strings ("file_in_loadpath: FILE argument must be a string");
 
-      if (! error_state && names.numel () > 0)
+      if (names.numel () > 0)
         {
           if (nargin == 1)
             retval =
               octave_env::make_absolute (load_path::find_first_of (names));
           else if (nargin == 2)
             {
               std::string opt = args(1).string_value ();
 
               if (! error_state && opt == "all")
                 retval = Cell (make_absolute
                                (load_path::find_all_first_of (names)));
               else
                 error ("file_in_loadpath: invalid option");
             }
         }
       else
-        error ("file_in_loadpath: FILE argument must be a string");
+        error ("file_in_loadpath: FILE argument must not be empty");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -390,35 +390,35 @@ If no files are found, return an empty c
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       std::string path = args(0).xstring_value ("file_in_path: PATH must be a string");
 
-      string_vector names = args(1).all_strings ();
+      string_vector names = args(1).xall_strings ("file_in_path: FILE argument must be a string");
 
-      if (! error_state && names.numel () > 0)
+      if (names.numel () > 0)
         {
           if (nargin == 2)
             retval = search_path_for_file (path, names);
           else if (nargin == 3)
             {
               std::string opt = args(2).string_value ();
 
               if (! error_state && opt == "all")
                 retval = Cell (make_absolute
                                (search_path_for_all_files (path, names)));
               else
                 error ("file_in_path: invalid option");
             }
         }
       else
-        error ("file_in_path: all arguments must be strings");
+        error ("file_in_path: FILE argument must not be empty");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -774,22 +774,19 @@ set_internal_variable (bool& var, const 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      bool bval = args(0).bool_value ();
-
-      if (! error_state)
-        var = bval;
-      else
-        error ("%s: expecting arg to be a logical value", nm);
+      bool bval = args(0).xbool_value ("%s: expecting arg to be a logical value", nm);
+
+      var = bval;
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -849,30 +846,25 @@ set_internal_variable (int& var, const o
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      int ival = args(0).int_value ();
-
-      if (! error_state)
-        {
-          if (ival < minval)
-            error ("%s: expecting arg to be greater than %d", nm, minval);
-          else if (ival > maxval)
-            error ("%s: expecting arg to be less than or equal to %d",
-                   nm, maxval);
-          else
-            var = ival;
-        }
+      int ival = args(0).xint_value ("%s: expecting arg to be an integer value", nm);
+
+      if (ival < minval)
+        error ("%s: expecting arg to be greater than %d", nm, minval);
+      else if (ival > maxval)
+        error ("%s: expecting arg to be less than or equal to %d",
+               nm, maxval);
       else
-        error ("%s: expecting arg to be an integer value", nm);
+        var = ival;
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -890,29 +882,24 @@ set_internal_variable (double& var, cons
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      double dval = args(0).scalar_value ();
-
-      if (! error_state)
-        {
-          if (dval < minval)
-            error ("%s: expecting arg to be greater than %g", minval);
-          else if (dval > maxval)
-            error ("%s: expecting arg to be less than or equal to %g", maxval);
-          else
-            var = dval;
-        }
+      double dval = args(0).xscalar_value ("%s: expecting arg to be a scalar value", nm);
+
+      if (dval < minval)
+        error ("%s: expecting arg to be greater than %g", minval);
+      else if (dval > maxval)
+        error ("%s: expecting arg to be less than or equal to %g", maxval);
       else
-        error ("%s: expecting arg to be a scalar value", nm);
+        var = dval;
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -302,54 +302,38 @@ glpk (int sense, int n, int m, double *c
 #define OCTAVE_GLPK_GET_REAL_PARAM(NAME, VAL) \
   do \
     { \
       octave_value tmp = PARAM.getfield (NAME); \
  \
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
-            { \
-              VAL = tmp.scalar_value (); \
- \
-              if (error_state) \
-                { \
-                  error ("glpk: invalid value in PARAM." NAME); \
-                  return retval; \
-                } \
-            } \
+            VAL = tmp.xscalar_value ("glpk: invalid value in PARAM" NAME); \
           else \
             { \
-              error ("glpk: invalid value in PARAM." NAME); \
+              error ("glpk: invalid value in PARAM" NAME); \
               return retval; \
             } \
         } \
     } \
   while (0)
 
 #define OCTAVE_GLPK_GET_INT_PARAM(NAME, VAL) \
   do \
     { \
       octave_value tmp = PARAM.getfield (NAME); \
  \
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
-            { \
-              VAL = tmp.int_value (); \
- \
-              if (error_state) \
-                { \
-                  error ("glpk: invalid value in PARAM." NAME); \
-                  return retval; \
-                } \
-            } \
+            VAL = tmp.xint_value ("glpk: invalid value in PARAM" NAME); \
           else \
             { \
-              error ("glpk: invalid value in PARAM." NAME); \
+              error ("glpk: invalid value in PARAM" NAME); \
               return retval; \
             } \
         } \
     } \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
            "-*- texinfo -*-\n\
@@ -369,42 +353,30 @@ Undocumented internal function.\n\
       print_usage ();
       return retval;
     }
 
   //-- 1nd Input. A column array containing the objective function
   //--            coefficients.
   volatile int mrowsc = args(0).rows ();
 
-  Matrix C (args(0).matrix_value ());
-
-  if (error_state)
-    {
-      error ("__glpk__: invalid value of C");
-      return retval;
-    }
+  Matrix C = args(0).xmatrix_value ("__glpk__: invalid value of C");
 
   double *c = C.fortran_vec ();
   Array<int> rn;
   Array<int> cn;
   ColumnVector a;
   volatile int mrowsA;
   volatile int nz = 0;
 
   //-- 2nd Input. A matrix containing the constraints coefficients.
   // If matrix A is NOT a sparse matrix
   if (args(1).is_sparse_type ())
     {
-      SparseMatrix A = args(1).sparse_matrix_value (); // get the sparse matrix
-
-      if (error_state)
-        {
-          error ("__glpk__: invalid value of A");
-          return retval;
-        }
+      SparseMatrix A = args(1).xsparse_matrix_value ("__glpk__: invalid value of A");
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nnz ();
       rn.resize (dim_vector (Anz+1, 1));
       cn.resize (dim_vector (Anz+1, 1));
       a.resize (Anz+1, 0.0);
 
@@ -420,23 +392,17 @@ Undocumented internal function.\n\
             nz++;
             rn(nz) = A.ridx (i) + 1;
             cn(nz) = j + 1;
             a(nz) = A.data(i);
           }
     }
   else
     {
-      Matrix A (args(1).matrix_value ()); // get the matrix
-
-      if (error_state)
-        {
-          error ("__glpk__: invalid value of A");
-          return retval;
-        }
+      Matrix A = args(1).xmatrix_value ("__glpk__: invalid value of A");
 
       mrowsA = A.rows ();
       rn.resize (dim_vector (mrowsA*mrowsc+1, 1));
       cn.resize (dim_vector (mrowsA*mrowsc+1, 1));
       a.resize (mrowsA*mrowsc+1, 0.0);
 
       for (int i = 0; i < mrowsA; i++)
         {
@@ -451,33 +417,27 @@ Undocumented internal function.\n\
                 }
             }
         }
 
     }
 
   //-- 3rd Input. A column array containing the right-hand side value
   //               for each constraint in the constraint matrix.
-  Matrix B (args(2).matrix_value ());
-
-  if (error_state)
-    {
-      error ("__glpk__: invalid value of B");
-      return retval;
-    }
+  Matrix B = args(2).xmatrix_value ("__glpk__: invalid value of B");
 
   double *b = B.fortran_vec ();
 
   //-- 4th Input. An array of length mrowsc containing the lower
   //--            bound on each of the variables.
-  Matrix LB (args(3).matrix_value ());
+  Matrix LB = args(3).xmatrix_value ("__glpk__: invalid value of LB");
 
-  if (error_state || LB.numel () < mrowsc)
+  if (LB.numel () < mrowsc)
     {
-      error ("__glpk__: invalid value of LB");
+      error ("__glpk__: invalid dimensions for LB");
       return retval;
     }
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
   Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
@@ -488,21 +448,21 @@ Undocumented internal function.\n\
           lb[i] = -octave_Inf;
         }
       else
         freeLB(i) = 0;
     }
 
   //-- 5th Input. An array of at least length numcols containing the upper
   //--            bound on each of the variables.
-  Matrix UB (args(4).matrix_value ());
+  Matrix UB = args(4).xmatrix_value ("__glpk__: invalid value of UB");
 
-  if (error_state || UB.numel () < mrowsc)
+  if (UB.numel () < mrowsc)
     {
-      error ("__glpk__: invalid value of UB");
+      error ("__glpk__: invalid dimensions for UB");
       return retval;
     }
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
@@ -512,71 +472,47 @@ Undocumented internal function.\n\
           ub[i] = octave_Inf;
         }
       else
         freeUB(i) = 0;
     }
 
   //-- 6th Input. A column array containing the sense of each constraint
   //--            in the constraint matrix.
-  charMatrix CTYPE (args(5).char_matrix_value ());
-
-  if (error_state)
-    {
-      error ("__glpk__: invalid value of CTYPE");
-      return retval;
-    }
+  charMatrix CTYPE = args(5).char_matrix_value ("__glpk__: invalid value of CTYPE");
 
   char *ctype = CTYPE.fortran_vec ();
 
   //-- 7th Input. A column array containing the types of the variables.
-  charMatrix VTYPE (args(6).char_matrix_value ());
-
-  if (error_state)
-    {
-      error ("__glpk__: invalid value of VARTYPE");
-      return retval;
-    }
+  charMatrix VTYPE = args(6).char_matrix_value ("__glpk__: invalid value of VARTYPE");
 
   Array<int> vartype (dim_vector (mrowsc, 1));
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
         {
           isMIP = 1;
           vartype(i) = GLP_IV;
         }
       else
         vartype(i) = GLP_CV;
     }
 
   //-- 8th Input. Sense of optimization.
   volatile int sense;
-  double SENSE = args(7).scalar_value ();
-
-  if (error_state)
-    {
-      error ("__glpk__: invalid value of SENSE");
-      return retval;
-    }
+  double SENSE = args(7).scalar_value ("__glpk__: invalid value of SENSE");
 
   if (SENSE >= 0)
     sense = 1;
   else
     sense = -1;
 
   //-- 9th Input. A structure containing the control parameters.
-  octave_scalar_map PARAM = args(8).scalar_map_value ();
-
-  if (error_state)
-    {
-      error ("__glpk__: invalid value of PARAM");
-      return retval;
-    }
+  octave_scalar_map PARAM = args(8).xscalar_map_value ("__glpk__: invalid value of PARAM");
 
   control_params par;
 
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   //-- Integer parameters
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   //-- Level of messages output by the solver
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -743,22 +743,17 @@ Use @code{imread} instead.\n\
   maybe_initialize_magick ();
 
   if (args.length () != 2 || ! args(0).is_string ())
     {
       print_usage ();
       return output;
     }
 
-  const octave_scalar_map options = args(1).scalar_map_value ();
-  if (error_state)
-    {
-      error ("__magick_read__: OPTIONS must be a struct");
-      return output;
-    }
+  const octave_scalar_map options = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
 
   std::vector<Magick::Image> imvec;
   read_file (args(0).string_value (), imvec);
 
   // Prepare an Array with the indexes for the requested frames.
   const octave_idx_type nFrames = imvec.size ();
   Array<octave_idx_type> frameidx;
   const octave_value indexes = options.getfield ("index");
@@ -1400,32 +1395,22 @@ Use @code{imwrite} instead.\n\
   maybe_initialize_magick ();
 
   if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
     {
       print_usage ();
       return retval;
     }
   const std::string filename = args(0).string_value ();
-  const std::string ext      = args(1).string_value ();
+  const std::string ext = args(1).string_value ();
 
-  const octave_scalar_map options = args(4).scalar_map_value ();
-  if (error_state)
-    {
-      error ("__magick_write__: OPTIONS must be a struct");
-      return retval;
-    }
+  const octave_scalar_map options = args(4).xscalar_map_value ("__magick_write__: OPTIONS must be a struct");
 
   const octave_value img  = args(2);
-  const Matrix       cmap = args(3).matrix_value ();
-  if (error_state)
-    {
-      error ("__magick_write__: invalid IMG or MAP");
-      return retval;
-    }
+  const Matrix cmap = args(3).xmatrix_value ("__magick_write__: invalid MAP");
 
   std::vector<Magick::Image> imvec;
 
   if (cmap.is_empty ())
     {
       const octave_value alpha = options.getfield ("alpha");
       if (img.is_bool_type ())
         encode_bool_image (imvec, img.bool_array_value ());
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -132,32 +132,27 @@ The author of the code itself is Timothy
 
       if (n_row != n_col)
         error ("amd: matrix S must be square");
 
       OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
       AMD_NAME (_defaults) (Control) ;
       if (nargin > 1)
         {
-          octave_scalar_map arg1 = args(1).scalar_map_value ();
+          octave_scalar_map arg1 = args(1).xscalar_map_value ("amd: OPTS argument must be a scalar structure");
 
-          if (!error_state)
-            {
-              octave_value tmp;
+          octave_value tmp;
 
-              tmp = arg1.getfield ("dense");
-              if (tmp.is_defined ())
-                Control[AMD_DENSE] = tmp.double_value ();
+          tmp = arg1.getfield ("dense");
+          if (tmp.is_defined ())
+            Control[AMD_DENSE] = tmp.double_value ();
 
-              tmp = arg1.getfield ("aggressive");
-              if (tmp.is_defined ())
-                Control[AMD_AGGRESSIVE] = tmp.double_value ();
-            }
-          else
-            error ("amd: OPTS argument must be a scalar structure");
+          tmp = arg1.getfield ("aggressive");
+          if (tmp.is_defined ())
+            Control[AMD_AGGRESSIVE] = tmp.double_value ();
         }
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
       Matrix xinfo (AMD_INFO, 1);
       double *Info = xinfo.fortran_vec ();
 
       // FIXME: how can we manage the memory allocation of amd
       //        in a cleaner manner?
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1362,24 +1362,21 @@ To convert back from a cellstr to a char
   if (args.length () == 1)
     {
       octave_value_list tmp = Fiscellstr (args, 1);
 
       if (tmp(0).is_true ())
         retval = args(0);
       else
         {
-          string_vector s = args(0).all_strings ();
+          string_vector s = args(0).xall_strings ("cellstr: argument STRING must be a 2-D character array");
 
-          if (! error_state)
-            retval = (s.is_empty ()
-                      ? Cell (octave_value (std::string ()))
-                      : Cell (s, true));
-          else
-            error ("cellstr: argument STRING must be a 2-D character array");
+          retval = (s.is_empty ()
+                    ? Cell (octave_value (std::string ()))
+                    : Cell (s, true));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -1419,53 +1416,48 @@ c(2,1,:)(:)\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      const octave_map m = args(0).map_value ();
+      const octave_map m = args(0).xmap_value ("struct2cell: argument S must be a structure");
 
-      if (! error_state)
-        {
-          const dim_vector m_dv = m.dims ();
+      const dim_vector m_dv = m.dims ();
 
-          octave_idx_type num_fields = m.nfields ();
+      octave_idx_type num_fields = m.nfields ();
 
-          // The resulting dim_vector should have dimensions:
-          // [numel(fields) size(struct)]
-          // except if the struct is a column vector.
+      // The resulting dim_vector should have dimensions:
+      // [numel(fields) size(struct)]
+      // except if the struct is a column vector.
 
-          dim_vector result_dv;
-          if (m_dv(m_dv.length () - 1) == 1)
-            result_dv.resize (m_dv.length ());
-          else
-            result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
+      dim_vector result_dv;
+      if (m_dv(m_dv.length () - 1) == 1)
+        result_dv.resize (m_dv.length ());
+      else
+        result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
 
-          result_dv(0) = num_fields;
+      result_dv(0) = num_fields;
 
-          for (int i = 1; i < result_dv.length (); i++)
-            result_dv(i) = m_dv(i-1);
+      for (int i = 1; i < result_dv.length (); i++)
+        result_dv(i) = m_dv(i-1);
 
-          NoAlias<Cell> c (result_dv);
-
-          octave_idx_type n_elts = m.numel ();
+      NoAlias<Cell> c (result_dv);
 
-          // Fill c in one sweep. Note that thanks to octave_map structure,
-          // we don't need a key lookup at all.
-          for (octave_idx_type j = 0; j < n_elts; j++)
-            for (octave_idx_type i = 0; i < num_fields; i++)
-              c(i,j) = m.contents(i)(j);
+      octave_idx_type n_elts = m.numel ();
 
-          retval = c;
-        }
-      else
-        error ("struct2cell: argument S must be a structure");
+      // Fill c in one sweep. Note that thanks to octave_map structure,
+      // we don't need a key lookup at all.
+      for (octave_idx_type j = 0; j < n_elts; j++)
+        for (octave_idx_type i = 0; i < num_fields; i++)
+          c(i,j) = m.contents(i)(j);
+
+      retval = c;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -779,42 +779,34 @@ functions from strings is through the us
       else if (nargin == 2 && args(1).is_numeric_type ())
         {
           if (! args(1).is_scalar_type ())
             {
               error ("inline: N must be an integer");
               return retval;
             }
 
-          int n = args(1).int_value ();
+          int n = args(1).int_value ("inline: N must be an integer");
 
-          if (! error_state)
+          if (n >= 0)
             {
-              if (n >= 0)
-                {
-                  fargs.resize (n+1);
-
-                  fargs(0) = "x";
+              fargs.resize (n+1);
 
-                  for (int i = 1; i < n+1; i++)
-                    {
-                      std::ostringstream buf;
-                      buf << "P" << i;
-                      fargs(i) = buf.str ();
-                    }
-                }
-              else
+              fargs(0) = "x";
+
+              for (int i = 1; i < n+1; i++)
                 {
-                  error ("inline: N must be a positive integer or zero");
-                  return retval;
+                  std::ostringstream buf;
+                  buf << "P" << i;
+                  fargs(i) = buf.str ();
                 }
             }
           else
             {
-              error ("inline: N must be an integer");
+              error ("inline: N must be a positive integer or zero");
               return retval;
             }
         }
       else
         {
           fargs.resize (nargin - 1);
 
           for (int i = 1; i < nargin; i++)
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -500,32 +500,27 @@ octave_struct::subsasgn (const std::stri
                   }
                 else
                   gripe_failed_assignment ();
               }
             else
               {
                 if (t_rhs.is_map () || t_rhs.is_object ())
                   {
-                    octave_map rhs_map = t_rhs.map_value ();
+                    octave_map rhs_map = t_rhs.xmap_value ("invalid structure assignment");
+
+                    map.assign (idx.front (), rhs_map);
 
                     if (! error_state)
                       {
-                        map.assign (idx.front (), rhs_map);
-
-                        if (! error_state)
-                          {
-                            count++;
-                            retval = octave_value (this);
-                          }
-                        else
-                          gripe_failed_assignment ();
+                        count++;
+                        retval = octave_value (this);
                       }
                     else
-                      error ("invalid structure assignment");
+                      gripe_failed_assignment ();
                   }
                 else
                   {
                     if (t_rhs.is_null_value ())
                       {
                         map.delete_elements (idx.front ());
 
                         if (! error_state)
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1989,16 +1989,17 @@ XVALUE_EXTRACTOR (int32NDArray, xint32_a
 XVALUE_EXTRACTOR (int64NDArray, xint64_array_value, int64_array_value)
 
 XVALUE_EXTRACTOR (uint8NDArray, xuint8_array_value, uint8_array_value)
 XVALUE_EXTRACTOR (uint16NDArray, xuint16_array_value, uint16_array_value)
 XVALUE_EXTRACTOR (uint32NDArray, xuint32_array_value, uint32_array_value)
 XVALUE_EXTRACTOR (uint64NDArray, xuint64_array_value, uint64_array_value)
 
 XVALUE_EXTRACTOR (std::string, xstring_value, rep->xstring_value)
+XVALUE_EXTRACTOR (string_vector, xall_strings, all_strings)
 
 XVALUE_EXTRACTOR (Cell, xcell_value, cell_value)
 XVALUE_EXTRACTOR (Array<std::string>, xcellstr_value, cellstr_value)
 
 XVALUE_EXTRACTOR (Range, xrange_value, range_value)
 
 XVALUE_EXTRACTOR (octave_map, xmap_value, map_value)
 XVALUE_EXTRACTOR (octave_scalar_map, xscalar_map_value, scalar_map_value)
@@ -2953,20 +2954,19 @@ Return the size of @var{val} in bytes.\n
 %!assert (sizeof ({"foo", "bar", "baaz"}), 10)
 */
 
 static void
 decode_subscripts (const char* name, const octave_value& arg,
                    std::string& type_string,
                    std::list<octave_value_list>& idx)
 {
-  const octave_map m = arg.map_value ();
-
-  if (! error_state
-      && m.nfields () == 2 && m.contains ("type") && m.contains ("subs"))
+  const octave_map m = arg.xmap_value ("%s: second argument must be a structure with fields 'type' and 'subs'", name);
+
+  if (m.nfields () == 2 && m.contains ("type") && m.contains ("subs"))
     {
       octave_idx_type nel = m.numel ();
 
       type_string = std::string (nel, '\0');
       idx = std::list<octave_value_list> ();
 
       if (nel == 0)
         return;
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1106,16 +1106,18 @@ public:
   uint16NDArray xuint16_array_value (const char *fmt, ...) const;
 
   uint32NDArray xuint32_array_value (const char *fmt, ...) const;
 
   uint64NDArray xuint64_array_value (const char *fmt, ...) const;
 
   std::string xstring_value (const char *fmt, ...) const;
 
+  string_vector xall_strings (const char *fmt, ...) const;
+
   Cell xcell_value (const char *fmt, ...) const;
 
   Array<std::string> xcellstr_value (const char *fmt, ...) const;
 
   Range xrange_value (const char *fmt, ...) const;
 
   octave_map xmap_value (const char *fmt, ...) const;
 
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -197,23 +197,23 @@
 %!       S_ISCHR(stat(nm).mode)
 %!       S_ISBLK(stat(nm).mode)
 %!       S_ISFIFO(stat(nm).mode)
 %!       S_ISLNK(lstat(nm).mode)
 %!       S_ISSOCK(stat(nm).mode) ];
 %! unlink (nm);
 %! assert (r(:), [true; false; false; false; false; false; false]);
 
-%!error <octave_base_value::double_value> S_ISREG ({})
-%!error <octave_base_value::double_value> S_ISDIR ({})
-%!error <octave_base_value::double_value> S_ISCHR ({})
-%!error <octave_base_value::double_value> S_ISBLK ({})
-%!error <octave_base_value::double_value> S_ISFIFO ({})
-%!error <octave_base_value::double_value> S_ISLNK ({})
-%!error <octave_base_value::double_value> S_ISSOCK ({})
+%!error <S_ISREG: invalid MODE value> S_ISREG ({})
+%!error <S_ISDIR: invalid MODE value> S_ISDIR ({})
+%!error <S_ISCHR: invalid MODE value> S_ISCHR ({})
+%!error <S_ISBLK: invalid MODE value> S_ISBLK ({})
+%!error <S_ISFIFO: invalid MODE value> S_ISFIFO ({})
+%!error <S_ISLNK: invalid MODE value> S_ISLNK ({})
+%!error <S_ISSOCK: invalid MODE value> S_ISSOCK ({})
 
 %!error <Invalid call to S_ISREG> S_ISREG ()
 %!error <Invalid call to S_ISDIR> S_ISDIR ()
 %!error <Invalid call to S_ISCHR> S_ISCHR ()
 %!error <Invalid call to S_ISBLK> S_ISBLK ()
 %!error <Invalid call to S_ISFIFO> S_ISFIFO ()
 %!error <Invalid call to S_ISLNK> S_ISLNK ()
 %!error <Invalid call to S_ISSOCK> S_ISSOCK ()
