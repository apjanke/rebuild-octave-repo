# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450121328 28800
#      Mon Dec 14 11:28:48 2015 -0800
# Node ID c07bee629973c176e9a492c2576b62b1e05de645
# Parent  95c0d4c07c56706305d6f790b02236176b6bec4d
2015 Code Sprint: use ovl ().

diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -129,24 +129,25 @@ void ilu_0 (octave_matrix_t& sm, const s
 DEFUN (__ilu0__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{L}, @var{U}] =} __ilu0__ (@var{A})\n\
 @deftypefnx {} {[@var{L}, @var{U}] =} __ilu0__ (@var{A}, @var{milu})\n\
 @deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} __ilu0__ (@var{A}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
-  std::string milu;
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value_list retval (2);
+
+  std::string milu;
+
   // In ILU0 algorithm the zero-pattern of the input matrix is preserved so
   // it's structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list param_list;
   if (! args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       ilu_0 <SparseMatrix, double> (sm, milu);
@@ -462,28 +463,27 @@ void ilu_crout (octave_matrix_t& sm_l, o
   U = U.transpose ();
 }
 
 DEFUN (__iluc__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{L}, @var{U}] =} __iluc__ (@var{A})\n\
 @deftypefnx {} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol})\n\
 @deftypefnx {} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol}, @var{milu})\n\
-@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} __iluc__ (@var{A}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
-  std::string milu = "off";
-  double droptol = 0;
 
   if (nargout != 2 || nargin < 1 || nargin > 3)
     print_usage ();
 
+  std::string milu = "off";
+  double droptol = 0;
+
   // Don't repeat input validation of arguments done in ilu.m
   if (nargin >= 2)
     droptol = args(1).double_value ();
 
   if (nargin == 3)
     milu = args(2).string_value ();
 
   octave_value_list param_list;
@@ -494,56 +494,50 @@ Undocumented internal function.\n\
       SparseMatrix sm_u = feval ("triu", param_list)(0).sparse_matrix_value ();
       param_list.append (-1);
       SparseMatrix sm_l = feval ("tril", param_list)(0).sparse_matrix_value ();
       param_list(1) = "rows";
       rows_norm = feval ("norm", param_list)(0).vector_value ();
       param_list(1) = "cols";
       cols_norm = feval ("norm", param_list)(0).vector_value ();
       param_list.clear ();
-      SparseMatrix U;
-      SparseMatrix L;
+      SparseMatrix U, L;
       ilu_crout <SparseMatrix, double> (sm_l, sm_u, L, U,
                                         cols_norm.fortran_vec (),
                                         rows_norm.fortran_vec (),
                                         droptol, milu);
       param_list.append (octave_value (L.cols ()));
       SparseMatrix eye =
         feval ("speye", param_list)(0).sparse_matrix_value ();
-      retval(1) = U;
-      retval(0) = L + eye;
+      return ovl (L + eye, U);
     }
   else
     {
       Array<Complex> cols_norm, rows_norm;
       param_list.append (args(0).sparse_complex_matrix_value ());
       SparseComplexMatrix sm_u =
         feval ("triu", param_list)(0).sparse_complex_matrix_value ();
       param_list.append (-1);
       SparseComplexMatrix sm_l =
         feval ("tril", param_list)(0).sparse_complex_matrix_value ();
       param_list(1) = "rows";
       rows_norm = feval ("norm", param_list)(0).complex_vector_value ();
       param_list(1) = "cols";
       cols_norm = feval ("norm", param_list)(0).complex_vector_value ();
       param_list.clear ();
-      SparseComplexMatrix U;
-      SparseComplexMatrix L;
+      SparseComplexMatrix U, L;
       ilu_crout < SparseComplexMatrix, Complex >
                 (sm_l, sm_u, L, U, cols_norm.fortran_vec () ,
                  rows_norm.fortran_vec (), Complex (droptol), milu);
 
       param_list.append (octave_value (L.cols ()));
       SparseComplexMatrix eye =
         feval ("speye", param_list)(0).sparse_complex_matrix_value ();
-      retval(1) = U;
-      retval(0) = L + eye;
+      return ovl (L + eye, U);
     }
-
-  return retval;
 }
 
 // That function implements the IKJ and JKI variants of gaussian elimination
 // to perform the ILUTP decomposition.  The behaviour is controlled by milu
 // parameter.  If milu = ['off'|'col'] the JKI version is performed taking
 // advantage of CCS format of the input matrix.  Row pivoting is performed.
 // If milu = 'row' the input matrix has to be transposed to obtain the
 // equivalent CRS structure so we can work efficiently with rows.  In that
@@ -939,27 +933,27 @@ DEFUN (__ilutp__, args, nargout,
 @deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol})\n\
 @deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh})\n\
 @deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh}, @var{milu})\n\
 @deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh}, @var{milu}, @var{udiag})\n\
 @deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} __ilutp__ (@var{A}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  int nargin = args.length ();
 
-  int nargin = args.length ();
+  if (nargout < 2 || nargout > 3 || nargin < 1 || nargin > 5)
+    print_usage ();
+
+  octave_value_list retval;
   std::string milu = "";
   double droptol = 0;
   double thresh = 1;
   double udiag = 0;
 
-  if (nargout < 2 || nargout > 3 || nargin < 1 || nargin > 5)
-    print_usage ();
-
   // Don't repeat input validation of arguments done in ilu.m
   if (nargin >= 2)
     droptol = args(1).double_value ();
 
   if (nargin >= 3)
     thresh = args(2).double_value ();
 
   if (nargin >= 4)
@@ -980,18 +974,17 @@ Undocumented internal function.\n\
       nnz_l =  (feval ("tril", param_list)(0).sparse_matrix_value ()).nnz ();
       if (milu == "row")
         param_list (1) = "rows";
       else
         param_list (1) = "cols";
       rc_norm = feval ("norm", param_list)(0).vector_value ();
       param_list.clear ();
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
-      SparseMatrix U;
-      SparseMatrix L;
+      SparseMatrix U, L;
       ilu_tp <SparseMatrix, double> (sm, L, U, nnz_u, nnz_l,
                                      rc_norm.fortran_vec (),
                                      perm, droptol, thresh, milu, udiag);
       param_list.append (octave_value (L.cols ()));
       SparseMatrix eye =
         feval ("speye", param_list)(0).sparse_matrix_value ();
       if (milu == "row")
         {
@@ -1031,18 +1024,17 @@ Undocumented internal function.\n\
         feval ("tril", param_list)(0).sparse_complex_matrix_value ().nnz ();
       if (milu == "row")
         param_list(1) = "rows";
       else
         param_list(1) = "cols";
       rc_norm = feval ("norm", param_list)(0).complex_vector_value ();
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
       param_list.clear ();
-      SparseComplexMatrix U;
-      SparseComplexMatrix L;
+      SparseComplexMatrix U, L;
       ilu_tp < SparseComplexMatrix, Complex>
               (sm, L, U, nnz_u, nnz_l, rc_norm.fortran_vec (), perm,
                Complex (droptol), Complex (thresh), milu, udiag);
 
       param_list.append (octave_value (L.cols ()));
       SparseComplexMatrix eye =
         feval ("speye", param_list)(0).sparse_complex_matrix_value ();
       if (milu == "row")
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -486,44 +486,37 @@ qp (const Matrix& H, const ColumnVector&
 }
 
 DEFUN (__qp__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 8)
     print_usage ();
 
-  const ColumnVector x0  (args(0) . vector_value ());
-  const Matrix H         (args(1) . matrix_value ());
-  const ColumnVector q   (args(2) . vector_value ());
-  const Matrix Aeq       (args(3) . matrix_value ());
-  const ColumnVector beq (args(4) . vector_value ());
-  const Matrix Ain       (args(5) . matrix_value ());
-  const ColumnVector bin (args(6) . vector_value ());
-  const int maxit        (args(7) . int_value ());
+  const ColumnVector x0  (args(0).vector_value ());
+  const Matrix H         (args(1).matrix_value ());
+  const ColumnVector q   (args(2).vector_value ());
+  const Matrix Aeq       (args(3).matrix_value ());
+  const ColumnVector beq (args(4).vector_value ());
+  const Matrix Ain       (args(5).matrix_value ());
+  const ColumnVector bin (args(6).vector_value ());
+  const int maxit        (args(7).int_value ());
 
   int iter = 0;
 
-  // Copying the initial guess in the working variable
+  // Copy the initial guess into the working variable
   ColumnVector x = x0;
 
   // Reordering the Lagrange multipliers
   ColumnVector lambda;
 
   int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
 
-  retval(3) = iter;
-  retval(2) = info;
-  retval(1) = lambda;
-  retval(0) = x;
-
-  return retval;
+  return ovl (x, lambda, info, iter);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -76,23 +76,23 @@ enum bessel_type
         } \
     } \
   while (0)
 
 octave_value_list
 do_bessel (enum bessel_type type, const char *fn,
            const octave_value_list& args, int nargout)
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  octave_value_list retval (nargout > 1 ? 2 : 1);
+
   bool scaled = false;
   if (nargin == 3)
     {
       octave_value opt_arg = args(2);
       bool rpt_error = false;
 
       if (! opt_arg.is_scalar_type ())
         rpt_error = true;
@@ -123,35 +123,33 @@ do_bessel (enum bessel_type type, const 
             {
               FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
 
               octave_idx_type ierr;
               octave_value result;
 
               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+              retval(0) = result;
               if (nargout > 1)
                 retval(1) = static_cast<float> (ierr);
-
-              retval(0) = result;
             }
           else
             {
               FloatComplexNDArray x
                 = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
               Array<octave_idx_type> ierr;
               octave_value result;
 
               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+              retval(0) = result;
               if (nargout > 1)
                 retval(1) = NDArray (ierr);
-
-              retval(0) = result;
             }
         }
       else
         {
           dim_vector dv0 = args(0).dims ();
           dim_vector dv1 = args(1).dims ();
 
           bool args0_is_row_vector = (dv0(1) == dv0.numel ());
@@ -164,53 +162,50 @@ do_bessel (enum bessel_type type, const 
               FloatComplexColumnVector cx =
                 x_arg.xfloat_complex_column_vector_value ("%s: X must be a scalar or matrix", fn);
 
               Array<octave_idx_type> ierr;
               octave_value result;
 
               DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
+              retval(0) = result;
               if (nargout > 1)
                 retval(1) = NDArray (ierr);
-
-              retval(0) = result;
             }
           else
             {
               FloatNDArray alpha = args(0).xfloat_array_value ("%s: ALPHA must be a scalar or matrix", fn);
 
               if (x_arg.is_scalar_type ())
                 {
                   FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+                  retval(0) = result;
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
-
-                  retval(0) = result;
                 }
               else
                 {
                   FloatComplexNDArray x
                     = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+                  retval(0) = result;
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
-
-                  retval(0) = result;
                 }
             }
         }
     }
   else
     {
       if (alpha_arg.is_scalar_type ())
         {
@@ -220,34 +215,32 @@ do_bessel (enum bessel_type type, const 
             {
               Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
 
               octave_idx_type ierr;
               octave_value result;
 
               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+              retval(0) = result;
               if (nargout > 1)
                 retval(1) = static_cast<double> (ierr);
-
-              retval(0) = result;
             }
           else
             {
               ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
 
               Array<octave_idx_type> ierr;
               octave_value result;
 
               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+              retval(0) = result;
               if (nargout > 1)
                 retval(1) = NDArray (ierr);
-
-              retval(0) = result;
             }
         }
       else
         {
           dim_vector dv0 = args(0).dims ();
           dim_vector dv1 = args(1).dims ();
 
           bool args0_is_row_vector = (dv0(1) == dv0.numel ());
@@ -260,52 +253,49 @@ do_bessel (enum bessel_type type, const 
               ComplexColumnVector cx =
                 x_arg.xcomplex_column_vector_value ("%s: X must be a scalar or matrix", fn);
 
               Array<octave_idx_type> ierr;
               octave_value result;
 
               DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
+              retval(0) = result;
               if (nargout > 1)
                 retval(1) = NDArray (ierr);
-
-              retval(0) = result;
             }
           else
             {
               NDArray alpha = args(0).xarray_value ("%s: ALPHA must be a scalar or matrix", fn);
 
               if (x_arg.is_scalar_type ())
                 {
                   Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+                  retval(0) = result;
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
-
-                  retval(0) = result;
                 }
               else
                 {
                   ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
+                  retval(0) = result;
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
-
-                  retval(0) = result;
                 }
             }
         }
     }
 
   return retval;
 }
 
@@ -427,23 +417,23 @@ See besselj.\n\
 */
 
 DEFUN (besselh, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargin == 2)
     {
       retval = do_bessel (BESSEL_H1, "besselh", args, nargout);
     }
   else
     {
       octave_idx_type kind = args(1).xint_value ("besselh: invalid value of K");
 
@@ -512,77 +502,74 @@ Loss of significance by argument reducti
 Complete loss of significance by argument reduction, return @code{NaN}.\n\
 \n\
 @item\n\
 Error---no computation, algorithm termination condition not met,\n\
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
-  bool scale = (nargin == 3);
+  octave_value_list retval (nargout > 1 ? 2 : 1);
 
   int kind = 0;
-
   if (nargin > 1)
     {
       kind = args(0).xint_value ("airy: K must be an integer value");
 
       if (kind < 0 || kind > 3)
         error ("airy: K must be 0, 1, 2, or 3");
     }
 
-  int idx = nargin == 1 ? 0 : 1;
+  bool scale = (nargin == 3);
+
+  int idx = (nargin == 1 ? 0 : 1);
 
   if (args(idx).is_single_type ())
     {
       FloatComplexNDArray z = args(idx).xfloat_complex_array_value ("airy: Z must be a complex matrix");
 
       Array<octave_idx_type> ierr;
       octave_value result;
 
       if (kind > 1)
         result = biry (z, kind == 3, scale, ierr);
       else
         result = airy (z, kind == 1, scale, ierr);
 
+      retval(0) = result;
       if (nargout > 1)
         retval(1) = NDArray (ierr);
-
-      retval(0) = result;
     }
   else
     {
       ComplexNDArray z = args(idx).xcomplex_array_value ("airy: Z must be a complex matrix");
 
       Array<octave_idx_type> ierr;
       octave_value result;
 
       if (kind > 1)
         result = biry (z, kind == 3, scale, ierr);
       else
         result = airy (z, kind == 1, scale, ierr);
 
+      retval(0) = result;
       if (nargout > 1)
         retval(1) = NDArray (ierr);
-
-      retval(0) = result;
     }
 
   return retval;
 }
 
 /*
-%!# FIXME: Function airy does not yet have BIST tests
+FIXME: Function airy does not yet have BIST tests
 */
 
 /*
 ## Test values computed with GP/PARI version 2.3.3
 %!shared alpha, x, jx, yx, ix, kx, nix
 %!
 %! ## Bessel functions, even order, positive and negative x
 %! alpha = 2;  x = 1.25;
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -272,17 +272,17 @@ greater than zero (consistent with the F
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{daspk_options} to set optional\n\
 parameters for @code{daspk}.\n\
 @seealso{dassl}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value_list retval (4);
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
@@ -440,27 +440,27 @@ parameters for @code{daspk}.\n\
 
   if (fcn_name.length ())
     clear_function (fcn_name);
   if (jac_name.length ())
     clear_function (jac_name);
 
   std::string msg = dae.error_message ();
 
-  retval(3) = msg;
-  retval(2) = static_cast<double> (dae.integration_state ());
-
   if (dae.integration_ok ())
     {
+      retval(0) = output;
       retval(1) = deriv_output;
-      retval(0) = output;
     }
   else
     {
-      retval(1) = Matrix ();
-      retval(0) = Matrix ();
-
       if (nargout < 3)
         error ("daspk: %s", msg.c_str ());
+
+      retval(0) = Matrix ();
+      retval(1) = Matrix ();
     }
 
+  retval(2) = static_cast<double> (dae.integration_state ());
+  retval(3) = msg;
+
   return retval;
 }
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -351,17 +351,17 @@ greater than zero (consistent with the F
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dasrt_options} to set optional\n\
 parameters for @code{dasrt}.\n\
 @seealso{dasrt_options, daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value_list retval (5);
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
@@ -549,29 +549,29 @@ parameters for @code{dasrt}.\n\
 
   if (fcn_name.length ())
     clear_function (fcn_name);
   if (jac_name.length ())
     clear_function (jac_name);
 
   std::string msg = dae.error_message ();
 
-  retval(4) = msg;
-  retval(3) = static_cast<double> (dae.integration_state ());
-
   if (dae.integration_ok ())
     {
-      retval(2) = output.times ();
+      retval(0) = output.state ();
       retval(1) = output.deriv ();
-      retval(0) = output.state ();
+      retval(2) = output.times ();
     }
   else
     {
-      retval(2) = Matrix ();
-      retval(1) = Matrix ();
-      retval(0) = Matrix ();
-
       if (nargout < 4)
         error ("dasrt: %s", msg.c_str ());
+
+      retval(0) = Matrix ();
+      retval(1) = Matrix ();
+      retval(2) = Matrix ();
     }
 
+  retval(3) = static_cast<double> (dae.integration_state ());
+  retval(4) = msg;
+
   return retval;
 }
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -273,17 +273,17 @@ greater than zero (consistent with the F
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dassl_options} to set optional\n\
 parameters for @code{dassl}.\n\
 @seealso{daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value_list retval (4);
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
@@ -442,33 +442,33 @@ parameters for @code{dassl}.\n\
 
   if (fcn_name.length ())
     clear_function (fcn_name);
   if (jac_name.length ())
     clear_function (jac_name);
 
   std::string msg = dae.error_message ();
 
-  retval(3) = msg;
-  retval(2) = static_cast<double> (dae.integration_state ());
-
   if (dae.integration_ok ())
     {
+      retval(0) = output;
       retval(1) = deriv_output;
-      retval(0) = output;
     }
   else
     {
-      retval(1) = Matrix ();
-      retval(0) = Matrix ();
-
       if (nargout < 3)
         error ("dassl: %s", msg.c_str ());
+
+      retval(0) = Matrix ();
+      retval(1) = Matrix ();
     }
 
+  retval(2) = static_cast<double> (dae.integration_state ());
+  retval(3) = msg;
+
   return retval;
 }
 
 /*
 ## dassl-1.m
 ##
 ## Test dassl() function
 ##
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -59,49 +59,48 @@ Programming Notes: Routines from @sc{lap
 code from @sc{umfpack} is used for sparse matrices.\n\
 \n\
 The determinant should not be used to check a matrix for singularity.\n\
 For that, use any of the condition number functions: @code{cond},\n\
 @code{condest}, @code{rcond}.\n\
 @seealso{cond, condest, rcond}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
-    {
-      retval(0) = 1.0;
-      return retval;
-    }
+    return octave_value (1.0);
 
   int arg_is_empty = empty_arg ("det", nr, nc);
   if (arg_is_empty < 0)
-    return retval;
+    return octave_value_list ();
   if (arg_is_empty > 0)
-    return octave_value (Matrix (1, 1, 1.0));
-
+    return octave_value (1.0);
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("det");
-      return retval;
+      return octave_value_list ();
     }
 
+  octave_value_list retval (2);
+
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
+      if (nargout <= 1)
+        retval.resize (1);
+
       if (arg.is_complex_type ())
         {
           if (isfloat)
             {
               retval(0) = arg.float_complex_diag_matrix_value ()
                           .determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.float_complex_diag_matrix_value ().rcond ();
@@ -128,16 +127,19 @@ For that, use any of the condition numbe
               retval(0) = arg.diag_matrix_value ().determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.diag_matrix_value ().rcond ();
             }
         }
     }
   else if (arg.is_perm_matrix ())
     {
+      if (nargout <= 1)
+        retval.resize (1);
+
       retval(0) = static_cast<double> (arg.perm_matrix_value ().determinant ());
       if (nargout > 1)
         retval(1) = 1.0;
     }
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
@@ -145,34 +147,34 @@ For that, use any of the condition numbe
           float rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           FloatMatrix m = arg.float_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_matrix);
           MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
           FloatDET det = m.determinant (mtype, info, rcond);
+          retval(0) = info == -1 ? 0.0f : det.value ();
           retval(1) = rcond;
-          retval(0) = info == -1 ? 0.0f : det.value ();
           if (rep)
             rep->matrix_type (mtype);
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_complex_matrix);
           MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
           FloatComplexDET det = m.determinant (mtype, info, rcond);
+          retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
           retval(1) = rcond;
-          retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
           if (rep)
             rep->matrix_type (mtype);
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
@@ -180,64 +182,65 @@ For that, use any of the condition numbe
           double rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               DET det = m.determinant (info, rcond);
+              retval(0) = info == -1 ? 0.0 : det.value ();
               retval(1) = rcond;
-              retval(0) = info == -1 ? 0.0 : det.value ();
             }
           else
             {
               Matrix m = arg.matrix_value ();
 
               MAYBE_CAST (rep, octave_matrix);
               MatrixType mtype = rep ? rep -> matrix_type ()
                 : MatrixType ();
               DET det = m.determinant (mtype, info, rcond);
+              retval(0) = info == -1 ? 0.0 : det.value ();
               retval(1) = rcond;
-              retval(0) = info == -1 ? 0.0 : det.value ();
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect numerically
           // singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               ComplexDET det = m.determinant (info, rcond);
+              retval(0) = info == -1 ? Complex (0.0) : det.value ();
               retval(1) = rcond;
-              retval(0) = info == -1 ? Complex (0.0) : det.value ();
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               MAYBE_CAST (rep, octave_complex_matrix);
               MatrixType mtype = rep ? rep -> matrix_type ()
                 : MatrixType ();
               ComplexDET det = m.determinant (mtype, info, rcond);
+              retval(0) = info == -1 ? Complex (0.0) : det.value ();
               retval(1) = rcond;
-              retval(0) = info == -1 ? Complex (0.0) : det.value ();
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else
         gripe_wrong_type_arg ("det", arg);
     }
+
   return retval;
 }
 
 /*
 %!assert (det ([1, 2; 3, 4]), -2, 10*eps)
 %!assert (det (single ([1, 2; 3, 4])), single (-2), 10*eps ("single"))
 %!error det ()
 %!error det (1, 2)
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -63,23 +63,23 @@ return @code{NaN}.\n\
 \n\
 Reference: Milton @nospell{Abramowitz} and Irene A @nospell{Stegun},\n\
 @cite{Handbook of Mathematical Functions}, Chapter 16 (Sections 16.4, 16.13,\n\
 and 16.15), Dover, 1965.\n\
 \n\
 @seealso{ellipke}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  octave_value_list retval (nargout > 3 ? 4 : 3);
+
   octave_value u_arg = args(0);
   octave_value m_arg = args(1);
 
   if (m_arg.is_scalar_type ())
     {
       double m = args(1).xdouble_value ("ellipj: M must be a scalar or matrix");
 
       if (u_arg.is_scalar_type ())
@@ -89,37 +89,35 @@ and 16.15), Dover, 1965.\n\
               // u real, m scalar
               double u = args(0).xdouble_value ("ellipj: U must be a scalar or matrix");
 
               double sn, cn, dn;
               double err = 0;
 
               ellipj (u, m, sn, cn, dn, err);
 
-              if (nargout > 3)
-                retval(3) = err;
-              retval(2) = dn;
-              retval(1) = cn;
-              retval(0) = sn;
+              if (nargout <= 3)
+                return ovl (sn, cn, dn);
+              else
+                return ovl (sn, cn, dn, err);
             }
           else
             {
               // u complex, m scalar
               Complex u = u_arg.xcomplex_value ("ellipj: U must be a scalar or matrix");
 
               Complex sn, cn, dn;
               double err = 0;
 
               ellipj (u, m, sn, cn, dn, err);
 
-              if (nargout > 3)
-                retval(3) = err;
-              retval(2) = dn;
-              retval(1) = cn;
-              retval(0) = sn;
+              if (nargout <= 3)
+                return ovl (sn, cn, dn);
+              else
+                return ovl (sn, cn, dn, err);
             }
         }
       else
         {
           // u is matrix, m is scalar
           ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: U must be a scalar or matrix");
 
           dim_vector sz_u = u.dims ();
@@ -132,21 +130,21 @@ and 16.15), Dover, 1965.\n\
           Complex *pcn = cn.fortran_vec ();
           Complex *pdn = dn.fortran_vec ();
           double *perr = err.fortran_vec ();
           octave_idx_type nel = u.numel ();
 
           for (octave_idx_type i = 0; i < nel; i++)
             ellipj (pu[i], m, psn[i], pcn[i], pdn[i], perr[i]);
 
-          if (nargout > 3)
-            retval(3) = err;
-          retval(2) = dn;
-          retval(1) = cn;
-          retval(0) = sn;
+
+          if (nargout <= 3)
+            return ovl (sn, cn, dn);
+          else
+            return ovl (sn, cn, dn, err);
         }
     }
   else
     {
       NDArray m = args(1).xarray_value ("ellipj: M must be a scalar or matrix");
 
       dim_vector sz_m = m.dims ();
 
@@ -166,21 +164,20 @@ and 16.15), Dover, 1965.\n\
               double *pcn = cn.fortran_vec ();
               double *pdn = dn.fortran_vec ();
               double *perr = err.fortran_vec ();
               octave_idx_type nel = m.numel ();
 
               for (octave_idx_type i = 0; i < nel; i++)
                 ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
-              if (nargout > 3)
-                retval(3) = err;
-              retval(2) = dn;
-              retval(1) = cn;
-              retval(0) = sn;
+              if (nargout <= 3)
+                return ovl (sn, cn, dn);
+              else
+                return ovl (sn, cn, dn, err);
             }
           else
             {
               // u is complex scalar, m is array
               Complex u = u_arg.xcomplex_value ("ellipj: U must be a scalar or matrix");
 
               ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
               NDArray err (sz_m);
@@ -190,21 +187,20 @@ and 16.15), Dover, 1965.\n\
               Complex *pcn = cn.fortran_vec ();
               Complex *pdn = dn.fortran_vec ();
               double *perr = err.fortran_vec ();
               octave_idx_type nel = m.numel ();
 
               for (octave_idx_type i = 0; i < nel; i++)
                 ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
-              if (nargout > 3)
-                retval(3) = err;
-              retval(2) = dn;
-              retval(1) = cn;
-              retval(0) = sn;
+              if (nargout <= 3)
+                return ovl (sn, cn, dn);
+              else
+                return ovl (sn, cn, dn, err);
             }
         }
       else
         {
           // u is array, m is array
           if (u_arg.is_real_type ())
             {
               // u is real array, m is array
@@ -226,21 +222,20 @@ and 16.15), Dover, 1965.\n\
                   const double *pu = u.data ();
                   const double *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
                       ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j),
                               err(i,j));
 
-                  if (nargout > 3)
-                    retval(3) = err;
-                  retval(2) = dn;
-                  retval(1) = cn;
-                  retval(0) = sn;
+                  if (nargout <= 3)
+                    return ovl (sn, cn, dn);
+                  else
+                    return ovl (sn, cn, dn, err);
                 }
               else if (sz_m == sz_u)
                 {
                   NDArray sn (sz_m), cn (sz_m), dn (sz_m);
                   NDArray err (sz_m);
 
                   const double *pu = u.data ();
                   const double *pm = m.data ();
@@ -248,21 +243,20 @@ and 16.15), Dover, 1965.\n\
                   double *pcn = cn.fortran_vec ();
                   double *pdn = dn.fortran_vec ();
                   double *perr = err.fortran_vec ();
                   octave_idx_type nel = m.numel ();
 
                   for (octave_idx_type i = 0; i < nel; i++)
                     ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
-                  if (nargout > 3)
-                    retval(3) = err;
-                  retval(2) = dn;
-                  retval(1) = cn;
-                  retval(0) = sn;
+                  if (nargout <= 3)
+                    return ovl (sn, cn, dn);
+                  else
+                    return ovl (sn, cn, dn, err);
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
           else
             {
               // u is complex array, m is array
               ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: U must be a scalar or matrix");
@@ -283,21 +277,20 @@ and 16.15), Dover, 1965.\n\
                   const Complex *pu = u.data ();
                   const double  *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
                       ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j),
                               err(i,j));
 
-                  if (nargout > 3)
-                    retval(3) = err;
-                  retval(2) = dn;
-                  retval(1) = cn;
-                  retval(0) = sn;
+                  if (nargout <= 3)
+                    return ovl (sn, cn, dn);
+                  else
+                    return ovl (sn, cn, dn, err);
                 }
               else if (sz_m == sz_u)
                 {
                   ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
                   NDArray err (sz_m);
 
                   const Complex *pu = u.data ();
                   const double  *pm = m.data ();
@@ -305,21 +298,20 @@ and 16.15), Dover, 1965.\n\
                   Complex *pcn = cn.fortran_vec ();
                   Complex *pdn = dn.fortran_vec ();
                   double *perr = err.fortran_vec ();
                   octave_idx_type nel = m.numel ();
 
                   for (octave_idx_type i = 0; i < nel; i++)
                     ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
-                  if (nargout > 3)
-                    retval(3) = err;
-                  retval(2) = dn;
-                  retval(1) = cn;
-                  retval(0) = sn;
+                  if (nargout <= 3)
+                    return ovl (sn, cn, dn);
+                  else
+                    return ovl (sn, cn, dn, err);
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
         }
     }  // m matrix
 
   return retval;
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -366,18 +366,16 @@ H(z) = ---------------------\n\
            k=1\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{filter2, fftfilt, freqz}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 5)
     print_usage ();
 
   const char *a_b_errmsg = "filter: A and B must be vectors";
   const char *x_si_errmsg = "filter: X and SI must be arrays";
 
@@ -397,16 +395,18 @@ H(z) = ---------------------\n\
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
 
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
 
+  octave_value_list retval (nargout > 1 ? 2 : 1);
+
   bool isfloat = (args(0).is_single_type ()
                   || args(1).is_single_type ()
                   || args(2).is_single_type ()
                   || (nargin >= 4 && args(3).is_single_type ()));
 
   if (args(0).is_complex_type ()
       || args(1).is_complex_type ()
       || args(2).is_complex_type ()
@@ -439,20 +439,19 @@ H(z) = ---------------------\n\
               si = args(3).xfloat_complex_array_value (x_si_errmsg);
 
               if (si.is_vector () && x.is_vector ())
                 si = si.reshape (dim_vector (si.numel (), 1));
             }
 
           FloatComplexNDArray y (filter (b, a, x, si, dim));
 
+          retval(0) = y;
           if (nargout == 2)
             retval(1) = si;
-
-          retval(0) = y;
         }
       else
         {
           ComplexColumnVector b = args(0).xcomplex_vector_value (a_b_errmsg);
           ComplexColumnVector a = args(1).xcomplex_vector_value (a_b_errmsg);
 
           ComplexNDArray x = args(2).xcomplex_array_value (x_si_errmsg);
 
@@ -477,20 +476,19 @@ H(z) = ---------------------\n\
               si = args(3).xcomplex_array_value (x_si_errmsg);
 
               if (si.is_vector () && x.is_vector ())
                 si = si.reshape (dim_vector (si.numel (), 1));
             }
 
           ComplexNDArray y (filter (b, a, x, si, dim));
 
+          retval(0) = y;
           if (nargout == 2)
             retval(1) = si;
-
-          retval(0) = y;
         }
     }
   else
     {
       if (isfloat)
         {
           FloatColumnVector b = args(0).xfloat_vector_value (a_b_errmsg);
           FloatColumnVector a = args(1).xfloat_vector_value (a_b_errmsg);
@@ -518,20 +516,19 @@ H(z) = ---------------------\n\
               si = args(3).xfloat_array_value (x_si_errmsg);
 
               if (si.is_vector () && x.is_vector ())
                 si = si.reshape (dim_vector (si.numel (), 1));
             }
 
           FloatNDArray y (filter (b, a, x, si, dim));
 
+          retval(0) = y;
           if (nargout == 2)
             retval(1) = si;
-
-          retval(0) = y;
         }
       else
         {
           ColumnVector b = args(0).xvector_value (a_b_errmsg);
           ColumnVector a = args(1).xvector_value (a_b_errmsg);
 
           NDArray x = args(2).xarray_value (x_si_errmsg);
 
@@ -556,20 +553,19 @@ H(z) = ---------------------\n\
               si = args(3).xarray_value (x_si_errmsg);
 
               if (si.is_vector () && x.is_vector ())
                 si = si.reshape (dim_vector (si.numel (), 1));
             }
 
           NDArray y (filter (b, a, x, si, dim));
 
+          retval(0) = y;
           if (nargout == 2)
             retval(1) = si;
-
-          retval(0) = y;
         }
     }
 
   return retval;
 }
 
 template MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&,
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -6813,18 +6813,18 @@ axes::properties::get_axis_limits (doubl
           // Prevent round-off from cropping ticks
           min_val = std::min (min_val, tick_sep * min_tick);
           max_val = std::max (max_val, tick_sep * max_tick);
         }
     }
 
   retval.resize (1, 2);
 
+  retval(0) = min_val;
   retval(1) = max_val;
-  retval(0) = min_val;
 
   return retval;
 }
 
 void
 axes::properties::calc_ticks_and_lims (array_property& lims,
                                        array_property& ticks,
                                        array_property& mticks,
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -53,21 +53,21 @@ equations (@var{A}*@math{x} = @math{b}) 
 @code{@var{y} = inv (@var{A}) * @math{b}}.\n\
 \n\
 If called with a sparse matrix, then in general @var{x} will be a full\n\
 matrix requiring significantly more storage.  Avoid forming the inverse of a\n\
 sparse matrix if possible.\n\
 @seealso{ldivide, rdivide}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value_list retval;
+
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -256,17 +256,17 @@ After a successful computation, the valu
 If the computation is not successful, @var{istate} will be something\n\
 other than 2 and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{lsode_options} to set optional\n\
 parameters for @code{lsode}.\n\
 @seealso{daspk, dassl, dasrt}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value_list retval (3);
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
@@ -422,28 +422,25 @@ parameters for @code{lsode}.\n\
 
   if (fcn_name.length ())
     clear_function (fcn_name);
   if (jac_name.length ())
     clear_function (jac_name);
 
   std::string msg = ode.error_message ();
 
-  retval(2) = msg;
-  retval(1) = static_cast<double> (ode.integration_state ());
-
   if (ode.integration_ok ())
     retval(0) = output;
+  else if (nargout < 2)
+    error ("lsode: %s", msg.c_str ());
   else
-    {
-      retval(0) = Matrix ();
+    retval(0) = Matrix ();
 
-      if (nargout < 2)
-        error ("lsode: %s", msg.c_str ());
-    }
+  retval(1) = static_cast<double> (ode.integration_state ());
+  retval(2) = msg;
 
   return retval;
 }
 
 /*
 
 ## dassl-1.m
 ##
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -137,290 +137,280 @@ lower triangular matrices, such that @co
 With one output argument @var{y}, then the matrix returned by the @sc{lapack}\n\
 routines is returned.  If the input matrix is sparse then the matrix @var{L}\n\
 is embedded into @var{U} to give a return value similar to the full case.\n\
 For both full and sparse matrices, @code{lu} loses the permutation\n\
 information.\n\
 @seealso{luupdate, ilu, chol, hess, qr, qz, schur, svd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
 
   if (nargin < 1 || (issparse && (nargin > 3 || nargout > 5))
       || (! issparse && (nargin > 2 || nargout > 3)))
     print_usage ();
 
-  bool scale = (nargout == 5);
   bool vecout = false;
   Matrix thres;
+  int n = 1;
 
-  int n = 1;
   while (n < nargin)
     {
       if (args(n).is_string ())
         {
           std::string tmp = args(n++).string_value ();
 
-          if (tmp.compare ("vector") == 0)
+          if (tmp == "vector")
             vecout = true;
           else
             error ("lu: unrecognized string argument");
         }
       else
         {
+          if (! issparse)
+            error ("lu: can not define pivoting threshold THRES for full matrices");
           Matrix tmp = args(n++).matrix_value ();
 
-          if (!issparse)
-            error ("lu: can not define pivoting threshold THRES for full matrices");
-          else if (tmp.numel () == 1)
+          if (tmp.numel () == 1)
             {
               thres.resize (1,2);
               thres(0) = tmp(0);
               thres(1) = tmp(0);
             }
           else if (tmp.numel () == 2)
             thres = tmp;
           else
             error ("lu: THRES must be a 1 or 2-element vector");
         }
     }
 
+  octave_value_list retval;
+  bool scale = (nargout == 5);
+
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("lu", nr, nc);
 
   if (issparse)
     {
       if (arg_is_empty < 0)
-        return retval;
+        return octave_value_list ();
       else if (arg_is_empty > 0)
         return octave_value_list (5, SparseMatrix ());
 
       if (arg.is_real_type ())
         {
-
           SparseMatrix m = arg.sparse_matrix_value ();
 
           if (nargout < 4)
             {
-
-              ColumnVector Qinit;
-              Qinit.resize (nc);
+              ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
-                Qinit (i) = i;
+                Qinit(i) = i;
               SparseLU fact (m, Qinit, thres, false, true);
 
               if (nargout < 2)
                 retval(0) = fact.Y ();
               else
                 {
-
+                  retval.resize (nargout == 3 ? 3 : 2); 
                   retval(1)
                     = octave_value (
                         fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseMatrix L = fact.L ();
-                  if (nargout < 3)
+
+                  if (nargout == 2)
                       retval(0)
                         = octave_value (P.transpose () * L,
                             MatrixType (MatrixType::Permuted_Lower,
                                         nr, fact.row_perm ()));
                   else
                     {
                       retval(0) = L;
                       if (vecout)
                         retval(2) = fact.Pr_vec();
                       else
                         retval(2) = P;
                     }
-
                 }
-
             }
           else
             {
-
+              retval.resize (scale ? 5 : 4);
               SparseLU fact (m, thres, scale);
 
-              if (scale)
-                retval(4) = fact.R ();
+              retval(0) = octave_value (fact.L (),
+                                        MatrixType (MatrixType::Lower));
+              retval(1) = octave_value (fact.U (),
+                                        MatrixType (MatrixType::Upper));
 
               if (vecout)
                 {
+                  retval(2) = fact.Pr_vec ();
                   retval(3) = fact.Pc_vec ();
-                  retval(2) = fact.Pr_vec ();
                 }
               else
                 {
+                  retval(2) = fact.Pr_mat ();
                   retval(3) = fact.Pc_mat ();
-                  retval(2) = fact.Pr_mat ();
                 }
-              retval(1) = octave_value (fact.U (),
-                                        MatrixType (MatrixType::Upper));
-              retval(0) = octave_value (fact.L (),
-                                        MatrixType (MatrixType::Lower));
+
+              if (scale)
+                retval(4) = fact.R ();
             }
-
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
           if (nargout < 4)
             {
-
-              ColumnVector Qinit;
-              Qinit.resize (nc);
+              ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
-                Qinit (i) = i;
+                Qinit(i) = i;
               SparseComplexLU fact (m, Qinit, thres, false, true);
 
               if (nargout < 2)
-
                 retval(0) = fact.Y ();
-
               else
                 {
-
+                  retval.resize (nargout == 3 ? 3 : 2); 
                   retval(1)
                     = octave_value (
                         fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseComplexMatrix L = fact.L ();
-                  if (nargout < 3)
+                  if (nargout == 2)
                     retval(0)
                       = octave_value (P.transpose () * L,
                                       MatrixType (MatrixType::Permuted_Lower,
                                                   nr, fact.row_perm ()));
                   else
                     {
                       retval(0) = L;
                       if (vecout)
                         retval(2) = fact.Pr_vec();
                       else
                         retval(2) = P;
                     }
-
                 }
-
             }
           else
             {
+              retval.resize (scale ? 5 : 4);
+              SparseComplexLU fact (m, thres, scale);
 
-              SparseComplexLU fact (m, thres, scale);
+              retval(0) = octave_value (fact.L (),
+                                        MatrixType (MatrixType::Lower));
+              retval(1) = octave_value (fact.U (),
+                                        MatrixType (MatrixType::Upper));
+
+              if (vecout)
+                {
+                  retval(2) = fact.Pr_vec ();
+                  retval(3) = fact.Pc_vec ();
+                }
+              else
+                {
+                  retval(2) = fact.Pr_mat ();
+                  retval(3) = fact.Pc_mat ();
+                }
 
               if (scale)
                 retval(4) = fact.R ();
-
-              if (vecout)
-                {
-                  retval(3) = fact.Pc_vec ();
-                  retval(2) = fact.Pr_vec ();
-                }
-              else
-                {
-                  retval(3) = fact.Pc_mat ();
-                  retval(2) = fact.Pr_mat ();
-                }
-              retval(1) = octave_value (fact.U (),
-                                        MatrixType (MatrixType::Upper));
-              retval(0) = octave_value (fact.L (),
-                                        MatrixType (MatrixType::Lower));
             }
 
         }
       else
         gripe_wrong_type_arg ("lu", arg);
     }
   else
     {
       if (arg_is_empty < 0)
-        return retval;
+        return octave_value_list ();
       else if (arg_is_empty > 0)
         return octave_value_list (3, Matrix ());
 
       if (arg.is_real_type ())
         {
           if (arg.is_single_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               FloatLU fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
-                  retval(0) = fact.Y ();
+                  retval = ovl (fact.Y ());
                   break;
 
                 case 2:
                   {
                     PermMatrix P = fact.P ();
                     FloatMatrix L = P.transpose () * fact.L ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = L;
+                    retval = ovl (L, get_lu_u (fact));
                   }
                   break;
 
                 case 3:
                 default:
                   {
                     if (vecout)
-                      retval(2) = fact.P_vec ();
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P_vec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = get_lu_l (fact);
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P ());
                   }
                   break;
                 }
             }
           else
             {
               Matrix m = arg.matrix_value ();
 
               LU fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
-                  retval(0) = fact.Y ();
+                  retval = ovl (fact.Y ());
                   break;
 
                 case 2:
                   {
                     PermMatrix P = fact.P ();
                     Matrix L = P.transpose () * fact.L ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = L;
+                    retval = ovl (L, get_lu_u (fact));
                   }
                   break;
 
                 case 3:
                 default:
                   {
                     if (vecout)
-                      retval(2) = fact.P_vec ();
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P_vec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = get_lu_l (fact);
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P ());
                   }
                   break;
                 }
             }
         }
       else if (arg.is_complex_type ())
         {
           if (arg.is_single_type ())
@@ -428,72 +418,70 @@ information.\n\
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               FloatComplexLU fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
-                  retval(0) = fact.Y ();
+                  retval = ovl (fact.Y ());
                   break;
 
                 case 2:
                   {
                     PermMatrix P = fact.P ();
                     FloatComplexMatrix L = P.transpose () * fact.L ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = L;
+                    retval = ovl (L, get_lu_u (fact));
                   }
                   break;
 
                 case 3:
                 default:
                   {
                     if (vecout)
-                      retval(2) = fact.P_vec ();
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P_vec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = get_lu_l (fact);
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P ());
                   }
                   break;
                 }
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               ComplexLU fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
-                  retval(0) = fact.Y ();
+                  retval = ovl (fact.Y ());
                   break;
 
                 case 2:
                   {
                     PermMatrix P = fact.P ();
                     ComplexMatrix L = P.transpose () * fact.L ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = L;
+                    retval = ovl (L, get_lu_u (fact));
                   }
                   break;
 
                 case 3:
                 default:
                   {
                     if (vecout)
-                      retval(2) = fact.P_vec ();
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P_vec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_lu_u (fact);
-                    retval(0) = get_lu_l (fact);
+                      retval = ovl (get_lu_l (fact), get_lu_u (fact),
+                                    fact.P ());
                   }
                   break;
                 }
             }
         }
       else
         gripe_wrong_type_arg ("lu", arg);
     }
@@ -571,16 +559,17 @@ information.\n\
 
 static
 bool check_lu_dims (const octave_value& l, const octave_value& u,
                     const octave_value& p)
 {
   octave_idx_type m = l.rows ();
   octave_idx_type k = u.rows ();
   octave_idx_type n = u.columns ();
+
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
           && k == std::min (m, n)
           && (p.is_undefined () || p.rows () == m));
 }
 
 DEFUN (luupdate, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
@@ -621,135 +610,125 @@ stable.  The second form uses a slower p
 stable.\n\
 \n\
 The matrix case is done as a sequence of rank-1 updates; thus, for large\n\
 enough k, it will be both faster and more accurate to recompute the\n\
 factorization from scratch.\n\
 @seealso{lu, cholupdate, qrupdate}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin != 4 && nargin != 5)
     print_usage ();
 
   bool pivoted = (nargin == 5);
 
   octave_value argl = args(0);
   octave_value argu = args(1);
   octave_value argp = pivoted ? args(2) : octave_value ();
   octave_value argx = args(2 + pivoted);
   octave_value argy = args(3 + pivoted);
 
-  if (argl.is_numeric_type () && argu.is_numeric_type ()
-      && argx.is_numeric_type () && argy.is_numeric_type ()
-      && (! pivoted || argp.is_perm_matrix ()))
-    {
-      if (check_lu_dims (argl, argu, argp))
-        {
-          PermMatrix P = (pivoted
-                          ? argp.perm_matrix_value ()
-                          : PermMatrix::eye (argl.rows ()));
+  if (! (argl.is_numeric_type () && argu.is_numeric_type ()
+         && argx.is_numeric_type () && argy.is_numeric_type ()
+         && (! pivoted || argp.is_perm_matrix ())))
+    error ("luupdate: L, U, X, and Y must be numeric");
 
-          if (argl.is_real_type ()
-              && argu.is_real_type ()
-              && argx.is_real_type ()
-              && argy.is_real_type ())
-            {
-              // all real case
-              if (argl.is_single_type ()
-                  || argu.is_single_type ()
-                  || argx.is_single_type ()
-                  || argy.is_single_type ())
-                {
-                  FloatMatrix L = argl.float_matrix_value ();
-                  FloatMatrix U = argu.float_matrix_value ();
-                  FloatMatrix x = argx.float_matrix_value ();
-                  FloatMatrix y = argy.float_matrix_value ();
+  if (! check_lu_dims (argl, argu, argp))
+    error ("luupdate: dimension mismatch");
 
-                  FloatLU fact (L, U, P);
-                  if (pivoted)
-                    fact.update_piv (x, y);
-                  else
-                    fact.update (x, y);
-
-                  if (pivoted)
-                    retval(2) = fact.P ();
-                  retval(1) = get_lu_u (fact);
-                  retval(0) = get_lu_l (fact);
-                }
-              else
-                {
-                  Matrix L = argl.matrix_value ();
-                  Matrix U = argu.matrix_value ();
-                  Matrix x = argx.matrix_value ();
-                  Matrix y = argy.matrix_value ();
-
-                  LU fact (L, U, P);
-                  if (pivoted)
-                    fact.update_piv (x, y);
-                  else
-                    fact.update (x, y);
+  octave_value_list retval;
+  PermMatrix P = (pivoted
+                  ? argp.perm_matrix_value ()
+                  : PermMatrix::eye (argl.rows ()));
 
-                  if (pivoted)
-                    retval(2) = fact.P ();
-                  retval(1) = get_lu_u (fact);
-                  retval(0) = get_lu_l (fact);
-                }
-            }
-          else
-            {
-              // complex case
-              if (argl.is_single_type ()
-                  || argu.is_single_type ()
-                  || argx.is_single_type ()
-                  || argy.is_single_type ())
-                {
-                  FloatComplexMatrix L = argl.float_complex_matrix_value ();
-                  FloatComplexMatrix U = argu.float_complex_matrix_value ();
-                  FloatComplexMatrix x = argx.float_complex_matrix_value ();
-                  FloatComplexMatrix y = argy.float_complex_matrix_value ();
-
-                  FloatComplexLU fact (L, U, P);
-                  if (pivoted)
-                    fact.update_piv (x, y);
-                  else
-                    fact.update (x, y);
+  if (argl.is_real_type () && argu.is_real_type ()
+      && argx.is_real_type () && argy.is_real_type ())
+    {
+      // all real case
+      if (argl.is_single_type () || argu.is_single_type ()
+          || argx.is_single_type () || argy.is_single_type ())
+        {
+          FloatMatrix L = argl.float_matrix_value ();
+          FloatMatrix U = argu.float_matrix_value ();
+          FloatMatrix x = argx.float_matrix_value ();
+          FloatMatrix y = argy.float_matrix_value ();
 
-                  if (pivoted)
-                    retval(2) = fact.P ();
-                  retval(1) = get_lu_u (fact);
-                  retval(0) = get_lu_l (fact);
-                }
-              else
-                {
-                  ComplexMatrix L = argl.complex_matrix_value ();
-                  ComplexMatrix U = argu.complex_matrix_value ();
-                  ComplexMatrix x = argx.complex_matrix_value ();
-                  ComplexMatrix y = argy.complex_matrix_value ();
+          FloatLU fact (L, U, P);
+          if (pivoted)
+            fact.update_piv (x, y);
+          else
+            fact.update (x, y);
 
-                  ComplexLU fact (L, U, P);
-                  if (pivoted)
-                    fact.update_piv (x, y);
-                  else
-                    fact.update (x, y);
-
-                  if (pivoted)
-                    retval(2) = fact.P ();
-                  retval(1) = get_lu_u (fact);
-                  retval(0) = get_lu_l (fact);
-                }
-            }
+          if (pivoted)
+            retval(2) = fact.P ();
+          retval(1) = get_lu_u (fact);
+          retval(0) = get_lu_l (fact);
         }
       else
-        error ("luupdate: dimension mismatch");
+        {
+          Matrix L = argl.matrix_value ();
+          Matrix U = argu.matrix_value ();
+          Matrix x = argx.matrix_value ();
+          Matrix y = argy.matrix_value ();
+
+          LU fact (L, U, P);
+          if (pivoted)
+            fact.update_piv (x, y);
+          else
+            fact.update (x, y);
+
+          if (pivoted)
+            retval(2) = fact.P ();
+          retval(1) = get_lu_u (fact);
+          retval(0) = get_lu_l (fact);
+        }
     }
   else
-    error ("luupdate: L, U, X, and Y must be numeric");
+    {
+      // complex case
+      if (argl.is_single_type () || argu.is_single_type ()
+          || argx.is_single_type () || argy.is_single_type ())
+        {
+          FloatComplexMatrix L = argl.float_complex_matrix_value ();
+          FloatComplexMatrix U = argu.float_complex_matrix_value ();
+          FloatComplexMatrix x = argx.float_complex_matrix_value ();
+          FloatComplexMatrix y = argy.float_complex_matrix_value ();
+
+          FloatComplexLU fact (L, U, P);
+          if (pivoted)
+            fact.update_piv (x, y);
+          else
+            fact.update (x, y);
+
+          if (pivoted)
+            retval(2) = fact.P ();
+          retval(1) = get_lu_u (fact);
+          retval(0) = get_lu_l (fact);
+        }
+      else
+        {
+          ComplexMatrix L = argl.complex_matrix_value ();
+          ComplexMatrix U = argu.complex_matrix_value ();
+          ComplexMatrix x = argx.complex_matrix_value ();
+          ComplexMatrix y = argy.complex_matrix_value ();
+
+          ComplexLU fact (L, U, P);
+          if (pivoted)
+            fact.update_piv (x, y);
+          else
+            fact.update (x, y);
+
+          if (pivoted)
+            retval(2) = fact.P ();
+          retval(1) = get_lu_u (fact);
+          retval(0) = get_lu_l (fact);
+        }
+    }
 
   return retval;
 }
 
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -94,26 +94,28 @@ All other fields in @var{opts} are ignor
 are the same as for @code{lu}.\n\
 \n\
 Given the string argument @qcode{\"vector\"}, @code{luinc} returns the\n\
 values of @var{p} @var{q} as vector values.\n\
 @seealso{sparse, lu, ilu, ichol}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
-  octave_value_list retval;
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  if (! args(0).is_sparse_type ())
+    error ("luinc: matrix A must be sparse");
+
   bool zero_level = false;
   bool milu = false;
   bool udiag = false;
   Matrix thresh;
-  double droptol = -1.;
+  double droptol = -1.0;
   bool vecout = false;
 
   if (args(1).is_string ())
     {
       if (args(1).string_value () == "0")
         zero_level = true;
       else
         error ("luinc: unrecognized string argument");
@@ -128,67 +130,69 @@ values of @var{p} @var{q} as vector valu
       if (tmp.is_defined ())
         droptol = tmp.double_value ();
 
       tmp = map.getfield ("milu");
       if (tmp.is_defined ())
         {
           double val = tmp.double_value ();
 
-          milu = (val == 0. ? false : true);
+          milu = (val == 0.0 ? false : true);
         }
 
       tmp = map.getfield ("udiag");
       if (tmp.is_defined ())
         {
           double val = tmp.double_value ();
 
-          udiag = (val == 0. ? false : true);
+          udiag = (val == 0.0 ? false : true);
         }
 
       tmp = map.getfield ("thresh");
       if (tmp.is_defined ())
         {
           thresh = tmp.matrix_value ();
 
           if (thresh.numel () == 1)
             {
-              thresh.resize (1,2);
+              thresh.resize (1, 2);
               thresh(1) = thresh(0);
             }
           else if (thresh.numel () != 2)
             error ("luinc: THRESH must be a 1 or 2-element vector");
         }
     }
   else
     droptol = args(1).double_value ();
 
   if (nargin == 3)
     {
       std::string tmp = args(2).string_value ();
 
-      if (tmp.compare ("vector") == 0)
+      if (tmp == "vector")
         vecout = true;
       else
         error ("luinc: unrecognized string argument");
     }
 
   // FIXME: Add code for zero-level factorization
   if (zero_level)
     error ("luinc: zero-level factorization not implemented");
 
-  if (args(0).type_name () == "sparse matrix")
+  octave_value_list retval;
+
+  if (args(0).is_real_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       octave_idx_type sm_nr = sm.rows ();
       octave_idx_type sm_nc = sm.cols ();
       ColumnVector Qinit (sm_nc);
 
       for (octave_idx_type i = 0; i < sm_nc; i++)
-        Qinit (i) = i;
+        Qinit(i) = i;
 
       switch (nargout)
         {
         case 0:
         case 1:
         case 2:
           {
             SparseLU fact (sm, Qinit, thresh, false, true, droptol,
@@ -245,37 +249,35 @@ values of @var{p} @var{q} as vector valu
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
             retval(0)
               = octave_value (fact.L (), MatrixType (MatrixType::Lower));
           }
           break;
         }
     }
-  else if (args(0).type_name () == "sparse complex matrix")
+  else
     {
-      SparseComplexMatrix sm =
-        args(0).sparse_complex_matrix_value ();
+      SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       octave_idx_type sm_nr = sm.rows ();
       octave_idx_type sm_nc = sm.cols ();
       ColumnVector Qinit (sm_nc);
 
       for (octave_idx_type i = 0; i < sm_nc; i++)
-        Qinit (i) = i;
+        Qinit(i) = i;
 
       switch (nargout)
         {
         case 0:
         case 1:
         case 2:
           {
             SparseComplexLU fact (sm, Qinit, thresh, false, true,
                                   droptol, milu, udiag);
 
-
             SparseMatrix P = fact.Pr ();
             SparseComplexMatrix L = P.transpose () * fact.L ();
 
             retval(1)
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
             retval(0)
               = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
@@ -322,18 +324,16 @@ values of @var{p} @var{q} as vector valu
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
             retval(0)
               = octave_value (fact.L (), MatrixType (MatrixType::Lower));
           }
           break;
         }
     }
-  else
-    error ("luinc: matrix A must be sparse");
 
   return retval;
 }
 
 /*
 %!testif HAVE_UMFPACK
 %! a = sparse ([1,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
 %! [l,u] = luinc (a, 1e-10);
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -41,37 +41,36 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 template <class ArrayType>
 static octave_value_list
 do_minmax_red_op (const octave_value& arg,
                   int nargout, int dim, bool ismin)
 {
-  octave_value_list retval;
+  octave_value_list retval (nargout > 1 ? 2 : 1);
   ArrayType array = octave_value_extract<ArrayType> (arg);
 
-  if (nargout == 2)
+  if (nargout <= 1)
     {
-      retval.resize (2);
+      if (ismin)
+        retval(0) = array.min (dim);
+      else
+        retval(0) = array.max (dim);
+    }
+  else
+    {
       Array<octave_idx_type> idx;
       if (ismin)
         retval(0) = array.min (idx, dim);
       else
         retval(0) = array.max (idx, dim);
 
       retval(1) = octave_value (idx, true, true);
     }
-  else
-    {
-      if (ismin)
-        retval(0) = array.min (dim);
-      else
-        retval(0) = array.max (dim);
-    }
 
   return retval;
 }
 
 // Matlab returns double arrays for min/max operations on character
 // arrays, so we specialize here to get that behavior.  Other possible
 // solutions are to convert the argument to double here and call the
 // code for double, but that could waste memory, or to have the
@@ -79,37 +78,36 @@ do_minmax_red_op (const octave_value& ar
 // charNDArray, but that is inconsistent with the way other min/max
 // functions work.
 
 template <>
 octave_value_list
 do_minmax_red_op<charNDArray> (const octave_value& arg,
                                int nargout, int dim, bool ismin)
 {
-  octave_value_list retval;
+  octave_value_list retval (nargout > 1 ? 2 : 1);
   charNDArray array = octave_value_extract<charNDArray> (arg);
 
-  if (nargout == 2)
+  if (nargout <= 1)
     {
-      retval.resize (2);
+      if (ismin)
+        retval(0) = NDArray (array.min (dim));
+      else
+        retval(0) = NDArray (array.max (dim));
+    }
+  else
+    {
       Array<octave_idx_type> idx;
       if (ismin)
         retval(0) = NDArray (array.min (idx, dim));
       else
         retval(0) = NDArray (array.max (idx, dim));
 
       retval(1) = octave_value (idx, true, true);
     }
-  else
-    {
-      if (ismin)
-        retval(0) = NDArray (array.min (dim));
-      else
-        retval(0) = NDArray (array.max (dim));
-    }
 
   return retval;
 }
 
 // Specialization for bool arrays.
 template <>
 octave_value_list
 do_minmax_red_op<boolNDArray> (const octave_value& arg,
@@ -222,25 +220,25 @@ do_minmax_bin_op<charNDArray> (const oct
 
   return retval;
 }
 
 static octave_value_list
 do_minmax_body (const octave_value_list& args,
                 int nargout, bool ismin)
 {
-  octave_value_list retval;
-
-  const char *func = ismin ? "min" : "max";
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   
+  octave_value_list retval (nargout > 1 ? 2 : 1);
+
+  const char *func = ismin ? "min" : "max";
+
   if (nargin == 3 || nargin == 1)
     {
       octave_value arg = args(0);
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
 
@@ -871,64 +869,64 @@ the first index of the maximum value(s).
 
 */
 
 template <class ArrayType>
 static octave_value_list
 do_cumminmax_red_op (const octave_value& arg,
                      int nargout, int dim, bool ismin)
 {
-  octave_value_list retval;
+  octave_value_list retval (nargout > 1 ? 2 : 1);
   ArrayType array = octave_value_extract<ArrayType> (arg);
 
-  if (nargout == 2)
+  if (nargout <= 1)
+    {
+      if (ismin)
+        retval(0) = array.cummin (dim);
+      else
+        retval(0) = array.cummax (dim);
+    }
+  else
     {
       retval.resize (2);
       Array<octave_idx_type> idx;
       if (ismin)
         retval(0) = array.cummin (idx, dim);
       else
         retval(0) = array.cummax (idx, dim);
 
       retval(1) = octave_value (idx, true, true);
     }
-  else
-    {
-      if (ismin)
-        retval(0) = array.cummin (dim);
-      else
-        retval(0) = array.cummax (dim);
-    }
 
   return retval;
 }
 
 static octave_value_list
 do_cumminmax_body (const octave_value_list& args,
                    int nargout, bool ismin)
 {
-  octave_value_list retval;
-
-  const char *func = ismin ? "cummin" : "cummax";
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  const char *func = ismin ? "cummin" : "cummax";
+
   octave_value arg = args(0);
   int dim = -1;
   if (nargin == 2)
     {
       dim = args(1).int_value (true) - 1;
 
       if (dim < 0)
         error ("%s: DIM must be a valid dimension", func);
     }
 
+  octave_value_list retval;
+
   switch (arg.builtin_type ())
     {
     case btyp_double:
       retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
       break;
 
     case btyp_complex:
       retval = do_cumminmax_red_op<ComplexNDArray> (arg, nargout, dim,
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -4373,31 +4373,27 @@ octave_stream_list::do_clear (bool flush
     }
 
   lookup_cache = list.end ();
 }
 
 string_vector
 octave_stream_list::do_get_info (int fid) const
 {
-  string_vector retval;
-
   octave_stream os = do_lookup (fid);
 
-  if (os.is_valid ())
-    {
-      retval.resize (3);
-
-      retval(2) = oct_mach_info::float_format_as_string (os.float_format ());
-      retval(1) = octave_stream::mode_as_string (os.mode ());
-      retval(0) = os.name ();
-    }
-  else
+  if (! os.is_valid ())
     ::error ("invalid file id = %d", fid);
 
+  string_vector retval (3);
+
+  retval(0) = os.name ();
+  retval(1) = octave_stream::mode_as_string (os.mode ());
+  retval(2) = oct_mach_info::float_format_as_string (os.float_format ());
+
   return retval;
 }
 
 string_vector
 octave_stream_list::do_get_info (const octave_value& fid) const
 {
   string_vector retval;
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -249,19 +249,17 @@ Undocumented internal function.\n\
           std::list<std::string>::iterator it = items_lst.begin ();
 
           for (int idx = 0; idx < nel; idx++)
             {
               items.xelem (idx) = *it;
               it++;
             }
 
-          retval(0) = items;
-          retval(1) = *it++;
-          retval(2) = atoi (it->c_str ());
+          retval = ovl (items, *it++, atoi (it->c_str ()));
         }
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_list_dialog__, args, ,
        "-*- texinfo -*-\n\
@@ -314,18 +312,17 @@ Undocumented internal function.\n\
       Matrix items (dim_vector (1, nel));
       octave_idx_type i = 0;
       for (std::list<int>::iterator it = items_lst.begin ();
            it != items_lst.end (); it++)
         {
           items.xelem(i++) = *it;
         }
 
-      retval(1) = result.second;
-      retval(0) = items;
+      retval = ovl (items, result.second);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_input_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})\n\
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -136,18 +136,17 @@ is in the upper left corner, by doing:\n
           octave_idx_type m; \
           octave_idx_type info; \
           TYPE_COND cond1, cond2;
 
 #define PREPARE_OUTPUT()\
           if (info != 0) \
             error ("ordschur: trsen failed"); \
  \
-          retval(0) = U; \
-          retval(1) = S;
+          retval = ovl (U, S);
 
   if (double_type)
     {
       if (complex_type)
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
 
           F77_XFCN (ztrsen, ztrsen,
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -428,20 +428,20 @@ Undocumented internal function.\n\
 
 // Query the timings collected by the profiler.
 DEFUN (__profiler_data__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __profiler_data__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () > 0)
     warning ("profiler_data: ignoring extra arguments");
 
+  octave_value_list retval;
+
   if (nargout > 1)
     retval(1) = profiler.get_hierarchical ();
   retval(0) = profiler.get_flat ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -369,17 +369,16 @@ in the closed right half-plane\n\
 @end enumerate\n\
 \n\
 Note: @code{qz} performs permutation balancing, but not scaling\n\
 (@pxref{XREFbalance}).  The order of output arguments was selected for\n\
 compatibility with @sc{matlab}.\n\
 @seealso{eig, balance, lu, chol, hess, qr, qzhess, schur, svd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
 
 #ifdef DEBUG
   std::cout << "qz: nargin = " << nargin
             << ", nargout = " << nargout << std::endl;
 #endif
 
   if (nargin < 2 || nargin > 3 || nargout > 7)
@@ -450,16 +449,18 @@ compatibility with @sc{matlab}.\n\
   octave_idx_type nn = args(0).rows ();
 
 #ifdef DEBUG
   std::cout << "argument 1 dimensions: ("
             << nn << "," << args(0).columns () << ")"
             << std::endl;
 #endif
 
+  octave_value_list retval;
+
   int arg_is_empty = empty_arg ("qz", nn, args(0).columns ());
 
   if (arg_is_empty < 0)
     {
       gripe_empty_arg ("qz: parameter 1", 0);
       return retval;
     }
   else if (arg_is_empty > 0)
@@ -1208,17 +1209,16 @@ compatibility with @sc{matlab}.\n\
             std::cout << std::endl;
 #endif
             retval(1) = bb;
             retval(0) = aa;
           }
       }
       break;
 
-
     case 1:
     case 0:
 #ifdef DEBUG
       std::cout << "qz: retval(0) = gev = " << gev << std::endl;
 #endif
       retval(0) = gev;
       break;
 
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -123,27 +123,24 @@ leading @var{k} columns of @var{U} alway
 subspace corresponding to the @var{k} leading eigenvalues of @var{S}.\n\
 \n\
 The Schur@tie{}decomposition is used to compute eigenvalues of a square\n\
 matrix, and has applications in the solution of algebraic Riccati equations\n\
 in control (see @code{are} and @code{dare}).\n\
 @seealso{rsf2csf, ordschur, lu, chol, hess, qr, qz, svd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     print_usage ();
 
   octave_value arg = args(0);
 
   std::string ord;
-
   if (nargin == 2)
     ord = args(1).xstring_value ("schur: second argument must be a string");
 
   bool force_complex = false;
 
   if (ord == "real")
     {
       ord = std::string ();
@@ -157,98 +154,100 @@ in control (see @code{are} and @code{dar
     {
       char ord_char = ord.empty () ? 'U' : ord[0];
 
       if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
           && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
         {
           warning ("schur: incorrect ordered schur argument '%s'",
                    ord.c_str ());
-          return retval;
+          return octave_value_list ();
         }
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("schur");
-      return retval;
+      return octave_value_list ();
     }
 
+  octave_value_list retval (nargout > 1 ? 2 : 1);
+
   if (! arg.is_numeric_type ())
     gripe_wrong_type_arg ("schur", arg);
   else if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
-          if (nargout == 0 || nargout == 1)
+          if (nargout <= 1)
             {
               FloatSCHUR result (tmp, ord, false);
-              retval(0) = result.schur_matrix ();
+              retval = ovl (result.schur_matrix ());
             }
           else
             {
               FloatSCHUR result (tmp, ord, true);
-              retval(1) = result.schur_matrix ();
-              retval(0) = result.unitary_matrix ();
+              retval = ovl (result.unitary_matrix (),
+                            result.schur_matrix ());
             }
         }
       else
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-          if (nargout == 0 || nargout == 1)
+          if (nargout <= 1)
             {
               FloatComplexSCHUR result (ctmp, ord, false);
-              retval(0) = mark_upper_triangular (result.schur_matrix ());
+              retval = ovl (mark_upper_triangular (result.schur_matrix ()));
             }
           else
             {
               FloatComplexSCHUR result (ctmp, ord, true);
-              retval(1) = mark_upper_triangular (result.schur_matrix ());
-              retval(0) = result.unitary_matrix ();
+              retval = ovl (result.unitary_matrix (),
+                            mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
   else
     {
       if (! force_complex && arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
-          if (nargout == 0 || nargout == 1)
+          if (nargout <= 1)
             {
               SCHUR result (tmp, ord, false);
-              retval(0) = result.schur_matrix ();
+              retval = ovl (result.schur_matrix ());
             }
           else
             {
               SCHUR result (tmp, ord, true);
-              retval(1) = result.schur_matrix ();
-              retval(0) = result.unitary_matrix ();
+              retval = ovl (result.unitary_matrix (),
+                            result.schur_matrix ());
             }
         }
       else
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-          if (nargout == 0 || nargout == 1)
+          if (nargout <= 1)
             {
               ComplexSCHUR result (ctmp, ord, false);
-              retval(0) = mark_upper_triangular (result.schur_matrix ());
+              retval = ovl (mark_upper_triangular (result.schur_matrix ()));
             }
           else
             {
               ComplexSCHUR result (ctmp, ord, true);
-              retval(1) = mark_upper_triangular (result.schur_matrix ());
-              retval(0) = result.unitary_matrix ();
+              retval = ovl (result.unitary_matrix (),
+                            mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -108,22 +108,20 @@ longer running time.\n\
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       if (nargout == 0)
         octave_sparse_params::print_info (octave_stdout, "");
       else if (nargout == 1)
-        retval(0) =  octave_sparse_params::get_vals ();
+        retval = ovl (octave_sparse_params::get_vals ());
       else if (nargout == 2)
-        {
-          retval(1) = octave_sparse_params::get_vals ();
-          retval(0) = octave_sparse_params::get_keys ();
-        }
+        retval = ovl (octave_sparse_params::get_keys (),
+                      octave_sparse_params::get_vals ());
       else
         error ("spparms: too many output arguments");
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string str = args(0).string_value ();
@@ -145,17 +143,17 @@ longer running time.\n\
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
               if (xisnan (val))
                 error ("spparms: KEY not recognized");
               else
-                retval(0) = val;
+                retval = ovl (val);
             }
         }
       else
         {
           NDArray vals = args(0).xarray_value ("spparms: input must be a string or a vector");
 
           if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
             error ("spparms: too many elements in vector VALS");
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -207,32 +207,33 @@ DEFUN (sqrtm, args, nargout,
 Compute the matrix square root of the square matrix @var{A}.\n\
 \n\
 Ref: @nospell{N.J. Higham}.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type n = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (n != nc || arg.ndims () > 2)
     gripe_square_matrix_required ("sqrtm");
 
+  octave_value_list retval (nargout > 1 ? 3 : 1);
+
   if (nargout > 1)
     {
-      retval.resize (1, 2);
+      // FIXME: Octave does not calculate a condition number with respect to
+      //        sqrtm.  Should this return NaN instead of -1?
       retval(2) = -1.0;
     }
 
   if (arg.is_diag_matrix ())
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
     retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix, FloatComplexSCHUR>
