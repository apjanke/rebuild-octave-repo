# HG changeset patch
# User Rik <rik@octave.org>
# Date 1477325070 25200
#      Mon Oct 24 09:04:30 2016 -0700
# Node ID 9a939479308f05c95b35f86d43effb2419f1e74f
# Parent  a93887d7f0da75deda475ef191993565324c506e
# Parent  655157b34a9f24c09dd98ea7912cbcae22a37dbe
maint: Periodic merge of stable to default.

diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -44,18 +44,19 @@ do_fft (const octave_value_list &args, c
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   octave_value retval;
   octave_value arg = args(0);
+  octave_idx_type n_points = -1;
   dim_vector dims = arg.dims ();
-  octave_idx_type n_points = -1;
+  int ndims = dims.ndims ();
   int dim = -1;
 
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
         {
           double dval = args(1).double_value ();
           if (octave::math::isnan (dval))
@@ -67,55 +68,63 @@ do_fft (const octave_value_list &args, c
         }
     }
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (octave::math::isnan (dval))
         error ("%s: DIM cannot be NaN", fcn);
-      else if (dval < 1 || dval > dims.ndims ())
+      else if (dval < 1 || dval > ndims)
         error ("%s: DIM must be a valid dimension along which to perform FFT",
                fcn);
       else
         // to be safe, cast it back to int since dim is an int
         dim = octave::math::nint (dval) - 1;
     }
 
-  for (octave_idx_type i = 0; i < dims.ndims (); i++)
+  // FIXME: This seems strange and unnecessary (10/21/16).
+  // How would you ever arrive at an octave_value object without correct dims?
+  // We certainly don't make this check every other place in Octave.
+  for (octave_idx_type i = 0; i < ndims; i++)
     if (dims(i) < 0)
       return retval;
 
   if (dim < 0)
     {
-      for (octave_idx_type i = 0; i < dims.ndims (); i++)
-        if (dims(i) > 1)
-          {
-            dim = i;
-            break;
-          }
+      dim = dims.first_non_singleton ();
 
       // And if the first argument is scalar?
-      if (dim < 0)
+      if (dim == ndims)
         dim = 1;
     }
 
   if (n_points < 0)
     n_points = dims(dim);
   else
     dims(dim) = n_points;
 
-  if (dims.any_zero () || n_points == 0)
+  if (n_points == 0 || dims.any_zero ())
     {
       if (arg.is_single_type ())
         return octave_value (FloatNDArray (dims));
       else
         return octave_value (NDArray (dims));
     }
 
+  if (n_points == 1)
+    {
+      octave_value_list idx (ndims);
+      for (octave_idx_type i = 0; i < ndims; i++)
+        idx(i) = idx_vector::colon;
+      idx(dim) = idx_vector (0);
+
+      return arg.do_index_op (idx);
+    }
+
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
@@ -225,66 +234,66 @@ If called with three arguments, @var{dim
 dimension of the matrix along which the inverse FFT is performed
 @seealso{fft, ifft2, ifftn, fftw}
 @end deftypefn */)
 {
   return do_fft (args, "ifft", 1);
 }
 
 /*
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! N = 64;
 %! n = 4;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %! S = fft (s);
 %!
 %! answer = zeros (size (t));
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
 %!
 %! assert (S, answer, 4*N*eps);
 
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
 %! S = zeros (size (t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
 %! assert (ifft (S), s, 4*N*eps);
 
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! N = 64;
 %! n = 4;
 %! t = single (2*pi*(0:1:N-1)/N);
 %! s = cos (n*t);
 %! S = fft (s);
 %!
 %! answer = zeros (size (t), "single");
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
 %!
 %! assert (S, answer, 4*N*eps ("single"));
 
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
 %! S = zeros (size (t), "single");
 %! S(n+1) = N/2;
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -55,18 +55,19 @@
 ## the ODE solver.  It is a structure generated by @code{odeset}.
 ##
 ## The function typically returns two outputs.  Variable @var{t} is a
 ## column vector and contains the times where the solution was found.  The
 ## output @var{y} is a matrix in which each column refers to a different
 ## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## The output can also be returned as a structure @var{solution} which
-## has field @var{x} containing the time where the solution was evaluated and
-## field @var{y} containing the solution matrix for the times in @var{x}.
+## has a field @var{x} containing a row vector of times where the solution
+## was evaluated and a field @var{y} containing the solution matrix such
+## that each column corresponds to a time in @var{x}.
 ## Use @code{fieldnames (@var{solution})} to see the other fields and
 ## additional information returned.
 ##
 ## If using the @qcode{"Events"} option then three additional outputs may
 ## be returned.  @var{te} holds the time when an Event function returned a
 ## zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
@@ -150,25 +151,23 @@ function varargout = ode23 (fun, trange,
            "ode23: FUN must be a valid function handle");
   endif
 
   ## Start preprocessing, have a look which options are set in odeopts,
   ## check if an invalid or unused option is set.
   [defaults, classes, attributes] = odedefaults (numel (init),
                                                  trange(1), trange(end));
 
-  defaults   = rmfield (defaults,   {"Jacobian", "JPattern", "Vectorized", ...
-                                     "MvPattern", "MassSingular", ...
-                                     "InitialSlope", "MaxOrder", "BDF"});
-  classes    = rmfield (classes,    {"Jacobian", "JPattern", "Vectorized", ...
-                                     "MvPattern", "MassSingular", ...
-                                     "InitialSlope", "MaxOrder", "BDF"});
-  attributes = rmfield (attributes, {"Jacobian", "JPattern", "Vectorized", ...
-                                     "MvPattern", "MassSingular", ...
-                                     "InitialSlope", "MaxOrder", "BDF"});
+  persistent ode23_ignore_options = ...
+    {"BDF", "InitialSlope", "Jacobian", "JPattern",
+     "MassSingular", "MaxOrder", "MvPattern", "Vectorized"};
+  
+  defaults   = rmfield (defaults, ode23_ignore_options);
+  classes    = rmfield (classes, ode23_ignore_options);
+  attributes = rmfield (attributes, ode23_ignore_options);
 
   odeopts = odemergeopts ("ode23", odeopts, defaults, classes, attributes);
 
   odeopts.funarguments = funarguments;
   odeopts.direction    = direction;
 
   if (! isempty (odeopts.NonNegative))
     if (isempty (odeopts.Mass))
@@ -206,38 +205,46 @@ function varargout = ode23 (fun, trange,
   else  # no mass matrix - creating a diag-matrix of ones for mass
     havemasshandle = false; # mass = diag (ones (length (init), 1), 0);
   endif
 
   ## Starting the initialization of the core solver ode23
 
   if (havemasshandle)   # Handle only the dynamic mass matrix,
     if (! strcmp (odeopts.MStateDependence, "none"))
-      ## FIXME: How is this comment supposed to end?
-      ## constant mass matrices have already
+      ## constant mass matrices have already been handled
       mass = @(t,x) odeopts.Mass (t, x, odeopts.funarguments{:});
       fun = @(t,x) mass (t, x, odeopts.funarguments{:}) ...
                    \ fun (t, x, odeopts.funarguments{:});
     else
       mass = @(t) odeopts.Mass (t, odeopts.funarguments{:});
       fun = @(t,x) mass (t, odeopts.funarguments{:}) ...
                    \ fun (t, x, odeopts.funarguments{:});
     endif
   endif
 
+  if (nargout == 1)
+    ## Single output requires auto-selected intermediate times,
+    ## which is obtained by NOT specifying specific solution times.
+    trange = [trange(1); trange(end)];
+    odeopts.Refine = [];  # disable Refine when single output requested
+  elseif (numel (trange) > 2)
+    odeopts.Refine = [];  # disable Refine when specific times requested
+  endif
+
   solution = integrate_adaptive (@runge_kutta_23,
                                  order, fun, trange, init, odeopts);
 
   ## Postprocessing, do whatever when terminating integration algorithm
   if (odeopts.haveoutputfunction)  # Cleanup plotter
     feval (odeopts.OutputFcn, [], [], "done", odeopts.funarguments{:});
   endif
   if (! isempty (odeopts.Events))   # Cleanup event function handling
     ode_event_handler (odeopts.Events, solution.t(end),
-                       solution.x(end,:)', "done", odeopts.funarguments{:});
+                       solution.x(end,:).', "done", odeopts.funarguments{:});
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
     nsteps    = solution.cntloop;             # cntloop from 2..end
     nfailed   = solution.cntcycles - nsteps;  # cntcycl from 1..end
     nfevals   = 3 * solution.cntcycles + 1;   # number of ode evaluations
     ndecomps  = 0;  # number of LU decompositions
@@ -250,18 +257,18 @@ function varargout = ode23 (fun, trange,
       printf ("Number of function calls:   %d\n", nfevals);
     endif
   endif
 
   if (nargout == 2)
     varargout{1} = solution.t;      # Time stamps are first output argument
     varargout{2} = solution.x;      # Results are second output argument
   elseif (nargout == 1)
-    varargout{1}.x = solution.t;    # Time stamps are saved in field x
-    varargout{1}.y = solution.x;    # Results are saved in field y
+    varargout{1}.x = solution.t.';   # Time stamps are saved in field x (row vector)
+    varargout{1}.y = solution.x.';   # Results are saved in field y (row vector)
     varargout{1}.solver = solver;   # Solver name is saved in field solver
     if (! isempty (odeopts.Events))
       varargout{1}.ie = solution.event{2};  # Index info which event occurred
       varargout{1}.xe = solution.event{3};  # Time info when an event occurred
       varargout{1}.ye = solution.event{4};  # Results when an event occurred
     endif
     if (strcmp (odeopts.Stats, "on"))
       varargout{1}.stats = struct ();
@@ -316,22 +323,16 @@ endfunction
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
 %!function ydot = fpol (t, y)  # The Van der Pol ODE
 %!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
 %!function ref = fref ()       # The computed reference sol
 %!  ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
-%!function jac = fjac (t, y, varargin)  # its Jacobian
-%!  jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
-%!endfunction
-%!function jac = fjcc (t, y, varargin)  # sparse type
-%!  jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
-%!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
 %!  val = fpol (t, y, varargin);    # We use the derivatives
 %!  trm = zeros (2,1);              # that's why component 2
 %!  dir = ones (2,1);               # does not seem to be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
 %!  val = fpol (t, y, varargin);    # We use the derivatives
 %!  trm = ones (2,1);               # that's why component 2
@@ -386,51 +387,51 @@ endfunction
 %! assert ([t(2)-t(1)], [1e-8], 1e-9);
 %!test  # MaxStep option
 %! opt = odeset ("MaxStep", 1e-3);
 %! sol = ode23 (@fpol, [0 0.2], [2 0], opt);
 %! assert ([sol.x(5)-sol.x(4)], [1e-3], 1e-4);
 %!test  # Solve in backward direction starting at t=0
 %! ref = [-1.205364552835178, 0.951542399860817];
 %! sol = ode23 (@fpol, [0 -2], [2 0]);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 5e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [-2; ref'], 5e-3);
 %!test  # Solve in backward direction starting at t=2
 %! ref = [-1.205364552835178, 0.951542399860817];
 %! sol = ode23 (@fpol, [2 0 -2], fref);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 2e-2);
+%! assert ([sol.x(end); sol.y(:,end)], [-2; ref'], 2e-2);
 %!test  # Solve another anonymous function in backward direction
 %! ref = [-1, 0.367879437558975];
 %! sol = ode23 (@(t,y) y, [0 -1], 1);
-%! assert ([sol.x(end), sol.y(end,:)], ref, 1e-2);
+%! assert ([sol.x(end); sol.y(:,end)], ref', 1e-2);
 %!test  # Solve another anonymous function below zero
 %! ref = [0, 14.77810590694212];
 %! sol = ode23 (@(t,y) y, [-2 0], 2);
-%! assert ([sol.x(end), sol.y(end,:)], ref, 1e-2);
+%! assert ([sol.x(end); sol.y(:,end)], ref', 1e-2);
 %!test  # Solve in backward direction starting at t=0 with MaxStep option
 %! ref = [-1.205364552835178, 0.951542399860817];
 %! opt = odeset ("MaxStep", 1e-3);
 %! sol = ode23 (@fpol, [0 -2], [2 0], opt);
 %! assert ([abs(sol.x(8)-sol.x(7))], [1e-3], 1e-3);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [-2; ref'], 1e-3);
 %!test  # AbsTol option
 %! opt = odeset ("AbsTol", 1e-5);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # AbsTol and RelTol option
 %! opt = odeset ("AbsTol", 1e-8, "RelTol", 1e-8);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # RelTol and NormControl option -- higher accuracy
 %! opt = odeset ("RelTol", 1e-8, "NormControl", "on");
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-4);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-4);
 %!test  # Keeps initial values while integrating
 %! opt = odeset ("NonNegative", 2);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, 2, 0], 1e-1);
+%! assert ([sol.x(end); sol.y(:,end)], [2; 2; 0], 1e-1);
 %!test  # Details of OutputSel and Refine can't be tested
 %! opt = odeset ("OutputFcn", @fout, "OutputSel", 1, "Refine", 5);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
 %!test  # Stats must add further elements in sol
 %! opt = odeset ("Stats", "on");
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
 %! assert (isfield (sol, "stats"));
 %! assert (isfield (sol.stats, "nsteps"));
@@ -450,38 +451,51 @@ endfunction
 %!test  # Events option, five output arguments
 %! warning ("off", "integrate_adaptive:unexpected_termination", "local");
 %! opt = odeset ("Events", @fevn, "NormControl", "on");
 %! [t, y, vxe, ye, vie] = ode23 (@fpol, [0 10], [2 0], opt);
 %! assert ([vie, vxe, ye], [2.0, 2.496110, -0.830550, -2.677589], 1e-1);
 %!test  # Mass option as function
 %! opt = odeset ("Mass", @fmas);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as matrix
 %! opt = odeset ("Mass", eye (2,2));
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as sparse matrix
 %! opt = odeset ("Mass", sparse (eye (2,2)));
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as function and sparse matrix
 %! opt = odeset ("Mass", @fmsa);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 
-## FIXME: Missing tests.
-## test for InitialSlope option is missing
-## test for MaxOrder option is missing
-## test for MvPattern option is missing
+## Note: The following options have no effect on this solver
+##       therefore it makes no sense to test them here:
+##
+## "BDF"
+## "InitialSlope"
+## "JPattern"
+## "Jacobian"
+## "MassSingular"
+## "MaxOrder"
+## "MvPattern"
+## "Vectorized"
+
+%!test # Check that imaginary part of solution does not get inverted
+%! sol = ode23 (@(x,y) 1, [0 1], 1i);
+%! assert (imag (sol.y), ones (size (sol.y)))
+%! [x, y] = ode23 (@(x,y) 1, [0 1], 1i);
+%! assert (imag (y), ones (size (y)))
 
 ## Test input validation
 %!error ode23 ()
 %!error ode23 (1)
 %!error ode23 (1,2)
 %!error <TRANGE must be a numeric> ode23 (@fpol, {[0 25]}, [3 15 1])
 %!error <TRANGE must be a .* vector> ode23 (@fpol, [0 25; 25 0], [3 15 1])
 %!error <TRANGE must contain at least 2 elements> ode23 (@fpol, [1], [3 15 1])
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -53,18 +53,19 @@
 ## the ODE solver.  It is a structure generated by @code{odeset}.
 ##
 ## The function typically returns two outputs.  Variable @var{t} is a
 ## column vector and contains the times where the solution was found.  The
 ## output @var{y} is a matrix in which each column refers to a different
 ## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## The output can also be returned as a structure @var{solution} which
-## has field @var{x} containing the time where the solution was evaluated and
-## field @var{y} containing the solution matrix for the times in @var{x}.
+## has a field @var{x} containing a row vector of times where the solution
+## was evaluated and a field @var{y} containing the solution matrix such
+## that each column corresponds to a time in @var{x}.
 ## Use @code{fieldnames (@var{solution})} to see the other fields and
 ## additional information returned.
 ##
 ## If using the @qcode{"Events"} option then three additional outputs may
 ## be returned.  @var{te} holds the time when an Event function returned a
 ## zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
@@ -141,26 +142,26 @@ function varargout = ode45 (fun, trange,
            "ode45: FUN must be a valid function handle");
   endif
 
   ## Start preprocessing, have a look which options are set in odeopts,
   ## check if an invalid or unused option is set
   [defaults, classes, attributes] = odedefaults (numel (init),
                                                  trange(1), trange(end));
 
-  defaults   = odeset (defaults, "Refine", 4);
-  defaults   = rmfield (defaults,   {"Jacobian", "JPattern", "Vectorized", ...
-                                     "MvPattern", "MassSingular", ...
-                                     "InitialSlope", "MaxOrder", "BDF"});
-  classes    = rmfield (classes,    {"Jacobian", "JPattern", "Vectorized", ...
-                                     "MvPattern", "MassSingular", ...
-                                     "InitialSlope", "MaxOrder", "BDF"});
-  attributes = rmfield (attributes, {"Jacobian", "JPattern", "Vectorized", ...
-                                     "MvPattern", "MassSingular", ...
-                                     "InitialSlope", "MaxOrder", "BDF"});
+  ## FIXME: Refine is not correctly implemented yet
+  defaults = odeset (defaults, "Refine", 4);
+
+  persistent ode45_ignore_options = ...
+    {"BDF", "InitialSlope", "Jacobian", "JPattern",
+     "MassSingular", "MaxOrder", "MvPattern", "Vectorized"};
+
+  defaults   = rmfield (defaults, ode45_ignore_options);
+  classes    = rmfield (classes, ode45_ignore_options);
+  attributes = rmfield (attributes, ode45_ignore_options);
 
   odeopts = odemergeopts ("ode45", odeopts, defaults, classes, attributes);
 
   odeopts.funarguments = funarguments;
   odeopts.direction    = direction;
 
   if (! isempty (odeopts.NonNegative))
     if (isempty (odeopts.Mass))
@@ -209,26 +210,35 @@ function varargout = ode45 (fun, trange,
                    \ fun (t, x, odeopts.funarguments{:});
     else
       mass = @(t) odeopts.Mass (t, odeopts.funarguments{:});
       fun = @(t,x) mass (t, odeopts.funarguments{:}) ...
                    \ fun (t, x, odeopts.funarguments{:});
     endif
   endif
 
+  if (nargout == 1)
+    ## Single output requires auto-selected intermediate times,
+    ## which is obtained by NOT specifying specific solution times.
+    trange = [trange(1); trange(end)];
+    odeopts.Refine = [];  # disable Refine when single output requested
+  elseif (numel (trange) > 2)
+    odeopts.Refine = [];  # disable Refine when specific times requested
+  endif
+
   solution = integrate_adaptive (@runge_kutta_45_dorpri,
                                  order, fun, trange, init, odeopts);
 
   ## Postprocessing, do whatever when terminating integration algorithm
   if (odeopts.haveoutputfunction)  # Cleanup plotter
     feval (odeopts.OutputFcn, [], [], "done", odeopts.funarguments{:});
   endif
   if (! isempty (odeopts.Events))   # Cleanup event function handling
     ode_event_handler (odeopts.Events, solution.t(end),
-                       solution.x(end,:)', "done", odeopts.funarguments{:});
+                       solution.x(end,:).', "done", odeopts.funarguments{:});
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
     nsteps    = solution.cntloop;             # cntloop from 2..end
     nfailed   = solution.cntcycles - nsteps;  # cntcycl from 1..end
     nfevals   = 6 * solution.cntcycles + 1;   # number of ode evaluations
     ndecomps  = 0;  # number of LU decompositions
@@ -241,18 +251,18 @@ function varargout = ode45 (fun, trange,
       printf ("Number of function calls:   %d\n", nfevals);
     endif
   endif
 
   if (nargout == 2)
     varargout{1} = solution.t;      # Time stamps are first output argument
     varargout{2} = solution.x;      # Results are second output argument
   elseif (nargout == 1)
-    varargout{1}.x = solution.t;    # Time stamps are saved in field x
-    varargout{1}.y = solution.x;    # Results are saved in field y
+    varargout{1}.x = solution.t.';   # Time stamps are saved in field x (row vector)
+    varargout{1}.y = solution.x.';   # Results are saved in field y (row vector)
     varargout{1}.solver = solver;   # Solver name is saved in field solver
     if (! isempty (odeopts.Events))
       varargout{1}.ie = solution.event{2};  # Index info which event occurred
       varargout{1}.xe = solution.event{3};  # Time info when an event occurred
       varargout{1}.ye = solution.event{4};  # Results when an event occurred
     endif
     if (strcmp (odeopts.Stats, "on"))
       varargout{1}.stats = struct ();
@@ -307,22 +317,16 @@ endfunction
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
 %!function ydot = fpol (t, y)  # The Van der Pol ODE
 %!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
 %!function ref = fref ()       # The computed reference solution
 %!  ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
-%!function jac = fjac (t, y, varargin)  # its Jacobian
-%!  jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
-%!endfunction
-%!function jac = fjcc (t, y, varargin)  # sparse type
-%!  jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
-%!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
 %!  val = fpol (t, y, varargin);    # We use the derivatives
 %!  trm = zeros (2,1);              # that's why component 2
 %!  dir = ones (2,1);               # does not seem to be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
 %!  val = fpol (t, y, varargin);    # We use the derivatives
 %!  trm = ones (2,1);               # that's why component 2
@@ -380,64 +384,64 @@ endfunction
 %!test  # InitialStep option
 %! opt = odeset ("InitialStep", 1e-8);
 %! [t, y] = ode45 (@fpol, [0 0.2], [2 0], opt);
 %! assert ([t(2)-t(1)], [1e-8], 1e-9);
 %!test  # MaxStep option
 %! opt = odeset ("MaxStep", 1e-3);
 %! sol = ode45 (@fpol, [0 0.2], [2 0], opt);
 %! assert ([sol.x(5)-sol.x(4)], [1e-3], 1e-3);
-%!test  # Solve with intermidiate step
-%! sol = ode45 (@fpol, [0 1 2], [2 0]);
-%! assert (any((sol.x-1) == 0));
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # Solve with intermediate step
+%! [t, y] = ode45 (@fpol, [0 1 2], [2 0]);
+%! assert (any((t-1) == 0));
+%! assert ([t(end), y(end,:)], [2, fref], 1e-3);
 %!test  # Solve in backward direction starting at t=0
 %! vref = [-1.205364552835178, 0.951542399860817];
 %! sol = ode45 (@fpol, [0 -2], [2 0]);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, vref], 1e-2);
+%! assert ([sol.x(end); sol.y(:,end)], [-2; vref'], 1e-2);
 %!test  # Solve in backward direction starting at t=2
 %! vref = [-1.205364552835178, 0.951542399860817];
 %! sol = ode45 (@fpol, [2 -2], fref);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, vref], 1e-2);
-%!test  # Solve in backward direction starting at t=2, with intermidiate step
+%! assert ([sol.x(end); sol.y(:,end)], [-2; vref'], 1e-2);
+%!test  # Solve in backward direction starting at t=2, with intermediate step
 %! vref = [-1.205364552835178, 0.951542399860817];
-%! sol = ode45 (@fpol, [2 0 -2], fref);
-%! idx = find(sol.x < 0, 1, "first") - 1;
-%! assert ([sol.x(idx), sol.y(idx,:)], [0 2 0], 1e-2);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, vref], 1e-2);
+%! [t, y] = ode45 (@fpol, [2 0 -2], fref);
+%! idx = find(y < 0, 1, "first") - 1;
+%! assert ([t(idx), y(idx,:)], [0,2,0], 1e-2);
+%! assert ([t(end), y(end,:)], [-2, vref], 1e-2);
 %!test  # Solve another anonymous function in backward direction
 %! vref = [-1, 0.367879437558975];
 %! sol = ode45 (@(t,y) y, [0 -1], 1);
-%! assert ([sol.x(end), sol.y(end,:)], vref, 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], vref', 1e-3);
 %!test  # Solve another anonymous function below zero
 %! vref = [0, 14.77810590694212];
 %! sol = ode45 (@(t,y) y, [-2 0], 2);
-%! assert ([sol.x(end), sol.y(end,:)], vref, 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], vref', 1e-3);
 %!test  # Solve in backward direction starting at t=0 with MaxStep option
 %! vref = [-1.205364552835178, 0.951542399860817];
 %! opt = odeset ("MaxStep", 1e-3);
 %! sol = ode45 (@fpol, [0 -2], [2 0], opt);
 %! assert ([abs(sol.x(8)-sol.x(7))], [1e-3], 1e-3);
-%! assert ([sol.x(end), sol.y(end,:)], [-2, vref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [-2; vref'], 1e-3);
 %!test  # AbsTol option
 %! opt = odeset ("AbsTol", 1e-5);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # AbsTol and RelTol option
 %! opt = odeset ("AbsTol", 1e-8, "RelTol", 1e-8);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # RelTol and NormControl option -- higher accuracy
 %! opt = odeset ("RelTol", 1e-8, "NormControl", "on");
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-5);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-5);
 %!test  # Keeps initial values while integrating
 %! opt = odeset ("NonNegative", 2);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, 2, 0], 0.5);
+%! assert ([sol.x(end); sol.y(:,end)], [2; 2; 0], 0.5);
 %!test  # Details of OutputSel and Refine can't be tested
 %! opt = odeset ("OutputFcn", @fout, "OutputSel", 1, "Refine", 5);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %!test  # Stats must add further elements in sol
 %! opt = odeset ("Stats", "on");
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert (isfield (sol, "stats"));
 %! assert (isfield (sol.stats, "nsteps"));
@@ -458,38 +462,51 @@ endfunction
 %! warning ("off", "integrate_adaptive:unexpected_termination", "local");
 %! opt = odeset ("Events", @fevn, "NormControl", "on");
 %! [t, y, vxe, ye, vie] = ode45 (@fpol, [0 10], [2 0], opt);
 %! assert ([vie, vxe, ye],
 %!         [2.0, 2.496110, -0.830550, -2.677589], 6e-1);
 %!test  # Mass option as function
 %! opt = odeset ("Mass", @fmas);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as matrix
 %! opt = odeset ("Mass", eye (2,2));
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as sparse matrix
 %! opt = odeset ("Mass", sparse (eye (2,2)));
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as function and sparse matrix
 %! opt = odeset ("Mass", @fmsa);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
-%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%! assert ([sol.x(end); sol.y(:,end)], [2; fref'], 1e-3);
 
-## FIXME: Missing tests.
-## test for InitialSlope option is missing
-## test for MaxOrder option is missing
-## test for MvPattern option is missing
+## Note: The following options have no effect on this solver
+##       therefore it makes no sense to test them here:
+##
+## "BDF"
+## "InitialSlope"
+## "JPattern"
+## "Jacobian"
+## "MassSingular"
+## "MaxOrder"
+## "MvPattern"
+## "Vectorized"
+
+%!test # Check that imaginary part of solution does not get inverted
+%! sol = ode45 (@(x,y) 1, [0 1], 1i);
+%! assert (imag (sol.y), ones (size (sol.y)))
+%! [x, y] = ode45 (@(x,y) 1, [0 1], 1i);
+%! assert (imag (y), ones (size (y)))
 
 %!error ode45 ()
 %!error ode45 (1)
 %!error ode45 (1,2)
 %!error <TRANGE must be a numeric> ode45 (@fpol, {[0 25]}, [3 15 1])
 %!error <TRANGE must be a .* vector> ode45 (@fpol, [0 25; 25 0], [3 15 1])
 %!error <TRANGE must contain at least 2 elements> ode45 (@fpol, [1], [3 15 1])
 %!error <invalid time span> ode45 (@fpol, [1 1], [3 15 1])
diff --git a/scripts/ode/odeset.m b/scripts/ode/odeset.m
--- a/scripts/ode/odeset.m
+++ b/scripts/ode/odeset.m
@@ -55,16 +55,17 @@
 ## by @qcode{odeset}, are the following:
 ##
 ## @table @asis
 ## @item AbsTol
 ## Absolute error tolerance.
 ##
 ## @item BDF
 ## Use BDF formulas in implicit multistep methods.
+## @strong{Note:} This option is not yet implemented.
 ##
 ## @item Events
 ## Event function. An event function must have the form
 ## @code{[value, isterminal, direction] = my_events_f (t, y)}
 ##
 ## @item InitialSlope
 ## Consistent initial slope vector for DAE solvers.
 ##
@@ -98,16 +99,17 @@
 ## Maximum time step value.
 ##
 ## @item MStateDependence
 ## Specify whether the mass matrix depends on the state or only on time.
 ##
 ## @item MvPattern
 ## If the mass matrix is sparse and non-constant but maintains a
 ## constant sparsity pattern, specify the sparsity pattern.
+## @strong{Note:} This option is not yet implemented.
 ##
 ## @item NonNegative
 ## Specify elements of the state vector that are expected to remain
 ## nonnegative during the simulation.
 ##
 ## @item NormControl
 ## Control error relative to the 2-norm of the solution, rather than its
 ## absolute value.
@@ -120,16 +122,17 @@
 ## Indices of elements of the state vector to be passed to the output
 ## monitoring function.
 ##
 ## @item Refine
 ## Specify whether output should be returned only at the end of each
 ## time step or also at intermediate time instances. The value should be
 ## a scalar indicating the number of equally spaced time points to use
 ## within each timestep at which to return output.
+## @strong{Note:} This option is not yet implemented.
 ##
 ## @item RelTol
 ## Relative error tolerance.
 ##
 ## @item Stats
 ## Print solver statistics after simulation.
 ##
 ## @item Vectorized
diff --git a/scripts/ode/private/integrate_adaptive.m b/scripts/ode/private/integrate_adaptive.m
--- a/scripts/ode/private/integrate_adaptive.m
+++ b/scripts/ode/private/integrate_adaptive.m
@@ -188,16 +188,19 @@ function solution = integrate_adaptive (
           ## Call OutputFcn only if a valid result has been found.
           ## Stop integration if function returns true.
           if (options.haveoutputfunction)
             cnt = options.Refine + 1;
             approxtime = linspace (t_old, t_new, cnt);
             approxvals = interp1 ([t_old, t(t_caught), t_new],
                                   [x_old, x(:, t_caught), x_new] .',
                                   approxtime, "linear") .';
+            if (isvector (approxvals))
+              approxvals = approxvals.';
+            endif
             if (! isempty (options.OutputSel))
               approxvals = approxvals(options.OutputSel, :);
             endif
             stop_solve = false;
             for ii = 1:numel (approxtime)
               stop_solve = feval (options.OutputFcn,
                                   approxtime(ii), approxvals(:, ii), [],
                                   options.funarguments{:});
@@ -236,16 +239,19 @@ function solution = integrate_adaptive (
         ## Call OutputFcn only if a valid result has been found.
         ## Stop integration if function returns true.
         if (options.haveoutputfunction)
           cnt = options.Refine + 1;
           approxtime = linspace (t_old, t_new, cnt);
           approxvals = interp1 ([t_old, t_new],
                                 [x_old, x_new] .',
                                 approxtime, "linear") .';
+          if (isvector (approxvals))
+            approxvals = approxvals.';
+          endif
           if (! isempty (options.OutputSel))
             approxvals = approxvals(options.OutputSel, :);
           endif
           stop_solve = false;
           for ii = 1:numel (approxtime)
             stop_solve = feval (options.OutputFcn,
                                 approxtime(ii), approxvals(:, ii), [],
                                 options.funarguments{:});
diff --git a/scripts/ode/private/ode_event_handler.m b/scripts/ode/private/ode_event_handler.m
--- a/scripts/ode/private/ode_event_handler.m
+++ b/scripts/ode/private/ode_event_handler.m
@@ -83,17 +83,17 @@ function retval = ode_event_handler (evt
       y = y{1};  # Delete cell element 2
     endif
     if (nargin > 4)
       inpargs = {inpargs{:}, varargin{:}};
     endif
     [evt, term, dir] = feval (inpargs{:});
 
     ## We require that all return values be row vectors
-    evt = evt(:)'; term = term(:)'; dir = dir(:)';
+    evt = evt(:).'; term = term(:).'; dir = dir(:).';
 
     ## Check if one or more signs of the event has changed
     signum = (sign (evtold) != sign (evt));
     if (any (signum))         # One or more values have changed
       idx = find (signum);    # Get the index of the changed values
 
       if (any (dir(idx) == 0))
         ## Rising or falling (both are possible)
@@ -110,17 +110,17 @@ function retval = ode_event_handler (evt
       if (! isempty (idx))
         ## Change the persistent result cell array
         retcell{1} = any (term(idx));     # Stop integration or not
         retcell{2}(evtcnt,1) = idx(1,1);  # Take first event found
         ## Calculate the time stamp when the event function returned 0 and
         ## calculate new values for the integration results, we do both by
         ## a linear interpolation
         tnew = t - evt(1,idx) * (t - told) / (evt(1,idx) - evtold(1,idx));
-        ynew = (y - (t - tnew) * (y - yold) / (t - told))';
+        ynew = (y - (t - tnew) * (y - yold) / (t - told)).';
         retcell{3}(evtcnt,1) = tnew;
         retcell{4}(evtcnt,:) = ynew;
         evtcnt += 1;
       endif
 
     endif
     evtold = evt; told = t; yold = y;
     retval = retcell;
@@ -137,17 +137,17 @@ function retval = ode_event_handler (evt
       y = y{1};  # Delete cell element 2
     endif
     if (nargin > 4)
       inpargs = {inpargs{:}, varargin{:}};
     endif
     [evtold, ~, ~] = feval (inpargs{:});
 
     ## We require that all return values be row vectors
-    evtold = evtold(:)'; told = t; yold = y;
+    evtold = evtold(:).'; told = t; yold = y;
     evtcnt = 1;
     retval = retcell = cell (1,4);
 
   elseif (strcmp (flag, "done"))
     ## Clear this event handling function
     evtold = told = yold = evtcnt = [];
     retval = retcell = cell (1,4);
 
diff --git a/scripts/ode/private/odedefaults.m b/scripts/ode/private/odedefaults.m
--- a/scripts/ode/private/odedefaults.m
+++ b/scripts/ode/private/odedefaults.m
@@ -42,16 +42,17 @@ function [defaults, classes, attributes]
                                 "NormControl", "off",
                                 "OutputFcn", [],
                                 "OutputSel", [],
                                 "Refine", 1,
                                 "RelTol", 1e-3,
                                 "Stats", "off",
                                 "Vectorized", "off");
 
+  defaults.InitialSlope = zeros (n,1);
   defaults.MaxStep = 0.1 * abs (tf -t0);
 
   persistent classes = struct ("AbsTol", {{"float"}},
                                "BDF", "char",
                                "Events", {{"function_handle"}},
                                "InitialSlope", {{"float"}},
                                "InitialStep", {{"float"}},
                                "Jacobian", {{"float", "function_handle", "cell"}},
@@ -90,10 +91,14 @@ function [defaults, classes, attributes]
                                   "NormControl", {{"on", "off"}},
                                   "OutputFcn", {{}},
                                   "OutputSel", {{"vector", "integer", "positive",...
                                                  ">", 0, "<=", n}},
                                   "Refine", {{"scalar", ">", 0, "integer"}},
                                   "RelTol", {{"scalar", "positive", "real"}},
                                   "Stats", {{"on", "off"}},
                                   "Vectorized", {{"on", "off"}});
+
+  attributes.InitialSlope = {"real", "vector", "numel", n};
+  attributes.OutputSel = {"vector", "integer", "positive", ">", 0, "<=", n};
+
 endfunction
 
diff --git a/scripts/ode/private/runge_kutta_45_dorpri.m b/scripts/ode/private/runge_kutta_45_dorpri.m
--- a/scripts/ode/private/runge_kutta_45_dorpri.m
+++ b/scripts/ode/private/runge_kutta_45_dorpri.m
@@ -55,38 +55,36 @@
 ## to use in an FSAL scheme or for dense output.
 ## @end deftypefn
 
 function [t_next, x_next, x_est, k] = runge_kutta_45_dorpri (f, t, x, dt,
                                                              options = [],
                                                              k_vals = [],
                                                              t_next = t + dt)
 
+  ## Reference: Hairer, Ernst; NÃ¸rsett, Syvert Paul; Wanner, Gerhard (2008),
+  ## Solving ordinary differential equations I: Nonstiff problems,
+  ## Berlin, New York: Springer-Verlag, ISBN 978-3-540-56670-0
   persistent a = [0           0          0           0        0          0;
                   1/5         0          0           0        0          0;
                   3/40        9/40       0           0        0          0;
                   44/45      -56/15      32/9        0        0          0;
                   19372/6561 -25360/2187 64448/6561 -212/729  0          0;
                   9017/3168  -355/33     46732/5247  49/176  -5103/18656 0];
   persistent b = [0, 1/5, 3/10, 4/5, 8/9, 1, 1];
   persistent c = [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84];
   persistent c_prime = [5179/57600, 0, 7571/16695, 393/640, ...
                         -92097/339200, 187/2100, 1/40];
-  ## FIXME: Which source is c_prime derived from?
-  ##        Can't the Shampine clause be deleted if it will never be used?
-  ## According to Shampine 1986:
-  ## persistent c_prime = [(1951/21600) 0 (22642/50085) (451/720), ...
-  ##                       (-12231/42400) (649/6300) (1/60)];
 
   s = t + dt * b;
   cc = dt * c;
   aa = dt * a;
   k = zeros (rows (x), 7);
 
-  if (! isempty (options))  # extra arguments for function evaluator
+  if (! isempty (options))   # extra arguments for function evaluator
     args = options.funarguments;
   else
     args = {};
   endif
 
   if (! isempty (k_vals))    # k values from previous step are passed
     k(:,1) = k_vals(:,end);  # FSAL property
   else
diff --git a/scripts/ode/private/runge_kutta_interpolate.m b/scripts/ode/private/runge_kutta_interpolate.m
--- a/scripts/ode/private/runge_kutta_interpolate.m
+++ b/scripts/ode/private/runge_kutta_interpolate.m
@@ -17,38 +17,29 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function u_interp = runge_kutta_interpolate (order, z, u, t, k_vals, dt, func, args)
 
   switch (order)
 
     case 1
-      u_interp = interp1 (z, u', t, "linear");
+      u_interp = interp1 (z, u.', t, "linear");
 
     case 2
       if (! isempty (k_vals))
         der = k_vals(:,1);
       else
         der = feval (func, z(1) , u(:,1), args);
       endif
       u_interp = quadratic_interpolation (z, u, der, t);
 
     case 3
       u_interp = hermite_cubic_interpolation (z, u, k_vals, t);
 
-    ## FIXME: Do we need an algorithm for order = 4?
-    #{
-    case 4
-      ## if ode45 is used without local extrapolation this function
-      ## doesn't require a new function evaluation.
-      u_interp = dorpri_interpolation ([z(i-1) z(i)],
-                                       [u(:,i-1) u(:,i)],
-                                       k_vals, tspan(counter));
-    #}
     case 5
       ## ode45 with Dormand-Prince scheme:
       u_interp = hermite_quartic_interpolation (z, u, k_vals, t);
 
     otherwise
       warning (["High order interpolation not yet implemented: ", ...
                 "using cubic interpolation instead"]);
       der(:,1) = feval (func, z(1), u(:,1), args);
