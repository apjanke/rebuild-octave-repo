# HG changeset patch
# User jwe
# Date 1147119787 0
#      Mon May 08 20:23:07 2006 +0000
# Node ID 1138ced03f14787c63846062ef7aab30ebc87bb2
# Parent  395382df0d8ad042e3f6f7cf74309bf7a70d3e5f
[project @ 2006-05-08 20:23:04 by jwe]

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,16 +1,17 @@
 Summary of changes for version 3.0:
 ----------------------------------
 
   * Previous versions of Octave had a number of built-in variables to
     control warnings (for example, warn_divide_by_zero).  These
     variables have been replaced by warning identifiers that are used
-    with the warning function to control the state of warnings.  Now,
-    instead of writing
+    with the warning function to control the state of warnings.
+
+    For example, instead of writing
 
       warn_divide_by_zero = false;
 
     to disable divide-by-zero warnings, you should write
 
       warning ("off", "Octave:divide-by-zero");
 
     You may use the same technique in your own code to control
@@ -39,9 +40,25 @@ Summary of changes for version 3.0:
     returned).
 
     A partial list and description of warning identifiers is available
     using
 
       help warning_ids
 
 
+  * All built-in variables have been converted to functions.  This
+    change simplifies the interpreter and allows a consistent
+    interface to internal variables for user-defined packages and the
+    core functions distributed with Octave.  In most cases, code that
+    simply accesses internal variables does not need to change.  Code
+    that sets internal variables will change.  For example, instead of
+    writing
+
+      PS1 = ">> ";
+
+    you will need to write
+
+      PS1 (">> ");
+
+
+
 See NEWS.2 for old news.
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -19,19 +19,20 @@ Boston, MA 02110-1301, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 
-
+// FIXME -- liboctave should not be including files from the src directory.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
+
 #include "MArray2.h"
 #include "MSparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 #include "MatrixType.h"
 #include "oct-sort.h"
 
 template <class T>
diff --git a/scripts/miscellaneous/doc.m b/scripts/miscellaneous/doc.m
--- a/scripts/miscellaneous/doc.m
+++ b/scripts/miscellaneous/doc.m
@@ -54,28 +54,28 @@ function retval = doc (fname)
     info_dir = fileparts (ffile);
   else
     info_dir = octave_config_info ("infodir");
   endif
 
   ## Determine if a file called doc.info exist in the same 
   ## directory as the function.
 
-  info_file = fullfile (info_dir, "doc.info");
+  info_file_name = fullfile (info_dir, "doc.info");
 
-  if (! isstruct (stat (info_file)))
-    info_file = INFO_FILE;
+  if (! isstruct (stat (info_file_name)))
+    info_file_name = info_file ();
   endif
 
   cmd = sprintf ("\"%s\" --directory \"%s\" --file \"%s\" --index-search %s",
-		 INFO_PROGRAM, info_dir, info_file, fname);
+		 info_program (), info_dir, info_file_name, fname);
 
   status = system (cmd);
 
   if (status == 127)
-    warning ("unable to find info program `%s'", INFO_PROGRAM);
+    warning ("unable to find info program `%s'", info_program ());
   endif
 
   if (nargout > 0)
     retval = status;
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -37,18 +37,16 @@ function dump_prefs (file)
   ## remember to update it each time the list of preference variables
   ## changes
 
   var_list = ["DEFAULT_EXEC_PATH";
 	      "DEFAULT_LOADPATH";
 	      "EDITOR";
               "EXEC_PATH";
               "IMAGEPATH";
-              "INFO_FILE";
-              "INFO_PROGRAM";
               "LOADPATH";
               "PAGER";
               "PS1";
               "PS2";
               "PS4";
               "automatic_replot";
               "beep_on_error";
               "completion_append_char";
@@ -63,16 +61,19 @@ function dump_prefs (file)
               "gnuplot_command_splot";
               "gnuplot_command_title";
               "gnuplot_command_using";
               "gnuplot_command_with";
               "gnuplot_has_frames";
               "history_file";
               "history_size";
               "ignore_function_time_stamp";
+              "info_file";
+              "info_program";
+              "makeinfo_program";
               "max_recursion_depth";
               "output_max_field_width";
               "output_precision";
               "page_output_immediately";
               "page_screen_output";
               "print_answer_id_name";
               "print_empty_dimensions";
               "print_rhs_assign_val";
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -117,16 +117,20 @@
 ## that is in the future.  By default, the
 ## @code{Octave:future-time-stamp} warning is enabled.
 ## 
 ## @item Octave:imag-to-real
 ## If the @code{Octave:imag-to-real} warning is enabled, a warning is
 ## printed for implicit conversions of complex numbers to real numbers.
 ## By default, the @code{Octave:imag-to-real} warning is disabled.
 ## 
+## @item Octave:matlab-incompatible
+## Print warnings for Octave language features that may cause
+## compatibility problems with Matlab.
+## 
 ## @item Octave:missing-semicolon
 ## If the @code{Octave:missing-semicolon} warning is enabled, Octave
 ## will warn when statements in function definitions don't end in
 ## semicolons.  By default the @code{Octave:missing-semicolon} warning
 ## is disabled.
 ## 
 ## @item Octave:neg-dim-as-zero
 ## If the @code{Octave:neg-dim-as-zero} warning is enabled, print a warning
@@ -170,16 +174,24 @@
 ## @code{Octave:reload-forces-clear} warning is enabled.
 ## 
 ## @item Octave:resize-on-range-error
 ## If the @code{Octave:resize-on-range-error} warning is enabled, print a
 ## warning when a matrix is resized by an indexed assignment with
 ## indices outside the current bounds.  By default, the
 ## @code{Octave:resize-on-range-error} warning is disabled.
 ## 
+## @item Octave:separator-insert
+## Print warning if commas or semicolons might be inserted
+## automatically in literal matrices.
+## 
+## @item Octave:single-quote-string
+## Print warning if a signle quote character is used to introduce a
+## string constant.
+## 
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
 ## for implicit conversions of strings to their numeric ASCII equivalents.
 ## For example,
 ## @example
 ## @group
 ## "abc" + 0
 ##      @result{} 97 98 99
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -66,16 +66,18 @@
 ##   @item dxf
 ##     AutoCAD
 ##   @item mf
 ##     Metafont
 ##   @item png
 ##     Portable network graphics
 ##   @item pbm
 ##     PBMplus
+##   @item emf
+##     Microsoft Enhanced Metafile
 ##   @end table
 ##
 ##   Other devices are supported by "convert" from ImageMagick.  Type
 ##   system("convert") to see what formats are available.
 ##
 ##   If the device is omitted, it is inferred from the file extension,
 ##   or if there is no filename it is sent to the printer as postscript.
 ##
diff --git a/scripts/startup/main-rcfile b/scripts/startup/main-rcfile
--- a/scripts/startup/main-rcfile
+++ b/scripts/startup/main-rcfile
@@ -1,26 +1,11 @@
 ## System-wide startup file for Octave.
 ##
 ## This file should contain any commands that should be executed each
 ## time Octave starts for every user at this site.
 
-## Default state for warnings is "on", but most people will want to
-## have these disabled.
-
-warning ("off", "Octave:array-to-scalar");
-warning ("off", "Octave:array-to-vector");
-warning ("off", "Octave:empty-list-elements");
-warning ("off", "Octave:fortran-indexing");
-warning ("off", "Octave:imag-to-real");
-warning ("off", "Octave:missing-semicolon");
-warning ("off", "Octave:neg-dim-as-zero");
-warning ("off", "Octave:resize-on-range-error");
-warning ("off", "Octave:str-to-num");
-warning ("off", "Octave:string-concat");
-warning ("off", "Octave:variable-switch-label");
-
 ## Configure readline using the file inputrc in the Octave startup
 ## directory.
 
 read_readline_init_file (sprintf ("%s%s%s",
 				  octave_config_info ("startupfiledir"),
 				  filesep, "inputrc"));
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,204 @@
+2006-05-08  John W. Eaton  <jwe@octave.org>
+
+	* load-save.cc: No need to handle built-in variables.
+	* help.cc (simple_help): No need to handle built-in variables.
+
+	* variables.cc (is_builtin_variable, builtin_string_variable,
+	builtin_real_scalar_variable, builtin_any_variable):
+	Delete functions.
+	(Fexist, Fdocument, do_who, Fwho, link_to_builtin_or_function): 
+	No need to handle built-in variables.
+	* variables.h (is_builtin_variable, builtin_string_variable,
+	builtin_real_scalar_variable, builtin_any_variable): Delete decls.
+
+	* symtab.h (symbol_record::symbol_def::is_builtin_variable,
+	symbol_record::is_builtin_variable): Delete.
+	(symbol_record::TYPE): Remove BUILTIN_VARIABLE from enum.
+	(symbol_record::symbol_def::is_variable, SYMTAB_ALL_TYPES,
+	SYMTAB_VARIABLES): No need to handle built-in variables now.
+	(symbol_record::define_builtin_variable,
+	symbol_record::link_to_builtin_variable): Delete decls.
+	* symtab.cc (record::define, SYMBOL_DEF::type,
+	SYMBOL_DEF::type_as_string): No need to handle built-in variables.
+	(symbol_record::define_builtin_variable): Delete.
+	(symbol_record::variable_reference): No need to attemp to link to
+	built-in variable.
+
+	* utils.cc (check_preference, warn_old_style_preference): Delete.
+	* utils.h (check_preference): Delete decl.
+
+	* defun-int.h: Delete all DEFVAR macros.
+
+	* Makefile.in, mkbuiltins: No need for VAR_FILES.
+
+	* parse.y (current_script_file_name): Delete all uses.
+	(clear_current_script_file_name): Delete function.
+
+	* variables.cc (symbols_of_variables): Delete DEFVAR and function.
+	(bind_ans): Lookup ans in curr_sym_tab, not fbi_sym_tab.
+	SR is no longer static, so we insert value in local scope.
+
+	* defun.cc (bind_builtin_variable): Delete function.
+	* defun-int.h: Delete decl.
+
+	* defaults.cc (fftw_wisdom_program): Rename from fftw_wisdom_prog.
+	Change all uses.
+	(VDEFAULT_LOADPATH): Rename from Vdefault_load_path.  Change all uses.
+	(VLOADPATH): Rename from Vload_path.  Change all uses.
+	(VDEFAULT_EXECPATH): Rename from Vdefault_exec_path.  Change all uses.
+	(VEXECPATH): Rename from Vexec_path.  Change all uses.
+	(VEDITOR): Rename from Veditor.  Change all uses.
+	(Ffftw_wisdom_program, FDEFAULT_LOADPATH, FLOADPATH,
+	FDEFAULT_EXEC_PATH, FEXEC_PATH, FEDITOR, FIMAGEPATH): New functions.
+	(fftw_wisdom_program, default_load_path, loadpath,
+	default_exec_path, exec_path, editor, image_path): Delete functions.
+	(symbols_of_defaults): Delete DEFVARs and function.
+
+	* pr-output.cc (set_output_prec_and_fw): Set Voutput_precision and
+	Voutput_max_field_width directly instad of calling
+	bind_builtin_variable.
+
+	* octave.cc (octave_main, maximum_braindamage):
+	Call bind_internal_variable instead of bind_builtin_variable.
+
+	* pager.cc (Fmore): Set Vpage_screen_output directly instead of
+	calling bind_builtin_variable.
+
+	* error.cc (Fwarning): Set Vdebug_on_warning directly instead of
+	calling bind_builtin_variable.
+
+	* error.cc (initialize_warning_options): Now static.
+	(disable_warning, initialize_default_warning_state): New functions.
+
+	* error.h (initialize_warning_options): Delete decl.
+	(initialize_default_warning_state): Provide decl.
+	* octave.cc (octave_main): Call initialize_default_warning_state
+	instead initialize_warning_options.
+
+	* lex.l (warn_matlab_incompatible, warn_separator_insert,
+	warn_single_quote_string): Delete functions.
+	(symbols_of_lex): Delete DEFVARS.
+	(Vwarn_matlab_incompatible, Vwarn_separator_insert,
+	Vwarn_single_quote_string): Delete variables.
+	(maybe_warn_separator_insert, gripe_single_quote_string,
+	gripe_matlab_incompatible): Call warning_with_id instead of warning.
+
+	* variables.h (SET_NONEMPTY_INTERNAL_STRING_VARIABLE,
+	SET_INTERNAL_VARIABLE_WITH_LIMITS): New macros.
+
+	* ls-oct-ascii.cc (Fsave_precision): New function.
+	(save_precision): Delete function.
+	(symbols_of_ls_oct_ascii): Delete DEFVAR and function.
+
+	* oct-hist.cc (initialize_history): New function.
+	* oct-hist.h: Provide decl.
+	* octave.cc (octave_main): Call initialize_history instead of
+	command_history::read.
+
+	* oct-hist.cc (Fhistory_size, Fhistory_file,
+	Fhistory_timestamp_format_string, Fsaving_history): New functions.
+	(history_size, history_file, history_timestamp_format_string,
+	saving_history): Delete functions.
+	(symbols_of_oct_hist): Delete DEFVARs and function.
+
+	* pt-mat.cc (Fstring_fill_char): New function.
+	(string_fill_char): Delete function.
+	(symbols_of_pt_mat): Delete DEFVAR and function.
+
+	* variables.cc (Fignore_function_time_stamp, ans): New functions.
+	(ignore_function_time_stamp): Delete function.
+	(symbols_of_variables): Delete DEFVARs and function.
+
+	* oct-procbuf.cc: (Vkluge_procbuf_delay): Delete variable.
+	(octave_procbuf::open): Never delay after fork.
+	(kluge_procbuf_delay): Delete function.
+	(symbols_of_oct_procbuf): Delete DEFVAR and function.
+
+	* dirfns.cc (Fconfirm_recursive_rmdir): New function.
+	(confirm_recursive_rmdir): Delete function.
+	(symbols_of_dirfns): Delete DEFVAR and function.
+
+	* error.cc (initialize_warning_options): Now extern.
+	Rename from init_warning_options. 
+	* error.h: Provide decl.
+	* octave.cc (octave_main): Call it here.
+
+	* error.cc (Fbeep_on_error, Fdebug_on_error, Fdebug_on_warning):
+	New functions.
+	(beep_on_error, debug_on_error, debug_on_warning): Delete Functions.
+	(symbols_of_error): Delete DEFVARs and function.
+
+	* help.cc (Finfo_file, Finfo_program, Fmakeinfo_program,
+	Fsuppress_verbose_help_message): New function.
+	(info_file, info_program, makeinfo_program,
+	suppress_verbose_help_message): Delete function.
+	(symbols_of_help): Delete DEFVARs and function.
+	(Vinfo_program): Rename from Vinfo_prog.  Change all uses.
+
+	* input.cc (FPS1, FPS2, FPS4, Fcompletion_append_char,
+	Fecho_executing_commands): New functions.
+	(ps1, ps2, ps4, completion_append_char, echo_executing_commands):
+	Delete functions.
+	(symbols_of_input): Delete DEFVARs and function.
+	(VPS1, VPS2, VPS4): Rename from Vps1, Vps2, Vps4.  Change all uses.
+	(Fecho): Set Vecho_executing_commands directly.
+
+	* load-save.cc (crash_dumps_octave_core, Fdefault_save_options,
+	Foctave_core_file_limit, Foctave_core_file_name,
+	Foctave_core_file_options, Fsave_header_format_string):	
+	New functions.
+	(crash_dumps_octave_core, default_save_options,
+	octave_core_file_limit, octave_core_file_name,
+	octave_core_file_options, save_header_format_string):	
+	Delete functions. 
+	(symbols_of_load_save): Delete DEFVARs and function.
+
+	* ov-base.cc (Fprint_answer_id_name, Fsilent_functions): New functions.
+	(print_answer_id_name, silent_functions): Delete functions.
+	(symbols_of_ov_base): Delete DEFVARs and function.
+
+	* ov-usr-fcn.cc (Fmax_recursion_depth): New function.
+	(max_recursion_depth): Delete function.
+	(symbols_of_ov_usr_fcn): Delete DEFVAR for max_recursion_depth.
+	Delete function.
+
+	* pager.cc (Fpage_output_immediately, Fpage_screen_output, FPAGER):
+	New functions.
+	(page_output_immediately, page_screen_output, pager_binary):
+	Delete functions.
+	(symbols_of_pager): Delete DEFVARs and function.
+	(VPAGER): Rename from Vpager_binary.  Change all uses.
+
+	* pr-output.cc (Ffixed_point_format, Fprint_empty_dimensions,
+	Fsplit_long_rows, Foutput_max_field_width, Foutput_precision,
+	Fstruct_levels_to_print): New functions.
+	(fixed_point_format, print_empty_dimensions, split_long_rows,
+	output_max_field_width, output_precision, struct_levels_to_print):
+	Delete functions.
+	(symbols_of_pr_output): Delete DEFVARs and function.
+
+	* pt-assign.cc (Fprint_rhs_assign_val): New function.
+	(print_rhs_assign_val): Delete function.
+	(symbols_of_pt_assign): Delete DEFVAR.  Delete function.
+
+	* sighandlers.cc (Fdebug_on_interrupt, Fsighup_dumps_octave_core,
+	Fsigterm_dumps_octave_core): New functions.
+	(debug_on_interrupt, sighup_dumps_octave_core,
+	sigterm_dumps_octave_core): Delete functions.
+	(symbols_of_sighanlders): Delete DEFVARs.  Delete function.
+
+	* symtab.cc (Vdebug_symtab_lookups): Now bool.
+	(Fdebug_symtab_lookups, Fwhos_line_format,
+	Fvariables_can_hide_functions): New functions.
+	(debug_symtab_lookups, whos_line_format,
+	variables_can_hide_functions): Delete functions.
+	(symbols_of_symtab): Delete DEFVARs and function.
+
 2006-05-04  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/sqqr (Fdmperm): Allow compilation with versions
 	v2.0.0 of CXSparse or later.
 
 2006-05-04  John W. Eaton  <jwe@octave.org>
 
 	* variables.cc (set_internal_variable): Move here from
@@ -212,31 +408,29 @@ 2006-05-01  John W. Eaton  <jwe@octave.o
 2006-04-27  John W. Eaton  <jwe@octave.org>
 
 	* variables.cc (Fexist): Fix doc string.
 
 	* help.cc (simple_help): No need to handle built-in constants now.
 	* variables.cc (do_who): Likewise.
 	(symbol_exist): Likewise.
 	(link_to_builtin_or_function): Likewise.
-
 	* symtab.cc (SYMBOL_DEF::type_as_string): Likewise.
 	(record::read_only_error): Likewise.
 	(SYMBOL_DEF::type): Likewise.
 	(record::variable_reference): Likewise.
 	(symbol_record::define_builtin_const): Delete function.
 
 	* symtab.h (symbol_record::define_builtin_const): Delete decl.
 	(symbol_record::symbol_def::is_constant): Delete function.
 	(symbol_record::symbol_def::is_builtin_constant): Delete function.
 	(symbol_record::symbol_def::is_constant): Delete function.
 	(symbol_record::is_builtin_constant): Delete function.
 	(SYMTAB_ALL_TYPES): No need to handle builtin-constants now.
 	(symbol_record::TYPE): Remove BUILTIN_CONSTANT from enum.
-	(symbol_record): 
 
 	* defun.cc (install_builtin_constant): Delete function.
 	* defun-int.h (install_builtin_constant): Delete decl.
 
 	* variables.cc (bind_builtin_constant): Delete function.
 	* variables.h (bind_builtin_constant): Delete decl.
 
 	* defun-int.h (DEFCONST, DEFCONSTX, DEFCONST_INTERNAL,
diff --git a/src/DLD-FUNCTIONS/__gnuplot_raw__.l b/src/DLD-FUNCTIONS/__gnuplot_raw__.l
--- a/src/DLD-FUNCTIONS/__gnuplot_raw__.l
+++ b/src/DLD-FUNCTIONS/__gnuplot_raw__.l
@@ -1459,118 +1459,117 @@ public:
 };
 
 static gnuplot_X X;
 
 // -----------------------
 // User-callable functions
 // -----------------------
 
-DEFUN_DLD (automatic_replot, args, ,
+DEFUN_DLD (automatic_replot, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} automatic_replot ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} automatic_replot (@var{new_val})\n\
 Query or set the current automatic replot state.  Although it is fairly\n\
 inefficient, especially for large plots, automatic replotting is enabled\n\
 by default for compatibility with Matlab.\n\
-\n\
-When setting the state, @var{new_val}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (automatic_replot);
 }
 
-DEFUN_DLD (gnuplot_binary, args, ,
+DEFUN_DLD (gnuplot_binary, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} gnuplot_binary\n\
-The name of the program invoked by the plot command.  The default value\n\
-is @code{\"gnuplot\"}.  @xref{Installation}.\n\
+@deftypefn {Loadable Function} {@var{val} =} gnuplot_binary ()\n\
+@deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_binary (@var{new_val})\n\
+Query or set the name of the program invoked by the plot command.\n\
+The default value @code{\"gnuplot\"}.  @xref{Installation}.\n\
 @end deftypefn")
 {
   octave_value retval = SET_INTERNAL_VARIABLE (gnuplot_binary);
 
   if (! error_state && args.length () == 1)
     gnuplot::set_gnuplot_exe (Vgnuplot_binary);
 
   return retval;
 }
 
-DEFUN_DLD (gnuplot_command_plot, args, ,
+DEFUN_DLD (gnuplot_command_plot, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} = } gnuplot_command_plot ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} = } gnuplot_command_plot (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_plot);
 }
 
-DEFUN_DLD (gnuplot_command_replot, args, ,
+DEFUN_DLD (gnuplot_command_replot, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_replot ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_replot (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_replot);
 }
 
-DEFUN_DLD (gnuplot_command_splot, args, ,
+DEFUN_DLD (gnuplot_command_splot, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_splot ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_splot (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_splot);
 }
 
-DEFUN_DLD (gnuplot_command_using, args, ,
+DEFUN_DLD (gnuplot_command_using, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_using ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_using (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_using);
 }
 
-DEFUN_DLD (gnuplot_command_with, args, ,
+DEFUN_DLD (gnuplot_command_with, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_with ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_with (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_with);
 }
 
-DEFUN_DLD (gnuplot_command_axes, args, ,
+DEFUN_DLD (gnuplot_command_axes, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_axes ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_axes (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_axes);
 }
 
-DEFUN_DLD (gnuplot_command_title, args, ,
+DEFUN_DLD (gnuplot_command_title, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_title ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_title (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_title);
 }
 
-DEFUN_DLD (gnuplot_command_end, args, ,
+DEFUN_DLD (gnuplot_command_end, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_command_end ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_command_end (@var{new_val})\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (gnuplot_command_end);
 }
 
-DEFUN_DLD (gnuplot_use_title_option, args, ,
+DEFUN_DLD (gnuplot_use_title_option, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{val} =} gnuplot_use_title_option ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} gnuplot_use_title_option (@var{new_val})\n\
 If enabled, append @samp{-title \"Figure NN\"} to the gnuplot command.\n\
 By default, this feature is enabled if the @code{DISPLAY} environment\n\
 variable is set when Octave starts.\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/fftw_wisdom.cc b/src/DLD-FUNCTIONS/fftw_wisdom.cc
--- a/src/DLD-FUNCTIONS/fftw_wisdom.cc
+++ b/src/DLD-FUNCTIONS/fftw_wisdom.cc
@@ -155,17 +155,17 @@ Octave.\n\
 
       if (name.empty ())
 	{
 	  error ("fftw_wisdom: can not open temporary file");
 	  return retval;
 	}
 
       std::ostringstream cmd_buf; 
-      cmd_buf << Vfftw_wisdom_prog << " -n -o \"" << name << "\"";
+      cmd_buf << Vfftw_wisdom_program << " -n -o \"" << name << "\"";
 
       for (octave_idx_type k = 0; k < m.rows (); k++)
 	{
 	  bool first = true;
 
 	  cmd_buf << " ";
 
 	  // Note reversal of dimensions for column major storage in FFTW
@@ -192,18 +192,17 @@ Octave.\n\
       if (WIFEXITED (status))
 	{
 	  FILE *ifile = fopen (name.c_str (), "r");
 	  if (! fftw_import_wisdom_from_file (ifile))
 	    error ("fftw_wisdom: can not import wisdom from temporary file"); 
 	  fclose (ifile);
 	}
       else
-	error ("fftw_wisdom: error running %s", Vfftw_wisdom_prog.c_str ());
-
+	error ("fftw_wisdom: error running %s", Vfftw_wisdom_program.c_str ());
     }
 
 #else
 
   warning ("fftw_wisdom: this copy of Octave was not configured to use FFTW3");
 
 #endif
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -218,25 +218,17 @@ DLD_DEF_FILES_1 := $(patsubst %.l, %.df,
 DLD_DEF_FILES := $(patsubst %.cc, %.df, $(DLD_DEF_FILES_1))
 
 DEF_4 := $(addprefix $(srcdir)/, $(SOURCES))
 DEF_3 := $(notdir $(shell egrep -l $(DEFUN_PATTERN) $(DEF_4)))
 DEF_2 := $(patsubst %.y, %.df, $(DEF_3))
 DEF_1 := $(patsubst %.l, %.df, $(DEF_2))
 DEF_FILES := $(patsubst %.cc, %.df, $(DEF_1)) $(DLD_DEF_FILES)
 
-DEFVAR_PATTERN = "^[ \t]*DEF(VAR|CONS(T|TX))[ \t]*\\("
-
-VAR_4 := $(addprefix $(srcdir)/, $(SOURCES))
-VAR_3 := $(notdir $(shell egrep -l $(DEFVAR_PATTERN) $(VAR_4)))
-VAR_2 := $(patsubst %.y, %.df, $(VAR_3))
-VAR_1 := $(patsubst %.l, %.df, $(VAR_2))
-VAR_FILES := $(patsubst %.cc, %.df, $(VAR_1))
-
-DOC_FILES := $(sort $(DEF_FILES) $(VAR_FILES))
+DOC_FILES := $(sort $(DEF_FILES))
 
 OCTAVE_LFLAGS = -L$(TOPDIR)/liboctave -L$(TOPDIR)/libcruft \
   -L$(TOPDIR)/src $(RLD_FLAG)
 
 ifeq ($(ENABLE_DYNAMIC_LINKING), true)
   OCTAVE_LIBS = $(LIBOCTINTERP) $(LIBOCTAVE) \
     $(SPECIAL_MATH_LIB) $(LIBCRUFT) \
     $(LIBPLPLOT) $(LIBGLOB) $(LIBDLFCN)
@@ -336,20 +328,18 @@ pic:
 	  mkdir pic; \
 	fi
 
 $(PICOBJ): stmp-pic
 
 builtins.cc: $(DEF_FILES) mkbuiltins
 	@echo making $@
 	@echo DEF_FILES = $(DEF_FILES)
-	@echo VAR_FILES = $(VAR_FILES)
 	@echo $(DEF_FILES) > def-files
-	@echo $(VAR_FILES) > var-files
-	@$(srcdir)/mkbuiltins def-files var-files > $@-t
+	@$(srcdir)/mkbuiltins def-files > $@-t
 	@$(top_srcdir)/move-if-change $@-t $@
 
 PKG_ADD: $(DLD_DEF_FILES)
 	$(srcdir)/mk-pkg-add $(DLD_DEF_FILES) > $@-t
 	mv $@-t $@
 
 DOCSTRINGS: gendoc$(BUILD_EXEEXT)
 	./gendoc > $@-t
@@ -470,17 +460,17 @@ tags: $(SOURCES) $(DLD_SRC)
 TAGS: $(SOURCES) $(DLD_SRC)
 	etags $(SOURCES) $(DLD_SRC)
 
 clean:
 	rm -f liboctinterp.$(LIBEXT)
 	rm -f liboctinterp.$(SHLEXT_VER) liboctinterp.$(SHLEXT)
 	rm -f $(OBJECTS) $(MAKEDEPS) $(DOC_FILES) $(OCT_FILES)
 	rm -f $(PICOBJ) $(DLD_PICOBJ) stmp-pic gendoc$(EXEEXT)
-	rm -f builtins.cc ops.cc defaults.h oct-conf.h def-files var-files
+	rm -f builtins.cc ops.cc defaults.h oct-conf.h def-files
 	rm -f PKG_ADD
 	-rmdir pic
 .PHONY: clean
 
 mostlyclean: clean
 .PHONY: mostlyclean
 
 distclean: clean
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -66,42 +66,42 @@ std::string Vlibexec_dir;
 std::string Varch_lib_dir;
 std::string Vlocal_arch_lib_dir;
 std::string Vlocal_ver_arch_lib_dir;
 std::string Vfcn_file_dir;
 std::string Voct_file_dir;
 
 // The default path that will be searched for programs that we
 // execute (in addition to the user-specified --exec-path).
-static std::string Vdefault_exec_path;
+static std::string VDEFAULT_EXEC_PATH;
 
 // The path that will be searched for programs that we execute.
 // (--exec-path path)
-std::string Vexec_path;
+static std::string VEXEC_PATH;
 
 // Load path specified on command line.
 // (--path path; -p path)
-static std::string Vload_path;
+static std::string VLOADPATH;
 
 // The default load path with OCTAVE_HOME appropriately substituted.
-static std::string Vdefault_load_path;
+static std::string VDEFAULT_LOADPATH;
 
 // And the cached directory path corresponding to Vload_path.
 dir_path Vload_path_dir_path;
 
 // Name of the editor to be invoked by the edit_history command.
-std::string Veditor;
+std::string VEDITOR;
 
-std::string Vimagepath;
+static std::string VIMAGEPATH;
 
 std::string Vlocal_site_defaults_file;
 std::string Vsite_defaults_file;
 
 // Name of the FFTW wisdom program.
-std::string Vfftw_wisdom_prog;
+std::string Vfftw_wisdom_program;
 
 // Each element of A and B should be directory names.  For each
 // element of A not in the list B, execute SCRIPT_FILE in that
 // directory if it exists.
 
 static void
 maybe_add_or_del_packages (const string_vector& a,
 			   const string_vector& b,
@@ -151,17 +151,17 @@ maybe_add_or_del_packages (const string_
   unwind_protect::run_frame ("maybe_add_or_del_packages");
 }
 
 static void
 update_load_path_dir_path (void)
 {
   string_vector old_dirs = Vload_path_dir_path.all_directories ();
 
-  Vload_path_dir_path = dir_path (Vload_path, Vdefault_load_path);
+  Vload_path_dir_path = dir_path (VLOADPATH, VDEFAULT_LOADPATH);
 
   string_vector new_dirs = Vload_path_dir_path.all_directories ();
 
   maybe_add_or_del_packages (old_dirs, new_dirs, "PKG_DEL");
 
   if (! error_state)
     maybe_add_or_del_packages (new_dirs, old_dirs, "PKG_ADD");
 }
@@ -258,17 +258,17 @@ static void
 set_default_bin_dir (void)
 {
   Vbin_dir = subst_octave_home (OCTAVE_BINDIR);
 }
 
 static void
 set_default_default_exec_path (void)
 {
-  Vdefault_exec_path
+  VDEFAULT_EXEC_PATH
     = Vlocal_ver_arch_lib_dir + dir_path::path_sep_str
     + Vlocal_arch_lib_dir + dir_path::path_sep_str
     + Varch_lib_dir + dir_path::path_sep_str
     + Vbin_dir;
 }
 
 static void
 set_default_exec_path (void)
@@ -276,32 +276,32 @@ set_default_exec_path (void)
   std::string octave_exec_path = octave_env::getenv ("OCTAVE_EXEC_PATH");
 
   if (octave_exec_path.empty ())
     {
       std::string shell_path = octave_env::getenv ("PATH");
 
       if (! shell_path.empty ())
 	{
-	  Vexec_path = dir_path::path_sep_str;
-	  Vexec_path.append (shell_path);
+	  VEXEC_PATH = dir_path::path_sep_str;
+	  VEXEC_PATH.append (shell_path);
 	}
     }
   else
-    Vexec_path = std::string (octave_exec_path);
+    VEXEC_PATH = std::string (octave_exec_path);
 }
 
 static void
 set_default_path (void)
 {
-  Vdefault_load_path = subst_octave_home (OCTAVE_FCNFILEPATH);
+  VDEFAULT_LOADPATH = subst_octave_home (OCTAVE_FCNFILEPATH);
 
   std::string oct_path = octave_env::getenv ("OCTAVE_PATH");
 
-  Vload_path = oct_path.empty () ? dir_path::path_sep_str : oct_path;
+  VLOADPATH = oct_path.empty () ? dir_path::path_sep_str : oct_path;
 
   update_load_path_dir_path ();
 }
 
 static void
 set_default_info_file (void)
 {
   std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
@@ -312,41 +312,41 @@ set_default_info_file (void)
 }
 
 static void
 set_default_info_prog (void)
 {
   std::string oct_info_prog = octave_env::getenv ("OCTAVE_INFO_PROGRAM");
 
   if (oct_info_prog.empty ())
-    Vinfo_prog = "info";
+    Vinfo_program = "info";
   else
-    Vinfo_prog = std::string (oct_info_prog);
+    Vinfo_program = std::string (oct_info_prog);
 }
 
 static void
 set_default_fftw_wisdom_prog (void)
 {
   std::string oct_wisdom_prog = octave_env::getenv ("OCTAVE_FFTW_WISDOM_PROGRAM");
 
   if (oct_wisdom_prog.empty ())
-    Vfftw_wisdom_prog = "fftw-wisdom";
+    Vfftw_wisdom_program = "fftw-wisdom";
   else
-    Vfftw_wisdom_prog = std::string (oct_wisdom_prog);
+    Vfftw_wisdom_program = std::string (oct_wisdom_prog);
 }
 
 static void
 set_default_editor (void)
 {
-  Veditor = "emacs";
+  VEDITOR = "emacs";
 
   std::string env_editor = octave_env::getenv ("EDITOR");
 
   if (! env_editor.empty ())
-    Veditor = env_editor;
+    VEDITOR = env_editor;
 }
 
 static void
 set_local_site_defaults_file (void)
 {
   std::string lsf = octave_env::getenv ("OCTAVE_LOCAL_SITE_INITFILE");
 
   if (lsf.empty ())
@@ -376,32 +376,32 @@ std::string
 maybe_add_default_load_path (const std::string& pathstring)
 {
   std::string retval;
 
   if (! pathstring.empty ())
     {
       if (dir_path::is_path_sep (pathstring[0]))
 	{
-	  retval = Vdefault_load_path;
+	  retval = VDEFAULT_LOADPATH;
 	  retval.append (pathstring);
 	}
       else
 	retval = pathstring;
 
       if (dir_path::is_path_sep (pathstring[pathstring.length () - 1]))
-	retval.append (Vdefault_load_path);
+	retval.append (VDEFAULT_LOADPATH);
 
       size_t pos = 0;
       do
 	{
 	  pos = retval.find (dir_path::path_sep_str + dir_path::path_sep_str);
 
 	  if (pos != NPOS)
-	    retval.insert (pos+1, Vdefault_load_path);
+	    retval.insert (pos+1, VDEFAULT_LOADPATH);
 	}
       while (pos != NPOS);
     }
 
   return retval;
 }
 
 void
@@ -456,266 +456,144 @@ Reinitialize Octave's @code{LOADPATH} di
 {
   octave_value_list retval;
 
   Vload_path_dir_path.rehash ();
 
   return retval;
 }
 
-static int
-editor (void)
+DEFUN (EDITOR, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} EDITOR ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
+Query or set the internal variable that specifies the editor to\n\
+use with the @code{edit_history} command.  If the environment\n\
+variable @code{EDITOR} is set when Octave starts, its\n\
+value is used as the default.  Otherwise, @code{EDITOR} is set to\n\
+@code{\"emacs\"}.\n\
+@seealso{edit_history}\n\
+@end deftypefn")
 {
-  int status = 0;
-
-  std::string s = builtin_string_variable ("EDITOR");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("EDITOR");
-      status = -1;
-    }
-  else
-    Veditor = s;
-
-  return status;
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
-static int
-exec_path (void)
+static void
+update_exec_path (void)
 {
-  int status = 0;
-
-  std::string s = builtin_string_variable ("EXEC_PATH");
+  std::string path;
 
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("EXEC_PATH");
-      status = -1;
-    }
-  else
-    {
-      Vexec_path = s;
-
-      std::string path;
+  int eplen = VEXEC_PATH.length ();
 
-      int eplen = Vexec_path.length ();
-
-      if (eplen > 0)
-	{
-	  bool prepend = (Vexec_path[0] == ':');
-	  bool append = (eplen > 1 && Vexec_path[eplen-1] == ':');
+  if (eplen > 0)
+    {
+      bool prepend = (VEXEC_PATH[0] == ':');
+      bool append = (eplen > 1 && VEXEC_PATH[eplen-1] == ':');
 
-	  if (prepend)
-	    {
-	      path = Vdefault_exec_path + Vexec_path;
-	    }
-	  else
-	    {
-	      path = Vexec_path;
-
-	      if (append)
-		path.append (Vdefault_exec_path);
-	    }
+      if (prepend)
+	{
+	  path = VDEFAULT_EXEC_PATH + VEXEC_PATH;
 	}
       else
-	path = Vdefault_exec_path;
-
-      octave_env::putenv ("PATH", path);
-    }
-
-  return status;
-}
-
-static int
-fftw_wisdom_prog (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("FFTW_WISDOM_PROGRAM");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("FFTW_WISDOM_PROGRAM");
-      status = -1;
-    }
-  else
-    Vfftw_wisdom_prog = s;
-
-  return status;
-}
+	{
+	  path = VEXEC_PATH;
 
-static int
-default_exec_path (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("DEFAULT_EXEC_PATH");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("DEFAULT_EXEC_PATH");
-      status = -1;
-    }
-  else
-    {
-      Vdefault_exec_path = s;
-
-      // Now also update PATH in environment.
-      exec_path ();
-    }
-
-  return status;
-}
-
-static int
-imagepath (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("IMAGEPATH");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("IMAGEPATH");
-      status = -1;
+	  if (append)
+	    path.append (VDEFAULT_EXEC_PATH);
+	}
     }
   else
-    Vimagepath = s;
-
-  return status;
-}
-
-static int
-loadpath (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("LOADPATH");
+    path = VDEFAULT_EXEC_PATH;
 
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("LOADPATH");
-      status = -1;
-    }
-  else if (Vload_path != s)
-    {
-      // I'm not sure whether this causes more problems that it
-      // solves...
-      //      if (! (s[0] == ':' || s[s.length () - 1] == ':'
-      //	     || s.find (dir_path::path_sep_str + 
-      //                        dir_path::path_sep_str) != NPOS))
-      //	warning ("LOADPATH will ignore default load path");
-
-      Vload_path = s;
-
-      // By resetting the last prompt time variable, we will force
-      // checks for out of date symbols even if the change to LOADPATH
-      // and subsequent function calls happen between prompts.
-
-      // FIXME -- maybe we should rename
-      // Vlast_prompt_time_stamp since the new usage doesn't really
-      // fit with the current name?
-
-      Vlast_prompt_time.stamp ();
-
-      update_load_path_dir_path ();
-    }
-
-  return status;
+  octave_env::putenv ("PATH", path);
 }
 
-static int
-default_load_path (void)
+DEFUN (EXEC_PATH, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
+Query or set the internal variable that specifies a colon separated\n\
+list of directories to search when executing external programs.\n\
+Its initial value is taken from the environment variable\n\
+@code{OCTAVE_EXEC_PATH} (if it exists) or @code{PATH}, but that\n\
+value can be overridden by the command line argument\n\
+@code{--exec-path PATH}.  Any leading, trailing, or doubled colon in\n\
+the value of @code{EXEC_PATH} are replaced by by the value of\n\
+@code{DEFAULT_EXEC_PATH}.\n\
+@seealso{DEFAULT_EXEC_PATH}\n\
+@end deftypefn")
 {
-  int status = 0;
-
-  std::string s = builtin_string_variable ("DEFAULT_LOADPATH");
+  std::string saved_exec_path = VEXEC_PATH;
 
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("DEFAULT_LOADPATH");
-      status = -1;
-    }
-  else
-    {
-      Vdefault_load_path = s;
+  octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EXEC_PATH);
 
-      update_load_path_dir_path ();
-    }
+  if (VEXEC_PATH != saved_exec_path)
+    update_exec_path ();
 
-  return status;
+  return retval;
 }
 
-void
-symbols_of_defaults (void)
-{
-  DEFVAR (EDITOR, Veditor, editor,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} EDITOR\n\
-A string naming the editor to use with the @code{edit_history} command.\n\
-If the environment variable @code{EDITOR} is set when Octave starts, its\n\
-value is used as the default.  Otherwise, @code{EDITOR} is set to\n\
-@code{\"emacs\"}.\n\
-@end defvr");
-
-  DEFVAR (FFTW_WISDOM_PROGRAM, Vfftw_wisdom_prog, fftw_wisdom_prog,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} FFTW_WISDOM_PROGRAM\n\
-A string naming the FFTW wisdom program to use to create wisdom data\n\
-to accelerate Fourier transforms. If the environment variable\n\
-@code{OCTAVE_WISDOM_PROGRAM} is set when Octave starts, its value is used\n\
-as the default. Otherwise, @code{WISDOM_PROGRAM} is set to\n\
-@code{\"fftw-wisdom\"}.\n\
-@end defvr");
-  
-  DEFVAR (EXEC_PATH, Vexec_path, exec_path,
+DEFUN (fftw_wisdom_program, args, nargout,
     "-*- texinfo -*-\n\
-@defvr {Built-in Variable} EXEC_PATH\n\
-The variable @code{EXEC_PATH} is a colon separated list of directories\n\
-to search when executing external programs.  Its initial value is taken from\n\
-the environment variable @code{OCTAVE_EXEC_PATH} (if it exists) or\n\
-@code{PATH}, but that value can be overridden by the command line\n\
-argument @code{--exec-path PATH}, or by setting the value of\n\
-@code{EXEC_PATH} in a startup script.  If the value of @code{EXEC_PATH}\n\
-begins (ends) with a colon, the directories\n\
-\n\
-@example\n\
-@group\n\
-@var{octave-home}/libexec/octave/site/exec/@var{arch}\n\
-@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}\n\
-@end group\n\
-@end example\n\
-\n\
-@noindent\n\
-are prepended (appended) to @code{EXEC_PATH}, where @var{octave-home}\n\
-is the top-level directory where all of Octave is installed\n\
-(the default value is @file{@value{OCTAVEHOME}}).  If you don't specify\n\
-a value for @code{EXEC_PATH} explicitly, these special directories are\n\
-prepended to your shell path.\n\
-@end defvr");
+@deftypefn {Built-in Function} {@var{val} =} FFTW_WISDOM_PROGRAM ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} FFTW_WISDOM_PROGRAM (@var{new_val})\n\
+Query or set the internal variable that specifies the FFTW wisdom\n\
+program to use to create wisdom data to accelerate Fourier transforms.\n\
+If the environment variable @code{OCTAVE_WISDOM_PROGRAM} is set when\n\
+Octave starts, its value is used as the default. Otherwise,\n\
+@code{WISDOM_PROGRAM} is set to @code{\"fftw-wisdom\"}.\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (fftw_wisdom_program);
+}
 
-  DEFVAR (DEFAULT_EXEC_PATH, Vdefault_exec_path, default_exec_path,
+DEFUN (DEFAULT_EXEC_PATH, args, nargout,
     "-*- texinfo -*-\n\
-@defvr {Built-in Variable} DEFAULT_EXEC_PATH\n\
-A colon separated list of directories in which to search when executing\n\
+@deftypefn {Built-in Function} {@var{val} =} DEFAULT_EXEC_PATH ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} DEFAULT_EXEC_PATH (@var{new_val})\n\
+Query or set the internal variable that specifies a colon separated\n\
+list of directories in which to search when executing\n\
 external programs.  The value of this variable is automatically\n\
 substituted for leading, trailing, or doubled colons that appear in the\n\
 built-in variable @code{EXEC_PATH}.\n\
-@end defvr");
+@seealso{EXEC_PATH}\n\
+@end deftypefn")
+{
+  std::string saved_default_exec_path = VDEFAULT_EXEC_PATH;
+
+  octave_value retval
+    = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (DEFAULT_EXEC_PATH);
+
+  if (VDEFAULT_EXEC_PATH != saved_default_exec_path)
+    update_exec_path ();
+
+  return retval;
+}
 
-  DEFVAR (LOADPATH, Vload_path, loadpath,
+DEFUN (IMAGEPATH, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} IMAGEPATH ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} IMAGEPATH (@var{new_val})\n\
+Query or set the internal variable that specifies a colon separated\n\
+list of directories in which to search for image files.\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGEPATH);
+}
+
+DEFUN (LOADPATH, args, nargout,
     "-*- texinfo -*-\n\
-@defvr {Built-in Variable} LOADPATH\n\
-A colon separated list of directories in which to search for function\n\
+@deftypefn {Built-in Function} {@var{val} =} LOADPATH ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} LOADPATH (@var{new_val})\n\
+Query or set the internal variable that specifies a colon separated\n\
+list of directories in which to search for function\n\
 files.  @xref{Functions and Scripts}.  The value of @code{LOADPATH}\n\
 overrides the environment variable @code{OCTAVE_PATH}.  @xref{Installation}.\n\
 \n\
-@code{LOADPATH} is now handled in the same way as @TeX{} handles\n\
-@code{TEXINPUTS}.  Leading, trailing, or doubled colons that appear in\n\
+Leading, trailing, or doubled colons that appear in\n\
 @code{LOADPATH} are replaced by the value of @code{DEFAULT_LOADPATH}.\n\
 The default value of @code{LOADPATH} is @code{\"\n"
 SEPCHAR_STR
 "\"}, which tells Octave to search in the directories specified by\n\
 @code{DEFAULT_LOADPATH}.\n\
 \n\
 In addition, if any path element ends in @samp{//}, that directory and\n\
 all subdirectories it contains are searched recursively for function\n\
@@ -726,35 +604,63 @@ normally only needs to search its intern
 \n\
 To improve performance of recursive directory searching, it is best for\n\
 each directory that is to be searched recursively to contain\n\
 @emph{either} additional subdirectories @emph{or} function files, but\n\
 not a mixture of both.\n\
 \n\
 @xref{Organization of Functions}, for a description of the function file\n\
 directories that are distributed with Octave.\n\
-@end defvr");
+@seealso{DEFAULT_LOADPATH}\n\
+@end deftypefn")
+{
+  std::string saved_loadpath = VLOADPATH;
+
+  octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (LOADPATH);
 
-  DEFVAR (DEFAULT_LOADPATH, Vdefault_load_path, default_load_path,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} DEFAULT_LOADPATH\n\
-A colon separated list of directories in which to search for function\n\
-files.  The value of this variable is automatically substituted for\n\
-leading, trailing, or doubled colons that appear in the built-in\n\
-variable @code{LOADPATH}.\n\
-@end defvr");
-  
-  DEFVAR (IMAGEPATH, OCTAVE_IMAGEPATH, imagepath,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} IMAGEPATH\n\
-A colon separated list of directories in which to search for image\n\
-files.\n\
-@end defvr");
+  if (VLOADPATH != saved_loadpath)
+    {
+      // By resetting the last prompt time variable, we will force
+      // checks for out of date symbols even if the change to LOADPATH
+      // and subsequent function calls happen between prompts.
+
+      // FIXME -- maybe we should rename
+      // Vlast_prompt_time_stamp since the new usage doesn't really
+      // fit with the current name?
+
+      Vlast_prompt_time.stamp ();
+
+      update_load_path_dir_path ();
+    }
+
+  return retval;
 }
 
+DEFUN (DEFAULT_LOADPATH, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} DEFAULT_LOADPATH ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} DEFAULT_LOADPATH (@var{new_val})\n\
+Query or set the internal variable that specifies the colon separated\n\
+list of directories in which to search for function files.  The value\n\
+of this variable is automatically substituted for leading, trailing,\n\
+or doubled colons that appear in the internal @code{loadpath} variable.\n\
+@seealso{LOADPATH}\n\
+@end deftypefn")
+{
+  std::string saved_default_loadpath = VDEFAULT_LOADPATH;
+
+  octave_value retval
+    = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (DEFAULT_LOADPATH);
+
+  if (VDEFAULT_LOADPATH != saved_default_loadpath)
+    update_load_path_dir_path ();
+
+  return retval;
+}
+  
 DEFUN (OCTAVE_HOME, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/defaults.h.in b/src/defaults.h.in
--- a/src/defaults.h.in
+++ b/src/defaults.h.in
@@ -180,33 +180,27 @@ extern std::string Vinfo_dir;
 extern std::string Vdata_dir;
 extern std::string Vlibexec_dir;
 extern std::string Varch_lib_dir;
 extern std::string Vlocal_arch_lib_dir;
 extern std::string Vlocal_ver_arch_lib_dir;
 extern std::string Vfcn_file_dir;
 extern std::string Voct_file_dir;
 
-// The path that will be searched for programs that we execute.
-// (--exec-path path)
-extern std::string Vexec_path;
-
 // And the cached directory path corresponding to Vload_path.
 extern dir_path Vload_path_dir_path;
 
 // Name of the editor to be invoked by the edit_history command.
-extern std::string Veditor;
-
-extern std::string Vimagepath;
+extern std::string VEDITOR;
 
 extern std::string Vlocal_site_defaults_file;
 extern std::string Vsite_defaults_file;
 
 // Name of the FFTW wisdom program.
-extern std::string Vfftw_wisdom_prog;
+extern std::string Vfftw_wisdom_program;
 
 extern void execute_default_pkg_add_files (void);
 
 extern std::string maybe_add_default_load_path (const std::string& pathstring);
 
 extern void install_defaults (void);
 
 #endif
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -43,22 +43,16 @@ extern void
 install_builtin_mapper (octave_mapper *mf);
 
 extern void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn = false,
 			  bool can_hide_function = true);
 
 extern void
-install_builtin_variable (const std::string& n, const octave_value& v,
-			  bool p, bool e,
-			  symbol_record::change_function chg_fcn,
-			  const std::string& h);
-
-extern void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
 		      const std::string& doc, bool is_text_fcn = false);
 
 extern void
 alias_builtin (const std::string& alias, const std::string& name);
 
 #define DECLARE_FUNX(name, args_name, nargout_name) \
@@ -85,38 +79,16 @@ typedef bool (*octave_dld_fcn_installer)
   bool \
   FS ## name ## _ ## cxx_abi (const octave_shlib& shl) \
   { \
     check_version (OCTAVE_API_VERSION, #name); \
     install_dld_function (F ## name, #name, shl, doc); \
     return error_state ? false : true; \
   }
 
-// Define a builtin variable.
-//
-//   name is the name of the variable, unquoted.
-//
-//   defn is the initial value for the variable.
-//
-//   protect is a flag that says whether it should be possible to give
-//     the variable a new value.
-//
-//   eternal is a flag that says whether it should be possible to
-//     clear the variable.  Most builtin variables are eternal, and
-//     cannot be cleared.
-//
-//   chg_fcn is a pointer to a function that should be called whenever
-//     this variable is given a new value.  It can be 0 if there is no
-//     function to call.  See also the code in user-prefs.cc.
-//
-//   doc is the simple help text for this variable.
-
-#define DEFVAR(name, defn, chg_fcn, doc) \
-  DEFVAR_INTERNAL (#name, SBV_ ## name, defn, false, chg_fcn, doc)
-
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.df files that are eventually used to
 // create the builtins.cc file.
 
 #if defined (MAKE_BUILTINS)
 
 // Generate code to install name in the symbol table.  The script
 // mkdefs will create a .def file for every .cc file that uses DEFUN,
@@ -149,21 +121,16 @@ typedef bool (*octave_dld_fcn_installer)
 
 // Generate code for making another name for an existing function.
 
 #define DEFALIAS_INTERNAL(alias, name) \
   BEGIN_INSTALL_BUILTIN \
     XDEFALIAS_INTERNAL(alias, name) \
   END_INSTALL_BUILTIN
 
-#define DEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
-  BEGIN_INSTALL_BUILTIN \
-    XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
-  END_INSTALL_BUILTIN
-
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      ch_map_flag, can_ret_cmplx_for_real, doc) \
   BEGIN_INSTALL_BUILTIN \
     XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 		           d_c_map, c_c_map, lo, hi, \
 			   ch_map_flag, can_ret_cmplx_for_real, doc) \
   END_INSTALL_BUILTIN
@@ -182,27 +149,16 @@ typedef bool (*octave_dld_fcn_installer)
 #define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
 			is_text_fcn, doc) \
   DECLARE_FUNX (fname, args_name, nargout_name)
 
 // No definition is required for an alias.
 
 #define DEFALIAS_INTERNAL(alias, name)
 
-// How builtin variables are actually installed.
-
-#define DEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
-  install_builtin_variable (name, octave_value (defn), protect, \
-			    (chg_fcn != 0), chg_fcn, doc)
-
-// How builtin variables are actually installed.
-
-#define INSTALL_CONST(name, sname, defn, protect, doc) \
-  install_builtin_constant (name, octave_value (defn), protect, doc)
-
 // How mapper functions are actually installed.
 
 // FIXME -- Really want to avoid the following casts, since
 // (as always with casts) it may mask some real errors...
 
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      ch_map_flag, can_ret_cmplx_for_real, doc) \
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -122,25 +122,16 @@ install_builtin_function (octave_builtin
   sym_rec->unprotect ();
   sym_rec->define (new octave_builtin (f, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_variable (const std::string& name, const octave_value& value,
-			  bool protect, bool eternal,
-			  symbol_record::change_function chg_fcn,
-			  const std::string& doc)
-{
-  bind_builtin_variable (name, value, protect, eternal, chg_fcn, doc);
-}
-
-void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
 		      const std::string& doc, bool is_text_fcn)
 {
   symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::DLD_FUNCTION;
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -43,17 +43,17 @@ 02110-1301, USA.
 //   doc is the simple help text for the function.
 
 #define DEFUN(name, args_name, nargout_name, doc) \
   DEFUN_INTERNAL (name, args_name, nargout_name, false, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
-// too (the convetion is to use a prefix of "F", so "foo" becomes "Ffoo").
+// too (the convention is to use a prefix of "F", so "foo" becomes "Ffoo").
 
 #define DEFUNX(name, fname, args_name, nargout_name, doc) \
   DEFUNX_INTERNAL (name, fname, args_name, nargout_name, false, doc)
 
 // Define a builtin command-style function.
 //
 // This is like DEFUN, except that it defines a function that can be
 // called from the Octave language without using parenthesis to
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -710,33 +710,24 @@ a path.\n\
   if (args.length () == 0)
     retval = dir_path::path_sep_str;
   else
     print_usage ("pathsep");
 
   return retval;
 }
 
-static int
-confirm_recursive_rmdir (void)
+DEFUN (confirm_recursive_rmdir, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave\n\
+will ask for confirmation before recursively removing a directory tree.\n\
+@end deftypefn")
 {
-  Vconfirm_recursive_rmdir = check_preference ("confirm_recursive_rmdir");
-
-  return 0;
-}
-
-void
-symbols_of_dirfns (void)
-{
-  DEFVAR (confirm_recursive_rmdir, true, confirm_recursive_rmdir,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} confirm_recursive_rmdir\n\
-If the value of @code{confirm_recursive_rmdir} is nonzero, Octave\n\
-will ask for confirmation before recursively removing a directory tree.\n\
-The default value is 1.\n\
-@end defvr");
+  return SET_INTERNAL_VARIABLE (confirm_recursive_rmdir);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -43,26 +43,26 @@ 02110-1301, USA.
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 // TRUE means that Octave will try to beep obnoxiously before printing
 // error messages.
-static bool Vbeep_on_error;
+static bool Vbeep_on_error = false;
 
 // TRUE means that Octave will try to enter the debugger when an error
 // is encountered.  This will also inhibit printing of the normal
 // traceback message (you will only see the top-level error message).
-static bool Vdebug_on_error;
+static bool Vdebug_on_error = false;
 
 // TRUE means that Octave will try to enter the debugger when a warning
 // is encountered.
-static bool Vdebug_on_warning;
+static bool Vdebug_on_warning = false;
 
 // TRUE means that Octave will try to display a stack trace when a
 // warning is encountered.
 static bool Vbacktrace_on_warning = false;
 
 // TRUE means that Octave will print a verbose warning.  Currently unused.
 static bool Vverbose_warning;
 
@@ -124,17 +124,17 @@ reset_error_handler (void)
 {
   error_state = 0;
   warning_state = 0;
   buffer_error_messages = 0;
   discard_error_messages = false;
 }
 
 static void
-init_warning_options (const std::string& state = "on")
+initialize_warning_options (const std::string& state)
 {
   warning_options.clear ();
 
   warning_options.assign ("identifier", "all");
   warning_options.assign ("state", state);
 }
 
 // Warning messages are never buffered.
@@ -854,17 +854,17 @@ warning named by @var{id} is handled as 
 		      Vbacktrace_on_warning = (arg1 == "on");
 		      done = true;
 		    }
 		}
 	      else if (arg2 == "debug")
 		{
 		  if (arg1 != "error")
 		    {
-		      bind_builtin_variable ("debug_on_warning", arg1 == "on");
+		      Vdebug_on_warning = (arg1 == "on");
 		      done = true;
 		    }
 		}
 	      else if (arg2 == "verbose")
 		{
 		  if (arg1 != "error")
 		    {
 		      Vverbose_warning = (arg1 == "on");
@@ -880,17 +880,17 @@ warning named by @var{id} is handled as 
 		    }
 		}
 	      else
 		{
 		  if (arg2 == "last")
 		    arg2 = Vlast_warning_id;
 
 		  if (arg2 == "all")
-		    init_warning_options (arg1);
+		    initialize_warning_options (arg1);
 		  else
 		    {
 		      Cell ident = warning_options.contents ("identifier");
 		      Cell state = warning_options.contents ("state");
 
 		      octave_idx_type nel = ident.numel ();
 
 		      bool found = false;
@@ -1071,16 +1071,50 @@ warning named by @var{id} is handled as 
 
       if (nargout > 0)
 	retval = prev_msg;
     }
 
   return retval;
 }
 
+static void
+disable_warning (const std::string& id)
+{
+  octave_value_list args;
+
+  args(1) = id;
+  args(0) = "off";
+
+  Fwarning (args, 0);
+}
+
+void
+initialize_default_warning_state (void)
+{
+  initialize_warning_options ("on");
+
+  // Most people will want to have the following disabled.
+
+  disable_warning ("Octave:array-to-scalar");
+  disable_warning ("Octave:array-to-vector");
+  disable_warning ("Octave:empty-list-elements");
+  disable_warning ("Octave:fortran-indexing");
+  disable_warning ("Octave:imag-to-real");
+  disable_warning ("Octave:matlab-incompatible");
+  disable_warning ("Octave:missing-semicolon");
+  disable_warning ("Octave:neg-dim-as-zero");
+  disable_warning ("Octave:resize-on-range-error");
+  disable_warning ("Octave:separator-insert");
+  disable_warning ("Octave:single-quote-string");
+  disable_warning ("Octave:str-to-num");
+  disable_warning ("Octave:string-concat");
+  disable_warning ("Octave:variable-switch-label");
+}
+
 DEFUN (lasterr, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr (@var{msg}, @var{msgid})\n\
 Without any arguments, return the last error message.  With one\n\
 argument, set the last error message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
 @end deftypefn")
 {
@@ -1194,68 +1228,48 @@ endif\n\
 to check for the proper number of arguments.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   handle_message (usage_with_id, "", "unknown", args);
   return retval;
 }
 
-static int
-beep_on_error (void)
-{
-  Vbeep_on_error = check_preference ("beep_on_error");
-
-  return 0;
-}
-
-static int
-debug_on_error (void)
+DEFUN (beep_on_error, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} beep_on_error ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} beep_on_error (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave will try\n\
+to ring the terminal bell before printing an error message.\n\
+@end deftypefn")
 {
-  Vdebug_on_error = check_preference ("debug_on_error");
-
-  return 0;
-}
-
-static int
-debug_on_warning (void)
-{
-  Vdebug_on_warning = check_preference ("debug_on_warning");
-
-  return 0;
+  return SET_INTERNAL_VARIABLE (beep_on_error);
 }
 
-void
-symbols_of_error (void)
-{
-  init_warning_options ();
-
-  DEFVAR (beep_on_error, false, beep_on_error,
+DEFUN (debug_on_error, args, nargout,
     "-*- texinfo -*-\n\
-@defvr {Built-in Variable} beep_on_error\n\
-If the value of @code{beep_on_error} is nonzero, Octave will try\n\
-to ring your terminal's bell before printing an error message.  The\n\
-default value is 0.\n\
-@end defvr");
-
-  DEFVAR (debug_on_error, false, debug_on_error,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} debug_on_error\n\
-If the value of @code{debug_on_error} is nonzero, Octave will try\n\
+@deftypefn {Built-in Function} {@var{val} =} debug_on_error ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} debug_on_error (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
-the top-level error message).  The default value is 0.\n\
-@end defvr");
+the top-level error message).\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (debug_on_error);
+}
 
-  DEFVAR (debug_on_warning, false, debug_on_warning,
+DEFUN (debug_on_warning, args, nargout,
     "-*- texinfo -*-\n\
-@defvr {Built-in Variable} debug_on_warning\n\
-If the value of @code{debug_on_warning} is nonzero, Octave will try\n\
-to enter the debugger when a warning is encountered.  The default\n\
-value is 0.\n\
-@end defvr");
+@deftypefn {Built-in Function} {@var{val} =} debug_on_warning ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave will try\n\
+to enter the debugger when a warning is encountered.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (debug_on_warning);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -55,16 +55,18 @@ error_with_id (const char *id, const cha
 extern void
 parse_error_with_id (const char *id, const char *fmt, ...);
 
 extern void panic (const char *fmt, ...) GCC_ATTR_NORETURN;
 
 // Helper function for print_usage defined in defun.cc.
 extern void defun_usage_message (const std::string& msg);
 
+extern void initialize_default_warning_state (void);
+
 // Current error state.
 extern int error_state;
 
 // Current warning state.
 extern int warning_state;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -70,24 +70,24 @@ 02110-1301, USA.
 #include "quit.h"
 
 // Name of the info file specified on command line.
 // (--info-file file)
 std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
-std::string Vinfo_prog;
+std::string Vinfo_program;
 
 // Name of the makeinfo program to run.
-static std::string Vmakeinfo_prog = "makeinfo";
+static std::string Vmakeinfo_program = "makeinfo";
 
 // If TRUE, don't print additional help message in help and usage
 // functions.
-static bool Vsuppress_verbose_help_message;
+static bool Vsuppress_verbose_help_message = false;
 
 // FIXME -- maybe this should use string instead of char*.
 
 struct help_list
 {
   const char *name;
   const char *help;
 };
@@ -447,18 +447,18 @@ make_name_list (void)
   return list;
 }
 
 void
 additional_help_message (std::ostream& os)
 {
   if (! Vsuppress_verbose_help_message)
     os << "\
-Additional help for built-in functions, operators, and variables\n\
-is available in the on-line version of the manual.  Use the command\n\
+Additional help for built-in functions and operators is\n\
+available in the on-line version of the manual.  Use the command\n\
 `doc <topic>' to search the manual index.\n\
 \n\
 Help and information about Octave is also available on the WWW\n\
 at http://www.octave.org and via the help@octave.org\n\
 mailing list.\n"; 
 }
 
 // FIXME -- this needs a major overhaul to cope with new
@@ -513,18 +513,16 @@ simple_help (void)
   display_names_from_help_list (octave_stdout, operator_help (),
 				"operators");
 
   display_names_from_help_list (octave_stdout, keyword_help (),
 				"reserved words");
 
   // FIXME -- is this distinction needed?
 
-  LIST_SYMBOLS (symbol_record::BUILTIN_VARIABLE, "built-in variables");
-
   LIST_SYMBOLS (symbol_record::COMMAND, "commands");
 
   LIST_SYMBOLS (symbol_record::MAPPER_FUNCTION, "mapper functions");
 
   LIST_SYMBOLS (symbol_record::BUILTIN_FUNCTION, "general functions");
 
   // Also need to list variables and currently compiled functions from
   // the symbol table, if there are any.
@@ -641,17 +639,17 @@ display_help_text (std::ostream& os, con
 	cols -= 7;
 
       if (cols > 80)
 	cols = 72;
 
       std::ostringstream buf;
 
       buf << "sed -e 's/^[#%][#%]* *//' -e 's/^ *@/@/' | "
-	  << "\"" << Vmakeinfo_prog << "\""
+	  << "\"" << Vmakeinfo_program << "\""
 	  << " -D \"VERSION " << OCTAVE_VERSION << "\""
 	  << " -D \"OCTAVEHOME " << OCTAVE_PREFIX << "\""
 	  << " -D \"TARGETHOSTTYPE " << OCTAVE_CANONICAL_HOST_TYPE << "\""
 	  << " --fill-column " << cols
 	  << " --no-warn"
 	  << " --no-validate"
 	  << " --no-headers"
 	  << " --force"
@@ -873,20 +871,20 @@ builtin_help (int argc, const string_vec
 }
 
 DEFCMD (help, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} help\n\
 Octave's @code{help} command can be used to print brief usage-style\n\
 messages, or to display information directly from an on-line version of\n\
 the printed manual, using the GNU Info browser.  If invoked without any\n\
-arguments, @code{help} prints a list of all the available operators,\n\
-functions, and built-in variables.  If the first argument is @code{-i},\n\
-the @code{help} command searches the index of the on-line version of\n\
-this manual for the given topics.\n\
+arguments, @code{help} prints a list of all the available operators\n\
+and functions.  If the first argument is @code{-i}, the @code{help}\n\
+command searches the index of the on-line version of this manual for\n\
+the given topics.\n\
 \n\
 For example, the command @kbd{help help} prints a short message\n\
 describing the @code{help} command, and @kbd{help -i help} starts the\n\
 GNU Info browser at this node in the on-line version of the manual.\n\
 \n\
 Once the GNU Info browser is running, help for using it is available\n\
 using the command @kbd{C-h}.\n\
 @seealso{doc, which, lookfor}\n\
@@ -1843,119 +1841,71 @@ to find related functions that are not p
   else
     {
       error ("lookfor: argument must be a string");
     }
 
   return retval;
 }
 
-static int
-info_file (void)
+DEFUN (info_file, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} info_file ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
+Query or set the internal variable that specifies the name of the\n\
+Octave info file.  The default value is\n\
+@code{\"@var{octave-home}/info/octave.info\"}, in\n\
+which @var{octave-home} is the directory where all of Octave is installed.\n\
+@seealso{info_program, doc, help, makeinfo_program}\n\
+@end deftypefn")
 {
-  int status = 0;
-
-  std::string s = builtin_string_variable ("INFO_FILE");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("INFO_FILE");
-      status = -1;
-    }
-  else
-    Vinfo_file = s;
-
-  return status;
-}
-
-static int
-info_prog (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("INFO_PROGRAM");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("INFO_PROGRAM");
-      status = -1;
-    }
-  else
-    Vinfo_prog = s;
-
-  return status;
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
 }
 
-static int
-makeinfo_prog (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("MAKEINFO_PROGRAM");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("MAKEINFO_PROGRAM");
-      status = -1;
-    }
-  else
-    Vmakeinfo_prog = s;
-
-  return status;
-}
-
-static int
-suppress_verbose_help_message (void)
-{
-  Vsuppress_verbose_help_message
-    = check_preference ("suppress_verbose_help_message");
-
-  return 0;
-}
-
-void
-symbols_of_help (void)
-{
-  DEFVAR (INFO_FILE, Vinfo_file, info_file,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} INFO_FILE\n\
-The variable @code{INFO_FILE} names the location of the Octave info file.\n\
-The default value is @code{\"@var{octave-home}/info/octave.info\"}, in\n\
-which @var{octave-home} is the directory where all of Octave is installed.\n\
-@end defvr");
-
-  DEFVAR (INFO_PROGRAM, Vinfo_prog, info_prog,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} INFO_PROGRAM\n\
-The variable @code{INFO_PROGRAM} names the info program to run.  Its\n\
-default initial value is\n\
+DEFUN (info_program, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} info_program ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} info_program (@var{new_val})\n\
+Query or set the internal variable that specifies the name of the\n\
+info program to run.  The default initial value is\n\
 @code{\"@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info\"}\n\
 in which @var{octave-home} is the directory where all of Octave is\n\
 installed, @var{version} is the Octave version number, and @var{arch}\n\
 is the system type (for example, @code{i686-pc-linux-gnu}).  The\n\
 default initial value may be overridden by the environment variable\n\
 @code{OCTAVE_INFO_PROGRAM}, or the command line argument\n\
-@code{--info-program NAME}, or by setting the value of\n\
-@code{INFO_PROGRAM} in a startup script\n\
-@end defvr");
+@code{--info-program NAME}.\n\
+@seealso{info_file, doc, help, makeinfo_program}\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
+}
 
-  DEFVAR (MAKEINFO_PROGRAM, Vmakeinfo_prog, makeinfo_prog,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} MAKEINFO_PROGRAM\n\
-The variable @code{MAKEINFO_PROGRAM} names the makeinfo program that\n\
-Octave runs to format help text that contains Texinfo markup commands.\n\
-Its default initial value is @code{\"makeinfo\"}.\n\
-@end defvr");
+DEFUN (makeinfo_program, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} makeinfo_program ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
+Query or set the internal variable that specifies the name of the\n\
+makeinfo program that Octave runs to format help text containing\n\
+Texinfo markup commands.  The default initial value is @code{\"makeinfo\"}.\n\
+@seealso{info_file, info_program, doc, help}\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
+}
 
-  DEFVAR (suppress_verbose_help_message, false, suppress_verbose_help_message,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} suppress_verbose_help_message\n\
-If the value of @code{suppress_verbose_help_message} is nonzero, Octave\n\
-will not add additional help information to the end of the output from\n\
+DEFUN (suppress_verbose_help_message, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
+Query or set the internal vaiable that controls whether Octave\n\
+will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -38,17 +38,17 @@ extern void display_help_text (std::ostr
 extern void additional_help_message (std::ostream&);
 
 // Name of the info file specified on command line.
 // (--info-file file)
 extern std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
-extern std::string Vinfo_prog;
+extern std::string Vinfo_program;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -67,38 +67,38 @@ 02110-1301, USA.
 #include "sighandlers.h"
 #include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Primary prompt string.
-static std::string Vps1;
+static std::string VPS1 = "\\s:\\#> ";
 
 // Secondary prompt string.
-static std::string Vps2;
+static std::string VPS2 = "> ";
 
 // String printed before echoed input (enabled by --echo-input).
-std::string Vps4;
+std::string VPS4 = "+ ";
 
 // Echo commands as they are executed?
 //
 //   1  ==>  echo commands read from script files
 //   2  ==>  echo commands from functions
 //   4  ==>  echo commands read from command line
 //
 // more than one state can be active at once.
-int Vecho_executing_commands;
+int Vecho_executing_commands = ECHO_OFF;
 
 // The time we last printed a prompt.
 octave_time Vlast_prompt_time;
 
 // Character to append after successful command-line completion attempts.
-static char Vcompletion_append_char;
+static char Vcompletion_append_char = ' ';
 
 // Global pointer for eval().
 std::string current_eval_string;
 
 // TRUE means get input from current_eval_string.
 bool get_input_from_eval_string = false;
 
 // TRUE means we haven't been asked for the input from
@@ -146,22 +146,22 @@ do_input_echo (const std::string& input_
     (Vecho_executing_commands & ECHO_SCRIPTS)
       : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
 	{
 	  if (promptflag > 0)
-	    octave_stdout << command_editor::decode_prompt_string (Vps1);
+	    octave_stdout << command_editor::decode_prompt_string (VPS1);
 	  else
-	    octave_stdout << command_editor::decode_prompt_string (Vps2);
+	    octave_stdout << command_editor::decode_prompt_string (VPS2);
 	}
       else
-	octave_stdout << command_editor::decode_prompt_string (Vps4);
+	octave_stdout << command_editor::decode_prompt_string (VPS4);
 
       if (! input_string.empty ())
 	{
 	  octave_stdout << input_string;
 
 	  if (input_string[input_string.length () - 1] != '\n')
 	    octave_stdout << "\n";
 	}
@@ -212,17 +212,17 @@ octave_gets (void)
 
   std::string retval;
 
   Vlast_prompt_time.stamp ();
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file || reading_script_file)))
     {
-      std::string ps = (promptflag > 0) ? Vps1 : Vps2;
+      std::string ps = (promptflag > 0) ? VPS1 : VPS2;
 
       std::string prompt = command_editor::decode_prompt_string (ps);
 
       pipe_handler_error_count = 0;
 
       flush_octave_stdout ();
 
       octave_diary << prompt;
@@ -893,46 +893,46 @@ state.\n\
     return retval;
 
   switch (argc)
     {
     case 1:
       {
 	if ((Vecho_executing_commands & ECHO_SCRIPTS)
 	    || (Vecho_executing_commands & ECHO_FUNCTIONS))
-	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
+	  Vecho_executing_commands = ECHO_OFF;
 	else
-	  bind_builtin_variable ("echo_executing_commands", ECHO_SCRIPTS);
+	  Vecho_executing_commands = ECHO_SCRIPTS;
       }
       break;
 
     case 2:
       {
 	std::string arg = argv[1];
 
 	if (arg == "on")
-	  bind_builtin_variable ("echo_executing_commands", ECHO_SCRIPTS);
+	  Vecho_executing_commands = ECHO_SCRIPTS;
 	else if (arg == "off")
-	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
+	  Vecho_executing_commands = ECHO_OFF;
 	else
 	  print_usage ("echo");
       }
       break;
 
     case 3:
       {
 	std::string arg = argv[1];
 
 	if (arg == "on" && argv[2] == "all")
 	  {
 	    int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
-	    bind_builtin_variable ("echo_executing_commands", tmp);
+	    Vecho_executing_commands = tmp;
 	  }
 	else if (arg == "off" && argv[2] == "all")
-	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
+	  Vecho_executing_commands = ECHO_OFF;
 	else
 	  print_usage ("echo");
       }
       break;
 
     default:
       print_usage ("echo");
       break;
@@ -1120,136 +1120,90 @@ and the user data are returned.\n\
 
       hook_fcn = tmp_hook_fcn;
       user_data = tmp_user_data;
     }
 
   return retval;
 }
 
-static int
-ps1 (void)
-{
-  int status = 0;
-
-  Vps1 = builtin_string_variable ("PS1");
-
-  return status;
-}
-
-static int
-ps2 (void)
-{
-  int status = 0;
-
-  Vps2 = builtin_string_variable ("PS2");
-
-  return status;
-}
-
-static int
-ps4 (void)
-{
-  int status = 0;
-
-  Vps4 = builtin_string_variable ("PS4");
-
-  return status;
-}
-
-static int
-completion_append_char (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("completion_append_char");
-
-  switch (s.length ())
-    {
-    case 1:
-      Vcompletion_append_char = s[0];
-      break;
-
-    case 0:
-      Vcompletion_append_char = '\0';
-      break;
-
-    default:
-      warning ("completion_append_char must be a single character");
-      status = -1;
-      break;
-    }
-
-  return status;
-}
-
-static int
-echo_executing_commands (void)
-{
-  Vecho_executing_commands = check_preference ("echo_executing_commands"); 
-
-  return 0;
-}
-
-void
-symbols_of_input (void)
-{
-  DEFVAR (PS1, "\\s:\\#> ", ps1,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} PS1\n\
-The primary prompt string.  When executing interactively, Octave\n\
-displays the primary prompt @code{PS1} when it is ready to read a\n\
-command.\n\
+DEFUN (PS1, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} PS1 ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
+Query or set the primary prompt string.  When executing interactively,\n\
+Octave displays the primary prompt when it is ready to read a command.\n\
 \n\
-The default value of @code{PS1} is @code{\"\\s:\\#> \"}.  To change it, use a\n\
-command like\n\
+The default value of the primary prompt string is @code{\"\\s:\\#> \"}.\n\
+To change it, use a command like\n\
 \n\
 @example\n\
 octave:13> PS1 = \"\\\\u@@\\\\H> \"\n\
 @end example\n\
 \n\
 @noindent\n\
 which will result in the prompt @samp{boris@@kremvax> } for the user\n\
 @samp{boris} logged in on the host @samp{kremvax.kgb.su}.  Note that two\n\
-backslashes are required to enter a backslash into a string.\n\
+backslashes are required to enter a backslash into a double-quoted\n\
+character string.\n\
 @xref{Strings}.\n\
-@end defvr");
+@seealso{PS1, PS2}\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (PS1);
+}
 
-  DEFVAR (PS2, "> ", ps2,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} PS2\n\
-The secondary prompt string, which is printed when Octave is\n\
-expecting additional input to complete a command.  For example, when\n\
-defining a function over several lines, Octave will print the value of\n\
-@code{PS1} at the beginning of each line after the first.  The default\n\
-value of @code{PS2} is @code{\"> \"}.\n\
-@end defvr");
+DEFUN (PS2, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} PS2 ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} PS2 (@var{new_val})\n\
+Query or set the secondary prompt string.  The secondary prompt is\n\
+printed when Octave is expecting additional input to complete a\n\
+command.  For example, if you are typing a for loop that spans several\n\
+lines, Octave will print the secondary prompt at the beginning of\n\
+each line after the first.  The default value of the secondary prompt\n\
+string is @code{\"> \"}.\n\
+@seealso{PS1, PS4}\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (PS2);
+}
 
-  DEFVAR (PS4, "+ ", ps4,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} PS4\n\
-If Octave is invoked with the @code{--echo-commands} option, the value of\n\
-@code{PS4} is printed before each line of input that is echoed.  The\n\
-default value of @code{PS4} is @code{\"+ \"}.  @xref{Invoking Octave}, for\n\
+DEFUN (PS4, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} PS4 ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} PS4 (@var{new_val})\n\
+Query or set the character string used to prefix output produced\n\
+when echoing commands when @code{echo_executing_commands} is enabled.\n\
+The default value is @code{\"+ \"}.  @xref{Invoking Octave}, for\n\
 a description of @code{--echo-commands}.\n\
-@end defvr");
+@seealso{echo_executing_commands, PS1, PS2}\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (PS4);
+}
 
-  DEFVAR (completion_append_char, " ", completion_append_char,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} completion_append_char\n\
-The value of @code{completion_append_char} is used as the character to\n\
-append to successful command-line completion attempts.  The default\n\
+DEFUN (completion_append_char, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} completion_append_char ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} completion_append_char (@var{new_val})\n\
+Query or set the internal character variable that is appended to\n\
+successful command-line completion attempts.  The default\n\
 value is @code{\" \"} (a single space).\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (completion_append_char);
+}
 
-  DEFVAR (echo_executing_commands, ECHO_OFF, echo_executing_commands,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} echo_executing_commands\n\
-This variable may also be used to control the echo state.  It may be\n\
-the sum of the following values:\n\
+DEFUN (echo_executing_commands, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} echo_executing_commands (@var{new_val})\n\
+Query or set the internal variable that controls the echo state.\n\
+It may be the sum of the following values:\n\
 \n\
 @table @asis\n\
 @item 1\n\
 Echo commands read from script files.\n\
 \n\
 @item 2\n\
 Echo commands from functions.\n\
 \n\
@@ -1257,16 +1211,18 @@ Echo commands from functions.\n\
 Echo commands read from command line.\n\
 @end table\n\
 \n\
 More than one state can be active at once.  For example, a value of 3 is\n\
 equivalent to the command @kbd{echo on all}.\n\
 \n\
 The value of @code{echo_executing_commands} is set by the @kbd{echo}\n\
 command and the command line option @code{--echo-input}.\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (echo_executing_commands);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -87,17 +87,17 @@ extern bool octave_completion_matches_ca
 extern std::string gnu_readline (const std::string& s, bool force_readline = false);
 
 extern void initialize_command_input (void);
 
 extern bool octave_yes_or_no (const std::string& prompt);
 
 extern octave_value do_keyboard (const octave_value_list& args = octave_value_list ());
 
-extern std::string Vps4;
+extern std::string VPS4;
 
 enum echo_state
 {
   ECHO_OFF = 0,
   ECHO_SCRIPTS = 1,
   ECHO_FUNCTIONS = 2,
   ECHO_CMD_LINE = 4
 };
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -227,22 +227,16 @@ private:
 };
 
 const int bracket_brace_paren_nesting_level::BRACKET = 1;
 const int bracket_brace_paren_nesting_level::BRACE = 2;
 const int bracket_brace_paren_nesting_level::PAREN = 3;
 
 static bracket_brace_paren_nesting_level nesting_level;
 
-static bool Vwarn_matlab_incompatible = false;
-
-static bool Vwarn_separator_insert = false;
-
-static bool Vwarn_single_quote_string = false;
-
 static unsigned int Vtoken_count = 0;
 
 // Forward declarations for functions defined at the bottom of this
 // file.
 
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_keyword_token (const std::string& s);
@@ -2476,48 +2470,47 @@ is omitted, return a list of keywords.\n
 }
 
 
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
-  if (Vwarn_separator_insert)
-    {
-      if (nm.empty ())
-	warning ("potential auto-insertion of `%c' near line %d",
-		 sep, input_line_number);
-      else
-	warning ("potential auto-insertion of `%c' near line %d of file %s",
-		 sep, input_line_number, nm.c_str ());
-    }
+  if (nm.empty ())
+    warning_with_id ("Octave:separator-insert",
+		     "potential auto-insertion of `%c' near line %d",
+		     sep, input_line_number);
+  else
+    warning_with_id ("Octave:separator-insert",
+		     "potential auto-insertion of `%c' near line %d of file %s",
+		     sep, input_line_number, nm.c_str ());
 }
 
 static void
 gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
-  if (Vwarn_single_quote_string)
-    {
-      if (nm.empty ())
-	warning ("single quote delimited string near line %d",
-		 input_line_number);
-      else
-	warning ("single quote delimited string near line %d of file %s",
-		 input_line_number, nm.c_str ());
-    }
+  if (nm.empty ())
+    warning_with_id ("Octave:single-quote-string",
+		     "single quote delimited string near line %d",
+		     input_line_number);
+  else
+    warning_with_id ("Octave:single-quote-string",
+		     "single quote delimited string near line %d of file %s",
+		     input_line_number, nm.c_str ());
 }
 
 static void
 gripe_matlab_incompatible (const std::string& msg)
 {
-  if (Vwarn_matlab_incompatible)
-    warning ("potential Matlab compatibility problem: %s", msg.c_str ());
+  warning_with_id ("Octave:matlab-incompatible",
+		   "potential Matlab compatibility problem: %s",
+		   msg.c_str ());
 }
 
 static void
 maybe_gripe_matlab_incompatible_comment (char c)
 {
   if (c == '#')
     gripe_matlab_incompatible ("# used as comment character");
 }
@@ -2542,62 +2535,13 @@ DEFUN (__token_count__, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __token_count__\n\
 Number of language tokens processed since Octave startup.\n\
 @end deftypefn")
 {
   return octave_value (Vtoken_count);
 }
 
-static int
-warn_matlab_incompatible (void)
-{
-  Vwarn_matlab_incompatible = check_preference ("warn_matlab_incompatible");
-
-  return 0;
-}
-
-static int
-warn_separator_insert (void)
-{
-  Vwarn_separator_insert = check_preference ("warn_separator_insert");
-
-  return 0;
-}
-
-static int
-warn_single_quote_string (void)
-{
-  Vwarn_single_quote_string = check_preference ("warn_single_quote_string");
-
-  return 0;
-}
-
-void
-symbols_of_lex (void)
-{
-  DEFVAR (warn_matlab_incompatible, false, warn_matlab_incompatible,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_matlab_incompatible\n\
-Print warnings for Octave language features that may cause\n\
-compatibility problems with Matlab.\n\
-@end defvr");
-
-  DEFVAR (warn_separator_insert, false, warn_separator_insert,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_separator_insert\n\
-Print warning if commas or semicolons might be inserted\n\
-automatically in literal matrices.\n\
-@end defvr");
-
-  DEFVAR (warn_single_quote_string, false, warn_single_quote_string,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_single_quote_string\n\
-Print warning if a signle quote character is used to introduce a\n\
-string constant.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -81,36 +81,48 @@ 02110-1301, USA.
 #include "ls-oct-ascii.h"
 #include "ls-oct-binary.h"
 
 #ifdef HAVE_ZLIB
 #include "zfstream.h"
 #endif
 
 // Write octave-core file if Octave crashes or is killed by a signal.
-static bool Vcrash_dumps_octave_core;
+static bool Vcrash_dumps_octave_core = true;
 
 // The maximum amount of memory (in kilobytes) that we will attempt to
 // write to the Octave core file.
-static double Voctave_core_file_limit;
+static double Voctave_core_file_limit = -1.0;
 
 // The name of the Octave core file.
-static std::string Voctave_core_file_name;
+static std::string Voctave_core_file_name = "octave-core";
 
 // The default output format.  May be one of "binary", "text",
 // "mat-binary", or "hdf5".
-static std::string Vdefault_save_options;
+static std::string Vdefault_save_options = "-text";
 
 // The output format for Octave core files.
-static std::string Voctave_core_file_options;
+static std::string Voctave_core_file_options = "-binary";
+
+static std::string
+default_save_header_format (void)
+{
+  return
+    std::string ("# Created by Octave " OCTAVE_VERSION
+		 ", %a %b %d %H:%M:%S %Y %Z <")
+    + octave_env::get_user_name ()
+    + std::string ("@")
+    + octave_env::get_host_name ()
+    + std::string (">");
+}
 
 // The format string for the comment line at the top of text-format
 // save files.  Passed to strftime.  Should begin with `#' and contain
 // no newline characters.
-static std::string Vsave_header_format_string;
+static std::string Vsave_header_format_string = default_save_header_format ();
 
 static void
 gripe_file_open (const std::string& fcn, const std::string& file)
 {
   if (fcn == "load")
     error ("%s: unable to open input file `%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
     error ("%s: unable to open output file `%s'", fcn.c_str (), file.c_str ());
@@ -1041,21 +1053,20 @@ do_save (std::ostream& os, symbol_record
       int global = sr->is_linked_to_global ();
 
       do_save (os, tc, name, help, global, fmt, save_as_floats,
 	       infnan_warned);
     }
 }
 
 // Save variables with names matching PATTERN on stream OS in the
-// format specified by FMT.  If SAVE_BUILTINS is TRUE, also save
-// builtin variables with names that match PATTERN.
+// format specified by FMT.
 
 static int
-save_vars (std::ostream& os, const std::string& pattern, bool save_builtins,
+save_vars (std::ostream& os, const std::string& pattern,
 	   load_save_format fmt, bool save_as_floats)
 {
   Array<symbol_record *> vars = curr_sym_tab->glob
     (pattern, symbol_record::USER_VARIABLE, SYMTAB_ALL_SCOPES);
 
   int saved = vars.length ();
 
   bool infnan_warned = false;
@@ -1063,42 +1074,23 @@ save_vars (std::ostream& os, const std::
   for (int i = 0; i < saved; i++)
     {
       do_save (os, vars(i), fmt, save_as_floats, infnan_warned);
 
       if (error_state)
 	break;
     }
 
-  if (! error_state && save_builtins)
-    {
-      vars = fbi_sym_tab->glob
-	(pattern, symbol_record::BUILTIN_VARIABLE, SYMTAB_ALL_SCOPES);
-
-      int count = vars.length ();
-
-      saved += count;
-
-      for (int i = 0; i < count; i++)
-	{
-	  do_save (os, vars(i), fmt, save_as_floats, infnan_warned);
-
-	  if (error_state)
-	    break;
-	}
-    }
-
   return saved;
 }
 
 static int
 parse_save_options (const string_vector &argv, int argc, 
 		    load_save_format &format, bool &append,
-		    bool &save_as_floats, bool &save_builtins,
-		    bool &use_zlib, int start_arg)
+		    bool &save_as_floats, bool &use_zlib, int start_arg)
 {
   int i;
   for (i = start_arg; i < argc; i++)
     {
       if (argv[i] == "-append")
 	{
 	  append = true;
 	}
@@ -1154,52 +1146,48 @@ parse_save_options (const string_vector 
 	{
 #ifdef HAVE_HDF5
 	  format = LS_HDF5;
 	  save_as_floats = true;
 #else /* ! HAVE_HDF5 */
 	  error ("save: octave executable was not linked with HDF5 library");
 #endif /* ! HAVE_HDF5 */
 	}
-      else if (argv[i] == "-save-builtins")
-	{
-	  save_builtins = true;
-	}
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-zip" || argv[i] == "-z")
 	{
 	  use_zlib  = true;
 	}
 #endif
       else
 	break;
     }
 
   return i;
 }
 
 static int
 parse_save_options (const std::string &arg, load_save_format &format, 
 		    bool &append, bool &save_as_floats, 
-		    bool &save_builtins, bool &use_zlib, int start_arg)
+		    bool &use_zlib, int start_arg)
 {
   std::istringstream is (arg);
   std::string str;
   int argc = 0;
   string_vector argv;
   
   while (! is.eof ())
     {
       is >> str;
       argv.append (str);
       argc++;
     }
 
   return parse_save_options (argv, argc, format, append, save_as_floats, 
-			     save_builtins, use_zlib, start_arg);
+			     use_zlib, start_arg);
 }
 
 void
 write_header (std::ostream& os, load_save_format format)
 {
   switch (format)
     {
     case LS_BINARY:
@@ -1276,31 +1264,31 @@ write_header (std::ostream& os, load_sav
 
     default:
       break;
     }
 }
 
 static void
 save_vars (const string_vector& argv, int argv_idx, int argc,
-	   std::ostream& os, bool save_builtins, load_save_format fmt,
+	   std::ostream& os, load_save_format fmt,
 	   bool save_as_floats, bool write_header_info)
 {
   if (write_header_info)
     write_header (os, fmt);
 
   if (argv_idx == argc)
     {
-      save_vars (os, "*", save_builtins, fmt, save_as_floats);
+      save_vars (os, "*", fmt, save_as_floats);
     }
   else
     {
       for (int i = argv_idx; i < argc; i++)
 	{
-	  if (! save_vars (os, argv[i], save_builtins, fmt, save_as_floats))
+	  if (! save_vars (os, argv[i], fmt, save_as_floats))
 	    {
 	      warning ("save: no such variable `%s'", argv[i].c_str ());
 	    }
 	}
     }
 }
 
 static void
@@ -1364,27 +1352,24 @@ dump_octave_core (void)
       // FIXME -- should choose better file name?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
       message (0, "attempting to save variables to `%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
-      bool save_builtins = false;
-
       bool save_as_floats = false;
 
       bool append = false;
 
       bool use_zlib = false;
 
-      // Note save_builtins is ignored
       parse_save_options (Voctave_core_file_options, format, append, 
-			  save_as_floats, save_builtins, use_zlib, 0);
+			  save_as_floats, use_zlib, 0);
   
       std::ios::openmode mode = std::ios::out;
 
       if (format == LS_BINARY
 #ifdef HAVE_HDF5
 	  || format == LS_HDF5
 #endif
 	  || format == LS_MAT_BINARY
@@ -1456,18 +1441,18 @@ the zlib library."
 DEFCMD (save, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} save options file @var{v1} @var{v2} @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{} in the file\n\
 @var{file}.  The special filename @samp{-} can be used to write the\n\
 output to your terminal.  If no variable names are listed, Octave saves\n\
 all the variables in the current scope.  Valid options for the\n\
 @code{save} command are listed in the following table.  Options that\n\
-modify the output format override the format specified by the built-in\n\
-variable @code{default_save_options}.\n\
+modify the output format override the format specified by\n\
+@code{default_save_options}.\n\
 \n\
 If save is invoked using the functional form\n\
 \n\
 @example\n\
 save (\"-text\", \"file.txt\", \"a\")\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -1521,20 +1506,16 @@ Center for Supercomputing Applications a
 HAVE_HDF5_HELP_STRING
 
 "\n\
 @item -float-hdf5\n\
 Save the data in HDF5 format but only using single precision.\n\
 You should use this format only if you know that all the\n\
 values to be saved can be represented in single precision.\n\
 \n\
-@item -save-builtins\n\
-Force Octave to save the values of built-in variables too.  By default,\n\
-Octave does not save built-in variables.\n\
-\n\
 @item -zip\n\
 @itemx -z\n\
 Use the gzip algorithm to compress the file. This works equally on files that\n\
 are compressed with gzip outside of octave, and gzip can equally be used to\n\
 convert the files for backward compatibility.\n"
 
 HAVE_ZLIB_HELP_STRING
 
@@ -1582,39 +1563,37 @@ the file @file{data} in Octave's binary 
   string_vector argv = args.make_argv ("save");
 
   if (error_state)
     return retval;
 
   // Here is where we would get the default save format if it were
   // stored in a user preference variable.
 
-  bool save_builtins = false;
-
   bool save_as_floats = false;
 
   load_save_format format = LS_ASCII;
 
   bool append = false;
 
   bool use_zlib = false;
 
   load_save_format user_file_format = LS_UNKNOWN;
   bool dummy;
 
   // Get user file format
   parse_save_options (argv, argc, user_file_format, dummy, 
-		      dummy, dummy, dummy, 1);
+		      dummy, dummy, 1);
 
   if (user_file_format == LS_UNKNOWN)
     parse_save_options (Vdefault_save_options, format, append, save_as_floats, 
-			save_builtins, use_zlib, 0);
+			use_zlib, 0);
 
   int i = parse_save_options (argv, argc, format, append, save_as_floats, 
-			  save_builtins, use_zlib, 1);
+			      use_zlib, 1);
 
   if (error_state)
     return retval;
 
   if (i == argc)
     {
       print_usage ("save");
       return retval;
@@ -1636,17 +1615,17 @@ the file @file{data} in Octave's binary 
       else
 #endif /* HAVE_HDF5 */
 	// don't insert any commands here!  the brace below must go
 	// with the "else" above!
 	{
 	  // FIXME -- should things intended for the screen end up
 	  // in a octave_value (string)?
 	  
-	  save_vars (argv, i, argc, octave_stdout, save_builtins, format,
+	  save_vars (argv, i, argc, octave_stdout, format,
 		     save_as_floats, true);
 	}
     }
 
   // Guard against things like `save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     {
@@ -1674,17 +1653,17 @@ the file @file{data} in Octave's binary 
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
 	{
 	  hdf5_ofstream hdf5_file (fname.c_str ());
 
 	  if (hdf5_file.file_id >= 0)
 	    {
-	      save_vars (argv, i, argc, hdf5_file, save_builtins, format,
+	      save_vars (argv, i, argc, hdf5_file, format,
 			 save_as_floats, true);
 
 	      hdf5_file.close ();
 	  }
 	else
 	  {
 	    gripe_file_open ("save", fname);
 	    return retval;
@@ -1701,17 +1680,17 @@ the file @file{data} in Octave's binary 
 	      gzofstream file (fname.c_str (), mode);
 
 	      if (file)
 		{
 		  bool write_header_info
 		    = ((file.rdbuf ())->pubseekoff (0, std::ios::cur)
 		       == static_cast<std::streampos> (0));
 	      
-		  save_vars (argv, i, argc, file, save_builtins, format,
+		  save_vars (argv, i, argc, file, format,
 			     save_as_floats, write_header_info);
 
 		  file.close ();
 		}
 	      else
 		{
 		  gripe_file_open ("save", fname);
 		  return retval;
@@ -1723,211 +1702,125 @@ the file @file{data} in Octave's binary 
 	      std::ofstream file (fname.c_str (), mode);
 	  
 	      if (file)
 		{
 		  bool write_header_info
 		    = ((file.rdbuf ())->pubseekoff (0, std::ios::cur)
 		       == static_cast<std::streampos> (0));
 	      
-		  save_vars (argv, i, argc, file, save_builtins, format,
+		  save_vars (argv, i, argc, file, format,
 			     save_as_floats, write_header_info);
 
 		  file.close ();
 		}
 	      else
 		{
 		  gripe_file_open ("save", fname);
 		  return retval;
 		}
 	    }
 	}
     }
 
   return retval;
 }
 
-static int
-crash_dumps_octave_core (void)
-{
-  Vcrash_dumps_octave_core = check_preference ("crash_dumps_octave_core");
-
-  return 0;
-}
-
-static int
-default_save_options (void)
+DEFUN (crash_dumps_octave_core, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave tries\n\
+to save all current variables the the file \"octave-core\" if it\n\
+crashes or receives a hangup, terminate or similar signal.\n\
+@seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
+@end deftypefn")
 {
-  int status = 0;
-
-  std::string s = builtin_string_variable ("default_save_options");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("default_save_options");
-      status = -1;
-    }
-  else
-    Vdefault_save_options = s;
-
-  return status;
+  return SET_INTERNAL_VARIABLE (crash_dumps_octave_core);
 }
 
-static int
-octave_core_file_limit (void)
-{
-  double val;
-
-  if (builtin_real_scalar_variable ("octave_core_file_limit", val))
-    {
-      Voctave_core_file_limit = val;
-      return 0;
-    }
-  else
-    gripe_invalid_value_specified ("octave_core_file_limit");
-
-  return -1;
-}
-
-static int
-octave_core_file_name (void)
+DEFUN (default_save_options, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} default_save_options ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} default_save_options (@var{new_val})\n\
+Query or set the internal variable that specifies the default options\n\
+for the @code{save} command, and defines the default format.\n\
+Typical values include @code{\"-ascii\"}, @code{\"-ascii -zip\"}.\n\
+The default value is @code{-ascii}.\n\
+@seealso{save}\n\
+@end deftypefn")
 {
-  int status = 0;
-
-  std::string s = builtin_string_variable ("octave_core_file_name");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("octave_core_file_name");
-      status = -1;
-    }
-  else
-    Voctave_core_file_name = s;
-
-  return status;
-}
-
-static int
-octave_core_file_options (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("octave_core_file_options");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("octave_core_file_options");
-      status = -1;
-    }
-  else
-    Voctave_core_file_options = s;
-
-  return status;
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (default_save_options);
 }
 
-static std::string
-default_save_header_format (void)
+DEFUN (octave_core_file_limit, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
+Query or set the internal variable that specifies the maximum amount\n\
+of memory (in kilobytes) of the top-level workspace that Octave will\n\
+attempt to save when writing data to the crash dump file (the name of\n\
+the file is specified by @var{octave_core_file_name}).  If\n\
+@var{octave_core_file_options} flags specifies a binary format,\n\
+then @var{octave_core_file_limit} will be approximately the maximum\n\
+size of the file.  If a text file format is used, then the file could\n\
+be much larger than the limit.  The default value is -1 (unlimited)\n\
+@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
+@end deftypefn")
 {
-  return
-    std::string ("# Created by Octave " OCTAVE_VERSION
-		 ", %a %b %d %H:%M:%S %Y %Z <")
-    + octave_env::get_user_name ()
-    + std::string ("@")
-    + octave_env::get_host_name ()
-    + std::string (">");
-}
-
-static int
-save_header_format_string (void)
-{
-  int status = 0;
-
-  octave_value v = builtin_any_variable ("save_header_format_string");
-
-  if (v.is_string ())
-    Vsave_header_format_string = v.string_value ();
-  else
-    {
-      gripe_invalid_value_specified ("save_header_format_string");
-      status = -1;
-    }
-
-  return status;
+  return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
 
-void
-symbols_of_load_save (void)
+DEFUN (octave_core_file_name, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
+Query or set the internal variable that specifies the name of the file\n\
+used for saving data from the top-level workspace if Octave aborts.\n\
+The default value is @code{\"octave-core\"}\n\
+@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
+@end deftypefn")
 {
-  DEFVAR (crash_dumps_octave_core, true, crash_dumps_octave_core,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} crash_dumps_octave_core\n\
-If this variable is set to a nonzero value, Octave tries to save all\n\
-current variables the the file \"octave-core\" if it crashes or receives a\n\
-hangup, terminate or similar signal.  The default value is 1.\n\
-@seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
-@end defvr");
-
-  DEFVAR (default_save_options, "-text", default_save_options,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} default_save_options\n\
-This variable specifies the default options for the @code{save} command,\n\
-and is used to define the default format. Typical values include,\n\
-@code{\"-ascii\"}, @code{\"-ascii -zip\"}. For other possible options\n\
-see the @code{save} command. The initial value of this variable is\n\
-@code{-ascii}.\n\
-@end defvr");
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
+}
 
-  DEFVAR (octave_core_file_limit, -1.0, octave_core_file_limit,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} octave_core_file_limit\n\
-The maximum amount of memory (in kilobytes) of the top-level workspace\n\
-that Octave will attempt to write when saving data to the\n\
-@var{octave_core_file_name}.  If @var{octave_core_file_options} flags a\n\
-binary format, then @var{octave_core_file_limit} will be approximately\n\
-the maximum size of the file.  If a text file format is used, then the\n\
-file could be much larger than the limit.\n\
-The default value is -1 (unlimited)\n\
-@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
-@end defvr");
-
-  DEFVAR (octave_core_file_name, "octave-core", octave_core_file_name,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} octave_core_file_name\n\
-The name of the file used for saving data from the top-level workspace\n\
-when Octave aborts.  The default value is @code{\"octave-core\"}\n\
-@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
-@end defvr");
-
-  DEFVAR (octave_core_file_options, "-binary", octave_core_file_options,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} octave_core_file_options\n\
-If Octave aborts, it attempts to save the contents of the top-level\n\
-workspace in a file using this variable to define the format. The value of\n\
-@code{octave_core_file_options} should follow the same format as the options\n\
-that may be used with @code{save}. The default value is Octave's binary\n\
+DEFUN (octave_core_file_options, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} octave_core_file_options ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
+Query or set the internal variable that specifies the options used for\n\
+saving the workspace data if Octave aborts.  The value of\n\
+@code{octave_core_file_options} should follow the same format as the\n\
+options for the @code{save} function. The default value is Octave's binary\n\
 format.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_options);
+}
 
-  DEFVAR (save_header_format_string, default_save_header_format (),
-	  save_header_format_string,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} save_header_format_string\n\
-This variable specifies the the format string for the comment line\n\
-that is written at the beginning of text-format data files saved by\n\
-Octave.  The format string is passed to @code{strftime} and should\n\
-begin with the character @samp{#} and contain no newline characters.\n\
-If the value of @code{save_header_format_string} is the empty string,\n\
+DEFUN (save_header_format_string, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} save_header_format_string ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} save_header_format_string (@var{new_val})\n\
+Query or set the internal variable that specifies the format\n\
+string used for the comment line written at the beginning of\n\
+text-format data files saved by Octave.  The format string is\n\
+passed to @code{strftime} and should begin with the character\n\
+@samp{#} and contain no newline characters.  If the value of\n\
+@code{save_header_format_string} is the empty string,\n\
 the header comment is omitted from text-format data files.  The\n\
 default value is\n\
 \n\
 @example\n\
 \"# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end example\n\
 @seealso{strftime}\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (save_header_format_string);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -63,17 +63,17 @@ 02110-1301, USA.
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-oct-ascii.h"
 
 // The number of decimal digits to use when writing ascii data.
-static int Vsave_precision;
+static int Vsave_precision = 15;
 
 // Functions for reading ascii data.
 
 static Matrix
 strip_infnan (const Matrix& m)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
@@ -443,43 +443,25 @@ save_three_d (std::ostream& os, const oc
     {
       ::error ("for now, I can only save real matrices in 3D format");
       fail = true;
     }
 
   return (os && ! fail);
 }
 
-static int
-save_precision (void)
+DEFUN (save_precision, args, nargout,
+    "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} save_precision ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
+Query or set the internal variable that specifies the number of\n\
+digits to keep when saving data in text format.\n\
+@end deftypefn")
 {
-  double val;
-  if (builtin_real_scalar_variable ("save_precision", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && ival == val)
-	{
-	  Vsave_precision = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("save_precision");
-  return -1;
-}
-
-void
-symbols_of_ls_oct_ascii (void)
-{
-  DEFVAR (save_precision, 15.0, save_precision,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} save_precision\n\
-This variable specifies the number of digits to keep when saving data in\n\
-text format.  The default value is 17.\n\
-@end defvr");
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1, INT_MAX);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
 
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -1,30 +1,24 @@
 #!/bin/sh
 
-if test $# -ne 2; then
-  echo "usage: mkbuiltins f1 f2" 1>&2
+if test $# -ne 1; then
+  echo "usage: mkbuiltins f1" 1>&2
   exit 1
 fi
 
 SED=${SED:-'sed'}
 
 DEF_FILES=`cat $1`
-VAR_FILES=`cat $2`
 
 if test -z "$DEF_FILES"; then
   echo "mkbuiltins: DEF_FILES is empty!" 1>&2
   exit 1
 fi
 
-if test -z "$VAR_FILES"; then
-  echo "mkbuiltins: VAR_FILES is empty!" 1>&2
-  exit 1
-fi
-
 cat << \EOF
 // DO NOT EDIT!  Generated automatically by mkbuiltins.
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "defun.h"
@@ -54,18 +48,16 @@ cat << \EOF
 #define XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
 			 is_text_fcn, doc) \
   extern DECLARE_FUNX (fname, args_name, nargout_name); \
   install_builtin_function (fname, name, doc, is_text_fcn); \
 
 #define XDEFALIAS_INTERNAL(alias, name) \
   alias_builtin (#alias, #name);
 
-#define XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc)
-
 #define XDEFCONST_INTERNAL(name, defn, doc)
 
 #define XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			       d_c_map, c_c_map, lo, hi, \
 			       ch_map_flag, can_ret_cmplx_for_real, doc)
 
 EOF
 
@@ -74,37 +66,19 @@ for file in $DEF_FILES; do
   echo "static void"
   echo "install_${fcn}_fcns (void)"
   echo "{"
   cat $file
   echo "}"
   echo ""
 done
 
-for file in $VAR_FILES; do
-  f=`echo $file | $SED 's,^\./,,; s/\.df//; s/-/_/g'`
-  echo "extern void symbols_of_${f} (void);"
-done
-
 cat << \EOF
 
 static void
-install_builtin_variables (void)
-{
-EOF
-
-for file in $VAR_FILES; do
-  f=`echo $file | $SED 's,^\./,,; s/\.df//; s/-/_/g'`
-  echo "  symbols_of_${f} ();"
-done
-
-cat << \EOF
-}
-
-static void
 install_builtin_functions (void)
 {
 EOF
 
 for file in $DEF_FILES; do
   fcn=`echo $file | $SED 's,^\./,,; s/\.df//; s/-/_/g'`
   echo "  install_${fcn}_fcns ();"
 done
@@ -112,15 +86,14 @@ done
 cat << \EOF
 }
 
 extern void install_mapper_functions (void);
 
 void
 install_builtins (void)
 {
-  install_builtin_variables ();
   install_mapper_functions ();
   install_builtin_functions ();
 }
 EOF
 
 exit 0
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -71,32 +71,16 @@ Software Foundation, Inc.
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means input is coming from temporary history file.
 bool input_from_tmp_history_file = false;
 
-// Where history is saved.
-static std::string Vhistory_file;
-
-// The number of lines to keep in the history file.
-static int Vhistory_size;
-
-// The format of the timestamp marker written to the history file when
-// Octave exits.
-static std::string Vhistory_timestamp_format_string;
-
-// TRUE if we are saving history.
-bool Vsaving_history = true;
-
-// Get some default values, possibly reading them from the
-// environment.
-
 static std::string
 default_history_file (void)
 {
   std::string file;
 
   std::string env_file = octave_env::getenv ("OCTAVE_HISTFILE");
 
   if (! env_file.empty ())
@@ -121,16 +105,19 @@ default_history_file (void)
 	}
       else
 	file = ".octave_hist";
     }
 
   return file;
 }
 
+// Where history is saved.
+static std::string Vhistory_file = default_history_file ();
+
 static int
 default_history_size (void)
 {
   int size = 1024;
 
   std::string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
@@ -139,27 +126,38 @@ default_history_size (void)
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
 	size = val > 0 ? val : 0;
     }
 
   return size;
 }
 
+// The number of lines to keep in the history file.
+static int Vhistory_size = default_history_size ();
+
 static std::string
 default_history_timestamp_format (void)
 {
   return
     std::string ("# Octave " OCTAVE_VERSION ", %a %b %d %H:%M:%S %Y %Z <")
     + octave_env::get_user_name ()
     + std::string ("@")
     + octave_env::get_host_name ()
     + std::string (">");
 }
 
+// The format of the timestamp marker written to the history file when
+// Octave exits.
+static std::string Vhistory_timestamp_format_string
+  = default_history_timestamp_format ();
+
+// TRUE if we are saving history.
+bool Vsaving_history = true;
+
 // Display, save, or load history.  Stolen and modified from bash.
 //
 // Arg of -w FILENAME means write file, arg of -r FILENAME
 // means read file, arg of -q means don't number lines.  Arg of N
 // means only display that many items. 
 
 static void
 do_history (int argc, const string_vector& argv)
@@ -451,17 +449,17 @@ do_edit_history (int argc, const string_
 {
   std::string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
   if (name.empty ())
     return;
 
   // Call up our favorite editor on the file of commands.
 
-  std::string cmd = Veditor;
+  std::string cmd = VEDITOR;
   cmd.append (" \"");
   cmd.append (name);
   cmd.append ("\"");
 
   // Ignore interrupts while we are off editing commands.  Should we
   // maybe avoid using system()?
 
   volatile octave_interrupt_handler old_interrupt_handler
@@ -546,16 +544,24 @@ do_run_history (int argc, const string_v
   // Delete the temporary file.
 
   // FIXME -- should probably be done using an unwind_protect.
 
   unlink (name.c_str ());
 }
 
 void
+initialize_history (void)
+{
+  command_history::set_file (file_ops::tilde_expand (Vhistory_file));
+  
+  command_history::read (false);
+}
+
+void
 octave_history_write_timestamp (void)
 {
   octave_localtime now;
 
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
 
   if (! timestamp.empty ())
     command_history::add (timestamp);
@@ -670,126 +676,81 @@ and the commands are simply executed as 
   if (error_state)
     return retval;
 
   do_run_history (argc, argv);
 
   return retval;
 }
 
-static int
-history_size (void)
+DEFUN (history_size, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} history_size ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
+Query or set the internal variable that specifies how many entries\n\
+to store in the history file.  The default value is @code{1024},\n\
+but may be overridden by the environment variable @code{OCTAVE_HISTSIZE}.\n\
+@seealso{history_file, history_timestamp_format, saving_history}\n\
+@end deftypefn")
 {
-  double val;
-  if (builtin_real_scalar_variable ("history_size", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && ival == val)
-	{
-	  Vhistory_size = ival;
-	  command_history::set_size (ival);
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("history_size");
-  return -1;
-}
-
-static int
-history_file (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("history_file");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("history_file");
-      status = -1;
-    }
-  else
-    {
-      Vhistory_file = s;
-      command_history::set_file (file_ops::tilde_expand (s));
-    }
-
-  return status;
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (history_size, -1, INT_MAX);
 }
 
-static int
-history_timestamp_format_string (void)
+DEFUN (history_file, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} history_file ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} history_file (@var{new_val})\n\
+Query or set the internal variable that specifies the name of the\n\
+file used to store command history.  The default value is\n\
+@code{\"~/.octave_hist\"}, but may be overridden by the environment\n\
+variable @code{OCTAVE_HISTFILE}.\n\
+@seealso{history_size, saving_history, history_timestamp_format_string}\n\
+@end deftypefn")
 {
-  int status = 0;
-
-  octave_value v = builtin_any_variable ("history_timestamp_format_string");
+  std::string saved_history_file = Vhistory_file;
 
-  if (v.is_string ())
-    Vhistory_timestamp_format_string = v.string_value ();
-  else
-    {
-      gripe_invalid_value_specified ("history_timestamp_format_string");
-      status = -1;
-    }
+  octave_value retval = SET_INTERNAL_VARIABLE (history_file);
 
-  return status;
-}
+  if (Vhistory_file != saved_history_file)
+    command_history::set_file (file_ops::tilde_expand (Vhistory_file));
 
-static int
-saving_history (void)
-{
-  Vsaving_history = check_preference ("saving_history");
-
-  command_history::ignore_entries (! Vsaving_history);
-
-  return 0;
+  return retval;;
 }
 
-void
-symbols_of_oct_hist (void)
-{
-  DEFVAR (history_file, default_history_file (), history_file,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} history_file\n\
-This variable specifies the name of the file used to store command\n\
-history.  The default value is @code{\"~/.octave_hist\"}, but may be\n\
-overridden by the environment variable @code{OCTAVE_HISTFILE}.\n\
-@end defvr");
-
-  double tmp_hist_size = default_history_size ();
-
-  DEFVAR (history_size, tmp_hist_size, history_size,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} history_size\n\
-This variable specifies how many entries to store in the history file.\n\
-The default value is @code{1024}, but may be overridden by the\n\
-environment variable @code{OCTAVE_HISTSIZE}.\n\
-@end defvr");
-
-  DEFVAR (history_timestamp_format_string,
-	  default_history_timestamp_format (),
-	  history_timestamp_format_string,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} history_timestamp_format_string\n\
-This variable specifies the the format string for the comment line\n\
-that is written to the history file when Octave exits.  The format\n\
-string is passed to @code{strftime}.  The default value is\n\
+DEFUN (history_timestamp_format_string, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
+Query or set the internal variable that specifies the the format string\n\
+for the comment line that is written to the history file when Octave\n\
+exits.  The format string is passed to @code{strftime}.  The default\n\
+value is\n\
 \n\
 @example\n\
 \"# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end example\n\
-@seealso{strftime}\n\
-@end defvr");
+@seealso{strftime, history_file, history_size, saving_history}\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (history_timestamp_format_string);
+}
 
-  DEFVAR (saving_history, true, saving_history,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} saving_history\n\
-If the value of @code{saving_history} is nonzero, command entered\n\
-on the command line are saved in the file specified by the variable\n\
-@code{history_file}.\n\
-@end defvr");
+DEFUN (saving_history, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} saving_history ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} saving_history (@var{new_val})\n\
+Query or set the internal variable that controls whether commands entered\n\
+on the command line are saved in the history file.\n\
+@seealso{history_file, history_size, history_timestamp_format}.\n\
+@end deftypefn")
+{
+  octave_value retval = SET_INTERNAL_VARIABLE (saving_history);
+
+  command_history::ignore_entries (! Vsaving_history);
+
+  return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -23,16 +23,18 @@ 02110-1301, USA.
 
 #if !defined (octave_octave_hist_h)
 #define octave_octave_hist_h 1
 
 #include <string>
 
 #include "cmd-hist.h"
 
+extern void initialize_history (void);
+
 // Write timestamp to history file.
 extern void octave_history_write_timestamp (void);
 
 // TRUE means input is coming from temporary history file.
 extern bool input_from_tmp_history_file;
 
 // TRUE if we are saving history.
 extern bool Vsaving_history;
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -41,19 +41,16 @@ 02110-1301, USA.
 #include "oct-procbuf.h"
 #include "oct-syscalls.h"
 #include "variables.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "utils.h"
 
-// Number of microseconds to delay in the parent after forking.
-static int Vkluge_procbuf_delay = 0;
-
 // This class is based on the procbuf class from libg++, written by
 // Per Bothner, Copyright (C) 1993 Free Software Foundation.
 
 static octave_procbuf *octave_procbuf_list = 0;
 
 #if defined (__CYGWIN__)
 #define W32POPEN popen
 #define W32PCLOSE pclose
@@ -136,19 +133,16 @@ octave_procbuf::open (const char *comman
 	  octave_procbuf_list = octave_procbuf_list->next;
 	}
 
       execl ("/bin/sh", "sh", "-c", command, static_cast<void *> (0));
 
       exit (127);
     }
 
-  if (Vkluge_procbuf_delay > 0)
-    octave_usleep (Vkluge_procbuf_delay);
-
   ::close (child_end);
 
   if (proc_pid < 0)
     {
       ::close (parent_end);
       return 0;
     }
 
@@ -228,42 +222,13 @@ octave_procbuf::close (void)
 
 #else
 
   return 0;
 
 #endif
 }
 
-static int
-kluge_procbuf_delay (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("__kluge_procbuf_delay__", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && static_cast<double> (ival) == val)
-	{
-	  Vkluge_procbuf_delay = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("__kluge_procbuf_delay__");
-  return -1;
-}
-
-void
-symbols_of_oct_procbuf (void)
-{
-  DEFVAR (__kluge_procbuf_delay__, Vkluge_procbuf_delay, kluge_procbuf_delay,
-    "-*- texinfo -*-\n\
-@defvr __kluge_procbuf_delay__\n\
-Number of microseconds to delay in the parent after forking.\n\
-@end defvr");
-
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -473,27 +473,27 @@ initialize_error_handlers ()
 
 // What happens on --traditional.
 
 static void
 maximum_braindamage (void)
 {
   persist = true;
 
-  bind_builtin_variable ("PS1", ">> ");
-  bind_builtin_variable ("PS2", "");
-  bind_builtin_variable ("beep_on_error", true);
-  bind_builtin_variable ("crash_dumps_octave_core", false);
-  bind_builtin_variable ("default_save_options", "-mat-binary");
-  bind_builtin_variable ("fixed_point_format", true);
-  bind_builtin_variable ("history_timestamp_format_string",
+  bind_internal_variable ("PS1", ">> ");
+  bind_internal_variable ("PS2", "");
+  bind_internal_variable ("beep_on_error", true);
+  bind_internal_variable ("crash_dumps_octave_core", false);
+  bind_internal_variable ("default_save_options", "-mat-binary");
+  bind_internal_variable ("fixed_point_format", true);
+  bind_internal_variable ("history_timestamp_format_string",
 			 "%%-- %D %I:%M %p --%%");
-  bind_builtin_variable ("page_screen_output", false);
-  bind_builtin_variable ("print_empty_dimensions", false);
-  bind_builtin_variable ("warn_function_name_clash", false);
+  bind_internal_variable ("page_screen_output", false);
+  bind_internal_variable ("print_empty_dimensions", false);
+  bind_internal_variable ("warn_function_name_clash", false);
 }
 
 // You guessed it.
 
 int
 octave_main (int argc, char **argv, int embedded)
 {
   octave_env::set_program_name (argv[0]);
@@ -501,30 +501,32 @@ octave_main (int argc, char **argv, int 
   octave_program_invocation_name = octave_env::get_program_invocation_name ();
   octave_program_name = octave_env::get_program_name ();
 
   // The order of these calls is important.  The call to
   // install_defaults must come before install_builtins because
   // default variable values must be available for the variables to be
   // installed, and the call to install_builtins must come before the
   // options are processed because some command line options override
-  // defaults by calling bind_builtin_variable.
+  // defaults by calling bind_internal_variable.
 
   sysdep_init ();
 
   // The idea here is to force xerbla to be referenced so that we will
   // link to our own version instead of the one provided by the BLAS
   // library.  But octave_NaN should never be -1, so we should never
   // actually call xerbla.
 
   if (octave_NaN == -1)
     F77_FUNC (xerbla, XERBLA) ("octave", 13, 6L);
 
   initialize_error_handlers ();
 
+  initialize_default_warning_state ();
+
   install_defaults ();
 
   initialize_pathsearch ();
 
   if (! embedded)
     install_signal_handlers ();
 
   initialize_file_io ();
@@ -540,17 +542,17 @@ octave_main (int argc, char **argv, int 
   prog_args args (argc, argv, short_opts, long_opts);
 
   int optc;
   while ((optc = args.getopt ()) != EOF)
     {
       switch (optc)
 	{
 	case 'H':
-	  bind_builtin_variable ("saving_history", false);
+	  bind_internal_variable ("saving_history", false);
 	  break;
 
 	case 'V':
 	  verbose_flag = true;
 	  break;
 
 	case 'd':
 	  // This is the same as yydebug in parse.y.
@@ -568,27 +570,27 @@ octave_main (int argc, char **argv, int 
 	  break;
 
 	case 'i':
 	  forced_interactive = true;
 	  break;
 
 	case 'p':
 	  if (args.optarg ())
-	    bind_builtin_variable ("LOADPATH", args.optarg ());
+	    bind_internal_variable ("LOADPATH", args.optarg ());
 	  break;
 
 	case 'q':
 	  inhibit_startup_message = true;
 	  break;
 
 	case 'x':
 	  {
 	    double tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE);
-	    bind_builtin_variable ("echo_executing_commands", tmp);
+	    bind_internal_variable ("echo_executing_commands", tmp);
 	  }
 	  break;
 
 	case 'v':
 	  print_version_and_exit ();
 	  break;
 
 	case EVAL_OPTION:
@@ -598,27 +600,27 @@ octave_main (int argc, char **argv, int 
 		code_to_eval = args.optarg ();
 	      else
 		code_to_eval += std::string (" ") + args.optarg ();
 	    }
 	  break;
 
 	case EXEC_PATH_OPTION:
 	  if (args.optarg ())
-	    bind_builtin_variable ("EXEC_PATH", args.optarg ());
+	    bind_internal_variable ("exec_path", args.optarg ());
 	  break;
 
 	case INFO_FILE_OPTION:
 	  if (args.optarg ())
-	    bind_builtin_variable ("INFO_FILE", args.optarg ());
+	    bind_internal_variable ("info_file", args.optarg ());
 	  break;
 
 	case INFO_PROG_OPTION:
 	  if (args.optarg ())
-	    bind_builtin_variable ("INFO_PROGRAM", args.optarg ());
+	    bind_internal_variable ("info_program", args.optarg ());
 	  break;
 
 	case NO_INIT_FILE_OPTION:
 	  read_init_files = false;
 	  break;
 
 	case NO_LINE_EDITING_OPTION:
 	  line_editing = false;
@@ -664,17 +666,17 @@ octave_main (int argc, char **argv, int 
   octave_interpreter_ready = true;
 
   initialize_version_info ();
 
   execute_default_pkg_add_files ();
 
   execute_startup_files ();
 
-  command_history::read (false);
+  initialize_history ();
 
   if (! inhibit_startup_message && reading_startup_message_printed)
     std::cout << std::endl;
 
   // Is input coming from a terminal?  If so, we are probably
   // interactive.
 
   interactive = (! embedded
@@ -730,17 +732,17 @@ octave_main (int argc, char **argv, int 
   // has forced interactive behavior.
 
   if (! interactive && forced_interactive)
     {
       command_editor::blink_matching_paren (false);
 
       // FIXME -- is this the right thing to do?
 
-      bind_builtin_variable ("echo_executing_commands", ECHO_CMD_LINE);
+      bind_internal_variable ("echo_executing_commands", ECHO_CMD_LINE);
     }
 
   if (embedded)
     {
       // FIXME -- do we need to do any cleanup here before
       // returning?  If we don't, what will happen to Octave functions
       // that have been registered to execute with atexit, for example?
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -55,21 +55,21 @@ 02110-1301, USA.
 #include "parse.h"
 #include "utils.h"
 #include "variables.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value,
 				     "<unknown type>", "unknown");
 
 // If TRUE, print the name along with the value.
-static bool Vprint_answer_id_name;
+static bool Vprint_answer_id_name = true;
 
 // If TRUE, turn off printing of results in functions (as if a
 // semicolon has been appended to each statement).
-static bool Vsilent_functions;
+static bool Vsilent_functions = false;
 
 octave_value
 octave_base_value::squeeze (void) const
 {
   std::string nm = type_name ();
   error ("squeeze: invalid operation for %s type", nm.c_str ());
   return octave_value ();
 }
@@ -1091,62 +1091,37 @@ install_base_type_conversions (void)
   INSTALL_ASSIGNCONV (octave_base_value, octave_cell, octave_cell);
 
   INSTALL_WIDENOP (octave_base_value, octave_matrix, matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_complex_matrix, complex_matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
-static int
-print_answer_id_name (void)
+DEFUN (print_answer_id_name, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} print_answer_id_name ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} print_answer_id_name (@var{new_val})\n\
+Query or set the internal variable that controls whether variable\n\
+names are printed along with results produced by evaluating an expression.\n\
+@end deftypefn")
 {
-  Vprint_answer_id_name = check_preference ("print_answer_id_name");
-
-  return 0;
-}
-
-static int
-silent_functions (void)
-{
-  Vsilent_functions = check_preference ("silent_functions");
-
-  return 0;
+  return SET_INTERNAL_VARIABLE (print_answer_id_name);
 }
 
-void
-symbols_of_ov_base (void)
+DEFUN (silent_functions, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} silent_functions ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
+Query or set the internal variable that controls whether internal\n\
+output from a function is suppressed.  If this option is disabled,\n\
+Octave will display the results produced by evaluating expressions\n\
+within a function body that are not terminated with a semicolon.\n\
+@end deftypefn")
 {
-  DEFVAR (print_answer_id_name, true, print_answer_id_name,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} print_answer_id_name\n\
-If the value of @code{print_answer_id_name} is nonzero, variable\n\
-names are printed along with the result.  Otherwise, only the result\n\
-values are printed.  The default value is 1.\n\
-@end defvr");
-
-  DEFVAR (silent_functions, false, silent_functions,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} silent_functions\n\
-If the value of @code{silent_functions} is nonzero, internal output\n\
-from a function is suppressed.  Otherwise, the results of expressions\n\
-within a function body that are not terminated with a semicolon will\n\
-have their values printed.  The default value is 0.\n\
-\n\
-For example, if the function\n\
-\n\
-@example\n\
-function f ()\n\
-  2 + 2\n\
-endfunction\n\
-@end example\n\
-\n\
-@noindent\n\
-is executed, Octave will either print @samp{ans = 4} or nothing\n\
-depending on the value of @code{silent_functions}.\n\
-@end defvr");
+  return SET_INTERNAL_VARIABLE (silent_functions);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -44,17 +44,17 @@ 02110-1301, USA.
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "parse.h"
 #include "variables.h"
 
 // Maximum nesting level for functions called recursively.
-static int Vmax_recursion_depth;
+static int Vmax_recursion_depth = 256;
 
 // User defined functions.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
 				     "user-defined function",
 				     "user-defined function");
@@ -540,25 +540,25 @@ octave_user_function::print_symtab_info 
     sym_tab->print_info (os);
   else
     warning ("%s: no symbol table info!", my_name.c_str ());
 }
 
 void
 octave_user_function::print_code_function_header (void)
 {
-  tree_print_code tpc (octave_stdout, Vps4);
+  tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_header (*this);
 }
 
 void
 octave_user_function::print_code_function_trailer (void)
 {
-  tree_print_code tpc (octave_stdout, Vps4);
+  tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::install_automatic_vars (void)
 {
   if (sym_tab)
@@ -860,35 +860,25 @@ been declared to return an unspecified n
 	::error ("vr_val only valid within function body");
     }
   else
     print_usage ("vr_val");
 
   return retval;
 }
 
-static int
-max_recursion_depth (void)
+DEFUN (max_recursion_depth, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
+Query or set the internal limit on the number of times a function may\n\
+be called recursively.  If the limit is exceeded, an error message is\n\
+printed and control returns to the top level.\n\
+@end deftypefn")
 {
-  Vmax_recursion_depth = check_preference ("max_recursion_depth");
-
-  return 0;
-}
-
-void
-symbols_of_ov_usr_fcn (void)
-{
-  DEFVAR (max_recursion_depth, 256.0, max_recursion_depth,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} max_recursion_depth\n\
-Limit the number of times a function may be called recursively.\n\
-If the limit is exceeded, an error message is printed and control\n\
-returns to the top level.\n\
-\n\
-The default value is 256.\n\
-@end defvr");
+  return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -52,27 +52,52 @@ static oprocstream *external_pager = 0;
 static bool write_to_diary_file = false;
 
 // The name of the current diary file.
 static std::string diary_file;
 
 // The diary file.
 static std::ofstream external_diary_file;
 
+static std::string
+default_pager (void)
+{
+  std::string pager_binary = octave_env::getenv ("PAGER");
+
+#ifdef OCTAVE_DEFAULT_PAGER
+  if (pager_binary.empty ())
+    {
+      pager_binary = std::string (OCTAVE_DEFAULT_PAGER);
+
+      if (pager_binary == "less")
+	{
+	  pager_binary.append (" -e");
+
+	  std::string lessflags = octave_env::getenv ("LESS");
+	  if (lessflags.empty ())
+	    pager_binary.append
+	      (" -X -P'-- less ?pB(%pB\\%):--. (f)orward, (b)ack, (q)uit$'");
+	}
+    }
+#endif
+
+  return pager_binary;
+}
+
 // The shell command to run as the pager.
-static std::string Vpager_binary;
+static std::string VPAGER = default_pager ();
 
 // TRUE means that if output is going to the pager, it is sent as soon
 // as it is available.  Otherwise, it is buffered and only sent to the
 // pager when it is time to print another prompt.
-static bool Vpage_output_immediately;
+static bool Vpage_output_immediately = false;
 
 // TRUE means all output intended for the screen should be passed
 // through the pager.
-static bool Vpage_screen_output;
+static bool Vpage_screen_output = true;
 
 static bool really_flush_to_pager = false;
 
 static bool flushing_output_to_pager = false;
 
 static void
 clear_external_pager (void)
 {
@@ -121,17 +146,17 @@ do_sync (const char *msg, int len, bool 
 	{
 	  std::cout.write (msg, len);
 	  std::cout.flush ();
 	}
       else
 	{
 	  if (! external_pager)
 	    {
-	      std::string pgr = Vpager_binary;
+	      std::string pgr = VPAGER;
 
 	      if (! pgr.empty ())
 		{
 		  external_pager = new oprocstream (pgr.c_str ());
 
 		  if (external_pager)
 		    octave_child_list::insert (external_pager->pid (),
 					       pager_event_handler);
@@ -480,29 +505,24 @@ toggles the current state.\n\
   if (error_state)
     return retval;
 
   if (argc == 2)
     {
       std::string arg = argv[1];
 
       if (arg == "on")
-	bind_builtin_variable ("page_screen_output", true);
+	Vpage_screen_output = true;
       else if (arg == "off")
-	bind_builtin_variable ("page_screen_output", false);
+	Vpage_screen_output = false;
       else
 	error ("more: unrecognized argument `%s'", arg.c_str ());
     }
   else if (argc == 1)
-    {
-      octave_value tmp = builtin_any_variable ("page_screen_output");
-
-      if (! error_state)
-	bind_builtin_variable ("page_screen_output", ! tmp.is_true ());
-    }
+    Vpage_screen_output = ! Vpage_screen_output;
   else
     print_usage ("more");
 
   return retval;
 }
 
 DEFUN (terminal_size, , ,
   "-*- texinfo -*-\n\
@@ -515,107 +535,55 @@ terminal window in characters (rows and 
   RowVector size (2, 0.0);
 
   size(0) = command_editor::terminal_rows ();
   size(1) = command_editor::terminal_cols ();
 
   return octave_value (size);
 }
 
-static std::string
-default_pager (void)
+DEFUN (page_output_immediately, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} page_output_immediately ()\n\
+@deftypefnx {Built-in Function} {@var{val} =} page_output_immediately (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave sends\n\
+output to the pager as soon as it is available.  Otherwise, Octave\n\
+buffers its output and waits until just before the prompt is printed to\n\
+flush it to the pager.\n\
+@end deftypefn")
 {
-  std::string pager_binary = octave_env::getenv ("PAGER");
-
-#ifdef OCTAVE_DEFAULT_PAGER
-  if (pager_binary.empty ())
-    {
-      pager_binary = std::string (OCTAVE_DEFAULT_PAGER);
-
-      if (pager_binary == "less")
-	{
-	  pager_binary.append (" -e");
-
-	  std::string lessflags = octave_env::getenv ("LESS");
-	  if (lessflags.empty ())
-	    pager_binary.append
-	      (" -X -P'-- less ?pB(%pB\\%):--. (f)orward, (b)ack, (q)uit$'");
-	}
-    }
-#endif
-
-  return pager_binary;
-}
-
-static int
-pager_binary (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("PAGER");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("PAGER");
-      status = -1;
-    }
-  else
-    Vpager_binary = s;
-
-  return status;
+  return SET_INTERNAL_VARIABLE (page_output_immediately);
 }
 
-static int
-page_output_immediately (void)
+DEFUN (page_screen_output, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} page_screen_output ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} page_screen_output (@var{new_val})\n\
+Query or set the internal variable that controls whether output intended\n\
+for the terminal window that is longer than one page is sent through a\n\
+pager.  This allows you to view one screenful at a time.  Some pagers\n\
+(such as @code{less}---see @ref{Installation}) are also capable of moving\n\
+backward on the output.\n\
+@end deftypefn")
 {
-  Vpage_output_immediately = check_preference ("page_output_immediately");
-
-  return 0;
+  return SET_INTERNAL_VARIABLE (page_screen_output);
 }
 
-static int
-page_screen_output (void)
-{
-  Vpage_screen_output = check_preference ("page_screen_output");
-
-  return 0;
-}
-
-void
-symbols_of_pager (void)
-{
-  DEFVAR (PAGER, default_pager (), pager_binary,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} PAGER\n\
-The default value is normally @code{\"less\"}, @code{\"more\"}, or\n\
+DEFUN (PAGER, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} PAGER ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} PAGER (@var{new_val})\n\
+Query or set the internal variable that specifies the program to use\n\
+to display terminal output on your system.  The default value is\n\
+normally @code{\"less\"}, @code{\"more\"}, or\n\
 @code{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
-\n\
-When running interactively, Octave sends any output intended for your\n\
-terminal that is more than one screen long to the program named by the\n\
-value of the variable @code{PAGER}.\n\
-@end defvr");
-
-  DEFVAR (page_output_immediately, false, page_output_immediately,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} page_output_immediately\n\
-If the value of @code{page_output_immediately} is nonzero, Octave sends\n\
-output to the pager as soon as it is available.  Otherwise, Octave\n\
-buffers its output and waits until just before the prompt is printed to\n\
-flush it to the pager.  The default value is 0.\n\
-@end defvr");
-
-  DEFVAR (page_screen_output, true, page_screen_output,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} page_screen_output\n\
-If the value of @code{page_screen_output} is nonzero, all output\n\
-intended for the screen that is longer than one page is sent through a\n\
-pager.  This allows you to view one screenful at a time.  Some pagers\n\
-(such as @code{less}---see @ref{Installation}) are also capable of moving\n\
-backward on the output.  The default value is 1.\n\
-@end defvr");
+@seealso{page_screen_output, page_output_immediately}\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -3207,22 +3207,16 @@ restore_command_history (void *)
 }
 
 static void
 restore_input_stream (void *f)
 {
   command_editor::set_input_stream (static_cast<FILE *> (f));
 }
 
-static void
-clear_current_script_file_name (void *)
-{
-  bind_builtin_variable ("current_script_file_name", octave_value ());
-}
-
 static bool
 parse_fcn_file (const std::string& ff, bool exec_script, bool force_script = false)
 {
   unwind_protect::begin_frame ("parse_fcn_file");
 
   int script_file_executed = false;
 
   // Open function file and parse.
@@ -3324,20 +3318,16 @@ parse_fcn_file (const std::string& ff, b
 	  unwind_protect::add (restore_command_history, 0);
 
 	  unwind_protect_bool (Vsaving_history);
 	  unwind_protect_bool (reading_script_file);
 
 	  Vsaving_history = false;
 	  reading_script_file = true;
 
-	  unwind_protect::add (clear_current_script_file_name, 0);
-
-	  bind_builtin_variable ("current_script_file_name", ff);
-
 	  octave_user_script *script = new octave_user_script (ff, ff, "");
 	  octave_call_stack::push (script);
 	  unwind_protect::add (octave_call_stack::unwind_pop_script, 0);
 
 	  parse_and_execute (ffile);
 
 	  script_file_executed = true;
 	}
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -55,36 +55,36 @@ 02110-1301, USA.
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means use a scaled fixed point format for `format long' and
 // `format short'.
-static bool Vfixed_point_format;
+static bool Vfixed_point_format = false;
 
 // The maximum field width for a number printed by the default output
 // routines.
-static int Voutput_max_field_width;
+static int Voutput_max_field_width = 10;
 
 // The precision of the numbers printed by the default output
 // routines.
-static int Voutput_precision;
+static int Voutput_precision = 5;
 
 // TRUE means that the dimensions of empty objects should be printed
 // like this: x = [](2x0).
-bool Vprint_empty_dimensions;
+bool Vprint_empty_dimensions = true;
 
 // TRUE means that the rows of big matrices should be split into
 // smaller slices that fit on the screen.
-static bool Vsplit_long_rows;
+static bool Vsplit_long_rows = true;
 
 // How many levels of structure elements should we print?
-int Vstruct_levels_to_print;
+int Vstruct_levels_to_print = 2;
 
 // TRUE means don't do any fancy formatting.
 static bool free_format = false;
 
 // TRUE means print plus sign for nonzero, blank for zero.
 static bool plus_format = false;
 
 // First char for > 0, second for < 0, third for == 0.
@@ -2602,18 +2602,18 @@ init_format_state (void)
   print_e = false;
   print_big_e = false;
   print_g = false;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
 {
-  bind_builtin_variable ("output_precision", prec);
-  bind_builtin_variable ("output_max_field_width", fw);
+  Voutput_precision =  prec;
+  Voutput_max_field_width = fw;
 }
 
 static void
 set_format_style (int argc, const string_vector& argv)
 {
   int idx = 1;
 
   if (--argc > 0)
@@ -2939,103 +2939,24 @@ state is restored.\n\
   if (error_state)
     return retval;
 
   set_format_style (argc, argv);
 
   return retval;
 }
 
-static int
-fixed_point_format (void)
-{
-  Vfixed_point_format = check_preference ("fixed_point_format");
-
-  return 0;
-}
-
-static int
-output_max_field_width (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("output_max_field_width", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival > 0 && ival == val)
-	{
-	  Voutput_max_field_width = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("output_max_field_width");
-  return -1;
-}
-
-static int
-output_precision (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("output_precision", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && ival == val)
-	{
-	  Voutput_precision = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("output_precision");
-  return -1;
-}
-
-static int
-print_empty_dimensions (void)
-{
-  Vprint_empty_dimensions = check_preference ("print_empty_dimensions");
-
-  return 0;
-}
-
-static int
-split_long_rows (void)
-{
-  Vsplit_long_rows = check_preference ("split_long_rows");
-
-  return 0;
-}
-
-static int
-struct_levels_to_print (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("struct_levels_to_print", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival == val)
-	{
-	  Vstruct_levels_to_print = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("struct_levels_to_print");
-  return -1;
-}
-
-void
-symbols_of_pr_output (void)
-{
-  DEFVAR (fixed_point_format, false, fixed_point_format,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} fixed_point_format\n\
-If the value of this variable is nonzero, Octave will scale all values\n\
-in a matrix so that the largest may be written with one leading digit.\n\
-The scaling factor is printed on the first line of output.  For example,\n\
+DEFUN (fixed_point_format, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} fixed_point_format ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave will\n\
+use a scaled format to print matrix values such that the largest\n\
+element may be written with a single leading digit with the scaling\n\
+factor is printed on the first line of output.  For example,\n\
 \n\
 @example\n\
 @group\n\
 octave:1> logspace (1, 7, 5)'\n\
 ans =\n\
 \n\
   1.0e+07  *\n\
 \n\
@@ -3046,66 +2967,54 @@ ans =\n\
   1.00000\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Notice that first value appears to be zero when it is actually 1.  For\n\
 this reason, you should be careful when setting\n\
 @code{fixed_point_format} to a nonzero value.\n\
-\n\
-The default value of @code{fixed_point_format} is 0.\n\
-@end defvr");
-
-  DEFVAR (output_max_field_width, 10.0, output_max_field_width,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} output_max_field_width\n\
-This variable specifies the maximum width of a numeric output field.\n\
-The default value is 10.\n\
-@end defvr");
-
-  DEFVAR (output_precision, 5.0, output_precision,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} output_precision\n\
-This variable specifies the minimum number of significant figures to\n\
-display for numeric output.  The default value is 5.\n\
-@end defvr");
-
-  DEFVAR (print_empty_dimensions, true, print_empty_dimensions,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} print_empty_dimensions\n\
-If the value of @code{print_empty_dimensions} is nonzero, the\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (fixed_point_format);
+}
+
+DEFUN (print_empty_dimensions, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
+Query or set the internal varaible that controls whether the\n\
 dimensions of empty matrices are printed along with the empty matrix\n\
 symbol, @samp{[]}.  For example, the expression\n\
 \n\
 @example\n\
 zeros (3, 0)\n\
 @end example\n\
 \n\
 @noindent\n\
 will print\n\
 \n\
 @example\n\
 ans = [](3x0)\n\
 @end example\n\
-@end defvr");
-
-  DEFVAR (split_long_rows, true, split_long_rows,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} split_long_rows\n\
-For large matrices, Octave may not be able to display all the columns of\n\
-a given row on one line of your screen.  This can result in missing\n\
-information or output that is nearly impossible to decipher, depending\n\
-on whether your terminal truncates or wraps long lines.\n\
-\n\
-If the value of @code{split_long_rows} is nonzero, Octave will display\n\
-the matrix in a series of smaller pieces, each of which can fit within\n\
-the limits of your terminal width.  Each set of rows is labeled so that\n\
-you can easily see which columns are currently being displayed.\n\
-For example:\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (print_empty_dimensions);
+}
+
+DEFUN (split_long_rows, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} split_long_rows ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} split_long_rows (@var{new_val})\n\
+Query or set the internal variable that controls whether rows of a matrix\n\
+may be split when displayed to a terminal window.  If the rows are split,\n\
+Octave will display the matrix in a series of smaller pieces, each of\n\
+which can fit within the limits of your terminal width and each set of\n\
+rows is labeled so that you can easily see which columns are currently\n\
+being displayed.  For example:\n\
 \n\
 @smallexample\n\
 @group\n\
 octave:13> rand (2,10)\n\
 ans =\n\
 \n\
  Columns 1 through 6:\n\
 \n\
@@ -3113,26 +3022,54 @@ ans =\n\
   0.75697  0.51942  0.40031  0.61784  0.92309  0.40201\n\
 \n\
  Columns 7 through 10:\n\
 \n\
   0.90174  0.11854  0.72313  0.73326\n\
   0.44672  0.94303  0.56564  0.82150\n\
 @end group\n\
 @end smallexample\n\
-\n\
-@noindent\n\
-The default value of @code{split_long_rows} is nonzero.\n\
-@end defvr");
-
-  DEFVAR (struct_levels_to_print, 2.0, struct_levels_to_print,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} struct_levels_to_print\n\
-You can tell Octave how many structure levels to display by setting the\n\
-built-in variable @code{struct_levels_to_print}.  The default value is 2.\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (split_long_rows);
+}
+
+DEFUN (output_max_field_width, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} output_max_field_width ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
+Query or set the internal variable that specifies the maximum width\n\
+of a numeric output field.\n\
+@seealso{format, output_precision}\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, 0, INT_MAX);
+}
+
+DEFUN (output_precision, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} output_precision ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
+Query or set the internal variable that specifies the minimum number of\n\
+significant figures to display for numeric output.\n\
+@seealso{format, output_max_field_width}\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1, INT_MAX);
+}
+
+DEFUN (struct_levels_to_print, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
+Query or set the internal variable that specifies the number of\n\
+structure levels to display.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print,
+					    -1, INT_MAX);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -34,20 +34,21 @@ 02110-1301, USA.
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-assign.h"
 #include "pt-walk.h"
 #include "utils.h"
+#include "variables.h"
 
 // TRUE means print the right hand side of an assignment instead of
 // the left.
-static bool Vprint_rhs_assign_val;
+static bool Vprint_rhs_assign_val = false;
 
 // Simple assignment expressions.
 
 tree_simple_assignment::~tree_simple_assignment (void)
 {
   if (! preserve)
     delete lhs;
 
@@ -337,34 +338,26 @@ tree_multi_assignment::oper (void) const
 }
 
 void
 tree_multi_assignment::accept (tree_walker& tw)
 {
   tw.visit_multi_assignment (*this);
 }
 
-static int
-print_rhs_assign_val (void)
+DEFUN (print_rhs_assign_val, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} print_rhs_assign_val ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} print_rhs_assign_val (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave will\n\
+print the value of the right hand side of assignment expressions\n\
+instead of the value of the left hand side (after the assignment).\n\
+@end deftypefn")
 {
-  Vprint_rhs_assign_val = check_preference ("print_rhs_assign_val");
-
-  return 0;
+  return SET_INTERNAL_VARIABLE (print_rhs_assign_val);
 }
 
-void
-symbols_of_pt_assign (void)
-{
-  DEFVAR (print_rhs_assign_val, false, print_rhs_assign_val,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} print_rhs_assign_val\n\
-If the value of this variable is non-zero, Octave will print the value\n\
-of the right hand side of assignment expressions instead of the value\n\
-of the left hand side (after the assignment).\n\
-@end defvr");
-
-}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -87,17 +87,17 @@ private:
   tree_expression *lhs;
 
   // The right hand side of the assignment.
   tree_expression *rhs;
 
   // True if we should not delete the lhs.
   bool preserve;
 
-  // True if this is an assignment to the built-in variable ans.
+  // True if this is an assignment to the automatic variable ans.
   bool ans_ass;
 
   // The type of the expression.
   octave_value::assign_op etype;
 
   // No copying!
 
   tree_simple_assignment (const tree_simple_assignment&);
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -934,61 +934,35 @@ done:
 }
 
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
-static int
-string_fill_char (void)
-{
-  int status = 0;
-
-  std::string s = builtin_string_variable ("string_fill_char");
-
-  switch (s.length ())
-    {
-    case 1:
-      Vstring_fill_char = s[0];
-      break;
-
-    case 0:
-      Vstring_fill_char = '\0';
-      break;
-
-    default:
-      warning ("string_fill_char must be a single character");
-      status = -1;
-      break;
-    }
-
-  return status;
-}
-
-void
-symbols_of_pt_mat (void)
-{
-  DEFVAR (string_fill_char, " ", string_fill_char,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} string_fill_char\n\
-The value of this variable is used to pad all strings in a string matrix\n\
-to the same length.  It should be a single character.  The default value\n\
-is @code{\" \"} (a single space).  For example,\n\
+DEFUN (string_fill_char, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} string_fill_char ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
+Query or set the internal variable used to pad all rows of a character\n\
+matrix to the same length.  It must be a single character.  The default\n\
+value is @code{\" \"} (a single space).  For example,\n\
 \n\
 @example\n\
 @group\n\
-string_fill_char = \"X\";\n\
+string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
      @result{} \"theseXX\"\n\
         \"areXXXX\"\n\
         \"strings\"\n\
 @end group\n\
 @end example\n\
-@end defvr");
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (string_fill_char);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -73,17 +73,17 @@ tree_statement::column (void)
 }
 
 void
 tree_statement::maybe_echo_code (bool in_function_body)
 {
   if (in_function_body
       && (Vecho_executing_commands & ECHO_FUNCTIONS))
     {
-      tree_print_code tpc (octave_stdout, Vps4);
+      tree_print_code tpc (octave_stdout, VPS4);
 
       accept (tpc);
     }
 }
 
 octave_value_list
 tree_statement::eval (bool silent, int nargout, bool in_function_body)
 {
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -47,34 +47,35 @@ 02110-1301, USA.
 #include "oct-map.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "utils.h"
+#include "variables.h"
 
 // Nonzero means we have already printed a message for this series of
 // SIGPIPES.  We assume that the writer will eventually give up.
 int pipe_handler_error_count = 0;
 
 // TRUE means we can be interrupted.
 bool can_interrupt = false;
 
 // TRUE means we should try to enter the debugger on SIGINT.
 static bool Vdebug_on_interrupt = false;
 
 // Allow users to avoid writing octave-core for SIGHUP (sent by
 // closing gnome-terminal, for example).  Note that this variable has
 // no effect if Vcrash_dumps_octave_core is FALSE.
-static bool Vsighup_dumps_octave_core;
+static bool Vsighup_dumps_octave_core = true;
 
 // Similar to Vsighup_dumps_octave_core, but for SIGTERM signal.
-static bool Vsigterm_dumps_octave_core;
+static bool Vsigterm_dumps_octave_core = true;
 
 #if RETSIGTYPE == void
 #define SIGHANDLER_RETURN(status) return
 #else
 #define SIGHANDLER_RETURN(status) return status
 #endif
 
 #if defined (MUST_REINSTALL_SIGHANDLERS)
@@ -986,69 +987,50 @@ Return a structure containing Unix signa
       retval = m;
     }
   else
     print_usage ("SIG");
 
   return retval;
 }
 
-static int
-debug_on_interrupt (void)
-{
-  Vdebug_on_interrupt = check_preference ("debug_on_interrupt");
-
-  return 0;
-}
-
-static int
-sighup_dumps_octave_core (void)
+DEFUN (debug_on_interrupt, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave will try\n\
+to enter debugging mode when it receives an interrupt signal (typically\n\
+generated with @kbd{C-c}).  If a second interrupt signal is received\n\
+before reaching the debugging mode, a normal interrupt will occur.\n\
+@end deftypefn")
 {
-  Vsighup_dumps_octave_core = check_preference ("sighup_dumps_octave_core");
-
-  return 0;
-}
-
-static int
-sigterm_dumps_octave_core (void)
-{
-  Vsigterm_dumps_octave_core = check_preference ("sigterm_dumps_octave_core");
-
-  return 0;
+  return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
-void
-symbols_of_sighandlers (void)
+DEFUN (sighup_dumps_octave_core, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave tries\n\
+to save all current variables the the file \"octave-core\" if it receives\n\
+a hangup signal.\n\
+@end deftypefn")
 {
-  DEFVAR (debug_on_interrupt, false, debug_on_interrupt,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} debug_on_interrupt\n\
-If @code{debug_on_interrupt} is nonzero, Octave will try to enter\n\
-debugging mode when it receives an interrupt signal (typically\n\
-generated with @kbd{C-c}).  If a second interrupt signal is received\n\
-before reaching the debugging mode, a normal interrupt will occur.\n\
-The default value is 0.\n\
-@end defvr");
+  return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
+}
 
-  DEFVAR (sighup_dumps_octave_core, true, sighup_dumps_octave_core,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} sighup_dumps_octave_core\n\
-If this variable is set to a nonzero value and\n\
-@code{crash_dumps_octave_core} is also nonzero, Octave tries to save all\n\
-current variables the the file \"octave-core\" if it receives a\n\
-hangup signal.  The default value is 1.\n\
-@end defvr");
-
-  DEFVAR (sigterm_dumps_octave_core, true, sigterm_dumps_octave_core,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} sigterm_dumps_octave_core\n\
-If this variable is set to a nonzero value and\n\
-@code{crash_dumps_octave_core} is also nonzero, Octave tries to save all\n\
-current variables the the file \"octave-core\" if it receives a\n\
-terminate signal.  The default value is 1.\n\
-@end defvr");
+DEFUN (sigterm_dumps_octave_core, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave tries\n\
+to save all current variables the the file \"octave-core\" if it receives\n\
+a terminate signal.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -51,23 +51,24 @@ 02110-1301, USA.
 
 #include "parse.h"
 
 unsigned long int symbol_table::symtab_count = 0;
 
 // Should variables be allowed to hide functions of the same name?  A
 // positive value means yes.  A negative value means yes, but print a
 // warning message.  Zero means it should be considered an error.
-static int Vvariables_can_hide_functions;
+static int Vvariables_can_hide_functions = 1;
 
 // Nonzero means we print debugging info about symbol table lookups.
-static int Vdebug_symtab_lookups;
+static bool Vdebug_symtab_lookups = false;
 
 // Defines layout for the whos/who -long command
-std::string Vwhos_line_format;
+std::string Vwhos_line_format
+  = "  %p:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lt:-1;\n";
 
 octave_allocator
 symbol_record::symbol_def::allocator (sizeof (symbol_record::symbol_def));
 
 #define SYMBOL_DEF symbol_record::symbol_def
 
 std::string
 SYMBOL_DEF::type_as_string (void) const
@@ -77,18 +78,16 @@ SYMBOL_DEF::type_as_string (void) const
   if (is_user_variable ())
     retval = "user-defined variable";
   else if (is_command ())
     retval = "built-in command";
   else if (is_mapper_function ())
     retval = "built-in mapper function";
   else if (is_user_function ())
     retval = "user-defined function";
-  else if (is_builtin_variable ())
-    retval = "built-in variable";
   else if (is_builtin_function ())
     retval = "built-in function";
   else if (is_dld_function ())
     retval = "dynamically-linked function";
 
   return retval;
 }
 
@@ -125,17 +124,17 @@ SYMBOL_DEF::type (std::ostream& os, cons
 	  if (pr_type_info && ! quiet)
 	    os << name << " is a " << type_as_string () << ":\n\n";
 
 	  tree_print_code tpc (os, "", pr_orig_txt);
 
 	  defn->accept (tpc);
 	}
     }
-  else if (is_user_variable () || is_builtin_variable ())
+  else if (is_user_variable ())
     {
       if (pr_type_info && ! quiet)
 	os << name << " is a " << type_as_string () << "\n";
 
       definition.print_raw (os, true);
 
       if (pr_type_info)
 	os << "\n";
@@ -201,31 +200,17 @@ symbol_record::rename (const std::string
   if (! read_only_error ("rename"))
     nm = new_name;
 }
 
 void
 symbol_record::define (const octave_value& v, unsigned int sym_type)
 {
   if (! (is_variable () && read_only_error ("redefine")))
-    {
-      if (definition->type () == symbol_record::BUILTIN_VARIABLE)
-	sym_type = symbol_record::BUILTIN_VARIABLE;
-
-      definition->define (v, sym_type);
-    }
-}
-
-void
-symbol_record::define_builtin_var (const octave_value& v)
-{
-  define (v, symbol_record::BUILTIN_VARIABLE);
-
-  if (chg_fcn)
-    chg_fcn ();
+    definition->define (v, sym_type);
 }
 
 bool
 symbol_record::define (octave_function *f, unsigned int sym_type)
 {
   bool retval = false;
 
   if (! read_only_error ("redefine"))
@@ -319,25 +304,16 @@ symbol_record::mark_as_static (void)
 octave_value&
 symbol_record::variable_value (void)
 {
   static octave_value foo;
 
   return is_variable () ? def () : foo;
 }
 
-inline void
-symbol_record::link_to_builtin_variable (void)
-{
-  symbol_record *tmp_sym = fbi_sym_tab->lookup (name ());
-
-  if (tmp_sym && tmp_sym->is_builtin_variable ())
-    alias (tmp_sym);
-}
-
 octave_lvalue
 symbol_record::variable_reference (void)
 {
   if ((Vvariables_can_hide_functions <= 0 || ! can_hide_function)
       && (is_function ()
 	  || (! is_defined () && is_valid_function (nm))))
     {
       if (Vvariables_can_hide_functions < 0 && can_hide_function)
@@ -349,24 +325,18 @@ symbol_record::variable_reference (void)
 	}
     }
 
   if (is_function ())
     clear ();
 
   if (! is_defined ())
     {
-      if (! (is_formal_parameter () || is_linked_to_global ()))
-	link_to_builtin_variable ();
-
-      if (! is_defined ())
-	{
-	  octave_value tmp;
-	  define (tmp);
-	}
+      octave_value tmp;
+      define (tmp);
     }
 
   return octave_lvalue (&(def ()), chg_fcn);
 }
 
 void
 symbol_record::push_context (void)
 {
@@ -1720,65 +1690,34 @@ symbol_table::hash (const std::string& s
   unsigned int h = 0;
 
   for (unsigned int i = 0; i < str.length (); i++)
     h = h * 33 + str[i];
 
   return h & (table_size - 1);
 }
 
-
-static int
-variables_can_hide_functions (void)
+DEFUN (debug_symtab_lookups, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} debug_symtab_lookups ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} debug_symtab_lookups (@var{new_val})\n\
+Query or set the internal variable that controls whether debugging\n\
+information is printed when searching for symbols in the symbol tables.\n\
+@end deftypefn")
 {
-  Vvariables_can_hide_functions
-    = check_preference ("variables_can_hide_functions");
-
-  return 0;
-}
-
-static int
-debug_symtab_lookups (void)
-{
-  Vdebug_symtab_lookups = check_preference ("debug_symtab_lookups");
-
-  return 0;
+  return SET_INTERNAL_VARIABLE (debug_symtab_lookups);
 }
 
-static int
-whos_line_format (void)
-{
-  Vwhos_line_format = builtin_string_variable ("whos_line_format");
-
-  return 0;
-}
-
-void
-symbols_of_symtab (void)
-{
-  DEFVAR (variables_can_hide_functions, true, variables_can_hide_functions,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} variables_can_hide_functions\n\
-If the value of this variable is nonzero, assignments to variables may\n\
-hide previously defined functions of the same name.  A negative value\n\
-will cause Octave to print a warning, but allow the operation.\n\
-@end defvr");
-
-  DEFVAR (debug_symtab_lookups, false, debug_symtab_lookups,
-    "-*- texinfo -*-\n\
-@defvr debug_symtab_lookups\n\
-If the value of this variable is nonzero, print debugging info when\n\
-searching for symbols in the symbol tables.\n\
-@end defvr");
-
-  DEFVAR (whos_line_format, "  %p:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lt:-1;\n", whos_line_format,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} whos_line_format\n\
-This string decides in what order attributtes of variables are to be printed.\n\
-The following commands are used:\n\
+DEFUN (whos_line_format, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} whos_line_format ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
+Query or set the format string used by the @code{whos}.\n\
+\n\
+The following escape sequences may be used in the format:\n\
 @table @code\n\
 @item %b\n\
 Prints number of bytes occupied by variables.\n\
 @item %e\n\
 Prints elements held by variables.\n\
 @item %n\n\
 Prints variable names.\n\
 @item %p\n\
@@ -1807,17 +1746,33 @@ tells how many columns the parameter wil
 print_dims tells how many dimensions to print. If number of\n\
 dimensions exceeds print_dims, dimensions will be printed like\n\
 x-D.\n\
 center-specific and print_dims may only be applied to command\n\
 %s. A negative value for print_dims will cause Octave to print all\n\
 dimensions whatsoever.\n\
 balance specifies the offset for printing of the dimensions string.\n\
 \n\
-Default format is \"  %p:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lt:-1;\\n\".\n\
-@end defvr");
+The default format is \"  %p:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lt:-1;\\n\".\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (whos_line_format);
+}
+
+DEFUN (variables_can_hide_functions, args, nargout,
+    "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} variables_can_hide_functions ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} variables_can_hide_functions (@var{new_val})\n\
+Query or set the internal variable that controls whether assignments\n\
+to variables may hide previously defined functions of the same name.\n\
+If set to a nonzero value allows hiding, zero causes Octave to\n\
+generate an error, and a negative value cause Octave to print a\n\
+warning, but allow the operation.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (variables_can_hide_functions);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -69,18 +69,17 @@ public:
     {
       UNKNOWN = 0,
       USER_FUNCTION = 1,
       USER_VARIABLE = 2,
       DLD_FUNCTION = 4,
       BUILTIN_FUNCTION = 8,
       COMMAND = 16,
       RAWCOMMAND = 32,
-      MAPPER_FUNCTION = 64,
-      BUILTIN_VARIABLE = 128
+      MAPPER_FUNCTION = 64
     };
 
 private:
 
   // Variables or functions.
 
   class symbol_def
   {
@@ -89,20 +88,17 @@ private:
     symbol_def (const octave_value& val = octave_value (),
 		unsigned int sym_type = 0)
       : symbol_type (sym_type), eternal (0), read_only (0), help_string (),
 	definition (val), count (1) { }
 
     ~symbol_def (void) { }
 
     bool is_variable (void) const
-      {
-	return (symbol_type & symbol_record::USER_VARIABLE
-		|| symbol_type & symbol_record::BUILTIN_VARIABLE);
-      }
+      { return (symbol_type & symbol_record::USER_VARIABLE); }
 
     // It's not necessary to check for COMMAND and MAPPER_FUNCTION
     // here.  Those tags are just used as additional qualifiers for
     // the other types of functions.
 
     bool is_function (void) const
       {
 	return (symbol_type & symbol_record::USER_FUNCTION
@@ -134,19 +130,16 @@ private:
       { return (symbol_type & symbol_record::RAWCOMMAND); }      
 
     bool is_mapper_function (void) const
       { return (symbol_type & symbol_record::MAPPER_FUNCTION); }
 
     bool is_user_function (void) const
       { return (symbol_type & symbol_record::USER_FUNCTION); }
 
-    bool is_builtin_variable (void) const
-      { return (symbol_type & symbol_record::BUILTIN_VARIABLE); }
-
     bool is_builtin_function (void) const
       { return (symbol_type & symbol_record::BUILTIN_FUNCTION); }
 
     bool is_dld_function (void) const
       { return (symbol_type & symbol_record::DLD_FUNCTION); }
 
     // FIXME
     bool is_map_element (const std::string& /* elts */) const
@@ -325,19 +318,16 @@ public:
     { return definition->is_dld_function (); }
 
   bool is_variable (void) const
     { return definition->is_variable (); }
 
   bool is_user_variable (void) const
     { return definition->is_user_variable (); }
 
-  bool is_builtin_variable (void) const
-    { return definition->is_builtin_variable (); }
-
   bool is_map_element (const std::string& elts) const
     { return definition->is_map_element (elts); }
 
   unsigned int type (void) const { return definition->type (); }
 
   bool is_defined (void) const { return definition->is_defined (); }
 
   bool is_read_only (void) const { return definition->is_read_only (); }
@@ -353,18 +343,16 @@ public:
   void hide (void) { visible = false; }
   void show (void) { visible = true; }
   bool is_visible (void) const { return visible; }
 
   void set_change_function (change_function f) { chg_fcn = f; }
 
   void define (const octave_value& v, unsigned int sym_type = USER_VARIABLE);
 
-  void define_builtin_var (const octave_value& v);
-
   bool define (octave_function *f, unsigned int sym_type);
 
   void document (const std::string& h) { definition->document (h); }
 
   void clear (void);
 
   void alias (symbol_record *s, bool mark_to_clear = false);
 
@@ -462,18 +450,16 @@ private:
 
   std::stack <symbol_record *> aliases_to_clear;
 
   void push_alias_to_clear (symbol_record *s)
     { aliases_to_clear.push (s); }
 
   bool read_only_error (const char *action);
 
-  void link_to_builtin_variable (void);
-
   void maybe_delete_def (void)
     {
       if (--definition->count <= 0)
         delete definition;
     }
 
   // No copying!
 
@@ -490,21 +476,19 @@ private:
 #define SYMTAB_ALL_SCOPES (SYMTAB_LOCAL_SCOPE | SYMTAB_GLOBAL_SCOPE)
 
 #define SYMTAB_ALL_TYPES (symbol_record::USER_FUNCTION \
 			  | symbol_record::USER_VARIABLE \
 			  | symbol_record::DLD_FUNCTION \
 			  | symbol_record::BUILTIN_FUNCTION \
 			  | symbol_record::COMMAND \
   			  | symbol_record::RAWCOMMAND \
-			  | symbol_record::MAPPER_FUNCTION \
-			  | symbol_record::BUILTIN_VARIABLE)
+			  | symbol_record::MAPPER_FUNCTION)
 
-#define SYMTAB_VARIABLES (symbol_record::USER_VARIABLE \
-			  | symbol_record::BUILTIN_VARIABLE)
+#define SYMTAB_VARIABLES (symbol_record::USER_VARIABLE)
 
 class
 symbol_table
 {
 public:
 
   symbol_table (unsigned int tab_size = 128,
 		const std::string& nm = std::string ())
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -323,19 +323,18 @@ name in the path.  If no files are found
 }
 
 DEFUN (file_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
-directories in the format described for the built-in variable\n\
-@code{LOADPATH}.  If no file is found, return an empty matrix.\n\
-For example,\n\
+directories in the format described for @code{LOADPATH}.  If no file\n\
+is found, return an empty matrix.  For example,\n\
 \n\
 @example\n\
 file_in_path (EXEC_PATH, \"sh\")\n\
      @result{} \"/bin/sh\"\n\
 @end example\n\
 \n\
 If the second argument is a cell array of strings, search each\n\
 directory of the path for element of the cell array and return\n\
@@ -736,61 +735,16 @@ Return a structure containing the system
     retval = octave_errno::list ();
   else
     print_usage ("errno_list");
 
   return retval;
 }
 
 static void
-warn_old_style_preference (bool val, const std::string& sval)
-{
-  warning
-    ("preference of \"%s\" is obsolete -- use numeric value of %d instead",
-     sval.c_str (), (val ? 1 : 0));
-}
-
-// Check the value of a string variable to see if it it's ok to do
-// something.
-//
-//   return of  1 => always ok.
-//   return of  0 => never ok.
-//   return of -1 => ok, but give me warning (default).
-
-int
-check_preference (const std::string& var)
-{
-  int pref = -1;
-
-  std::string val = builtin_string_variable (var);
-
-  if (val.empty ())
-    {
-      double dval = 0;
-      if (builtin_real_scalar_variable (var, dval))
-	pref = NINT (dval);
-    }
-  else
-    {
-      if (val == "yes" || val == "true")
-	{
-	  warn_old_style_preference (true, val);
-	  pref = 1;
-	}
-      else if (val == "never" || val == "no" || val == "false")
-	{
-	  warn_old_style_preference (false, val);
-	  pref = 0;
-	}
-    }
-
-  return pref;
-}
-
-static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       warning_with_id ("Octave:neg-dim-as-zero",
 		       "%s: converting negative dimension to zero", warnfor);
 
       nr = (nr < 0) ? 0 : nr;
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -60,18 +60,16 @@ extern std::string fcn_file_in_path (con
 extern std::string oct_file_in_path (const std::string&);
 
 extern std::string do_string_escapes (const std::string& s);
 
 extern const char *undo_string_escape (char c);
 
 extern std::string undo_string_escapes (const std::string& s);
 
-extern int check_preference (const std::string& var);
-
 extern void
 check_dimensions (dim_vector& dim, const char *warnfor);
 
 extern void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim);
 
 extern void
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -55,17 +55,17 @@ 02110-1301, USA.
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
-static int Vignore_function_time_stamp;
+static int Vignore_function_time_stamp = 1;
 
 // Symbol table for symbols at the top level.
 symbol_table *top_level_sym_tab = 0;
 
 // Symbol table for the current scope.
 symbol_table *curr_sym_tab = 0;
 
 // Symbol table for the current caller scope.
@@ -100,25 +100,16 @@ initialize_symbol_tables (void)
   if (! top_level_sym_tab)
     top_level_sym_tab = new symbol_table (4096, "TOP");
 
   curr_caller_sym_tab = curr_sym_tab = top_level_sym_tab;
 }
 
 // Attributes of variables and functions.
 
-// Is this variable a builtin?
-
-bool
-is_builtin_variable (const std::string& name)
-{
-  symbol_record *sr = fbi_sym_tab->lookup (name);
-  return (sr && sr->is_builtin_variable ());
-}
-
 // Is this a command-style function?
 
 static std::set <std::string> command_set;
 
 static inline bool
 is_marked_as_command (const std::string& s)
 {
   return command_set.find (s) != command_set.end ();
@@ -794,20 +785,16 @@ symbol_exist (const std::string& name, c
 
       if (! retval
 	  && (type == "any" || type == "builtin"))
 	{
 	  if (not_a_struct && sr->is_builtin_function ())
 	    {
 	      retval = 5;
 	    }
-	  else if (var_ok && sr->is_builtin_variable ())
-	    {
-	      retval = 101;
-	    }
 	}
 
       if (! retval
 	  && not_a_struct
 	  && (type == "any" || type == "file")
 	  && (sr->is_user_function () || sr->is_dld_function ()))
 	{
 	  octave_value t = sr->def ();
@@ -901,18 +888,17 @@ unique_symbol_name (const std::string& b
 }
 
 DEFUN (exist, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} exist (@var{name}, @var{type})\n\
 Return 1 if the name exists as a variable, 2 if the name (after\n\
 appending @samp{.m}) is a function file in Octave's LOADPATH, 3 if the\n\
 name is a @samp{.oct} file in Octave's LOADPATH, 5 if the name is a\n\
-built-in function, 7 if the name is a directory, 101 if the name is\n\
-a built-in variable, or 103\n\
+built-in function, 7 if the name is a directory, or 103\n\
 if the name is a function not associated with a file (entered on\n\
 the command line).\n\
 \n\
 Otherwise, return 0.\n\
 \n\
 This function also returns 2 if a regular file called @var{name}\n\
 exists in Octave's @code{LOADPATH}.  If you want information about\n\
 other types of files, you should use some combination of the functions\n\
@@ -1253,130 +1239,180 @@ set_global_value (const std::string& nm,
   else
     panic_impossible ();
 }
 
 // Variable values.
 
 octave_value
 set_internal_variable (bool& var, const octave_value_list& args,
-		       const char *nm)
+		       int nargout, const char *nm)
 {
-  octave_value retval = var;
+  octave_value retval;
+
+  if (nargout > 0)
+    retval = var;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       bool bval = args(0).bool_value ();
 
       if (! error_state)
 	var = bval;
       else
 	error ("%s: expecting arg to be a logical value", nm);
     }
   else if (nargin > 1)
-    print_usage ("automatic_replot");
+    print_usage (nm);
 
   return retval;
 }
 
 octave_value
-set_internal_variable (std::string& var, const octave_value_list& args,
-		       const char *nm)
+set_internal_variable (char& var, const octave_value_list& args,
+		       int nargout, const char *nm)
 {
-  octave_value retval = var;
+  octave_value retval;
+
+  if (nargout > 0)
+    retval = var;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).string_value ();
 
       if (! error_state)
-	var = sval;
+	{
+	  switch (sval.length ())
+	    {
+	    case 1:
+	      var = sval[0];
+	      break;
+
+	    case 0:
+	      var = '\0';
+	      break;
+
+	    default:
+	      error ("%s: argument must be a single character", nm);
+	      break;
+	    }
+	}
+      else
+	error ("%s: argument must be a single character", nm);
+    }
+  else if (nargin > 1)
+    print_usage (nm);
+
+  return retval;
+}
+
+octave_value
+set_internal_variable (int& var, const octave_value_list& args,
+		       int nargout, const char *nm,
+		       int minval, int maxval)
+{
+  octave_value retval;
+
+  if (nargout > 0)
+    retval = var;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+      int ival = args(0).int_value ();
+
+      if (! error_state)
+	{
+	  if (ival < minval)
+	    error ("%s: expecting arg to be greater than %d", minval);
+	  else if (ival > maxval)
+	    error ("%s: expecting arg to be less than or equal to %d", maxval);
+	  else
+	    var = ival;
+	}
+      else
+	error ("%s: expecting arg to be an integer value", nm);
+    }
+  else if (nargin > 1)
+    print_usage (nm);
+
+  return retval;
+}
+
+octave_value
+set_internal_variable (double& var, const octave_value_list& args,
+		       int nargout, const char *nm,
+		       double minval, double maxval)
+{
+  octave_value retval;
+
+  if (nargout > 0)
+    retval = var;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+      double dval = args(0).scalar_value ();
+
+      if (! error_state)
+	{
+	  if (dval < minval)
+	    error ("%s: expecting arg to be greater than %g", minval);
+	  else if (dval > maxval)
+	    error ("%s: expecting arg to be less than or equal to %g", maxval);
+	  else
+	    var = dval;
+	}
+      else
+	error ("%s: expecting arg to be a scalar value", nm);
+    }
+  else if (nargin > 1)
+    print_usage (nm);
+
+  return retval;
+}
+
+octave_value
+set_internal_variable (std::string& var, const octave_value_list& args,
+		       int nargout, const char *nm, bool empty_ok)
+{
+  octave_value retval;
+
+  if (nargout > 0)
+    retval = var;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+      std::string sval = args(0).string_value ();
+
+      if (! error_state)
+	{
+	  if (empty_ok || ! sval.empty ())
+	    var = sval;
+	  else
+	    error ("%s: value must not be empty", nm);
+	}
       else
 	error ("%s: expecting arg to be a character string", nm);
     }
   else if (nargin > 1)
-    print_usage ("automatic_replot");
-
-  return retval;
-}
-
-// Look for the given name in the global symbol table.  If it refers
-// to a string, return a new copy.  If not, return 0;
-
-std::string
-builtin_string_variable (const std::string& name)
-{
-  symbol_record *sr = fbi_sym_tab->lookup (name);
-
-  // It is a programming error to look for builtins that aren't.
-
-  // Use != here to avoid possible conversion to int of smaller type
-  // than the sr pointer.
-
-  assert (sr != 0);
-
-  std::string retval;
-
-  octave_value val = sr->def ();
-
-  if (! error_state && val.is_string ())
-    retval = val.string_value ();
+    print_usage (nm);
 
   return retval;
 }
 
-// Look for the given name in the global symbol table.  If it refers
-// to a real scalar, place the value in d and return 1.  Otherwise,
-// return 0.
-
-int
-builtin_real_scalar_variable (const std::string& name, double& d)
-{
-  int status = 0;
-  symbol_record *sr = fbi_sym_tab->lookup (name);
-
-  // It is a programming error to look for builtins that aren't.
-
-  // Use != here to avoid possible conversion to int of smaller type
-  // than the sr pointer.
-
-  assert (sr != 0);
-
-  octave_value val = sr->def ();
-
-  if (! error_state && val.is_scalar_type ())
-    {
-      d = val.double_value ();
-      status = 1;
-    }
-
-  return status;
-}
-
-// Look for the given name in the global symbol table.
-
-octave_value
-builtin_any_variable (const std::string& name)
-{
-  symbol_record *sr = fbi_sym_tab->lookup (name);
-
-  // It is a programming error to look for builtins that aren't.
-
-  // Use != here to avoid possible conversion to int of smaller type
-  // than the sr pointer.
-
-  assert (sr != 0);
-
-  return sr->def ();
-}
-
 // Global stuff and links to builtin variables and functions.
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the global variable of the same name, creating it if
 // it doesn't already exist.
 
 void
 link_to_global_variable (symbol_record *sr)
@@ -1400,19 +1436,18 @@ link_to_global_variable (symbol_record *
 	}
     }
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable of the same name.
 
 // Make the definition of the symbol record sr be the same as the
-// definition of the builtin variable or function, or user
-// function of the same name, provided that the name has not been used
-// as a formal parameter.
+// definition of the builtin function, or user function of the same
+// name, provided that the name has not been used as a formal parameter.
 
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
   std::string nm = sr->name ();
 
   symbol_record *tmp_sym = 0;
 
@@ -1422,18 +1457,17 @@ link_to_builtin_or_function (symbol_reco
 
       tmp_sym = fbi_sym_tab->lookup (parent + ":" + nm);
     }
 
   if (! tmp_sym)
     tmp_sym = fbi_sym_tab->lookup (nm);
 
   if (tmp_sym
-      && (tmp_sym->is_builtin_variable ()
-	  || tmp_sym->is_function ())
+      && tmp_sym->is_function ()
       && ! tmp_sym->is_formal_parameter ())
     sr->alias (tmp_sym);
 }
 
 // Force a link to a function in the current symbol table.  This is
 // used just after defining a function to avoid different behavior
 // depending on whether or not the function has been evaluated after
 // being defined.
@@ -1468,21 +1502,20 @@ Set the documentation string for @var{sy
       std::string name = args(0).string_value ();
 
       if (! error_state)
 	{
 	  std::string help = args(1).string_value ();
 
 	  if (! error_state)
 	    {
-	      if (is_builtin_variable (name)
-		  || is_command_name (name)
+	      if (is_command_name (name)
 		  || is_mapper_function_name (name)
 		  || is_builtin_function_name (name))
-		error ("document: can't redefine help for built-in variables and functions");
+		error ("document: can't redefine help for built-in functions");
 	      else
 		{
 		  symbol_record *sym_rec = curr_sym_tab->lookup (name);
 
 		  if (sym_rec)
 		    sym_rec->document (help);
 		  else
 		    error ("document: no such symbol `%s'", name.c_str ());
@@ -1572,28 +1605,24 @@ do_who (int argc, const string_vector& a
 
   if (return_list)
     {
       // FIXME -- maybe symbol_list should return a std::list
       // object instead of an Array.
 
       dim_vector dv (0, 0);
 
-      Array<symbol_record *> s2 (dv);
       Array<symbol_record *> s3 (dv);
       Array<symbol_record *> s4 (dv);
       Array<symbol_record *> s5 (dv);
       Array<symbol_record *> s6 (dv);
       Array<symbol_record *> s7 (dv);
 
       if (show_builtins)
 	{
-	  s2 = fbi_sym_tab->symbol_list (pats, symbol_record::BUILTIN_VARIABLE,
-					 SYMTAB_ALL_SCOPES);
-
 	  s3 = fbi_sym_tab->symbol_list (pats, symbol_record::BUILTIN_FUNCTION,
 					 SYMTAB_ALL_SCOPES);
 	}
 
       if (show_functions)
 	{
 	  s4 = fbi_sym_tab->symbol_list (pats, symbol_record::DLD_FUNCTION,
 					 SYMTAB_ALL_SCOPES);
@@ -1606,32 +1635,28 @@ do_who (int argc, const string_vector& a
 	{
 	  s6 = curr_sym_tab->symbol_list (pats, symbol_record::USER_VARIABLE,
 					  SYMTAB_LOCAL_SCOPE);
 
 	  s7 = curr_sym_tab->symbol_list (pats, symbol_record::USER_VARIABLE,
 					  SYMTAB_GLOBAL_SCOPE);
 	}
 
-      octave_idx_type s2_len = s2.length ();
       octave_idx_type s3_len = s3.length ();
       octave_idx_type s4_len = s4.length ();
       octave_idx_type s5_len = s5.length ();
       octave_idx_type s6_len = s6.length ();
       octave_idx_type s7_len = s7.length ();
 
-      octave_idx_type symbols_len
-	= s2_len + s3_len + s4_len + s5_len + s6_len + s7_len;
+      octave_idx_type symbols_len = s3_len + s4_len + s5_len + s6_len + s7_len;
 
       Array<symbol_record *> symbols (dim_vector (symbols_len, 1));
 
       octave_idx_type k = 0;
 
-      symbols.insert (s2, k, 0);
-      k += s2_len;
       symbols.insert (s3, k, 0);
       k += s3_len;
       symbols.insert (s4, k, 0);
       k += s4_len;
       symbols.insert (s5, k, 0);
       k += s5_len;
       symbols.insert (s6, k, 0);
       k += s6_len;
@@ -1705,20 +1730,16 @@ do_who (int argc, const string_vector& a
     }
   else
     {
       int pad_after = 0;
 
       if (show_builtins)
 	{
 	  pad_after += fbi_sym_tab->maybe_list
-	    ("*** built-in variables:", pats, octave_stdout,
-	     show_verbose, symbol_record::BUILTIN_VARIABLE, SYMTAB_ALL_SCOPES);
-
-	  pad_after += fbi_sym_tab->maybe_list
 	    ("*** built-in functions:", pats, octave_stdout,
 	     show_verbose, symbol_record::BUILTIN_FUNCTION, SYMTAB_ALL_SCOPES);
 	}
 
       if (show_functions)
 	{
 	  pad_after += fbi_sym_tab->maybe_list
 	    ("*** dynamically linked functions:", pats,
@@ -1758,17 +1779,17 @@ List currently defined symbols matching 
 following are valid options.  They may be shortened to one character but\n\
 may not be combined.\n\
 \n\
 @table @code\n\
 @item -all\n\
 List all currently defined symbols.\n\
 \n\
 @item -builtins\n\
-List built-in variables and functions.  This includes all currently\n\
+List built-in functions.  This includes all currently\n\
 compiled function files, but does not include all function files that\n\
 are in the @code{LOADPATH}.\n\
 \n\
 @item -functions\n\
 List user-defined functions.\n\
 \n\
 @item -long\n\
 Print a long listing including the type and dimensions of any symbols.\n\
@@ -1841,67 +1862,35 @@ See who.\n\
   return retval;
 }
 
 // Defining variables.
 
 void
 bind_ans (const octave_value& val, bool print)
 {
-  static symbol_record *sr = fbi_sym_tab->lookup ("ans", true);
+  symbol_record *sr = curr_sym_tab->lookup ("ans", true);
 
   if (val.is_defined ())
     {
       sr->define (val);
 
       if (print)
 	val.print_with_name (octave_stdout, "ans");
     }
 }
 
-// Give a global variable a definition.  This will insert the symbol
-// in the global table if necessary.
-
-// How is this different than install_builtin_variable?  Are both
-// functions needed?
-
 void
-bind_builtin_variable (const std::string& varname, const octave_value& val,
-		       bool protect, bool eternal,
-		       symbol_record::change_function chg_fcn,
-		       const std::string& help)
+bind_internal_variable (const std::string& fname, const octave_value& val)
 {
-  symbol_record *sr = fbi_sym_tab->lookup (varname, true);
-
-  // It is a programming error for a builtin symbol to be missing.
-  // Besides, we just inserted it, so it must be there.
-
-  // Use != here to avoid possible conversion to int of smaller type
-  // than the sr pointer.
-
-  assert (sr != 0);
-
-  sr->unprotect ();
-
-  // Must do this before define, since define will call the special
-  // variable function only if it knows about it, and it needs to, so
-  // that user prefs can be properly initialized.
-
-  if (chg_fcn)
-    sr->set_change_function (chg_fcn);
-
-  sr->define_builtin_var (val);
-
-  if (protect)
-    sr->protect ();
-
-  if (eternal)
-    sr->make_eternal ();
-
-  sr->document (help);
+  octave_value_list args;
+
+  args(0) = val;
+
+  feval (fname, args, 0);
 }
 
 void 
 mlock (const std::string& nm)
 {
   symbol_record *sr = fbi_sym_tab->lookup (nm, true);
 
   if (sr)
@@ -2603,74 +2592,76 @@ Print symbol table information for the s
 	print_usage ("__print_symbol_info__");
     }
   else
     print_usage ("__print_symbol_info__");
 
   return retval;
 }
 
-// FIXME -- some of these should do their own checking to be
-// able to provide more meaningful warning or error messages.
-
-static int
-ignore_function_time_stamp (void)
-{
-  int pref = 0;
-
-  std::string val = builtin_string_variable ("ignore_function_time_stamp");
-
-  if (! val.empty ())
-    {
-      if (val == "all")
-	pref = 2;
-      else if (val == "system")
-	pref = 1;
-    }
-
-  Vignore_function_time_stamp = pref;
-
-  return 0;
-}
-
-// FIXME -- there still may be better places for some of these
-// to be defined.
-
-void
-symbols_of_variables (void)
-{
-  DEFVAR (ans, , 0,
+DEFUN (ignore_function_time_stamp, args, nargout,
     "-*- texinfo -*-\n\
-@defvr {Built-in Variable} ans\n\
-This variable holds the most recently computed result that was not\n\
-explicitly assigned to a variable.  For example, after the expression\n\
-\n\
-@example\n\
-3^2 + 4^2\n\
-@end example\n\
-\n\
-@noindent\n\
-is evaluated, the value of @code{ans} is 25.\n\
-@end defvr");
-
-  DEFVAR (ignore_function_time_stamp, "system", ignore_function_time_stamp,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} ignore_function_time_stamp\n\
-This variable can be used to prevent Octave from making the system call\n\
-@code{stat} each time it looks up functions defined in function files.\n\
-If @code{ignore_function_time_stamp} to @code{\"system\"}, Octave will not\n\
-automatically recompile function files in subdirectories of\n\
+@deftypefn {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave checks\n\
+the time stamp on files each time it looks up functions defined in\n\
+function files.  If the internal variable is set to @code{\"system\"},\n\
+Octave will not automatically recompile function files in subdirectories of\n\
 @file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
 they were last compiled, but will recompile other function files in the\n\
 @code{LOADPATH} if they change.  If set to @code{\"all\"}, Octave will not\n\
 recompile any function files unless their definitions are removed with\n\
-@code{clear}.  For any other value of @code{ignore_function_time_stamp},\n\
-Octave will always check to see if functions defined in function files\n\
-need to recompiled.  The default value of @code{ignore_function_time_stamp} is\n\
-@code{\"system\"}.\n\
-@end defvr");
+@code{clear}.  If set to \"none\", Octave will always check time stamps\n\
+on files to determine whether functions defined in function files\n\
+need to recompiled.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  if (nargout > 0)
+    {
+      switch (Vignore_function_time_stamp)
+	{
+	case 1:
+	  retval = "system";
+	  break;
+
+	case 2:
+	  retval = "all";
+	  break;
+
+	default:
+	  retval = "none";
+	  break;
+	}
+    }
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+      std::string sval = args(0).string_value ();
+
+      if (! error_state)
+	{
+	  if (sval == "all")
+	    Vignore_function_time_stamp = 2;
+	  else if (sval == "system")
+	    Vignore_function_time_stamp = 1;
+	  else if (sval == "none")
+	    Vignore_function_time_stamp = 0;
+	  else
+	    error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
+	}
+      else
+	error ("ignore_function_time_stamp: expecting argument to be character string");
+    }
+  else if (nargin > 1)
+    print_usage ("ignore_function_time_stamp");
+
+  return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -31,27 +31,29 @@ class symbol_table;
 
 class tree_identifier;
 class octave_value;
 class octave_value_list;
 class octave_builtin;
 class octave_mapper;
 class string_vector;
 
+#include <climits>
+#include <cfloat>
+
 #include <string>
 
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern bool at_top_level (void);
 
 extern void initialize_symbol_tables (void);
 
-extern bool is_builtin_variable (const std::string&);
 extern bool is_command_name (const std::string&);
 
 // The next three are here temporarily...
 extern bool is_marked_as_rawcommand (const std::string& s);
 extern void mark_as_rawcommand (const std::string& s);
 extern void unmark_rawcommand (const std::string& s);
 
 extern bool is_rawcommand_name (const std::string&);
@@ -104,40 +106,58 @@ extern octave_value lookup_function_hand
 
 extern octave_value
 get_global_value (const std::string& nm, bool silent = false);
 
 extern void set_global_value (const std::string& nm, const octave_value& val);
 
 extern octave_value
 set_internal_variable (bool& var, const octave_value_list& args,
-		       const char *nm);
+		       int nargout, const char *nm);
+
+extern octave_value
+set_internal_variable (char& var, const octave_value_list& args,
+		       int nargout, const char *nm);
+
+extern octave_value
+set_internal_variable (int& var, const octave_value_list& args,
+		       int nargout, const char *nm,
+		       int minval = INT_MIN, int maxval = INT_MAX);
+
+extern octave_value
+set_internal_variable (double& var, const octave_value_list& args,
+		       int nargout, const char *nm,
+		       double minval = DBL_MIN, double maxval = DBL_MAX);
 
 extern octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
-		       const char *nm);
+		       int nargout, const char *nm, bool empty_ok = true);
+
+#define SET_INTERNAL_VARIABLE(NM) \
+  set_internal_variable (V ## NM, args, nargout, #NM)
 
-#define SET_INTERNAL_VARIABLE(NM) set_internal_variable (V ## NM, args, #NM)
+#define SET_NONEMPTY_INTERNAL_STRING_VARIABLE(NM) \
+  set_internal_variable (V ## NM, args, nargout, #NM, false)
+
+#define SET_INTERNAL_VARIABLE_WITH_LIMITS(NM, MINVAL, MAXVAL) \
+  set_internal_variable (V ## NM, args, nargout, #NM, MINVAL, MAXVAL)
 
 extern std::string builtin_string_variable (const std::string&);
 extern int builtin_real_scalar_variable (const std::string&, double&);
 extern octave_value builtin_any_variable (const std::string&);
 
 extern void link_to_global_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
 extern void force_link_to_function (const std::string&);
 
 extern void bind_ans (const octave_value& val, bool print);
 
 extern void
-bind_builtin_variable (const std::string&, const octave_value&,
-		       bool protect = false, bool eternal = false,
-		       symbol_record::change_function f = 0,
-		       const std::string& help = std::string ());
+bind_internal_variable (const std::string& fname, const octave_value& val);
 
 extern void mlock (const std::string&);
 extern void munlock (const std::string&);
 extern bool mislocked (const std::string&);
 
 extern bool clear_function (const std::string& nm);
 extern bool clear_variable (const std::string& nm);
 extern bool clear_symbol (const std::string& nm);
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,12 @@
+2006-05-04  John W. Eaton  <jwe@octave.org>
+
+	* test_prefer.m: Adjust tests for eliminated built-in variables.
+
 2006-04-29  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (check): Use run-octave script.
 
 2006-04-28  John W. Eaton  <jwe@octave.org>
 
 	* test_prefer.m: Adjust tests for new way of handling warning state.
 	* build_sparse_tests.sh: Likewise.
diff --git a/test/test_prefer.m b/test/test_prefer.m
--- a/test/test_prefer.m
+++ b/test/test_prefer.m
@@ -93,106 +93,106 @@
 %!test
 %! clear a; 
 %! a(1) = 1; a(2) = 2;
 %! assert(all (a == [1,2]));
 
 %% FIXME How the hell do I test this one in test/assert 
 %% test/octave.test/prefer/prefer-19.m
 %!#test
-%! pid = print_answer_id_name
-%! print_answer_id_name = 0;
+%! pid = print_answer_id_name ();
+%! print_answer_id_name (0);
 %! a = 1
-%! print_answer_id_name = pid;
+%! print_answer_id_name (pid);
 
 %% FIXME How the hell do I test this one in test/assert 
 %% test/octave.test/prefer/prefer-20.m
 %!#test
-%! pid = print_answer_id_name
-%! print_answer_id_name = 1;
+%! pid = print_answer_id_name ();
+%! print_answer_id_name (1);
 %! a = 1
-%! print_answer_id_name = pid;
+%! print_answer_id_name (pid);
 
 %% test/octave.test/prefer/prefer-21.m
 %!test
-%! ped = print_empty_dimensions;
-%! print_empty_dimensions = 0;
+%! ped = print_empty_dimensions ();
+%! print_empty_dimensions (0);
 %! a = cell (1, 1);
 %! b = type -q a;
 %! assert(!isempty(findstr(b,"[]")));
 %! assert(isempty(findstr(b,"[](0x0)")));
-%! print_empty_dimensions = ped;
+%! print_empty_dimensions (ped);
 
 %% test/octave.test/prefer/prefer-22.m
 %!test
-%! ped = print_empty_dimensions;
-%! print_empty_dimensions = 1;
+%! ped = print_empty_dimensions ();
+%! print_empty_dimensions (1);
 %! a = cell (1, 1);
 %! b = type -q a;
 %! assert(!isempty(findstr(b,"[](0x0)")));
-%! print_empty_dimensions = ped;
+%! print_empty_dimensions (ped);
 
 %% test/octave.test/prefer/prefer-23.m
 %!assert(all (size (inv ([])) == [0, 0]));
 
 %% test/octave.test/prefer/prefer-24.m
 %!assert(all (svd ([]) == zeros (0, 1)));
 
 %% FIXME return_last_computed_value no longer exists!!
 %% Remove the next two tests
 %% test/octave.test/prefer/prefer-25.m
 %% test/octave.test/prefer/prefer-26.m
 
 %% test/octave.test/prefer/prefer-27.m
 %!test
-%! sp = save_precision;
-%! save_precision = 1;
+%! sp = save_precision ();
+%! save_precision (1);
 %! x = pi;
 %! nm = tmpnam();
 %! save("-text",nm,"x");
 %! clear x;
 %! load(nm);
 %! unlink(nm);
 %! assert(x,3);
-%! save_precision = sp;
+%! save_precision (sp);
 
 %% test/octave.test/prefer/prefer-28.m
 %!test
-%! sp = save_precision;
-%! save_precision = 5;
+%! sp = save_precision ();
+%! save_precision (5);
 %! x = pi;
 %! nm = tmpnam();
 %! save("-text",nm,"x");
 %! clear x;
 %! load(nm);
 %! unlink(nm);
 %! assert(x,3.1416);
-%! save_precision = sp;
+%! save_precision (sp);
 
 %% FIXME Same problem as above!!!
 %% test/octave.test/prefer/prefer-29.m
 %!function f ()
 %! 1
 %!#test
-%! sf = silent_functions;
-%! silent_functions = 0;
+%! sf = silent_functions ();
+%! silent_functions (0);
 %! f
 %! assert(??);
-%! silent_functions = sf;
+%! silent_functions (sf);
 
 %% FIXME Same problem as above!!!
 %% test/octave.test/prefer/prefer-30.m
 %!function f ()
 %! 1
 %!#test
-%! sf = silent_functions;
-%! silent_functions = 1;
+%! sf = silent_functions ();
+%! silent_functions (1);
 %! f
 %! assert(??);
-%! silent_functions = sf;
+%! silent_functions (sf);
 
 %% test/octave.test/prefer/prefer-32.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("on", "Octave:neg-dim-as-zero");
 %! fail("eye (-1) == []","warning");
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
