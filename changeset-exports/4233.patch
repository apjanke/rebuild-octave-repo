# HG changeset patch
# User jwe
# Date 1040424235 0
#      Fri Dec 20 22:43:55 2002 +0000
# Node ID ccfdb55c8156f8a6facc4498bab5e303d7fe2aff
# Parent  b032ebd54586f2215d12254e2cbbc8d769454542
[project @ 2002-12-20 22:43:54 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,39 @@
+2002-12-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* DLD-FUNCTIONS/time.cc (extract_tm): Use int_value() instead of
+	casting double_value() to int.
+
+	* DLD-FUNCITONS/time.cc ()
+
+	* ov.cc (octave_value::next_subsref): Arg "skip" is now size_t.
+
+	* oct-obj.h (octave_value_list::octave_value_list (double),
+	octave_value_list::octave_value_list (const Matrix&),
+	octave_value_list::octave_value_list (const DiagMatrix&),
+	octave_value_list::octave_value_list (const RowVector&),
+	octave_value_list::octave_value_list (const ColumnVector&),
+	octave_value_list::octave_value_list (const Complex&),
+	octave_value_list::octave_value_list (const ComplexMatrix&),
+	octave_value_list::octave_value_list (const ComplexDiagMatrix&),
+	octave_value_list::octave_value_list (const ComplexRowVector&),
+	octave_value_list::octave_value_list (const ComplexColumnVector&),
+	octave_value_list::octave_value_list (const char *),
+	octave_value_list::octave_value_list (const std::string&),
+	octave_value_list::octave_value_list (const string_vector&),
+	octave_value_list::octave_value_list (double, double, double),
+	octave_value_list::octave_value_list (const Range&): Delete.
+	Adjust uses of octave_value/octave_value_list to handle this change.
+
+	* ov.cc (octave_value::octave_value (int)): New constructor.
+	* ov.h: Provide decl.
+	In files that construct integer-valued octave_value objects, use
+	ints instead of casing to double.
+
 2002-12-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* load-save.cc (read_mat_ascii_data): Allow commas to separate values.
 	Try harder to convert filenames to valid identifiers in a
 	Matlab-compatible way.
 
 2002-12-18  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -67,17 +67,17 @@ r' * r = a.\n\
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("chol", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   if (arg_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  int info;
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -52,25 +52,25 @@ of the reciprocal condition number if re
 
   octave_value arg = args(0);
     
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
     {
-      retval = 1.0;
+      retval(0) = 1.0;
       return retval;
     }
 
   int arg_is_empty = empty_arg ("det", nr, nc);
   if (arg_is_empty < 0)
     return retval;
   if (arg_is_empty > 0)
-    return Matrix (1, 1, 1.0);
+    return octave_value (Matrix (1, 1, 1.0));
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("det");
       return retval;
     }
 
   if (arg.is_real_type ())
diff --git a/src/DLD-FUNCTIONS/expm.cc b/src/DLD-FUNCTIONS/expm.cc
--- a/src/DLD-FUNCTIONS/expm.cc
+++ b/src/DLD-FUNCTIONS/expm.cc
@@ -113,17 +113,17 @@ approximation when\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{Dq(a)}\n\
 @end ifinfo\n\
 is ill-conditioned.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("expm");
       return retval;
     }
@@ -133,17 +133,17 @@ is ill-conditioned.\n\
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("expm", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   if (arg_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("expm");
       return retval;
     }
 
   if (arg.is_real_type ())
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -42,17 +42,17 @@ is a matrix, @code{fft} computes the FFT
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
 specifying the number of elements of @var{a} to use.  If @var{a} is a\n\
 matrix, @var{n} specifies the number of rows of @var{a} to use.  If\n\
 @var{n} is larger than the size of @var{a}, @var{a} is resized and\n\
 padded with zeros.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("fft");
       return retval;
     }
@@ -81,17 +81,17 @@ padded with zeros.\n\
       return retval;
     }
 
   int arg_is_empty = empty_arg ("fft", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty || n_points == 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  if (m.rows () == 1)
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -40,17 +40,17 @@ DEFUN_DLD (fft2, args, ,
 Compute the two dimensional FFT of @var{a}.\n\
 \n\
 The optional arguments @var{n} and @var{m} may be used specify the\n\
 number of rows and columns of @var{a} to use.  If either of these is\n\
 larger than the size of @var{a}, @var{a} is resized and padded with\n\
 zeros.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("fft2");
       return retval;
     }
@@ -89,17 +89,17 @@ zeros.\n\
       return retval;
     }
 
   int arg_is_empty = empty_arg ("fft2", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty || n_rows == 0 || n_cols == 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  m.resize (n_rows, n_cols, 0.0);
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -46,40 +46,40 @@ static octave_value
 mk_gr_map (const octave_group& gr)
 {
   octave_value retval;
 
   if (gr)
     {
       Octave_map m;
 
-      m ["name"] = gr.name ();
-      m ["passwd"] = gr.passwd ();
-      m ["gid"] = static_cast<double> (gr.gid ());
-      m ["mem"] = gr.mem ();
+      m ["name"](0) = gr.name ();
+      m ["passwd"](0) = gr.passwd ();
+      m ["gid"](0) = static_cast<double> (gr.gid ());
+      m ["mem"](0) = gr.mem ();
 
       retval = m;
     }
   else
-    retval = 0.0;
+    retval = 0;
 
   return retval;
 }
 
 DEFUN_DLD (getgrent, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 Once the end of the data has been reached, @code{getgrent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
-  retval(0) = 0.0;
+  retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = mk_gr_map (octave_group::getgrent (msg));
@@ -97,17 +97,17 @@ DEFUN_DLD (getgrgid, args, ,
 Return the first entry from the group database with the group ID\n\
 @var{gid}.  If the group ID does not exist in the database,\n\
 @code{getgrgid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
-  retval(0) = 0.0;
+  retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
@@ -137,17 +137,17 @@ DEFUN_DLD (getgrnam, args, ,
 Return the first entry from the group database with the group name\n\
 @var{name}.  If the group name does not exist in the database,\n\
 @code{getgrname} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
-  retval(0) = 0.0;
+  retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
       if (! error_state)
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -46,44 +46,44 @@ static octave_value
 mk_pw_map (const octave_passwd& pw)
 {
   octave_value retval;
 
   if (pw)
     {
       Octave_map m;
 
-      m ["name"] = pw.name ();
-      m ["passwd"] = pw.passwd ();
-      m ["uid"] = static_cast<double> (pw.uid ());
-      m ["gid"] = static_cast<double> (pw.gid ());
-      m ["gecos"] = pw.gecos ();
-      m ["dir"] = pw.dir ();
-      m ["shell"] = pw.shell ();
+      m ["name"](0) = pw.name ();
+      m ["passwd"](0) = pw.passwd ();
+      m ["uid"](0) = static_cast<double> (pw.uid ());
+      m ["gid"](0) = static_cast<double> (pw.gid ());
+      m ["gecos"](0) = pw.gecos ();
+      m ["dir"](0) = pw.dir ();
+      m ["shell"](0) = pw.shell ();
 
       retval = m;
     }
   else
-    retval = 0.0;
+    retval = 0;
 
   return retval;
 }
 
 DEFUN_DLD (getpwent, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{pw_struct} = } getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary. Once the end of the data has been reached,\n\
 @code{getpwent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
-  retval(0) = 0.0;
+  retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
@@ -101,17 +101,17 @@ DEFUN_DLD (getpwuid, args, ,
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.  If the user ID does not exist in the\n\
 database, @code{getpwuid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
-  retval(0) = 0.0;
+  retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -133,39 +133,39 @@ elements @code{sec} (seconds) @code{usec
   Octave_map tv_tmp;
 
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
-  tv_tmp ["sec"] = static_cast<double> (ru.ru_utime.tv_sec);
-  tv_tmp ["usec"] = static_cast<double> (ru.ru_utime.tv_usec);
-  m ["utime"] = octave_value (tv_tmp);
+  tv_tmp ["sec"](0) = static_cast<double> (ru.ru_utime.tv_sec);
+  tv_tmp ["usec"](0) = static_cast<double> (ru.ru_utime.tv_usec);
+  m ["utime"](0) = octave_value (tv_tmp);
 
-  tv_tmp ["sec"] = static_cast<double> (ru.ru_stime.tv_sec);
-  tv_tmp ["usec"] = static_cast<double> (ru.ru_stime.tv_usec);
-  m ["stime"] = octave_value (tv_tmp);
+  tv_tmp ["sec"](0) = static_cast<double> (ru.ru_stime.tv_sec);
+  tv_tmp ["usec"](0) = static_cast<double> (ru.ru_stime.tv_usec);
+  m ["stime"](0) = octave_value (tv_tmp);
 
 #if ! defined (RUSAGE_TIMES_ONLY)
-  m ["maxrss"] = static_cast<double> (ru.ru_maxrss);
-  m ["ixrss"] = static_cast<double> (ru.ru_ixrss);
-  m ["idrss"] = static_cast<double> (ru.ru_idrss);
-  m ["isrss"] = static_cast<double> (ru.ru_isrss);
-  m ["minflt"] = static_cast<double> (ru.ru_minflt);
-  m ["majflt"] = static_cast<double> (ru.ru_majflt);
-  m ["nswap"] = static_cast<double> (ru.ru_nswap);
-  m ["inblock"] = static_cast<double> (ru.ru_inblock);
-  m ["oublock"] = static_cast<double> (ru.ru_oublock);
-  m ["msgsnd"] = static_cast<double> (ru.ru_msgsnd);
-  m ["msgrcv"] = static_cast<double> (ru.ru_msgrcv);
-  m ["nsignals"] = static_cast<double> (ru.ru_nsignals);
-  m ["nvcsw"] = static_cast<double> (ru.ru_nvcsw);
-  m ["nivcsw"] = static_cast<double> (ru.ru_nivcsw);
+  m ["maxrss"](0) = static_cast<double> (ru.ru_maxrss);
+  m ["ixrss"](0) = static_cast<double> (ru.ru_ixrss);
+  m ["idrss"](0) = static_cast<double> (ru.ru_idrss);
+  m ["isrss"](0) = static_cast<double> (ru.ru_isrss);
+  m ["minflt"](0) = static_cast<double> (ru.ru_minflt);
+  m ["majflt"](0) = static_cast<double> (ru.ru_majflt);
+  m ["nswap"](0) = static_cast<double> (ru.ru_nswap);
+  m ["inblock"](0) = static_cast<double> (ru.ru_inblock);
+  m ["oublock"](0) = static_cast<double> (ru.ru_oublock);
+  m ["msgsnd"](0) = static_cast<double> (ru.ru_msgsnd);
+  m ["msgrcv"](0) = static_cast<double> (ru.ru_msgrcv);
+  m ["nsignals"](0) = static_cast<double> (ru.ru_nsignals);
+  m ["nvcsw"](0) = static_cast<double> (ru.ru_nvcsw);
+  m ["nivcsw"](0) = static_cast<double> (ru.ru_nivcsw);
 #endif
 
 #else
 #if defined (HAVE_TIMES) && defined (HAVE_SYS_TIMES_H)
 
   struct tms t;
 
   times (&t);
@@ -173,56 +173,56 @@ elements @code{sec} (seconds) @code{usec
   unsigned long ticks;
   unsigned long seconds;
   unsigned long fraction;
 
   ticks = t.tms_utime + t.tms_cutime;
   fraction = ticks % HZ;
   seconds = ticks / HZ;
 
-  tv_tmp ["sec"] = static_cast<double> (seconds);
-  tv_tmp ["usec"] = static_cast<double> (fraction * 1e6 / HZ);
-  m ["utime"] = octave_value (tv_tmp);
+  tv_tmp ["sec"](0) = static_cast<double> (seconds);
+  tv_tmp ["usec"](0) = static_cast<double> (fraction * 1e6 / HZ);
+  m ["utime"](0) = octave_value (tv_tmp);
 
   ticks = t.tms_stime + t.tms_cstime;
   fraction = ticks % HZ;
   seconds = ticks / HZ;
 
-  tv_tmp ["sec"] = static_cast<double> (seconds);
-  tv_tmp ["usec"] = static_cast<double> (fraction * 1e6 / HZ);
-  m ["stime"] = octave_value (tv_tmp);
+  tv_tmp ["sec"](0) = static_cast<double> (seconds);
+  tv_tmp ["usec"](0) = static_cast<double> (fraction * 1e6 / HZ);
+  m ["stime"](0) = octave_value (tv_tmp);
 
 #else
 
-  tv_tmp ["sec"] = 0.0;
-  tv_tmp ["usec"] = 0.0;
-  m ["utime"] = octave_value (tv_tmp);
+  tv_tmp ["sec"](0) = 0;
+  tv_tmp ["usec"](0) = 0;
+  m ["utime"](0) = octave_value (tv_tmp);
 
-  tv_tmp ["sec"] = 0.0;
-  tv_tmp ["usec"] = 0.0;
-  m ["stime"] = octave_value (tv_tmp);
+  tv_tmp ["sec"](0) = 0;
+  tv_tmp ["usec"](0) = 0;
+  m ["stime"](0) = octave_value (tv_tmp);
 
 #endif
 
   double tmp = lo_ieee_nan_value ();
 
-  m ["maxrss"] = tmp;
-  m ["ixrss"] = tmp;
-  m ["idrss"] = tmp;
-  m ["isrss"] = tmp;
-  m ["minflt"] = tmp;
-  m ["majflt"] = tmp;
-  m ["nswap"] = tmp;
-  m ["inblock"] = tmp;
-  m ["oublock"] = tmp;
-  m ["msgsnd"] = tmp;
-  m ["msgrcv"] = tmp;
-  m ["nsignals"] = tmp;
-  m ["nvcsw"] = tmp;
-  m ["nivcsw"] = tmp;
+  m ["maxrss"](0) = tmp;
+  m ["ixrss"](0) = tmp;
+  m ["idrss"](0) = tmp;
+  m ["isrss"](0) = tmp;
+  m ["minflt"](0) = tmp;
+  m ["majflt"](0) = tmp;
+  m ["nswap"](0) = tmp;
+  m ["inblock"](0) = tmp;
+  m ["oublock"](0) = tmp;
+  m ["msgsnd"](0) = tmp;
+  m ["msgrcv"](0) = tmp;
+  m ["nsignals"](0) = tmp;
+  m ["nvcsw"](0) = tmp;
+  m ["nivcsw"](0) = tmp;
 
 #endif
 
   return octave_value (m);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/ifft.cc b/src/DLD-FUNCTIONS/ifft.cc
--- a/src/DLD-FUNCTIONS/ifft.cc
+++ b/src/DLD-FUNCTIONS/ifft.cc
@@ -43,17 +43,17 @@ of @var{a}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
 specifying the number of elements of @var{a} to use.  If @var{a} is a\n\
 matrix, @var{n} specifies the number of rows of @var{a} to use.  If\n\
 @var{n} is larger than the size of @var{a}, @var{a} is resized and\n\
 padded with zeros.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("ifft");
       return retval;
     }
@@ -82,17 +82,17 @@ padded with zeros.\n\
       return retval;
     }
 
   int arg_is_empty = empty_arg ("ifft", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty || n_points == 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  if (m.rows () == 1)
diff --git a/src/DLD-FUNCTIONS/ifft2.cc b/src/DLD-FUNCTIONS/ifft2.cc
--- a/src/DLD-FUNCTIONS/ifft2.cc
+++ b/src/DLD-FUNCTIONS/ifft2.cc
@@ -40,17 +40,17 @@ DEFUN_DLD (ifft2, args, ,
 Compute the two dimensional inverse FFT of @var{a}.\n\
 \n\
 The optional arguments @var{n} and @var{m} may be used specify the\n\
 number of rows and columns of @var{a} to use.  If either of these is\n\
 larger than the size of @var{a}, @var{a} is resized and padded with\n\
 zeros.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("ifft2");
       return retval;
     }
@@ -89,17 +89,17 @@ zeros.\n\
       return retval;
     }
 
   int arg_is_empty = empty_arg ("ifft2", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty || n_rows == 0 || n_cols == 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  m.resize (n_rows, n_cols, 0.0);
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -54,17 +54,17 @@ ill-conditioned matrix if the reciprocal
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("inverse");
       return retval;
     }
 
   if (arg.is_real_type ())
diff --git a/src/DLD-FUNCTIONS/log.cc b/src/DLD-FUNCTIONS/log.cc
--- a/src/DLD-FUNCTIONS/log.cc
+++ b/src/DLD-FUNCTIONS/log.cc
@@ -57,17 +57,17 @@ needs to be improved to be more robust.\
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("logm", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_scalar ())
     {
       double d = arg.double_value ();
       if (d > 0.0)
 	retval(0) = log (d);
       else
 	{
@@ -176,17 +176,17 @@ needs to be improved to be more robust.\
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("sqrtm", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_scalar ())
     {
       double d = arg.double_value ();
       if (d > 0.0)
 	retval(0) = sqrt (d);
       else
 	{
diff --git a/src/DLD-FUNCTIONS/odessa.cc b/src/DLD-FUNCTIONS/odessa.cc
--- a/src/DLD-FUNCTIONS/odessa.cc
+++ b/src/DLD-FUNCTIONS/odessa.cc
@@ -225,29 +225,29 @@ odessa_user_b (const ColumnVector& x, do
 	}
       else
 	gripe_user_supplied_eval ("odessa");
     }
 
   return retval;
 }
 
-static octave_value_list
+static octave_value
 make_list (const Array<Matrix>& m_array)
 {
   octave_value_list retval;
 
   int len = m_array.length ();
 
   retval.resize (len);
 
   for (int i = 0; i < len; i++)
     retval(i) = m_array(i);
 
-  return retval;
+  return octave_value (retval);
 }
 
 #define ODESSA_ABORT() \
   do \
     { \
       unwind_protect::run_frame ("Fodessa"); \
       return retval; \
     } \
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -41,17 +41,17 @@ If the second argument is omitted, it is
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
 @end example\n\
 \n\
 @noindent\n\
 where @code{sigma_max (@var{x})} is the maximal singular value of @var{x}.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("pinv");
       return retval;
     }
@@ -71,17 +71,17 @@ where @code{sigma_max (@var{x})} is the 
       return retval;
     }
 
   int arg_is_empty = empty_arg ("pinv", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	retval = m.pseudo_inverse (tol);
     }
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -54,17 +54,17 @@ using standard @sc{Lapack} subroutines. 
 @example\n\
 @group\n\
 syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
      @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 3 || nargout > 1)
     {
       print_usage ("syl");
       return retval;
     }
@@ -82,17 +82,17 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
   int c_nr = arg_c.rows ();
   int c_nc = arg_c.columns ();
 
   int arg_a_is_empty = empty_arg ("syl", a_nr, a_nc);
   int arg_b_is_empty = empty_arg ("syl", b_nr, b_nc);
   int arg_c_is_empty = empty_arg ("syl", c_nr, c_nc);
 
   if (arg_a_is_empty > 0 && arg_b_is_empty > 0 && arg_c_is_empty > 0)
-    return Matrix ();
+    return octave_value (Matrix ());
   else if (arg_a_is_empty || arg_b_is_empty || arg_c_is_empty)
     return retval;
 
   // Arguments are not empty, so check for correct dimensions.
 
   if (a_nr != a_nc || b_nr != b_nc)
     {
       gripe_square_matrix_required ("syl: first two parameters:");
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -35,46 +35,46 @@ Software Foundation, 59 Temple Place - S
 
 // Date and time functions.
 
 static Octave_map
 mk_tm_map (const octave_base_tm& t)
 {
   Octave_map m;
 
-  m ["usec"] = static_cast<double> (t.usec ());
-  m ["sec"] = static_cast<double> (t.sec ());
-  m ["min"] = static_cast<double> (t.min ());
-  m ["hour"] = static_cast<double> (t.hour ());
-  m ["mday"] = static_cast<double> (t.mday ());
-  m ["mon"] = static_cast<double> (t.mon ());
-  m ["year"] = static_cast<double> (t.year ());
-  m ["wday"] = static_cast<double> (t.wday ());
-  m ["yday"] = static_cast<double> (t.yday ());
-  m ["isdst"] = static_cast<double> (t.isdst ());
-  m ["zone"]  = t.zone ();
+  m ["usec"](0) = static_cast<double> (t.usec ());
+  m ["sec"](0) = static_cast<double> (t.sec ());
+  m ["min"](0) = static_cast<double> (t.min ());
+  m ["hour"](0) = static_cast<double> (t.hour ());
+  m ["mday"](0) = static_cast<double> (t.mday ());
+  m ["mon"](0) = static_cast<double> (t.mon ());
+  m ["year"](0) = static_cast<double> (t.year ());
+  m ["wday"](0) = static_cast<double> (t.wday ());
+  m ["yday"](0) = static_cast<double> (t.yday ());
+  m ["isdst"](0) = static_cast<double> (t.isdst ());
+  m ["zone"](0) = t.zone ();
 
   return m;
 }
 
 static octave_base_tm
 extract_tm (Octave_map &m)
 {
   octave_base_tm tm;
 
-  tm.usec (static_cast<int> (m ["usec"](0) . double_value ()));
-  tm.sec (static_cast<int> (m ["sec"](0) . double_value ()));
-  tm.min (static_cast<int> (m ["min"](0) . double_value ()));
-  tm.hour (static_cast<int> (m ["hour"](0) . double_value ()));
-  tm.mday (static_cast<int> (m ["mday"](0) . double_value ()));
-  tm.mon (static_cast<int> (m ["mon"](0) . double_value ()));
-  tm.year (static_cast<int> (m ["year"](0) . double_value ()));
-  tm.wday (static_cast<int> (m ["wday"](0) . double_value ()));
-  tm.yday (static_cast<int> (m ["yday"](0) . double_value ()));
-  tm.isdst (static_cast<int> (m ["isdst"](0) . double_value ()));
+  tm.usec (m ["usec"](0) . int_value ());
+  tm.sec (m ["sec"](0) . int_value ());
+  tm.min (m ["min"](0) . int_value ());
+  tm.hour (m ["hour"](0) . int_value ());
+  tm.mday (m ["mday"](0) . int_value ());
+  tm.mon (m ["mon"](0) . int_value ());
+  tm.year (m ["year"](0) . int_value ());
+  tm.wday (m ["wday"](0) . int_value ());
+  tm.yday (m ["yday"](0) . int_value ());
+  tm.isdst (m ["isdst"](0) . int_value ());
   tm.zone (m ["zone"](0) . string_value ());
 
   return tm;
 }
 
 DEFUN_DLD (time, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} time ()\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -48,17 +48,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifndef ABS
 #define ABS(x) (((x) < 0) ? (-x) : (x))
 #endif
 
 #define ANY_ALL(FCN) \
  \
-  octave_value_list retval; \
+  octave_value retval; \
  \
   int nargin = args.length (); \
  \
   if (nargin == 1 || nargin == 2) \
     { \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
       if (! error_state) \
@@ -183,17 +183,17 @@ map_m_m (d_dd_fcn f, const Matrix& x, co
 
 DEFUN (atan2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.  The result is in range -pi to pi.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_value arg_y = args(0);
       octave_value arg_x = args(1);
 
@@ -202,17 +202,17 @@ and @var{x}.  The result is in range -pi
 
       int x_nr = arg_x.rows ();
       int x_nc = arg_x.columns ();
 
       int arg_y_empty = empty_arg ("atan2", y_nr, y_nc);
       int arg_x_empty = empty_arg ("atan2", x_nr, x_nc);
 
       if (arg_y_empty > 0 && arg_x_empty > 0)
-	return Matrix ();
+	return octave_value (Matrix ());
       else if (arg_y_empty || arg_x_empty)
 	return retval;
 
       int y_is_scalar = (y_nr == 1 && y_nc == 1);
       int x_is_scalar = (x_nr == 1 && x_nc == 1);
 
       if (y_is_scalar && x_is_scalar)
 	{
@@ -268,17 +268,17 @@ and @var{x}.  The result is in range -pi
   else
     print_usage ("atan2");
 
   return retval;
 }
 
 #define DATA_REDUCTION(FCN) \
  \
-  octave_value_list retval; \
+  octave_value retval; \
  \
   int nargin = args.length (); \
  \
   if (nargin == 1 || nargin == 2) \
     { \
       octave_value arg = args(0); \
  \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
@@ -287,24 +287,24 @@ and @var{x}.  The result is in range -pi
 	{ \
 	  if (dim <= 1 && dim >= -1) \
 	    { \
 	      if (arg.is_real_type ()) \
 		{ \
 		  Matrix tmp = arg.matrix_value (); \
  \
 		  if (! error_state) \
-		    retval(0) = tmp.FCN (dim); \
+		    retval = tmp.FCN (dim); \
 		} \
 	      else if (arg.is_complex_type ()) \
 		{ \
 		  ComplexMatrix tmp = arg.complex_matrix_value (); \
  \
 		  if (! error_state) \
-		    retval(0) = tmp.FCN (dim); \
+		    retval = tmp.FCN (dim); \
 		} \
 	      else \
 		{ \
 		  gripe_wrong_type_arg (#FCN, arg); \
 		  return retval; \
 		} \
 	    } \
 	  else \
@@ -363,25 +363,25 @@ make_diag (const Matrix& v, int k)
     }
 
   if (nr == 1)
     {
       int n = nc + ABS (k);
       Matrix m (n, n, 0.0);
       for (int i = 0; i < nc; i++)
 	m (i+roff, i+coff) = v (0, i);
-      retval = octave_value (m);
+      retval = m;
     }
   else
     {
       int n = nr + ABS (k);
       Matrix m (n, n, 0.0);
       for (int i = 0; i < nr; i++)
 	m (i+roff, i+coff) = v (i, 0);
-      retval = octave_value (m);
+      retval = m;
     }
 
   return retval;
 }
 
 static octave_value
 make_diag (const ComplexMatrix& v, int k)
 {
@@ -405,25 +405,25 @@ make_diag (const ComplexMatrix& v, int k
     }
 
   if (nr == 1)
     {
       int n = nc + ABS (k);
       ComplexMatrix m (n, n, 0.0);
       for (int i = 0; i < nc; i++)
 	m (i+roff, i+coff) = v (0, i);
-      retval = octave_value (m);
+      retval = m;
     }
   else
     {
       int n = nr + ABS (k);
       ComplexMatrix m (n, n, 0.0);
       for (int i = 0; i < nr; i++)
 	m (i+roff, i+coff) = v (i, 0);
-      retval = octave_value (m);
+      retval = m;
     }
 
   return retval;
 }
 
 static octave_value
 make_diag (const octave_value& arg)
 {
@@ -555,17 +555,17 @@ diag ([1, 2, 3], 1)\n\
      @result{}  0  1  0  0\n\
          0  0  2  0\n\
          0  0  0  3\n\
          0  0  0  0\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = make_diag (args(0));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     retval = make_diag (args(0), args(1));
   else
@@ -594,17 +594,17 @@ odd definition is used for compatibility
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       int len = args(0).length ();
 
       if (! error_state)
-	retval = static_cast<double> (len);
+	retval = len;
     }
   else
     print_usage ("length");
 
   return retval;
 }
 
 DEFUN (size, args, nargout,
@@ -649,36 +649,36 @@ returns the number of columns in the giv
       int nr = args(0).rows ();
       int nc = args(0).columns ();
 
       if (nargout == 0 || nargout == 1)
 	{
 	  Matrix m (1, 2);
 	  m (0, 0) = nr;
 	  m (0, 1) = nc;
-	  retval = m;
+	  retval(0) = m;
 	}
       else if (nargout == 2)
 	{
-	  retval(1) = static_cast<double> (nc);
-	  retval(0) = static_cast<double> (nr);
+	  retval(1) = nc;
+	  retval(0) = nr;
 	}
     }
   else if (nargin == 2 && nargout < 2)
     {
       int nd = args(1).nint_value ();
 
       if (error_state)
 	error ("size: expecting scalar as second argument");
       else
 	{
 	  if (nd == 1)
-	    retval(0) = static_cast<double> (args(0).rows ());
+	    retval(0) = args(0).rows ();
 	  else if (nd == 2)
-	    retval(0) = static_cast<double> (args(0).columns ());
+	    retval(0) = args(0).columns ();
 	  else
 	    error ("size: invalid second argument -- expecting 1 or 2");
 	}
     }
   else
     print_usage ("size");
 
   return retval;
@@ -762,26 +762,26 @@ Return true if @var{x} is a real-valued 
 
 DEFUN (isempty, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isempty (@var{a})\n\
 Return 1 if @var{a} is an empty matrix (either the number of rows, or\n\
 the number of columns, or both are zero).  Otherwise, return 0.\n\
 @end deftypefn")
 {
-  double retval = 0.0;
+  octave_value retval = false;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_matrix_type ())
-	retval = static_cast<double> (arg.rows () == 0 || arg.columns () == 0);
+	retval = (arg.rows () == 0 || arg.columns () == 0);
       else if (arg.is_list () || arg.is_string ())
-	retval = static_cast<double> (arg.length () == 0);
+	retval = (arg.length () == 0);
     }
   else
     print_usage ("isempty");
 
   return retval;
 }
 
 DEFUN (isnumeric, args, ,
@@ -817,26 +817,26 @@ Return nonzero if @var{x} is a list.\n\
 }
 
 DEFUN (ismatrix, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return 1 if @var{a} is a matrix.  Otherwise, return 0.\n\
 @end deftypefn")
 {
-  double retval = 0.0;
+  octave_value retval = false;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_scalar_type () || arg.is_range ())
-	retval = 1.0;
+	retval = true;
       else if (arg.is_matrix_type ())
-	retval = static_cast<double> (arg.rows () >= 1 && arg.columns () >= 1);
+	retval = (arg.rows () >= 1 && arg.columns () >= 1);
     }
   else
     print_usage ("ismatrix");
 
   return retval;
 }
 
 DEFUN (isstruct, args, ,
@@ -858,26 +858,26 @@ Return 1 if the value of the expression 
 DEFUN (struct_elements, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct_elements (@var{struct})\n\
 Return a list of strings naming the elements of the structure\n\
 @var{struct}.  It is an error to call @code{struct_elements} with an\n\
 argument that is not a structure.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args (0).is_map ())
 	{
 	  Octave_map m = args(0).map_value ();
-	  retval(0) = m.keys ();
+	  retval = m.keys ();
 	}
       else
 	gripe_wrong_type_arg ("struct_elements", args (0));
     }
   else
     print_usage ("struct_elements");
 
   return retval;
@@ -886,34 +886,34 @@ argument that is not a structure.\n\
 DEFUN (struct_contains, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct_contains (@var{expr}, @var{name})\n\
 Return 1 if the expression @var{expr} is a structure and it includes an\n\
 element named @var{name}.  The first argument must be a structure and\n\
 the second must be a string.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      retval = 0.0;
+      retval = false;
 
       // XXX FIXME XXX -- should this work for all types that can do
       // structure reference operations?
 
       if (args(0).is_map () && args(1).is_string ())
 	{
 	  std::string key = args(1).string_value ();
 
 	  Octave_map m = args(0).map_value ();
 
-	  retval = static_cast<double> (m.contains (key));
+	  retval = m.contains (key);
 	}
       else
 	print_usage ("struct_contains");
     }
   else
     print_usage ("struct_contains");
 
   return retval;
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -139,17 +139,17 @@ The rline returned is the real line that
 	  result = cmds->set_breakpoint (line);
 	}
       else
 	error ("dbstop: unable to find the function requested\n");	
     }
   else
     error ("dbstop: one argument when in a function and two when not\n");
 
-  retval = static_cast<double> (result);
+  retval = result;
 
   return retval;
 }
 
 DEFCMD (dbclear, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbclear (func, line)\n\
 Delete a breakpoint in a function\n\
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -216,17 +216,17 @@ from system to system.\n\
 DEFALIAS (dir, ls);
 
 DEFUN (pwd, , nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pwd ()\n\
 Return the current working directory.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   std::string directory = octave_env::getcwd ();
 
   if (directory.empty ())
     warning ("pwd: can't find working directory!");
   else
     {
       if (nargout == 0)
@@ -309,17 +309,17 @@ system-dependent error message.\n\
 	gripe_wrong_type_arg ("mkdir", args(0));
       else
 	{
 	  std::string msg;
 
 	  int status = file_ops::mkdir (file_ops::tilde_expand (dirname),
 					0777, msg);
 
-	  retval(0) = static_cast<double> (status);
+	  retval(0) = status;
 
 	  if (status < 0)
 	    retval(1) = msg;
 	}
     }
   else
     print_usage ("mkdir");
 
@@ -348,17 +348,17 @@ system-dependent error message.\n\
       if (error_state)
 	gripe_wrong_type_arg ("rmdir", args(0));
       else
 	{
 	  std::string msg;
 
 	  int status = file_ops::rmdir (file_ops::tilde_expand (dirname), msg);
 
-	  retval(0) = static_cast<double> (status);
+	  retval(0) = status;
 
 	  if (status < 0)
 	    retval(1) = msg;
 	}
     }
   else
     print_usage ("rmdir");
 
@@ -393,17 +393,17 @@ system-dependent error message.\n\
 	  if (error_state)
 	    gripe_wrong_type_arg ("link", args(1));
 	  else
 	    {
 	      std::string msg;
 
 	      int status = file_ops::link (from, to, msg);
 
-	      retval(0) = static_cast<double> (status);
+	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
     print_usage ("link");
@@ -439,17 +439,17 @@ system-dependent error message.\n\
 	  if (error_state)
 	    gripe_wrong_type_arg ("symlink", args(1));
 	  else
 	    {
 	      std::string msg;
 
 	      int status = file_ops::symlink (from, to, msg);
 
-	      retval(0) = static_cast<double> (status);
+	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
     print_usage ("symlink");
@@ -484,17 +484,17 @@ system-dependent error message.\n\
 	{
 	  std::string result;
 	  std::string msg;
 
 	  int status = file_ops::readlink (symlink, result, msg);
 
 	  retval(0) = result;
 
-	  retval(1) = static_cast<double> (status);
+	  retval(1) = status;
 
 	  if (status < 0)
 	    retval(2) = msg;
 	}
     }
   else
     print_usage ("readlink");
 
@@ -529,17 +529,17 @@ system-dependent error message.\n\
 	  if (error_state)
 	    gripe_wrong_type_arg ("rename", args(1));
 	  else
 	    {
 	      std::string msg;
 
 	      int status = file_ops::rename (from, to, msg);
 
-	      retval(0) = static_cast<double> (status);
+	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
     print_usage ("rename");
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -333,17 +333,17 @@ warn_reload_forces_clear (void)
   Vwarn_reload_forces_clear = check_preference ("warn_reload_forces_clear");
 
   return 0;
 }
 
 void
 symbols_of_dynamic_ld (void)
 {
-  DEFVAR (warn_reload_forces_clear, 1.0, warn_reload_forces_clear,
+  DEFVAR (warn_reload_forces_clear, true, warn_reload_forces_clear,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_reload_forces_clear\n\
 If several functions have been loaded from the same file, Octave must\n\
 clear all the functions before any one of them can be reloaded.  If\n\
 @code{warn_reload_forces_clear}, Octave will warn you when this happens,\n\
 and print a list of the additional functions that it is forced to clear.\n\
 @end defvr");
 }
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -764,34 +764,34 @@ debug_on_warning (void)
   Vdebug_on_warning = check_preference ("debug_on_warning");
 
   return 0;
 }
 
 void
 symbols_of_error (void)
 {
-  DEFVAR (beep_on_error, 0.0, beep_on_error,
+  DEFVAR (beep_on_error, false, beep_on_error,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} beep_on_error\n\
 If the value of @code{beep_on_error} is nonzero, Octave will try\n\
 to ring your terminal's bell before printing an error message.  The\n\
 default value is 0.\n\
 @end defvr");
 
-  DEFVAR (debug_on_error, 0.0, debug_on_error,
+  DEFVAR (debug_on_error, false, debug_on_error,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} debug_on_error\n\
 If the value of @code{debug_on_error} is nonzero, Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
 the top-level error message).  The default value is 0.\n\
 @end defvr");
 
-  DEFVAR (debug_on_warning, 0.0, debug_on_warning,
+  DEFVAR (debug_on_warning, false, debug_on_warning,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} debug_on_warning\n\
 If the value of @code{debug_on_warning} is nonzero, Octave will try\n\
 to enter the debugger when a warning is encountered.  The default\n\
 value is 0.\n\
 @end defvr");
 
   DEFCONST (error_text, "",
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -155,60 +155,59 @@ Return true if @var{x} is a stream objec
 DEFUN (fclose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclose (@var{fid})\n\
 Closes the specified file.  If an error is encountered while trying to\n\
 close the file, an error message is printed and @code{fclose} returns\n\
 0.  Otherwise, it returns 1.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
-    retval = static_cast<double> (octave_stream_list::remove (args(0),
-				  "fclose"));
+    retval = octave_stream_list::remove (args(0), "fclose");
   else
     print_usage ("fclose");
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fflush (@var{fid})\n\
 Flush output to @var{fid}.  This is useful for ensuring that all\n\
 pending output makes it to the screen before some other event occurs.\n\
 For example, it is always a good idea to flush the standard output\n\
 stream before calling @code{input}.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       // XXX FIXME XXX -- any way to avoid special case for stdout?
 
       int fid = octave_stream_list::get_file_number (args (0));
 
       if (fid == 1)
 	{
 	  flush_octave_stdout ();
 
-	  retval = 0.0;
+	  retval = 0;
 	}
       else
 	{
 	  octave_stream os = octave_stream_list::lookup (fid, "fflush");
 
 	  if (! error_state)
-	    retval = static_cast<double> (os.flush ());
+	    retval = os.flush ();
 	}
     }
   else
     print_usage ("fflush");
 
   return retval;
 }
 
@@ -222,29 +221,29 @@ the possible trailing newline, are retur
 If @var{len} is omitted, @code{fgetl} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgetl} returns @minus{}1.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = 0.0;
-  retval(0) = -1.0;
+  retval(1) = 0;
+  retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fgetl");
 
       if (! error_state)
 	{
 	  octave_value len_arg = (nargin == 2)
-	    ? args(1) : octave_value (static_cast<double> (INT_MAX));
+	    ? args(1) : octave_value (INT_MAX);
 
 	  bool err = false;
 
 	  std::string tmp = os.getl (len_arg, err);
 
 	  if (! err)
 	    {
 	      retval(1) = static_cast<double> (tmp.length ());
@@ -280,17 +279,17 @@ If there are no more characters to read,
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fgets");
 
       if (! error_state)
 	{
 	  octave_value len_arg = (nargin == 2)
-	    ? args(1) : octave_value (static_cast<double> (INT_MAX));
+	    ? args(1) : octave_value (INT_MAX);
 
 	  bool err = false;
 
 	  std::string tmp = os.gets (len_arg, err);
 
 	  if (! err)
 	    {
 	      retval(1) = static_cast<double> (tmp.length ());
@@ -552,26 +551,26 @@ freport ()\n\
 DEFUN (frewind, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} frewind (@var{fid})\n\
 Move the file pointer to the beginning of the file @var{fid}, returning\n\
 1 for success, and 0 if an error was encountered.  It is equivalent to\n\
 @code{fseek (@var{fid}, 0, SEEK_SET)}.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "frewind");
 
       if (! error_state)
-	retval = static_cast<double> (os.rewind ());
+	retval = os.rewind ();
     }
   else
     print_usage ("frewind");
 
   return retval;
 }
 
 DEFUN (fseek, args, ,
@@ -581,46 +580,46 @@ Set the file pointer to any location wit
 pointer is positioned @var{offset} characters from the @var{origin},\n\
 which may be one of the predefined variables @code{SEEK_CUR} (current\n\
 position), @code{SEEK_SET} (beginning), or @code{SEEK_END} (end of\n\
 file). If @var{origin} is omitted, @code{SEEK_SET} is assumed.  The\n\
 offset must be zero, or a value returned by @code{ftell} (in which case\n\
 @var{origin} must be @code{SEEK_SET}.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
       if (! error_state)
 	{
 	  octave_value origin_arg = (nargin == 3)
 	    ? args(2) : octave_value (-1.0);
 
-	  retval = static_cast<double> (os.seek (args(1), origin_arg));
+	  retval = os.seek (args(1), origin_arg);
 	}
     }
   else
     print_usage ("fseek");
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters\n\
 from the beginning of the file @var{fid}.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
       if (! error_state)
@@ -634,17 +633,17 @@ from the beginning of the file @var{fid}
 
 DEFUN (fprintf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 This function is just like @code{printf}, except that the output is\n\
 written to the stream @var{fid} instead of @code{stdout}.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
   bool return_char_count = true;
 
   int nargin = args.length ();
 
   if (nargin > 1 || (nargin > 0 && args(0).is_string ()))
     {
       octave_stream os;
       int fmt_n = 0;
@@ -697,17 +696,17 @@ written to the stream @var{fid} instead 
 }
 
 DEFUN (fputs, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fputs (@var{fid}, @var{string})\n\
 Write a string to a file with no formatting.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fputs");
 
       if (! error_state)
@@ -754,17 +753,17 @@ converted.\n\
 	      if (nargin > 1)
 		{
 		  tmp_args.resize (nargin-1, octave_value ());
 
 		  for (int i = 1; i < nargin; i++)
 		    tmp_args(i-1) = args(i);
 		}
 
-	      retval(2) = static_cast<double> (os.printf (fmt, tmp_args));
+	      retval(2) = os.printf (fmt, tmp_args);
 	      retval(1) = os.error ();
 	      retval(0) = ostr->str ();
 	    }
 	  else
 	    ::error ("sprintf: format must be a string");
 	}
       else
 	::error ("sprintf: unable to create output buffer");
@@ -858,17 +857,17 @@ conversions is returned in @var{count}\n
 		  Array<double> size = (nargin == 3)
 		    ? args(2).vector_value ()
 		    : Array<double> (1, lo_ieee_inf_value ());
 
 		  if (! error_state)
 		    {
 		      octave_value tmp = os.scanf (fmt, size, count);
 
-		      retval(1) = static_cast<double> (count);
+		      retval(1) = count;
 		      retval(0) = tmp;
 		    }
 		}
 	      else
 		::error ("fscanf: format must be a string");
 	    }
 	}
       else
@@ -947,17 +946,17 @@ string is treated as an end-of-file cond
 
 		      // XXX FIXME XXX -- is this the right thing to do?
 		      // Extract error message first, because getting
 		      // position will clear it.
 		      std::string errmsg = os.error ();
 
 		      retval(3) = static_cast<double> (os.tell () + 1);
 		      retval(2) = errmsg;
-		      retval(1) = static_cast<double> (count);
+		      retval(1) = count;
 		      retval(0) = tmp;
 		    }
 		  else
 		    ::error ("sscanf: format must be a string");
 		}
 	      else
 		::error ("sscanf: unable to create temporary input buffer");
 	    }
@@ -1196,17 +1195,17 @@ values read is returned in @code{count}\
 
 	  octave_value arch = (nargin > 4)
 	    ? args(4) : octave_value ("unknown");
 
 	  int count = -1;
 
 	  octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
-	  retval(1) = static_cast<double> (count);
+	  retval(1) = count;
 	  retval(0) = tmp;
 	}
     }
   else
     print_usage ("fread");
 
   return retval;
 }
@@ -1268,17 +1267,17 @@ the file.  The values are extracted in c
 \n\
 The remaining arguments @var{precision}, @var{skip}, and @var{arch} are\n\
 optional, and are interpreted as described for @code{fread}.\n\
 \n\
 The behavior of @code{fwrite} is undefined if the values in @var{data}\n\
 are too large to fit in the specified precision.\n\
 @end deftypefn")
 {
-  octave_value retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 6)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
 
       if (! error_state)
@@ -1309,17 +1308,17 @@ DEFUN (feof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for a given\n\
 file and 0 otherwise.  Note that it will only return 1 if the end of the\n\
 file has already been encountered, not if the next read operation will\n\
 result in an end-of-file condition.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "feof");
 
       if (! error_state)
@@ -1361,17 +1360,17 @@ error condition.\n\
 	      else
 		return retval;
 	    }
 
 	  int error_number = 0;
 
 	  std::string error_message = os.error (clear, error_number);
 
-	  retval(1) = static_cast<double> (error_number);
+	  retval(1) = error_number;
 	  retval(0) = error_message;
 	}
     }
   else
     print_usage ("ferror");
 
   return retval;
 }
@@ -1404,17 +1403,17 @@ while (isstr (s = fgets (fid)))\n\
 endwhile\n\
      @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
      @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
      @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
@@ -1452,23 +1451,22 @@ endwhile\n\
 
 DEFUN (pclose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pclose (@var{fid})\n\
 Close a file identifier that was opened by @code{popen}.  You may also\n\
 use @code{fclose} for the same purpose.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
-    retval = static_cast<double> (octave_stream_list::remove (args(0),
-				  "pclose"));
+    retval = octave_stream_list::remove (args(0), "pclose");
   else
     print_usage ("pclose");
 
   return retval;
 }
 
 DEFUN (tmpnam, args, ,
  "-*- texinfo -*-\n\
@@ -1566,28 +1564,28 @@ Set the permission mask for file creatio
 	  status = -1;
 	  ::error ("umask: expecting integer argument");
 	}
     }
   else
     print_usage ("umask");
 
   if (status >= 0)
-    retval(0) = static_cast<double> (status);
+    retval(0) = status;
 
   return retval;
 }
 
 void
 symbols_of_file_io (void)
 {
   // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
   // this way for Matlab compatibility.
 
-  DEFCONSTX ("SEEK_SET", SBV_SEEK_SET, -1.0,
+  DEFCONSTX ("SEEK_SET", SBV_SEEK_SET, -1,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} SEEK_SET\n\
 @defvrx {Built-in Variable} SEEK_CUR\n\
 @defvrx {Built-in Variable} SEEK_END\n\
 These variables may be used as the optional third argument for the\n\
 function @code{fseek}.\n\
 \n\
 @table @code\n\
@@ -1597,23 +1595,23 @@ Position file relative to the beginning.
 @item SEEK_CUR\n\
 Position file relative to the current position.\n\
 \n\
 @item SEEK_END\n\
 used with fseek to position file relative to the end.\n\
 @end table\n\
 @end defvr");
 
-  DEFCONSTX ("SEEK_CUR", SBV_SEEK_CUR, 0.0,
+  DEFCONSTX ("SEEK_CUR", SBV_SEEK_CUR, 0,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} SEEK_CUR\n\
 See SEEK_SET.\n\
 @end defvr");
 
-  DEFCONSTX ("SEEK_END", SBV_SEEK_END, 1.0,
+  DEFCONSTX ("SEEK_END", SBV_SEEK_END, 1,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} SEEK_END\n\
 See SEEK_SET.\n\
 @end defvr");
 
   DEFCONSTX ("stdin", SBV_stdin, stdin_file,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} stdin\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1097,17 +1097,17 @@ default initial value may be overridden 
   DEFVAR (MAKEINFO_PROGRAM, Vmakeinfo_prog, makeinfo_prog,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} MAKEINFO_PROGRAM\n\
 The variable @code{MAKEINFO_PROGRAM} names the makeinfo program that\n\
 Octave runs to format help text that contains Texinfo markup commands.\n\
 Its default initial value is @code{\"makeinfo\"}.\n\
 @end defvr");
 
-  DEFVAR (suppress_verbose_help_message, 0.0, suppress_verbose_help_message,
+  DEFVAR (suppress_verbose_help_message, false, suppress_verbose_help_message,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} suppress_verbose_help_message\n\
 If the value of @code{suppress_verbose_help_message} is nonzero, Octave\n\
 will not add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
 @end defvr");
 }
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -560,22 +560,17 @@ get_user_input (const octave_value_list&
 
       size_t len = input_buf.length ();
 
       if (len < 1)
 	{
 	  if (debug)
 	    goto again;
 	  else
-	    {
-	      if (read_as_string)
-		return "";
-	      else
-		return Matrix ();
-	    }
+	    return read_as_string ? octave_value ("") : octave_value (Matrix ());
 	}
 
       if (debug)
 	{
 	  if (match_sans_spaces_semi ("exit", input_buf)
 	      || match_sans_spaces_semi ("quit", input_buf)
 	      || match_sans_spaces_semi ("return", input_buf)
 	      || match_sans_spaces_semi ("dbg_cont", input_buf))
@@ -714,17 +709,19 @@ do_keyboard (const octave_value_list& ar
   command_history::ignore_entries (false);
 
   unwind_protect::add (restore_command_history, 0);
 
   unwind_protect_bool (Vsaving_history);
 
   Vsaving_history = true;
 
-  retval = get_user_input (args, true, 0);
+  octave_value_list tmp = get_user_input (args, true, 0);
+
+  retval = tmp(0);
 
   unwind_protect::run_frame ("do_keyboard");
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
   "-*- texinfo -*-\n\
@@ -790,52 +787,46 @@ state.\n\
     return retval;
 
   switch (argc)
     {
     case 1:
       {
 	if ((Vecho_executing_commands & ECHO_SCRIPTS)
 	    || (Vecho_executing_commands & ECHO_FUNCTIONS))
-	  bind_builtin_variable ("echo_executing_commands",
-				 static_cast<double> (ECHO_OFF));
+	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
 	else
-	  bind_builtin_variable ("echo_executing_commands",
-				 static_cast<double> (ECHO_SCRIPTS));
+	  bind_builtin_variable ("echo_executing_commands", ECHO_SCRIPTS);
       }
       break;
 
     case 2:
       {
 	std::string arg = argv[1];
 
 	if (arg == "on")
-	  bind_builtin_variable ("echo_executing_commands",
-				 static_cast<double> (ECHO_SCRIPTS));
+	  bind_builtin_variable ("echo_executing_commands", ECHO_SCRIPTS);
 	else if (arg == "off")
-	  bind_builtin_variable ("echo_executing_commands",
-				 static_cast<double> (ECHO_OFF));
+	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
 	else
 	  print_usage ("echo");
       }
       break;
 
     case 3:
       {
 	std::string arg = argv[1];
 
 	if (arg == "on" && argv[2] == "all")
 	  {
 	    int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
-	    bind_builtin_variable ("echo_executing_commands",
-				   static_cast<double> (tmp));
+	    bind_builtin_variable ("echo_executing_commands", tmp);
 	  }
 	else if (arg == "off" && argv[2] == "all")
-	  bind_builtin_variable ("echo_executing_commands",
-				 static_cast<double> (ECHO_OFF));
+	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
 	else
 	  print_usage ("echo");
       }
       break;
 
     default:
       print_usage ("echo");
       break;
@@ -1126,18 +1117,17 @@ a description of @code{--echo-input}.\n\
   DEFVAR (completion_append_char, " ", completion_append_char,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} completion_append_char\n\
 The value of @code{completion_append_char} is used as the character to\n\
 append to successful command-line completion attempts.  The default\n\
 value is @code{\" \"} (a single space).\n\
 @end defvr");
 
-  DEFVAR (echo_executing_commands, static_cast<double> (ECHO_OFF),
-	  echo_executing_commands,
+  DEFVAR (echo_executing_commands, ECHO_OFF, echo_executing_commands,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} echo_executing_commands\n\
 This variable may also be used to control the echo state.  It may be\n\
 the sum of the following values:\n\
 \n\
 @table @asis\n\
 @item 1\n\
 Echo commands read from script files.\n\
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -2666,31 +2666,31 @@ whitespace_in_literal_matrix (void)
   Vwhitespace_in_literal_matrix = pref;
 
   return 0;
 }
 
 void
 symbols_of_lex (void)
 {
-  DEFVAR (warn_matlab_incompatible, 0.0, warn_matlab_incompatible,
+  DEFVAR (warn_matlab_incompatible, false, warn_matlab_incompatible,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_matlab_incompatible\n\
 Print warnings for Octave language features that may cause\n\
 compatibility problems with Matlab.\n\
 @end defvr");
 
-  DEFVAR (warn_separator_insert, 0.0, warn_separator_insert,
+  DEFVAR (warn_separator_insert, false, warn_separator_insert,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_separator_insert\n\
 Print warning if commas or semicolons might be inserted\n\
 automatically in literal matrices.\n\
 @end defvr");
 
-  DEFVAR (warn_single_quote_string, 0.0, warn_single_quote_string,
+  DEFVAR (warn_single_quote_string, false, warn_single_quote_string,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_single_quote_string\n\
 Print warning if a signle quote character is used to introduce a\n\
 string constant.\n\
 @end defvr");
 
   DEFVAR (whitespace_in_literal_matrix, "", whitespace_in_literal_matrix,
     "-*- texinfo -*-\n\
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1215,17 +1215,17 @@ hdf5_import_multidim (hid_t data_id, hid
 					 dims, curdim-1, start, count,
 					 type_id, slice);
 	  if (retval < 0)
 	    break;
 	  lst.append (slice);
 	}
 
       if (retval > 0)
-	tc = lst;
+	tc = octave_value (lst);
     }
 
   return retval;
 }
 
 // Return true if loc_id has the attribute named attr_name, and false
 // otherwise.
 
@@ -1681,17 +1681,17 @@ hdf5_read_next_data (hid_t group_id, con
 
       if (retval2 < 0)
 	retval = retval2;
       else
 	{
 	  d->global = hdf5_check_attr (group_id, "OCTAVE_GLOBAL");
 
 	  if (is_list)
-	    d->tc = lst;
+	    d->tc = octave_value (lst);
 	  else
 	    d->tc = m;
 	}
 
       H5Gclose (subgroup_id);
     }
   else if (! ident_valid)
     {
@@ -3900,19 +3900,20 @@ add_hdf5_data (hid_t loc_id, const octav
 
       data_is_group = 1;
 
       // recursively add each element of the structure to this group
       Octave_map m = tc.map_value ();
       Octave_map::iterator i = m.begin ();
       while (i != m.end ())
 	{
-	  bool retval2 = add_hdf5_data (data_id, 
-					m.contents (i), m.key (i), "",
-					false, save_as_floats);
+	  // XXX FIXME XXX -- if the length of the structure array is
+	  // 1, should we really create a list object?
+	  bool retval2 = add_hdf5_data (data_id, octave_value (m.contents (i)),
+					m.key (i), "", false, save_as_floats);
 	  if (! retval2)
 	    goto error_cleanup;
 
 	  i++;
 	}
     }
   else
     {
@@ -4262,19 +4263,21 @@ save_mat5_binary_element (std::ostream& 
 	    memset (buf, 0, 32);
 	    strncpy (buf, tstr.c_str (), 31); // only 31 char names permitted
 	    os.write (buf, 32);
 	  }
 
 	for (Octave_map::iterator i = m.begin (); i != m.end (); i++)
 	  {
 	    // write the data of each element
-	    bool retval2 = save_mat5_binary_element (os, m.contents (i), "",
-						     mark_as_global,
-						     save_as_floats);
+	    // XXX FIXME XXX -- if the length of the structure array is
+	    // 1, should we really create a list object?
+	    bool retval2
+	      = save_mat5_binary_element (os, octave_value (m.contents (i)),
+					  "", mark_as_global, save_as_floats);
 
 	    if (! retval2)
 	      goto error_cleanup;
 	  }
       }
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
@@ -5309,17 +5312,17 @@ save_precision (void)
     }
   gripe_invalid_value_specified ("save_precision");
   return -1;
 }
 
 void
 symbols_of_load_save (void)
 {
-  DEFVAR (crash_dumps_octave_core, 1.0, crash_dumps_octave_core,
+  DEFVAR (crash_dumps_octave_core, true, crash_dumps_octave_core,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} crash_dumps_octave_core\n\
 If this variable is set to a nonzero value, Octave tries to save all\n\
 current variables the the file \"octave-core\" if it crashes or receives a\n\
 hangup, terminate or similar signal.  The default value is 1.\n\
 @end defvr");
 
   DEFVAR (default_save_format, "ascii", default_save_format,
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -712,17 +712,17 @@ overridden by the environment variable @
   DEFVAR (history_size, tmp_hist_size, history_size,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} history_size\n\
 This variable specifies how many entries to store in the history file.\n\
 The default value is @code{1024}, but may be overridden by the\n\
 environment variable @code{OCTAVE_HISTSIZE}.\n\
 @end defvr");
 
-  DEFVAR (saving_history, 1.0, saving_history,
+  DEFVAR (saving_history, true, saving_history,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} saving_history\n\
 If the value of @code{saving_history} is nonzero, command entered\n\
 on the command line are saved in the file specified by the variable\n\
 @code{history_file}.\n\
 @end defvr");
 }
 
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -44,61 +44,16 @@ public:
     : data () { }
 
   octave_value_list (int n, const octave_value& val)
     : data (n, val) { }
 
   octave_value_list (const octave_value& tc)
     : data (1, tc) { }
 
-  octave_value_list (double d)
-    : data (1, octave_value (d)) { }
-
-  octave_value_list (const Matrix& m)
-    : data (1, octave_value (m)) { }
-
-  octave_value_list (const DiagMatrix& d)
-    : data (1, octave_value (d)) { }
-
-  octave_value_list (const RowVector& v)
-    : data (1, octave_value (v)) { }
-
-  octave_value_list (const ColumnVector& v)
-    : data (1, octave_value (v)) { }
-
-  octave_value_list (const Complex& c)
-    : data (1, octave_value (c)) { }
-
-  octave_value_list (const ComplexMatrix& m)
-    : data (1, octave_value (m)) { }
-
-  octave_value_list (const ComplexDiagMatrix& d)
-    : data (1, octave_value (d)) { }
-
-  octave_value_list (const ComplexRowVector& v)
-    : data (1, octave_value (v)) { }
-
-  octave_value_list (const ComplexColumnVector& v)
-    : data (1, octave_value (v)) { }
-
-  octave_value_list (const char *s)
-    : data (1, octave_value (s)) { }
-
-  octave_value_list (const std::string& s)
-    : data (1, octave_value (s)) { }
-
-  octave_value_list (const string_vector& s)
-    : data (1, octave_value (s)) { }
-
-  octave_value_list (double base, double limit, double inc)
-    : data (1, octave_value (base, limit, inc)) { }
-
-  octave_value_list (const Range& r)
-    : data (1, octave_value (r)) { }
-
   octave_value_list (const octave_value_list& obj)
     : data (obj.data), names (obj.names) { }
 
   ~octave_value_list (void) { }
 
   void *operator new (size_t size)
     { return allocator.alloc (size); }
 
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -205,18 +205,17 @@ kluge_procbuf_delay (void)
     }
   gripe_invalid_value_specified ("__kluge_procbuf_delay__");
   return -1;
 }
 
 void
 symbols_of_oct_procbuf (void)
 {
-  DEFVAR (__kluge_procbuf_delay__, static_cast<double> (Vkluge_procbuf_delay),
-	  kluge_procbuf_delay,
+  DEFVAR (__kluge_procbuf_delay__, Vkluge_procbuf_delay, kluge_procbuf_delay,
     "-*- texinfo -*-\n\
 @defvr __kluge_procbuf_delay__\n\
 Number of microseconds to delay in the parent after forking.\n\
 @end defvr");
 
 }
 
 /*
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1777,17 +1777,17 @@ octave_base_stream::do_oscanf (const sca
 
 	    case 'd': case 'i':
 	      {
 		int tmp;
 
 		if (OCTAVE_SCAN (is, *elt, &tmp))
 		  {
 		    if (! discard)
-		      retval = static_cast<double> (tmp);
+		      retval = tmp;
 		  }
 		else
 		  quit = true;
 	      }
 	      break;
 
 	    case 'o': case 'u': case 'x':
 	      {
@@ -1930,17 +1930,17 @@ octave_base_stream::oscanf (const std::s
 
 		  if (! ok ())
 		    break;
 
 		  elt = fmt_list.next (nconv > 0);
 		}
 	    }
 
-	  retval (nconv) = static_cast<double> (num_values);
+	  retval(nconv) = num_values;
 
 	  if (! quit)
 	    {
 	      // Pick up any trailing stuff.
 	      if (ok () && len > nconv)
 		{
 		  octave_value tmp;
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -153,18 +153,17 @@ long_options long_opts[] =
     { 0,                  0,                       0, 0 }
   };
 
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
-  bind_builtin_variable ("nargin", static_cast<double> (argc-1),
-			 true, true, 0);
+  bind_builtin_variable ("nargin", argc-1, true, true, 0);
 
   Cell octave_argv;
 
   if (argc > 1)
     {
       Array<octave_value> tmp (argc-1);
 
       // Skip program name in argv.
@@ -585,18 +584,17 @@ octave_main (int argc, char **argv)
   // has forced interactive behavior.
 
   if (! interactive && forced_interactive)
     {
       command_editor::blink_matching_paren (false);
 
       // XXX FIXME XXX -- is this the right thing to do?
 
-      bind_builtin_variable ("echo_executing_commands",
-			     static_cast<double> (ECHO_CMD_LINE));
+      bind_builtin_variable ("echo_executing_commands", ECHO_CMD_LINE);
     }
 
   if (! interactive)
     line_editing = false;
 
   int retval = main_loop ();
 
   if (retval == 1 && ! error_state)
diff --git a/src/ov-file.cc b/src/ov-file.cc
--- a/src/ov-file.cc
+++ b/src/ov-file.cc
@@ -41,17 +41,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_file);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_file, "file");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_file&);
 
-  return new octave_scalar (static_cast<double> (v.stream_number ()));
+  return new octave_scalar (v.stream_number ());
 }
 
 type_conv_fcn
 octave_file::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -53,17 +53,17 @@ octave_list::subsref (const std::string 
     case '(':
       {
 	octave_value_list tmp_idx = idx.front ();
 
 	if (tmp_idx.length () == 1)
 	  {
 	    idx_vector i = tmp_idx (0).index_vector ();
 
-	    retval = octave_value_list (lst.index (i));
+	    retval = octave_value (octave_value_list (lst.index (i)));
 	  }
 	else
 	  error ("only one index allowed for lists");
       }
       break;
 
     case '{':
       {
@@ -101,17 +101,17 @@ octave_value
 octave_list::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (idx.length () == 1)
     {
       idx_vector i = idx (0).index_vector ();
 
-      retval = octave_value_list (lst.index (i, resize_ok));
+      retval = octave_value (octave_value_list (lst.index (i, resize_ok)));
     }
   else
     error ("lists may only be indexed by a single scalar");
 
   return retval;
 }
 
 octave_value
@@ -352,17 +352,17 @@ a list containing the three elements @sa
 	      octave_value ov = args(i);
 
 	      if (ov.is_list ())
 		tmp.append (ov.list_value ());
 	      else
 		tmp.append (ov);
 	    }
 
-	  retval = tmp;
+	  retval = octave_value (tmp);
 	}
     }
   else
     print_usage ("append");
 
   return retval;
 }
 
@@ -376,17 +376,17 @@ Return a new list created by reversing t
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value_list tmp = args(0).list_value ();
 
       if (! error_state)
-	  retval = tmp.reverse ();
+	  retval = octave_value (tmp.reverse ());
     }
   else
     print_usage ("reverse");
 
   return retval;
 }
 
 DEFUN (splice, args, ,
@@ -436,17 +436,17 @@ is equivalent to @code{append (@var{list
 			    error ("splice: fourth argument must be a list");
 			}
 		    }
 		  else
 		    error ("splice: LENGTH must be an integer");
 		}
 
 	      if (! error_state)
-		retval = list_1.splice (offset, length, list_2);
+		retval = octave_value (list_1.splice (offset, length, list_2));
 	    }
 	  else
 	    error ("splice: OFFSET must be an integer");
 	}
       else
 	error ("splice: first argument must be a list");      
     }
   else
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -573,18 +573,18 @@ octave_user_function::install_automatic_
 void
 octave_user_function::bind_automatic_vars
   (const string_vector& arg_names, int nargin, int nargout,
    const octave_value_list& va_args)
 {
   if (! arg_names.empty ())
     argn_sr->define (arg_names);
 
-  nargin_sr->define (static_cast<double> (nargin));
-  nargout_sr->define (static_cast<double> (nargout));
+  nargin_sr->define (nargin);
+  nargout_sr->define (nargout);
 
   if (takes_varargs ())
     {
       int n = va_args.length ();
 
       Cell varargin (1, n);
 
       for (int i = 0; i < n; i++)
@@ -755,17 +755,17 @@ symbols_of_ov_usr_fcn (void)
   DEFVAR (default_return_value, Matrix (), 0,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} default_return_value\n\
 The value given to otherwise uninitialized return values if\n\
 @code{define_all_return_values} is nonzero.  The default value is\n\
 @code{[]}.\n\
 @end defvr");
 
-  DEFVAR (define_all_return_values, 0.0, define_all_return_values,
+  DEFVAR (define_all_return_values, false, define_all_return_values,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} define_all_return_values\n\
 If the value of @code{define_all_return_values} is nonzero, Octave\n\
 will substitute the value specified by @code{default_return_value} for\n\
 any return values that remain undefined when a function returns.  The\n\
 default value is 0.\n\
 @end defvr");
 
@@ -774,17 +774,17 @@ default value is 0.\n\
 @defvr {Built-in Variable} max_recursion_depth\n\
 Limit the number of times a function may be called recursively.\n\
 If the limit is exceeded, an error message is printed and control\n\
 returns to the top level.\n\
 \n\
 The default value is 256.\n\
 @end defvr");
 
-  DEFVAR (return_last_computed_value, 0.0, return_last_computed_value,
+  DEFVAR (return_last_computed_value, false, return_last_computed_value,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} return_last_computed_value\n\
 If the value of @code{return_last_computed_value} is true, and a\n\
 function is defined without explicitly specifying a return value, the\n\
 function will return the value of the last expression.  Otherwise, no\n\
 value will be returned.  The default value is 0.\n\
 \n\
 For example, the function\n\
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -338,16 +338,22 @@ octave_value::assign_op_as_string (assig
 }
 
 octave_value::octave_value (void)
   : rep (new octave_base_value ())
 {
   rep->count = 1;
 }
 
+octave_value::octave_value (int i)
+  : rep (new octave_scalar (i))
+{
+  rep->count = 1;
+}
+
 octave_value::octave_value (double d)
   : rep (new octave_scalar (d))
 {
   rep->count = 1;
 }
 
 octave_value::octave_value (const Cell& c)
   : rep (new octave_cell (c))
@@ -574,24 +580,22 @@ octave_value::subsref (const std::string
     return rep->subsref (type, idx);
   else
     return rep->subsref (type, idx, nargout);
 }
 
 octave_value
 octave_value::next_subsref (const std::string type,
 			    const std::list<octave_value_list>& idx,
-			    int skip) 
+			    size_t skip) 
 {
-  assert (skip > 0);
-
   if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
-      for (int i = 0; i < skip; i++)
+      for (size_t i = 0; i < skip; i++)
 	new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx);
     }
   else
     return *this;
 }
 
 octave_value_list
@@ -1757,26 +1761,26 @@ warn_divide_by_zero (void)
   Vwarn_divide_by_zero = check_preference ("warn_divide_by_zero");
 
   return 0;
 }
 
 void
 symbols_of_ov (void)
 {
-  DEFVAR (do_fortran_indexing, 0.0, do_fortran_indexing,
+  DEFVAR (do_fortran_indexing, false, do_fortran_indexing,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} do_fortran_indexing\n\
 If the value of @code{do_fortran_indexing} is nonzero, Octave allows \n\
 you to select elements of a two-dimensional matrix using a single index\n\
 by treating the matrix as a single vector created from the columns of\n\
 the matrix.  The default value is 0. \n\
 @end defvr");
 
-  DEFVAR (implicit_str_to_num_ok, 0.0, implicit_str_to_num_ok,
+  DEFVAR (implicit_str_to_num_ok, false, implicit_str_to_num_ok,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} implicit_str_to_num_ok\n\
 If the value of @code{implicit_str_to_num_ok} is nonzero, implicit\n\
 conversions of strings to their numeric ASCII equivalents are allowed.\n\
 Otherwise, an error message is printed and control is returned to the\n\
 top level.  The default value is 0.\n\
 @end defvr");
 
@@ -1786,17 +1790,17 @@ top level.  The default value is 0.\n\
 If the value of @code{ok_to_lose_imaginary_part} is nonzero, implicit\n\
 conversions of complex numbers to real numbers are allowed (for example,\n\
 by fsolve).  If the value is @code{\"warn\"}, the conversion is allowed,\n\
 but a warning is printed.  Otherwise, an error message is printed and\n\
 control is returned to the top level.  The default value is\n\
 @code{\"warn\"}.\n\
 @end defvr");
 
-  DEFVAR (prefer_column_vectors, 1.0, prefer_column_vectors,
+  DEFVAR (prefer_column_vectors, true, prefer_column_vectors,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} prefer_column_vectors\n\
 If @code{prefer_column_vectors} is nonzero, operations like\n\
 \n\
 @example\n\
 for i = 1:10\n\
   a (i) = i;\n\
 endfor\n\
@@ -1806,33 +1810,33 @@ endfor\n\
 (for @code{a} previously  undefined) produce column vectors.  Otherwise, row\n\
 vectors are preferred.  The default value is 1.\n\
 \n\
 If a variable is already defined to be a vector (a matrix with a single\n\
 row or column), the original orientation is respected, regardless of the\n\
 value of @code{prefer_column_vectors}.\n\
 @end defvr");
 
-  DEFVAR (print_answer_id_name, 1.0, print_answer_id_name,
+  DEFVAR (print_answer_id_name, true, print_answer_id_name,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} print_answer_id_name\n\
 If the value of @code{print_answer_id_name} is nonzero, variable\n\
 names are printed along with the result.  Otherwise, only the result\n\
 values are printed.  The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (propagate_empty_matrices, 1.0, propagate_empty_matrices,
+  DEFVAR (propagate_empty_matrices, true, propagate_empty_matrices,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} propagate_empty_matrices\n\
 If the value of @code{propagate_empty_matrices} is nonzero,\n\
 functions like @code{inverse} and @code{svd} will return an empty matrix\n\
 if they are given one as an argument.  The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (resize_on_range_error, 1.0, resize_on_range_error,
+  DEFVAR (resize_on_range_error, true, resize_on_range_error,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} resize_on_range_error\n\
 If the value of @code{resize_on_range_error} is nonzero, expressions\n\
 like\n\
 \n\
 @example\n\
 for i = 1:10\n\
   a (i) = sqrt (i);\n\
@@ -1842,17 +1846,17 @@ endfor\n\
 @noindent\n\
 (for @code{a} previously undefined) result in the variable @code{a}\n\
 being resized to be just large enough to hold the new value.  New\n\
 elements that have not been given a value are set to zero.  If the value\n\
 of @code{resize_on_range_error} is 0, an error message is printed and\n\
 control is returned to the top level.  The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (silent_functions, 0.0, silent_functions,
+  DEFVAR (silent_functions, false, silent_functions,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} silent_functions\n\
 If the value of @code{silent_functions} is nonzero, internal output\n\
 from a function is suppressed.  Otherwise, the results of expressions\n\
 within a function body that are not terminated with a semicolon will\n\
 have their values printed.  The default value is 0.\n\
 \n\
 For example, if the function\n\
@@ -1870,17 +1874,17 @@ depending on the value of @code{silent_f
 
   DEFVAR (struct_levels_to_print, 2.0, struct_levels_to_print,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} struct_levels_to_print\n\
 You can tell Octave how many structure levels to display by setting the\n\
 built-in variable @code{struct_levels_to_print}.  The default value is 2.\n\
 @end defvr");
 
-  DEFVAR (warn_divide_by_zero, 1.0, warn_divide_by_zero,
+  DEFVAR (warn_divide_by_zero, true, warn_divide_by_zero,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_divide_by_zero\n\
 If the value of @code{warn_divide_by_zero} is nonzero, a warning\n\
 is issued when Octave encounters a division by zero.  If the value is\n\
 0, the warning is omitted.  The default value is 1.\n\
 @end defvr");
 }
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -152,16 +152,17 @@ public:
 
   static octave_value empty_conv (const std::string& type,
 				  const octave_value& rhs = octave_value ());
 
   enum magic_colon { magic_colon_t };
   enum all_va_args { all_va_args_t };
 
   octave_value (void);
+  octave_value (int i);
   octave_value (double d);
   octave_value (const Cell& m);
   octave_value (const Matrix& m);
   octave_value (const DiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const Complex& C);
   octave_value (const ComplexMatrix& m);
@@ -256,17 +257,17 @@ public:
     }
 
   virtual octave_value_list subsref (const std::string type,
 				     const std::list<octave_value_list>& idx,
     				     int nargout);
 
   octave_value next_subsref (const std::string type, const
 			     std::list<octave_value_list>& idx,
-			     int skip = 1);
+			     size_t skip = 1);
 
   virtual octave_value do_index_op (const octave_value_list& idx,
 				    int resize_ok)
     { return rep->do_index_op (idx, resize_ok); }
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -582,26 +582,26 @@ The default value is normally @code{\"le
 @code{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
 \n\
 When running interactively, Octave sends any output intended for your\n\
 terminal that is more than one screen long to the program named by the\n\
 value of the variable @code{PAGER}.\n\
 @end defvr");
 
-  DEFVAR (page_output_immediately, 0.0, page_output_immediately,
+  DEFVAR (page_output_immediately, false, page_output_immediately,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} page_output_immediately\n\
 If the value of @code{page_output_immediately} is nonzero, Octave sends\n\
 output to the pager as soon as it is available.  Otherwise, Octave\n\
 buffers its output and waits until just before the prompt is printed to\n\
 flush it to the pager.  The default value is 0.\n\
 @end defvr");
 
-  DEFVAR (page_screen_output, 1.0, page_screen_output,
+  DEFVAR (page_screen_output, true, page_screen_output,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} page_screen_output\n\
 If the value of @code{page_screen_output} is nonzero, all output\n\
 intended for the screen that is longer than one page is sent through a\n\
 pager.  This allows you to view one screenful at a time.  Some pagers\n\
 (such as @code{less}---see @ref{Installation}) are also capable of moving\n\
 backward on the output.  The default value is 1.\n\
 @end defvr");
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -3591,17 +3591,17 @@ static octave_value_list
 eval_string (const octave_value& arg, bool silent, int& parse_status,
 	     int nargout)
 {
   std::string s = arg.string_value ();
 
   if (error_state)
     {
       error ("eval: expecting std::string argument");
-      return -1.0;
+      return octave_value (-1);
     }
 
   return eval_string (s, silent, parse_status, nargout);
 }
 
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} eval (@var{try}, @var{catch})\n\
@@ -3736,25 +3736,25 @@ warn_variable_switch_label (void)
     = check_preference ("warn_variable_switch_label");
 
   return 0;
 }
 
 void
 symbols_of_parse (void)
 {
-  DEFVAR (default_eval_print_flag, 1.0, default_eval_print_flag,
+  DEFVAR (default_eval_print_flag, true, default_eval_print_flag,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} default_eval_print_flag\n\
 If the value of this variable is nonzero, Octave prints the results of\n\
 commands executed by @code{eval} that do not end with semicolons.  If it\n\
 is zero, automatic printing is suppressed.  The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (warn_assign_as_truth_value, 1.0, warn_assign_as_truth_value,
+  DEFVAR (warn_assign_as_truth_value, true, warn_assign_as_truth_value,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_assign_as_truth_value\n\
 If the value of @code{warn_assign_as_truth_value} is nonzero, a\n\
 warning is issued for statements like\n\
 \n\
 @example\n\
 if (s = t)\n\
   ...\n\
@@ -3808,51 +3808,51 @@ while ((c = getc()))\n\
 @noindent\n\
 will prevent the warning from being printed for this statement, while\n\
 allowing Octave to warn about other assignments used in conditional\n\
 contexts.\n\
 \n\
 The default value of @code{warn_assign_as_truth_value} is 1.\n\
 @end defvr");
 
-  DEFVAR (warn_function_name_clash, 1.0, warn_function_name_clash,
+  DEFVAR (warn_function_name_clash, true, warn_function_name_clash,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_function_name_clash\n\
 If the value of @code{warn_function_name_clash} is nonzero, a warning is\n\
 issued when Octave finds that the name of a function defined in a\n\
 function file differs from the name of the file.  (If the names\n\
 disagree, the name declared inside the file is ignored.)  If the value\n\
 is 0, the warning is omitted.  The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (warn_future_time_stamp, 1.0, warn_future_time_stamp,
+  DEFVAR (warn_future_time_stamp, true, warn_future_time_stamp,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_future_time_stamp\n\
 If the value of this variable is nonzero, Octave will print a warning\n\
 if it finds a function file with a time stamp that is in the future.\n\
 @end defvr");
 
-  DEFVAR (warn_missing_semicolon, 0.0, warn_missing_semicolon,
+  DEFVAR (warn_missing_semicolon, false, warn_missing_semicolon,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_missing_semicolon\n\
 If the value of this variable is nonzero, Octave will warn when\n\
 statements in function definitions don't end in semicolons.  The default\n\
 value is 0.\n\
 @end defvr");
 
-  DEFVAR (warn_precedence_change, 1.0, warn_precedence_change,
+  DEFVAR (warn_precedence_change, true, warn_precedence_change,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_precedence_change\n\
 If the value of this variable is nonzero, Octave will warn about\n\
 possible changes in the meaning of some code due to changes in\n\
 precedence for some operators.  Precedence changes have typically\n\
 been made for Matlab compatibility.  The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (warn_variable_switch_label, 0.0, warn_variable_switch_label,
+  DEFVAR (warn_variable_switch_label, false, warn_variable_switch_label,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_variable_switch_label\n\
 If the value of this variable is nonzero, Octave will print a warning if\n\
 a switch label is not a constant or constant expression\n\
 @end defvr");
 
 }
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1877,18 +1877,18 @@ init_format_state (void)
   bit_format = 0;
   print_e = false;
   print_big_e = false;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
 {
-  bind_builtin_variable ("output_precision", static_cast<double> (prec));
-  bind_builtin_variable ("output_max_field_width", static_cast<double> (fw));
+  bind_builtin_variable ("output_precision", prec);
+  bind_builtin_variable ("output_max_field_width", fw);
 }
 
 static void
 set_format_style (int argc, const string_vector& argv)
 {
   int idx = 1;
 
   if (--argc > 0)
@@ -2172,17 +2172,17 @@ split_long_rows (void)
   Vsplit_long_rows = check_preference ("split_long_rows");
 
   return 0;
 }
 
 void
 symbols_of_pr_output (void)
 {
-  DEFVAR (fixed_point_format, 0.0, fixed_point_format,
+  DEFVAR (fixed_point_format, false, fixed_point_format,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} fixed_point_format\n\
 If the value of this variable is nonzero, Octave will scale all values\n\
 in a matrix so that the largest may be written with one leading digit.\n\
 The scaling factor is printed on the first line of output.  For example,\n\
 \n\
 @example\n\
 @group\n\
@@ -2216,17 +2216,17 @@ The default value is 10.\n\
 
   DEFVAR (output_precision, 5.0, output_precision,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} output_precision\n\
 This variable specifies the minimum number of significant figures to\n\
 display for numeric output.  The default value is 5.\n\
 @end defvr");
 
-  DEFVAR (print_empty_dimensions, 1.0, print_empty_dimensions,
+  DEFVAR (print_empty_dimensions, true, print_empty_dimensions,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} print_empty_dimensions\n\
 If the value of @code{print_empty_dimensions} is nonzero, the\n\
 dimensions of empty matrices are printed along with the empty matrix\n\
 symbol, @samp{[]}.  For example, the expression\n\
 \n\
 @example\n\
 zeros (3, 0)\n\
@@ -2235,17 +2235,17 @@ zeros (3, 0)\n\
 @noindent\n\
 will print\n\
 \n\
 @example\n\
 ans = [](3x0)\n\
 @end example\n\
 @end defvr");
 
-  DEFVAR (split_long_rows, 1.0, split_long_rows,
+  DEFVAR (split_long_rows, true, split_long_rows,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} split_long_rows\n\
 For large matrices, Octave may not be able to display all the columns of\n\
 a given row on one line of your screen.  This can result in missing\n\
 information or output that is nearly impossible to decipher, depending\n\
 on whether your terminal truncates or wraps long lines.\n\
 \n\
 If the value of @code{split_long_rows} is nonzero, Octave will display\n\
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -327,17 +327,17 @@ print_rhs_assign_val (void)
   Vprint_rhs_assign_val = check_preference ("print_rhs_assign_val");
 
   return 0;
 }
 
 void
 symbols_of_pt_assign (void)
 {
-  DEFVAR (print_rhs_assign_val, 0.0, print_rhs_assign_val,
+  DEFVAR (print_rhs_assign_val, false, print_rhs_assign_val,
     "-*- texinfo -*-\n\
 @defvr print_rhs_assign_val\n\
 If the value of this variable is non-zero, Octave will print the value\n\
 of the right hand side of assignment expressions instead of the value\n\
 of the left hand side (after the assignment).\n\
 @end defvr");
 
 }
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -50,17 +50,17 @@ tree_breakpoint::take_action (tree &tr)
     {
       tr.delete_breakpoint ();
       found = true;
     }
   else if (act == list)
     {
       if (tr.is_breakpoint ())
 	{
-	  bp_list.append (octave_value (static_cast<double> (tr.line ())));
+	  bp_list.append (octave_value (tr.line ()));
 	  line = tr.line () + 1;
 	}
     }
   else
     panic_impossible ();
 
   return;
 }
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -54,17 +54,17 @@ tree_cell::rvalue (void)
   int nc = -1;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
 
       if (nc < 0)
 	nc = elt->length ();
-      else if (nc != elt->length ())
+      else if (nc != static_cast<int> (elt->length ()))
 	{
 	  ::error ("number of columns must match");
 	  return retval;
 	}
     }
 
   Cell val (nr, nc);
 
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -211,17 +211,17 @@ global foo;\n\
 foo\n\
      @result{} 13\n\
 @end group\n\
 @end example\n\
 \n\
 the variable @code{default_global_variable_value} is initially undefined.\n\
 @end defvr");
 
-  DEFVAR (initialize_global_variables, 0.0, initialize_global_variables,
+  DEFVAR (initialize_global_variables, false, initialize_global_variables,
     "-*- texinfo -*-\n\
 @defvr initialize_global_variables\n\
 If the value of this variable is nonzero, global variables are given\n\
 the default initial value specified by the built-in variable\n\
 @code{default_global_variable_value}.\n\
 @end defvr");
 
 }
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -278,17 +278,17 @@ tree_index_expression::rvalue (int nargo
 	      break;
 
 	    case '{':
 	      idx.push_back (make_value_list (*p_args, *p_arg_nm));
 	      break;
 
 	    case '.':
 	      {
-		idx.push_back (get_struct_index (p_arg_nm, p_dyn_field));
+		idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
 
 		if (error_state)
 		  eval_error ();
 	      }
 	      break;
 
 	    default:
 	      panic_impossible ();
@@ -344,17 +344,17 @@ tree_index_expression::lvalue (void)
 	  break;
 
 	case '{':
 	  idx.push_back (make_value_list (*p_args, *p_arg_nm));
 	  break;
 
 	case '.':
 	  {
-	    idx.push_back (get_struct_index (p_arg_nm, p_dyn_field));
+	    idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
 
 	    if (error_state)
 	      eval_error ();
 	  }
 	  break;
 
 	default:
 	  panic_impossible ();
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -616,17 +616,17 @@ string_fill_char (void)
     }
 
   return status;
 }
 
 void
 symbols_of_pt_mat (void)
 {
-  DEFVAR (empty_list_elements_ok, 1.0, empty_list_elements_ok,
+  DEFVAR (empty_list_elements_ok, true, empty_list_elements_ok,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} empty_list_elements_ok\n\
 This variable controls whether Octave ignores empty matrices in a matrix\n\
 list.\n\
 \n\
 For example, if the value of @code{empty_list_elements_ok} is\n\
 nonzero, Octave will ignore the empty matrices in the expression\n\
 \n\
@@ -635,17 +635,17 @@ a = [1, [], 3, [], 5]\n\
 @end example\n\
 \n\
 @noindent\n\
 and the variable @code{a} will be assigned the value @code{[ 1, 3, 5 ]}.\n\
 \n\
 The default value is 1.\n\
 @end defvr");
 
-  DEFVAR (implicit_num_to_str_ok, 0.0, implicit_num_to_str_ok,
+  DEFVAR (implicit_num_to_str_ok, false, implicit_num_to_str_ok,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} implicit_num_to_str_ok\n\
 If the value of @code{implicit_num_to_str_ok} is nonzero, implicit\n\
 conversions of numbers to their ASCII character equivalents are\n\
 allowed when strings are constructed using a mixture of strings and\n\
 numbers in matrix notation.  Otherwise, an error message is printed and\n\
 control is returned to the top level. The default value is 0.  For\n\
 example,\n\
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -1026,17 +1026,17 @@ off, and @code{hold} with no arguments t
 
 DEFUN (ishold, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ishold\n\
 Return 1 if the next line will be added to the current plot, or 0 if\n\
 the plot device will be cleared before drawing the next line.\n\
 @end deftypefn")
 {
-  return static_cast<double> (! clear_before_plotting);
+  return octave_value (! clear_before_plotting);
 }
 
 DEFUN (purge_tmp_files, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} purge_tmp_files\n\
 Delete the temporary files created by the plotting commands.\n\
 \n\
 Octave creates temporary data files for @code{gnuplot} and then sends\n\
@@ -1278,17 +1278,17 @@ gnuplot_has_multiplot (void)
   Vgnuplot_has_multiplot = check_preference ("gnuplot_has_multiplot");
 
   return 0;
 }
 
 void
 symbols_of_pt_plot (void)
 {
-  DEFVAR (automatic_replot, 0.0, automatic_replot,
+  DEFVAR (automatic_replot, false, automatic_replot,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} automatic_replot\n\
 You can tell Octave to redisplay the plot each time anything about it\n\
 changes by setting the value of the builtin variable\n\
 @code{automatic_replot} to a nonzero value.  Since this is fairly\n\
 inefficient, the default value is 0.\n\
 @end defvr");
 
@@ -1335,35 +1335,35 @@ is @code{\"gnuplot\"}.  @xref{Installati
 @end defvr");
 
   DEFVAR (gnuplot_command_end, "\n", gnuplot_command_end,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} gnuplot_command_end\n\
 @end defvr");
 
 #if defined (GNUPLOT_HAS_FRAMES)
-  double with_frames = 1.0;
+  bool with_frames = true;
 #else
-  double with_frames = 0.0;
+  bool with_frames = false;
 #endif
 
   DEFVAR (gnuplot_has_frames, with_frames, gnuplot_has_frames,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} gnuplot_has_frames\n\
 If the value of this variable is nonzero, Octave assumes that your copy\n\
 of gnuplot has support for multiple frames that is included in recent\n\
 3.6beta releases.  It's initial value is determined by configure, but it\n\
 can be changed in your startup script or at the command line in case\n\
 configure got it wrong, or if you upgrade your gnuplot installation.\n\
 @end defvr");
 
 #if defined (GNUPLOT_HAS_MULTIPLOT)
-  double with_multiplot = 1.0;
+  bool with_multiplot = true;
 #else
-  double with_multiplot = 0.0;
+  bool with_multiplot = false;
 #endif
 
   DEFVAR (gnuplot_has_multiplot, with_multiplot, gnuplot_has_multiplot,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} gnuplot_has_multiplot\n\
 If the value of this variable is nonzero, Octave assumes that your copy\n\
 of gnuplot has the multiplot support that is included in recent\n\
 3.6beta releases.  It's initial value is determined by configure, but it\n\
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -127,19 +127,16 @@ tree_switch_case::~tree_switch_case (voi
 // Compare two octave values, returning true if equal, false if not
 // XXX FIXME XXX --- should be member or friend of octave_value class.
 
 static bool
 equal (const octave_value& val, const octave_value& test)
 {
   bool retval = false;
 
-  int t1 = val.type_id ();
-  int t2 = test.type_id ();
-
   // If there is no op_eq for these types, we can't compare values.
 
   if (val.rows () == test.rows () && val.columns () == test.columns ())
     {
       octave_value tmp = do_binary_op (octave_value::op_eq, val, test);
 
       if (! error_state && tmp.is_defined ())
 	retval = tmp.is_true ();
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -620,17 +620,17 @@ debug_on_interrupt (void)
   Vdebug_on_interrupt = check_preference ("debug_on_interrupt");
 
   return 0;
 }
 
 void
 symbols_of_sighandlers (void)
 {
-  DEFVAR (debug_on_interrupt, 0.0, debug_on_interrupt,
+  DEFVAR (debug_on_interrupt, false, debug_on_interrupt,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} debug_on_interrupt\n\
 If @code{debug_on_interrupt} is nonzero, Octave will try to enter\n\
 debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
 The default value is 0.\n\
 @end defvr");
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -36,22 +36,22 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 
 DEFUN (isstr, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstr (@var{a})\n\
 Return 1 if @var{a} is a string.  Otherwise, return 0.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
-    retval = static_cast<double> (args(0).is_string ());
+    retval = args(0).is_string ();
   else
     print_usage ("isstr");
 
   return retval;
 }
 
 DEFUN (setstr, args, ,
   "-*- texinfo -*-\n\
@@ -63,17 +63,17 @@ character.  For example,\n\
 @example\n\
 @group\n\
 setstr ([97, 98, 99])\n\
      @result{} \"abc\"\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).convert_to_str ();
   else
     print_usage ("setstr");
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1071,17 +1071,17 @@ variables_can_hide_functions (void)
     = check_preference ("variables_can_hide_functions");
 
   return 0;
 }
 
 void
 symbols_of_symtab (void)
 {
-  DEFVAR (variables_can_hide_functions, 1.0, variables_can_hide_functions,
+  DEFVAR (variables_can_hide_functions, true, variables_can_hide_functions,
     "-*- texinfo -*-\n\
 @defvr variables_can_hide_functions\n\
 If the value of this variable is nonzero, assignments to variables may\n\
 hide previously defined functions of the same name.  A negative value\n\
 will cause Octave to print a warning, but allow the operation.\n\
 @end defvr");
 
 }
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -60,34 +60,34 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 #include "variables.h"
 
 static Octave_map
 mk_stat_map (const file_stat& fs)
 {
   Octave_map m;
 
-  m["dev"] = static_cast<double> (fs.dev ());
-  m["ino"] = static_cast<double> (fs.ino ());
-  m["modestr"] = fs.mode_as_string ();
-  m["nlink"] = static_cast<double> (fs.nlink ());
-  m["uid"] = static_cast<double> (fs.uid ());
-  m["gid"] = static_cast<double> (fs.gid ());
+  m["dev"](0) = static_cast<double> (fs.dev ());
+  m["ino"](0) = static_cast<double> (fs.ino ());
+  m["modestr"](0) = fs.mode_as_string ();
+  m["nlink"](0) = static_cast<double> (fs.nlink ());
+  m["uid"](0) = static_cast<double> (fs.uid ());
+  m["gid"](0) = static_cast<double> (fs.gid ());
 #if defined (HAVE_STRUCT_STAT_ST_RDEV)
-  m["rdev"] = static_cast<double> (fs.rdev ());
+  m["rdev"](0) = static_cast<double> (fs.rdev ());
 #endif
-  m["size"] = static_cast<double> (fs.size ());
-  m["atime"] = static_cast<double> (fs.atime ());
-  m["mtime"] = static_cast<double> (fs.mtime ());
-  m["ctime"] = static_cast<double> (fs.ctime ());
+  m["size"](0) = static_cast<double> (fs.size ());
+  m["atime"](0) = static_cast<double> (fs.atime ());
+  m["mtime"](0) = static_cast<double> (fs.mtime ());
+  m["ctime"](0) = static_cast<double> (fs.ctime ());
 #if defined (HAVE_STRUCT_STAT_ST_BLKSIZE)
-  m["blksize"] = static_cast<double> (fs.blksize ());
+  m["blksize"](0) = static_cast<double> (fs.blksize ());
 #endif
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
-  m["blocks"] = static_cast<double> (fs.blocks ());
+  m["blocks"](0) = static_cast<double> (fs.blocks ());
 #endif
 
   return m;
 }
 
 DEFUN (dup2, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})\n\
@@ -121,17 +121,17 @@ system-dependent error message.\n\
 	      int i_new = new_stream.file_number ();
 
 	      if (i_old >= 0 && i_new >= 0)
 		{
 		  std::string msg;
 
 		  int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
-		  retval(0) = static_cast<double> (status);
+		  retval(0) = status;
 		  retval(1) = msg;
 		}
 	    }
 	}
       else
 	error ("dup2: invalid stream");
     }
   else
@@ -200,17 +200,17 @@ error message.\n\
 	    }
 
 	  if (! error_state)
 	    {
 	      std::string msg;
 
 	      int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
-	      retval(0) = static_cast<double> (status);
+	      retval(0) = status;
 	      retval(1) = msg;
 	    }
 	}
       else
 	error ("exec: first argument must be a string");
     }
   else
     print_usage ("exec");
@@ -296,17 +296,17 @@ system-dependent error message.\n\
 	      if (fid < 0)
 		error ("fcntl: invalid file id");
 	      else
 		{
 		  std::string msg;
 
 		  int status = octave_syscalls::fcntl (fid, req, arg, msg);
 
-		  retval(0) = static_cast<double> (status);
+		  retval(0) = status;
 		  retval(1) = msg;
 		}
 	    }
 	}
       else
 	error ("fcntl: file id, request, and argument must be integers");
     }
   else
@@ -346,17 +346,17 @@ action.  A system dependent error messag
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
       pid_t pid = octave_syscalls::fork (msg);
 
-      retval(0) = static_cast<double> (pid);
+      retval(0) = pid;
       retval(1) = msg;
     }
   else
     print_usage ("fork");
 
   return retval;
 }
 
@@ -372,32 +372,32 @@ Return the process group id of the curre
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
-      retval(0) = static_cast<double> (octave_syscalls::getpgrp (msg));
+      retval(0) = octave_syscalls::getpgrp (msg);
       retval(1) = msg;
     }
   else
     print_usage ("getpgrp");
 
   return retval;
 }
 
 DEFUN (getpid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getpid ()\n\
 Return the process id of the current process.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getpid ();
   else
     print_usage ("getpid");
 
@@ -405,17 +405,17 @@ Return the process id of the current pro
 }
 
 DEFUN (getppid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getppid ()\n\
 Return the process id of the parent process.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getppid ();
   else
     print_usage ("getppid");
 
@@ -423,76 +423,76 @@ Return the process id of the parent proc
 }
 
 DEFUN (getegid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {egid =} getegid ()\n\
 Return the effective group id of the current process.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = octave_syscalls::getegid ();
+    retval = static_cast<double> (octave_syscalls::getegid ());
   else
     print_usage ("getegid");
 
   return retval;
 }
 
 DEFUN (getgid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {gid =} getgid ()\n\
 Return the real group id of the current process.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = octave_syscalls::getgid ();
+    retval = static_cast<double> (octave_syscalls::getgid ());
   else
     print_usage ("getgid");
 
   return retval;
 }
 
 DEFUN (geteuid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {euid =} geteuid ()\n\
 Return the effective user id of the current process.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = octave_syscalls::geteuid ();
+    retval = static_cast<double> (octave_syscalls::geteuid ());
   else
     print_usage ("geteuid");
 
   return retval;
 }
 
 DEFUN (getuid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {uid =} getuid ()\n\
 Return the real user id of the current process.\n\
 @end deftypefn")
 {
-  double retval = -1.0;
+  octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = octave_syscalls::getuid ();
+    retval = static_cast<double> (octave_syscalls::getuid ());
   else
     print_usage ("getuid");
 
   return retval;
 }
 
 DEFUN (lstat, args, ,
   "-*- texinfo -*-\n\
@@ -509,17 +509,17 @@ See stat.\n\
       if (! error_state)
 	{
 	  file_stat fs (fname, false);
 
 	  if (fs)
 	    {
 	      retval(2) = std::string ();
 	      retval(1) = 0.0;
-	      retval(0) = octave_value (mk_stat_map (fs));
+	      retval(0) = mk_stat_map (fs);
 	    }
 	  else
 	    {
 	      retval(2) = fs.error ();
 	      retval(1) = -1.0;
 	      retval(0) = Matrix ();
 	    }
 	}
@@ -558,17 +558,17 @@ system-dependent error message.\n\
 	  if (args(1).is_scalar_type ())
 	    {
 	      long mode = static_cast<long> (args(1).double_value ());
 
 	      std::string msg;
 
 	      int status = file_ops::mkfifo (name, mode, msg);
 
-	      retval(0) = static_cast<double> (status);
+	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	  else
 	    error ("mkfifo: MODE must be an integer");
 	}
       else
@@ -617,17 +617,17 @@ system-dependent error message.\n\
 	  octave_stream is = octave_istdiostream::create (std::string (), ifile);
 	  octave_stream os = octave_ostdiostream::create (std::string (), ofile);
 
 	  octave_value_list file_ids;
 
 	  file_ids(1) = octave_stream_list::insert (os);
 	  file_ids(0) = octave_stream_list::insert (is);
 
-	  retval(1) = static_cast<double> (status);
+	  retval(1) = status;
           retval(0) = octave_value (file_ids);
 	}
     }
   else
     print_usage ("pipe");
 
   return retval;
 }
@@ -772,17 +772,17 @@ system-dependent error message.\n\
       if (args(0).is_string ())
 	{
 	  std::string name = args(0).string_value ();
 
 	  std::string msg;
 
 	  int status = file_ops::unlink (name, msg);
 
-	  retval(0) = static_cast<double> (status);
+	  retval(0) = status;
 	  retval(1) = msg;	    
 	}
       else
 	error ("unlink: file name must be a string");
     }
   else
     print_usage ("unlink");
 
@@ -859,17 +859,17 @@ message.\n\
 	    }
 
 	  if (! error_state)
 	    {
 	      std::string msg;
 
 	      pid_t status = octave_syscalls::waitpid (pid, options, msg);
 
-	      retval(0) = static_cast<double> (status);
+	      retval(0) = status;
 	      retval(1) = msg;
 	    }
 	}
       else
 	error ("waitpid: PID must be an integer value");
     }
   else
     print_usage ("waitpid");
@@ -880,115 +880,115 @@ message.\n\
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
 void
 symbols_of_syscalls (void)
 {
 #if defined (F_DUPFD)
-  DEFCONSTX ("F_DUPFD", SBV_F_DUPFD, static_cast<double> (F_DUPFD),
+  DEFCONSTX ("F_DUPFD", SBV_F_DUPFD, F_DUPFD,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} F_DUPFD\n\
 @end defvr");
 #endif
 
 #if defined (F_GETFD)
-  DEFCONSTX ("F_GETFD", SBV_F_GETFD, static_cast<double> (F_GETFD),
+  DEFCONSTX ("F_GETFD", SBV_F_GETFD, F_GETFD,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} F_GETFD\n\
 @end defvr");
 #endif
 
 #if defined (F_GETFL)
-  DEFCONSTX ("F_GETFL", SBV_F_GETFL, static_cast<double> (F_GETFL),
+  DEFCONSTX ("F_GETFL", SBV_F_GETFL, F_GETFL,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} F_GETFL\n\
 @end defvr");
 #endif
 
 #if defined (F_SETFD)
-  DEFCONSTX ("F_SETFD", SBV_F_SETFD, static_cast<double> (F_SETFD),
+  DEFCONSTX ("F_SETFD", SBV_F_SETFD, F_SETFD,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} F_SETFD\n\
 @end defvr");
 #endif
 
 #if defined (F_SETFL)
-  DEFCONSTX ("F_SETFL", SBV_F_SETFL, static_cast<double> (F_SETFL),
+  DEFCONSTX ("F_SETFL", SBV_F_SETFL, F_SETFL,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} F_SETFL\n\
 @end defvr");
 #endif
 
 #if defined (O_APPEND)
-  DEFCONSTX ("O_APPEND", SBV_O_APPEND, static_cast<double> (O_APPEND),
+  DEFCONSTX ("O_APPEND", SBV_O_APPEND, O_APPEND,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_APPEND\n\
 @end defvr");
 #endif
 
 #if defined (O_ASYNC)
-  DEFCONSTX ("O_ASYNC", SBV_O_ASYNC, static_cast<double> (O_ASYNC),
+  DEFCONSTX ("O_ASYNC", SBV_O_ASYNC, O_ASYNC,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_ASYNC\n\
 @end defvr");
 #endif
 
 #if defined (O_CREAT)
-  DEFCONSTX ("O_CREAT", SBV_O_CREAT, static_cast<double> (O_CREAT),
+  DEFCONSTX ("O_CREAT", SBV_O_CREAT, O_CREAT,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_CREAT\n\
 @end defvr");
 #endif
 
 #if defined (O_EXCL)
-  DEFCONSTX ("O_EXCL", SBV_O_EXCL, static_cast<double> (O_EXCL),
+  DEFCONSTX ("O_EXCL", SBV_O_EXCL, O_EXCL,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_EXCL\n\
 @end defvr");
 #endif
 
 #if defined (O_NONBLOCK)
-  DEFCONSTX ("O_NONBLOCK", SBV_O_NONBLOCK, static_cast<double> (O_NONBLOCK),
+  DEFCONSTX ("O_NONBLOCK", SBV_O_NONBLOCK, O_NONBLOCK,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_NONBLOCK\n\
 @end defvr");
 #endif
 
 #if defined (O_RDONLY)
-  DEFCONSTX ("O_RDONLY", SBV_O_RDONLY, static_cast<double> (O_RDONLY),
+  DEFCONSTX ("O_RDONLY", SBV_O_RDONLY, O_RDONLY,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_RDONLY\n\
 @end defvr");
 #endif
 
 #if defined (O_RDWR)
-  DEFCONSTX ("O_RDWR", SBV_O_RDWR, static_cast<double> (O_RDWR),
+  DEFCONSTX ("O_RDWR", SBV_O_RDWR, O_RDWR,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_RDWR\n\
 @end defvr");
 #endif
 
 #if defined (O_SYNC)
-  DEFCONSTX ("O_SYNC", SBV_O_SYNC, static_cast<double> (O_SYNC),
+  DEFCONSTX ("O_SYNC", SBV_O_SYNC, O_SYNC,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_SYNC\n\
 @end defvr");
 #endif
 
 #if defined (O_TRUNC)
-  DEFCONSTX ("O_TRUNC", SBV_O_TRUNC, static_cast<double> (O_TRUNC),
+  DEFCONSTX ("O_TRUNC", SBV_O_TRUNC, O_TRUNC,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_TRUNC\n\
 @end defvr");
 #endif
 
 #if defined (O_WRONLY)
-  DEFCONSTX ("O_WRONLY", SBV_O_WRONLY, static_cast<double> (O_WRONLY),
+  DEFCONSTX ("O_WRONLY", SBV_O_WRONLY, O_WRONLY,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} O_WRONLY\n\
 @end defvr");
 #endif
 
 }
 
 /*
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -382,17 +382,17 @@ Return the value of the environment vari
 @example\n\
 getenv (\"PATH\")\n\
 @end example\n\
 \n\
 @noindent\n\
 returns a string containing the value of your path.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
@@ -456,17 +456,17 @@ it is typed.\n\
 x = kbhit (1);\n\
 @end example\n\
 \n\
 @noindent\n\
 identical to the above example, but don't wait for a keypress,\n\
 returning the empty string if no key is available.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   // XXX FIXME XXX -- add timeout and default value args?
 
   if (interactive || forced_interactive)
     {
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
@@ -603,18 +603,18 @@ DEFUN (isieee, , ,
 @deftypefn {Built-in Function} {} isieee ()\n\
 Return 1 if your computer claims to conform to the IEEE standard for\n\
 floating point calculations.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();
 
-  return static_cast<double> (flt_fmt == oct_mach_info::ieee_little_endian
-			      || flt_fmt == oct_mach_info::ieee_big_endian);
+  return octave_value (flt_fmt == oct_mach_info::ieee_little_endian
+		       || flt_fmt == oct_mach_info::ieee_big_endian);
 }
 
 DEFUN (tilde_expand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
 Performs tilde expansion on @var{string}.  If @var{string} begins with a\n\
 tilde character, (@samp{~}), all of the characters preceding the first\n\
 slash (or all characters, if there is no slash) are treated as a\n\
@@ -628,17 +628,17 @@ home directory of the user running Octav
 tilde_expand (\"~joeuser/bin\")\n\
      @result{} \"/home/joeuser/bin\"\n\
 tilde_expand (\"~/bin\")\n\
      @result{} \"/home/jwe/bin\"\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = file_ops::tilde_expand (args(0).all_strings ());
   else
     print_usage ("tilde_expand");
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -257,17 +257,17 @@ computer ()\n\
      @print{} i586-pc-linux-gnu\n\
 \n\
 x = computer ()\n\
      @result{} x = \"i586-pc-linux-gnu\"\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 0)
     warning ("computer: ignoring extra arguments");
 
   std::string msg;
 
@@ -558,17 +558,17 @@ variable @code{status} to the integer @s
 	      // The value in status is as returned by waitpid.  If
 	      // the process exited normally, extract the actual exit
 	      // status of the command.  Otherwise, return 127 as a
 	      // failure code.
 
 	      if (WIFEXITED (status))
 		status = WEXITSTATUS (status);
 
-	      retval = static_cast<double> (status);
+	      retval(0) = status;
 	    }
 	}
     }
   else
     print_usage ("system");
 
   unwind_protect::run_frame ("Fsystem");
 
@@ -583,21 +583,21 @@ std::stack<std::string> octave_atexit_fu
 
 void
 do_octave_atexit (void)
 {
   static bool deja_vu = false;
 
   while (! octave_atexit_functions.empty ())
     {
-      octave_value_list fcn = octave_atexit_functions.top ();
+      std::string fcn = octave_atexit_functions.top ();
 
       octave_atexit_functions.pop ();
 
-      feval (fcn, 0);
+      feval (fcn, octave_value_list (), 0);
 
       flush_octave_stdout ();
     }
 
   if (! deja_vu)
     {
       deja_vu = true;
 
@@ -679,132 +679,132 @@ specified option.\n\
 #if defined (ENABLE_DYNAMIC_LINKING)
   bool octave_supports_dynamic_linking = true;
 #else
   bool octave_supports_dynamic_linking = false;
 #endif
 
   Octave_map m;
 
-  m ["ALL_CFLAGS"] = OCTAVE_CONF_ALL_CFLAGS;
-  m ["ALL_CXXFLAGS"] = OCTAVE_CONF_ALL_CXXFLAGS;
-  m ["ALL_FFLAGS"] = OCTAVE_CONF_ALL_FFLAGS;
-  m ["ALL_LDFLAGS"] = OCTAVE_CONF_ALL_LDFLAGS;
-  m ["AR"] = OCTAVE_CONF_AR;
-  m ["ARFLAGS"] = OCTAVE_CONF_ARFLAGS;
-  m ["BLAS_LIBS"] = OCTAVE_CONF_BLAS_LIBS;
-  m ["CC"] = OCTAVE_CONF_CC;
-  m ["CC_VERSION"] = OCTAVE_CONF_CC_VERSION;
-  m ["CFLAGS"] = OCTAVE_CONF_CFLAGS;
-  m ["CPICFLAG"] = OCTAVE_CONF_CPICFLAG;
-  m ["CPPFLAGS"] = OCTAVE_CONF_CPPFLAGS;
-  m ["CXX"] = OCTAVE_CONF_CXX;
-  m ["CXXCPP"] = OCTAVE_CONF_CXXCPP;
-  m ["CXXFLAGS"] = OCTAVE_CONF_CXXFLAGS;
-  m ["CXXPICFLAG"] = OCTAVE_CONF_CXXPICFLAG;
-  m ["CXX_VERSION"] = OCTAVE_CONF_CXX_VERSION;
-  m ["DEFAULT_PAGER"] = OCTAVE_DEFAULT_PAGER;
-  m ["DLFCN_INCFLAGS"] = OCTAVE_CONF_DLFCN_INCFLAGS;
-  m ["EXEEXT"] = OCTAVE_CONF_EXEEXT;
-  m ["F2C"] = OCTAVE_CONF_F2C;
-  m ["F2CFLAGS"] = OCTAVE_CONF_F2CFLAGS;
-  m ["F77"] = OCTAVE_CONF_F77;
-  m ["FC"] = OCTAVE_CONF_FC;
-  m ["FFLAGS"] = OCTAVE_CONF_FFLAGS;
-  m ["FFTW_LIBS"] = OCTAVE_CONF_FFTW_LIBS;
-  m ["FLIBS"] = OCTAVE_CONF_FLIBS;
-  m ["FPICFLAG"] = OCTAVE_CONF_FPICFLAG;
-  m ["GLOB_INCFLAGS"] = OCTAVE_CONF_GLOB_INCFLAGS;
-  m ["INCFLAGS"] = OCTAVE_CONF_INCFLAGS;
-  m ["LDFLAGS"] = OCTAVE_CONF_LDFLAGS;
-  m ["LD_CXX"] = OCTAVE_CONF_LD_CXX;
-  m ["LD_STATIC_FLAG"] = OCTAVE_CONF_LD_STATIC_FLAG;
-  m ["LEX"] = OCTAVE_CONF_LEX;
-  m ["LEXLIB"] = OCTAVE_CONF_LEXLIB;
-  m ["LFLAGS"] = OCTAVE_CONF_LFLAGS;
-  m ["LIBCRUFT"] = OCTAVE_CONF_LIBCRUFT;
-  m ["LIBDLFCN"] = OCTAVE_CONF_LIBDLFCN;
-  m ["LIBEXT"] = OCTAVE_CONF_LIBEXT;
-  m ["LIBFLAGS"] = OCTAVE_CONF_LIBFLAGS;
-  m ["LIBGLOB"] = OCTAVE_CONF_LIBGLOB;
-  m ["LIBKPATHSEA"] = OCTAVE_CONF_LIBKPATHSEA;
-  m ["LIBOCTAVE"] = OCTAVE_CONF_LIBOCTAVE;
-  m ["LIBOCTINTERP"] = OCTAVE_CONF_LIBOCTINTERP;
-  m ["LIBPLPLOT"] = OCTAVE_CONF_LIBPLPLOT;
-  m ["LIBREADLINE"] = OCTAVE_CONF_LIBREADLINE;
-  m ["LIBS"] = OCTAVE_CONF_LIBS;
-  m ["LN_S"] = OCTAVE_CONF_LN_S;
-  m ["MKOCTFILE_INCFLAGS"] = OCTAVE_CONF_MKOCTFILE_INCFLAGS;
-  m ["MKOCTFILE_LFLAGS"] = OCTAVE_CONF_MKOCTFILE_LFLAGS;
-  m ["MKOCTFILE_SH_LDFLAGS"] = OCTAVE_CONF_MKOCTFILE_SH_LDFLAGS;
-  m ["RANLIB"] = OCTAVE_CONF_RANLIB;
-  m ["RDYNAMIC_FLAG"] = OCTAVE_CONF_RDYNAMIC_FLAG;
-  m ["RLD_FLAG"] = OCTAVE_CONF_RLD_FLAG;
-  m ["RUNTEST"] = OCTAVE_CONF_RUNTEST;
-  m ["SED"] = OCTAVE_CONF_SED;
-  m ["SHARED_LIBS"] = OCTAVE_CONF_SHARED_LIBS;
-  m ["SHLEXT"] = OCTAVE_CONF_SHLEXT;
-  m ["SHLEXT_VER"] = OCTAVE_CONF_SHLEXT_VER;
-  m ["SH_LD"] = OCTAVE_CONF_SH_LD;
-  m ["SH_LDFLAGS"] = OCTAVE_CONF_SH_LDFLAGS;
-  m ["SONAME_FLAGS"] = OCTAVE_CONF_SONAME_FLAGS;
-  m ["STATIC_LIBS"] = OCTAVE_CONF_STATIC_LIBS;
-  m ["UGLY_DEFS"] = OCTAVE_CONF_DEFS;
-  m ["UGLY_DEFS"] = OCTAVE_CONF_UGLY_DEFS;
-  m ["ENABLE_DYNAMIC_LINKING"] = OCTAVE_CONF_ENABLE_DYNAMIC_LINKING;
-  m ["XTRA_CFLAGS"] = OCTAVE_CONF_XTRA_CFLAGS;
-  m ["XTRA_CXXFLAGS"] = OCTAVE_CONF_XTRA_CXXFLAGS;
-  m ["YACC"] = OCTAVE_CONF_YACC;
-  m ["YFLAGS"] = OCTAVE_CONF_YFLAGS;
-  m ["archlibdir"] = OCTAVE_ARCHLIBDIR;
-  m ["bindir"] = OCTAVE_BINDIR;
-  m ["canonical_host_type"] = OCTAVE_CANONICAL_HOST_TYPE;
-  m ["config_opts"] = OCTAVE_CONF_config_opts;
-  m ["datadir"] = OCTAVE_DATADIR;
-  m ["dld"] = static_cast<double> (octave_supports_dynamic_linking);
-  m ["exec_prefix"] = OCTAVE_EXEC_PREFIX;
-  m ["fcnfiledir"] = OCTAVE_FCNFILEDIR;
-  m ["fcnfilepath"] = OCTAVE_FCNFILEPATH;
-  m ["imagedir"] = OCTAVE_IMAGEDIR;
-  m ["imagepath"] = OCTAVE_IMAGEPATH;
-  m ["includedir"] = OCTAVE_INCLUDEDIR;
-  m ["infodir"] = OCTAVE_INFODIR;
-  m ["infofile"] = OCTAVE_INFOFILE;
-  m ["libdir"] = OCTAVE_LIBDIR;
-  m ["libexecdir"] = OCTAVE_LIBEXECDIR;
-  m ["localarchlibdir"] = OCTAVE_LOCALARCHLIBDIR;
-  m ["localfcnfiledir"] = OCTAVE_LOCALFCNFILEDIR;
-  m ["localfcnfilepath"] = OCTAVE_LOCALFCNFILEPATH;
-  m ["localoctfiledir"] = OCTAVE_LOCALOCTFILEDIR;
-  m ["localoctfilepath"] = OCTAVE_LOCALOCTFILEPATH;
-  m ["localstartupfiledir"] = OCTAVE_LOCALSTARTUPFILEDIR;
-  m ["localverarchlibdir"] = OCTAVE_LOCALVERARCHLIBDIR;
-  m ["localverfcnfiledir"] = OCTAVE_LOCALVERFCNFILEDIR;
-  m ["localveroctfiledir"] = OCTAVE_LOCALVEROCTFILEDIR;
-  m ["man1dir"] = OCTAVE_MAN1DIR;
-  m ["man1ext"] = OCTAVE_MAN1EXT;
-  m ["mandir"] = OCTAVE_MANDIR;
-  m ["octfiledir"] = OCTAVE_OCTFILEDIR;
-  m ["octincludedir"] = OCTAVE_OCTINCLUDEDIR;
-  m ["octlibdir"] = OCTAVE_OCTLIBDIR;
-  m ["prefix"] = OCTAVE_PREFIX;
-  m ["startupfiledir"] = OCTAVE_STARTUPFILEDIR;
-  m ["version"] = OCTAVE_VERSION;
+  m ["ALL_CFLAGS"](0) = OCTAVE_CONF_ALL_CFLAGS;
+  m ["ALL_CXXFLAGS"](0) = OCTAVE_CONF_ALL_CXXFLAGS;
+  m ["ALL_FFLAGS"](0) = OCTAVE_CONF_ALL_FFLAGS;
+  m ["ALL_LDFLAGS"](0) = OCTAVE_CONF_ALL_LDFLAGS;
+  m ["AR"](0) = OCTAVE_CONF_AR;
+  m ["ARFLAGS"](0) = OCTAVE_CONF_ARFLAGS;
+  m ["BLAS_LIBS"](0) = OCTAVE_CONF_BLAS_LIBS;
+  m ["CC"](0) = OCTAVE_CONF_CC;
+  m ["CC_VERSION"](0) = OCTAVE_CONF_CC_VERSION;
+  m ["CFLAGS"](0) = OCTAVE_CONF_CFLAGS;
+  m ["CPICFLAG"](0) = OCTAVE_CONF_CPICFLAG;
+  m ["CPPFLAGS"](0) = OCTAVE_CONF_CPPFLAGS;
+  m ["CXX"](0) = OCTAVE_CONF_CXX;
+  m ["CXXCPP"](0) = OCTAVE_CONF_CXXCPP;
+  m ["CXXFLAGS"](0) = OCTAVE_CONF_CXXFLAGS;
+  m ["CXXPICFLAG"](0) = OCTAVE_CONF_CXXPICFLAG;
+  m ["CXX_VERSION"](0) = OCTAVE_CONF_CXX_VERSION;
+  m ["DEFAULT_PAGER"](0) = OCTAVE_DEFAULT_PAGER;
+  m ["DLFCN_INCFLAGS"](0) = OCTAVE_CONF_DLFCN_INCFLAGS;
+  m ["EXEEXT"](0) = OCTAVE_CONF_EXEEXT;
+  m ["F2C"](0) = OCTAVE_CONF_F2C;
+  m ["F2CFLAGS"](0) = OCTAVE_CONF_F2CFLAGS;
+  m ["F77"](0) = OCTAVE_CONF_F77;
+  m ["FC"](0) = OCTAVE_CONF_FC;
+  m ["FFLAGS"](0) = OCTAVE_CONF_FFLAGS;
+  m ["FFTW_LIBS"](0) = OCTAVE_CONF_FFTW_LIBS;
+  m ["FLIBS"](0) = OCTAVE_CONF_FLIBS;
+  m ["FPICFLAG"](0) = OCTAVE_CONF_FPICFLAG;
+  m ["GLOB_INCFLAGS"](0) = OCTAVE_CONF_GLOB_INCFLAGS;
+  m ["INCFLAGS"](0) = OCTAVE_CONF_INCFLAGS;
+  m ["LDFLAGS"](0) = OCTAVE_CONF_LDFLAGS;
+  m ["LD_CXX"](0) = OCTAVE_CONF_LD_CXX;
+  m ["LD_STATIC_FLAG"](0) = OCTAVE_CONF_LD_STATIC_FLAG;
+  m ["LEX"](0) = OCTAVE_CONF_LEX;
+  m ["LEXLIB"](0) = OCTAVE_CONF_LEXLIB;
+  m ["LFLAGS"](0) = OCTAVE_CONF_LFLAGS;
+  m ["LIBCRUFT"](0) = OCTAVE_CONF_LIBCRUFT;
+  m ["LIBDLFCN"](0) = OCTAVE_CONF_LIBDLFCN;
+  m ["LIBEXT"](0) = OCTAVE_CONF_LIBEXT;
+  m ["LIBFLAGS"](0) = OCTAVE_CONF_LIBFLAGS;
+  m ["LIBGLOB"](0) = OCTAVE_CONF_LIBGLOB;
+  m ["LIBKPATHSEA"](0) = OCTAVE_CONF_LIBKPATHSEA;
+  m ["LIBOCTAVE"](0) = OCTAVE_CONF_LIBOCTAVE;
+  m ["LIBOCTINTERP"](0) = OCTAVE_CONF_LIBOCTINTERP;
+  m ["LIBPLPLOT"](0) = OCTAVE_CONF_LIBPLPLOT;
+  m ["LIBREADLINE"](0) = OCTAVE_CONF_LIBREADLINE;
+  m ["LIBS"](0) = OCTAVE_CONF_LIBS;
+  m ["LN_S"](0) = OCTAVE_CONF_LN_S;
+  m ["MKOCTFILE_INCFLAGS"](0) = OCTAVE_CONF_MKOCTFILE_INCFLAGS;
+  m ["MKOCTFILE_LFLAGS"](0) = OCTAVE_CONF_MKOCTFILE_LFLAGS;
+  m ["MKOCTFILE_SH_LDFLAGS"](0) = OCTAVE_CONF_MKOCTFILE_SH_LDFLAGS;
+  m ["RANLIB"](0) = OCTAVE_CONF_RANLIB;
+  m ["RDYNAMIC_FLAG"](0) = OCTAVE_CONF_RDYNAMIC_FLAG;
+  m ["RLD_FLAG"](0) = OCTAVE_CONF_RLD_FLAG;
+  m ["RUNTEST"](0) = OCTAVE_CONF_RUNTEST;
+  m ["SED"](0) = OCTAVE_CONF_SED;
+  m ["SHARED_LIBS"](0) = OCTAVE_CONF_SHARED_LIBS;
+  m ["SHLEXT"](0) = OCTAVE_CONF_SHLEXT;
+  m ["SHLEXT_VER"](0) = OCTAVE_CONF_SHLEXT_VER;
+  m ["SH_LD"](0) = OCTAVE_CONF_SH_LD;
+  m ["SH_LDFLAGS"](0) = OCTAVE_CONF_SH_LDFLAGS;
+  m ["SONAME_FLAGS"](0) = OCTAVE_CONF_SONAME_FLAGS;
+  m ["STATIC_LIBS"](0) = OCTAVE_CONF_STATIC_LIBS;
+  m ["UGLY_DEFS"](0) = OCTAVE_CONF_DEFS;
+  m ["UGLY_DEFS"](0) = OCTAVE_CONF_UGLY_DEFS;
+  m ["ENABLE_DYNAMIC_LINKING"](0) = OCTAVE_CONF_ENABLE_DYNAMIC_LINKING;
+  m ["XTRA_CFLAGS"](0) = OCTAVE_CONF_XTRA_CFLAGS;
+  m ["XTRA_CXXFLAGS"](0) = OCTAVE_CONF_XTRA_CXXFLAGS;
+  m ["YACC"](0) = OCTAVE_CONF_YACC;
+  m ["YFLAGS"](0) = OCTAVE_CONF_YFLAGS;
+  m ["archlibdir"](0) = OCTAVE_ARCHLIBDIR;
+  m ["bindir"](0) = OCTAVE_BINDIR;
+  m ["canonical_host_type"](0) = OCTAVE_CANONICAL_HOST_TYPE;
+  m ["config_opts"](0) = OCTAVE_CONF_config_opts;
+  m ["datadir"](0) = OCTAVE_DATADIR;
+  m ["dld"](0) = octave_supports_dynamic_linking;
+  m ["exec_prefix"](0) = OCTAVE_EXEC_PREFIX;
+  m ["fcnfiledir"](0) = OCTAVE_FCNFILEDIR;
+  m ["fcnfilepath"](0) = OCTAVE_FCNFILEPATH;
+  m ["imagedir"](0) = OCTAVE_IMAGEDIR;
+  m ["imagepath"](0) = OCTAVE_IMAGEPATH;
+  m ["includedir"](0) = OCTAVE_INCLUDEDIR;
+  m ["infodir"](0) = OCTAVE_INFODIR;
+  m ["infofile"](0) = OCTAVE_INFOFILE;
+  m ["libdir"](0) = OCTAVE_LIBDIR;
+  m ["libexecdir"](0) = OCTAVE_LIBEXECDIR;
+  m ["localarchlibdir"](0) = OCTAVE_LOCALARCHLIBDIR;
+  m ["localfcnfiledir"](0) = OCTAVE_LOCALFCNFILEDIR;
+  m ["localfcnfilepath"](0) = OCTAVE_LOCALFCNFILEPATH;
+  m ["localoctfiledir"](0) = OCTAVE_LOCALOCTFILEDIR;
+  m ["localoctfilepath"](0) = OCTAVE_LOCALOCTFILEPATH;
+  m ["localstartupfiledir"](0) = OCTAVE_LOCALSTARTUPFILEDIR;
+  m ["localverarchlibdir"](0) = OCTAVE_LOCALVERARCHLIBDIR;
+  m ["localverfcnfiledir"](0) = OCTAVE_LOCALVERFCNFILEDIR;
+  m ["localveroctfiledir"](0) = OCTAVE_LOCALVEROCTFILEDIR;
+  m ["man1dir"](0) = OCTAVE_MAN1DIR;
+  m ["man1ext"](0) = OCTAVE_MAN1EXT;
+  m ["mandir"](0) = OCTAVE_MANDIR;
+  m ["octfiledir"](0) = OCTAVE_OCTFILEDIR;
+  m ["octincludedir"](0) = OCTAVE_OCTINCLUDEDIR;
+  m ["octlibdir"](0) = OCTAVE_OCTLIBDIR;
+  m ["prefix"](0) = OCTAVE_PREFIX;
+  m ["startupfiledir"](0) = OCTAVE_STARTUPFILEDIR;
+  m ["version"](0) = OCTAVE_VERSION;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       if (! error_state)
-	retval = octave_value (m [arg.c_str ()](0));
+	retval = m [arg.c_str ()](0);
     }
   else if (nargin == 0)
-    retval = octave_value (m);
+    retval = m;
   else
     print_usage ("octave_config_info");
 
   return retval;
 }
 
 #if defined (__GNUG__) && defined (DEBUG_NEW_DELETE)
 
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -818,17 +818,17 @@ treat_neg_dim_as_zero (void)
   Vtreat_neg_dim_as_zero = check_preference ("treat_neg_dim_as_zero");
 
   return 0;
 }
 
 void
 symbols_of_utils (void)
 {
-  DEFVAR (treat_neg_dim_as_zero, 0.0, treat_neg_dim_as_zero,
+  DEFVAR (treat_neg_dim_as_zero, false, treat_neg_dim_as_zero,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} treat_neg_dim_as_zero\n\
 If the value of @code{treat_neg_dim_as_zero} is nonzero, expressions\n\
 like\n\
 \n\
 @example\n\
 eye (-1)\n\
 @end example\n\
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -497,17 +497,17 @@ example,\n\
 @group\n\
 global x\n\
 isglobal (\"x\")\n\
      @result{} 1\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value retval = 0.0;
+  octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("isglobal");
       return retval;
     }
@@ -517,17 +517,17 @@ isglobal (\"x\")\n\
   if (error_state)
     {
       error ("isglobal: expecting std::string argument");
       return retval;
     }
 
   symbol_record *sr = curr_sym_tab->lookup (name);
 
-  retval = static_cast<double> (sr && sr->is_linked_to_global ());
+  retval = (sr && sr->is_linked_to_global ());
 
   return retval;
 }
 
 int
 symbol_exist (const std::string& name, const std::string& type)
 {
   int retval = 0;
@@ -666,31 +666,31 @@ Check only for variables.\n\
 Check only for built-in functions.\n\
 @item \"file\"\n\
 Check only for files.\n\
 @item \"dir\"\n\
 Check only for directories.\n\
 @end table\n\
 @end deftypefn")
 {
-  octave_value retval = 0.0;
+  octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
 	{
 	  std::string type
 	    = (nargin == 2) ? args(1).string_value () : std::string ("any");
 
 	  if (! error_state)
-	    retval = static_cast<double> (symbol_exist (name, type));
+	    retval = symbol_exist (name, type);
 	  else
 	    error ("exist: expecting second argument to be a string");
 	}
       else
 	error ("exist: expecting first argument to be a string");
     }
   else
     print_usage ("exist");
