# HG changeset patch
# User jwe
# Date 1113342931 0
#      Tue Apr 12 21:55:31 2005 +0000
# Node ID bd32f770c09ab9eeca96c7bd651ee9aa6a1f37e4
# Parent  fe23ec6763b76ad60f1d19373b9a8025b8d3f874
[project @ 2005-04-12 21:55:31 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,56 @@
+2005-04-12  John W. Eaton  <jwe@octave.org>
+
+	* file-io.cc (Ffprintf, Fprintf, Fsprintf):
+	Pass octave_value to octave_stream::printf for FMT.
+	(Fscanf, Fsscanf): Likewise, for octave_stream::scanf and
+	octave_stream::oscanf.
+
+	* oct-stream.cc, oct-stream.h (octave_stream::printf,
+	octave_stream::scanf, octave_stream::oscanf): New versions that
+	accept an octave_value for FMT.
+	(octave_stream::puts): New version that accepts octave_value for
+	value to print.
+	(octave_base_stream::do_scanf): If all_char_conv, force
+	conversion to string to avoid warning.
+
+	* ov-str-mat.h, ov-str-mat.cc (octave_char_matrix_sq_str): New class.
+	(octave_char_matrix_dq_str): New typedef.
+
+	* ov.h, ov.cc: All string constructors now take type argument.
+
+	* ov.cc (install_types): Register octave_char_matrix_sq_str.
+
+	* ov.h (octave_value::convert_to_str): New arg, type.
+	(octave_value::convert_to_str_internal): Likewise.
+	Change all derived classes.
+
+	* ov.h (octave_value::is_sq_string): New predicate.
+
+	* octave.gperf (__FILE__): Now a DQ_STRING.
+
+	* ls-mat4.cc (read_mat_binary_data): Force sq strings here.
+	* ls-mat5.cc (read_mat5_binary_element): And here.
+
+	* lex.l (<COMMAND_START>[\;\,]): Return SQ_STRING, not STRING.
+	(<COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}*): Likewise.
+	(handle_string): Type of string to return depends on delimeter.
+
+	* parse.y (DQ_STRING, SQ_STRING): New token types.
+	(STRING): Delete token type.
+	(string): New non-terminal.
+	(constant): Recognize string here instead of STRING.
+	(word_list): Likewise.
+	(opt_sep): Handle DQ_STRING and SQ_STRING.
+
+	* OPERATORS/op-str-m.cc, OPERATORS/op-str-s.cc,
+	OPERATORS/op-str-str.cc: Define operators for both sq and dq
+	strings.
+
 2005-04-08  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (clean): Use exact filenames instead of *.xxx.
 	Also remove PKG_ADD.
 	(DISTFILES): Add gplot.cc to the list.
 	(maintainer-clean): Remove gplot.cc here.
 
 	* Initial merge of 64-bit changes from Clinton Chee:
diff --git a/src/OPERATORS/op-str-m.cc b/src/OPERATORS/op-str-m.cc
--- a/src/OPERATORS/op-str-m.cc
+++ b/src/OPERATORS/op-str-m.cc
@@ -31,52 +31,60 @@ Software Foundation, 59 Temple Place - S
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_matrix&);
 
-  octave_value tmp = v2.convert_to_str_internal (false, false);
+  octave_value tmp
+    = v2.convert_to_str_internal (false, false,
+				  a1.is_sq_string () ? '\'' : '"');
 
   if (! error_state)
     v1.assign (idx, tmp.char_matrix_value ());
 
   return octave_value ();
 }
 
 DEFCATOP (str_m, char_matrix_str, matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_matrix&);
 
   if (Vwarn_num_to_str)
     gripe_implicit_conversion (v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (), 
-			       ra_idx), true);
+						       ra_idx),
+		       true, a1.is_sq_string () ? '\'' : '"');
 }
 
 DEFCATOP (m_str, matrix, char_matrix_str)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix_str&);
 
   if (Vwarn_num_to_str)
     gripe_implicit_conversion (v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (), 
-			       ra_idx), true);
+						  ra_idx),
+		       true, a2.is_sq_string () ? '\'' : '"');
 }
 
 void
 install_str_m_ops (void)
 {
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_matrix, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_matrix, assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_matrix, str_m);
+  INSTALL_CATOP (octave_char_matrix_sq_str, octave_matrix, str_m);
+
   INSTALL_CATOP (octave_matrix, octave_char_matrix_str, m_str);
+  INSTALL_CATOP (octave_matrix, octave_char_matrix_sq_str, m_str);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-str-s.cc b/src/OPERATORS/op-str-s.cc
--- a/src/OPERATORS/op-str-s.cc
+++ b/src/OPERATORS/op-str-s.cc
@@ -31,52 +31,60 @@ Software Foundation, 59 Temple Place - S
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_scalar&);
 
-  octave_value tmp = v2.convert_to_str_internal (false, false);
+  octave_value tmp
+    = v2.convert_to_str_internal (false, false,
+ 				  a1.is_sq_string () ? '\'' : '"');
 
   if (! error_state)
     v1.assign (idx, tmp.char_matrix_value ());
 
   return octave_value ();
 }
 
 DEFCATOP (str_s, char_matrix_str, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_scalar&);
 
   if (Vwarn_num_to_str)
     gripe_implicit_conversion (v2.type_name (), v1.type_name ());
 
-  return octave_value (v1.char_array_value (). concat (v2.array_value (), 
-			       ra_idx), true);
+  return octave_value (v1.char_array_value (). concat (v2.array_value (),
+						       ra_idx),
+		       true, a1.is_sq_string () ? '\'' : '"');
 }
 
 DEFCATOP (s_str, scalar, char_matrix_str)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix_str&);
 
   if (Vwarn_num_to_str)
     gripe_implicit_conversion (v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (), 
-			       ra_idx), true);
+						  ra_idx),
+		       true, a2.is_sq_string () ? '\'' : '"');
 }
 
 void
 install_str_s_ops (void)
 {
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_scalar, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_scalar, assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_scalar, str_s);
+  INSTALL_CATOP (octave_char_matrix_sq_str, octave_scalar, str_s);
+
   INSTALL_CATOP (octave_scalar, octave_char_matrix_str, s_str);
+  INSTALL_CATOP (octave_scalar, octave_char_matrix_sq_str, s_str);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -28,27 +28,28 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 // string unary ops.
 
-DEFUNOP (transpose, matrix)
+DEFUNOP (transpose, char_matrix_str)
 {
   CAST_UNOP_ARG (const octave_char_matrix_str&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.char_matrix_value().transpose (), true);
+    return octave_value (v.char_matrix_value().transpose (), true,
+			 a.is_sq_string () ? '\'' : '"');
 }
 
 // string by string ops.
 
 DEFBINOP (eq, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (const octave_char_matrix_str&,
 		   const octave_char_matrix_str&);
@@ -112,30 +113,49 @@ DEFASSIGNOP (assign, char_matrix_str, ch
   v1.assign (idx, v2.char_matrix_value ());
   return octave_value ();
 }
 
 DEFCATOP (str_str, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
   return octave_value (v1.char_array_value (). concat (v2.char_array_value (), 
-			       ra_idx), true);
+						       ra_idx),
+		       true,
+		       (a1.is_sq_string () && a2.is_sq_string ()
+			? '\'' : '"'));
 }
 
 void
 install_str_str_ops (void)
 {
   INSTALL_UNOP (op_transpose, octave_char_matrix_str, transpose);
+  INSTALL_UNOP (op_transpose, octave_char_matrix_sq_str, transpose);
+
   INSTALL_UNOP (op_hermitian, octave_char_matrix_str, transpose);
+  INSTALL_UNOP (op_hermitian, octave_char_matrix_sq_str, transpose);
 
   INSTALL_BINOP (op_eq, octave_char_matrix_str, octave_char_matrix_str, eq);
+  INSTALL_BINOP (op_eq, octave_char_matrix_str, octave_char_matrix_sq_str, eq);
+  INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_str, eq);
+  INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str, eq);
+
   INSTALL_BINOP (op_ne, octave_char_matrix_str, octave_char_matrix_str, ne);
+  INSTALL_BINOP (op_ne, octave_char_matrix_str, octave_char_matrix_sq_str, ne);
+  INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_str, ne);
+  INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_sq_str, ne);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_char_matrix_str, str_str);
+  INSTALL_CATOP (octave_char_matrix_str, octave_char_matrix_sq_str, str_str);
+  INSTALL_CATOP (octave_char_matrix_sq_str, octave_char_matrix_str, str_str);
+  INSTALL_CATOP (octave_char_matrix_sq_str, octave_char_matrix_sq_str, str_str);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_char_matrix_str, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_char_matrix_sq_str, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_char_matrix_str, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str, assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -771,29 +771,27 @@ written to the stream @var{fid} instead 
 	  fmt_n = 1;
 	  os = octave_stream_list::lookup (args(0), who);
 	}
 
       if (! error_state)
 	{
 	  if (args(fmt_n).is_string ())
 	    {
-	      std::string fmt = args(fmt_n).string_value ();
-
 	      octave_value_list tmp_args;
 
 	      if (nargin > 1 + fmt_n)
 		{
 		  tmp_args.resize (nargin-fmt_n-1, octave_value ());
 
 		  for (int i = fmt_n + 1; i < nargin; i++)
 		    tmp_args(i-fmt_n-1) = args(i);
 		}
 
-	      result = os.printf (fmt, tmp_args, who);
+	      result = os.printf (args(fmt_n), tmp_args, who);
 	    }
 	  else
 	    ::error ("%s: format must be a string", who.c_str ());
 	}
     }
   else
     print_usage (who);
 
@@ -820,29 +818,27 @@ Return the number of characters printed.
   int result = -1;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       if (args(0).is_string ())
 	{
-	  std::string fmt = args(0).string_value ();
-
 	  octave_value_list tmp_args;
 
 	  if (nargin > 1)
 	    {
 	      tmp_args.resize (nargin-1, octave_value ());
 
 	      for (int i = 1; i < nargin; i++)
 		tmp_args(i-1) = args(i);
 	    }
 
-	  result = stdout_stream.printf (fmt, tmp_args, who);
+	  result = stdout_stream.printf (args(0), tmp_args, who);
 	}
       else
 	::error ("%s: format must be a string", who.c_str ());
     }
   else
     print_usage (who);
 
   if (nargout > 0)
@@ -924,29 +920,27 @@ converted.\n\
       octave_ostrstream *ostr = new octave_ostrstream ();
 
       octave_stream os (ostr);
 
       if (os.is_valid ())
 	{
 	  if (args(0).is_string ())
 	    {
-	      std::string fmt = args(0).string_value ();
-
 	      octave_value_list tmp_args;
 
 	      if (nargin > 1)
 		{
 		  tmp_args.resize (nargin-1, octave_value ());
 
 		  for (int i = 1; i < nargin; i++)
 		    tmp_args(i-1) = args(i);
 		}
 
-	      retval(2) = os.printf (fmt, tmp_args, who);
+	      retval(2) = os.printf (args(0), tmp_args, who);
 	      retval(1) = os.error ();
 	      retval(0) = ostr->str ();
 	    }
 	  else
 	    ::error ("%s: format must be a string", who.c_str ());
 	}
       else
 	::error ("%s: unable to create output buffer", who.c_str ());
@@ -1009,21 +1003,17 @@ conversions is returned in @var{count}\n
 
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
 	{
 	  if (args(1).is_string ())
-	    {
-	      std::string fmt = args(1).string_value ();
-
-	      retval = os.oscanf (fmt, who);
-	    }
+	    retval = os.oscanf (args(1), who);
 	  else
 	    ::error ("%s: format must be a string", who.c_str ());
 	}
     }
   else
     {
       retval (1) = 0.0;
       retval (0) = Matrix ();
@@ -1031,27 +1021,25 @@ conversions is returned in @var{count}\n
       if (nargin == 2 || nargin == 3)
 	{
 	  octave_stream os = octave_stream_list::lookup (args(0), who);
 
 	  if (! error_state)
 	    {
 	      if (args(1).is_string ())
 		{
-		  std::string fmt = args(1).string_value ();
-
 		  octave_idx_type count = 0;
 
 		  Array<double> size = (nargin == 3)
 		    ? args(2).vector_value ()
 		    : Array<double> (1, lo_ieee_inf_value ());
 
 		  if (! error_state)
 		    {
-		      octave_value tmp = os.scanf (fmt, size, count, who);
+		      octave_value tmp = os.scanf (args(1), size, count, who);
 
 		      retval(1) = count;
 		      retval(0) = tmp;
 		    }
 		}
 	      else
 		::error ("%s: format must be a string", who.c_str ());
 	    }
@@ -1085,21 +1073,17 @@ string is treated as an end-of-file cond
 	{
 	  std::string data = args(0).string_value ();
 
 	  octave_stream os = octave_istrstream::create (data);
 
 	  if (os.is_valid ())
 	    {
 	      if (args(1).is_string ())
-		{
-		  std::string fmt = args(1).string_value ();
-
-		  retval = os.oscanf (fmt, who);
-		}
+		retval = os.oscanf (args(1), who);
 	      else
 		::error ("%s: format must be a string", who.c_str ());
 	    }
 	  else
 	    ::error ("%s: unable to create temporary input buffer",
 		     who.c_str ());
 	}
       else
@@ -1119,25 +1103,23 @@ string is treated as an end-of-file cond
 	      std::string data = args(0).string_value ();
 
 	      octave_stream os = octave_istrstream::create (data);
 
 	      if (os.is_valid ())
 		{
 		  if (args(1).is_string ())
 		    {
-		      std::string fmt = args(1).string_value ();
-
 		      octave_idx_type count = 0;
 
 		      Array<double> size = (nargin == 3)
 			? args(2).vector_value ()
 			: Array<double> (1, lo_ieee_inf_value ());
 
-		      octave_value tmp = os.scanf (fmt, size, count, who);
+		      octave_value tmp = os.scanf (args(1), size, count, who);
 
 		      // XXX FIXME XXX -- is this the right thing to do?
 		      // Extract error message first, because getting
 		      // position will clear it.
 		      std::string errmsg = os.error ();
 
 		      retval(3) = os.tell () + 1;
 		      retval(2) = errmsg;
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -316,34 +316,34 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.doing_rawcommand = false;
     COUNT_TOK_AND_RETURN ('\n');
   }
 
 <COMMAND_START>[\;\,] {
     if (lexer_flags.doing_rawcommand)
-      TOK_PUSH_AND_RETURN (yytext, STRING);
+      TOK_PUSH_AND_RETURN (yytext, SQ_STRING);
 
     BEGIN (INITIAL);
 
     if (strcmp (yytext, ",") == 0)
       TOK_RETURN (',');
     else
       TOK_RETURN (';');
   }
 
 <COMMAND_START>[\"\'] {
     current_input_column++;
     COUNT_TOK_AND_RETURN (handle_string (yytext[0], true));
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     std::string tok = strip_trailing_whitespace (yytext);
-    TOK_PUSH_AND_RETURN (tok, STRING);
+    TOK_PUSH_AND_RETURN (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is `=' or `=='.
 //
 // It would have been so much easier if the delimiters were simply
 // different for the expression on the left hand side of the equals
@@ -1978,17 +1978,17 @@ handle_string (char delim, int text_styl
 		  if (lexer_flags.doing_rawcommand)
 		    buf << static_cast<char> (c);
 		}
 	      else
 		{
 		  std::string s;  
 		  yyunput (c, yytext);
 		  buf << OSSTREAM_ENDS;
-		  if (lexer_flags.doing_rawcommand)
+		  if (lexer_flags.doing_rawcommand || delim == '\'')
 		    s = OSSTREAM_STR (buf);
 		  else
 		    s = do_string_escapes (OSSTREAM_STR(buf));
 		  OSSTREAM_FREEZE (buf);
 
 		  if (text_style && lexer_flags.doing_rawcommand)
 		    s = std::string (1, delim) + s + std::string (1, delim);
 		  else
@@ -2000,17 +2000,17 @@ handle_string (char delim, int text_styl
 		  yylval.tok_val = new token (s, bos_line, bos_col);
 		  token_stack.push (yylval.tok_val);
 
 		  if (delim == '"')
 		    gripe_matlab_incompatible ("\" used as string delimiter");
 		  else if (delim == '\'')
 		    gripe_single_quote_string ();
 
-		  return STRING;
+		  return delim == '"' ? DQ_STRING : SQ_STRING;
 		}
 	    }
 	}
       else
 	{
 	  buf << static_cast<char> (c);
 	}
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -367,17 +367,17 @@ read_mat_binary_data (std::istream& is, 
 	      ctmp (i, j) = Complex (re (i, j), im (i, j));
 
 	  tc = order ? ctmp.transpose () : ctmp;
 	}
       else
 	tc = order ? re.transpose () : re;
 
       if (type == 1)
-	tc = tc.convert_to_str ();
+	tc = tc.convert_to_str (false, true, '\'');
 
       return retval;
     }
 
  data_read_error:
   error ("load: trouble reading binary file `%s'", filename.c_str ());
   return retval;
 }
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -905,17 +905,17 @@ read_mat5_binary_element (std::istream& 
 
 	    tc = ctmp;
 	  }
 	else
 	  {
 	    tc = re;
 
 	    if (arrayclass == mxCHAR_CLASS)
-	      tc = tc.convert_to_str (false, true);
+	      tc = tc.convert_to_str (false, true, '\'');
 	  }
       }
     }
 
   is.seekg (pos + static_cast<std::streamoff> (element_length));
 
   if (is.eof ())
     is.clear ();
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1943,17 +1943,17 @@ octave_base_stream::do_scanf (scanf_form
 
   if (ok ())
     {
       mval.resize (final_nr, final_nc, 0.0);
 
       retval = mval;
 
       if (all_char_conv)
-	retval = retval.convert_to_str ();
+	retval = retval.convert_to_str (false, true);
     }
 
   return retval;
 }
 
 octave_value
 octave_base_stream::scanf (const std::string& fmt, const Array<double>& size,
 			   octave_idx_type& conversion_count, const std::string& who)
@@ -3578,40 +3578,114 @@ octave_stream::scanf (const std::string&
   octave_value retval;
 
   if (stream_ok (who))
     retval = rep->scanf (fmt, size, count, who);
 
   return retval;
 }
 
+octave_value
+octave_stream::scanf (const octave_value& fmt, const Array<double>& size,
+		      int& count, const std::string& who)
+{
+  octave_value retval = Matrix ();
+
+  if (fmt.is_string ())
+    {
+      std::string sfmt = fmt.string_value ();
+
+      if (fmt.is_sq_string ())
+	sfmt = do_string_escapes (sfmt);
+
+      retval = scanf (sfmt, size, count, who);
+    }
+  else
+    {
+      // Note that this is not ::error () !
+
+      error (who + ": format must be a string");
+    }
+
+  return retval;
+}
+
 octave_value_list
 octave_stream::oscanf (const std::string& fmt, const std::string& who)
 {
   octave_value_list retval;
 
   if (stream_ok (who))
     retval = rep->oscanf (fmt, who);
 
   return retval;
 }
 
+octave_value_list
+octave_stream::oscanf (const octave_value& fmt, const std::string& who)
+{
+  octave_value_list retval;
+
+  if (fmt.is_string ())
+    {
+      std::string sfmt = fmt.string_value ();
+
+      if (fmt.is_sq_string ())
+	sfmt = do_string_escapes (sfmt);
+
+      retval = oscanf (sfmt, who);
+    }
+  else
+    {
+      // Note that this is not ::error () !
+
+      error (who + ": format must be a string");
+    }
+
+  return retval;
+}
+
 int
 octave_stream::printf (const std::string& fmt, const octave_value_list& args,
 		       const std::string& who)
 {
   int retval = -1;
 
   if (stream_ok (who))
     retval = rep->printf (fmt, args, who);
 
   return retval;
 }
 
 int
+octave_stream::printf (const octave_value& fmt, const octave_value_list& args,
+		       const std::string& who)
+{
+  int retval = 0;
+
+  if (fmt.is_string ())
+    {
+      std::string sfmt = fmt.string_value ();
+
+      if (fmt.is_sq_string ())
+	sfmt = do_string_escapes (sfmt);
+
+      retval = printf (sfmt, args, who);
+    }
+  else
+    {
+      // Note that this is not ::error () !
+
+      error (who + ": format must be a string");
+    }
+
+  return retval;
+}
+
+int
 octave_stream::puts (const std::string& s, const std::string& who)
 {
   int retval = -1;
 
   if (stream_ok (who))
     retval = rep->puts (s, who);
 
   return retval;
@@ -3622,17 +3696,17 @@ octave_stream::puts (const std::string& 
 int
 octave_stream::puts (const octave_value& tc_s, const std::string& who)
 {
   int retval = -1;
 
   if (tc_s.is_string ())
     {
       std::string s = tc_s.string_value ();      
-      retval = rep->puts (s, who);
+      retval = puts (s, who);
     }
   else
     {
       // Note that this is not ::error () !
 
       error (who + ": argument must be a string");
     }
 
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -520,22 +520,31 @@ public:
   template <class T>
   octave_idx_type write (const Array<T>&, octave_idx_type block_size,
 	     oct_data_conv::data_type output_type,
 	     octave_idx_type skip, oct_mach_info::float_format flt_fmt);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
 		      octave_idx_type& count, const std::string& who /* = "scanf" */);
 
+  octave_value scanf (const octave_value& fmt, const Array<double>& size,
+		      int& count, const std::string& who /* = "scanf" */);
+
   octave_value_list oscanf (const std::string& fmt,
 			    const std::string& who /* = "scanf" */);
 
+  octave_value_list oscanf (const octave_value& fmt,
+			    const std::string& who /* = "scanf" */);
+
   int printf (const std::string& fmt, const octave_value_list& args,
 	      const std::string& who /* = "printf" */);
 
+  int printf (const octave_value& fmt, const octave_value_list& args,
+	      const std::string& who /* = "printf" */);
+
   int puts (const std::string& s, const std::string& who /* = "puts" */);
   int puts (const octave_value& s, const std::string& who /* = "puts" */);
 
   bool eof (void) const;
 
   std::string error (bool clear, int& err_num);
 
   std::string error (bool clear = false)
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -68,10 +68,10 @@ static, STATIC, static_kw
 switch, SWITCH, switch_kw
 try, TRY, try_kw
 until, UNTIL, until_kw
 unwind_protect, UNWIND, unwind_protect_kw
 unwind_protect_cleanup, CLEANUP, unwind_protect_cleanup_kw
 varargin, VARARGIN, varargin_kw
 varargout, VARARGOUT, varargout_kw
 while, WHILE, while_kw
-__FILE__, STRING, magic_file_kw
+__FILE__, DQ_STRING, magic_file_kw
 __LINE__, NUM, magic_line_kw
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -189,17 +189,17 @@ octave_base_value::permute (const Array<
 octave_value
 octave_base_value::resize (const dim_vector&) const
 {
   gripe_wrong_type_arg ("octave_base_value::resize ()", type_name ());
   return octave_value ();
 }
 
 octave_value
-octave_base_value::convert_to_str_internal (bool, bool) const
+octave_base_value::convert_to_str_internal (bool, bool, char) const
 {
   gripe_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
 			type_name ());
   return octave_value ();
 }
 
 void
 octave_base_value::convert_to_row_or_column_vector (void)
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -119,16 +119,18 @@ public:
   bool is_complex_matrix (void) const { return false; }
 
   bool is_bool_matrix (void) const { return false; }
 
   bool is_char_matrix (void) const { return false; }
 
   bool is_string (void) const { return false; }
 
+  bool is_sq_string (void) const { return false; }
+
   bool is_range (void) const { return false; }
 
   bool is_map (void) const { return false; }
 
   bool is_stream (void) const { return false; }
 
   bool is_streamoff (void) const { return false; }
 
@@ -281,17 +283,17 @@ public:
   octave_user_function *user_function_value (bool silent = false);
 
   octave_fcn_handle *fcn_handle_value (bool silent = false);
 
   octave_fcn_inline *fcn_inline_value (bool silent = false);
 
   octave_value_list list_value (void) const;
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void convert_to_row_or_column_vector (void);
 
   bool print_as_scalar (void) const { return false; }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -131,20 +131,21 @@ octave_bool_matrix::complex_value (bool)
     }
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
-octave_bool_matrix::convert_to_str_internal (bool pad, bool force) const
+octave_bool_matrix::convert_to_str_internal (bool pad, bool force,
+					     char type) const
 {
   octave_value tmp = octave_value (array_value ());
-  return tmp.convert_to_str (pad, force);
+  return tmp.convert_to_str (pad, force, type);
 }
 
 void
 octave_bool_matrix::print_raw (std::ostream& os,
 			       bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level ());
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -112,17 +112,17 @@ public:
   { return SparseMatrix (Matrix (matrix.matrix_value ())); }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
   { return SparseComplexMatrix (ComplexMatrix (matrix.matrix_value ())); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
   { return SparseBoolMatrix (matrix.matrix_value ()); }
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os, bool& infnan_warned,
 		 bool strip_nan_and_inf);
 
   bool load_ascii (std::istream& is);
 
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -129,20 +129,21 @@ octave_sparse_bool_matrix::complex_value
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
-octave_sparse_bool_matrix::convert_to_str_internal (bool pad, bool force) const
+octave_sparse_bool_matrix::convert_to_str_internal (bool pad, bool force,
+						    char type) const
 {
   octave_value tmp = octave_value (array_value ());
-  return tmp.convert_to_str (pad, force);
+  return tmp.convert_to_str (pad, force, type);
 }
 
 // XXX FIXME XXX These are inefficient ways of creating full matrices
 
 Matrix
 octave_sparse_bool_matrix::matrix_value (bool) const
 {
   return Matrix (matrix.matrix_value ());
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -115,17 +115,17 @@ public:
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
     { return matrix; }
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -98,23 +98,23 @@ octave_bool::do_index_op (const octave_v
 
       retval = tmp.do_index_op (idx, resize_ok);
     }
 
   return retval;
 }
 
 octave_value
-octave_bool::convert_to_str_internal (bool, bool) const
+octave_bool::convert_to_str_internal (bool, bool, char type) const
 {
   char s[2];
   s[0] = static_cast<char> (scalar);
   s[1] = '\0';
 
-  return octave_value (s);
+  return octave_value (s, type);
 }
 
 bool 
 octave_bool::save_ascii (std::ostream& os, bool& /* infnan_warned */,
 			 bool /* strip_nan_and_inf */)
 {
   double d = double_value ();
 
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -106,17 +106,17 @@ public:
     { return boolMatrix (1, 1, scalar); }
 
   boolNDArray bool_array_value (void) const
     { return boolNDArray (dim_vector (1, 1), scalar); }
 
   octave_value resize (const dim_vector& dv) const
     { boolNDArray retval (dv); if (dv.numel()) retval(0) = scalar; return retval; }
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_ascii (std::ostream& os, bool& infnan_warned,
 		 bool strip_nan_and_inf);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -95,18 +95,18 @@ public:
   bool is_constant (void) const { return false; }
 
   bool is_cell (void) const { return true; }
 
   Cell cell_value (void) const { return matrix; }
 
   octave_value_list list_value (void) const;
 
-  octave_value convert_to_str_internal (bool pad, bool force) const
-    { return all_strings (pad, force); }
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const
+    { return octave_value (all_strings (pad, force), type); }
 
   string_vector all_strings (bool pad = false, bool force = false) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -109,18 +109,18 @@ public:
     { return ComplexNDArray (matrix); }
 
   charMatrix char_matrix_value (bool = false) const
     { return matrix.matrix_value (); }
 
   charNDArray char_array_value (bool = false) const
     { return matrix; }
 
-  octave_value convert_to_str_internal (bool, bool) const
-    { return octave_value (matrix, true); }
+  octave_value convert_to_str_internal (bool, bool, char type) const
+    { return octave_value (matrix, true, type); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -555,19 +555,19 @@ octave_fcn_inline::print_raw (std::ostre
   buf << ") = " << iftext << OSSTREAM_ENDS;
 
   octave_print_internal (os, OSSTREAM_STR (buf), pr_as_read_syntax,
 			 current_print_indent_level ());
   OSSTREAM_FREEZE (buf);
 }
 
 octave_value
-octave_fcn_inline::convert_to_str_internal (bool, bool) const
+octave_fcn_inline::convert_to_str_internal (bool, bool, char type) const
 {
-  return octave_value (fcn_text ());
+  return octave_value (fcn_text (), type);
 }
 
 DEFUN (inline, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} inline (@var{str})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, ...)\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -58,17 +58,17 @@ public:
   bool is_inline_function (void) const { return true; }
 
   octave_fcn_inline *fcn_inline_value (bool = false) { return this; }
 
   std::string fcn_text (void) const { return iftext; }
 
   string_vector fcn_arg_names (void) const { return ifargs; }
 
-  octave_value convert_to_str_internal (bool, bool) const;
+  octave_value convert_to_str_internal (bool, bool, char) const;
 
   bool save_ascii (std::ostream& os, bool& infnan_warned,
 		 bool strip_nan_and_inf);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -203,20 +203,20 @@ octave_range::complex_value (bool) const
     }
   else
     gripe_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
 
 octave_value
-octave_range::convert_to_str_internal (bool pad, bool force) const
+octave_range::convert_to_str_internal (bool pad, bool force, char type) const
 {
   octave_value tmp (range.matrix_value ());
-  return tmp.convert_to_str (pad, force);
+  return tmp.convert_to_str (pad, force, type);
 }
 
 void
 octave_range::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -160,17 +160,17 @@ public:
   ComplexMatrix complex_matrix_value (bool = false) const
     { return ComplexMatrix (range.matrix_value ()); }
 
   ComplexNDArray complex_array_value (bool = false) const
     { return ComplexMatrix (range.matrix_value ()); }
 
   Range range_value (void) const { return range; }
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   bool save_ascii (std::ostream& os, bool& infnan_warned,
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -194,26 +194,26 @@ octave_matrix::streamoff_array_value (vo
 	  break;
 	}
     }
 
   return retval;
 }
 
 octave_value
-octave_matrix::convert_to_str_internal (bool, bool) const
+octave_matrix::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
   dim_vector dv = dims ();
   int nel = dv.numel ();
 
   if (nel == 0)
     {
       char s = '\0';
-      retval = octave_value (&s);
+      retval = octave_value (&s, type);
     }
   else
     {
       charNDArray chm (dv);
 	  
       bool warned = false;
 
       for (octave_idx_type i = 0; i < nel; i++)
@@ -244,17 +244,17 @@ octave_matrix::convert_to_str_internal (
 		      warned = true;
 		    }
 		}
 
 	      chm (i) = static_cast<char> (ival);
 	    }
 	}
 
-      retval = octave_value (chm, 1);
+      retval = octave_value (chm, true, type);
     }
 
   return retval;
 }
 
 static Matrix
 strip_infnan (const Matrix& m)
 {
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -112,17 +112,17 @@ public:
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   streamoff_array streamoff_array_value (void) const;
 
   void increment (void) { matrix += 1.0; }
 
   void decrement (void) { matrix -= 1.0; }
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os, bool& infnan_warned,
 		 bool strip_nan_and_inf);
 
   bool load_ascii (std::istream& is);
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -101,17 +101,17 @@ octave_scalar::streamoff_array_value (vo
 
   if (! error_state)
     retval = streamoff_array (dim_vector (1, 1), soff);
 
   return retval;
 }
 
 octave_value
-octave_scalar::convert_to_str_internal (bool, bool) const
+octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
     ::error ("invalid conversion from NaN to character");
   else
     {
       int ival = NINT (scalar);
@@ -120,17 +120,17 @@ octave_scalar::convert_to_str_internal (
 	{
 	  // XXX FIXME XXX -- is there something better we could do?
 
 	  ival = 0;
 
 	  ::warning ("range error for conversion to character value");
 	}
 
-      retval = octave_value (std::string (1, static_cast<char> (ival)));
+      retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
 
   return retval;
 }
 
 bool 
 octave_scalar::save_ascii (std::ostream& os, bool& infnan_warned, 
 			   bool strip_nan_and_inf)
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -122,17 +122,17 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const
     { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
   std::streamoff streamoff_value (void) const;
 
   streamoff_array streamoff_array_value (void) const;
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void increment (void) { ++scalar; }
 
   void decrement (void) { --scalar; }
 
   bool save_ascii (std::ostream& os, bool& infnan_warned,
 		 bool strip_nan_and_inf);
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -43,18 +43,20 @@ Software Foundation, 59 Temple Place - S
 #include "pt-mat.h"
 
 #include "byte-swap.h"
 #include "ls-oct-ascii.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_str);
+DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_sq_str);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_str, "string", "char");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string", "char");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   octave_value *retval = 0;
 
   CAST_CONV_ARG (const octave_char_matrix_str&);
 
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -144,15 +144,63 @@ public:
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
+typedef octave_char_matrix_str octave_char_matrix_dq_str;
+
+class
+octave_char_matrix_sq_str : public octave_char_matrix_str
+{
+public:
+
+  octave_char_matrix_sq_str (void)
+    : octave_char_matrix_str () { }
+
+  octave_char_matrix_sq_str (const charMatrix& chm)
+    : octave_char_matrix_str (chm) { }
+
+  octave_char_matrix_sq_str (const charNDArray& chm)
+    : octave_char_matrix_str (chm) { }
+
+  octave_char_matrix_sq_str (char c)
+    : octave_char_matrix_str (c) { }
+
+  octave_char_matrix_sq_str (const char *s)
+    : octave_char_matrix_str (s) { }
+
+  octave_char_matrix_sq_str (const std::string& s)
+    : octave_char_matrix_str (s) { }
+
+  octave_char_matrix_sq_str (const string_vector& s)
+    : octave_char_matrix_str (s) { }
+
+  octave_char_matrix_sq_str (const octave_char_matrix_str& chm)
+    : octave_char_matrix_str (chm) { }
+
+  octave_char_matrix_sq_str (const octave_char_matrix_sq_str& chms)
+    : octave_char_matrix_str (chms) { }
+
+  ~octave_char_matrix_sq_str (void) { }
+
+  octave_value *clone (void) const { return new octave_char_matrix_sq_str (*this); }
+  octave_value *empty_clone (void) const { return new octave_char_matrix_sq_str (); }
+
+  bool is_sq_string (void) const { return true; }
+
+private:
+
+  DECLARE_OCTAVE_ALLOCATOR
+
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+};
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -545,65 +545,79 @@ octave_value::octave_value (const boolMa
 
 octave_value::octave_value (const boolNDArray& bnda)
   : rep (new octave_bool_matrix (bnda))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (char c)
-  : rep (new octave_char_matrix_str (c))
+octave_value::octave_value (char c, char type)
+  : rep (type == '"'
+	 ? new octave_char_matrix_dq_str (c)
+	 : new octave_char_matrix_sq_str (c))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const char *s)
-  : rep (new octave_char_matrix_str (s))
+octave_value::octave_value (const char *s, char type)
+  : rep (type == '"'
+	 ? new octave_char_matrix_dq_str (s)
+	 : new octave_char_matrix_sq_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const std::string& s)
-  : rep (new octave_char_matrix_str (s))
+octave_value::octave_value (const std::string& s, char type)
+  : rep (type == '"'
+	 ? new octave_char_matrix_dq_str (s)
+	 : new octave_char_matrix_sq_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const string_vector& s)
-  : rep (new octave_char_matrix_str (s))
+octave_value::octave_value (const string_vector& s, char type)
+  : rep (type == '"'
+	 ? new octave_char_matrix_dq_str (s)
+	 : new octave_char_matrix_sq_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const charMatrix& chm, bool is_str)
+octave_value::octave_value (const charMatrix& chm, bool is_str, char type)
   : rep (is_str
-	 ? new octave_char_matrix_str (chm)
+	 ? (type == '"'
+	    ? new octave_char_matrix_dq_str (chm)
+	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const charNDArray& chm, bool is_str)
+octave_value::octave_value (const charNDArray& chm, bool is_str, char type)
   : rep (is_str
-	 ? new octave_char_matrix_str (chm)
+	 ? (type == '"'
+	    ? new octave_char_matrix_dq_str (chm)
+	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<char>& chm, bool is_str)
+octave_value::octave_value (const ArrayN<char>& chm, bool is_str, char type)
   : rep (is_str
-	 ? new octave_char_matrix_str (chm)
+	 ? (type == '"'
+	    ? new octave_char_matrix_dq_str (chm)
+	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const SparseMatrix& m, const SparseType &t)
   : rep (new octave_sparse_matrix (m, t))
@@ -1453,19 +1467,19 @@ octave_value::complex_vector_value (bool
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex vector");
     }
 
   return retval;
 }
 
 octave_value
-octave_value::convert_to_str (bool pad, bool force) const
+octave_value::convert_to_str (bool pad, bool force, char type) const
 {
-  octave_value retval = convert_to_str_internal (pad, force);
+  octave_value retval = convert_to_str_internal (pad, force, type);
 
   if (! force && is_numeric_type () && Vwarn_num_to_str)
     gripe_implicit_conversion (type_name (), retval.type_name ());
 
   return retval;
 }
 
 void
@@ -2175,16 +2189,17 @@ install_types (void)
   octave_complex::register_type ();
   octave_matrix::register_type ();
   octave_complex_matrix::register_type ();
   octave_range::register_type ();
   octave_bool::register_type ();
   octave_bool_matrix::register_type ();
   octave_char_matrix::register_type ();
   octave_char_matrix_str::register_type ();
+  octave_char_matrix_sq_str::register_type ();
   octave_int8_scalar::register_type ();
   octave_int16_scalar::register_type ();
   octave_int32_scalar::register_type ();
   octave_int64_scalar::register_type ();
   octave_uint8_scalar::register_type ();
   octave_uint16_scalar::register_type ();
   octave_uint32_scalar::register_type ();
   octave_uint64_scalar::register_type ();
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -203,23 +203,26 @@ public:
   octave_value (const ComplexNDArray& cnda);
   octave_value (const ArrayN<Complex>& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const ComplexColumnVector& v);
   octave_value (bool b);
   octave_value (const boolMatrix& bm);
   octave_value (const boolNDArray& bnda);
-  octave_value (char c);
-  octave_value (const char *s);
-  octave_value (const std::string& s);
-  octave_value (const string_vector& s);
-  octave_value (const charMatrix& chm, bool is_string = false);
-  octave_value (const charNDArray& chnda, bool is_string = false);
-  octave_value (const ArrayN<char>& chnda, bool is_string = false);
+  octave_value (char c, char type = '"');
+  octave_value (const char *s, char type = '"');
+  octave_value (const std::string& s, char type = '"');
+  octave_value (const string_vector& s, char type = '"');
+  octave_value (const charMatrix& chm, bool is_string = false,
+		char type = '"');
+  octave_value (const charNDArray& chnda, bool is_string = false,
+		char type = '"');
+  octave_value (const ArrayN<char>& chnda, bool is_string = false,
+		char type = '"');
   octave_value (const SparseMatrix& m, const SparseType& t = SparseType ());
   octave_value (const SparseComplexMatrix& m, 
 		const SparseType& t = SparseType ());
   octave_value (const SparseBoolMatrix& bm, 
 		const SparseType& t = SparseType ());
   octave_value (const octave_int8& i);
   octave_value (const octave_int16& i);
   octave_value (const octave_int32& i);
@@ -420,16 +423,19 @@ public:
     { return rep->is_bool_matrix (); }
 
   virtual bool is_char_matrix (void) const
     { return rep->is_char_matrix (); }
 
   virtual bool is_string (void) const
     { return rep->is_string (); }
 
+  virtual bool is_sq_string (void) const
+    { return rep->is_sq_string (); }
+
   virtual bool is_range (void) const
     { return rep->is_range (); }
 
   virtual bool is_map (void) const
     { return rep->is_map (); }
 
   virtual bool is_stream (void) const
     { return rep->is_stream (); }
@@ -692,20 +698,22 @@ public:
 
   Array<Complex> complex_vector_value (bool frc_str_conv = false,
 				       bool frc_vec_conv = false) const;
 
   // Conversions.  These should probably be private.  If a user of this
   // class wants a certain kind of constant, he should simply ask for
   // it, and we should convert it if possible.
 
-  octave_value convert_to_str (bool pad = false, bool force = false) const;
+  octave_value convert_to_str (bool pad = false, bool force = false,
+			       char type = '"') const;
 
-  virtual octave_value convert_to_str_internal (bool pad, bool force) const
-    { return rep->convert_to_str_internal (pad, force); }
+  virtual octave_value
+  convert_to_str_internal (bool pad, bool force, char type) const
+    { return rep->convert_to_str_internal (pad, force, type); }
 
   virtual void convert_to_row_or_column_vector (void)
     { rep->convert_to_row_or_column_vector (); }
 
   virtual bool print_as_scalar (void) const
     { return rep->print_as_scalar (); }
 
   virtual void print (std::ostream& os, bool pr_as_read_syntax = false) const
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -401,17 +401,17 @@ set_stmt_print_flag (tree_statement_list
 %token <tok_val> EXPR_LT EXPR_LE EXPR_EQ EXPR_NE EXPR_GE EXPR_GT
 %token <tok_val> LEFTDIV EMUL EDIV ELEFTDIV EPLUS EMINUS
 %token <tok_val> QUOTE TRANSPOSE
 %token <tok_val> PLUS_PLUS MINUS_MINUS POW EPOW
 %token <tok_val> NUM IMAG_NUM
 %token <tok_val> STRUCT_ELT
 %token <tok_val> NAME
 %token <tok_val> END
-%token <tok_val> STRING
+%token <tok_val> DQ_STRING SQ_STRING
 %token <tok_val> FOR WHILE DO UNTIL
 %token <tok_val> IF ELSEIF ELSE
 %token <tok_val> SWITCH CASE OTHERWISE
 %token <tok_val> BREAK CONTINUE FUNC_RET
 %token <tok_val> UNWIND CLEANUP
 %token <tok_val> TRY CATCH
 %token <tok_val> GLOBAL STATIC
 %token <tok_val> FCN_HANDLE
@@ -420,17 +420,17 @@ set_stmt_print_flag (tree_statement_list
 %token END_OF_INPUT LEXICAL_ERROR
 %token FCN VARARGIN VARARGOUT ALL_VA_ARGS
 %token USING TITLE WITH AXES COLON OPEN_BRACE CLOSE_BRACE CLEAR
 
 // Nonterminals we construct.
 %type <comment_type> stash_comment function_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl sep opt_sep
 %type <tree_type> input
-%type <tree_constant_type> constant magic_colon anon_fcn_handle
+%type <tree_constant_type> string constant magic_colon anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr postfix_expr prefix_expr binary_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name
 %type <octave_user_function_type> function1 function2 function3
@@ -573,22 +573,28 @@ statement	: expression
 
 identifier	: NAME
 		  {
 		    $$ = new tree_identifier
 		      ($1->sym_rec (), $1->line (), $1->column ());
 		  }
 		;
 
+string		: DQ_STRING
+		  { $$ = make_constant (DQ_STRING, $1); }
+		| SQ_STRING
+		  { $$ = make_constant (SQ_STRING, $1); }
+		;
+
 constant	: NUM
 		  { $$ = make_constant (NUM, $1); }
 		| IMAG_NUM
 		  { $$ = make_constant (IMAG_NUM, $1); }
-		| STRING
-		  { $$ = make_constant (STRING, $1); }
+		| string
+		  { $$ = $1; }
 		;
 
 in_matrix_or_assign_lhs
 		: // empty
 		  { lexer_flags.looking_at_matrix_or_assign_lhs = true; }
 		;
 
 matrix		: '[' ']'
@@ -889,25 +895,21 @@ assign_expr	: assign_lhs '=' expression
 		| assign_lhs OR_EQ expression
 		  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
 		;
 
 word_list_cmd	: identifier word_list
 		  { $$ = make_index_expression ($1, $2, '('); }
 		;
 
-word_list	: STRING 
+word_list	: string
+		  { $$ = new tree_argument_list ($1); }
+		| word_list string
 		  {
-		    tree_constant *tmp = make_constant (STRING, $1);
-		    $$ = new tree_argument_list (tmp);
-		  }
-		| word_list STRING
-		  {
-		    tree_constant *tmp = make_constant (STRING, $2);
-		    $1->append (tmp);
+		    $1->append ($2);
 		    $$ = $1;
 		  }
 		;
 
 expression	: simple_expr
 		  { $$ = $1; }
 		| word_list_cmd
 		  { $$ = $1; }
@@ -1759,19 +1761,20 @@ make_constant (int op, token *tok_val)
     case IMAG_NUM:
       {
 	octave_value tmp (Complex (0.0, tok_val->number ()));
 	retval = new tree_constant (tmp, l, c);
 	retval->stash_original_text (tok_val->text_rep ());
       }
       break;
 
-    case STRING:
+    case DQ_STRING:
+    case SQ_STRING:
       {
-	octave_value tmp (tok_val->text ());
+	octave_value tmp (tok_val->text (), op == DQ_STRING ? '"' : '\'');
 	retval = new tree_constant (tmp, l, c);
       }
       break;
 
     default:
       panic_impossible ();
       break;
     }
