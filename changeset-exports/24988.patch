# HG changeset patch
# User Rik <rik@octave.org>
# Date 1521833972 25200
#      Fri Mar 23 12:39:32 2018 -0700
# Node ID a70fa26c74f8d81e8f6e78237723641ede9101d4
# Parent  62c2902bcb231f179ee3746b2752205fbaef9b1c
# Parent  a895967fd5a70558c04e20fea8854a45778fd513
maint: merge stable to default.

diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -136,20 +136,20 @@ a(end:-1:1)       # reversal of a => [4,
 
 An array with @samp{nd} dimensions can be indexed by a vector @var{idx} which
 has from 1 to @samp{nd} elements.  If any element of @var{idx} is not a
 scalar then the complete set of index tuples will be generated from the
 Cartesian product of the index elements.
 
 For the ordinary and most common case, the number of indices
 (@code{nidx = numel (@var{idx})}) matches the number of dimensions @samp{nd}.
-In this case, each element of @var{idx} corresponds to its respective dimension,
-i.e., @code{@var{idx}(1)} refers to dimension 1, @code{@var{idx}(2)} refers to
-dimension 2, etc.  If @w{@code{nidx < nd}}, and every index is less than the
-size of the array in the @math{i^{th}} dimension
+In this case, each element of @var{idx} corresponds to its respective
+dimension, i.e., @code{@var{idx}(1)} refers to dimension 1,
+@code{@var{idx}(2)} refers to dimension 2, etc.  If @w{@code{nidx < nd}}, and
+every index is less than the size of the array in the @math{i^{th}} dimension
 (@code{@var{idx}(i) < size (@var{array}, i)}), then the index expression is
 padded with @w{@code{nd - nidx}} trailing singleton dimensions.  If
 @w{@code{nidx < nd}} but one of the indices @code{@var{idx}(i)} is outside the
 size of the current array, then the last @w{@code{nd - nidx + 1}} dimensions
 are folded into a single dimension with an extent equal to the product of
 extents of the original dimensions.  This is easiest to understand with an
 example.
 
@@ -522,32 +522,34 @@ f (2, 2)
 
 @noindent
 is equivalent to calling @code{plus (2, 2)} directly.  Beyond abstraction for
 general programming, function handles find use in callback methods for figures
 and graphics by adding listeners to properties or assigning pre-existing
 actions, such as in the following example:
 
 @cindex figure deletefcn
+
 @example
 @group
 function mydeletefcn (h, ~, msg)
   printf (msg);
 endfunction
 sombrero;
 set (gcf, "deletefcn", @{@@mydeletefcn, "Bye!\n"@});
 close;
 @end group
 @end example
 
 @noindent
-The above will print "Bye!" to the terminal upon the closing (deleting) of the
-figure.  There are many graphics property actions for which a callback function
-may be assigned, including, @code{buttondownfcn}, @code{windowscrollwheelfcn},
-@code{createfcn}, @code{deletefcn}, @code{keypressfcn}, etc.
+The above will print @qcode{"Bye!"} to the terminal upon the closing
+(deleting) of the figure.  There are many graphics property actions for which
+a callback function may be assigned, including, @code{buttondownfcn},
+@code{windowscrollwheelfcn}, @code{createfcn}, @code{deletefcn},
+@code{keypressfcn}, etc.
 
 Note that the @samp{@@} character also plays a role in defining class
 functions, i.e., methods, but not as a syntactical element.  Rather it begins a
 directory name containing methods for a class that shares the directory name
 sans the @samp{@@} character.  See @ref{Object Oriented Programming}.
 
 @node Arithmetic Ops
 @section Arithmetic Operators
diff --git a/doc/interpreter/external.txi b/doc/interpreter/external.txi
--- a/doc/interpreter/external.txi
+++ b/doc/interpreter/external.txi
@@ -604,17 +604,17 @@ dimensions is larger than the representa
 can overflow.  An example is @code{speye (1e6)} which will create a matrix with
 a million rows and columns, but only a million nonzero elements.  In this case,
 the number of rows multiplied by the number of columns is more than two hundred
 times the maximum value that can be represented by an unsigned 32-bit int.  The
 use of @code{numel} should, therefore, be avoided unless it is known that it
 will not overflow.
 
 Extreme care is also required when using the @code{elem} method or the
-@qcode{()} operator which perform essentially the same function.  The reason is
+@code{()} operator which perform essentially the same function.  The reason is
 that if a sparse object is non-const, then Octave will assume that a request
 for a zero element in a sparse matrix is in fact a request to create this
 element so it can be filled.  Therefore, a piece of code like
 
 @example
 @group
 SparseMatrix sm;
 @dots{}
@@ -1080,17 +1080,17 @@ input arguments before using them to avo
 However, in some cases this might not be sufficient as the underlying code
 imposes further constraints.  For example, an external function call might be
 undefined if the input arguments are not integers, or if one of the arguments
 is zero, or if the input is complex and a real value was expected.  Therefore,
 oct-files often need additional input parameter checking.
 
 There are several functions within Octave that can be useful for the purposes
 of parameter checking.  These include the methods of the @code{octave_value}
-class like @code{is_real_matrix}, @code{is_numeric_type}, etc. (See
+class like @code{is_real_matrix}, @code{is_numeric_type}, etc. (see
 @file{ov.h}).  Often, with a knowledge of the Octave m-file language, you can
 guess at what the corresponding C++ routine will.  In addition there are some
 more specialized input validation functions of which a few are demonstrated
 below.
 
 @example
 @EXAMPLEFILE(paramdemo.cc)
 @end example
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -665,17 +665,17 @@ endfunction
 @end group
 @end example
 
 Note that this function could not have been written using the
 @code{break} statement to exit the loop once a nonzero value is found
 without adding extra logic to avoid printing the message if the vector
 does contain a nonzero element.
 
-@deftypefn {Keyword} {} return
+@deftypefn {} {} return
 When Octave encounters the keyword @code{return} inside a function or
 script, it returns control to the caller immediately.  At the top level,
 the return statement is ignored.  A @code{return} statement is assumed
 at the end of every function definition.
 @end deftypefn
 
 @node Default Arguments
 @section Default Arguments
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -714,17 +714,17 @@ which special control sequences in the t
 
 The interpreter property can take three values: @qcode{"none"}, @qcode{"tex"},
 @qcode{"latex"}.  If the interpreter is set to @qcode{"none"} then no special
 rendering occurs---the displayed text is a verbatim copy of the specified text.
 Currently, the @qcode{"latex"} interpreter is not implemented for on-screen
 display and is equivalent to @qcode{"none"}.  Note that Octave does not parse
 or validate the text strings when in @qcode{"latex"} mode---it is the
 responsibility of the programmer to generate valid strings which may include
-wrapping sections that should appear in Math mode with '$' characters.
+wrapping sections that should appear in Math mode with @qcode{'$'} characters.
 
 The @qcode{"tex"} option implements a subset of @TeX{} functionality when
 rendering text.  This allows the insertion of special glyphs such as Greek
 characters or mathematical symbols.  Special characters are inserted by using
 a backslash (\) character followed by a code, as shown in @ref{tab:extended}.
 
 Besides special glyphs, the formatting of the text can be changed within the
 string by using the codes
@@ -1888,18 +1888,18 @@ string is evaluated.
 This can then be associated with an object either at the object's creation, or
 later with the @code{set} function.  For example,
 
 @example
 plot (x, "DeleteFcn", @@(h, e) disp ("Window Deleted"))
 @end example
 
 @noindent
-where at the moment that the plot is deleted, the message "Window Deleted" will
-be displayed.
+where at the moment that the plot is deleted, the message
+@qcode{"Window Deleted"} will be displayed.
 
 Additional user arguments can be passed to callback functions, and will be
 passed after the two default arguments.  For example:
 
 @example
 @group
 plot (x, "DeleteFcn", @{@@mycallback, "1"@})
 @dots{}
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -337,17 +337,17 @@ OCTAVE_HOME corresponds to the configura
 %!error OCTAVE_HOME (1)
 */
 
 DEFUN (OCTAVE_EXEC_HOME, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} OCTAVE_HOME ()
 Return the name of the top-level Octave installation directory for
 architecture-dependendent files.  If not specified separately, the value
-is the same as OCTAVE_HOME.  OCTAVE_EXEC_HOME corresponds to the
+is the same as OCTAVE_HOME@.  OCTAVE_EXEC_HOME corresponds to the
 configuration variable @var{exec_prefix}.
 @seealso{EXEC_PATH, IMAGE_PATH, OCTAVE_HOME}
 @end deftypefn */)
 {
   if (args.length () != 0)
     print_usage ();
 
   return ovl (octave::config::octave_exec_home ());
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -649,17 +649,17 @@ It is @samp{/} (forward slash) under UNI
       retval = octave::sys::file_ops::dir_sep_chars ();
     }
 
   return retval;
 }
 
 DEFUN (pathsep, args, ,
        doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} pathsep ()
+@deftypefn {} {@var{val} =} pathsep ()
 Query the character used to separate directories in a path.
 @seealso{filesep}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin > 0)
     print_usage ();
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1503,17 +1503,17 @@ is 0, otherwise return the output in a c
 @table @code
 @item -append
 Append to the destination instead of overwriting.
 
 @item -ascii
 Save a matrix in a text file without a header or any other information.  The
 matrix must be 2-D and only the real part of any complex value is written to
 the file.  Numbers are stored in single-precision format and separated by
-spaces.  Additional options for the @code{-ascii} format are
+spaces.  Additional options for the @option{-ascii} format are
 
 @table @code
 @item -double
 Store numbers in double-precision format.
 
 @item -tabs
 Separate numbers with tabs.
 @end table
diff --git a/libinterp/corefcn/pr-flt-fmt.cc b/libinterp/corefcn/pr-flt-fmt.cc
--- a/libinterp/corefcn/pr-flt-fmt.cc
+++ b/libinterp/corefcn/pr-flt-fmt.cc
@@ -42,17 +42,17 @@ output_precision (void)
 void
 set_output_prec (int prec)
 {
   Voutput_precision = prec;
 }
 
 DEFUN (output_max_field_width, , ,
        doc: /* -*- texinfo -*-
-@deftypefn  {} {} output_max_field_width
+@deftypefn {} {} output_max_field_width
 This function is obsolete and will be removed from a future version
 of Octave.
 @end deftypefn */)
 {
   return octave_value (20);
 }
 
 DEFUN (output_precision, args, nargout,
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1547,17 +1547,17 @@ other methods such as @code{quadgk}.
 The algorithm uses @nospell{Clenshaw-Curtis} quadrature rules of increasing
 degree in each interval and bisects the interval if either the function does
 not appear to be smooth or a rule of maximum degree has been reached.  The
 error estimate is computed from the L2-norm of the difference between two
 successive interpolations of the integrand over the nodes of the respective
 quadrature rules.
 
 @c FIXME: Remove in Octave version 4.8
-Implementation Note: For Octave versions <= 4.2, @code{quadcc} accepted a
+Implementation Note: For Octave versions @leq{} 4.2, @code{quadcc} accepted a
 single tolerance argument which specified the relative tolerance.  For
 versions 4.4 and 4.6, @code{quadcc} will issue a warning when called with a
 single tolerance argument indicating that the meaning of this input has
 changed from relative tolerance to absolute tolerance.  The warning ID for this
 message is @qcode{"Octave:quadcc:RelTol-conversion"}.  The warning may be
 disabled with @code{warning ("off", "Octave:quadcc:RelTol-conversion")}.
 
 Reference: @nospell{P. Gonnet}, @cite{Increasing the Reliability of Adaptive
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -856,24 +856,26 @@ Zero-length matches are not returned.  (
 
 @item emptymatch
 Return zero-length matches.
 
 @code{regexp ('a', 'b*', 'emptymatch')} returns @code{[1 2]} because there
 are zero or more @qcode{'b'} characters at positions 1 and end-of-string.
 
 @end table
+
 Stack Limitation Note: Pattern searches are done with a recursive function
 which can overflow the program stack when there are a high number of matches.
 For example,
 
 @example
 @code{regexp (repmat ('a', 1, 1e5), '(a)+')}
 @end example
 
+@noindent
 may lead to a segfault.  As an alternative, consider constructing pattern
 searches that reduce the number of matches (e.g., by creatively using set
 complement), and then further processing the return variables (now reduced in
 size) with successive @code{regexp} searches.
 @seealso{regexpi, strfind, regexprep}
 @end deftypefn */)
 {
   if (args.length () < 2)
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -221,22 +221,23 @@ In this case, the defining relationship 
 
 @example
 @var{Q} * @var{R} = @var{A}(:, @var{P})
 @end example
 
 The default, however, is to return a permutation matrix and this may be
 explicitly specified by using a final argument of @qcode{"matrix"}.
 
-If the final argument is the scalar 0 an "economy" factorization is returned.
-When the original matrix @var{A} has size MxN and M > N then the "economy"
-factorization will calculate just N rows in @var{R} and N columns in @var{Q}
-and omit the zeros in @var{R}.  If M @leq{} N there is no difference between
-the economy and standard factorizations.  When calculating an "economy"
-factorization the output @var{P} is always a vector rather than a matrix.
+If the final argument is the scalar 0 an @qcode{"economy"} factorization is
+returned.  When the original matrix @var{A} has size MxN and M > N then the
+@qcode{"economy"} factorization will calculate just N rows in @var{R} and N
+columns in @var{Q} and omit the zeros in @var{R}.  If M @leq{} N there is no
+difference between the economy and standard factorizations.  When calculating
+an @qcode{"economy"} factorization the output @var{P} is always a vector
+rather than a matrix.
 
 Background: The QR factorization has applications in the solution of least
 squares problems
 @tex
 $$
 \min_x \left\Vert A x - b \right\Vert_2
 $$
 @end tex
diff --git a/scripts/general/repelem.m b/scripts/general/repelem.m
--- a/scripts/general/repelem.m
+++ b/scripts/general/repelem.m
@@ -135,17 +135,17 @@
 ##       ans(:,:,2) =
 ##         -1  -1  -1   0   0   0
 ##         -1  -1  -1   0   0   0
 ##          0   0   0   1   1   1
 ##          0   0   0   1   1   1
 ## @end example
 ##
 ## @code{repelem} preserves the class of @var{x}, and works with strings,
-## cell arrays, NA, and NAN inputs.  If any @var{R_j} is  0 the output will
+## cell arrays, NA, and NAN inputs.  If any @var{R_j} is 0 the output will
 ## be an empty array.
 ##
 ## @example
 ## @group
 ## repelem ("Octave", 2, 3)
 ##   @result{}    OOOccctttaaavvveee
 ##         OOOccctttaaavvveee
 ##
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} isdefinite (@var{A})
 ## @deftypefnx {} {} isdefinite (@var{A}, @var{tol})
 ## Return 1 if @var{A} is symmetric positive definite within the
 ## tolerance specified by @var{tol} or 0 if @var{A} is symmetric
-## positive semidefinite.  Otherwise, return -1.
+## positive semi-definite.  Otherwise, return -1.
 ##
 ## If @var{tol} is omitted, use a tolerance of
 ## @code{100 * eps * norm (@var{A}, "fro")}
 ## @seealso{issymmetric, ishermitian}
 ## @end deftypefn
 
 ## Author: Gabriele Pannocchia <g.pannocchia@ing.unipi.it>
 ## Created: November 2003
diff --git a/scripts/linear-algebra/ols.m b/scripts/linear-algebra/ols.m
--- a/scripts/linear-algebra/ols.m
+++ b/scripts/linear-algebra/ols.m
@@ -66,18 +66,19 @@
 ## @table @var
 ## @item beta
 ## The OLS estimator for matrix @var{b}.
 ## @tex
 ## @var{beta} is calculated directly via $(@var{x}^T@var{x})^{-1} @var{x}^T
 ## @var{y}$ if the matrix $@var{x}^T@var{x}$ is of full rank.
 ## @end tex
 ## @ifnottex
-## @var{beta} is calculated directly via @code{inv (@var{x}'*@var{x}) * @var{x}' * @var{y}} if the
-## matrix @code{@var{x}'*@var{x}} is of full rank.
+## @var{beta} is calculated directly via
+## @code{inv (@var{x}'*@var{x}) * @var{x}' * @var{y}} if the matrix
+## @code{@var{x}'*@var{x}} is of full rank.
 ## @end ifnottex
 ## Otherwise, @code{@var{beta} = pinv (@var{x}) * @var{y}} where
 ## @code{pinv (@var{x})} denotes the pseudoinverse of @var{x}.
 ##
 ## @item sigma
 ## The OLS estimator for the matrix @var{s},
 ##
 ## @example
diff --git a/scripts/miscellaneous/genvarname.m b/scripts/miscellaneous/genvarname.m
--- a/scripts/miscellaneous/genvarname.m
+++ b/scripts/miscellaneous/genvarname.m
@@ -44,17 +44,17 @@
 ## x = 3.141;
 ## genvarname ("x", who ())
 ##   @result{} x1
 ## @end group
 ## @end example
 ##
 ## Note that the result is a char array or cell array of strings, not the
 ## variables themselves.  To define a variable, @code{eval()} can be used.
-## The following trivial example sets @code{x} to @code{42}.
+## The following trivial example sets @code{x} to 42.
 ##
 ## @example
 ## @group
 ## name = genvarname ("x");
 ## eval ([name " = 42"]);
 ##   @result{} x =  42
 ## @end group
 ## @end example
diff --git a/scripts/miscellaneous/inputParser.m b/scripts/miscellaneous/inputParser.m
--- a/scripts/miscellaneous/inputParser.m
+++ b/scripts/miscellaneous/inputParser.m
@@ -76,17 +76,16 @@
 ## @end deftypefn
 ## @deftypefn {} {} inputParser.StructExpand = @var{boolean}
 ## Set whether a structure can be passed to the function instead of
 ## parameter/value pairs.  Defaults to true.
 ##
 ## The following example shows how to use this class:
 ##
 ## @example
-## @group
 ## function check (varargin)
 ## @c The next two comments need to be indented by one for alignment
 ##   p = inputParser ();                      # create object
 ##   p.FunctionName = "check";                # set function name
 ##   p.addRequired ("pack", @@ischar);         # mandatory argument
 ##   p.addOptional ("path", pwd(), @@ischar);  # optional argument
 ##
 ##   ## create a function handle to anonymous functions for validators
@@ -102,17 +101,16 @@
 ##   ## create a switch type of argument
 ##   p.addSwitch ("verbose");
 ##
 ##   p.parse (varargin@{:@});  # Run created parser on inputs
 ##
 ##   ## the rest of the function can access inputs by using p.Results.
 ##   ## for example, get the tolerance input with p.Results.tolerance
 ## endfunction
-## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## check ("mech");           # valid, use defaults for other arguments
 ## check ();                 # error, one argument is mandatory
 ## check (1);                # error, since ! ischar
 ## check ("mech", "~/dev");  # valid, use defaults for other arguments
diff --git a/scripts/plot/appearance/camorbit.m b/scripts/plot/appearance/camorbit.m
--- a/scripts/plot/appearance/camorbit.m
+++ b/scripts/plot/appearance/camorbit.m
@@ -27,65 +27,69 @@
 ## @deftypefnx {} {} camorbit (@var{theta}, @var{phi}, "data", [@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {} camorbit (@var{theta}, @var{phi}, "camera")
 ## @deftypefnx {} {} camorbit (@var{hax}, @dots{})
 ## Rotate the camera up/down and left/right around its target.
 ##
 ## Move the camera @var{phi} degrees up and @var{theta} degrees to the right,
 ## as if it were in an orbit around its target.
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## sphere ()
 ## camorbit (30, 20)
 ## @end group
 ## @end example
 ##
 ## These rotations are centered around the camera target
 ## (@pxref{XREFcamtarget,,camtarget}).
 ## First the camera position is pitched up or down by rotating it @var{phi}
-## degrees around an axis orthogonal to both the viewing direction (specifically
-## @code{camtarget() - campos()}) and the camera ``up vector''
+## degrees around an axis orthogonal to both the viewing direction
+## (specifically @code{camtarget() - campos()}) and the camera ``up vector''
 ## (@pxref{XREFcamup,,camup}).
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camorbit (0, 20)
 ## @end group
 ## @end example
 ##
 ## The second rotation depends on the coordinate system @var{coorsys} and
 ## direction @var{dir} inputs.
-## The default for @var{coorsys} is @qcode{"data"}.  In this case, the camera is
-## yawed left or right by rotating it @var{theta} degrees around an axis
+## The default for @var{coorsys} is @qcode{"data"}.  In this case, the camera
+## is yawed left or right by rotating it @var{theta} degrees around an axis
 ## specified by @var{dir}.
 ## The default for @var{dir} is @qcode{"z"}, corresponding to the vector
 ## @code{[0, 0, 1]}.
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camorbit (30, 0)
 ## @end group
 ## @end example
 ##
-##
 ## When @var{coorsys} is set to @qcode{"camera"}, the camera is moved left or
 ## right by rotating it around an axis parallel to the camera up vector
 ## (@pxref{XREFcamup,,camup}).
 ## The input @var{dir} should not be specified in this case.
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camorbit (30, 0, "camera")
 ## @end group
 ## @end example
+##
 ## (Note: the rotation by @var{phi} is unaffected by @qcode{"camera"}.)
 ##
 ## The @code{camorbit} command modifies two camera properties:
 ## @pxref{XREFcampos,,campos} and @pxref{XREFcamup,,camup}.
 ##
 ## By default, this command affects the current axis; alternatively, an axis
 ## can be specified by the optional argument @var{hax}.
 ##
diff --git a/scripts/plot/appearance/campos.m b/scripts/plot/appearance/campos.m
--- a/scripts/plot/appearance/campos.m
+++ b/scripts/plot/appearance/campos.m
@@ -21,45 +21,49 @@
 ## @deftypefnx {} {} campos ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {@var{mode} =} campos ("mode")
 ## @deftypefnx {} {} campos (@var{mode})
 ## @deftypefnx {} {} campos (@var{ax}, @dots{})
 ## Set or get the camera position.
 ##
 ## The default camera position is determined automatically based on the scene.
 ## For example, to get the camera position:
+##
 ## @example
 ## @group
 ## hf = figure();
 ## peaks()
 ## p = campos ()
 ##   @result{} p =
 ##       -27.394  -35.701   64.079
 ## @end group
 ## @end example
 ##
 ## We can then move the camera further up the z-axis:
+##
 ## @example
 ## @group
 ## campos (p + [0 0 10])
 ## campos ()
 ##   @result{} ans =
 ##       -27.394  -35.701   74.079
 ## @end group
 ## @end example
 ##
 ## Having made that change, the camera position @var{mode} is now manual:
+##
 ## @example
 ## @group
 ## campos ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
 ##
 ## We can set it back to automatic:
+##
 ## @example
 ## @group
 ## campos ("auto")
 ## campos ()
 ##   @result{} ans =
 ##       -27.394  -35.701   64.079
 ## close (hf)
 ## @end group
diff --git a/scripts/plot/appearance/camroll.m b/scripts/plot/appearance/camroll.m
--- a/scripts/plot/appearance/camroll.m
+++ b/scripts/plot/appearance/camroll.m
@@ -20,33 +20,36 @@
 ## @deftypefn  {} {} camroll (@var{theta})
 ## @deftypefnx {} {} camroll (@var{ax}, @var{theta})
 ## Roll the camera.
 ##
 ## Roll the camera clockwise by @var{theta} degrees.
 ## For example, the following command will roll the camera by
 ## 30 degrees clockwise (to the right); this will cause the scene
 ## to appear to roll by 30 degrees to the left:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## peaks ()
 ## camroll (30)
 ## @end group
 ## @end example
 ##
 ## Roll the camera back:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camroll (-30)
 ## @end group
 ## @end example
 ##
 ## The following command restores the default camera roll:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camup ("auto")
 ## @end group
 ## @end example
 ##
 ## By default, these commands affect the current axis; alternatively, an axis
diff --git a/scripts/plot/appearance/camtarget.m b/scripts/plot/appearance/camtarget.m
--- a/scripts/plot/appearance/camtarget.m
+++ b/scripts/plot/appearance/camtarget.m
@@ -19,56 +19,62 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{T} =} camtarget ()
 ## @deftypefnx {} {} camtarget ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {@var{mode} =} camtarget ("mode")
 ## @deftypefnx {} {} camtarget (@var{mode})
 ## @deftypefnx {} {} camtarget (@var{ax}, @dots{})
 ## Set or get where the camera is pointed.
 ##
-## The camera target is a point in space where the camera is pointing.  Usually,
-## it is determined automatically based on the scene:
+## The camera target is a point in space where the camera is pointing.
+## Usually, it is determined automatically based on the scene:
+##
 ## @example
 ## @group
 ## hf = figure();
 ## sphere (36)
 ## v = camtarget ()
 ##   @result{} v =
 ##       0   0   0
 ## @end group
 ## @end example
 ##
 ## We can turn the camera to point at a new target:
+##
 ## @example
 ## @group
 ## camtarget ([1 1 1])
 ## camtarget ()
 ##   @result{}   1   1   1
 ## @end group
 ## @end example
 ##
 ## Having done so, the camera target @var{mode} is manual:
+##
 ## @example
 ## @group
 ## camtarget ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
+##
 ## This means, for example, adding new objects to the scene will not retarget
 ## the camera:
+##
 ## @example
 ## @group
 ## hold on;
 ## peaks ()
 ## camtarget ()
 ##   @result{}   1   1   1
 ## @end group
 ## @end example
 ##
 ## We can reset it to be automatic:
+##
 ## @example
 ## @group
 ## @c doctest: +XFAIL
 ## @c https://savannah.gnu.org/bugs/?44503
 ## camtarget ("auto")
 ## camtarget ()
 ##   @result{}   0   0   0.76426
 ## close (hf)
diff --git a/scripts/plot/appearance/camup.m b/scripts/plot/appearance/camup.m
--- a/scripts/plot/appearance/camup.m
+++ b/scripts/plot/appearance/camup.m
@@ -19,53 +19,60 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{up} =} camup ()
 ## @deftypefnx {} {} camup ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {@var{mode} =} camup ("mode")
 ## @deftypefnx {} {} camup (@var{mode})
 ## @deftypefnx {} {} camup (@var{ax}, @dots{})
 ## Set or get the camera up vector.
 ##
-## By default, the camera is oriented so that ``up'' corresponds to the positive
-## z-axis:
+## By default, the camera is oriented so that ``up'' corresponds to the
+## positive z-axis:
+##
 ## @example
 ## @group
 ## hf = figure ();
 ## sphere (36)
 ## v = camup ()
 ##   @result{} v =
 ##       0   0   1
 ## @end group
 ## @end example
 ##
 ## Specifying a new ``up vector'' rolls the camera and sets the mode to manual:
+##
 ## @example
 ## @group
 ## camup ([1 1 0])
 ## camup ()
 ##   @result{}   1   1   0
 ## camup ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
 ##
 ## Modifying the up vector does not modify the camera target
-## (@pxref{XREFcamtarget,,camtarget}). Thus, the camera up vector might not be
+## (@pxref{XREFcamtarget,,camtarget}).  Thus, the camera up vector might not be
 ## orthogonal to the direction of the camera's view:
+##
 ## @example
+## @group
 ## camup ([1 2 3])
 ## dot (camup (), camtarget () - campos ())
 ##   @result{} 6...
+## @end group
 ## @end example
+##
 ## A consequence is that ``pulling back'' on the up vector does not pitch the
 ## camera view (as that would require changing the target).  Setting the up
 ## vector is thus typically used only to roll the camera.  A more intuitive
 ## command for this purpose is @pxref{XREFcamroll,,camroll}.
 ##
 ## Finally, we can reset the up vector to automatic mode:
+##
 ## @example
 ## @group
 ## camup ("auto")
 ## camup ()
 ##   @result{}   0   0   1
 ## close (hf)
 ## @end group
 ## @end example
diff --git a/scripts/plot/appearance/camva.m b/scripts/plot/appearance/camva.m
--- a/scripts/plot/appearance/camva.m
+++ b/scripts/plot/appearance/camva.m
@@ -21,36 +21,39 @@
 ## @deftypefnx {} {} camva (@var{a})
 ## @deftypefnx {} {@var{mode} =} camva ("mode")
 ## @deftypefnx {} {} camva (@var{mode})
 ## @deftypefnx {} {} camva (@var{ax}, @dots{})
 ## Set or get the camera viewing angle.
 ##
 ## The camera has a viewing angle which determines how much can be seen.  By
 ## default this is:
+##
 ## @example
 ## @group
 ## hf = figure();
 ## sphere (36)
 ## a = camva ()
 ##   @result{} a =  10.340
 ## @end group
 ## @end example
 ##
-## To get a wider-angle view, we could double the viewing angle.  This will also
-## set the mode to manual:
+## To get a wider-angle view, we could double the viewing angle.  This will
+## also set the mode to manual:
+##
 ## @example
 ## @group
 ## camva (2*a)
 ## camva ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
 ##
 ## We can set it back to automatic:
+##
 ## @example
 ## @group
 ## camva ("auto")
 ## camva ("mode")
 ##   @result{} auto
 ## camva ()
 ##   @result{} ans =  10.340
 ## close (hf)
diff --git a/scripts/plot/appearance/camzoom.m b/scripts/plot/appearance/camzoom.m
--- a/scripts/plot/appearance/camzoom.m
+++ b/scripts/plot/appearance/camzoom.m
@@ -18,33 +18,37 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} camzoom (@var{zf})
 ## @deftypefnx {} {} camzoom (@var{ax}, @var{zf})
 ## Zoom the camera in or out.
 ##
 ## A value of @var{zf} larger than 1 ``zooms in'' such that the scene appears
 ## magnified:
+##
 ## @example
 ## @group
 ## hf = figure ();
 ## sphere (36)
 ## camzoom (1.2)
 ## @end group
 ## @end example
 ##
-## A value smaller than 1 ``zooms out'' so the camera can see more of the scene:
+## A value smaller than 1 ``zooms out'' so the camera can see more of the
+## scene:
+##
 ## @example
 ## @group
 ## camzoom (0.5)
 ## @end group
 ## @end example
 ##
 ## Technically speaking, zooming affects the ``viewing angle''.  The following
 ## command resets to the default zoom:
+##
 ## @example
 ## @group
 ## camva ("auto")
 ## close (hf)
 ## @end group
 ## @end example
 ##
 ## By default, these commands affect the current axis; alternatively, an axis
diff --git a/scripts/plot/draw/camlight.m b/scripts/plot/draw/camlight.m
--- a/scripts/plot/draw/camlight.m
+++ b/scripts/plot/draw/camlight.m
@@ -65,19 +65,19 @@
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camlight (45, 30);
 ## @end group
 ## @end example
 ##
 ## Here the light is first pitched upwards (@pxref{XREFcamup,,camup}) from the
-## camera position (@pxref{XREFcampos,,campos}) by 30 degrees.  It is then yawed
-## by 45 degrees to the right.  Both rotations are centered around the camera
-## target (@pxref{XREFcamtarget,,camtarget}).
+## camera position (@pxref{XREFcampos,,campos}) by 30 degrees.  It is then
+## yawed by 45 degrees to the right.  Both rotations are centered around the
+## camera target (@pxref{XREFcamtarget,,camtarget}).
 ##
 ## Return a handle to further manipulate the light object
 ##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## clf
 ## sphere (36);
diff --git a/scripts/plot/util/findobj.m b/scripts/plot/util/findobj.m
--- a/scripts/plot/util/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -55,19 +55,19 @@
 ## @end example
 ##
 ## Specifying a depth @var{d} of 0 limits the search to the set of objects
 ## passed in @var{hlist}.  A depth of 0 is also equivalent to the
 ## @qcode{"flat"} argument.  The default depth value is @code{Inf} which
 ## includes all descendants.
 ##
 ## A specified logical operator may be used between @var{prop_name},
-## @var{prop_value} pairs.  The supported logical operators are: @qcode{"-and"},
-## @qcode{"-or"}, @qcode{"-xor"}, @qcode{"-not"}.  Example code to locate all
-## figure and axes objects is
+## @var{prop_value} pairs.  The supported logical operators are:
+## @qcode{"-and"}, @qcode{"-or"}, @qcode{"-xor"}, @qcode{"-not"}.  Example code
+## to locate all figure and axes objects is
 ##
 ## @example
 ## findobj ("type", "figure", "-or", "type", "axes")
 ## @end example
 ##
 ## Objects may also be matched by comparing a regular expression to the
 ## property values, where property values that match
 ## @code{regexp (@var{prop_value}, @var{pattern})} are returned.
diff --git a/scripts/plot/util/hgsave.m b/scripts/plot/util/hgsave.m
--- a/scripts/plot/util/hgsave.m
+++ b/scripts/plot/util/hgsave.m
@@ -30,19 +30,19 @@
 ##
 ## If present, @var{fmt} should be one of the following:
 ##
 ## @itemize @bullet
 ## @item @option{-binary}, @option{-float-binary}
 ##
 ## @item @option{-hdf5}, @option{-float-hdf5}
 ##
-## @item @option{-V7}, @option{-v7}, @code{-7}, @option{-mat7-binary}
+## @item @option{-V7}, @option{-v7}, @option{-7}, @option{-mat7-binary}
 ##
-## @item @option{-V6}, @option{-v6}, @code{-6}, @option{-mat6-binary}
+## @item @option{-V6}, @option{-v6}, @option{-6}, @option{-mat6-binary}
 ##
 ## @item @option{-text}
 ##
 ## @item @option{-zip}, @option{-z}
 ## @end itemize
 ##
 ## When producing graphics for final publication use @code{print} or
 ## @code{saveas}.  When it is important to be able to continue to edit a
diff --git a/scripts/plot/util/ishandle.m b/scripts/plot/util/ishandle.m
--- a/scripts/plot/util/ishandle.m
+++ b/scripts/plot/util/ishandle.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {} ishandle (@var{h})
+## @deftypefn {} {} ishandle (@var{h})
 ## Return true if @var{h} is a handle to a graphics or Java object and false
 ## otherwise.
 ##
 ## @var{h} may also be a matrix of handles in which case a logical array is
 ## returned that is true where the elements of @var{h} are handles to graphics
 ## or Java objects and false where they are not.
 ##
 ## Programming Note: It is often more useful to test for a specific object
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -33,17 +33,18 @@
 ## The result is a vector with length equal to
 ## @code{length (@var{a}) + length (@var{b}) - 1}.
 ##
 ## @item @var{shape} = @qcode{"same"}
 ## Return the central part of the convolution with the same size as @var{a}.
 ##
 ## @item @var{shape} = @qcode{"valid"}
 ## Return only the parts which do not include zero-padded edges.
-## The size of the result is @code{max (size (@var{a}) - size (@var{b}) + 1, 0)}.
+## The size of the result is
+## @code{max (size (@var{a}) - size (@var{b}) + 1, 0)}.
 ## @end table
 ##
 ## @seealso{deconv, conv2, convn, fftconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -23,36 +23,36 @@
 ## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
 ## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the Bi-conjugate gradient iterative method.
 ##
 ## The input parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{A} it is a square matrix. @var{A} can be passed as a matrix or
+## @item @var{A} it is a square matrix.  @var{A} can be passed as a matrix or
 ## as a function handle or inline function
 ## @code{Afun} such that @code{Afun (x, "notransp") = A * x} and
 ## @code{Afun (x, "transp") = A' * x}.  Additional parameters to
 ## @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with same number of rows of @var{A}.
 ##
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
 ## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
 ## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
 ## @w{@code{@var{tol} * norm (@var{b})}}}.
 ## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
 ## set to [] the default value @code{min (20, numel (b))} is used.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The
+## @item @var{M1}, @var{M2} are the preconditioners.  The
 ## preconditioner @var{M} is given as @code{@var{M} = @var{M1} * @var{M2}}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a
 ## function handle or inline
 ## function @code{g} such that @code{g(@var{x}, "notransp") =
 ## @var{M1} \ @var{x}} or
 ## @code{g(@var{x}, "notransp") = @var{M2} \ @var{x}}
 ## and @code{g(@var{x}, "transp") = @var{M1}' \ @var{x}} or
 ## @code{g(@var{x}, "transp") = @var{M2}' \ @var{x}}.
@@ -72,17 +72,17 @@
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M}) which are passed
 ## to @code{bicg}.
 ##
 ## The output parameters are:
 ##
 ## @itemize
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -26,56 +26,56 @@
 ## method.
 ##
 ## The input parameters are:
 ##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with the same number of rows as @var{A}.
 ##
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
 ## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
 ## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
 ## @w{@code{@var{tol} * norm (@var{b})}}}.
 ## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
 ## set to [] the default value @code{min (20, numel (b))} is used.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
 ## @var{M} is given as @code{@var{M} = @var{M1} * @var{M2}}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that
 ## @code{g(@var{x}) = @var{M1} \ @var{x}} or
 ## @code {g(@var{x}) = @var{M2} \ @var{x}}.
-## The techinque used is the right preconditioning, i.e. it is
+## The techinque used is the right preconditioning, i.e., it is
 ## solved @code{@var{A} * inv (@var{M}) * @var{y} = @var{b}} and then
 ## @code{@var{x} = inv (@var{M}) * @var{y}}.
 ##
 ## @item @var{x0} the initial guess, if not given or set to [] the default
 ## value @code{zeros (size (@var{b}))} is used.
 ##
 ## @end itemize
 ##
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M}) which are passed
 ## to @code{bicstab}.
 ##
 ## The output parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
@@ -86,17 +86,17 @@
 ##
 ## @item 4: the algorithm can't continue due to a division by zero
 ## @end itemize
 ##
 ## @item @var{relres} is the relative residual obtained with as
 ## @code{(@var{A}*@var{x}-@var{b}) / @code{norm(@var{b})}}.
 ##
 ## @item @var{iter} is the (possibily half) iteration which @var{x} is
-## computed. If it is an half iteration then it is @code{@var{iter} + 0.5}
+## computed.  If it is an half iteration then it is @code{@var{iter} + 0.5}
 ##
 ## @item @var{resvec} is a vector containing the residual of each half and
 ## total iteration (There are also the half iterations since @var{x} is
 ## computed in two steps at each iteration).
 ## Doing @code{(length(@var{resvec}) - 1) / 2} is possible to see the
 ## total number of (total) iterations performed.
 ##
 ## @end itemize
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -26,49 +26,49 @@
 ## Conjugate Gradients Squared method.
 ##
 ## The input arguments are:
 ##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with same number of rows of @var{A}.
 ##
 ## @item @var{tol} is the relative tolerance, if not given or set to [] the
 ## default value 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
 ## set to [] the default value @code{min (20, numel (b))} is used.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
 ## matrix is given as @code{M = M1 * M2}.  Both @var{M1}
 ## and @var{M2} can be passed as a matrix or as a function handle or inline
 ## function @code{g} such that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.
 ## If M1 is empty or not passed then no preconditioners are applied.
-## The techinque used is the right preconditioning, i.e. it is solved
+## The techinque used is the right preconditioning, i.e., it is solved
 ## @code{@var{A}*inv(@var{M})*y = b} and then @code{@var{x} = inv(@var{M})*y}.
 ##
 ## @item @var{x0} the initial guess, if not given or set to [] the default
 ## value @code{zeros (size (b))} is used.
 ## @end itemize
 ##
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{P}) which are passed
 ## to @code{cgs}.
 ##
 ## The output parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -20,50 +20,51 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
 ## @deftypefnx {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
 ## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} gmres (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the Preconditioned GMRES iterative method with
 ## restart, a.k.a. PGMRES(restart).
 ##
 ## The input arguments are:
+##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with the same numbers of rows as @var{A}.
 ##
 ## @item @var{restart} is the number of iterations before that the
-## method restarts. If it is [] or N = numel (b), then the restart
+## method restarts.  If it is [] or N = numel (b), then the restart
 ## is not applied.
 ##
 ## @item @var{tol} is the required relative tolerance for the
 ## preconditioned residual error,
-## @code{inv (@var{M}) * (@var{b} - @var{a} * @var{x})}. The iteration stops if
-## @code{norm (inv (@var{M}) * (@var{b} - @var{a} * @var{x})) <=
-## @var{tol} * norm (inv (@var{M}) * @var{B})}.  If @var{tol} is omitted or
-## empty, then a tolerance of 1e-6 is used.
+## @code{inv (@var{M}) * (@var{b} - @var{a} * @var{x})}.  The iteration
+## stops if @code{norm (inv (@var{M}) * (@var{b} - @var{a} * @var{x}))
+## @leq{} @var{tol} * norm (inv (@var{M}) * @var{B})}.  If @var{tol} is
+## omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item @var{maxit} is the maximum number of outer iterations, if not given or
 ## set to [], then the default value @code{min (10, @var{N} / @var{restart})}
 ## is used.
 ## Note that, if @var{restart} is empty, then @var{maxit} is the maximum number
-## of iterations. If @var{restart} and @var{maxit} are not empty, then
+## of iterations.  If @var{restart} and @var{maxit} are not empty, then
 ## the maximum number of iterations is @code{@var{restart} * @var{maxit}}.
 ## If both @var{restart} and @var{maxit} are empty, then the maximum
 ## number of iterations is set to @code{min (10, @var{N})}.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
-## @var{M} is given as @code{M = M1 * M2}. Both @var{M1} and @var{M2} can
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
+## @var{M} is given as @code{M = M1 * M2}.  Both @var{M1} and @var{M2} can
 ## be passed as a matrix, function handle, or inline function @code{g} such
-## that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}. If @var{M1} is [] or not
+## that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.  If @var{M1} is [] or not
 ## given, then the preconditioner is not applied.
 ## The technique used is the left-preconditioning, i.e., it is solved
 ## @code{inv(@var{M}) * @var{A} * @var{x} = inv(@var{M}) * @var{b}} instead of
 ## @code{@var{A} * @var{x} = @var{b}}.
 ##
 ## @item @var{x0} is the initial guess,
 ## if not given or set to [], then the default value
 ## @code{zeros (size (@var{b}))} is used.
@@ -73,17 +74,17 @@
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M} or
 ## @var{M1} or @var{M2}) which are passed to @code{gmres}.
 ##
 ## The outputs are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} the computed approximation. If the method does not
+## @item @var{x} the computed approximation.  If the method does not
 ## converge, then it is the iterated with minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @table @asis
 ## @item 0 : iteration converged to within the specified tolerance
 ##
 ## @item 1 : maximum number of iterations exceeded
@@ -93,27 +94,27 @@
 ## @item 3 : algorithm reached stagnation (the relative difference between two
 ## consecutive iterations is less than eps)
 ## @end table
 ##
 ## @item @var{relres} is the value of the relative preconditioned
 ## residual of the approximation @var{x}.
 ##
 ## @item @var{iter} is a vector containing the number of outer iterations and
-## inner iterations performed to compute @var{x}. That is:
+## inner iterations performed to compute @var{x}.  That is:
 ##
 ## @itemize
-## @item @var{iter(1)}: number of outer iterations, i.e. how many
-## times the method restarted. (if @var{restart} is empty or @var{N},
-## then it is 1, if not 1 <= @var{iter(1)} <= @var{maxit}).
+## @item @var{iter(1)}: number of outer iterations, i.e., how many
+## times the method restarted.  (if @var{restart} is empty or @var{N},
+## then it is 1, if not 1 @leq{} @var{iter(1)} @leq{} @var{maxit}).
 ##
 ## @item @var{iter(2)}: the number of iterations performed before the
-## restart,  i.e., the method restarts when
-## @code{@var{iter(2)} = @var{restart}}. If @var{restart} is empty or
-## @var{N}, then 1 <= @var{iter(2)} <= @var{maxit}.
+## restart, i.e., the method restarts when
+## @code{@var{iter(2)} = @var{restart}}.  If @var{restart} is empty or
+## @var{N}, then 1 @leq{} @var{iter(2)} @leq{} @var{maxit}.
 ## @end itemize
 ##
 ## To be more clear, the approximation @var{x} is computed at the iteration
 ## @code{(@var{iter(1)} - 1) * @var{restart} + @var{iter(2)}}.
 ## Since the output @var{x} corresponds to the minimal preconditioned
 ## residual solution, the total number of iterations that
 ## the method performed is given by @code{length (resvec) - 1}.
 ##
@@ -157,16 +158,17 @@
 ## @sc{Example 3:} usage of @code{gmres} with the restart
 ##
 ## @example
 ## x = gmres (A, b, restart);
 ## @end example
 ##
 ## @sc{Example 4:} @code{gmres} with a preconditioner matrix @var{M}
 ## with and without restart
+##
 ## @example
 ## @group
 ## x = gmres (A, b, [], 1e-06, n, M)
 ## x = gmres (A, b, restart, 1e-06, n, M)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 5:} @code{gmres} with a function as preconditioner
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
+## @deftypefn  {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
 ## @deftypefnx {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
 ## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@var{A}, @var{b}, @dots{})
 ##
 ## Solve the linear system of equations @w{@code{@var{A} * @var{x} = @var{b}}}
 ## by means of the Preconditioned Conjugate Gradient iterative method.
 ##
 ## The input arguments are:
 ##
@@ -47,36 +47,36 @@
 ## @w{@code{@var{tol} * norm (@var{b})}}}.
 ## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item
 ## @var{maxit} is the maximum allowed number of iterations; if @var{maxit}
 ## is omitted or empty then a value of 20 is used.
 ##
 ## @item
-## @var{m} is a HPD preconditioning matrix. For any decomposition
+## @var{m} is a HPD preconditioning matrix.  For any decomposition
 ## @code{@var{m} = @var{p1} * @var {p2}} such that
 ## @w{@code{inv (@var{p1}) * @var{A} * inv (@var{p2})}} is HPD, the
-## conjugate gradient method is formally applied to the linear  system
+## conjugate gradient method is formally applied to the linear system
 ## @w{@code{inv (@var{p1}) * @var{A} * inv (@var{p2}) * @var{y} = inv
 ## (@var{p1}) * @var{b}}},
 ## with @code{@var{x} = inv (@var{p2}) * @var{y}} (split preconditioning).
 ## In practice, at each iteration of the conjugate gradient method a
 ## linear system with matrix @var{m} is solved with @code{mldivide}.
 ## If a particular factorization
 ## @code{@var{m} = @var{m1} * @var{m2}} is available (for instance, an
 ## incomplete Cholesky factorization of @var{a}), the two matrices
 ## @var{m1} and @var{m2} can be passed and the relative linear systems
 ## are solved with the @code{mldivide} operator.
 ## Note that a proper choice of the preconditioner may dramatically improve
 ## the overall performance of the method.  Instead of matrices @var{m1} and
 ## @var{m2}, the user may pass two functions which return the results of
 ## applying the inverse of @var{m1} and @var{m2} to a vector.
 ## If @var{m1} is omitted or empty @code{[]}, then no preconditioning
-## is applied. If no factorization of @var{m} is available, @var{m2}
+## is applied.  If no factorization of @var{m} is available, @var{m2}
 ## can be omitted or left [], and the input variable @var{m1} can be
 ## used to pass the preconditioner @var{m}.
 ##
 ## @item
 ## @var{x0} is the initial guess.  If @var{x0} is omitted or empty then the
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
 ##
@@ -85,41 +85,46 @@
 ## @var{m2}) which are passed to @code{pcg}.
 ## See the examples below for further details.
 ##
 ## The output arguments are:
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
-## @w{@code{@var{A} * @var{x} = @var{b}}}. If the algorithm did not converge,
+## @w{@code{@var{A} * @var{x} = @var{b}}}.  If the algorithm did not converge,
 ## then @var{x} is the iterated which has the minimum residual.
 ##
 ## @item
 ## @var{flag} reports on the convergence:
+##
 ## @itemize
 ## @item 0: The algorithm converged at the prescribed tolerance.
+##
 ## @item 1: The algorithm did not converge and it reached the maximum
 ## number of iterations.
+##
 ## @item 2: The preconditioner matrix is singular.
-## @item 3: The algorithm stagnated, i.e. the absolute value of the
+##
+## @item 3: The algorithm stagnated, i.e., the absolute value of the
 ## difference between
 ## the actual iteration @var{x} and the previous is less than
 ## @code{@var{eps} * norm (@var{x},2)}.
+##
 ## @item 4: The algorithm detects that the input (preconditioned) matrix is not
 ## HPD.
 ## @end itemize
 ##
 ## @item
 ## @var{relres} is the ratio of the final residual to its initial value,
 ## measured in the Euclidean norm.
 ##
 ## @item
 ## @var{iter} indicates the iteration of @var{x} which it was
-## computed. Since the output @var{x} corresponds to the minimal
+## computed.  Since the output @var{x} corresponds to the minimal
 ## residual solution, the total number of iterations that
 ## the method performed is given by @code{length(resvec) - 1}.
 ##
 ## @item
 ## @var{resvec} describes the convergence history of the method.
 ## @code{@var{resvec} (@var{i}, 1)} is the Euclidean norm of the residual, and
 ## @code{@var{resvec} (@var{i}, 2)} is the preconditioned residual
 ## norm, after the
diff --git a/scripts/sparse/private/__alltohandles__.m b/scripts/sparse/private/__alltohandles__.m
--- a/scripts/sparse/private/__alltohandles__.m
+++ b/scripts/sparse/private/__alltohandles__.m
@@ -12,36 +12,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {[@var{Afun}, @var{M1fun}, @var{M2fun}] =} __alltohandles__ (@var{A}, @var{b}, @var{M1}, @var{M2}, @var{solver_name})
+## @deftypefn {} {[@var{Afun}, @var{M1fun}, @var{M2fun}] =} __alltohandles__ (@var{A}, @var{b}, @var{M1}, @var{M2}, @var{solver_name})
 ##
 ## Check if the parameters @var{A} (matrix of our linear system), @var{b}
 ## (right hand side vector), @var{M1}, @var{M2} (preconditioner matrices) are
 ## really matrices or functions handle, summarizing if they are void or not.
 ##
 ## The input parameters are:
 ##
 ## @itemize
 ## @item @var{A} is the matrix of the linear system.
 ##
 ## @item @var{b} is the right hand side vector.
 ##
-## @item @var{M1}, @var{M2} preconditioners. They can be [].
+## @item @var{M1}, @var{M2} preconditioners.  They can be [].
 ##
 ## @item @var{solver_name} is the name of the solver as string.
 ##
 ## @end itemize
 ##
 ## The output parameters are:
+##
 ## @itemize
 ##
 ## @item @var{Afun}, @var{M1fun}, @var{M2fun} are the corresponding
 ## function handles.
 ##
 ## @end itemize
 ## @end deftypefn
 
diff --git a/scripts/sparse/private/__default__input__.m b/scripts/sparse/private/__default__input__.m
--- a/scripts/sparse/private/__default__input__.m
+++ b/scripts/sparse/private/__default__input__.m
@@ -12,28 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {@var{[varargout]} =} __default__input__ (@var{def_val}, @var{varargin})
+## @deftypefn {} {@var{[varargout]} =} __default__input__ (@var{def_val}, @var{varargin})
 ## Check if the arguments in input of a function are empty or missing
 ## and in such cases sets up them in default values.
 ##
 ## The input argoments are:
+##
 ## @itemize @minus
 ## @item @var{def_val} is a cell array that contains the values to use
-## as  default.
+## as default.
+##
 ## @item @var{varargin} are the input argument
 ## @end itemize
 ##
 ## The output argoments:
+##
 ## @itemize @minus
 ## @item @var{varargout} all the input argument with filled the empty
 ## or missing paramenters.
 ##
 ## @end itemize
 ##
 ## @end deftypefn
 
diff --git a/scripts/sparse/tfqmr.m b/scripts/sparse/tfqmr.m
--- a/scripts/sparse/tfqmr.m
+++ b/scripts/sparse/tfqmr.m
@@ -23,55 +23,55 @@
 ## Solve @code{A x = b} using the Transpose-Tree qmr method, based on the cgs.
 ##
 ## The input parameters are:
 ##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with the same number of rows as @var{A}.
 ##
 ## @item @var{tol} is the relative tolerance, if not given or set to [] the
 ## default value 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
-## set to [] the default value @code{min (20, numel (b))} is used. To be
+## set to [] the default value @code{min (20, numel (b))} is used.  To be
 ## compatible, since the method as different behaviours in the iteration
 ## number is odd or even, is considered as iteration in @code{tfqmr} the
-## entire odd-even cycle. That is, to make an entire iteration, the algorithm
+## entire odd-even cycle.  That is, to make an entire iteration, the algorithm
 ## performs two sub-iterations: the odd one and the even one.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
 ## @var{M} is given as @code{M = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code {g(x) = M2 \ x}.
-## The technique used is the rigth-preconditioning, i.e. it is solved
+## The technique used is the rigth-preconditioning, i.e., it is solved
 ## @code{A*inv(M)*y = b} and then @code{x = inv(M)*y}, instead of
 ## @code{A x = b}.
 ##
 ## @item @var{x0} the initial guess, if not given or set to [] the default
 ## value @code{zeros (size (b))} is used.
 ##
 ## @end itemize
 ##
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M}) which are passed
 ## to @code{tfqmr}.
 ##
 ## The output parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
diff --git a/scripts/specfun/gammainc.m b/scripts/specfun/gammainc.m
--- a/scripts/specfun/gammainc.m
+++ b/scripts/specfun/gammainc.m
@@ -67,17 +67,17 @@
 ## @ifnottex
 ## @math{gamma(a+1)*exp(x)/(x^a)}.
 ## @end ifnottex
 ## If @var{tail} is @qcode{"scaledupper"}, then the upper incomplete gamma
 ## function is multiplied by the same quantity.
 ##
 ## References:
 ##
-## @nospell{M. Abramowitz and I. Stegun},
+## @nospell{M. Abramowitz and I.A. Stegun},
 ## @cite{Handbook of mathematical functions},
 ## @nospell{Dover publications, Inc.}, 1972.
 ##
 ## @nospell{W. Gautschi},
 ## @cite{A computational procedure for incomplete gamma functions},
 ## @nospell{ACM Trans. Math Software}, pp. 466--481, Vol 5, No. 4, 2012.
 ##
 ## @nospell{W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery},
diff --git a/scripts/statistics/cov.m b/scripts/statistics/cov.m
--- a/scripts/statistics/cov.m
+++ b/scripts/statistics/cov.m
@@ -34,16 +34,17 @@
 ## where $\bar{x}$ and $\bar{y}$ are the mean values of @var{x} and @var{y}.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## cov (@var{x}) = 1/(N-1) * SUM_i (@var{x}(i) - mean(@var{x})) * (@var{y}(i) - mean(@var{y}))
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} and @var{y} vectors.
 ##
 ## @end ifnottex
 ##
 ## If called with one argument, compute @code{cov (@var{x}, @var{x})}, the
 ## covariance between the columns of @var{x}.
 ##
 ## The argument @var{opt} determines the type of normalization to use.
diff --git a/scripts/statistics/kurtosis.m b/scripts/statistics/kurtosis.m
--- a/scripts/statistics/kurtosis.m
+++ b/scripts/statistics/kurtosis.m
@@ -60,16 +60,17 @@
 ## @example
 ## @group
 ##               N - 1
 ## k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
 ##          (N - 2)(N - 3)
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## The bias-corrected kurtosis coefficient is obtained by replacing the sample
 ## second and fourth central moments by their unbiased versions.  It is an
 ## unbiased estimate of the population kurtosis for normal populations.
 ##
 ## If @var{x} is a matrix, or more generally a multi-dimensional array, return
diff --git a/scripts/statistics/mean.m b/scripts/statistics/mean.m
--- a/scripts/statistics/mean.m
+++ b/scripts/statistics/mean.m
@@ -32,16 +32,17 @@
 ##
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## mean (@var{x}) = SUM_i @var{x}(i) / N
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
diff --git a/scripts/statistics/meansq.m b/scripts/statistics/meansq.m
--- a/scripts/statistics/meansq.m
+++ b/scripts/statistics/meansq.m
@@ -33,16 +33,17 @@
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## meansq (@var{x}) = 1/N SUM_i @var{x}(i)^2
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, return a row vector containing the mean square
 ## of each column.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{var, std, moment}
diff --git a/scripts/statistics/median.m b/scripts/statistics/median.m
--- a/scripts/statistics/median.m
+++ b/scripts/statistics/median.m
@@ -17,18 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} median (@var{x})
 ## @deftypefnx {} {} median (@var{x}, @var{dim})
 ## Compute the median value of the elements of the vector @var{x}.
 ##
-## When the elements of @var{x} are sorted, say @code{@var{s} = sort (@var{x})},
-## the median is defined as
+## When the elements of @var{x} are sorted, say
+## @code{@var{s} = sort (@var{x})}, the median is defined as
 ## @tex
 ## $$
 ## {\rm median} (x) =
 ##   \cases{s(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (s(N/2)+s(N/2+1))/2, & $N$ even.}
 ## $$
 ## where $N$ is the number of elements of @var{x}.
 ##
diff --git a/scripts/statistics/moment.m b/scripts/statistics/moment.m
--- a/scripts/statistics/moment.m
+++ b/scripts/statistics/moment.m
@@ -35,16 +35,17 @@
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## 1/N SUM_i (@var{x}(i) - mean(@var{x}))^@var{p}
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ##
 ## If @var{x} is a matrix, return the row vector containing the @var{p}-th
 ## central moment of each column.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
diff --git a/scripts/statistics/skewness.m b/scripts/statistics/skewness.m
--- a/scripts/statistics/skewness.m
+++ b/scripts/statistics/skewness.m
@@ -60,16 +60,17 @@
 ## @example
 ## @group
 ##                   sqrt (N*(N-1))   mean ((@var{x} - mean (@var{x})).^3)
 ## skewness (@var{X}, 0) = -------------- * ------------------------.
 ##                       (N - 2)             std (@var{x}).^3
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## The adjusted skewness coefficient is obtained by replacing the sample second
 ## and third central moments by their bias-corrected versions.
 ##
 ## If @var{x} is a matrix, or more generally a multi-dimensional array, return
 ## the skewness along the first non-singleton dimension.  If the optional
diff --git a/scripts/statistics/var.m b/scripts/statistics/var.m
--- a/scripts/statistics/var.m
+++ b/scripts/statistics/var.m
@@ -34,16 +34,17 @@
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## var (@var{x}) = 1/(N-1) SUM_i (@var{x}(i) - mean(@var{x}))^2
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the variance for each column and return
 ## them in a row vector.
 ##
 ## The argument @var{opt} determines the type of normalization to use.
 ## Valid values are
diff --git a/scripts/strings/erase.m b/scripts/strings/erase.m
--- a/scripts/strings/erase.m
+++ b/scripts/strings/erase.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {@var{newstr} =} erase (@var{str}, @var{ptn})
+## @deftypefn {} {@var{newstr} =} erase (@var{str}, @var{ptn})
 ## Delete all occurrences of @var{ptn} within @var{str}.
 ##
 ## @var{str} and @var{ptn} can be ordinary strings, cell array of strings, or
 ## character arrays.
 ##
 ## Examples
 ##
 ## @example
@@ -41,21 +41,23 @@
 ##
 ## ## cellstr, multiple patterns
 ## erase (@{"The ", "Octave interpreter ", "is fabulous"@}, @{"interpreter ", "The "@})
 ##     @result{} @{"", "Octave ", "is fabulous"@}
 ## @end group
 ## @end example
 ##
 ## Programming Note: @code{erase} deletes the first instance of a pattern in a
-## string when there are overlapping occurrences.  For example,
+## string when there are overlapping occurrences.  For example:
 ##
 ## @example
+## @group
 ## erase ("abababa", "aba")
 ##     @result{} "b"
+## @end group
 ## @end example
 ##
 ## See @code{strrep} for processing overlaps.
 ##
 ## @seealso{strrep, regexprep}
 ## @end deftypefn
 
 ## Author: Sahil Yadav <yadavsahil5198@gmail.com>
diff --git a/scripts/strings/isstring.m b/scripts/strings/isstring.m
--- a/scripts/strings/isstring.m
+++ b/scripts/strings/isstring.m
@@ -15,22 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} isstring (@var{x})
 ## Return true if @var{x} is a string array.
 ##
-## A string array is a data type that stores strings (row vectors of characters)
-## at each element in the array.  It is distinct from character arrays which
-## are N-dimensional arrays where each element is a single 1x1 character.  It
-## is also distinct from cell arrays of strings which store strings at each
-## element, but use cell indexing @samp{@{@}} to access elements rather than
-## string arrays which use ordinary array indexing @samp{()}.
+## A string array is a data type that stores strings (row vectors of
+## characters) at each element in the array.  It is distinct from character
+## arrays which are N-dimensional arrays where each element is a single 1x1
+## character.  It is also distinct from cell arrays of strings which store
+## strings at each element, but use cell indexing @samp{@{@}} to access
+## elements rather than string arrays which use ordinary array indexing
+## @samp{()}.
 ##
 ## Programming Note: Octave does not yet implement string arrays so this
 ## function will always return false.
 ## @seealso{ischar, iscellstr, isfloat, isinteger, islogical, isnumeric, isa}
 ## @end deftypefn
 
 function retval = isstring (s)
 
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -218,17 +218,17 @@
 %! x = getpwuid (getuid ());
 %! assert (x.dir, tilde_expand (sprintf ("~%s", x.name)));
 %! assert ("foobar", tilde_expand ("foobar"));
 
 %!error <Invalid call to tilde_expand> tilde_expand ()
 %!error <Invalid call to tilde_expand> tilde_expand ("str", 2)
 
 %!testif HAVE_GETPGRP
-%! assert (getpgrp () > 0);
+%! assert (getpgrp () >= 0);
 
 %!error <... getpgrp> getpgrp (1)
 
 %!assert (getpid () > 0)
 
 %!error <... getpid> getpid (1)
 
 %!testif HAVE_GETPPID
