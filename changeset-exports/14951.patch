# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1339709886 18000
#      Thu Jun 14 16:38:06 2012 -0500
# Node ID 4c9fd3e314366db7838e8524dea6506bac28b565
# Parent  7ab3ac5c676c094e00c8b649dfef962b65d30829
Start of jit support for double matricies

diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -159,16 +159,24 @@ private:
       // NR was originally allocated with new, but that does not seem
       // to be necessary since it will never be deleted.  So just use
       // a static object instead.
 
       static typename Array<T>::ArrayRep nr;
       return &nr;
     }
 
+protected:
+
+  // For jit support
+  Array (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+    : dimensions (adims),
+      rep (reinterpret_cast<typename Array<T>::ArrayRep *> (arep)),
+      slice_data (sdata), slice_len (slen) {}
+
 public:
 
   // Empty ctor (0x0).
 
   Array (void)
     : dimensions (), rep (nil_rep ()), slice_data (rep->data),
       slice_len (rep->len)
     {
@@ -688,16 +696,26 @@ public:
 
   template <class U> friend class Array;
 
   // Returns true if this->dims () == dv, and if so, replaces this->dimensions
   // by a shallow copy of dv. This is useful for maintaining several arrays with
   // supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
+  // WARNING: Only call these functions from jit
+
+  int *jit_ref_count (void) { return rep->count.get (); }
+
+  T *jit_slice_data (void) const { return slice_data; }
+
+  octave_idx_type *jit_dimensions (void) const { return dimensions.to_jit (); }
+
+  void *jit_array_rep (void) const { return rep; }
+
 private:
 
   void resize2 (octave_idx_type nr, octave_idx_type nc, const T& rfv);
   void resize2 (octave_idx_type nr, octave_idx_type nc)                
   {
     resize2 (nr, nc, resize_fill_value ());
   }
 
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -34,16 +34,22 @@ along with Octave; see the file COPYING.
 #include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray, )
 
 template <class T>
 class
 MArray : public Array<T>
 {
+protected:
+
+  // For jit support
+  MArray (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+    : Array<T> (sdata, slen, adims, arep) { }
+
 public:
 
   MArray (void) : Array<T> () {}
 
   explicit MArray (octave_idx_type n) GCC_ATTR_DEPRECATED
     : Array<T> (dim_vector (n, 1)) { }
 
   MArray (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -59,16 +59,20 @@ public:
   template <class U>
   NDArray (const Array<U>& a) : MArray<double> (a) { }
 
   template <class U>
   explicit NDArray (const intNDArray<U>& a) : MArray<double> (a) { }
 
   NDArray (const charNDArray&);
 
+  // For jit support only
+  NDArray (double *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+    : MArray<double> (sdata, slen, adims, arep) { }
+
   NDArray& operator = (const NDArray& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   // unary operations
 
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -207,37 +207,44 @@ public:
           l--;
         while (l > 2 && rep[l-1] == 1);
         ndims () = l;
       }
   }
 
   void chop_all_singletons (void);
 
+  // WARNING: Only call by jit
+  octave_idx_type *to_jit (void) const
+  {
+    return rep;
+  }
+
 private:
 
   static octave_idx_type *nil_rep (void)
     {
       static dim_vector zv (0, 0);
       return zv.rep;
     }
 
-  explicit dim_vector (octave_idx_type *r)
-    : rep (r) { }
-
 public:
 
   static octave_idx_type dim_max (void);
 
   explicit dim_vector (void) : rep (nil_rep ())
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
   dim_vector (const dim_vector& dv) : rep (dv.rep)
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
+  // FIXME: Should be private, but required by array constructor for jit
+  explicit dim_vector (octave_idx_type *r)
+    : rep (r) { }
+
   static dim_vector alloc (int n)
   {
     return dim_vector (newrep (n < 2 ? 2 : n));
   }
 
   dim_vector& operator = (const dim_vector& dv)
   {
     if (&dv != this)
diff --git a/liboctave/oct-refcount.h b/liboctave/oct-refcount.h
--- a/liboctave/oct-refcount.h
+++ b/liboctave/oct-refcount.h
@@ -77,13 +77,18 @@ public:
       return OCTREFCOUNT_ATOMIC_DECREMENT_POST (&count);
     }
 
   operator count_type (void) const
     {
       return static_cast<count_type const volatile&> (count);
     }
 
+  count_type *get (void)
+    {
+      return &count;
+    }
+
 private:
   count_type count;
 };
 
 #endif
diff --git a/src/pt-jit.cc b/src/pt-jit.cc
--- a/src/pt-jit.cc
+++ b/src/pt-jit.cc
@@ -18,16 +18,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #define __STDC_LIMIT_MACROS
 #define __STDC_CONSTANT_MACROS
 
+#define OCTAVE_JIT_DEBUG
+
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #ifdef HAVE_LLVM
 
 #include "pt-jit.h"
 
@@ -142,23 +144,48 @@ octave_jit_compute_nelem (double base, d
 }
 
 extern "C" void
 octave_jit_release_any (octave_base_value *obv)
 {
   obv->release ();
 }
 
+extern "C" void
+octave_jit_delete_matrix (jit_matrix *m)
+{
+  NDArray array (*m);
+}
+
 extern "C" octave_base_value *
 octave_jit_grab_any (octave_base_value *obv)
 {
   obv->grab ();
   return obv;
 }
 
+extern "C" octave_base_value *
+octave_jit_cast_any_matrix (jit_matrix *jmatrix)
+{
+  ++(*jmatrix->ref_count);
+  NDArray matrix = *jmatrix;
+  octave_value ret (matrix);
+
+  octave_base_value *rep = ret.internal_rep ();
+  rep->grab ();
+  return rep;
+}
+
+extern "C" void
+octave_jit_cast_matrix_any (jit_matrix *ret, octave_base_value *obv)
+{
+  NDArray m = obv->array_value ();
+  *ret = m;
+}
+
 extern "C" double
 octave_jit_cast_scalar_any (octave_base_value *obv)
 {
   double ret = obv->double_value ();
   obv->release ();
   return ret;
 }
 
@@ -185,24 +212,68 @@ extern "C" octave_base_value *
 octave_jit_xpow (double a, double b)
 {
   octave_value ret = xpow (a, b);
   octave_base_value *obv = ret.internal_rep ();
   obv->grab ();
   return obv;
 }
 
+extern "C" void
+octave_jit_ginvalid_index (void)
+{
+  try
+    {
+      gripe_invalid_index ();      
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_library_execution_error ();
+    }
+}
+
+extern "C" void
+octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
+                         octave_idx_type ext)
+{
+  std::cout << "gindex_range\n";
+  try
+    {
+      gripe_index_out_of_range (nd, dim, iext, ext);
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_library_execution_error ();
+    }
+}
+
+extern "C" void
+octave_jit_print_matrix (jit_matrix *m)
+{
+  std::cout << *m << std::endl;
+}
+
 // -------------------- jit_range --------------------
 std::ostream&
 operator<< (std::ostream& os, const jit_range& rng)
 {
   return os << "Range[" << rng.base << ", " << rng.limit << ", " << rng.inc
             << ", " << rng.nelem << "]";
 }
 
+// -------------------- jit_matrix --------------------
+
+std::ostream&
+operator<< (std::ostream& os, const jit_matrix& mat)
+{
+  return os << "Matrix[" << mat.ref_count << ", " << mat.slice_data << ", "
+            << mat.slice_len << ", " << mat.dimensions << ", "
+            << mat.array_rep << "]";
+}
+
 // -------------------- jit_type --------------------
 llvm::Type *
 jit_type::to_llvm_arg (void) const
 {
   return llvm_type ? llvm_type->getPointerTo () : 0;
 }
 
 // -------------------- jit_function --------------------
@@ -286,44 +357,46 @@ jit_typeinfo::initialize (llvm::Module *
 {
   instance = new jit_typeinfo (m, e);
 }
 
 jit_typeinfo::jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e)
   : module (m), engine (e), next_id (0)
 {
   // FIXME: We should be registering types like in octave_value_typeinfo
-  ov_t = llvm::StructType::create (context, "octave_base_value");
-  ov_t = ov_t->getPointerTo ();
-
-  llvm::Type *dbl = llvm::Type::getDoubleTy (context);
+  llvm::Type *any_t = llvm::StructType::create (context, "octave_base_value");
+  any_t = any_t->getPointerTo ();
+
+  llvm::Type *scalar_t = llvm::Type::getDoubleTy (context);
   llvm::Type *bool_t = llvm::Type::getInt1Ty (context);
   llvm::Type *string_t = llvm::Type::getInt8Ty (context);
   string_t = string_t->getPointerTo ();
-  llvm::Type *index_t = 0;
-  switch (sizeof(octave_idx_type))
-    {
-    case 4:
-      index_t = llvm::Type::getInt32Ty (context);
-      break;
-    case 8:
-      index_t = llvm::Type::getInt64Ty (context);
-      break;
-    default:
-      assert (false && "Unrecognized index type size");
-    }
+  llvm::Type *index_t = llvm::Type::getIntNTy (context, sizeof(octave_idx_type) * 8);
 
   llvm::StructType *range_t = llvm::StructType::create (context, "range");
-  std::vector<llvm::Type *> range_contents (4, dbl);
+  std::vector<llvm::Type *> range_contents (4, scalar_t);
   range_contents[3] = index_t;
   range_t->setBody (range_contents);
 
+  llvm::Type *refcount_t = llvm::Type::getIntNTy (context, sizeof(int) * 8);
+  llvm::Type *int_t = refcount_t;
+
+  llvm::StructType *matrix_t = llvm::StructType::create (context, "matrix");
+  llvm::Type *matrix_contents[5];
+  matrix_contents[0] = refcount_t->getPointerTo ();
+  matrix_contents[1] = scalar_t->getPointerTo ();
+  matrix_contents[2] = index_t;
+  matrix_contents[3] = index_t->getPointerTo ();
+  matrix_contents[4] = string_t;
+  matrix_t->setBody (llvm::makeArrayRef (matrix_contents, 5));
+
   // create types
-  any = new_type ("any", 0, ov_t);
-  scalar = new_type ("scalar", any, dbl);
+  any = new_type ("any", 0, any_t);
+  matrix = new_type ("matrix", any, matrix_t);
+  scalar = new_type ("scalar", any, scalar_t);
   range = new_type ("range", any, range_t);
   string = new_type ("string", any, string_t);
   boolean = new_type ("bool", any, bool_t);
   index = new_type ("index", any, index_t);
 
   casts.resize (next_id + 1);
   identities.resize (next_id + 1, 0);
 
@@ -373,30 +446,85 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   // grab any
   fn = create_function ("octave_jit_grab_any", any, any);
                         
   engine->addGlobalMapping (fn, reinterpret_cast<void*>(&octave_jit_grab_any));
   grab_fn.add_overload (fn, false, any, any);
   grab_fn.stash_name ("grab");
 
+  // grab matrix
+  llvm::Function *print_matrix = create_function ("octave_jit_print_matrix",
+                                                  void_t,
+                                                  matrix_t->getPointerTo ());
+  engine->addGlobalMapping (print_matrix, reinterpret_cast<void*>(&octave_jit_print_matrix));
+
+  fn = create_function ("octave_jit_grab_matrix", matrix, matrix);
+  llvm::BasicBlock *body = llvm::BasicBlock::Create (context, "body", fn);
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantInt::get (refcount_t, 1);
+
+    llvm::Value *mat = fn->arg_begin ();
+    llvm::Value *rcount= builder.CreateExtractValue (mat, 0);
+    llvm::Value *count = builder.CreateLoad (rcount);
+    count = builder.CreateAdd (count, one);
+    builder.CreateStore (count, rcount);
+    builder.CreateRet (mat);
+  }
+  grab_fn.add_overload (fn, false, matrix, matrix);
+
   // grab scalar
   fn = create_identity (scalar);
   grab_fn.add_overload (fn, false, scalar, scalar);
 
   // grab index
   fn = create_identity (index);
   grab_fn.add_overload (fn, false, index, index);
 
   // release any
-  fn = create_function ("octave_jit_release_any", void_t, any->to_llvm ());
+  fn = create_function ("octave_jit_release_any", void_t, any_t);
   engine->addGlobalMapping (fn, reinterpret_cast<void*>(&octave_jit_release_any));
   release_fn.add_overload (fn, false, 0, any);
   release_fn.stash_name ("release");
 
+  // release matrix
+  llvm::Function *delete_mat = create_function ("octave_jit_delete_matrix", void_t,
+                                                matrix_t);
+  engine->addGlobalMapping (delete_mat,
+                            reinterpret_cast<void*> (&octave_jit_delete_matrix));
+
+  fn = create_function ("octave_jit_release_matrix", void_t, matrix_t);
+  llvm::Function *release_mat = fn;
+  body = llvm::BasicBlock::Create (context, "body", fn);
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantInt::get (refcount_t, 1);
+    llvm::Value *zero = llvm::ConstantInt::get (refcount_t, 0);
+
+    llvm::Value *mat = fn->arg_begin ();
+    llvm::Value *rcount= builder.CreateExtractValue (mat, 0);
+    llvm::Value *count = builder.CreateLoad (rcount);
+    count = builder.CreateSub (count, one);
+
+    llvm::BasicBlock *dead = llvm::BasicBlock::Create (context, "dead", fn);
+    llvm::BasicBlock *live = llvm::BasicBlock::Create (context, "live", fn);
+    llvm::Value *isdead = builder.CreateICmpEQ (count, zero);
+    builder.CreateCondBr (isdead, dead, live);
+
+    builder.SetInsertPoint (dead);
+    builder.CreateCall (delete_mat, mat);
+    builder.CreateRetVoid ();
+
+    builder.SetInsertPoint (live);
+    builder.CreateStore (count, rcount);
+    builder.CreateRetVoid ();
+  }
+  release_fn.add_overload (fn, false, 0, matrix);
+
   // release scalar
   fn = create_identity (scalar);
   release_fn.add_overload (fn, false, 0, scalar);
 
   // release index
   fn = create_identity (index);
   release_fn.add_overload (fn, false, 0, index);
 
@@ -424,23 +552,23 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   }
 
   llvm::Function *gripe_div0 = create_function ("gripe_divide_by_zero", void_t);
   engine->addGlobalMapping (gripe_div0,
                             reinterpret_cast<void *> (&gripe_divide_by_zero));
 
   // divide is annoying because it might error
   fn = create_function ("octave_jit_div_scalar_scalar", scalar, scalar, scalar);
-  llvm::BasicBlock *body = llvm::BasicBlock::Create (context, "body", fn);
+  body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::BasicBlock *warn_block = llvm::BasicBlock::Create (context, "warn", fn);
     llvm::BasicBlock *normal_block = llvm::BasicBlock::Create (context, "normal", fn);
 
-    llvm::Value *zero = llvm::ConstantFP::get (dbl, 0);
+    llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
     llvm::Value *check = builder.CreateFCmpUEQ (zero, ++fn->arg_begin ());
     builder.CreateCondBr (check, warn_block, normal_block);
 
     builder.SetInsertPoint (warn_block);
     builder.CreateCall (gripe_div0);
     builder.CreateBr (normal_block);
 
     builder.SetInsertPoint (normal_block);
@@ -509,17 +637,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   // index variabe for for loop
   for_index_fn.stash_name ("for_index");
 
   fn = create_function ("octave_jit_for_range_idx", scalar, range, index);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::Value *idx = ++fn->arg_begin ();
-    llvm::Value *didx = builder.CreateUIToFP (idx, dbl);
+    llvm::Value *didx = builder.CreateSIToFP (idx, scalar_t);
     llvm::Value *rng = fn->arg_begin ();
     llvm::Value *base = builder.CreateExtractValue (rng, 0);
     llvm::Value *inc = builder.CreateExtractValue (rng, 2);
 
     llvm::Value *ret = builder.CreateFMul (didx, inc);
     ret = builder.CreateFAdd (base, ret);
     builder.CreateRet (ret);
   }
@@ -543,17 +671,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *check = builder.CreateFCmpUNE (fn->arg_begin (), fn->arg_begin ());
     builder.CreateCondBr (check, error_block, normal_block);
 
     builder.SetInsertPoint (error_block);
     builder.CreateCall (gripe_nantl);
     builder.CreateBr (normal_block);
     builder.SetInsertPoint (normal_block);
 
-    llvm::Value *zero = llvm::ConstantFP::get (dbl, 0);
+    llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
     llvm::Value *ret = builder.CreateFCmpONE (fn->arg_begin (), zero);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
   logically_true_fn.add_overload (fn, true, boolean, scalar);
 
   fn = create_function ("octave_logically_true_bool", boolean, boolean);
   body = llvm::BasicBlock::Create (context, "body", fn);
@@ -575,32 +703,133 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   builder.SetInsertPoint (body);
   {
     llvm::Function::arg_iterator args = fn->arg_begin ();
     llvm::Value *base = args;
     llvm::Value *limit = ++args;
     llvm::Value *inc = ++args;
     llvm::Value *nelem = builder.CreateCall3 (compute_nelem, base, limit, inc);
 
-    llvm::Value *dzero = llvm::ConstantFP::get (dbl, 0);
+    llvm::Value *dzero = llvm::ConstantFP::get (scalar_t, 0);
     llvm::Value *izero = llvm::ConstantInt::get (index_t, 0);
     llvm::Value *rng = llvm::ConstantStruct::get (range_t, dzero, dzero, dzero,
                                                   izero, NULL);
     rng = builder.CreateInsertValue (rng, base, 0);
     rng = builder.CreateInsertValue (rng, limit, 1);
     rng = builder.CreateInsertValue (rng, inc, 2);
     rng = builder.CreateInsertValue (rng, nelem, 3);
     builder.CreateRet (rng);
   }
   llvm::verifyFunction (*fn);
   make_range_fn.add_overload (fn, false, range, scalar, scalar, scalar);
 
+  // paren_subsref
+  llvm::Function *ginvalid_index = create_function ("gipe_invalid_index", void_t);
+  engine->addGlobalMapping (ginvalid_index,
+                            reinterpret_cast<void*> (&octave_jit_ginvalid_index));
+
+  llvm::Function *gindex_range = create_function ("gripe_index_out_of_range",
+                                                  void_t, int_t, int_t, index_t,
+                                                  index_t);
+  engine->addGlobalMapping (gindex_range,
+                            reinterpret_cast<void*> (&octave_jit_gindex_range));
+
+  fn = create_function ("()subsref", scalar, matrix, scalar);
+  body = llvm::BasicBlock::Create (context, "body", fn);
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantInt::get (index_t, 1);
+    llvm::Value *ione;
+    if (index_t == int_t)
+      ione = one;
+    else
+      ione = llvm::ConstantInt::get (int_t, 1);
+            
+
+    llvm::Value *szero = llvm::ConstantFP::get (scalar_t, 0);
+
+    llvm::Function::arg_iterator args = fn->arg_begin ();
+    llvm::Value *mat = args++;
+    llvm::Value *idx = args;
+
+    // convert index to scalar to integer, and check index >= 1
+    llvm::Value *int_idx = builder.CreateFPToSI (idx, index_t);
+    llvm::Value *check_idx = builder.CreateSIToFP (int_idx, scalar_t);
+    llvm::Value *cond0 = builder.CreateFCmpUNE (idx, check_idx);
+    llvm::Value *cond1 = builder.CreateICmpSLT (int_idx, one);
+    llvm::Value *cond = builder.CreateOr (cond0, cond1);
+
+    llvm::BasicBlock *done = llvm::BasicBlock::Create (context, "done", fn);
+
+    llvm::BasicBlock *conv_error = llvm::BasicBlock::Create (context,
+                                                             "conv_error", fn,
+                                                             done);
+    llvm::BasicBlock *normal = llvm::BasicBlock::Create (context, "normal", fn,
+                                                         done);
+    builder.CreateCondBr (cond, conv_error, normal);
+
+    builder.SetInsertPoint (conv_error);
+    builder.CreateCall (ginvalid_index);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (normal);
+    llvm::Value *len = builder.CreateExtractValue (mat,
+                                                   llvm::ArrayRef<unsigned> (2));
+    cond = builder.CreateICmpSGT (int_idx, len);
+
+
+    llvm::BasicBlock *bounds_error = llvm::BasicBlock::Create (context,
+                                                               "bounds_error",
+                                                               fn, done);
+
+    llvm::BasicBlock *success = llvm::BasicBlock::Create (context, "success",
+                                                          fn, done);
+    builder.CreateCondBr (cond, bounds_error, success);
+
+    builder.SetInsertPoint (bounds_error);
+    builder.CreateCall4 (gindex_range, ione, ione, int_idx, len);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (success);
+    llvm::Value *data = builder.CreateExtractValue (mat,
+                                                    llvm::ArrayRef<unsigned> (1));
+    llvm::Value *gep = builder.CreateInBoundsGEP (data, int_idx);
+    llvm::Value *ret = builder.CreateLoad (gep);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (done);
+
+    llvm::PHINode *merge = llvm::PHINode::Create (scalar_t, 3);
+    builder.Insert (merge);
+    merge->addIncoming (szero, conv_error);
+    merge->addIncoming (szero, bounds_error);
+    merge->addIncoming (ret, success);
+    builder.CreateCall (release_mat, mat);
+    builder.CreateRet (merge);
+  }
+  llvm::verifyFunction (*fn);
+  paren_subsref_fn.add_overload (fn, true, scalar, matrix, scalar);
+
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
 
+  // cast any <- matrix
+  fn = create_function ("octave_jit_cast_any_matrix", any_t,
+                        matrix_t->getPointerTo ());
+  engine->addGlobalMapping (fn,
+                            reinterpret_cast<void*> (&octave_jit_cast_any_matrix));
+  casts[any->type_id ()].add_overload (fn, false, any, matrix);
+
+  // cast matrix <- any
+  fn = create_function ("octave_jit_cast_matrix_any", void_t,
+                        matrix_t->getPointerTo (), any_t);
+  engine->addGlobalMapping (fn,
+                            reinterpret_cast<void*> (&octave_jit_cast_matrix_any));
+  casts[matrix->type_id ()].add_overload (fn, false, matrix, any);
+
   // cast any <- scalar
   fn = create_function ("octave_jit_cast_any_scalar", any, scalar);
   engine->addGlobalMapping (fn, reinterpret_cast<void*> (&octave_jit_cast_any_scalar));
   casts[any->type_id ()].add_overload (fn, false, any, scalar);
 
   // cast scalar <- any
   fn = create_function ("octave_jit_cast_scalar_any", scalar, any);
   engine->addGlobalMapping (fn, reinterpret_cast<void*> (&octave_jit_cast_scalar_any));
@@ -735,24 +964,30 @@ jit_typeinfo::do_insert_error_check (voi
 {
   return builder.CreateLoad (lerror_state);
 }
 
 jit_type *
 jit_typeinfo::do_type_of (const octave_value &ov) const
 {
   if (ov.is_function ())
-    return 0;
-
-  if (ov.is_double_type () && ov.is_real_scalar ())
-    return get_scalar ();
+    return 0; // functions are not supported
 
   if (ov.is_range ())
     return get_range ();
 
+  if (ov.is_double_type ())
+    {
+      if (ov.is_real_scalar ())
+        return get_scalar ();
+
+      if (ov.is_matrix_type ())
+        return get_matrix ();
+    }
+
   return get_any ();
 }
 
 jit_type*
 jit_typeinfo::new_type (const std::string& name, jit_type *parent,
                         llvm::Type *llvm_type)
 {
   jit_type *ret = new jit_type (name, parent, llvm_type, next_id++);
@@ -1340,17 +1575,17 @@ jit_convert::jit_convert (llvm::Module *
 
   // for now just init arguments from entry, later we will have to do something
   // more interesting
   for (jit_block::iterator iter = entry_block->begin ();
        iter != entry_block->end (); ++iter)
     if (jit_extract_argument *extract = dynamic_cast<jit_extract_argument *> (*iter))
       arguments.push_back (std::make_pair (extract->name (), true));
 
-  convert_llvm to_llvm;
+  convert_llvm to_llvm (*this);
   function = to_llvm.convert (module, arguments, blocks, constants);
 
 #ifdef OCTAVE_JIT_DEBUG
   std::cout << "-------------------- llvm ir --------------------";
   llvm::raw_os_ostream llvm_cout (std::cout);
   function->print (llvm_cout);
   std::cout << std::endl;
   llvm::verifyFunction (*function);
@@ -1681,19 +1916,44 @@ jit_convert::visit_if_command_list (tree
       block = tail;
     }
   else
     // every branch broke, so we don't have a tail
     breaking = true;
 }
 
 void
-jit_convert::visit_index_expression (tree_index_expression&)
+jit_convert::visit_index_expression (tree_index_expression& exp)
 {
-  fail ();
+  std::string type = exp.type_tags ();
+  if (! (type.size () == 1 && type[0] == '('))
+    fail ("Unsupported index operation");
+
+  std::list<tree_argument_list *> args = exp.arg_lists ();
+  if (args.size () != 1)
+    fail ("Bad number of arguments in tree_index_expression");
+
+  tree_argument_list *arg_list = args.front ();
+  if (arg_list->size () != 1)
+    fail ("Bad number of arguments in arg_list");
+
+  tree_expression *tree_object = exp.expression ();
+  jit_value *object = visit (tree_object);
+
+  tree_expression *arg0 = arg_list->front ();
+  jit_value *index = visit (arg0);
+
+  jit_call *call = create<jit_call> (jit_typeinfo::paren_subsref, object, index);
+  block->append (call);
+
+  jit_block *normal = create<jit_block> (block->name ());
+  block->append (create<jit_check_error> (call, normal, final_block));
+  add_block (normal);
+  block = normal;
+  result = call;
 }
 
 void
 jit_convert::visit_matrix (tree_matrix&)
 {
   fail ();
 }
 
@@ -2281,17 +2541,17 @@ jit_convert::convert_llvm::finish_phi (j
               if (! ol.function)
                 {
                   std::stringstream ss;
                   ss << "No release for phi(" << i << "): ";
                   phi->print (ss);
                   fail (ss.str ());
                 }
 
-              builder.CreateCall (ol.function, phi->argument_llvm (i));
+              create_call (ol, phi->argument (i));
             }
         }
     }
   else
     {
       for (size_t i = 0; i < phi->argument_count (); ++i)
         {
           llvm::BasicBlock *pred = phi->incomming_llvm (i);
@@ -2300,27 +2560,18 @@ jit_convert::convert_llvm::finish_phi (j
           else
             {
               // add cast right before pred terminator
               builder.SetInsertPoint (--pred->end ());
 
               const jit_function::overload& ol
                 = jit_typeinfo::cast (phi->type (),
                                       phi->argument_type (i));
-              if (! ol.function)
-                {
-                  std::stringstream ss;
-                  ss << "No cast for phi(" << i << "): ";
-                  phi->print (ss);
-                  fail (ss.str ());
-                }
-
-              llvm::Value *casted;
-              casted = builder.CreateCall (ol.function,
-                                           phi->argument_llvm (i));
+
+              llvm::Value *casted = create_call (ol, phi->argument (i));
               llvm_phi->addIncoming (casted, pred);
             }
         }
     }
 }
 
 void
 jit_convert::convert_llvm::visit (jit_const_string& cs)
@@ -2338,24 +2589,24 @@ void jit_convert::convert_llvm::visit (j
 {
   ci.stash_llvm (llvm::ConstantInt::get (ci.type_llvm (), ci.value ()));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_const_range& cr)
 {
   llvm::StructType *stype = llvm::cast<llvm::StructType>(cr.type_llvm ());
-  llvm::Type *dbl = jit_typeinfo::get_scalar_llvm ();
+  llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
   llvm::Type *idx = jit_typeinfo::get_index_llvm ();
   const jit_range& rng = cr.value ();
 
   llvm::Constant *constants[4];
-  constants[0] = llvm::ConstantFP::get (dbl, rng.base);
-  constants[1] = llvm::ConstantFP::get (dbl, rng.limit);
-  constants[2] = llvm::ConstantFP::get (dbl, rng.inc);
+  constants[0] = llvm::ConstantFP::get (scalar_t, rng.base);
+  constants[1] = llvm::ConstantFP::get (scalar_t, rng.limit);
+  constants[2] = llvm::ConstantFP::get (scalar_t, rng.inc);
   constants[3] = llvm::ConstantInt::get (idx, rng.nelem);
 
   llvm::Value *as_llvm;
   as_llvm = llvm::ConstantStruct::get (stype,
                                        llvm::makeArrayRef (constants, 4));
   cr.stash_llvm (as_llvm);
 }
 
@@ -2381,49 +2632,35 @@ jit_convert::convert_llvm::visit (jit_co
   llvm::Value *br;
   br = builder.CreateCondBr (cond, cb.successor_llvm (0), cb.successor_llvm (1));
   cb.stash_llvm (br);
 }
 
 void
 jit_convert::convert_llvm::visit (jit_call& call)
 {
-  const jit_function::overload& ol = call.overload ();
-  if (! ol.function)
-    fail ("No overload for: " + call.print_string ());
-
-  std::vector<llvm::Value *> args (call.argument_count ());
-  for (size_t i = 0; i < call.argument_count (); ++i)
-    args[i] = call.argument_llvm (i);
-
-  call.stash_llvm (builder.CreateCall (ol.function, args));
+  llvm::Value *ret = create_call (call.overload (), call.arguments ());
+  call.stash_llvm (ret);
 }
 
 void
 jit_convert::convert_llvm::visit (jit_extract_argument& extract)
 {
-  const jit_function::overload& ol = extract.overload ();
-  if (! ol.function)
-    fail ();
-
   llvm::Value *arg = arguments[extract.name ()];
   assert (arg);
   arg = builder.CreateLoad (arg);
-  extract.stash_llvm (builder.CreateCall (ol.function, arg, extract.name ()));
+
+  jit_value *jarg = jthis.create<jit_argument> (jit_typeinfo::get_any (), arg);
+  extract.stash_llvm (create_call (extract.overload (), jarg));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_store_argument& store)
 {
-  llvm::Value *arg_value = store.result_llvm ();
-  const jit_function::overload& ol = store.overload ();
-  if (! ol.function)
-    fail ();
-
-  arg_value = builder.CreateCall (ol.function, arg_value);
+  llvm::Value *arg_value = create_call (store.overload (), store.result ());
 
   llvm::Value *arg = arguments[store.name ()];
   store.stash_llvm (builder.CreateStore (arg_value, arg));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_phi& phi)
 {
@@ -2458,16 +2695,79 @@ jit_convert::convert_llvm::visit (jit_ch
                                           check.successor_llvm (1));
   check.stash_llvm (br);
 }
 
 void
 jit_convert::convert_llvm::visit (jit_assign&)
 {}
 
+void
+jit_convert::convert_llvm::visit (jit_argument&)
+{}
+
+llvm::Value *
+jit_convert::convert_llvm::create_call (const jit_function::overload& ol,
+                                        const std::vector<jit_value *>& jargs)
+{
+   llvm::Function *fun = ol.function;
+   if (! fun)
+     fail ("Missing overload");
+
+  const llvm::Function::ArgumentListType& alist = fun->getArgumentList ();
+  size_t nargs = alist.size ();
+  bool sret = false;
+  if (nargs != jargs.size ())
+    {
+      // first argument is the structure return value
+      assert (nargs == jargs.size () + 1);
+      sret = true;
+    }
+
+  std::vector<llvm::Value *> args (nargs);
+  llvm::Function::arg_iterator llvm_arg = fun->arg_begin ();
+  if (sret)
+    {
+      args[0] = builder.CreateAlloca (ol.result->to_llvm ());
+      ++llvm_arg;
+    }
+
+  for (size_t i = 0; i < jargs.size (); ++i, ++llvm_arg)
+    {
+      llvm::Value *arg = jargs[i]->to_llvm ();
+      llvm::Type *arg_type = arg->getType ();
+      llvm::Type *llvm_arg_type = llvm_arg->getType ();
+
+      if (arg_type == llvm_arg_type)
+        args[i + sret] = arg;
+      else
+        {
+          // pass structure by pointer
+          assert (arg_type->getPointerTo () == llvm_arg_type);
+          llvm::Value *new_arg = builder.CreateAlloca (arg_type);
+          builder.CreateStore (arg, new_arg);
+          args[i + sret] = new_arg;
+        }
+    }
+
+  llvm::Value *llvm_call = builder.CreateCall (fun, args);
+  return sret ? builder.CreateLoad (args[0]) : llvm_call;
+}
+
+llvm::Value *
+jit_convert::convert_llvm::create_call (const jit_function::overload& ol,
+                                        const std::vector<jit_use>& uses)
+{
+  std::vector<jit_value *> values (uses.size ());
+  for (size_t i = 0; i < uses.size (); ++i)
+    values[i] = uses[i].value ();
+
+  return create_call (ol, values);
+}
+
 // -------------------- tree_jit --------------------
 
 tree_jit::tree_jit (void) : module (0), engine (0)
 {
 }
 
 tree_jit::~tree_jit (void)
 {}
diff --git a/src/pt-jit.h b/src/pt-jit.h
--- a/src/pt-jit.h
+++ b/src/pt-jit.h
@@ -214,16 +214,53 @@ jit_range
   double base;
   double limit;
   double inc;
   octave_idx_type nelem;
 };
 
 std::ostream& operator<< (std::ostream& os, const jit_range& rng);
 
+// jit_array is compatable with the llvm array/matrix structures
+template <typename T, typename U>
+struct
+jit_array
+{
+  jit_array (T& from) : ref_count (from.jit_ref_count ()),
+                        slice_data (from.jit_slice_data () - 1),
+                        slice_len (from.capacity ()),
+                        dimensions (from.jit_dimensions ()),
+                        array_rep (from.jit_array_rep ())
+  {
+    grab_dimensions ();
+  }
+
+  void grab_dimensions (void)
+  {
+    ++(dimensions[-2]);
+  }
+
+  operator T () const
+  {
+    return T (slice_data + 1, slice_len, dimensions, array_rep);
+  }
+
+  int *ref_count;
+
+  U *slice_data;
+  octave_idx_type slice_len;
+  octave_idx_type *dimensions;
+
+  void *array_rep;
+};
+
+typedef jit_array<NDArray, double> jit_matrix;
+
+std::ostream& operator<< (std::ostream& os, const jit_matrix& mat);
+
 // Used to keep track of estimated (infered) types during JIT. This is a
 // hierarchical type system which includes both concrete and abstract types.
 //
 // Current, we only support any and scalar types. If we can't figure out what
 // type a variable is, we assign it the any type. This allows us to generate
 // code even for the case of poor type inference.
 class
 jit_type
@@ -379,16 +416,18 @@ public:
 
   static jit_type *join (jit_type *lhs, jit_type *rhs)
   {
     return instance->do_join (lhs, rhs);
   }
 
   static jit_type *get_any (void) { return instance->any; }
 
+  static jit_type *get_matrix (void) { return instance->matrix; }
+
   static jit_type *get_scalar (void) { return instance->scalar; }
 
   static llvm::Type *get_scalar_llvm (void) { return instance->scalar->to_llvm (); }
 
   static jit_type *get_range (void) { return instance->range; }
 
   static jit_type *get_string (void) { return instance->string; }
 
@@ -440,16 +479,21 @@ public:
     return instance->for_index_fn;
   }
 
   static const jit_function& make_range (void)
   {
     return instance->make_range_fn;
   }
 
+  static const jit_function& paren_subsref (void)
+  {
+    return instance->paren_subsref_fn;
+  }
+
   static const jit_function& logically_true (void)
   {
     return instance->logically_true_fn;
   }
 
   static const jit_function& cast (jit_type *result)
   {
     return instance->do_cast (result);
@@ -592,48 +636,61 @@ private:
                                    jit_type *arg0, jit_type *arg1,
                                    jit_type *arg2)
   {
     return create_function (name, ret->to_llvm (), arg0->to_llvm (),
                             arg1->to_llvm (), arg2->to_llvm ());
   }
 
   llvm::Function *create_function (const llvm::Twine& name, llvm::Type *ret,
+                                   llvm::Type *arg0, llvm::Type *arg1,
+                                   llvm::Type *arg2, llvm::Type *arg3)
+  {
+    std::vector<llvm::Type *> args (4);
+    args[0] = arg0;
+    args[1] = arg1;
+    args[2] = arg2;
+    args[3] = arg3;
+    return create_function (name, ret, args);
+  }
+
+  llvm::Function *create_function (const llvm::Twine& name, llvm::Type *ret,
                                    const std::vector<llvm::Type *>& args);
 
   llvm::Function *create_identity (jit_type *type);
 
   llvm::Value *do_insert_error_check (void);
 
   static jit_typeinfo *instance;
 
   llvm::Module *module;
   llvm::ExecutionEngine *engine;
   int next_id;
 
-  llvm::Type *ov_t;
   llvm::GlobalVariable *lerror_state;
 
   std::vector<jit_type*> id_to_type;
   jit_type *any;
+  jit_type *matrix;
   jit_type *scalar;
   jit_type *range;
   jit_type *string;
   jit_type *boolean;
   jit_type *index;
 
   std::vector<jit_function> binary_ops;
   jit_function grab_fn;
   jit_function release_fn;
   jit_function print_fn;
   jit_function for_init_fn;
   jit_function for_check_fn;
   jit_function for_index_fn;
   jit_function logically_true_fn;
   jit_function make_range_fn;
+  jit_function paren_subsref_fn;
 
   // type id -> cast function TO that type
   std::vector<jit_function> casts;
 
   // type id -> identity function
   std::vector<llvm::Function *> identities;
 };
 
@@ -646,17 +703,18 @@ private:
   JIT_METH(break);                              \
   JIT_METH(cond_break);                         \
   JIT_METH(call);                               \
   JIT_METH(extract_argument);                   \
   JIT_METH(store_argument);                     \
   JIT_METH(phi);                                \
   JIT_METH(variable);                           \
   JIT_METH(check_error);                        \
-  JIT_METH(assign)
+  JIT_METH(assign)                              \
+  JIT_METH(argument)
 
 #define JIT_VISIT_IR_CONST                      \
   JIT_METH(const_scalar);                       \
   JIT_METH(const_index);                        \
   JIT_METH(const_string);                       \
   JIT_METH(const_range)
 
 #define JIT_VISIT_IR_CLASSES                    \
@@ -825,62 +883,62 @@ public:
   // FIXME: this code could be so much pretier with varadic templates...
   jit_instruction (void) : mid (next_id ()), mparent (0)
   {}
 
   jit_instruction (size_t nargs)
     : already_infered (nargs, reinterpret_cast<jit_type *>(0)),
       mid (next_id ()), mparent (0)
   {
-    arguments.reserve (nargs);
+    marguments.reserve (nargs);
   }
 
   jit_instruction (jit_value *arg0)
-    : already_infered (1, reinterpret_cast<jit_type *>(0)), arguments (1), 
+    : already_infered (1, reinterpret_cast<jit_type *>(0)), marguments (1), 
       mid (next_id ()), mparent (0)
   {
     stash_argument (0, arg0);
   }
 
   jit_instruction (jit_value *arg0, jit_value *arg1)
-    : already_infered (2, reinterpret_cast<jit_type *>(0)), arguments (2), 
+    : already_infered (2, reinterpret_cast<jit_type *>(0)), marguments (2), 
       mid (next_id ()), mparent (0)
   {
     stash_argument (0, arg0);
     stash_argument (1, arg1);
   }
 
   jit_instruction (jit_value *arg0, jit_value *arg1, jit_value *arg2)
-    : already_infered (3, reinterpret_cast<jit_type *>(0)), arguments (3), 
+    : already_infered (3, reinterpret_cast<jit_type *>(0)), marguments (3), 
       mid (next_id ()), mparent (0)
   {
     stash_argument (0, arg0);
     stash_argument (1, arg1);
     stash_argument (2, arg2);
   }
 
   jit_instruction (jit_value *arg0, jit_value *arg1, jit_value *arg2,
                    jit_value *arg3)
-    : already_infered (3, reinterpret_cast<jit_type *>(0)), arguments (4), 
+    : already_infered (3, reinterpret_cast<jit_type *>(0)), marguments (4), 
       mid (next_id ()), mparent (0)
   {
     stash_argument (0, arg0);
     stash_argument (1, arg1);
     stash_argument (2, arg2);
     stash_argument (3, arg3);
   }
 
   static void reset_ids (void)
   {
     next_id (true);
   }
 
   jit_value *argument (size_t i) const
   {
-    return arguments[i].value ();
+    return marguments[i].value ();
   }
 
   llvm::Value *argument_llvm (size_t i) const
   {
     assert (argument (i));
     return argument (i)->to_llvm ();
   }
 
@@ -900,42 +958,44 @@ public:
     if (argument (i))
       return argument (i)->short_print (os); 
     else
       return os << "NULL";
   }
 
   void stash_argument (size_t i, jit_value *arg)
   {
-    arguments[i].stash_value (arg, this, i);
+    marguments[i].stash_value (arg, this, i);
   }
 
   void push_argument (jit_value *arg)
   {
-    arguments.push_back (jit_use ());
-    stash_argument (arguments.size () - 1, arg);
+    marguments.push_back (jit_use ());
+    stash_argument (marguments.size () - 1, arg);
     already_infered.push_back (0);
   }
 
   size_t argument_count (void) const
   {
-    return arguments.size ();
+    return marguments.size ();
   }
 
   void resize_arguments (size_t acount, jit_value *adefault = 0)
   {
-    size_t old = arguments.size ();
-    arguments.resize (acount);
+    size_t old = marguments.size ();
+    marguments.resize (acount);
     already_infered.resize (acount);
 
     if (adefault)
       for (size_t i = old; i < acount; ++i)
         stash_argument (i, adefault);
   }
 
+  const std::vector<jit_use>& arguments (void) const { return marguments; }
+
   // argument types which have been infered already
   const std::vector<jit_type *>& argument_types (void) const
   { return already_infered; }
 
   virtual void push_variable (void) {}
 
   virtual void pop_variable (void) {}
 
@@ -969,27 +1029,47 @@ private:
   {
     static size_t ret = 0;
     if (reset)
       return ret = 0;
 
     return ret++;
   }
 
-  std::vector<jit_use> arguments;
+  std::vector<jit_use> marguments;
 
   size_t mid;
   jit_block *mparent;
   std::list<jit_instruction *>::iterator mlocation;
 };
 
 // defnie accept methods for subclasses
-#define JIT_VALUE_ACCEPT(clname)                \
+#define JIT_VALUE_ACCEPT                        \
   virtual void accept (jit_ir_walker& walker);
 
+// for use as a dummy argument during conversion to LLVM
+class
+jit_argument : public jit_value
+{
+public:
+  jit_argument (jit_type *atype, llvm::Value *avalue)
+  {
+    stash_type (atype);
+    stash_llvm (avalue);
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent);
+    return jit_print (os, type ()) << ": DUMMY";
+  }
+
+  JIT_VALUE_ACCEPT;
+};
+
 template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T,
           bool QUOTE>
 class
 jit_const : public jit_value
 {
 public:
   typedef PASS_T pass_t;
 
@@ -1007,17 +1087,17 @@ public:
     if (QUOTE)
       os << "\"";
     os << mvalue;
     if (QUOTE)
       os << "\"";
     return os;
   }
 
-  JIT_VALUE_ACCEPT (jit_const);
+  JIT_VALUE_ACCEPT;
 private:
   T mvalue;
 };
 
 class jit_phi_incomming;
 
 class
 jit_block : public jit_value, public jit_internal_list<jit_block, jit_phi_incomming>
@@ -1207,17 +1287,17 @@ public:
   llvm::BasicBlock *to_llvm (void) const;
 
   std::list<jit_block *>::iterator location (void) const
   { return mlocation; }
 
   void stash_location (std::list<jit_block *>::iterator alocation)
   { mlocation = alocation; }
 
-  JIT_VALUE_ACCEPT (block);
+  JIT_VALUE_ACCEPT;
 private:
   void internal_append (jit_instruction *instr);
 
   void compute_df (size_t visit_count);
 
   bool update_idom (size_t visit_count);
 
   void create_dom_tree (size_t visit_count);
@@ -1365,17 +1445,17 @@ public:
       }
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     return print_indent (os, indent) << mname;
   }
 
-  JIT_VALUE_ACCEPT (variable)
+  JIT_VALUE_ACCEPT;
 private:
   std::string mname;
   std::stack<jit_value *> value_stack;
   jit_instruction *mlast_use;
 };
 
 class
 jit_assign_base : public jit_instruction
@@ -1421,17 +1501,17 @@ public:
     dest ()->push (src ());
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     return print_indent (os, indent) << *dest () << " = " << *src ();
   }
 
-  JIT_VALUE_ACCEPT (assign);
+  JIT_VALUE_ACCEPT;
 private:
   jit_variable *mdest;
 };
 
 class
 jit_phi : public jit_assign_base
 {
 public:
@@ -1493,17 +1573,17 @@ public:
   {
     if (type ())
       jit_print (os, type ()) << ": ";
 
     dest ()->short_print (os);
     return os << "#" << id ();
   }
 
-  JIT_VALUE_ACCEPT (phi);
+  JIT_VALUE_ACCEPT;
 private:
   std::vector<jit_phi_incomming> mincomming;
 };
 
 class
 jit_terminator : public jit_instruction
 {
 public:
@@ -1592,17 +1672,17 @@ public:
   virtual size_t successor_count (void) const { return 1; }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "break: ";
     return print_successor (os);
   }
 
-  JIT_VALUE_ACCEPT (break)
+  JIT_VALUE_ACCEPT;
 };
 
 class
 jit_cond_break : public jit_terminator
 {
 public:
   jit_cond_break (jit_value *c, jit_block *ctrue, jit_block *cfalse)
     : jit_terminator (2, ctrue, cfalse, c) {}
@@ -1624,17 +1704,17 @@ public:
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "cond_break: ";
     print_cond (os) << ", ";
     print_successor (os, 0) << ", ";
     return print_successor (os, 1);
   }
 
-  JIT_VALUE_ACCEPT (cond_break)
+  JIT_VALUE_ACCEPT;
 };
 
 class
 jit_call : public jit_instruction
 {
 public:
   jit_call (const jit_function& afunction,
             jit_value *arg0) : jit_instruction (arg0), mfunction (afunction)
@@ -1686,17 +1766,17 @@ public:
         if (i + 1 < argument_count ())
           os << ", ";
       }
     return os << ")";
   }
 
   virtual bool infer (void);
 
-  JIT_VALUE_ACCEPT (call)
+  JIT_VALUE_ACCEPT;
 private:
   const jit_function& mfunction;
 };
 
 // FIXME: This is just ugly...
 // checks error_state, if error_state is false then goto the normal branche,
 // otherwise goto the error branch
 class
@@ -1713,17 +1793,17 @@ public:
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "error_check " << *check_for () << ", ";
     print_successor (os, 1) << ", ";
     return print_successor (os, 0);
   }
 
-  JIT_VALUE_ACCEPT (jit_check_error)
+  JIT_VALUE_ACCEPT;
 protected:
   virtual bool check_alive (size_t idx) const
   {
     return idx == 1 ? true : check_for ()->can_error ();
   }
 };
 
 class
@@ -1748,17 +1828,17 @@ public:
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
 
     return short_print (os) << " = extract " << name ();
   }
 
-  JIT_VALUE_ACCEPT (extract_argument)
+  JIT_VALUE_ACCEPT;
 };
 
 class
 jit_store_argument : public jit_instruction
 {
 public:
   jit_store_argument (jit_variable *var)
   : jit_instruction (var), dest (var)
@@ -1799,17 +1879,17 @@ public:
       {
         os << " = ";
         res->short_print (os);
       }
 
     return os;
   }
 
-  JIT_VALUE_ACCEPT (store_argument)
+  JIT_VALUE_ACCEPT;
 private:
   jit_variable *dest;
 };
 
 class
 jit_ir_walker
 {
 public:
@@ -2098,16 +2178,18 @@ private:
     void operator() (jit_block& block);
   };
 
   // this case is much simpler, just convert from the jit ir to llvm
   class
   convert_llvm : public jit_ir_walker
   {
   public:
+    convert_llvm (jit_convert& jc) : jthis (jc) {}
+
     llvm::Function *convert (llvm::Module *module,
                              const std::vector<std::pair<std::string, bool> >& args,
                              const std::list<jit_block *>& blocks,
                              const std::list<jit_value *>& constants);
 
 #define JIT_METH(clname)                        \
     virtual void visit (jit_ ## clname&);
 
@@ -2124,17 +2206,40 @@ private:
     {
       return visit (*jvalue);
     }
 
     void visit (jit_value &jvalue)
     {
       jvalue.accept (*this);
     }
+
+    llvm::Value *create_call (const jit_function::overload& ol, jit_value *arg0)
+    {
+      std::vector<jit_value *> args (1, arg0);
+      return create_call (ol, args);
+    }
+
+    llvm::Value *create_call (const jit_function::overload& ol, jit_value *arg0,
+                              jit_value *arg1)
+    {
+      std::vector<jit_value *> args (2);
+      args[0] = arg0;
+      args[1] = arg1;
+
+      return create_call (ol, args);
+    }
+
+    llvm::Value *create_call (const jit_function::overload& ol,
+                              const std::vector<jit_value *>& jargs);
+
+    llvm::Value *create_call (const jit_function::overload& ol,
+                              const std::vector<jit_use>& uses);
   private:
+    jit_convert &jthis;
     llvm::Function *function;
   };
 };
 
 class jit_info;
 
 class
 tree_jit
