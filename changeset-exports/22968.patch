# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1482868967 18000
#      Tue Dec 27 15:02:47 2016 -0500
# Node ID 7aa097a52048253b429abf07bb99f1d22048057e
# Parent  3c896180df16cd0212c337700fcc188504a35042
use F77_INT instead of octave_idx_type for libinterp eigs functions

* eiqs-base.cc: Use F77_INT instead of octave_idx_type for integer data
passed to Fortran subroutines.

diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -589,26 +589,28 @@ LuAminusSigmaB (const ComplexMatrix &m, 
     warn_convergence ();
 
   return true;
 }
 
 template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ,
-                         octave_idx_type k, octave_idx_type p,
+                         octave_idx_type k_arg, octave_idx_type p_arg,
                          octave_idx_type &info, Matrix &eig_vec,
                          ColumnVector &eig_val, const M& _b,
                          ColumnVector &permB, ColumnVector &resid,
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   M b(_b);
-  octave_idx_type n = m.cols ();
-  octave_idx_type mode = 1;
+  F77_INT n = to_f77_int (m.cols ());
+  F77_INT mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
@@ -650,17 +652,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
           if (checked(bidx) || bidx < 0 || bidx >= n
               || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
@@ -680,65 +682,69 @@ EigsRealSymmetricMatrix (const M& m, con
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
           if (permB.is_empty ())
             {
               permB = ColumnVector (n);
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb (b, bt, permB))
             (*current_liboctave_error_handler)
               ("eigs: The matrix B is not positive definite");
         }
     }
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
-  octave_idx_type lwork = p * (p + 8);
+  F77_INT lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, info
+         ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+      info = tmp_info;
+
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
@@ -758,22 +764,22 @@ EigsRealSymmetricMatrix (const M& m, con
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
                                      workd + iptr(1) - 1))
             break;
         }
       else
         {
@@ -781,27 +787,27 @@ EigsRealSymmetricMatrix (const M& m, con
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
   F77_FUNC (dseupd, DSEUPD)
@@ -812,48 +818,48 @@ EigsRealSymmetricMatrix (const M& m, con
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in dseupd");
 
   if (info2 == 0)
     {
-      octave_idx_type k2 = k / 2;
+      F77_INT k2 = k / 2;
       if (typ != "SM" && typ != "BE")
         {
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
               double dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
         }
 
       if (rvec)
         {
           if (typ != "SM" && typ != "BE")
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
-              for (octave_idx_type i = 0; i < k2; i++)
+              for (F77_INT i = 0; i < k2; i++)
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (k - i - 1) * n;
+                  F77_INT off1 = i * n;
+                  F77_INT off2 = (k - i - 1) * n;
 
                   if (off1 == off2)
                     continue;
 
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     dtmp[j] = z[off1 + j];
 
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     z[off1 + j] = z[off2 + j];
 
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     z[off2 + j] = dtmp[j];
                 }
             }
 
           if (note3)
             eig_vec = ltsolve (b, permB, eig_vec);
         }
     }
@@ -861,26 +867,28 @@ EigsRealSymmetricMatrix (const M& m, con
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
-                              octave_idx_type k, octave_idx_type p,
+                              octave_idx_type k_arg, octave_idx_type p_arg,
                               octave_idx_type &info, Matrix &eig_vec,
                               ColumnVector &eig_val, const M& _b,
                               ColumnVector &permB, ColumnVector &resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   M b(_b);
-  octave_idx_type n = m.cols ();
-  octave_idx_type mode = 3;
+  F77_INT n = to_f77_int (m.cols ());
+  F77_INT mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
@@ -925,75 +933,79 @@ EigsRealSymmetricMatrixShift (const M& m
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
           if (checked(bidx) || bidx < 0 || bidx >= n
               || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB (m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
-  octave_idx_type lwork = p * (p + 8);
+  F77_INT lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, info
+         ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+      info = tmp_info;
+
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
@@ -1020,87 +1032,87 @@ EigsRealSymmetricMatrixShift (const M& m
               if (ido == -1)
                 {
                   OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
                   vector_product (m, workd+iptr(0)-1, dtmp);
 
                   Matrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = dtmp[P[i]];
 
                   lusolve (L, U, tmp);
 
                   double *ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
               else if (ido == 2)
                 vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
               else
                 {
                   double *ip2 = workd+iptr(2)-1;
                   Matrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
 
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
           else
             {
               if (ido == 2)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     workd[iptr(0) + i - 1] = workd[iptr(1) + i - 1];
                 }
               else
                 {
                   double *ip2 = workd+iptr(0)-1;
                   Matrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
 
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
   F77_FUNC (dseupd, DSEUPD)
@@ -1111,66 +1123,69 @@ EigsRealSymmetricMatrixShift (const M& m
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in dseupd");
 
   if (info2 == 0)
     {
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           double dtmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = dtmp;
         }
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 dtmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = dtmp[j];
             }
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
-EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
+EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
                        const std::string &_typ, double sigma,
-                       octave_idx_type k, octave_idx_type p,
+                       octave_idx_type k_arg, octave_idx_type p_arg,
                        octave_idx_type &info, Matrix &eig_vec,
                        ColumnVector &eig_val, ColumnVector &resid,
                        std::ostream& os, double tol, bool rvec,
                        bool /* cholB */, int disp, int maxit)
 {
+  F77_INT n = to_f77_int (n_arg);
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
-  octave_idx_type mode = 1;
+  F77_INT mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
@@ -1221,53 +1236,57 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
-  octave_idx_type lwork = p * (p + 8);
+  F77_INT lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, info
+         ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+      info = tmp_info;
+
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
@@ -1287,126 +1306,129 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             x(i) = *ip2++;
 
           ColumnVector y = fun (x, err);
 
           if (err)
             return false;
 
           ip2 = workd + iptr(1) - 1;
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
   F77_FUNC (dseupd, DSEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+  
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in dseupd");
 
   if (info2 == 0)
     {
-      octave_idx_type k2 = k / 2;
+      F77_INT k2 = k / 2;
       if (typ != "SM" && typ != "BE")
         {
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
               double dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
         }
 
       if (rvec)
         {
           if (typ != "SM" && typ != "BE")
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
-              for (octave_idx_type i = 0; i < k2; i++)
+              for (F77_INT i = 0; i < k2; i++)
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (k - i - 1) * n;
+                  F77_INT off1 = i * n;
+                  F77_INT off2 = (k - i - 1) * n;
 
                   if (off1 == off2)
                     continue;
 
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     dtmp[j] = z[off1 + j];
 
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     z[off1 + j] = z[off2 + j];
 
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     z[off2 + j] = dtmp[j];
                 }
             }
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
-                            octave_idx_type k, octave_idx_type p,
+                            octave_idx_type k_arg, octave_idx_type p_arg,
                             octave_idx_type &info, ComplexMatrix &eig_vec,
                             ComplexColumnVector &eig_val, const M& _b,
                             ColumnVector &permB, ColumnVector &resid,
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   M b(_b);
-  octave_idx_type n = m.cols ();
-  octave_idx_type mode = 1;
+  F77_INT n = to_f77_int (m.cols ());
+  F77_INT mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
   double sigmai = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
@@ -1449,17 +1471,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
           if (checked(bidx) || bidx < 0 || bidx >= n
               || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
@@ -1479,65 +1501,69 @@ EigsRealNonSymmetricMatrix (const M& m, 
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
           if (permB.is_empty ())
             {
               permB = ColumnVector (n);
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb (b, bt, permB))
             (*current_liboctave_error_handler)
               ("eigs: The matrix B is not positive definite");
         }
     }
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
-  octave_idx_type lwork = 3 * p * (p + 2);
+  F77_INT lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, info
+         ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+      info = tmp_info;
+
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dnaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
@@ -1557,22 +1583,22 @@ EigsRealNonSymmetricMatrix (const M& m, 
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
                                      workd + iptr(1) - 1))
             break;
         }
       else
         {
@@ -1580,42 +1606,42 @@ EigsRealNonSymmetricMatrix (const M& m, 
             (*current_liboctave_error_handler)
               ("eigs: error %d in dnaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
   // Found with valgrind and
   //
   //   A = [1,0,0,-1;0,1,0,0;0,0,1,0;0,0,2,1];
   //   [vecs, vals, f] = eigs (A, 1)
 
   Matrix eig_vec2 (n, k + 1, 0.0);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
-  for (octave_idx_type i = 0; i < k+1; i++)
+  for (F77_INT i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
 
   F77_FUNC (dneupd, DNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
@@ -1624,75 +1650,75 @@ EigsRealNonSymmetricMatrix (const M& m, 
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in dneupd");
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   if (info2 == 0)
     {
-      octave_idx_type jj = 0;
-      for (octave_idx_type i = 0; i < k+1; i++)
+      F77_INT jj = 0;
+      for (F77_INT i = 0; i < k+1; i++)
         {
           if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
             jj++;
           else
             d[i-jj] = Complex (dr[i], di[i]);
         }
       if (jj == 0 && ! rvec)
-        for (octave_idx_type i = 0; i < k; i++)
+        for (F77_INT i = 0; i < k; i++)
           d[i] = d[i+1];
 
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           Complex dtmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = dtmp;
         }
       eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 dtmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = dtmp[j];
             }
 
           eig_vec.resize (n, k);
-          octave_idx_type i = 0;
+          F77_INT i = 0;
           while (i < k)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (i+1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (i+1) * n;
               if (octave::math::imag (eig_val(i)) == 0)
                 {
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     {
                       eig_vec(j,i) =
                         Complex (z[j+off1],z[j+off2]);
                       if (i < k - 1)
                         eig_vec(j,i+1) =
                           Complex (z[j+off1],-z[j+off2]);
                     }
                   i+=2;
@@ -1707,27 +1733,29 @@ EigsRealNonSymmetricMatrix (const M& m, 
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrixShift (const M& m, double sigmar,
-                                 octave_idx_type k, octave_idx_type p,
+                                 octave_idx_type k_arg, octave_idx_type p_arg,
                                  octave_idx_type &info,
                                  ComplexMatrix &eig_vec,
                                  ComplexColumnVector &eig_val, const M& _b,
                                  ColumnVector &permB, ColumnVector &resid,
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   M b(_b);
-  octave_idx_type n = m.cols ();
-  octave_idx_type mode = 3;
+  F77_INT n = to_f77_int (m.cols ());
+  F77_INT mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
   double sigmai = 0.;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
@@ -1773,75 +1801,79 @@ EigsRealNonSymmetricMatrixShift (const M
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check that we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
           if (checked(bidx) || bidx < 0 || bidx >= n
               || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB (m, b, cholB, permB, sigmar, L, U, P, Q))
     return -1;
 
-  octave_idx_type lwork = 3 * p * (p + 2);
+  F77_INT lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, info
+         ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+      info = tmp_info;
+
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
@@ -1868,102 +1900,102 @@ EigsRealNonSymmetricMatrixShift (const M
               if (ido == -1)
                 {
                   OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
                   vector_product (m, workd+iptr(0)-1, dtmp);
 
                   Matrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = dtmp[P[i]];
 
                   lusolve (L, U, tmp);
 
                   double *ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
               else if (ido == 2)
                 vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
               else
                 {
                   double *ip2 = workd+iptr(2)-1;
                   Matrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
 
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
           else
             {
               if (ido == 2)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     workd[iptr(0) + i - 1] = workd[iptr(1) + i - 1];
                 }
               else
                 {
                   double *ip2 = workd+iptr(0)-1;
                   Matrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
 
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
   // Found with valgrind and
   //
   //   A = [1,0,0,-1;0,1,0,0;0,0,1,0;0,0,2,1];
   //   [vecs, vals, f] = eigs (A, 1)
 
   Matrix eig_vec2 (n, k + 1, 0.0);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
-  for (octave_idx_type i = 0; i < k+1; i++)
+  for (F77_INT i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
 
   F77_FUNC (dneupd, DNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
@@ -1972,75 +2004,75 @@ EigsRealNonSymmetricMatrixShift (const M
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in dneupd");
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   if (info2 == 0)
     {
-      octave_idx_type jj = 0;
-      for (octave_idx_type i = 0; i < k+1; i++)
+      F77_INT jj = 0;
+      for (F77_INT i = 0; i < k+1; i++)
         {
           if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
             jj++;
           else
             d[i-jj] = Complex (dr[i], di[i]);
         }
       if (jj == 0 && ! rvec)
-        for (octave_idx_type i = 0; i < k; i++)
+        for (F77_INT i = 0; i < k; i++)
           d[i] = d[i+1];
 
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           Complex dtmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = dtmp;
         }
       eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 dtmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = dtmp[j];
             }
 
           eig_vec.resize (n, k);
-          octave_idx_type i = 0;
+          F77_INT i = 0;
           while (i < k)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (i+1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (i+1) * n;
               if (octave::math::imag (eig_val(i)) == 0)
                 {
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     {
                       eig_vec(j,i) =
                         Complex (z[j+off1],z[j+off2]);
                       if (i < k - 1)
                         eig_vec(j,i+1) =
                           Complex (z[j+off1],-z[j+off2]);
                     }
                   i+=2;
@@ -2050,29 +2082,32 @@ EigsRealNonSymmetricMatrixShift (const M
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
-EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
+EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
                           const std::string &_typ, double sigmar,
-                          octave_idx_type k, octave_idx_type p,
+                          octave_idx_type k_arg, octave_idx_type p_arg,
                           octave_idx_type &info, ComplexMatrix &eig_vec,
                           ComplexColumnVector &eig_val, ColumnVector &resid,
                           std::ostream& os, double tol, bool rvec,
                           bool /* cholB */, int disp, int maxit)
 {
+  F77_INT n = to_f77_int (n_arg);
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
-  octave_idx_type mode = 1;
+  F77_INT mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
@@ -2123,53 +2158,57 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   else if (! std::abs (sigmar))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
-  octave_idx_type lwork = 3 * p * (p + 2);
+  F77_INT lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, info
+         ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
+      info = tmp_info;
+
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dnaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
@@ -2189,65 +2228,65 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             x(i) = *ip2++;
 
           ColumnVector y = fun (x, err);
 
           if (err)
             return false;
 
           ip2 = workd + iptr(1) - 1;
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
   // Found with valgrind and
   //
   //   A = [1,0,0,-1;0,1,0,0;0,0,1,0;0,0,2,1];
   //   [vecs, vals, f] = eigs (A, 1)
 
   Matrix eig_vec2 (n, k + 1, 0.0);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
-  for (octave_idx_type i = 0; i < k+1; i++)
+  for (F77_INT i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
 
   F77_FUNC (dneupd, DNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
@@ -2256,75 +2295,75 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in dneupd");
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   if (info2 == 0)
     {
-      octave_idx_type jj = 0;
-      for (octave_idx_type i = 0; i < k+1; i++)
+      F77_INT jj = 0;
+      for (F77_INT i = 0; i < k+1; i++)
         {
           if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
             jj++;
           else
             d[i-jj] = Complex (dr[i], di[i]);
         }
       if (jj == 0 && ! rvec)
-        for (octave_idx_type i = 0; i < k; i++)
+        for (F77_INT i = 0; i < k; i++)
           d[i] = d[i+1];
 
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           Complex dtmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = dtmp;
         }
       eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 dtmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = dtmp[j];
             }
 
           eig_vec.resize (n, k);
-          octave_idx_type i = 0;
+          F77_INT i = 0;
           while (i < k)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (i+1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (i+1) * n;
               if (octave::math::imag (eig_val(i)) == 0)
                 {
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
-                  for (octave_idx_type j = 0; j < n; j++)
+                  for (F77_INT j = 0; j < n; j++)
                     {
                       eig_vec(j,i) =
                         Complex (z[j+off1],z[j+off2]);
                       if (i < k - 1)
                         eig_vec(j,i+1) =
                           Complex (z[j+off1],-z[j+off2]);
                     }
                   i+=2;
@@ -2336,27 +2375,29 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrix (const M& m, const std::string typ,
-                               octave_idx_type k, octave_idx_type p,
+                               octave_idx_type k_arg, octave_idx_type p_arg,
                                octave_idx_type &info, ComplexMatrix &eig_vec,
                                ComplexColumnVector &eig_val, const M& _b,
                                ColumnVector &permB,
                                ComplexColumnVector &cresid,
                                std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   M b(_b);
-  octave_idx_type n = m.cols ();
-  octave_idx_type mode = 1;
+  F77_INT n = to_f77_int (m.cols ());
+  F77_INT mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
@@ -2366,17 +2407,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -2402,17 +2443,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
           if (checked(bidx) || bidx < 0 || bidx >= n
               || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
@@ -2432,80 +2473,83 @@ EigsComplexNonSymmetricMatrix (const M& 
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.hermitian ();
           if (permB.is_empty ())
             {
               permB = ColumnVector (n);
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb (b, bt, permB))
             (*current_liboctave_error_handler)
               ("eigs: The matrix B is not positive definite");
         }
     }
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
-  octave_idx_type lwork = p * (3 * p + 5);
+  F77_INT lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 (typ.c_str (), 2),
          k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
          iparam, ipntr,
          F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
-         info
-         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+         tmp_info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+
+      info = tmp_info;
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
-              for (int i = 0 ; i < k; i++)
+              for (int i = 0; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
@@ -2513,20 +2557,20 @@ EigsComplexNonSymmetricMatrix (const M& 
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               ComplexMatrix mtmp (n,1);
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
 
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
                                      workd + iptr(1) - 1))
             break;
         }
       else
@@ -2535,27 +2579,27 @@ EigsComplexNonSymmetricMatrix (const M& 
             (*current_liboctave_error_handler)
               ("eigs: error %d in znaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
@@ -2572,72 +2616,74 @@ EigsComplexNonSymmetricMatrix (const M& 
      info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
       eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 ctmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
 
           if (note3)
             eig_vec = ltsolve (b, permB, eig_vec);
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
 template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const M& m, Complex sigma,
-                                    octave_idx_type k, octave_idx_type p,
+                                    octave_idx_type k_arg, octave_idx_type p_arg,
                                     octave_idx_type &info,
                                     ComplexMatrix &eig_vec,
                                     ComplexColumnVector &eig_val, const M& _b,
                                     ColumnVector &permB,
                                     ComplexColumnVector &cresid,
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   M b(_b);
-  octave_idx_type n = m.cols ();
-  octave_idx_type mode = 3;
+  F77_INT n = to_f77_int (m.cols ());
+  F77_INT mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
@@ -2650,17 +2696,17 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -2686,76 +2732,80 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check that we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
           if (checked(bidx) || bidx < 0 || bidx >= n
               || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB (m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
-  octave_idx_type lwork = p * (3 * p + 5);
+  F77_INT lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
          iparam, ipntr,
          F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
-         info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+         tmp_info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+
+      info = tmp_info;
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
@@ -2783,88 +2833,88 @@ EigsComplexNonSymmetricMatrixShift (cons
               if (ido == -1)
                 {
                   OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
                   vector_product (m, workd+iptr(0)-1, ctmp);
 
                   ComplexMatrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ctmp[P[i]];
 
                   lusolve (L, U, tmp);
 
                   Complex *ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
               else if (ido == 2)
                 vector_product (b, workd + iptr(0) - 1, workd + iptr(1) - 1);
               else
                 {
                   Complex *ip2 = workd+iptr(2)-1;
                   ComplexMatrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
 
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
           else
             {
               if (ido == 2)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     workd[iptr(0) + i - 1] =
                       workd[iptr(1) + i - 1];
                 }
               else
                 {
                   Complex *ip2 = workd+iptr(0)-1;
                   ComplexMatrix tmp(n, 1);
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
 
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
@@ -2881,79 +2931,82 @@ EigsComplexNonSymmetricMatrixShift (cons
      info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
       eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 ctmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
         }
     }
   else
     (*current_liboctave_error_handler)
       ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
-EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
+EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n_arg,
                              const std::string &_typ, Complex sigma,
-                             octave_idx_type k, octave_idx_type p,
+                             octave_idx_type k_arg, octave_idx_type p_arg,
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit)
 {
+  F77_INT n = to_f77_int (n_arg);
+  F77_INT k = to_f77_int (k_arg);
+  F77_INT p = to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (std::abs (sigma) ? true : false);
   char bmat = 'I';
-  octave_idx_type mode = 1;
+  F77_INT mode = 1;
   int err = 0;
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     (*current_liboctave_error_handler)
       ("eigs: n must be at least 3");
 
@@ -2999,54 +3052,58 @@ EigsComplexNonSymmetricFunc (EigsComplex
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (dim_vector (11, 1));
-  octave_idx_type *iparam = ip.fortran_vec ();
+  Array<F77_INT> ip (dim_vector (11, 1));
+  F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (dim_vector (14, 1));
-  octave_idx_type *ipntr = iptr.fortran_vec ();
-
-  octave_idx_type ido = 0;
+  Array<F77_INT> iptr (dim_vector (14, 1));
+  F77_INT *ipntr = iptr.fortran_vec ();
+
+  F77_INT ido = 0;
   int iter = 0;
-  octave_idx_type lwork = p * (3 * p + 5);
+  F77_INT lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
+      F77_INT tmp_info = to_f77_int (info);
+
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
          iparam, ipntr,
          F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
-         info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+         tmp_info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+
+      info = tmp_info;
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
@@ -3067,50 +3124,50 @@ EigsComplexNonSymmetricFunc (EigsComplex
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           Complex *ip2 = workd + iptr(0) - 1;
           ComplexColumnVector x(n);
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             x(i) = *ip2++;
 
           ComplexColumnVector y = fun (x, err);
 
           if (err)
             return false;
 
           ip2 = workd + iptr(1) - 1;
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
         }
     }
   while (1);
 
-  octave_idx_type info2;
+  F77_INT info2;
 
   // We have a problem in that the size of the C++ bool
   // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
-  Array<octave_idx_type> s (dim_vector (p, 1));
-  octave_idx_type *sel = s.fortran_vec ();
+  Array<F77_INT> s (dim_vector (p, 1));
+  F77_INT *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
@@ -3127,44 +3184,44 @@ EigsComplexNonSymmetricFunc (EigsComplex
      info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
-      octave_idx_type k2 = k / 2;
-      for (octave_idx_type i = 0; i < k2; i++)
+      F77_INT k2 = k / 2;
+      for (F77_INT i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
       eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
-          for (octave_idx_type i = 0; i < k2; i++)
+          for (F77_INT i = 0; i < k2; i++)
             {
-              octave_idx_type off1 = i * n;
-              octave_idx_type off2 = (k - i - 1) * n;
+              F77_INT off1 = i * n;
+              F77_INT off2 = (k - i - 1) * n;
 
               if (off1 == off2)
                 continue;
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 ctmp[j] = z[off1 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
-              for (octave_idx_type j = 0; j < n; j++)
+              for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in zneupd", info2);
 
   return ip(4);
