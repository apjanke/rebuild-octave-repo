# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1260215388 18000
#      Mon Dec 07 14:49:48 2009 -0500
# Node ID fb6b6fcafa62d836027177ab3aeddf3856db76ec
# Parent  1ddc25c3623a69d3cdd8c1930c1dc6f2ea963fac
untabify files in src/OPERATORS directory

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,25 @@
+2009-12-07  John W. Eaton  <jwe@octave.org>
+
+	* op-pm-sm.cc, op-pm-scm.cc, op-dm-sm.cc, op-dm-scm.cc,
+	op-fs-fm.cc, op-fs-fcm.cc, op-fs-fcs.cc, op-fm-fm.cc,
+	op-fm-fcs.cc, op-fm-fcm.cc, op-fcs-fs.cc, op-fcs-fm.cc,
+	op-fcs-fcm.cc, op-fcm-fs.cc, op-fcm-fm.cc, op-fm-fs.cc,
+	op-fcm-fcm.cc, op-class.cc, op-fcm-fcs.cc, op-str-str.cc,
+	op-str-s.cc, op-str-m.cc, op-struct.cc, op-sm-scm.cc, op-sm-s.cc,
+	op-sm-sm.cc, op-sm-cs.cc, op-sm-cm.cc, op-scm-sm.cc,
+	op-scm-scm.cc, op-scm-s.cc, op-scm-m.cc, op-scm-cs.cc, op-sm-m.cc,
+	op-sbm-sbm.cc, op-scm-cm.cc, op-sbm-bm.cc, op-s-sm.cc,
+	op-s-scm.cc, op-sbm-b.cc, op-m-scm.cc, op-m-sm.cc, op-m-cm.cc,
+	op-int.h, op-int-conv.cc, op-int-concat.cc, op-cs-sm.cc,
+	op-cs-scm.cc, op-cm-sm.cc, op-cs-cs.cc, op-cm-m.cc, op-cm-scm.cc,
+	op-cm-cm.cc, op-chm.cc, op-cell.cc, op-bm-sbm.cc, op-bm-bm.cc,
+	op-bm-b.cc, op-b-sbm.cc, op-fcs-fcs.cc: Untabify.
+
 2009-12-07  Jaroslav Hajek  <highegg@gmail.com>
 
 	* Makefile.am: Build OPT_HANDLERS before DEF_FILES.
 
 2009-12-06  Rik <rik@nomad.inbox5.com>
 
 	* Makefile.am: Distribute DOCSTRINGS so that documentation will not require
 	rebuild after merely untarring a distribution.
diff --git a/src/OPERATORS/op-b-sbm.cc b/src/OPERATORS/op-b-sbm.cc
--- a/src/OPERATORS/op-b-sbm.cc
+++ b/src/OPERATORS/op-b-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -45,17 +45,17 @@ DEFBINOP_FN (eq, bool, sparse_bool_matri
 DEFBINOP_FN (el_and, bool, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or, bool, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (b_sbm, bool, sparse_bool_matrix)
 {
   CAST_BINOP_ARGS (octave_bool&, const octave_sparse_bool_matrix&);
   SparseBoolMatrix tmp (1, 1, v1.bool_value ());
   return octave_value (tmp. concat (v2.sparse_bool_matrix_value (), 
-				    ra_idx));
+                                    ra_idx));
 }
 
 DEFCATOP (b_sm, bool, sparse_matrix)
 {
   CAST_BINOP_ARGS (octave_bool&, const octave_sparse_matrix&);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
@@ -84,17 +84,17 @@ install_b_sbm_ops (void)
   INSTALL_BINOP (op_el_and, octave_bool, octave_sparse_bool_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_bool, octave_sparse_bool_matrix, el_or);
 
   INSTALL_CATOP (octave_bool, octave_sparse_bool_matrix, b_sbm);
   INSTALL_CATOP (octave_bool, octave_sparse_matrix, b_sm);
   INSTALL_CATOP (octave_scalar, octave_sparse_bool_matrix, s_sbm);
 
   INSTALL_ASSIGNCONV (octave_bool, octave_sparse_bool_matrix, 
-		      octave_bool_matrix);
+                      octave_bool_matrix);
 
   INSTALL_WIDENOP (octave_bool, octave_sparse_bool_matrix, sparse_bool_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/OPERATORS/op-bm-b.cc b/src/OPERATORS/op-bm-b.cc
--- a/src/OPERATORS/op-bm-b.cc
+++ b/src/OPERATORS/op-bm-b.cc
@@ -1,11 +1,12 @@
 /*
 
-Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Cai Jianming
+Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+              Cai Jianming
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -60,18 +61,18 @@ DEFNDCATOP_FN (bm_s, bool_matrix, scalar
 DEFNDCATOP_FN (m_b, matrix, bool, array, array, concat)
 DEFNDCATOP_FN (bm_f, bool_matrix, float_scalar, float_array, float_array, concat)
 DEFNDCATOP_FN (fm_b, float_matrix, bool, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, bool_matrix, bool, bool_array, assign)
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
-			      const octave_value_list& idx,
-			      const octave_base_value& a2)
+                              const octave_value_list& idx,
+                              const octave_base_value& a2)
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
 
   // FIXME -- perhaps add a warning for this conversion if the values
   // are not all 0 or 1?
 
   boolNDArray v2 = a2.bool_array_value (true);
 
diff --git a/src/OPERATORS/op-bm-bm.cc b/src/OPERATORS/op-bm-bm.cc
--- a/src/OPERATORS/op-bm-bm.cc
+++ b/src/OPERATORS/op-bm-bm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -71,49 +71,49 @@ DEFUNOP (transpose, bool_matrix)
 }
 
 // bool matrix by bool matrix ops.
 
 DEFNDBINOP_FN (eq, bool_matrix, bool_matrix, bool_array, bool_array, mx_el_eq)
 DEFNDBINOP_FN (ne, bool_matrix, bool_matrix, bool_array, bool_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_and, bool_matrix, bool_matrix, bool_array, bool_array,
-	       mx_el_and)
+               mx_el_and)
 
 DEFNDBINOP_FN (el_or,  bool_matrix, bool_matrix, bool_array, bool_array,
-	       mx_el_or)
+               mx_el_or)
 
 DEFNDBINOP_FN (el_not_and, bool_matrix, bool_matrix, bool_array, bool_array,
-	       mx_el_not_and)
+               mx_el_not_and)
 
 DEFNDBINOP_FN (el_not_or,  bool_matrix, bool_matrix, bool_array, bool_array,
-	       mx_el_not_or)
+               mx_el_not_or)
 
 DEFNDBINOP_FN (el_and_not, bool_matrix, bool_matrix, bool_array, bool_array,
-	       mx_el_and_not)
+               mx_el_and_not)
 
 DEFNDBINOP_FN (el_or_not,  bool_matrix, bool_matrix, bool_array, bool_array,
-	       mx_el_or_not)
+               mx_el_or_not)
 
 DEFNDCATOP_FN (bm_bm, bool_matrix, bool_matrix, bool_array, bool_array, concat)
 DEFNDCATOP_FN (bm_m, bool_matrix, matrix, array, array, concat)
 DEFNDCATOP_FN (m_bm, matrix, bool_matrix, array, array, concat)
 DEFNDCATOP_FN (bm_fm, bool_matrix, float_matrix, float_array, float_array, concat)
 DEFNDCATOP_FN (fm_bm, float_matrix, bool_matrix, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, bool_matrix, bool_matrix, bool_array, assign)
 DEFNDASSIGNOP_FNOP (assign_and, bool_matrix, bool_matrix, bool_array, mx_el_and_assign)
 DEFNDASSIGNOP_FNOP (assign_or, bool_matrix, bool_matrix, bool_array, mx_el_or_assign)
 
 DEFNULLASSIGNOP_FN (null_assign, bool_matrix, delete_elements)
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
-			      const octave_value_list& idx,
-			      const octave_base_value& a2)
+                              const octave_value_list& idx,
+                              const octave_base_value& a2)
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
 
   // FIXME -- perhaps add a warning for this conversion if the values
   // are not all 0 or 1?
 
   boolNDArray v2 = a2.bool_array_value (true);
 
diff --git a/src/OPERATORS/op-bm-sbm.cc b/src/OPERATORS/op-bm-sbm.cc
--- a/src/OPERATORS/op-bm-sbm.cc
+++ b/src/OPERATORS/op-bm-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -47,17 +47,17 @@ DEFBINOP_FN (ne, bool_matrix, sparse_boo
 DEFBINOP_FN (el_and, bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  bool_matrix, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (bm_sbm, bool_matrix, sparse_bool_matrix)
 {
   CAST_BINOP_ARGS (octave_bool_matrix&, const octave_sparse_bool_matrix&);
   SparseBoolMatrix tmp (v1.bool_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_bool_matrix_value (), 
-				    ra_idx));
+                                    ra_idx));
 }
 
 DEFCATOP (m_sbm, matrix, sparse_bool_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_bool_matrix&);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
@@ -80,30 +80,30 @@ DEFNDASSIGNOP_FN (assign, bool_matrix, s
 
 void
 install_bm_sbm_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_bool_matrix, octave_sparse_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_bool_matrix, octave_sparse_bool_matrix, ne);
 
   INSTALL_BINOP (op_el_and, octave_bool_matrix, octave_sparse_bool_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_bool_matrix, octave_sparse_bool_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_bool_matrix, octave_sparse_bool_matrix, bm_sbm);
   INSTALL_CATOP (octave_bool_matrix, octave_sparse_matrix, bm_sm);
   INSTALL_CATOP (octave_matrix, octave_sparse_bool_matrix, m_sbm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_sparse_bool_matrix, 
-		    assign)
+                    assign)
   INSTALL_ASSIGNCONV (octave_bool_matrix, octave_sparse_bool_matrix, 
-		      octave_bool_matrix);
+                      octave_bool_matrix);
 
   INSTALL_WIDENOP (octave_bool_matrix, octave_sparse_bool_matrix, 
-		   sparse_bool_matrix_conv);
+                   sparse_bool_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cell.cc b/src/OPERATORS/op-cell.cc
--- a/src/OPERATORS/op-cell.cc
+++ b/src/OPERATORS/op-cell.cc
@@ -1,11 +1,12 @@
 /*
 
-Copyright (C) 1996, 1997, 2002, 2003, 2004, 2005, 2007, 2008 John W. Eaton
+Copyright (C) 1996, 1997, 2002, 2003, 2004, 2005, 2007, 2008, 2009
+              John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -48,32 +49,32 @@ DEFUNOP (transpose, cell)
   else
     return octave_value (Cell (v.cell_value().transpose ()));
 }
 
 DEFCATOP_FN (c_c, cell, cell, concat)
 
 static octave_value
 oct_catop_cell_matrix (octave_base_value& a1, const octave_base_value& a2,
-			 const Array<octave_idx_type>&)
+                         const Array<octave_idx_type>&)
 {
   octave_value retval;
   CAST_BINOP_ARGS (const octave_cell&, const octave_matrix&);
   NDArray tmp = v2.array_value ();
   dim_vector dv = tmp.dims ();
   if (dv.all_zero ())
     retval = octave_value (v1.cell_value ());
   else
     error ("invalid concatenation of cell array with matrix");
   return retval;
 }
 
 static octave_value
 oct_catop_matrix_cell (octave_base_value& a1, const octave_base_value& a2,
-			 const Array<octave_idx_type>&)
+                         const Array<octave_idx_type>&)
 {
   octave_value retval;
   CAST_BINOP_ARGS (const octave_matrix&, const octave_cell&);
   NDArray tmp = v1.array_value ();
   dim_vector dv = tmp.dims ();
   if (dv.all_zero ())
     retval = octave_value (v2.cell_value ());
   else
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996, 1997, 1998, 2000, 2002, 2004, 2005, 2006, 2007
+Copyright (C) 1996, 1997, 1998, 2000, 2002, 2004, 2005, 2006, 2007, 2009
               John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -41,60 +41,60 @@ along with Octave; see the file COPYING.
 DEFUNOP (transpose, char_matrix)
 {
   CAST_UNOP_ARG (const octave_char_matrix&);
 
   return octave_value (v.matrix_value().transpose ());
 }
 
 DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array, 
-	       concat)
+               concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
-			     v2.type_name (), v1.type_name ());
+                             v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat(v2.array_value (),
-			       ra_idx));
+                               ra_idx));
 }
 
 DEFCATOP (chm_m, char_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_matrix&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
-			     v2.type_name (), v1.type_name ());
+                             v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
-			       ra_idx));
+                               ra_idx));
 }
 
 DEFCATOP (s_chm, scalar, char_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
-			     v1.type_name (), v2.type_name ());
+                             v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
-			       ra_idx));
+                               ra_idx));
 }
 
 DEFCATOP (m_chm, matrix, char_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
-			     v1.type_name (), v2.type_name ());
+                             v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
-			       ra_idx));
+                               ra_idx));
 }
 
 void
 install_chm_ops (void)
 {
   INSTALL_UNOP (op_transpose, octave_char_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_char_matrix, transpose);
 
diff --git a/src/OPERATORS/op-class.cc b/src/OPERATORS/op-class.cc
--- a/src/OPERATORS/op-class.cc
+++ b/src/OPERATORS/op-class.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007, 2008 John W. Eaton
+Copyright (C) 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -45,24 +45,24 @@ along with Octave; see the file COPYING.
     octave_value retval; \
  \
     std::string class_name = a.class_name (); \
  \
     octave_value meth = symbol_table::find_method (#name, class_name); \
  \
     if (meth.is_defined ()) \
       { \
-	octave_value_list args; \
+        octave_value_list args; \
  \
-	args(0) = a; \
+        args(0) = a; \
  \
-	octave_value_list tmp = feval (meth.function_value (), args, 1); \
+        octave_value_list tmp = feval (meth.function_value (), args, 1); \
  \
-	if (tmp.length () > 0) \
-	  retval = tmp(0); \
+        if (tmp.length () > 0) \
+          retval = tmp(0); \
       } \
     else \
       error ("%s method not defined for %s class", \
              #name, class_name.c_str ()); \
  \
     return retval; \
   }
 
@@ -82,25 +82,25 @@ DEF_CLASS_UNOP (ctranspose)
  \
     std::string dispatch_type \
       = a1.is_object () ? a1.class_name () : a2.class_name (); \
  \
     octave_value meth = symbol_table::find_method (#name, dispatch_type); \
  \
     if (meth.is_defined ()) \
       { \
-	octave_value_list args; \
+        octave_value_list args; \
  \
-	args(1) = a2; \
-	args(0) = a1; \
+        args(1) = a2; \
+        args(0) = a1; \
  \
-	octave_value_list tmp = feval (meth.function_value (), args, 1); \
+        octave_value_list tmp = feval (meth.function_value (), args, 1); \
  \
-	if (tmp.length () > 0) \
-	  retval = tmp(0); \
+        if (tmp.length () > 0) \
+          retval = tmp(0); \
       } \
     else \
       error ("%s method not defined for %s class", \
              #name, dispatch_type.c_str ()); \
  \
     return retval; \
   }
 
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -80,17 +80,17 @@ DEFNDBINOP_OP (sub, complex_matrix, comp
 DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-			    v2.complex_matrix_value (), typ);
+                            v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -98,17 +98,17 @@ DEFBINOPX (pow, complex_matrix, complex_
 }
 
 DEFBINOP (ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
-				v2.complex_matrix_value (), typ);
+                                v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
@@ -142,29 +142,29 @@ DEFBINOP (mul_herm, complex_matrix, comp
 }
 
 DEFBINOP (trans_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
-				v2.complex_matrix_value (), typ, blas_trans);
+                                v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
-				v2.complex_matrix_value (), typ, blas_conj_trans);
+                                v2.complex_matrix_value (), typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_eq)
@@ -252,16 +252,16 @@ install_cm_cm_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_complex_matrix, octave_complex_matrix, assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_complex_matrix, octave_complex_matrix, assign_el_div);
 
   INSTALL_CONVOP (octave_complex_matrix, octave_float_complex_matrix, 
-		  complex_matrix_to_float_complex_matrix);
+                  complex_matrix_to_float_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cm-m.cc b/src/OPERATORS/op-cm-m.cc
--- a/src/OPERATORS/op-cm-m.cc
+++ b/src/OPERATORS/op-cm-m.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007 John W. Eaton
+              2007, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -59,17 +59,17 @@ DEFBINOP (mul_trans, complex_matrix, mat
 }
 
 DEFBINOP (div, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-			    v2.matrix_value (), typ);
+                            v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 
 DEFBINOPX (pow, complex_matrix, matrix)
 {
@@ -78,17 +78,17 @@ DEFBINOPX (pow, complex_matrix, matrix)
 }
 
 DEFBINOP (ldiv, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
-				v2.matrix_value (), typ);
+                                v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex_matrix, matrix, complex_array, array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex_matrix, matrix, complex_array, array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, complex_matrix, matrix, complex_array, array, mx_el_eq)
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -44,53 +44,53 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-				v2.sparse_complex_matrix_value (), typ);
+                                v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
-				v2.complex_matrix_value (), typ);
+                                v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (mul_trans, complex_matrix, sparse_complex_matrix, mul_trans);
 DEFBINOP_FN (mul_herm, complex_matrix, sparse_complex_matrix, mul_herm);
 
@@ -102,108 +102,108 @@ DEFBINOP_FN (gt, complex_matrix, sparse_
 DEFBINOP_FN (ne, complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   
   return octave_value 
     (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
-		v2.sparse_complex_matrix_value ()));
+                v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (), 
-				 v1.complex_matrix_value ()));
+                                 v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cm_scm, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   SparseComplexMatrix tmp (v1.complex_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (), 
-				    ra_idx));
+                                    ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex_matrix, 
-	 sparse_complex_matrix)
+         sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_matrix&);
   return new octave_sparse_complex_matrix 
     (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix, 
-		  complex_array, assign)
+                  complex_array, assign)
 
 void
 install_cm_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, add);
+                 octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, sub);
+                 octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, mul);
+                 octave_sparse_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, div);
+                 octave_sparse_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, pow);
+                 octave_sparse_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, ldiv);
+                 octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP (op_mul_trans, octave_complex_matrix, 
                  octave_sparse_complex_matrix, mul_trans);
   INSTALL_BINOP (op_mul_herm, octave_complex_matrix, 
                  octave_sparse_complex_matrix, mul_herm);
   INSTALL_BINOP (op_lt, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, lt);
+                 octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, le);
+                 octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, eq);
+                 octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, ge);
+                 octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, gt);
+                 octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, ne);
+                 octave_sparse_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, el_mul);
+                 octave_sparse_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, el_div);
+                 octave_sparse_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, el_pow);
+                 octave_sparse_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, el_ldiv);
+                 octave_sparse_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, el_and);
+                 octave_sparse_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, 
-		 octave_sparse_complex_matrix, el_or);
+                 octave_sparse_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_complex_matrix, 
-		 octave_sparse_complex_matrix, cm_scm);
+                 octave_sparse_complex_matrix, cm_scm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
-		    octave_sparse_complex_matrix, assign)
+                    octave_sparse_complex_matrix, assign)
   INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_complex_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex_matrix, octave_sparse_complex_matrix, 
-		   sparse_complex_matrix_conv);
+                   sparse_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -50,46 +50,46 @@ DEFBINOP (div, complex_matrix, sparse_ma
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
   
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-				v2.sparse_matrix_value (), typ);
+                                v2.sparse_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_matrix&);
+                   const octave_sparse_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
-				v2.matrix_value (), typ);
+                                v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, complex_matrix, sparse_matrix, mx_el_eq)
@@ -98,27 +98,27 @@ DEFBINOP_FN (gt, complex_matrix, sparse_
 DEFBINOP_FN (ne, complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_matrix&);
+                   const octave_sparse_matrix&);
   
   return octave_value 
     (elem_xpow ( SparseComplexMatrix (v1.complex_matrix_value ()),
-		 v2.sparse_matrix_value ()));
+                 v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_matrix&);
+                   const octave_sparse_matrix&);
   return octave_value
     (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (cm_sm, complex_matrix, sparse_matrix)
@@ -141,34 +141,34 @@ install_cm_sm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_complex_matrix, octave_sparse_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_complex_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex_matrix, octave_sparse_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_complex_matrix, octave_sparse_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_complex_matrix, octave_sparse_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_sparse_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_sparse_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_sparse_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_sparse_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_sparse_matrix, cm_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_sparse_matrix, 
-		    assign);
+                    assign);
   INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_matrix, 
-		      octave_complex_matrix)
+                      octave_complex_matrix)
 
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cs-cs.cc b/src/OPERATORS/op-cs-cs.cc
--- a/src/OPERATORS/op-cs-cs.cc
+++ b/src/OPERATORS/op-cs-cs.cc
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007, 2008
-              John W. Eaton
+Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007,
+              2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -189,16 +189,16 @@ install_cs_cs_ops (void)
 
   INSTALL_ASSIGNCONV (octave_complex, octave_complex, octave_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_null_matrix, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_str, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_sq_str, octave_complex_matrix);
 
   INSTALL_CONVOP (octave_complex, octave_float_complex_matrix, 
-		  complex_to_float_complex);
+                  complex_to_float_complex);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -48,17 +48,17 @@ DEFBINOP (div, complex, sparse_complex_m
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
       SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
@@ -66,17 +66,17 @@ DEFBINOP (div, complex, sparse_complex_m
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   return xpow (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
   Complex d = v1.complex_value ();
@@ -117,17 +117,17 @@ DEFBINOP (el_ldiv, complex, sparse_compl
 DEFBINOP_FN (el_and, complex, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cs_scm, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (octave_complex&, const octave_sparse_complex_matrix&);
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (), 
-				    ra_idx));
+                                    ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_sparse_complex_matrix 
     (SparseComplexMatrix (v.complex_matrix_value ()));
@@ -137,42 +137,42 @@ void
 install_cs_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex, octave_sparse_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_complex, octave_sparse_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_complex, octave_sparse_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_complex, octave_sparse_complex_matrix, 
-		 ldiv);
+                 ldiv);
   INSTALL_BINOP (op_lt, octave_complex, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex, octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex, octave_sparse_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_complex, octave_sparse_complex_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_complex, octave_sparse_complex_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_complex, octave_sparse_complex_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_sparse_complex_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_sparse_complex_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_sparse_complex_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_complex, octave_sparse_complex_matrix, cs_scm);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_sparse_complex_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex, octave_sparse_complex_matrix, 
-		   sparse_complex_matrix_conv);
+                   sparse_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -50,17 +50,17 @@ DEFBINOP (div, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
       SparseMatrix m2 = v2.sparse_matrix_value ();
@@ -155,17 +155,17 @@ install_cs_sm_ops (void)
   INSTALL_BINOP (op_el_pow, octave_complex, octave_sparse_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_sparse_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_sparse_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_sparse_matrix, el_or);
 
   INSTALL_CATOP (octave_complex, octave_sparse_matrix, cs_sm);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_sparse_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex, octave_sparse_matrix, sparse_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/OPERATORS/op-dm-scm.cc b/src/OPERATORS/op-dm-scm.cc
--- a/src/OPERATORS/op-dm-scm.cc
+++ b/src/OPERATORS/op-dm-scm.cc
@@ -106,41 +106,41 @@ DEFBINOP (mul_cdm_scm, complex_diag_matr
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (ldiv_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&,
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.diag_matrix_value (), v2.sparse_complex_matrix_value (),
-		   typ);
+                   typ);
 }
 
 DEFBINOP (ldiv_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-		   const octave_sparse_matrix&);
+                   const octave_sparse_matrix&);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_matrix_value (),
-		   typ);
+                   typ);
 }
 
 DEFBINOP (ldiv_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_complex_matrix_value (),
-		   typ);
+                   typ);
 }
 
 DEFBINOP (add_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
@@ -316,17 +316,17 @@ DEFBINOP (div_scm_dm, sparse_complex_mat
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (), v2.diag_matrix_value (), typ);
     }
@@ -336,17 +336,17 @@ DEFBINOP (div_sm_cdm, sparse_matrix, com
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (), v2.complex_diag_matrix_value (), typ);
     }
@@ -356,17 +356,17 @@ DEFBINOP (div_scm_cdm, sparse_complex_ma
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (), v2.complex_diag_matrix_value (), typ);
     }
@@ -467,41 +467,41 @@ DEFBINOP (sub_scm_cdm, sparse_complex_ma
   else
     return v1.sparse_complex_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 void
 install_dm_scm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_diag_matrix, octave_sparse_complex_matrix,
-		 mul_dm_scm);
+                 mul_dm_scm);
   INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_sparse_matrix,
-		 mul_cdm_sm);
+                 mul_cdm_sm);
   INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-		 mul_cdm_scm);
+                 mul_cdm_scm);
   INSTALL_BINOP (op_ldiv, octave_diag_matrix, octave_sparse_complex_matrix, ldiv_dm_scm);
   INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_sparse_matrix, ldiv_cdm_sm);
   INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-		 ldiv_cdm_scm);
+                 ldiv_cdm_scm);
 
   INSTALL_BINOP (op_add, octave_diag_matrix, octave_sparse_complex_matrix, add_dm_scm);
   INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_sparse_matrix, add_cdm_sm);
   INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-		 add_cdm_scm);
+                 add_cdm_scm);
   INSTALL_BINOP (op_sub, octave_diag_matrix, octave_sparse_complex_matrix, sub_dm_scm);
   INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_sparse_matrix, sub_cdm_sm);
   INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-		 sub_cdm_scm);
+                 sub_cdm_scm);
 
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_diag_matrix,
-		 mul_scm_dm);
+                 mul_scm_dm);
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_complex_diag_matrix,
-		 mul_sm_cdm);
+                 mul_sm_cdm);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_complex_diag_matrix,
-		 mul_scm_cdm);
+                 mul_scm_cdm);
 
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_diag_matrix, div_scm_dm);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_complex_diag_matrix, div_sm_cdm);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_complex_diag_matrix, div_scm_cdm);
 
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_diag_matrix, add_scm_dm);
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_complex_diag_matrix, add_sm_cdm);
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_complex_diag_matrix, add_scm_cdm);
diff --git a/src/OPERATORS/op-dm-sm.cc b/src/OPERATORS/op-dm-sm.cc
--- a/src/OPERATORS/op-dm-sm.cc
+++ b/src/OPERATORS/op-dm-sm.cc
@@ -129,17 +129,17 @@ DEFBINOP (div_sm_dm, sparse_matrix, diag
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (), v2.diag_matrix_value (), typ);
     }
@@ -176,21 +176,21 @@ DEFBINOP (sub_sm_dm, sparse_matrix, diag
   else
     return v1.sparse_matrix_value () - v2.diag_matrix_value ();
 }
 
 void
 install_dm_sm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_diag_matrix, octave_sparse_matrix,
-		 mul_dm_sm);
+                 mul_dm_sm);
 
   INSTALL_BINOP (op_add, octave_diag_matrix, octave_sparse_matrix, add_dm_sm);
   INSTALL_BINOP (op_sub, octave_diag_matrix, octave_sparse_matrix, sub_dm_sm);
   INSTALL_BINOP (op_ldiv, octave_diag_matrix, octave_sparse_matrix, ldiv_dm_sm);
 
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_diag_matrix,
-		 mul_sm_dm);
+                 mul_sm_dm);
 
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_diag_matrix, add_sm_dm);
   INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_diag_matrix, sub_sm_dm);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_diag_matrix, div_sm_dm);
 }
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -70,49 +70,49 @@ DEFUNOP (hermitian, float_complex_matrix
 
 DEFNCUNOP_METHOD (incr, float_complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, float_complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, float_complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
 DEFNDBINOP_OP (add, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, +)
+               float_complex_array, float_complex_array, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, -)
+               float_complex_array, float_complex_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_complex_matrix, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (), 
-			    v2.float_complex_matrix_value (), typ);
+                            v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
-				     v2.float_complex_matrix_value (), typ);
+                                     v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
@@ -143,85 +143,85 @@ DEFBINOP (mul_herm, float_complex_matrix
   return octave_value(xgemm (v1.float_complex_matrix_value (), 
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
-				     v2.float_complex_matrix_value (), typ, blas_trans);
+                                     v2.float_complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
-				     v2.float_complex_matrix_value (), typ, blas_conj_trans);
+                                     v2.float_complex_matrix_value (), typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_lt)
+               float_complex_array, float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_le)
+               float_complex_array, float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_eq)
+               float_complex_array, float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_ge)
+               float_complex_array, float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_gt)
+               float_complex_array, float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_ne)
+               float_complex_array, float_complex_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, product)
+               float_complex_array, float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, quotient)
+               float_complex_array, float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, elem_xpow)
+               float_complex_array, float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
 
   return octave_value (quotient (v2.float_complex_array_value (), v1.float_complex_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_and)
+               float_complex_array, float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, mx_el_or)
+               float_complex_array, float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fcm, float_complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, concat)
+               float_complex_array, float_complex_array, concat)
 
 DEFNDCATOP_FN (cm_fcm, complex_matrix, float_complex_matrix, 
-	       float_complex_array, float_complex_array, concat)
+               float_complex_array, float_complex_array, concat)
 
 DEFNDCATOP_FN (fcm_cm, float_complex_matrix, complex_matrix, 
-	       float_complex_array, float_complex_array, concat)
+               float_complex_array, float_complex_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex_matrix, 
-		  float_complex_array, assign)
+                  float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, float_complex_matrix, complex_matrix, 
-		  float_complex_array, assign)
+                  float_complex_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, float_complex_matrix, delete_elements)
 
 DEFNDASSIGNOP_OP (assign_add, float_complex_matrix, 
                   float_complex_matrix, float_complex_array, +=)
 DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix, 
                   float_complex_matrix, float_complex_array, -=)
 DEFNDASSIGNOP_FNOP (assign_el_mul, float_complex_matrix, float_complex_matrix,
@@ -245,76 +245,76 @@ install_fcm_fcm_ops (void)
   INSTALL_UNOP (op_transpose, octave_float_complex_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_float_complex_matrix, hermitian);
 
   INSTALL_NCUNOP (op_incr, octave_float_complex_matrix, incr);
   INSTALL_NCUNOP (op_decr, octave_float_complex_matrix, decr);
   INSTALL_NCUNOP (op_uminus, octave_float_complex_matrix, changesign);
 
   INSTALL_BINOP (op_add, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, add);
+                 octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, sub);
+                 octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, mul);
+                 octave_float_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, div);
+                 octave_float_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, pow);
+                 octave_float_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, ldiv);
+                 octave_float_complex_matrix, ldiv);
   INSTALL_BINOP (op_trans_mul, octave_float_complex_matrix, 
                  octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix, 
                  octave_float_complex_matrix, mul_trans);
   INSTALL_BINOP (op_herm_mul, octave_float_complex_matrix, 
                  octave_float_complex_matrix, herm_mul);
   INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix, 
                  octave_float_complex_matrix, mul_herm);
   INSTALL_BINOP (op_trans_ldiv, octave_float_complex_matrix, 
                  octave_float_complex_matrix, trans_ldiv);
   INSTALL_BINOP (op_herm_ldiv, octave_float_complex_matrix, 
                  octave_float_complex_matrix, herm_ldiv);
 
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, lt);
+                 octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, le);
+                 octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, eq);
+                 octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, ge);
+                 octave_float_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, gt);
+                 octave_float_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, ne);
+                 octave_float_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, el_mul);
+                 octave_float_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, el_div);
+                 octave_float_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, el_pow);
+                 octave_float_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, el_ldiv);
+                 octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, el_and);
+                 octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
-		 octave_float_complex_matrix, el_or);
+                 octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, 
-		 octave_float_complex_matrix, fcm_fcm);
+                 octave_float_complex_matrix, fcm_fcm);
   INSTALL_CATOP (octave_complex_matrix, 
-		 octave_float_complex_matrix, cm_fcm);
+                 octave_float_complex_matrix, cm_fcm);
   INSTALL_CATOP (octave_float_complex_matrix, 
-		 octave_complex_matrix, fcm_cm);
+                 octave_complex_matrix, fcm_cm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
-		    octave_float_complex_matrix, assign);
+                    octave_float_complex_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
-		    octave_complex_matrix, dbl_assign);
+                    octave_complex_matrix, dbl_assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
                     octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
                     octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
                     octave_null_sq_str, null_assign);
 
@@ -323,16 +323,16 @@ install_fcm_fcm_ops (void)
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_el_div);
 
   INSTALL_CONVOP (octave_float_complex_matrix, octave_complex_matrix, 
-		  float_complex_matrix_to_complex_matrix);
+                  float_complex_matrix_to_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcm-fcs.cc b/src/OPERATORS/op-fcm-fcs.cc
--- a/src/OPERATORS/op-fcm-fcs.cc
+++ b/src/OPERATORS/op-fcm-fcs.cc
@@ -35,161 +35,161 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, +)
+               float_complex_array, float_complex, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, -)
+               float_complex_array, float_complex, -)
 DEFNDBINOP_OP (mul, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, *)
+               float_complex_array, float_complex, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex&);
+                   const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex&);
+                   const octave_float_complex&);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_lt)
+               float_complex_array, float_complex, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_le)
+               float_complex_array, float_complex, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_eq)
+               float_complex_array, float_complex, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_ge)
+               float_complex_array, float_complex, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_gt)
+               float_complex_array, float_complex, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_ne)
+               float_complex_array, float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, *)
+               float_complex_array, float_complex, *)
 
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex&);
+                   const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, elem_xpow)
+               float_complex_array, float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_complex&);
+                   const octave_float_complex&);
 
   return x_el_div (v2.float_complex_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_and)
+               float_complex_array, float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex, mx_el_or)
+               float_complex_array, float_complex, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fcs, float_complex_matrix, float_complex, 
-	       float_complex_array, float_complex_array, concat)
+               float_complex_array, float_complex_array, concat)
 
 DEFNDCATOP_FN (cm_fcs, complex_matrix, float_complex, 
-	       float_complex_array, float_complex_array, concat)
+               float_complex_array, float_complex_array, concat)
 
 DEFNDCATOP_FN (fcm_cs, float_complex_matrix, complex, 
-	       float_complex_array, float_complex_array, concat)
+               float_complex_array, float_complex_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex, 
-		  float_complex, assign)
+                  float_complex, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_complex, 
-		  complex, assign)
+                  complex, assign)
 
 DEFNDASSIGNOP_OP (assign_add, float_complex_matrix, float_complex_scalar,
                   float_complex, +=)
 DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix, float_complex_scalar,
                   float_complex, -=)
 DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_complex_scalar,
                   float_complex, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_complex_scalar,
                   float_complex, /=)
 
 void
 install_fcm_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, 
-		 octave_float_complex, add);
+                 octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, 
-		 octave_float_complex, sub);
+                 octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, 
-		 octave_float_complex, mul);
+                 octave_float_complex, mul);
   INSTALL_BINOP (op_div, octave_float_complex_matrix, 
-		 octave_float_complex, div);
+                 octave_float_complex, div);
   INSTALL_BINOP (op_pow, octave_float_complex_matrix, 
-		 octave_float_complex, pow);
+                 octave_float_complex, pow);
   INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, 
-		 octave_float_complex, ldiv);
+                 octave_float_complex, ldiv);
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, octave_float_complex, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, octave_float_complex, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, octave_float_complex, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, octave_float_complex, ge);
   INSTALL_BINOP (op_gt, octave_float_complex_matrix, octave_float_complex, gt);
   INSTALL_BINOP (op_ne, octave_float_complex_matrix, octave_float_complex, ne);
   INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, 
-		 octave_float_complex, el_mul);
+                 octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex_matrix, 
-		 octave_float_complex, el_div);
+                 octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, 
-		 octave_float_complex, el_pow);
+                 octave_float_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
-		 octave_float_complex, el_ldiv);
+                 octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
-		 octave_float_complex, el_and);
+                 octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
-		 octave_float_complex, el_or);
+                 octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_complex, fcm_fcs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_complex, cm_fcs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_complex, fcm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
-		    octave_float_complex, assign);
+                    octave_float_complex, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
-		    octave_float_complex, dbl_assign);
+                    octave_float_complex, dbl_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
diff --git a/src/OPERATORS/op-fcm-fm.cc b/src/OPERATORS/op-fcm-fm.cc
--- a/src/OPERATORS/op-fcm-fm.cc
+++ b/src/OPERATORS/op-fcm-fm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -58,133 +58,133 @@ DEFBINOP (mul_trans, float_complex_matri
 
   return FloatComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                              xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, float_complex_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_matrix&);
+                   const octave_float_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (), 
-				 v2.float_matrix_value (), typ);
+                                 v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 
 DEFBINOPX (pow, float_complex_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_matrix&);
+                   const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
-				     v2.float_matrix_value (), typ);
+                                     v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_lt)
+               float_complex_array, float_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_le)
+               float_complex_array, float_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_eq)
+               float_complex_array, float_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_ge)
+               float_complex_array, float_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_gt)
+               float_complex_array, float_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_ne)
+               float_complex_array, float_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, product)
+               float_complex_array, float_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, quotient)
+               float_complex_array, float_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, elem_xpow)
+               float_complex_array, float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
-		   const octave_float_matrix&);
+                   const octave_float_matrix&);
 
   return quotient (v2.float_array_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_and)
+               float_complex_array, float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, mx_el_or)
+               float_complex_array, float_array, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fm, float_complex_matrix, float_matrix, 
-	       float_complex_array, float_array, concat)
+               float_complex_array, float_array, concat)
 
 DEFNDCATOP_FN (cm_fm, complex_matrix, float_matrix, 
-	       float_complex_array, float_array, concat)
+               float_complex_array, float_array, concat)
 
 DEFNDCATOP_FN (fcm_m, float_complex_matrix, matrix, 
-	       float_complex_array, float_array, concat)
+               float_complex_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_matrix, 
-		  float_complex_array, assign)
+                  float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_matrix, 
-		  complex_array, assign)
+                  complex_array, assign)
 
 void
 install_fcm_fm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, octave_float_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, octave_float_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, octave_float_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_complex_matrix, octave_float_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_complex_matrix, octave_float_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, 
-		 octave_float_matrix, ldiv);
+                 octave_float_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, octave_float_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, octave_float_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, octave_float_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, octave_float_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_complex_matrix, octave_float_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_complex_matrix, octave_float_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, 
-		 octave_float_matrix, el_mul);
+                 octave_float_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex_matrix, 
-		 octave_float_matrix, el_div);
+                 octave_float_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, 
-		 octave_float_matrix, el_pow);
+                 octave_float_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
-		 octave_float_matrix, el_ldiv);
+                 octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
-		 octave_float_matrix, el_and);
+                 octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
-		 octave_float_matrix, el_or);
+                 octave_float_matrix, el_or);
   INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix, 
                  octave_float_matrix, mul_trans);
   INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix, 
                  octave_float_matrix, mul_trans);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_matrix, fcm_fm);
   INSTALL_CATOP (octave_complex_matrix, octave_float_matrix, cm_fm);
   INSTALL_CATOP (octave_float_complex_matrix, octave_matrix, fcm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
-		    octave_float_matrix, assign);
+                    octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
-		    octave_float_matrix, dbl_assign);
+                    octave_float_matrix, dbl_assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcm-fs.cc b/src/OPERATORS/op-fcm-fs.cc
--- a/src/OPERATORS/op-fcm-fs.cc
+++ b/src/OPERATORS/op-fcm-fs.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -71,66 +71,66 @@ DEFBINOP (ldiv, float_complex_matrix, fl
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_lt)
+               float_scalar, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_le)
+               float_scalar, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_eq)
+               float_scalar, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_ge)
+               float_scalar, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_gt)
+               float_scalar, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_ne)
+               float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, *)
+               float_scalar, *)
 
 DEFBINOP (el_div, float_complex_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, elem_xpow)
+               float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
 
   return x_el_div (v2.float_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_and)
+               float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array, 
-	       float_scalar, mx_el_or)
+               float_scalar, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fs, float_complex_matrix, float_scalar, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (cm_fs, complex_matrix, float_scalar, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (fcm_s, float_complex_matrix, scalar, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_scalar, float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_scalar, complex_array, assign)
 
 DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_scalar,
                   float_scalar, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_scalar,
                   float_scalar, /=)
@@ -157,19 +157,19 @@ install_fcm_fs_ops (void)
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_scalar, fcm_fs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_scalar, cm_fs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_scalar, fcm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
-		    octave_float_scalar, assign);
+                    octave_float_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
-		    octave_float_scalar, dbl_assign);
+                    octave_float_scalar, dbl_assign);
 
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign_div);
 }
 
 /*
diff --git a/src/OPERATORS/op-fcs-fcm.cc b/src/OPERATORS/op-fcs-fcm.cc
--- a/src/OPERATORS/op-fcs-fcm.cc
+++ b/src/OPERATORS/op-fcs-fcm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -67,34 +67,34 @@ DEFBINOP (ldiv, float_complex, float_com
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, mx_el_lt)
+               float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, mx_el_le)
+               float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, mx_el_eq)
+               float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, mx_el_ge)
+               float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, mx_el_gt)
+               float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, mx_el_ne)
+               float_complex_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, *)
+               float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, x_el_div)
+               float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_complex_matrix, float_complex, 
-	       float_complex_array, elem_xpow)
+               float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
diff --git a/src/OPERATORS/op-fcs-fcs.cc b/src/OPERATORS/op-fcs-fcs.cc
--- a/src/OPERATORS/op-fcs-fcs.cc
+++ b/src/OPERATORS/op-fcs-fcs.cc
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007, 2008
-              John W. Eaton
+Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007,
+              2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -129,35 +129,35 @@ DEFBINOP (el_ldiv, float_complex, float_
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
   return (v1.float_complex_value () != static_cast<float>(0.0) && 
-	  v2.float_complex_value () != static_cast<float>(0.0));
+          v2.float_complex_value () != static_cast<float>(0.0));
 }
 
 DEFBINOP (el_or, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
   return (v1.float_complex_value () != static_cast<float>(0.0) || 
-	  v2.float_complex_value () != static_cast<float>(0.0));
+          v2.float_complex_value () != static_cast<float>(0.0));
 }
 
 DEFNDCATOP_FN (fcs_fcs, float_complex, float_complex, float_complex_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (cs_fcs, complex, float_complex, float_complex_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (fcs_cs, float_complex, complex, float_complex_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 CONVDECL (float_complex_to_complex)
 {
   CAST_CONV_ARG (const octave_float_complex&);
 
   return new octave_complex_matrix (ComplexMatrix (1, 1, static_cast<Complex>(v.float_complex_value ())));
 }
 
@@ -200,16 +200,16 @@ install_fcs_fcs_ops (void)
 
   INSTALL_ASSIGNCONV (octave_complex, octave_float_complex, octave_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_matrix, octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_str, octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_sq_str, octave_float_complex_matrix);
 
   INSTALL_CONVOP (octave_float_complex, octave_complex_matrix, 
-		  float_complex_to_complex);
+                  float_complex_to_complex);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcs-fm.cc b/src/OPERATORS/op-fcs-fm.cc
--- a/src/OPERATORS/op-fcs-fm.cc
+++ b/src/OPERATORS/op-fcs-fm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -74,60 +74,60 @@ DEFBINOP (ldiv, float_complex, float_mat
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_lt)
+               float_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_le)
+               float_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_eq)
+               float_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_ge)
+               float_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_gt)
+               float_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_ne)
+               float_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex, float_matrix, float_complex, 
-	       float_array, *)
+               float_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_matrix, float_complex, 
-	       float_array, x_el_div)
+               float_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_matrix, float_complex, 
-	       float_array, elem_xpow)
+               float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_and)
+               float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_matrix, float_complex, 
-	       float_array, mx_el_or)
+               float_array, mx_el_or)
 
 DEFNDCATOP_FN (fcs_fm, float_complex, float_matrix, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (cs_fm, complex, float_matrix, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (fcs_m, float_complex, matrix, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 void
 install_fcs_fm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex, octave_float_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex, octave_float_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_complex, octave_float_matrix, div);
@@ -146,18 +146,18 @@ install_fcs_fm_ops (void)
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_matrix, fcs_fm);
   INSTALL_CATOP (octave_complex, octave_float_matrix, cs_fm);
   INSTALL_CATOP (octave_float_complex, octave_matrix, fcs_m);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_matrix, 
-		      octave_float_complex_matrix);
+                      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_float_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcs-fs.cc b/src/OPERATORS/op-fcs-fs.cc
--- a/src/OPERATORS/op-fcs-fs.cc
+++ b/src/OPERATORS/op-fcs-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004, 2005, 2007, 2008
+Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009
               John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -106,35 +106,35 @@ DEFBINOP (el_ldiv, float_complex, float)
   return octave_value (v2.float_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
   return (v1.float_complex_value () != static_cast<float>(0.0) && 
-	  v2.float_value ());
+          v2.float_value ());
 }
 
 DEFBINOP (el_or, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
   return (v1.float_complex_value () != static_cast<float>(0.0) || 
-	  v2.float_value ());
+          v2.float_value ());
 }
 
 DEFNDCATOP_FN (fcs_fs, float_complex, float_scalar, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (cs_fs, complex, float_scalar, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (fcs_s, float_complex, scalar, float_complex_array, 
-	       float_array, concat)
+               float_array, concat)
 
 void
 install_fcs_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_complex, octave_float_scalar, sub);
   INSTALL_BINOP (op_mul, octave_float_complex, octave_float_scalar, mul);
   INSTALL_BINOP (op_div, octave_float_complex, octave_float_scalar, div);
@@ -153,18 +153,18 @@ install_fcs_fs_ops (void)
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_scalar, fcs_fs);
   INSTALL_CATOP (octave_complex, octave_float_scalar, cs_fs);
   INSTALL_CATOP (octave_float_complex, octave_scalar, fcs_s);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_scalar, 
-		      octave_float_complex_matrix);
+                      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_float_scalar, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fm-fcm.cc b/src/OPERATORS/op-fm-fcm.cc
--- a/src/OPERATORS/op-fm-fcm.cc
+++ b/src/OPERATORS/op-fm-fcm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -40,19 +40,19 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by complex matrix ops.
 
 DEFNDBINOP_OP (add, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, +)
+               float_complex_array, +)
 DEFNDBINOP_OP (sub, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, -)
+               float_complex_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_complex_matrix, *)
 
 DEFBINOP (trans_mul, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex_matrix&);
 
   FloatMatrix m1 = v1.float_matrix_value ();
@@ -60,40 +60,40 @@ DEFBINOP (trans_mul, float_matrix, float
 
   return FloatComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                              xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   FloatComplexMatrix ret = xdiv (v1.float_matrix_value (), 
-				 v2.float_complex_matrix_value (), typ);
+                                 v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (), 
-				v2.float_complex_matrix_value (), typ);
+                                v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, 
@@ -103,56 +103,56 @@ DEFBINOP (trans_ldiv, float_matrix, floa
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (), 
                          v2.float_complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_lt)
+               float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_le)
+               float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_eq)
+               float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_ge)
+               float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_gt)
+               float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_ne)
+               float_complex_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, product)
+               float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, quotient)
+               float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, elem_xpow)
+               float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
 
   return quotient (v2.float_complex_array_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_and)
+               float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, mx_el_or)
+               float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fm_fcm, float_matrix, float_complex_matrix, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (m_fcm, matrix, float_complex_matrix, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (fm_cm, float_matrix, complex_matrix, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_matrix, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
   return new octave_float_complex_matrix (FloatComplexNDArray (v.float_array_value ()));
 }
 
@@ -160,54 +160,54 @@ void
 install_fm_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_matrix, octave_float_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_matrix, octave_float_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_float_matrix, 
-		 octave_float_complex_matrix, ldiv);
+                 octave_float_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_float_matrix, octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_matrix, octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_matrix, octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_matrix, octave_float_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_matrix, octave_float_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_matrix, octave_float_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_float_matrix, 
-		 octave_float_complex_matrix, el_mul);
+                 octave_float_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_matrix, 
-		 octave_float_complex_matrix, el_div);
+                 octave_float_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_matrix, 
-		 octave_float_complex_matrix, el_pow);
+                 octave_float_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, 
-		 octave_float_complex_matrix, el_ldiv);
+                 octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, 
-		 octave_float_complex_matrix, el_and);
+                 octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, 
-		 octave_float_complex_matrix, el_or);
+                 octave_float_complex_matrix, el_or);
   INSTALL_BINOP (op_trans_mul, octave_float_matrix, 
                  octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP (op_herm_mul, octave_float_matrix, 
                  octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, 
                  octave_float_complex_matrix, trans_ldiv);
   INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, 
                  octave_float_complex_matrix, trans_ldiv);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex_matrix, fm_fcm);
   INSTALL_CATOP (octave_matrix, octave_float_complex_matrix, m_fcm);
   INSTALL_CATOP (octave_float_matrix, octave_complex_matrix, fm_cm);
 
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex_matrix, 
-		      octave_float_complex_matrix);
+                      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_matrix, octave_float_complex_matrix, 
-		   float_complex_matrix_conv);
+                   float_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fm-fcs.cc b/src/OPERATORS/op-fm-fcs.cc
--- a/src/OPERATORS/op-fm-fcs.cc
+++ b/src/OPERATORS/op-fm-fcs.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -74,66 +74,66 @@ DEFBINOP (ldiv, float_matrix, float_comp
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_lt)
+               float_complex, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_le)
+               float_complex, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_eq)
+               float_complex, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_ge)
+               float_complex, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_gt)
+               float_complex, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_ne)
+               float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_complex, float_array, 
-	       float_complex, *)
+               float_complex, *)
 
 DEFBINOP (el_div, float_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex, float_array, 
-	       float_complex, elem_xpow)
+               float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, flaot_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
   return x_el_div (v2.float_complex_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_and)
+               float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or, float_matrix, float_complex, float_array, 
-	       float_complex, mx_el_or)
+               float_complex, mx_el_or)
 
 DEFNDCATOP_FN (fm_fcs, float_matrix, float_complex, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (m_fcs, matrix, float_complex, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (fm_cs, float_matrix, complex, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 void
 install_fm_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_complex, mul);
   INSTALL_BINOP (op_div, octave_float_matrix, octave_float_complex, div);
@@ -152,18 +152,18 @@ install_fm_fcs_ops (void)
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex, fm_fcs);
   INSTALL_CATOP (octave_matrix, octave_float_complex, m_fcs);
   INSTALL_CATOP (octave_float_matrix, octave_complex, fm_cs);
 
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex, 
-		      octave_float_complex_matrix);
+                      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
-              2006, 2007, 2008 John W. Eaton
+              2006, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -67,17 +67,17 @@ DEFNDBINOP_OP (sub, float_matrix, float_
 DEFBINOP_OP (mul, float_matrix, float_matrix, *)
 
 DEFBINOP (div, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   FloatMatrix ret = xdiv (v1.float_matrix_value (), 
-			  v2.float_matrix_value (), typ);
+                          v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -85,17 +85,17 @@ DEFBINOPX (pow, float_matrix, float_matr
 }
 
 DEFBINOP (ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatMatrix ret = xleftdiv (v1.float_matrix_value (), 
-			      v2.float_matrix_value (), typ);
+                              v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
@@ -113,67 +113,67 @@ DEFBINOP (mul_trans, float_matrix, float
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   FloatMatrix ret = xleftdiv (v1.float_matrix_value (), 
-			      v2.float_matrix_value (), typ, blas_trans);
+                              v2.float_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDBINOP_FN (lt, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_lt)
+               float_array, mx_el_lt)
 DEFNDBINOP_FN (le, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_le)
+               float_array, mx_el_le)
 DEFNDBINOP_FN (eq, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_eq)
+               float_array, mx_el_eq)
 DEFNDBINOP_FN (ge, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_ge)
+               float_array, mx_el_ge)
 DEFNDBINOP_FN (gt, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_gt)
+               float_array, mx_el_gt)
 DEFNDBINOP_FN (ne, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_ne)
+               float_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_matrix, float_matrix, float_array, 
-	       float_array, product)
+               float_array, product)
 DEFNDBINOP_FN (el_div, float_matrix, float_matrix, float_array, 
-	       float_array, quotient)
+               float_array, quotient)
 DEFNDBINOP_FN (el_pow, float_matrix, float_matrix, float_array, 
-	       float_array, elem_xpow)
+               float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
 
   return octave_value (quotient (v2.float_array_value (), 
-				 v1.float_array_value ()));
+                                 v1.float_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_and)
+               float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_or)
+               float_array, mx_el_or)
 DEFNDBINOP_FN (el_not_and, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_not_and)
+               float_array, mx_el_not_and)
 DEFNDBINOP_FN (el_not_or,  float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_not_or)
+               float_array, mx_el_not_or)
 DEFNDBINOP_FN (el_and_not, float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_and_not)
+               float_array, mx_el_and_not)
 DEFNDBINOP_FN (el_or_not,  float_matrix, float_matrix, float_array, 
-	       float_array, mx_el_or_not)
+               float_array, mx_el_or_not)
 
 
 
 DEFNDCATOP_FN (fm_fm, float_matrix, float_matrix, float_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (m_fm, matrix, float_matrix, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fm_m, float_matrix, matrix, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_matrix, float_array, assign)
 
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_matrix, array, assign)
@@ -234,19 +234,19 @@ install_fm_fm_ops (void)
   INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
   INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_matrix, fm_fm);
   INSTALL_CATOP (octave_matrix, octave_float_matrix, m_fm);
   INSTALL_CATOP (octave_float_matrix, octave_matrix, fm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, 
-		    octave_float_matrix, assign);
+                    octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, 
-		    octave_float_matrix, dbl_assign);
+                    octave_float_matrix, dbl_assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_matrix, octave_float_matrix, assign_el_mul);
diff --git a/src/OPERATORS/op-fm-fs.cc b/src/OPERATORS/op-fm-fs.cc
--- a/src/OPERATORS/op-fm-fs.cc
+++ b/src/OPERATORS/op-fm-fs.cc
@@ -66,59 +66,59 @@ DEFBINOP (ldiv, float_matrix, float)
 
   FloatMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDBINOP_FN (lt, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_lt)
+               float_scalar, mx_el_lt)
 DEFNDBINOP_FN (le, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_le)
+               float_scalar, mx_el_le)
 DEFNDBINOP_FN (eq, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_eq)
+               float_scalar, mx_el_eq)
 DEFNDBINOP_FN (ge, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_ge)
+               float_scalar, mx_el_ge)
 DEFNDBINOP_FN (gt, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_gt)
+               float_scalar, mx_el_gt)
 DEFNDBINOP_FN (ne, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_ne)
+               float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_scalar, float_array, float_scalar, *)
 
 DEFBINOP (el_div, float_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_scalar, float_array, 
-	       float_scalar, elem_xpow)
+               float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
 
   return x_el_div (v2.float_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_and)
+               float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or, float_matrix, float_scalar, float_array, 
-	       float_scalar, mx_el_or)
+               float_scalar, mx_el_or)
 
 DEFNDCATOP_FN (fm_fs, float_matrix, float_scalar, float_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (m_fs, matrix, float_scalar, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fm_s, float_matrix, scalar, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_scalar, float_scalar, assign)
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_scalar, scalar, assign)
 
diff --git a/src/OPERATORS/op-fs-fcm.cc b/src/OPERATORS/op-fs-fcm.cc
--- a/src/OPERATORS/op-fs-fcm.cc
+++ b/src/OPERATORS/op-fs-fcm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
-              2006, 2007, 2008 John W. Eaton
+              2006, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -41,98 +41,98 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by complex matrix ops.
 
 DEFNDBINOP_OP (add, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, +)
+               float_complex_array, +)
 DEFNDBINOP_OP (sub, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, -)
+               float_complex_array, -)
 DEFNDBINOP_OP (mul, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, *)
+               float_complex_array, *)
 
 DEFBINOP (div, float_scalar, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_lt)
+               float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_le)
+               float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_eq)
+               float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_ge)
+               float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_gt)
+               float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_ne)
+               float_complex_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, *)
+               float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, x_el_div)
+               float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, elem_xpow)
+               float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, 
-		   const octave_float_complex_matrix&);
+                   const octave_float_complex_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_and)
+               float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_complex_matrix, float_scalar, 
-	       float_complex_array, mx_el_or)
+               float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fs_fcm, float_scalar, float_complex_matrix, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (s_fcm, scalar, float_complex_matrix, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (fs_cm, float_scalar, complex_matrix, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_scalar, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
   return new octave_float_complex_matrix (FloatComplexMatrix (v.float_matrix_value ()));
 }
 
@@ -140,46 +140,46 @@ void
 install_fs_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_scalar, octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_scalar, octave_float_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_scalar, octave_float_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_scalar, octave_float_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_float_scalar, 
-		 octave_float_complex_matrix, ldiv);
+                 octave_float_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_float_scalar, octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_scalar, octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_scalar, octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_scalar, octave_float_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_scalar, octave_float_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_scalar, octave_float_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_float_scalar, 
-		 octave_float_complex_matrix, el_mul);
+                 octave_float_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_scalar, 
-		 octave_float_complex_matrix, el_div);
+                 octave_float_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_scalar, 
-		 octave_float_complex_matrix, el_pow);
+                 octave_float_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, 
-		 octave_float_complex_matrix, el_ldiv);
+                 octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, 
-		 octave_float_complex_matrix, el_and);
+                 octave_float_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, 
-		 octave_float_complex_matrix, el_or);
+                 octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex_matrix, fs_fcm);
   INSTALL_CATOP (octave_scalar, octave_float_complex_matrix, s_fcm);
   INSTALL_CATOP (octave_float_scalar, octave_complex_matrix, fs_cm);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex_matrix, 
-		      octave_float_complex_matrix);
+                      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_scalar, octave_float_complex_matrix, 
-		   float_complex_matrix_conv);
+                   float_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fs-fcs.cc b/src/OPERATORS/op-fs-fcs.cc
--- a/src/OPERATORS/op-fs-fcs.cc
+++ b/src/OPERATORS/op-fs-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004, 2005, 2007, 2008
+Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009
               John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -116,23 +116,23 @@ DEFBINOP (el_and, float_scalar, float_co
 DEFBINOP (el_or, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   return octave_value (v1.float_scalar_value () || (v2.float_complex_value () != static_cast<float>(0.0)));
 }
 
 DEFNDCATOP_FN (fs_fcs, float_scalar, float_complex, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (s_fcs, scalar, float_complex, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 DEFNDCATOP_FN (fs_cs, float_scalar, complex, float_array, 
-	       float_complex_array, concat)
+               float_complex_array, concat)
 
 void
 install_fs_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_scalar, octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_scalar, octave_float_complex, mul);
   INSTALL_BINOP (op_div, octave_float_scalar, octave_float_complex, div);
@@ -151,18 +151,18 @@ install_fs_fcs_ops (void)
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex, fs_fcs);
   INSTALL_CATOP (octave_scalar, octave_float_complex, s_fcs);
   INSTALL_CATOP (octave_float_scalar, octave_complex, fs_cs);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex, 
-		      octave_float_complex_matrix);
+                      octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fs-fm.cc b/src/OPERATORS/op-fs-fm.cc
--- a/src/OPERATORS/op-fs-fm.cc
+++ b/src/OPERATORS/op-fs-fm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -67,54 +67,54 @@ DEFBINOP (ldiv, float_scalar, float_matr
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (lt, float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_lt)
+               float_array, mx_el_lt)
 DEFNDBINOP_FN (le, float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_le)
+               float_array, mx_el_le)
 DEFNDBINOP_FN (eq, float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_eq)
+               float_array, mx_el_eq)
 DEFNDBINOP_FN (ge, float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_ge)
+               float_array, mx_el_ge)
 DEFNDBINOP_FN (gt, float_scalar, float_matrix, float_scalar, 
 float_array, mx_el_gt)
 DEFNDBINOP_FN (ne, float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_ne)
+               float_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_scalar, float_matrix, float_scalar, 
-	       float_array, *)
+               float_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_matrix, float_scalar, 
-	       float_array, x_el_div)
+               float_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_matrix, float_scalar, 
-	       float_array, elem_xpow)
+               float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_and)
+               float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_matrix, float_scalar, 
-	       float_array, mx_el_or)
+               float_array, mx_el_or)
 
 DEFNDCATOP_FN (fs_fm, float_scalar, float_matrix, float_array, 
-	       float_array, concat)
+               float_array, concat)
 
 DEFNDCATOP_FN (s_fm, scalar, float_matrix, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fs_m, float_scalar, matrix, float_array, float_array, concat)
 
 DEFCONV (matrix_conv, float_scalar, float_matrix)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
diff --git a/src/OPERATORS/op-int-concat.cc b/src/OPERATORS/op-int-concat.cc
--- a/src/OPERATORS/op-int-concat.cc
+++ b/src/OPERATORS/op-int-concat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007, 2008 John W. Eaton
+Copyright (C) 2004, 2005, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -130,17 +130,17 @@ OCTAVE_INT_DOUBLE_CONCAT_FN (uint8)
 OCTAVE_INT_DOUBLE_CONCAT_FN (uint16)
 OCTAVE_INT_DOUBLE_CONCAT_FN (uint32)
 OCTAVE_INT_DOUBLE_CONCAT_FN (uint64)
 
 OCTAVE_DOUBLE_INT_CONCAT_FN (int8)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int16)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int32)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int64)
-	      	   
+                   
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint8)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint16)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint32)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint64)
 
 OCTAVE_INT_FLOAT_CONCAT_FN (int8)
 OCTAVE_INT_FLOAT_CONCAT_FN (int16)
 OCTAVE_INT_FLOAT_CONCAT_FN (int32)
@@ -150,17 +150,17 @@ OCTAVE_INT_FLOAT_CONCAT_FN (uint8)
 OCTAVE_INT_FLOAT_CONCAT_FN (uint16)
 OCTAVE_INT_FLOAT_CONCAT_FN (uint32)
 OCTAVE_INT_FLOAT_CONCAT_FN (uint64)
 
 OCTAVE_FLOAT_INT_CONCAT_FN (int8)
 OCTAVE_FLOAT_INT_CONCAT_FN (int16)
 OCTAVE_FLOAT_INT_CONCAT_FN (int32)
 OCTAVE_FLOAT_INT_CONCAT_FN (int64)
-	      	   
+                   
 OCTAVE_FLOAT_INT_CONCAT_FN (uint8)
 OCTAVE_FLOAT_INT_CONCAT_FN (uint16)
 OCTAVE_FLOAT_INT_CONCAT_FN (uint32)
 OCTAVE_FLOAT_INT_CONCAT_FN (uint64)
 
 OCTAVE_INT_CHAR_CONCAT_FN (int8)
 OCTAVE_INT_CHAR_CONCAT_FN (int16)
 OCTAVE_INT_CHAR_CONCAT_FN (int32)
@@ -170,17 +170,17 @@ OCTAVE_INT_CHAR_CONCAT_FN (uint8)
 OCTAVE_INT_CHAR_CONCAT_FN (uint16)
 OCTAVE_INT_CHAR_CONCAT_FN (uint32)
 OCTAVE_INT_CHAR_CONCAT_FN (uint64)
 
 OCTAVE_CHAR_INT_CONCAT_FN (int8)
 OCTAVE_CHAR_INT_CONCAT_FN (int16)
 OCTAVE_CHAR_INT_CONCAT_FN (int32)
 OCTAVE_CHAR_INT_CONCAT_FN (int64)
-	      	   
+                   
 OCTAVE_CHAR_INT_CONCAT_FN (uint8)
 OCTAVE_CHAR_INT_CONCAT_FN (uint16)
 OCTAVE_CHAR_INT_CONCAT_FN (uint32)
 OCTAVE_CHAR_INT_CONCAT_FN (uint64)
 
 void
 install_int_concat_ops (void)
 {
diff --git a/src/OPERATORS/op-int-conv.cc b/src/OPERATORS/op-int-conv.cc
--- a/src/OPERATORS/op-int-conv.cc
+++ b/src/OPERATORS/op-int-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007, 2008 John W. Eaton
+Copyright (C) 2004, 2005, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -50,23 +50,23 @@ along with Octave; see the file COPYING.
   CONVDECL (name) \
   { \
     CAST_CONV_ARG (const octave_ ## tfrom&); \
  \
     octave_ ## tto ::clear_conv_flag (); \
     octave_ ## tto ## _matrix v2 = v.tto ## _array_value (); \
     if (octave_ ## tto ::get_trunc_flag ()) \
       gripe_truncated_conversion (v.type_name (). c_str (), \
-				  v2.type_name (). c_str ()); \
+                                  v2.type_name (). c_str ()); \
     if (octave_ ## tto ::get_nan_flag ()) \
       gripe_nan_conversion (v.type_name (). c_str (), \
-			    v2.type_name (). c_str ()); \
+                            v2.type_name (). c_str ()); \
     if (octave_ ## tto ::get_non_int_flag ()) \
       gripe_non_integer_conversion (v.type_name (). c_str (), \
-			            v2.type_name (). c_str ()); \
+                                    v2.type_name (). c_str ()); \
     octave_ ## tto ::clear_conv_flag (); \
     return new octave_ ## tto ## _matrix (v2); \
   }
 
 // conversion ops
 
 DEFINTCONVFN (scalar_to_int8, scalar, int8)
 DEFINTCONVFN (scalar_to_int16, scalar, int16)
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -25,54 +25,54 @@ along with Octave; see the file COPYING.
 #define DEFINTBINOP_OP(name, t1, t2, op, t3) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value \
       (v1.t1 ## _value () op v2.t2 ## _value ()); \
     if (octave_ ## t3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define DEFINTNDBINOP_OP(name, t1, t2, e1, e2, op, t3) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value \
       (v1.e1 ## _value () op v2.e2 ## _value ()); \
     if (octave_ ## t3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
-#define DEFINTBINOP_FN(name, t1, t2, f, t3, op)	\
+#define DEFINTBINOP_FN(name, t1, t2, f, t3, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value (f (v1.t1 ## _value (), v2.t2 ## _value ())); \
     if (octave_ ## t3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
-#define DEFINTNDBINOP_FN(name, t1, t2, e1, e2, f, t3, op)	\
+#define DEFINTNDBINOP_FN(name, t1, t2, e1, e2, f, t3, op)       \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value (f (v1.e1 ## _value (), v2.e2 ## _value ())); \
     if (octave_ ## t3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_CONCAT_FN2(T1, T2) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _s_s, T1 ## _scalar, T2 ## _scalar, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _s_m, T1 ## _scalar, T2 ## _matrix, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _m_s, T1 ## _matrix, T2 ## _scalar, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
@@ -182,85 +182,85 @@ along with Octave; see the file COPYING.
     return retval; \
   } \
   DEFUNOP_OP (s_transpose, TYPE ## _scalar, /* no-op */) \
   DEFUNOP_OP (s_hermitian, TYPE ## _scalar, /* no-op */) \
  \
   DEFNCUNOP_METHOD (s_incr, TYPE ## _scalar, increment) \
   DEFNCUNOP_METHOD (s_decr, TYPE ## _scalar, decrement)
 
-#define OCTAVE_SS_INT_ARITH_OPS(PFX, T1, T2, T3)	\
+#define OCTAVE_SS_INT_ARITH_OPS(PFX, T1, T2, T3)        \
   /* scalar by scalar ops. */ \
  \
   DEFINTBINOP_OP (PFX ## _add, T1 ## scalar, T2 ## scalar, +, T3) \
   DEFINTBINOP_OP (PFX ## _sub, T1 ## scalar, T2 ## scalar, -, T3) \
   DEFINTBINOP_OP (PFX ## _mul, T1 ## scalar, T2 ## scalar, *, T3) \
  \
   DEFBINOP (PFX ## _div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v2.T2 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
     if (octave_ ## T3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated ("/", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
  \
-  DEFINTBINOP_FN (PFX ## _pow, T1 ## scalar, T2 ## scalar, xpow, T3, ^)	\
+  DEFINTBINOP_FN (PFX ## _pow, T1 ## scalar, T2 ## scalar, xpow, T3, ^) \
  \
   DEFBINOP (PFX ## _ldiv, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     if (octave_ ## T3 ::get_math_trunc_flag ()) \
           gripe_binop_integer_math_truncated ("\\", v1.type_name (). c_str (), \
-					      v2.type_name (). c_str ()); \
+                                              v2.type_name (). c_str ()); \
     octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
  \
-  DEFINTBINOP_OP (PFX ## _el_mul, T1 ## scalar, T2 ## scalar, *, T3)	\
+  DEFINTBINOP_OP (PFX ## _el_mul, T1 ## scalar, T2 ## scalar, *, T3)    \
  \
   DEFBINOP (PFX ## _el_div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v2.T2 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
     if (octave_ ## T3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ()); \
+                                          v2.type_name (). c_str ()); \
     octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _el_pow, T1 ## scalar, T2 ## scalar, xpow, T3, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     if (octave_ ## T3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
 
 #define OCTAVE_SS_INT_BOOL_OPS(PFX, T1, T2, Z1, Z2) \
   DEFBINOP (PFX ## _el_and, T2, T2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
@@ -357,47 +357,47 @@ along with Octave; see the file COPYING.
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     if (! v1.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TS ## scalar_value () / v1.TS ## scalar_value ()); \
     if (octave_ ## TI ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated ("\\", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
   DEFBINOP (PFX ## _el_div, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     octave_value retval = octave_value (v1.TS ## scalar_value () / v2.TM ## array_value ()); \
     if (octave_ ## TI ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     if (! v1.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
     if (octave_ ## TI ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_SM_INT_CMP_OPS(PFX, TS, TM) \
   DEFNDBINOP_FN (PFX ## _lt, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_eq) \
@@ -413,66 +413,66 @@ along with Octave; see the file COPYING.
 
 #define OCTAVE_SM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const octave_ ## T1& a, const T2 ## NDArray& b) \
   { \
     T2 ## NDArray result (b.dims ()); \
     for (int i = 0; i < b.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = pow (a, b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = pow (a, b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const octave_ ## T1& a, const NDArray& b) \
   { \
     T1 ## NDArray result (b.dims ()); \
     for (int i = 0; i < b.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = pow (a, b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = pow (a, b(i)); \
       } \
     return octave_value (result); \
   } \
  \
   octave_value \
   elem_xpow (double a, const T2 ## NDArray& b) \
   { \
     T2 ## NDArray result (b.dims ()); \
     for (int i = 0; i < b.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = pow (a, b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = pow (a, b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const octave_ ## T1& a, const FloatNDArray& b) \
   { \
     T1 ## NDArray result (b.dims ()); \
     for (int i = 0; i < b.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = powf (a, b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = powf (a, b(i)); \
       } \
     return octave_value (result); \
   } \
  \
   octave_value \
   elem_xpow (float a, const T2 ## NDArray& b) \
   { \
     T2 ## NDArray result (b.dims ()); \
     for (int i = 0; i < b.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = powf (a, b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = powf (a, b(i)); \
       } \
     return octave_value (result); \
   }
 
 
 #define OCTAVE_SM_CONV(TS, TM) \
   DEFCONV (TS ## s_ ## TM ## m_conv, TM ## scalar, TM ## matrix) \
   { \
@@ -514,17 +514,17 @@ along with Octave; see the file COPYING.
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
  \
     if (! v2.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
     if (octave_ ## TI ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated ("/", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   /* DEFBINOP_FN (PFX ## _pow, TM ## matrix, TS ## scalar, xpow) */ \
  \
   /* DEFBINOP (PFX ## _ldiv, TM ## matrix, TS ## scalar) */ \
   /* { */ \
@@ -543,31 +543,31 @@ along with Octave; see the file COPYING.
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
  \
     if (! v2.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
     if (octave_ ## TI ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated ("./", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
     \
     octave_value retval = v2.TS ## scalar_value () / v1.TM ## array_value (); \
     if (octave_ ## TI ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (".^", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_MS_INT_CMP_OPS(PFX, TM, TS) \
   DEFNDBINOP_FN (PFX ## _lt, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_eq) \
@@ -592,61 +592,61 @@ along with Octave; see the file COPYING.
 
 #define OCTAVE_MS_POW_OPS(T1, T2) \
 octave_value elem_xpow (T1 ## NDArray a, octave_ ## T2  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.length (); i++) \
     { \
       OCTAVE_QUIT; \
-      result (i) = pow (a(i), b);		\
+      result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (T1 ## NDArray a, double  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.length (); i++) \
     { \
       OCTAVE_QUIT; \
-      result (i) = pow (a(i), b);		\
+      result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (NDArray a, octave_ ## T2  b) \
 { \
   T2 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.length (); i++) \
     { \
       OCTAVE_QUIT; \
-      result (i) = pow (a(i), b);		\
+      result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (T1 ## NDArray a, float  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.length (); i++) \
     { \
       OCTAVE_QUIT; \
-      result (i) = powf (a(i), b);		\
+      result (i) = powf (a(i), b);              \
     } \
   return octave_value (result); \
 } \
 \
 octave_value elem_xpow (FloatNDArray a, octave_ ## T2  b) \
 { \
   T2 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.length (); i++) \
     { \
       OCTAVE_QUIT; \
-      result (i) = powf (a(i), b);		\
+      result (i) = powf (a(i), b);              \
     } \
   return octave_value (result); \
 }
 
 
 #define OCTAVE_MS_INT_OPS(TYPE) \
   OCTAVE_MS_POW_OPS (TYPE, TYPE) \
   OCTAVE_MS_INT_ARITH_OPS (ms, TYPE ## _, TYPE ## _, TYPE) \
@@ -685,28 +685,28 @@ octave_value elem_xpow (FloatNDArray a, 
   } \
  \
   DEFUNOP (m_transpose, TYPE ## _matrix) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix&); \
  \
     if (v.ndims () > 2) \
       { \
-	error ("transpose not defined for N-d objects"); \
-	return octave_value (); \
+        error ("transpose not defined for N-d objects"); \
+        return octave_value (); \
       } \
     else \
       return octave_value (v.TYPE ## _array_value().transpose ()); \
   } \
  \
   DEFNCUNOP_METHOD (m_incr, TYPE ## _matrix, increment) \
   DEFNCUNOP_METHOD (m_decr, TYPE ## _matrix, decrement) \
   DEFNCUNOP_METHOD (m_changesign, TYPE ## _matrix, changesign)
 
-#define OCTAVE_MM_INT_ARITH_OPS(PFX, T1, T2, T3)	\
+#define OCTAVE_MM_INT_ARITH_OPS(PFX, T1, T2, T3)        \
   /* matrix by matrix ops. */ \
  \
   DEFINTNDBINOP_OP (PFX ## _add, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, +, T3) \
   DEFINTNDBINOP_OP (PFX ## _sub, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, -, T3) \
  \
   /* DEFBINOP_OP (PFX ## _mul, T1 ## matrix, T2 ## matrix, *) */ \
   /* DEFBINOP_FN (PFX ## _div, T1 ## matrix, T2 ## matrix, xdiv) */ \
  \
@@ -726,17 +726,17 @@ octave_value elem_xpow (FloatNDArray a, 
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## matrix, T2 ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## matrix&, const octave_ ## T2 ## matrix&); \
     \
     octave_value retval = octave_value (quotient (v2.T2 ## array_value (), v1.T1 ## array_value ())); \
     if (octave_ ## T3 ::get_math_trunc_flag ()) \
       gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-					  v2.type_name (). c_str ());	\
+                                          v2.type_name (). c_str ());   \
     octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_MM_INT_CMP_OPS(PFX, T1, T2) \
   DEFNDBINOP_FN (PFX ## _lt, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_eq) \
@@ -764,100 +764,100 @@ octave_value elem_xpow (FloatNDArray a, 
 #define OCTAVE_MM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-	gripe_nonconformant ("operator .^", a_dims, b_dims); \
-	return octave_value (); \
+        gripe_nonconformant ("operator .^", a_dims, b_dims); \
+        return octave_value (); \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = pow (a(i), b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-	gripe_nonconformant ("operator .^", a_dims, b_dims); \
-	return octave_value (); \
+        gripe_nonconformant ("operator .^", a_dims, b_dims); \
+        return octave_value (); \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = pow (a(i), b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-	gripe_nonconformant ("operator .^", a_dims, b_dims); \
-	return octave_value (); \
+        gripe_nonconformant ("operator .^", a_dims, b_dims); \
+        return octave_value (); \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = pow (a(i), b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-	gripe_nonconformant ("operator .^", a_dims, b_dims); \
-	return octave_value (); \
+        gripe_nonconformant ("operator .^", a_dims, b_dims); \
+        return octave_value (); \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = powf (a(i), b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
   } \
 \
   octave_value \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-	gripe_nonconformant ("operator .^", a_dims, b_dims); \
-	return octave_value (); \
+        gripe_nonconformant ("operator .^", a_dims, b_dims); \
+        return octave_value (); \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
-	OCTAVE_QUIT; \
-	result (i) = powf (a(i), b(i)); \
+        OCTAVE_QUIT; \
+        result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
   }
 
 
 #define OCTAVE_MM_CONV(T1, T2) \
   DEFCONV (T1 ## m_ ## T2 ## m_conv, T1 ## matrix, T2 ## matrix) \
   { \
@@ -954,20 +954,20 @@ octave_value elem_xpow (FloatNDArray a, 
 
 #define OCTAVE_INSTALL_SS_INT_BOOL_OPS(PFX, T1, T2) \
   INSTALL_BINOP (op_el_and, octave_ ## T1 ## scalar, octave_ ## T2 ## scalar, PFX ## _el_and); \
   INSTALL_BINOP (op_el_or, octave_ ## T1 ## scalar, octave_ ## T2 ## scalar, PFX ## _el_or);
 
 #define OCTAVE_INSTALL_SS_INT_OPS(TYPE) \
   OCTAVE_INSTALL_S_INT_UNOPS (TYPE) \
   OCTAVE_INSTALL_SS_INT_ARITH_OPS (ss, TYPE ## _, TYPE ## _) \
-  OCTAVE_INSTALL_SS_INT_ARITH_OPS (ssx, TYPE ## _, )	     \
-  OCTAVE_INSTALL_SS_INT_ARITH_OPS (sxs,  , TYPE ## _)	     \
-  OCTAVE_INSTALL_SS_INT_ARITH_OPS (ssfx, TYPE ## _, float_)	     \
-  OCTAVE_INSTALL_SS_INT_ARITH_OPS (sfxs,  float_, TYPE ## _)	     \
+  OCTAVE_INSTALL_SS_INT_ARITH_OPS (ssx, TYPE ## _, )         \
+  OCTAVE_INSTALL_SS_INT_ARITH_OPS (sxs,  , TYPE ## _)        \
+  OCTAVE_INSTALL_SS_INT_ARITH_OPS (ssfx, TYPE ## _, float_)          \
+  OCTAVE_INSTALL_SS_INT_ARITH_OPS (sfxs,  float_, TYPE ## _)         \
   OCTAVE_INSTALL_SS_INT_CMP_OPS (ss, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_SS_INT_CMP_OPS (sx, TYPE ## _, ) \
   OCTAVE_INSTALL_SS_INT_CMP_OPS (xs, , TYPE ## _) \
   OCTAVE_INSTALL_SS_INT_CMP_OPS (sfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_SS_INT_CMP_OPS (fxs, float_, TYPE ## _) \
   OCTAVE_INSTALL_SS_INT_BOOL_OPS (ss, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_SS_INT_BOOL_OPS (sx, TYPE ## _, ) \
   OCTAVE_INSTALL_SS_INT_BOOL_OPS (xs, , TYPE ## _) \
@@ -1002,20 +1002,20 @@ octave_value elem_xpow (FloatNDArray a, 
 #define OCTAVE_INSTALL_SM_INT_BOOL_OPS(PFX, T1, T2) \
   INSTALL_BINOP (op_el_and, octave_ ## T1 ## scalar, octave_ ## T2 ## matrix, PFX ## _el_and); \
   INSTALL_BINOP (op_el_or, octave_ ## T1 ## scalar, octave_ ## T2 ## matrix, PFX ## _el_or); \
   INSTALL_BINOP (op_el_and_not, octave_ ## T1 ## scalar, octave_ ## T2 ## matrix, PFX ## _el_and_not); \
   INSTALL_BINOP (op_el_or_not, octave_ ## T1 ## scalar, octave_ ## T2 ## matrix, PFX ## _el_or_not);
 
 #define OCTAVE_INSTALL_SM_INT_OPS(TYPE) \
   OCTAVE_INSTALL_SM_INT_ARITH_OPS (sm, TYPE ## _, TYPE ## _) \
-  OCTAVE_INSTALL_SM_INT_ARITH_OPS (smx, TYPE ## _, )	     \
-  OCTAVE_INSTALL_SM_INT_ARITH_OPS (sxm, , TYPE ## _)	     \
-  OCTAVE_INSTALL_SM_INT_ARITH_OPS (smfx, TYPE ## _, float_)	     \
-  OCTAVE_INSTALL_SM_INT_ARITH_OPS (sfxm, float_, TYPE ## _)	     \
+  OCTAVE_INSTALL_SM_INT_ARITH_OPS (smx, TYPE ## _, )         \
+  OCTAVE_INSTALL_SM_INT_ARITH_OPS (sxm, , TYPE ## _)         \
+  OCTAVE_INSTALL_SM_INT_ARITH_OPS (smfx, TYPE ## _, float_)          \
+  OCTAVE_INSTALL_SM_INT_ARITH_OPS (sfxm, float_, TYPE ## _)          \
   OCTAVE_INSTALL_SM_INT_CMP_OPS (sm, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_SM_INT_CMP_OPS (xm, , TYPE ## _) \
   OCTAVE_INSTALL_SM_INT_CMP_OPS (smx, TYPE ## _, ) \
   OCTAVE_INSTALL_SM_INT_CMP_OPS (fxm, float_, TYPE ## _) \
   OCTAVE_INSTALL_SM_INT_CMP_OPS (smfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_SM_INT_BOOL_OPS (sm, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_SM_INT_BOOL_OPS (xm, , TYPE ## _) \
   OCTAVE_INSTALL_SM_INT_BOOL_OPS (smx, TYPE ## _, ) \
@@ -1064,19 +1064,19 @@ octave_value elem_xpow (FloatNDArray a, 
   INSTALL_ASSIGNOP (op_add_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_add) \
   INSTALL_ASSIGNOP (op_sub_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_sub) \
   INSTALL_ASSIGNOP (op_mul_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_mul) \
   INSTALL_ASSIGNOP (op_div_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_div)
 
 #define OCTAVE_INSTALL_MS_INT_OPS(TYPE) \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (msx, TYPE ## _, ) \
-  OCTAVE_INSTALL_MS_INT_ARITH_OPS (mxs, , TYPE ## _)	   \
+  OCTAVE_INSTALL_MS_INT_ARITH_OPS (mxs, , TYPE ## _)       \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (msfx, TYPE ## _, float_) \
-  OCTAVE_INSTALL_MS_INT_ARITH_OPS (mfxs, float_, TYPE ## _)	   \
+  OCTAVE_INSTALL_MS_INT_ARITH_OPS (mfxs, float_, TYPE ## _)        \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mx, TYPE ## _, ) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mxs, , TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mfxs, float_, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (mx, TYPE ## _, ) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (mxs, , TYPE ## _) \
@@ -1095,17 +1095,17 @@ octave_value elem_xpow (FloatNDArray a, 
   INSTALL_UNOP (op_uminus, octave_ ## TYPE ## _matrix, m_uminus); \
   INSTALL_UNOP (op_transpose, octave_ ## TYPE ## _matrix, m_transpose); \
   INSTALL_UNOP (op_hermitian, octave_ ## TYPE ## _matrix, m_transpose); \
  \
   INSTALL_NCUNOP (op_incr, octave_ ## TYPE ## _matrix, m_incr); \
   INSTALL_NCUNOP (op_decr, octave_ ## TYPE ## _matrix, m_decr); \
   INSTALL_NCUNOP (op_uminus, octave_ ## TYPE ## _matrix, m_changesign);
 
-#define OCTAVE_INSTALL_MM_INT_ARITH_OPS(PFX, T1, T2)			\
+#define OCTAVE_INSTALL_MM_INT_ARITH_OPS(PFX, T1, T2)                    \
   INSTALL_BINOP (op_add, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _add); \
   INSTALL_BINOP (op_sub, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _sub); \
   /* INSTALL_BINOP (op_mul, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _mul); */ \
   /* INSTALL_BINOP (op_div, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _div); */ \
   INSTALL_BINOP (op_pow, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _pow); \
   /* INSTALL_BINOP (op_ldiv, octave_ ## T1 ## _matrix, octave_ ## T2 ## _matrix, mm_ldiv); */ \
   INSTALL_BINOP (op_el_mul, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _el_mul); \
   INSTALL_BINOP (op_el_div, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _el_div); \
@@ -1136,19 +1136,19 @@ octave_value elem_xpow (FloatNDArray a, 
   INSTALL_ASSIGNOP (op_sub_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## matrix, PFX ## _assign_sub) \
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## matrix, PFX ## _assign_el_mul) \
   INSTALL_ASSIGNOP (op_el_div_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## matrix, PFX ## _assign_el_div)
 
 #define OCTAVE_INSTALL_MM_INT_OPS(TYPE) \
   OCTAVE_INSTALL_M_INT_UNOPS (TYPE) \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mm, TYPE ##_, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mmx, TYPE ##_, ) \
-  OCTAVE_INSTALL_MM_INT_ARITH_OPS (mxm, , TYPE ##_)	   \
+  OCTAVE_INSTALL_MM_INT_ARITH_OPS (mxm, , TYPE ##_)        \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mmfx, TYPE ##_, float_) \
-  OCTAVE_INSTALL_MM_INT_ARITH_OPS (mfxm, float_, TYPE ##_)	   \
+  OCTAVE_INSTALL_MM_INT_ARITH_OPS (mfxm, float_, TYPE ##_)         \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mm, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mmx, TYPE ## _, ) \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mxm, , TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mmfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mfxm, float_, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mm, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mmx, TYPE ## _, ) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mxm, , TYPE ## _) \
diff --git a/src/OPERATORS/op-m-cm.cc b/src/OPERATORS/op-m-cm.cc
--- a/src/OPERATORS/op-m-cm.cc
+++ b/src/OPERATORS/op-m-cm.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -61,17 +61,17 @@ DEFBINOP (trans_mul, matrix, complex_mat
 }
 
 DEFBINOP (div, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   ComplexMatrix ret = xdiv (v1.matrix_value (), 
-			    v2.complex_matrix_value (), typ);
+                            v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -79,17 +79,17 @@ DEFBINOPX (pow, matrix, complex_matrix)
 }
 
 DEFBINOP (ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
-				v2.complex_matrix_value (), typ);
+                                v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -51,46 +51,46 @@ DEFBINOP (div, matrix, sparse_complex_ma
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.matrix_value (), 
-				v2.sparse_complex_matrix_value (), typ);
+                                v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
   
   ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
-				v2.complex_matrix_value (), typ);
+                                v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, matrix, sparse_complex_matrix, mx_el_eq)
@@ -99,40 +99,40 @@ DEFBINOP_FN (gt, matrix, sparse_complex_
 DEFBINOP_FN (ne, matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   
   return octave_value 
     (elem_xpow (SparseMatrix (v1.matrix_value ()),
-		v2.sparse_complex_matrix_value ()));
+                v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   return octave_value 
     (quotient (v2.sparse_complex_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (m_scm, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_complex_matrix&);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (), 
-				    ra_idx));
+                                    ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, matrix, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_matrix&);
   return new octave_sparse_complex_matrix 
     (SparseComplexMatrix (v.complex_matrix_value ()));
 }
@@ -148,34 +148,34 @@ install_m_scm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_matrix, octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_matrix, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_matrix, octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_matrix, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_matrix, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_matrix, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_matrix, octave_sparse_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_matrix, octave_sparse_complex_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_matrix, octave_sparse_complex_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_matrix, octave_sparse_complex_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_sparse_complex_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_matrix, octave_sparse_complex_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_matrix, octave_sparse_complex_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_matrix, octave_sparse_complex_matrix, m_scm);
 
   INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_complex_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_matrix, octave_sparse_complex_matrix, 
-		   sparse_complex_matrix_conv);
+                   sparse_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -50,17 +50,17 @@ DEFBINOP (div, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
@@ -99,17 +99,17 @@ DEFBINOP_FN (ne, matrix, sparse_matrix, 
 DEFBINOP_FN (el_mul, matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
   
   return octave_value (elem_xpow (SparseMatrix (v1.matrix_value ()), 
-				  v2.sparse_matrix_value ()));
+                                  v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
   
   return octave_value 
     (quotient (v2.sparse_matrix_value (), v1.matrix_value ()));
@@ -158,16 +158,16 @@ install_m_sm_ops (void)
   INSTALL_BINOP (op_el_or, octave_matrix, octave_sparse_matrix,  el_or);
 
   INSTALL_CATOP (octave_matrix, octave_sparse_matrix, m_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_sparse_matrix, assign)
   INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_matrix, octave_matrix)
 
   INSTALL_WIDENOP (octave_matrix, octave_sparse_matrix, 
-		   sparse_matrix_conv);
+                   sparse_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-pm-scm.cc b/src/OPERATORS/op-pm-scm.cc
--- a/src/OPERATORS/op-pm-scm.cc
+++ b/src/OPERATORS/op-pm-scm.cc
@@ -82,16 +82,16 @@ DEFBINOP (div_scm_pm, sparse_complex_mat
 
   return v1.sparse_complex_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_scm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_sparse_complex_matrix,
-		 mul_pm_scm);
+                 mul_pm_scm);
   INSTALL_BINOP (op_ldiv, octave_perm_matrix, octave_sparse_complex_matrix,
-		 ldiv_pm_scm);
+                 ldiv_pm_scm);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_perm_matrix,
-		 mul_scm_pm);
+                 mul_scm_pm);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_perm_matrix,
-		 div_scm_pm);
+                 div_scm_pm);
 }
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -82,16 +82,16 @@ DEFBINOP (div_sm_pm, sparse_matrix, perm
 
   return v1.sparse_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_sm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_sparse_matrix,
-		 mul_pm_sm);
+                 mul_pm_sm);
   INSTALL_BINOP (op_ldiv, octave_perm_matrix, octave_sparse_matrix,
-		 ldiv_pm_sm);
+                 ldiv_pm_sm);
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_perm_matrix,
-		 mul_sm_pm);
+                 mul_sm_pm);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_perm_matrix,
-		 div_sm_pm);
+                 div_sm_pm);
 }
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -51,17 +51,17 @@ DEFBINOP (div, scalar, sparse_complex_ma
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       Matrix m1 = Matrix (1, 1, v1.scalar_value ());
       SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
@@ -69,24 +69,24 @@ DEFBINOP (div, scalar, sparse_complex_ma
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
   return xpow (v1.scalar_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -103,17 +103,17 @@ DEFBINOP_FN (ne, scalar, sparse_complex_
 
 DEFBINOP_OP (el_mul, scalar, sparse_complex_matrix, *)
 DEFBINOP_FN (el_div, scalar, sparse_complex_matrix, x_el_div)
 DEFBINOP_FN (el_pow, scalar, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -151,34 +151,34 @@ install_s_scm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_scalar, octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_scalar, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_scalar, octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_scalar, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_scalar, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_scalar, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_scalar, octave_sparse_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_scalar, octave_sparse_complex_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_scalar, octave_sparse_complex_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_scalar, octave_sparse_complex_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_scalar, octave_sparse_complex_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_scalar, octave_sparse_complex_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_scalar, octave_sparse_complex_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_scalar, octave_sparse_complex_matrix, s_scm);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_sparse_complex_matrix, 
-		      octave_complex_matrix);
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_scalar, octave_sparse_complex_matrix, 
-		   sparse_complex_matrix_conv);
+                   sparse_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -47,17 +47,17 @@ DEFBINOP (div, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseMatrix (1, 1, v1.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       Matrix m1 = Matrix (1, 1, v1.double_value ());
       SparseMatrix m2 = v2.sparse_matrix_value ();
diff --git a/src/OPERATORS/op-sbm-b.cc b/src/OPERATORS/op-sbm-b.cc
--- a/src/OPERATORS/op-sbm-b.cc
+++ b/src/OPERATORS/op-sbm-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -42,33 +42,33 @@ DEFBINOP_FN (ne, sparse_bool_matrix, boo
 DEFBINOP_FN (eq, sparse_bool_matrix, bool, mx_el_eq)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool, mx_el_and)
 DEFBINOP_FN (el_or, sparse_bool_matrix, bool, mx_el_or)
 
 DEFCATOP (sbm_b, sparse_bool_matrix, bool)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&); 
-		   
+                   
   SparseBoolMatrix tmp (1, 1, v2.bool_value ());
   return octave_value (v1.sparse_bool_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sm_b, sparse_matrix, bool)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool&);
-		   
+                   
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sbm_s, sparse_bool_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_scalar&); 
-		   
+                   
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_bool_matrix, bool)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&);
 
diff --git a/src/OPERATORS/op-sbm-bm.cc b/src/OPERATORS/op-sbm-bm.cc
--- a/src/OPERATORS/op-sbm-bm.cc
+++ b/src/OPERATORS/op-sbm-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -45,33 +45,33 @@ DEFBINOP_FN (eq, sparse_bool_matrix, boo
 DEFBINOP_FN (ne, sparse_bool_matrix, bool_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, bool_matrix, mx_el_or)
 
 DEFCATOP (sbm_bm, sparse_bool_matrix, bool_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&); 
-		   
+                   
   SparseBoolMatrix tmp (v2.bool_matrix_value ());
   return octave_value (v1.sparse_bool_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sbm_m, sparse_bool_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_matrix&);
-		   
+                   
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sm_bm, sparse_matrix, bool_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool_matrix&); 
-		   
+                   
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_bool_matrix, bool_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&);
 
@@ -81,25 +81,25 @@ DEFASSIGNOP (assign, sparse_bool_matrix,
 
 void
 install_sbm_bm_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_sparse_bool_matrix, octave_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_sparse_bool_matrix, octave_bool_matrix, ne);
 
   INSTALL_BINOP (op_el_and, octave_sparse_bool_matrix, octave_bool_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_bool_matrix, octave_bool_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_bool_matrix, sbm_bm);
   INSTALL_CATOP (octave_sparse_matrix, octave_bool_matrix, sm_bm);
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_matrix, sbm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, 
-		    octave_bool_matrix, assign);
+                    octave_bool_matrix, assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-sbm-sbm.cc b/src/OPERATORS/op-sbm-sbm.cc
--- a/src/OPERATORS/op-sbm-sbm.cc
+++ b/src/OPERATORS/op-sbm-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2007 David Bateman
+Copyright (C) 2004, 2005, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -61,24 +61,24 @@ DEFUNOP (transpose, sparse_bool_matrix)
 // sparse bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (el_and, sparse_bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, sparse_bool_matrix, mx_el_or)
 
 DEFNDCATOP_FN (sbm_sbm, sparse_bool_matrix, sparse_bool_matrix, 
-	       sparse_bool_matrix, sparse_bool_matrix, concat)
+               sparse_bool_matrix, sparse_bool_matrix, concat)
 DEFNDCATOP_FN (sbm_sm, sparse_bool_matrix, sparse_matrix, sparse_matrix, 
-	       sparse_matrix, concat)
+               sparse_matrix, concat)
 DEFNDCATOP_FN (sm_sbm, sparse_matrix, sparse_bool_matrix, sparse_matrix, 
-	       sparse_matrix, concat)
+               sparse_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_bool_matrix, sparse_bool_matrix, 
-		assign)
+                assign)
 
 CONVDECL (bool_matrix_to_double_matrix)
 {
   CAST_CONV_ARG (const octave_sparse_bool_matrix&);
 
   return new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
 }
 
@@ -87,34 +87,34 @@ install_sbm_sbm_ops (void)
 {
   INSTALL_UNOP (op_not, octave_sparse_bool_matrix, not);
   INSTALL_UNOP (op_uplus, octave_sparse_bool_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_sparse_bool_matrix, uminus);
   INSTALL_UNOP (op_transpose, octave_sparse_bool_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_sparse_bool_matrix, transpose);
 
   INSTALL_BINOP (op_eq, octave_sparse_bool_matrix, 
-		 octave_sparse_bool_matrix, eq);
+                 octave_sparse_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_sparse_bool_matrix, 
-		 octave_sparse_bool_matrix, ne);
+                 octave_sparse_bool_matrix, ne);
 
   INSTALL_BINOP (op_el_and, octave_sparse_bool_matrix, 
-		 octave_sparse_bool_matrix, el_and);
+                 octave_sparse_bool_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_bool_matrix, 
-		 octave_sparse_bool_matrix, el_or);
+                 octave_sparse_bool_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_bool_matrix, 
-		 sbm_sbm);
+                 sbm_sbm);
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_matrix, sbm_sm);
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_bool_matrix, sm_sbm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, 
-		    octave_sparse_bool_matrix, assign); 
+                    octave_sparse_bool_matrix, assign); 
 
   INSTALL_CONVOP (octave_sparse_bool_matrix, octave_sparse_matrix, 
-		  bool_matrix_to_double_matrix);
+                  bool_matrix_to_double_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -44,21 +44,21 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, sparse_complex_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-			    v2.complex_matrix_value (), typ);
+                            v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -69,26 +69,26 @@ DEFBINOP (ldiv, sparse_complex_matrix, c
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-		      v2.complex_matrix_value (), typ);
+                      v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (trans_mul, sparse_complex_matrix, complex_matrix, trans_mul);
 DEFBINOP_FN (herm_mul, sparse_complex_matrix, complex_matrix, herm_mul);
@@ -101,102 +101,102 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
   
   return octave_value 
     (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix 
-		(v2.complex_matrix_value ())));
+                (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
 
   return octave_value (quotient (v2.complex_matrix_value (), 
-				 v1.sparse_complex_matrix_value ()));
+                                 v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (scm_cm, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value
     (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&,
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, add);
+                 octave_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, sub);
+                 octave_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, mul);
+                 octave_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, div);
+                 octave_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, pow);
+                 octave_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, ldiv);
+                 octave_complex_matrix, ldiv);
   INSTALL_BINOP (op_trans_mul, octave_sparse_complex_matrix, 
                  octave_complex_matrix, trans_mul);
   INSTALL_BINOP (op_herm_mul, octave_sparse_complex_matrix, 
                  octave_complex_matrix, herm_mul);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, lt);
+                 octave_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, le);
+                 octave_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, eq);
+                 octave_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, ge);
+                 octave_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, gt);
+                 octave_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, ne);
+                 octave_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, el_mul);
+                 octave_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, el_div);
+                 octave_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, el_pow);
+                 octave_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, el_ldiv);
+                 octave_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, el_and);
+                 octave_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, 
-		 octave_complex_matrix, el_or);
+                 octave_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, 
-		 octave_complex_matrix, scm_cm);
+                 octave_complex_matrix, scm_cm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
-		    octave_complex_matrix, assign);
+                    octave_complex_matrix, assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -42,46 +42,46 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex&);
+                   const octave_complex&);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex&);
+                   const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
       ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
@@ -98,17 +98,17 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex&);
+                   const octave_complex&);
 
   octave_value retval;
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
@@ -117,17 +117,17 @@ DEFBINOP (el_div, sparse_complex_matrix,
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex&);
+                   const octave_complex&);
 
   return octave_value
     (x_el_div (v2.complex_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex, mx_el_or)
 
@@ -152,39 +152,39 @@ void
 install_scm_cs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_complex, add);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_complex, sub);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_complex, mul);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_complex, div);
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, octave_complex, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_complex, 
-		 ldiv);
+                 ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_complex, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_complex, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_complex, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_complex, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_complex, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_complex, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_complex, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_complex, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_complex, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_complex, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_complex, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_complex, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_complex, scm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_complex,
-		    assign);
+                    assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -49,17 +49,17 @@ DEFBINOP_OP (mul, sparse_complex_matrix,
 
 DEFBINOP (div, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
                    const octave_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-			    v2.matrix_value (), typ);
+                            v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -70,26 +70,26 @@ DEFBINOP (ldiv, sparse_complex_matrix, m
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
   
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-				    v2.matrix_value (), typ);
+                                    v2.matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, matrix, mx_el_le)
@@ -99,27 +99,27 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_matrix&);
+                   const octave_matrix&);
   
   return octave_value 
     (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix 
-		(v2.matrix_value ())));
+                (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_matrix&);
+                   const octave_matrix&);
 
   return octave_value
     (quotient (v2.matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, matrix, mx_el_or)
 
@@ -151,31 +151,31 @@ install_scm_m_ops (void)
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_matrix, scm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_matrix, 
-		    assign);
+                    assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -45,33 +45,33 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, scalar, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, scalar, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (div, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_scalar&);
+                   const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_scalar&);
+                   const octave_scalar&);
 
   double tmp = v2.scalar_value ();
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_complex_matrix_value (), tmp);
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
@@ -79,17 +79,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, s
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
       Matrix m2 = Matrix (1, 1, v2.scalar_value ());
@@ -106,17 +106,17 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, scalar, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_scalar&);
+                   const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
@@ -165,31 +165,31 @@ install_scm_s_ops (void)
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_scalar, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_scalar, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_scalar, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_scalar, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_scalar, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_scalar, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_scalar, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_scalar, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_scalar, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_scalar, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_scalar, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_scalar, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_scalar, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_scalar, scm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_scalar, 
-		    assign);
+                    assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -93,65 +93,65 @@ DEFUNOP (decr, sparse_complex_matrix)
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
  
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
-				      v2.sparse_complex_matrix_value (), typ);
+                                      v2.sparse_complex_matrix_value (), typ);
   
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret = 
-	xleftdiv (v1.sparse_complex_matrix_value (), 
-		  v2.sparse_complex_matrix_value (), typ);
+        xleftdiv (v1.sparse_complex_matrix_value (), 
+                  v2.sparse_complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_complex_matrix, mx_el_le)
@@ -162,20 +162,20 @@ DEFBINOP_FN (ne, sparse_complex_matrix, 
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (), 
-				 v1.sparse_complex_matrix_value ()));
+                                 v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP_FN (scm_scm, sparse_complex_matrix, sparse_complex_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_complex_matrix, sparse_complex_matrix, assign)
@@ -192,57 +192,57 @@ install_scm_scm_ops (void)
   INSTALL_UNOP (op_hermitian, octave_sparse_complex_matrix, hermitian);
 
 #if 0
   INSTALL_NCUNOP (op_incr, octave_sparse_complex_matrix, incr);
   INSTALL_NCUNOP (op_decr, octave_sparse_complex_matrix, decr);
 #endif
 
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, add);
+                 octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, sub);
+                 octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, mul);
+                 octave_sparse_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, div);
+                 octave_sparse_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, pow);
+                 octave_sparse_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, ldiv);
+                 octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, lt);
+                 octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, le);
+                 octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, eq);
+                 octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, ge);
+                 octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, gt);
+                 octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, ne);
+                 octave_sparse_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, el_mul);
+                 octave_sparse_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, el_div);
+                 octave_sparse_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, el_pow);
+                 octave_sparse_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, el_ldiv);
+                 octave_sparse_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, el_and);
+                 octave_sparse_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, el_or);
+                 octave_sparse_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, 
-		 octave_sparse_complex_matrix, scm_scm);
+                 octave_sparse_complex_matrix, scm_scm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
-		    octave_sparse_complex_matrix, assign);
+                    octave_sparse_complex_matrix, assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
                     octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
                     octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
                     octave_null_sq_str, null_assign);
 }
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -49,25 +49,25 @@ DEFBINOP (div, sparse_complex_matrix, sp
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
-				      v2.sparse_matrix_value (), typ);
+                                      v2.sparse_matrix_value (), typ);
   
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
@@ -79,26 +79,26 @@ DEFBINOP (ldiv, sparse_complex_matrix, s
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-					  v2.sparse_matrix_value (), typ);
+                                          v2.sparse_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_matrix, mx_el_le)
@@ -109,72 +109,72 @@ DEFBINOP_FN (ne, sparse_complex_matrix, 
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_sparse_matrix&);
+                   const octave_sparse_matrix&);
 
   return octave_value
     (quotient (v2.sparse_matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP_FN (scm_sm, sparse_complex_matrix, sparse_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_complex_matrix, sparse_matrix, assign)
 
 void
 install_scm_sm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_sparse_matrix,
-		 add);
+                 add);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_sparse_matrix,
-		 sub);
+                 sub);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_sparse_matrix,
-		 mul);
+                 mul);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_sparse_matrix,
-		 div);
+                 div);
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, octave_sparse_matrix,
-		 pow);
+                 pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_sparse_matrix,
-		 ldiv);
+                 ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_sparse_matrix, 
-		 lt);
+                 lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_sparse_matrix, 
-		 le);
+                 le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_sparse_matrix, 
-		 eq);
+                 eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_sparse_matrix, 
-		 ge);
+                 ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_sparse_matrix, 
-		 gt);
+                 gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_sparse_matrix, 
-		 ne);
+                 ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, 
-		 octave_sparse_matrix, el_mul);
+                 octave_sparse_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, 
-		 octave_sparse_matrix, el_div);
+                 octave_sparse_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix,
-		 octave_sparse_matrix, el_pow);
+                 octave_sparse_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, 
-		 octave_sparse_matrix, el_ldiv);
+                 octave_sparse_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, 
-		 octave_sparse_matrix, el_and);
+                 octave_sparse_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, 
-		 octave_sparse_matrix, el_or);
+                 octave_sparse_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_sparse_matrix, scm_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
-		    octave_sparse_matrix, assign);
+                    octave_sparse_matrix, assign);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -44,21 +44,21 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, sparse_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
   
   ComplexMatrix ret = xdiv (v1.matrix_value (), 
-			    v2.complex_matrix_value (), typ);
+                            v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -69,26 +69,26 @@ DEFBINOP (ldiv, sparse_matrix, complex_m
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
-				    v2.complex_matrix_value (), typ);
+                                    v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex_matrix, mx_el_le)
@@ -98,27 +98,27 @@ DEFBINOP_FN (gt, sparse_matrix, complex_
 DEFBINOP_FN (ne, sparse_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
   
   return octave_value 
     (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix 
-		(v2.complex_matrix_value ())));
+                (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, 
-		   const octave_complex_matrix&);
+                   const octave_complex_matrix&);
 
   return octave_value 
     (quotient (v2.complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, complex_matrix, mx_el_or)
 
@@ -146,34 +146,34 @@ install_sm_cm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_sparse_matrix, octave_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_matrix, octave_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_matrix, octave_complex_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_matrix, octave_complex_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_complex_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_complex_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_complex_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_complex_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_complex_matrix, sm_cm);
 
   INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_complex_matrix, 
-		      octave_sparse_complex_matrix);
+                      octave_sparse_complex_matrix);
 
   INSTALL_WIDENOP (octave_sparse_matrix, octave_complex_matrix, 
-		   sparse_complex_matrix_conv);
+                   sparse_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -71,17 +71,17 @@ DEFBINOP (ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseMatrix m1 = v1.sparse_matrix_value ();
       ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
@@ -117,17 +117,17 @@ DEFBINOP (el_div, sparse_matrix, complex
 
 DEFBINOP_FN (el_pow, sparse_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
   return octave_value (x_el_div (v2.complex_value (), 
-				 v1.sparse_matrix_value ()));
+                                 v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or, sparse_matrix, complex, mx_el_or)
 
 DEFCATOP (sm_cs, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex&);
@@ -156,16 +156,16 @@ install_sm_cs_ops (void)
   INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_complex, el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_complex, sm_cs);
 
   INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_complex,
-		      octave_sparse_complex_matrix);
+                      octave_sparse_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -67,26 +67,26 @@ DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
-			     v2.matrix_value (), typ);
+                             v2.matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (trans_mul, sparse_matrix, matrix, trans_mul);
 
@@ -100,17 +100,17 @@ DEFBINOP_FN (ne, sparse_matrix, matrix, 
 DEFBINOP_FN (el_mul, sparse_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
   
   return octave_value (elem_xpow (v1.sparse_matrix_value (), 
-				  SparseMatrix (v2.matrix_value ())));
+                                  SparseMatrix (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
   
   return octave_value
     (quotient (v2.matrix_value (), v1.sparse_matrix_value ()));
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -73,17 +73,17 @@ DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (SparseMatrix(1, 1, v2.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseMatrix m1 = v1.sparse_matrix_value ();
       Matrix m2 = Matrix (1, 1, v2.scalar_value ());
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -49,25 +49,25 @@ DEFBINOP (div, sparse_matrix, sparse_com
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
-				  v2.sparse_complex_matrix_value (), typ);
+                                  v2.sparse_complex_matrix_value (), typ);
   
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
@@ -79,27 +79,27 @@ DEFBINOP (ldiv, sparse_matrix, sparse_co
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret = 
-	xleftdiv (v1.sparse_matrix_value (), 
-		  v2.sparse_complex_matrix_value (), typ);
+        xleftdiv (v1.sparse_matrix_value (), 
+                  v2.sparse_complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_complex_matrix, mx_el_le)
@@ -110,17 +110,17 @@ DEFBINOP_FN (ne, sparse_matrix, sparse_c
 
 DEFBINOP_FN (el_mul, sparse_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, 
-		   const octave_sparse_complex_matrix&);
+                   const octave_sparse_complex_matrix&);
 
   return octave_value
     (quotient (v2.sparse_complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_complex_matrix, mx_el_or)
 
@@ -131,58 +131,58 @@ DEFCONV (sparse_complex_matrix_conv, spa
   CAST_CONV_ARG (const octave_sparse_matrix&);
   return new octave_sparse_complex_matrix (v.sparse_complex_matrix_value ());
 }
 
 void
 install_sm_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_sparse_complex_matrix,
-		 add);
+                 add);
   INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_sparse_complex_matrix,
-		 sub);
+                 sub);
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_sparse_complex_matrix,
-		 mul);
+                 mul);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_sparse_complex_matrix,
-		 div);
+                 div);
   INSTALL_BINOP (op_pow, octave_sparse_matrix, octave_sparse_complex_matrix,
-		 pow);
+                 pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_matrix, octave_sparse_complex_matrix,
-		 ldiv);
+                 ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_sparse_complex_matrix, 
-		 lt);
+                 lt);
   INSTALL_BINOP (op_le, octave_sparse_matrix, octave_sparse_complex_matrix, 
-		 le);
+                 le);
   INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_sparse_complex_matrix, 
-		 eq);
+                 eq);
   INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_sparse_complex_matrix, 
-		 ge);
+                 ge);
   INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_sparse_complex_matrix, 
-		 gt);
+                 gt);
   INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_sparse_complex_matrix, 
-		 ne);
+                 ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_matrix, 
-		 octave_sparse_complex_matrix, el_mul);
+                 octave_sparse_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_matrix, 
-		 octave_sparse_complex_matrix, el_div);
+                 octave_sparse_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_matrix, 
-		 octave_sparse_complex_matrix, el_pow);
+                 octave_sparse_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, 
-		 octave_sparse_complex_matrix, el_ldiv);
+                 octave_sparse_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, 
-		 octave_sparse_complex_matrix, el_and);
+                 octave_sparse_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, 
-		 octave_sparse_complex_matrix, el_or);
+                 octave_sparse_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_complex_matrix, sm_scm);
 
   INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_sparse_complex_matrix, 
-		      octave_sparse_complex_matrix);
+                      octave_sparse_complex_matrix);
 
   INSTALL_WIDENOP (octave_sparse_matrix, octave_sparse_complex_matrix, 
-		   sparse_complex_matrix_conv);
+                   sparse_complex_matrix_conv);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004, 2005, 2006, 2007, 2008 David Bateman
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 DEFUNOP_OP (not, sparse_matrix, !)
 DEFUNOP_OP (uplus, sparse_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_matrix, -)
 
 DEFUNOP (transpose, sparse_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_matrix&);
   return octave_value (v.sparse_matrix_value().transpose (),
-		       v.matrix_type ().transpose ());
+                       v.matrix_type ().transpose ());
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 
 // DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
 
@@ -72,25 +72,25 @@ DEFBINOP (div, sparse_matrix, sparse_mat
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
-			       v2.sparse_matrix_value (), typ);
+                               v2.sparse_matrix_value (), typ);
   
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
@@ -102,26 +102,26 @@ DEFBINOP (ldiv, sparse_matrix, sparse_ma
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       double d = v1.double_value ();
 
       if (d == 0.0)
-	gripe_divide_by_zero ();
+        gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
-				   v2.sparse_matrix_value (), typ);
+                                   v2.sparse_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_matrix, mx_el_le)
@@ -168,32 +168,32 @@ install_sm_sm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_sparse_matrix, octave_sparse_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_sparse_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_sparse_matrix, octave_sparse_matrix, 
-		 el_mul);
+                 el_mul);
   INSTALL_BINOP (op_el_div, octave_sparse_matrix, octave_sparse_matrix, 
-		 el_div);
+                 el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_sparse_matrix, 
-		 el_pow);
+                 el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_sparse_matrix, 
-		 el_ldiv);
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_sparse_matrix, 
-		 el_and);
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_sparse_matrix, 
-		 el_or);
+                 el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_matrix, sm_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_sparse_matrix, 
-		    assign);
+                    assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_sq_str, null_assign);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/OPERATORS/op-str-m.cc b/src/OPERATORS/op-str-m.cc
--- a/src/OPERATORS/op-str-m.cc
+++ b/src/OPERATORS/op-str-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003, 2004, 2005, 2007 John W. Eaton
+Copyright (C) 2003, 2004, 2005, 2007, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_matrix&);
 
   octave_value tmp
     = v2.convert_to_str_internal (false, false,
-				  a1.is_sq_string () ? '\'' : '"');
+                                  a1.is_sq_string () ? '\'' : '"');
 
   if (! error_state)
     v1.assign (idx, tmp.char_matrix_value ());
 
   return octave_value ();
 }
 
 DEFNDCHARCATOP_FN (str_m, char_matrix_str, matrix, concat)
diff --git a/src/OPERATORS/op-str-s.cc b/src/OPERATORS/op-str-s.cc
--- a/src/OPERATORS/op-str-s.cc
+++ b/src/OPERATORS/op-str-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003, 2004, 2005, 2007 John W. Eaton
+Copyright (C) 2003, 2004, 2005, 2007, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_scalar&);
 
   octave_value tmp
     = v2.convert_to_str_internal (false, false,
- 				  a1.is_sq_string () ? '\'' : '"');
+                                  a1.is_sq_string () ? '\'' : '"');
 
   if (! error_state)
     v1.assign (idx, tmp.char_matrix_value ());
 
   return octave_value ();
 }
 
 DEFNDCHARCATOP_FN (str_s, char_matrix_str, scalar, concat)
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007, 2008
-              John W. Eaton
+Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007,
+              2008, 2009John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -41,45 +41,45 @@ DEFUNOP (transpose, char_matrix_str)
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
     return octave_value (v.char_matrix_value().transpose (),
-			 a.is_sq_string () ? '\'' : '"');
+                         a.is_sq_string () ? '\'' : '"');
 }
 
 // string by string ops.
 
-#define DEFCHARNDBINOP_FN(name, op, t1, t2, e1, e2, f)	\
+#define DEFCHARNDBINOP_FN(name, op, t1, t2, e1, e2, f)  \
   BINOPDECL (name, a1, a2) \
   { \
     dim_vector a1_dims = a1.dims (); \
     dim_vector a2_dims = a2.dims (); \
  \
     bool a1_is_scalar = a1_dims.all_ones (); \
     bool a2_is_scalar = a2_dims.all_ones (); \
  \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
  \
     if (a1_is_scalar) \
       { \
-	if (a2_is_scalar) \
-	  return octave_value ((v1.e1 ## _value ())(0) op (v2.e2 ## _value ())(0)); \
-	else \
-	  return octave_value (f ((v1.e1 ## _value ())(0), v2.e2 ## _value ())); \
+        if (a2_is_scalar) \
+          return octave_value ((v1.e1 ## _value ())(0) op (v2.e2 ## _value ())(0)); \
+        else \
+          return octave_value (f ((v1.e1 ## _value ())(0), v2.e2 ## _value ())); \
       } \
     else \
       { \
-	if (a2_is_scalar) \
-	  return octave_value (f (v1.e1 ## _value (), (v2.e2 ## _value ())(0))); \
-	else \
-	  return octave_value (f (v1.e1 ## _value (), v2.e2 ## _value ())); \
+        if (a2_is_scalar) \
+          return octave_value (f (v1.e1 ## _value (), (v2.e2 ## _value ())(0))); \
+        else \
+          return octave_value (f (v1.e1 ## _value (), v2.e2 ## _value ())); \
       } \
   }
 
 DEFCHARNDBINOP_FN (lt, <, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_lt)
 DEFCHARNDBINOP_FN (le, <=, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_le)
 DEFCHARNDBINOP_FN (eq, ==, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_eq)
 DEFCHARNDBINOP_FN (ge, >=, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_ge)
 DEFCHARNDBINOP_FN (gt, >, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_gt)
diff --git a/src/OPERATORS/op-struct.cc b/src/OPERATORS/op-struct.cc
--- a/src/OPERATORS/op-struct.cc
+++ b/src/OPERATORS/op-struct.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996, 1997, 2004, 2005, 2007, 2008 John W. Eaton
+Copyright (C) 1996, 1997, 2004, 2005, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -46,32 +46,32 @@ DEFUNOP (transpose, cell)
   else
     return octave_value (v.map_value().transpose ());
 }
 
 DEFNDCATOP_FN (struct_struct, struct, struct, map, map, concat)
 
 static octave_value
 oct_catop_struct_matrix (octave_base_value& a1, const octave_base_value& a2,
-			 const Array<octave_idx_type>&)
+                         const Array<octave_idx_type>&)
 {
   octave_value retval;
   CAST_BINOP_ARGS (const octave_struct&, const octave_matrix&);
   NDArray tmp = v2.array_value ();
   dim_vector dv = tmp.dims ();
   if (dv.all_zero ())
     retval = octave_value (v1.map_value ());
   else
     error ("invalid concatenation of structure with matrix");
   return retval;
 }
 
 static octave_value
 oct_catop_matrix_struct (octave_base_value& a1, const octave_base_value& a2,
-			 const Array<octave_idx_type>&)
+                         const Array<octave_idx_type>&)
 {
   octave_value retval;
   CAST_BINOP_ARGS (const octave_matrix&, const octave_struct&);
   NDArray tmp = v1.array_value ();
   dim_vector dv = tmp.dims ();
   if (dv.all_zero ())
     retval = octave_value (v2.map_value ());
   else
