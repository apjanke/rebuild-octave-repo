# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1453843854 18000
#      Tue Jan 26 16:30:54 2016 -0500
# Node ID 307096fb67e14016af0ee0f9d856588633afd843
# Parent  76e0ef020dae2bac7d03540ab7a1dc3073afa0be
revamp sparse Cholesky factorization classes

* sparse-chol.h, sparse-chol.cc: Rename from sparse-base-chol.h and
sparse-base-chol.cc, respectively.
(class sparse_chol): Rename from sparse_base_chol.  Incorporate code
from SparseCmplxCHOL and SparsedbleCHOL classes into the sparse_chol
template.  Hide representation and HAVE_CHOLMOD macro from public
interface.

* sparse-chol-inst.cc: New file.

* SparseCmplxCHOL.cc, SparseCmplxCHOL.h, SparsedbleCHOL.cc,
SparsedbleCHOL.h: Delete.

* chol.cc, symbfact.cc, CSparse.cc, dSparse.cc, eigs-base.cc: Change
all uses of SparsedbleCHOL and SparseCmplxCHOL to use new
sparse_chol template class.

* liboctave/numeric/module.mk: Update.

diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -26,18 +26,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxCHOL.h"
 #include "dbleCHOL.h"
 #include "fCmplxCHOL.h"
 #include "floatCHOL.h"
-#include "SparseCmplxCHOL.h"
-#include "SparsedbleCHOL.h"
+#include "sparse-chol.h"
 #include "oct-spparms.h"
 #include "sparse-util.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
@@ -189,17 +188,17 @@ sparse matrices.\n\
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
 
       if (arg.is_real_type ())
         {
           SparseMatrix m = arg.sparse_matrix_value ();
 
-          SparseCHOL fact (m, info, natural, force);
+          sparse_chol<SparseMatrix> fact (m, info, natural, force);
 
           if (nargout == 3)
             {
               if (vecout)
                 retval(2) = fact.perm ();
               else
                 retval(2) = fact.Q ();
             }
@@ -214,17 +213,17 @@ sparse matrices.\n\
             }
           else
             error ("chol: input matrix must be positive definite");
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-          SparseComplexCHOL fact (m, info, natural, force);
+          sparse_chol<SparseComplexMatrix> fact (m, info, natural, force);
 
           if (nargout == 3)
             {
               if (vecout)
                 retval(2) = fact.perm ();
               else
                 retval(2) = fact.Q ();
             }
@@ -353,28 +352,28 @@ the Cholesky@tie{}factorization.\n\
       if (arg.is_sparse_type ())
         {
           octave_idx_type info;
 
           if (arg.is_real_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
-              SparseCHOL chol (m, info);
+              sparse_chol<SparseMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-              SparseComplexCHOL chol (m, info);
+              sparse_chol<SparseComplexMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("cholinv", arg);
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -20,18 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "SparseCmplxCHOL.h"
-#include "SparsedbleCHOL.h"
+#include "sparse-chol.h"
 #include "oct-spparms.h"
 #include "sparse-util.h"
 #include "oct-locbuf.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -49,17 +49,17 @@ along with Octave; see the file COPYING.
 #include "CSparse.h"
 #include "boolSparse.h"
 #include "dSparse.h"
 #include "functor.h"
 #include "oct-spparms.h"
 #include "SparseCmplxLU.h"
 #include "oct-sparse.h"
 #include "sparse-util.h"
-#include "SparseCmplxCHOL.h"
+#include "sparse-chol.h"
 #include "SparseCmplxQR.h"
 
 #include "Sparse-op-defs.h"
 
 #include "Sparse-diag-op-defs.h"
 
 #include "Sparse-perm-op-defs.h"
 
@@ -1074,17 +1074,17 @@ SparseComplexMatrix::inverse (MatrixType
       MatrixType newtype = mattype.transpose ();
       ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
-          SparseComplexCHOL fact (*this, info, false);
+          sparse_chol<SparseComplexMatrix> fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseComplexMatrix InvL = fact.L ().transpose ().
                                          tinverse (tmp_typ, info, rcond2,
                                                    true, false);
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "boolSparse.h"
 #include "dSparse.h"
 #include "functor.h"
 #include "oct-spparms.h"
 #include "SparsedbleLU.h"
 #include "MatrixType.h"
 #include "oct-sparse.h"
 #include "sparse-util.h"
-#include "SparsedbleCHOL.h"
+#include "sparse-chol.h"
 #include "SparseQR.h"
 
 #include "Sparse-op-defs.h"
 
 #include "Sparse-diag-op-defs.h"
 
 #include "Sparse-perm-op-defs.h"
 
@@ -1164,17 +1164,17 @@ SparseMatrix::inverse (MatrixType &matty
       MatrixType newtype = mattype.transpose ();
       ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
-          SparseCHOL fact (*this, info, false);
+          sparse_chol<SparseMatrix> fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                                   info, rcond2, true, false);
               ret = Q * InvL.transpose () * InvL * Q.transpose ();
diff --git a/liboctave/numeric/SparseCmplxCHOL.cc b/liboctave/numeric/SparseCmplxCHOL.cc
deleted file mode 100644
--- a/liboctave/numeric/SparseCmplxCHOL.cc
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
-
-Copyright (C) 2005-2015 David Bateman
-Copyright (C) 1998-2005 Andy Adler
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SparseCmplxCHOL.h"
-
-// Instantiate the base CHOL class for the type we need
-#define OCTAVE_CHOLMOD_TYPE CHOLMOD_COMPLEX
-#include "sparse-base-chol.h"
-#include "sparse-base-chol.cc"
-template class sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>;
-
-// Compute the inverse of a matrix using the Cholesky factorization.
-SparseComplexMatrix
-chol2inv (const SparseComplexMatrix& r)
-{
-  octave_idx_type r_nr = r.rows ();
-  octave_idx_type r_nc = r.cols ();
-
-  if (r_nr != r_nc)
-    (*current_liboctave_error_handler) ("U must be a square matrix");
-
-  SparseComplexMatrix retval;
-  MatrixType mattype (r);
-  int typ = mattype.type (false);
-  double rcond;
-  octave_idx_type info;
-  SparseComplexMatrix rinv;
-
-  if (typ == MatrixType::Upper)
-    {
-      rinv = r.inverse (mattype, info, rcond, true, false);
-      retval = rinv.transpose () * rinv;
-    }
-  else if (typ == MatrixType::Lower)
-    {
-      rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
-      retval = rinv.transpose () * rinv;
-    }
-  else
-    (*current_liboctave_error_handler) ("U must be a triangular matrix");
-
-  return retval;
-}
diff --git a/liboctave/numeric/SparseCmplxCHOL.h b/liboctave/numeric/SparseCmplxCHOL.h
deleted file mode 100644
--- a/liboctave/numeric/SparseCmplxCHOL.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-
-Copyright (C) 2005-2015 David Bateman
-Copyright (C) 1998-2005 Andy Adler
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_SparseCmplxCHOL_h)
-#define octave_SparseCmplxCHOL_h 1
-
-#include "sparse-base-chol.h"
-#include "dSparse.h"
-#include "CSparse.h"
-
-class
-OCTAVE_API
-SparseComplexCHOL
-  : public sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>
-{
-public:
-
-  SparseComplexCHOL (void)
-    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> () { }
-
-  SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true,
-                     bool force = false)
-    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
-       (a, natural, force) { }
-
-  SparseComplexCHOL (const SparseComplexMatrix& a, octave_idx_type& info,
-                     bool natural = true, bool force = false)
-    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
-       (a, info, natural, force) { }
-
-  SparseComplexCHOL (const SparseComplexCHOL& a)
-    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a) { }
-
-  ~SparseComplexCHOL (void) { }
-
-  SparseComplexCHOL& operator = (const SparseComplexCHOL& a)
-  {
-    if (this != &a)
-      sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
-      operator = (a);
-
-    return *this;
-  }
-
-  SparseComplexMatrix chol_matrix (void) const { return R (); }
-
-  SparseComplexMatrix L (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: L ();
-  }
-
-  SparseComplexMatrix R (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: R ();
-  }
-
-  octave_idx_type P (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: P ();
-  }
-
-  ColumnVector perm (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex,
-                            SparseMatrix>:: perm ();
-  }
-
-  SparseMatrix Q (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: Q ();
-  }
-
-  double rcond (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex,
-                            SparseMatrix>:: rcond ();
-  }
-
-  // Compute the inverse of a matrix using the Cholesky factorization.
-  SparseComplexMatrix inverse (void) const
-  {
-    return sparse_base_chol<SparseComplexMatrix, Complex,
-                            SparseMatrix>:: inverse ();
-  }
-};
-
-SparseComplexMatrix OCTAVE_API chol2inv (const SparseComplexMatrix& r);
-
-#endif
diff --git a/liboctave/numeric/SparsedbleCHOL.cc b/liboctave/numeric/SparsedbleCHOL.cc
deleted file mode 100644
--- a/liboctave/numeric/SparsedbleCHOL.cc
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
-
-Copyright (C) 2005-2015 David Bateman
-Copyright (C) 1998-2005 Andy Adler
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SparsedbleCHOL.h"
-
-// Instantiate the base CHOL class for the type we need
-#define OCTAVE_CHOLMOD_TYPE CHOLMOD_REAL
-#include "sparse-base-chol.h"
-#include "sparse-base-chol.cc"
-template class sparse_base_chol <SparseMatrix, double, SparseMatrix>;
-
-// Compute the inverse of a matrix using the Cholesky factorization.
-SparseMatrix
-chol2inv (const SparseMatrix& r)
-{
-  octave_idx_type r_nr = r.rows ();
-  octave_idx_type r_nc = r.cols ();
-  SparseMatrix retval;
-
-  if (r_nr != r_nc)
-    (*current_liboctave_error_handler) ("U must be a square matrix");
-
-  MatrixType mattype (r);
-  int typ = mattype.type (false);
-  double rcond;
-  octave_idx_type info;
-  SparseMatrix rinv;
-
-  if (typ == MatrixType::Upper)
-    {
-      rinv = r.inverse (mattype, info, rcond, true, false);
-      retval = rinv.transpose () * rinv;
-    }
-  else if (typ == MatrixType::Lower)
-    {
-      rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
-      retval = rinv.transpose () * rinv;
-    }
-  else
-    (*current_liboctave_error_handler) ("U must be a triangular matrix");
-
-  return retval;
-}
diff --git a/liboctave/numeric/SparsedbleCHOL.h b/liboctave/numeric/SparsedbleCHOL.h
deleted file mode 100644
--- a/liboctave/numeric/SparsedbleCHOL.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-
-Copyright (C) 2005-2015 David Bateman
-Copyright (C) 1998-2005 Andy Adler
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_SparsedbleCHOL_h)
-#define octave_SparsedbleCHOL_h 1
-
-#include "sparse-base-chol.h"
-#include "dSparse.h"
-
-class
-OCTAVE_API
-SparseCHOL : public sparse_base_chol <SparseMatrix, double, SparseMatrix>
-{
-public:
-
-  SparseCHOL (void) : sparse_base_chol<SparseMatrix, double, SparseMatrix> ()
-  { }
-
-  SparseCHOL (const SparseMatrix& a, bool natural = true, bool force = false)
-    : sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural, force)
-  { }
-
-  SparseCHOL (const SparseMatrix& a, octave_idx_type& info,
-              bool natural = false, bool force = false)
-    : sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural,
-                                                            force)
-  { }
-
-  SparseCHOL (const SparseCHOL& a) :
-    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a) { }
-
-  ~SparseCHOL (void) { }
-
-  SparseCHOL& operator = (const SparseCHOL& a)
-  {
-    if (this != &a)
-      sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
-
-    return *this;
-  }
-
-  SparseMatrix chol_matrix (void) const { return R (); }
-
-  SparseMatrix L (void) const
-  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: L (); }
-
-  SparseMatrix R (void) const
-  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: R (); }
-
-  octave_idx_type P (void) const
-  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: P (); }
-
-  ColumnVector perm (void) const
-  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: perm (); }
-
-  SparseMatrix Q (void) const
-  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: Q (); }
-
-  double rcond (void) const
-  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: rcond (); }
-
-  // Compute the inverse of a matrix using the Cholesky factorization.
-  SparseMatrix inverse (void) const
-  {
-    return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: inverse ();
-  }
-};
-
-SparseMatrix OCTAVE_API chol2inv (const SparseMatrix& r);
-
-#endif
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -32,18 +32,17 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "SparsedbleLU.h"
 #include "SparseCmplxLU.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "MatrixType.h"
-#include "SparsedbleCHOL.h"
-#include "SparseCmplxCHOL.h"
+#include "sparse-chol.h"
 #include "oct-rand.h"
 #include "dbleCHOL.h"
 #include "CmplxCHOL.h"
 #include "dbleLU.h"
 #include "CmplxLU.h"
 
 #ifdef HAVE_ARPACK
 typedef ColumnVector (*EigsFunc) (const ColumnVector &x, int &eigs_error);
@@ -365,17 +364,17 @@ make_cholb (Matrix& b, Matrix& bt, Colum
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
-  SparseCHOL fact (b, info, false);
+  sparse_chol<SparseMatrix> fact (b, info, false);
 
   if (fact.P () != 0)
     return false;
   else
     {
       b = fact.L ();
       bt = b.transpose ();
       permB = fact.perm () - 1.0;
@@ -403,17 +402,17 @@ make_cholb (ComplexMatrix& b, ComplexMat
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
             ColumnVector& permB)
 {
   octave_idx_type info;
-  SparseComplexCHOL fact (b, info, false);
+  sparse_chol<SparseComplexMatrix> fact (b, info, false);
 
   if (fact.P () != 0)
     return false;
   else
     {
       b = fact.L ();
       bt = b.hermitian ();
       permB = fact.perm () - 1.0;
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -74,22 +74,20 @@ NUMERIC_INC = \
   liboctave/numeric/ODEFunc.h \
   liboctave/numeric/ODE.h \
   liboctave/numeric/ODESFunc.h \
   liboctave/numeric/ODES.h \
   liboctave/numeric/Quad.h \
   liboctave/numeric/randgamma.h \
   liboctave/numeric/randmtzig.h \
   liboctave/numeric/randpoisson.h \
-  liboctave/numeric/sparse-base-chol.h \
+  liboctave/numeric/sparse-chol.h \
   liboctave/numeric/sparse-base-lu.h \
-  liboctave/numeric/SparseCmplxCHOL.h \
   liboctave/numeric/SparseCmplxLU.h \
   liboctave/numeric/SparseCmplxQR.h \
-  liboctave/numeric/SparsedbleCHOL.h \
   liboctave/numeric/SparsedbleLU.h \
   liboctave/numeric/SparseQR.h
 
 NUMERIC_C_SRC = \
   liboctave/numeric/randgamma.c \
   liboctave/numeric/randmtzig.c \
   liboctave/numeric/randpoisson.c
 
@@ -141,30 +139,29 @@ NUMERIC_SRC = \
   liboctave/numeric/LSODE.cc \
   liboctave/numeric/oct-convn.cc \
   liboctave/numeric/oct-fftw.cc \
   liboctave/numeric/oct-norm.cc \
   liboctave/numeric/oct-rand.cc \
   liboctave/numeric/oct-spparms.cc \
   liboctave/numeric/ODES.cc \
   liboctave/numeric/Quad.cc \
-  liboctave/numeric/SparseCmplxCHOL.cc \
   liboctave/numeric/SparseCmplxLU.cc \
   liboctave/numeric/SparseCmplxQR.cc \
-  liboctave/numeric/SparsedbleCHOL.cc \
   liboctave/numeric/SparsedbleLU.cc \
   liboctave/numeric/SparseQR.cc \
+  liboctave/numeric/sparse-chol-inst.cc \
   $(NUMERIC_C_SRC)
 
 LIBOCTAVE_TEMPLATE_SRC += \
   liboctave/numeric/base-lu.cc \
   liboctave/numeric/base-qr.cc \
   liboctave/numeric/bsxfun-defs.cc \
   liboctave/numeric/eigs-base.cc \
-  liboctave/numeric/sparse-base-chol.cc \
+  liboctave/numeric/sparse-chol.cc \
   liboctave/numeric/sparse-base-lu.cc \
   liboctave/numeric/sparse-dmsolve.cc
 
 ## Special rules for sources which must be built before rest of compilation.
 $(LIBOCTAVE_OPT_INC) : %.h : %.in
 	$(AM_V_GEN)rm -f $@-t $@ && \
 	$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-class-header $< > $@-t && \
 	mv $@-t $@
diff --git a/liboctave/numeric/sparse-chol-inst.cc b/liboctave/numeric/sparse-chol-inst.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/numeric/sparse-chol-inst.cc
@@ -0,0 +1,38 @@
+/*
+
+Copyright (C) 2016 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sparse-chol.h"
+#include "sparse-chol.cc"
+
+template class sparse_chol<SparseMatrix>;
+
+template class sparse_chol<SparseComplexMatrix>;
+
+template SparseMatrix
+chol2inv<SparseMatrix> (const SparseMatrix& r);
+
+template SparseComplexMatrix
+chol2inv<SparseComplexMatrix> (const SparseComplexMatrix& r);
diff --git a/liboctave/numeric/sparse-base-chol.cc b/liboctave/numeric/sparse-chol.cc
rename from liboctave/numeric/sparse-base-chol.cc
rename to liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-base-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -20,30 +20,127 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "sparse-base-chol.h"
+#include "sparse-chol.h"
 #include "sparse-util.h"
 #include "lo-error.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "quit.h"
 #include "MatrixType.h"
 
+template <typename chol_type>
+class sparse_chol<chol_type>::sparse_chol_rep
+{
+public:
+
+  sparse_chol_rep (void)
+    : count (1), is_pd (false), minor_p (0), perms (), cond (0),
 #ifdef HAVE_CHOLMOD
-// Can't use CHOLMOD_NAME(drop)(0.0, S, cm). It doesn't treat complex matrices
-template <typename chol_type, typename chol_elt, typename p_type>
+      Lsparse (0), Common ()
+#endif
+  { }
+
+  sparse_chol_rep (const chol_type& a, bool natural, bool force)
+    : count (1), is_pd (false), minor_p (0), perms (), cond (0),
+#ifdef HAVE_CHOLMOD
+      Lsparse (0), Common ()
+#endif
+  {
+    init (a, natural, force);
+  }
+
+  sparse_chol_rep (const chol_type& a, octave_idx_type& info,
+                   bool natural, bool force)
+    : count (1), is_pd (false), minor_p (0), perms (), cond (0),
+#ifdef HAVE_CHOLMOD
+      Lsparse (0), Common ()
+#endif
+  {
+    info = init (a, natural, force);
+  }
+
+  ~sparse_chol_rep (void)
+  {
+#ifdef HAVE_CHOLMOD
+    if (is_pd)
+      CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
+#endif
+  }
+
+  cholmod_sparse *L (void) const
+  {
+#ifdef HAVE_CHOLMOD
+    return Lsparse;
+#else
+    return 0;
+#endif
+  }
+
+  octave_idx_type P (void) const
+  {
+#ifdef HAVE_CHOLMOD
+    return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ?
+            0 : minor_p + 1);
+#else
+    return 0;
+#endif
+  }
+
+  ColumnVector perm (void) const { return perms + 1; }
+
+  SparseMatrix Q (void) const;
+
+  bool is_positive_definite (void) const { return is_pd; }
+
+  double rcond (void) const { return cond; }
+
+  octave_refcount<int> count;
+
+private:
+
+  bool is_pd;
+
+  octave_idx_type minor_p;
+
+  ColumnVector perms;
+
+  double cond;
+
+#ifdef HAVE_CHOLMOD
+  cholmod_sparse *Lsparse;
+
+  cholmod_common Common;
+
+  void drop_zeros (const cholmod_sparse *S);
+#endif
+
+  octave_idx_type init (const chol_type& a, bool natural, bool force);
+
+  // No copying!
+
+  sparse_chol_rep (const sparse_chol_rep&);
+
+  sparse_chol_rep& operator = (const sparse_chol_rep&);
+};
+
+#ifdef HAVE_CHOLMOD
+
+// Can't use CHOLMOD_NAME(drop)(0.0, S, cm) because it doesn't treat
+// complex matrices.
+
+template <typename chol_type>
 void
-sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::drop_zeros
-  (const cholmod_sparse* S)
+sparse_chol<chol_type>::sparse_chol_rep::drop_zeros (const cholmod_sparse *S)
 {
   chol_elt sik;
   octave_idx_type *Sp, *Si;
   chol_elt *Sx;
   octave_idx_type pdest, k, ncol, p, pend;
 
   if (! S)
     return;
@@ -70,31 +167,51 @@ sparse_base_chol<chol_type, chol_elt, p_
                   Sx[pdest] = sik;
                 }
               pdest++;
             }
         }
     }
   Sp[ncol] = pdest;
 }
+
+// Must provide a specialization for this function.
+template <typename T>
+int
+get_xtype (void);
+
+template <>
+inline int
+get_xtype<double> (void)
+{
+  return CHOLMOD_REAL;
+}
+
+template <>
+inline int
+get_xtype<Complex> (void)
+{
+  return CHOLMOD_COMPLEX;
+}
+
 #endif
 
-template <typename chol_type, typename chol_elt, typename p_type>
+template <typename chol_type>
 octave_idx_type
-sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init
-  (const chol_type& a, bool natural, bool force)
+sparse_chol<chol_type>::sparse_chol_rep::init (const chol_type& a,
+                                               bool natural, bool force)
 {
   volatile octave_idx_type info = 0;
 
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("SparseCHOL requires square matrix");
+    (*current_liboctave_error_handler) ("sparse_chol requires square matrix");
 
   cholmod_common *cm = &Common;
 
   // Setup initial parameters
   CHOLMOD_NAME(start) (cm);
   cm->prefer_zomplex = false;
 
   double spu = octave_sparse_params::get_key ("spumoni");
@@ -134,21 +251,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   ac->nz = 0;
 #if defined (ENABLE_64)
   ac->itype = CHOLMOD_LONG;
 #else
   ac->itype = CHOLMOD_INT;
 #endif
   ac->dtype = CHOLMOD_DOUBLE;
   ac->stype = 1;
-#ifdef OCTAVE_CHOLMOD_TYPE
-  ac->xtype = OCTAVE_CHOLMOD_TYPE;
-#else
-  ac->xtype = CHOLMOD_REAL;
-#endif
+  ac->xtype = get_xtype<chol_elt> ();
 
   if (a_nr < 1)
     ac->x = &dummy;
   else
     ac->x = a.data ();
 
   // use natural ordering if no q output parameter
   if (natural)
@@ -213,19 +326,103 @@ sparse_base_chol<chol_type, chol_elt, p_
   return info;
 
 #else
   (*current_liboctave_error_handler)
     ("support for CHOLMOD was unavailable or disabled when liboctave was built");
 #endif
 }
 
-template <typename chol_type, typename chol_elt, typename p_type>
+template <typename chol_type>
+SparseMatrix
+sparse_chol<chol_type>::sparse_chol_rep::Q (void) const
+{
+#ifdef HAVE_CHOLMOD
+  octave_idx_type n = Lsparse->nrow;
+  SparseMatrix p (n, n, n);
+
+  for (octave_idx_type i = 0; i < n; i++)
+    {
+      p.xcidx (i) = i;
+      p.xridx (i) = static_cast<octave_idx_type>(perms (i));
+      p.xdata (i) = 1;
+    }
+  p.xcidx (n) = n;
+
+  return p;
+#else
+  return SparseMatrix ();
+#endif
+}
+
+template <typename chol_type>
+sparse_chol<chol_type>::sparse_chol (void)
+  : rep (new typename sparse_chol<chol_type>::sparse_chol_rep ())
+{ }
+
+template <typename chol_type>
+sparse_chol<chol_type>::sparse_chol (const chol_type& a, bool natural,
+                                     bool force)
+  : rep (new typename
+         sparse_chol<chol_type>::sparse_chol_rep (a, natural, force))
+{ }
+
+template <typename chol_type>
+sparse_chol<chol_type>::sparse_chol (const chol_type& a, octave_idx_type& info,
+                                     bool natural, bool force)
+  : rep (new typename
+         sparse_chol<chol_type>::sparse_chol_rep (a, info, natural, force))
+{ }
+
+template <typename chol_type>
+sparse_chol<chol_type>::sparse_chol (const chol_type& a, octave_idx_type& info,
+                                     bool natural)
+  : rep (new typename
+         sparse_chol<chol_type>::sparse_chol_rep (a, info, natural, false))
+{ }
+
+template <typename chol_type>
+sparse_chol<chol_type>::sparse_chol (const chol_type& a, octave_idx_type& info)
+  : rep (new typename
+         sparse_chol<chol_type>::sparse_chol_rep (a, info, false, false))
+{ }
+
+template <typename chol_type>
+sparse_chol<chol_type>::sparse_chol (const sparse_chol<chol_type>& a)
+  : rep (a.rep)
+{
+  rep->count++;
+}
+
+template <typename chol_type>
+sparse_chol<chol_type>::~sparse_chol (void)
+{
+  if (--rep->count == 0)
+    delete rep;
+}
+
+template <typename chol_type>
+sparse_chol<chol_type>&
+sparse_chol<chol_type>::operator = (const sparse_chol& a)
+{
+  if (this != &a)
+    {
+      if (--rep->count == 0)
+        delete rep;
+
+      rep = a.rep;
+      rep->count++;
+    }
+
+  return *this;
+}
+
+template <typename chol_type>
 chol_type
-sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
+sparse_chol<chol_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = static_cast<octave_idx_type *>(m->p)[j];
@@ -235,55 +432,111 @@ sparse_base_chol<chol_type, chol_elt, p_
       ret.xdata (i) = static_cast<chol_elt *>(m->x)[i];
     }
   return ret;
 #else
   return chol_type ();
 #endif
 }
 
-template <typename chol_type, typename chol_elt, typename p_type>
-p_type
-sparse_base_chol<chol_type, chol_elt, p_type>::
-sparse_base_chol_rep::Q (void) const
+template <typename chol_type>
+octave_idx_type
+sparse_chol<chol_type>::P (void) const
 {
-#ifdef HAVE_CHOLMOD
-  octave_idx_type n = Lsparse->nrow;
-  p_type p (n, n, n);
+  return rep->P ();
+}
 
-  for (octave_idx_type i = 0; i < n; i++)
-    {
-      p.xcidx (i) = i;
-      p.xridx (i) = static_cast<octave_idx_type>(perms (i));
-      p.xdata (i) = 1;
-    }
-  p.xcidx (n) = n;
-
-  return p;
-#else
-  return p_type ();
-#endif
+template <typename chol_type>
+ColumnVector
+sparse_chol<chol_type>::perm (void) const
+{
+  return rep->perm ();
 }
 
-template <typename chol_type, typename chol_elt, typename p_type>
+template <typename chol_type>
+SparseMatrix
+sparse_chol<chol_type>::Q (void) const
+{
+  return rep->Q ();
+}
+
+template <typename chol_type>
+bool
+sparse_chol<chol_type>::is_positive_definite (void) const
+{
+  return rep->is_positive_definite ();
+}
+
+template <typename chol_type>
+double
+sparse_chol<chol_type>::rcond (void) const
+{
+  return rep->rcond ();
+}
+
+template <typename chol_type>
 chol_type
-sparse_base_chol<chol_type, chol_elt, p_type>::inverse (void) const
+sparse_chol<chol_type>::inverse (void) const
 {
   chol_type retval;
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm ();
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
   chol_type linv = L ().hermitian ().inverse (mattype, info, rcond2, 1, 0);
 
   if (perms.numel () == n)
     {
-      p_type Qc = Q ();
+      SparseMatrix Qc = Q ();
       retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
 #endif
   return retval;
 }
+
+template <typename chol_type>
+chol_type
+chol2inv (const chol_type& r)
+{
+  octave_idx_type r_nr = r.rows ();
+  octave_idx_type r_nc = r.cols ();
+  chol_type retval;
+
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("U must be a square matrix");
+
+  MatrixType mattype (r);
+  int typ = mattype.type (false);
+  double rcond;
+  octave_idx_type info;
+  chol_type rinv;
+
+  if (typ == MatrixType::Upper)
+    {
+      rinv = r.inverse (mattype, info, rcond, true, false);
+      retval = rinv.transpose () * rinv;
+    }
+  else if (typ == MatrixType::Lower)
+    {
+      rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
+      retval = rinv.transpose () * rinv;
+    }
+  else
+    (*current_liboctave_error_handler) ("U must be a triangular matrix");
+
+  return retval;
+}
+
+// SparseComplexMatrix specialization (the value for the NATURAL
+// parameter in the sparse_chol<T>::sparse_chol_rep constructor is
+// different from the default).
+
+template <>
+sparse_chol<SparseComplexMatrix>::sparse_chol (const SparseComplexMatrix& a,
+                                               octave_idx_type& info)
+  : rep (new typename
+         sparse_chol<SparseComplexMatrix>::sparse_chol_rep (a, info, true, false))
+{ }
diff --git a/liboctave/numeric/sparse-base-chol.h b/liboctave/numeric/sparse-chol.h
rename from liboctave/numeric/sparse-base-chol.h
rename to liboctave/numeric/sparse-chol.h
--- a/liboctave/numeric/sparse-base-chol.h
+++ b/liboctave/numeric/sparse-chol.h
@@ -16,210 +16,77 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#if ! defined (octave_sparse_base_chol_h)
-#define octave_sparse_base_chol_h 1
-
-#include "oct-sparse.h"
-#include "dColVector.h"
-
-template <typename chol_type, typename chol_elt, typename p_type>
-class
-sparse_base_chol
-{
-protected:
-#ifdef HAVE_CHOLMOD
-  class sparse_base_chol_rep
-  {
-  public:
-    sparse_base_chol_rep (void)
-      : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
-        perms (), cond (0)
-    { }
-
-    sparse_base_chol_rep (const chol_type& a, bool natural, bool force)
-      : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
-        perms (), cond (0)
-    {
-      init (a, natural, force);
-    }
-
-    sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
-                          bool natural, bool force)
-      : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
-        perms (), cond (0)
-    {
-      info = init (a, natural, force);
-    }
-
-    ~sparse_base_chol_rep (void)
-    {
-      if (is_pd)
-        CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
-    }
-
-    cholmod_sparse * L (void) const { return Lsparse; }
-
-    octave_idx_type P (void) const
-    {
-      return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ?
-              0 : minor_p + 1);
-    }
-
-    ColumnVector perm (void) const { return perms + 1; }
-
-    p_type Q (void) const;
-
-    bool is_positive_definite (void) const { return is_pd; }
-
-    double rcond (void) const { return cond; }
-
-    octave_refcount<int> count;
-
-  private:
-    cholmod_sparse *Lsparse;
-
-    cholmod_common Common;
-
-    bool is_pd;
-
-    octave_idx_type minor_p;
+#if ! defined (octave_sparse_chol_h)
+#define octave_sparse_chol_h 1
 
-    ColumnVector perms;
-
-    double cond;
-
-    octave_idx_type init (const chol_type& a, bool natural, bool force);
-
-    void drop_zeros (const cholmod_sparse* S);
-
-    // No copying!
-
-    sparse_base_chol_rep (const sparse_base_chol_rep&);
-
-    sparse_base_chol_rep& operator = (const sparse_base_chol_rep&);
-  };
-#else
-  class sparse_base_chol_rep
-  {
-  public:
-    sparse_base_chol_rep (void)
-      : count (1), is_pd (false), minor_p (0), perms (), cond (0) { }
-
-    sparse_base_chol_rep (const chol_type& a, bool natural, bool force)
-      : count (1), is_pd (false), minor_p (0), perms (), cond (0)
-    {
-      init (a, natural, force);
-    }
-
-    sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
-                          bool natural, bool force)
-      : count (1), is_pd (false), minor_p (0), perms (), cond (0)
-    {
-      info = init (a, natural, force);
-    }
+#include "CSparse.h"
+#include "dColVector.h"
+#include "dSparse.h"
+#include "oct-sparse.h"
 
-    ~sparse_base_chol_rep (void) { }
-
-    octave_idx_type P (void) const { return 0; }
-
-    ColumnVector perm (void) const { return perms + 1; }
-
-    p_type Q (void) const;
-
-    bool is_positive_definite (void) const { return is_pd; }
-
-    double rcond (void) const { return cond; }
-
-    octave_refcount<int> count;
-
-  private:
-    bool is_pd;
-
-    octave_idx_type minor_p;
-
-    ColumnVector perms;
-
-    double cond;
-
-    octave_idx_type init (const chol_type& a, bool natural, bool force);
-
-    // No copying!
-
-    sparse_base_chol_rep (const sparse_base_chol_rep&);
-
-    sparse_base_chol_rep& operator = (const sparse_base_chol_rep&);
-  };
-#endif
-
-private:
-  sparse_base_chol_rep *rep;
-
+template <typename chol_type>
+class
+sparse_chol
+{
 public:
 
-  sparse_base_chol (void)
-    : rep (new typename
-           sparse_base_chol<chol_type, chol_elt, p_type>
-           ::sparse_base_chol_rep ())
-  { }
+  sparse_chol (void);
 
-  sparse_base_chol (const chol_type& a, bool natural, bool force)
-    : rep (new typename
-           sparse_base_chol<chol_type, chol_elt, p_type>
-           ::sparse_base_chol_rep (a, natural, force))
-  { }
+  sparse_chol (const chol_type& a, bool natural, bool force);
 
-  sparse_base_chol (const chol_type& a, octave_idx_type& info,
-                    bool natural, bool force)
-    : rep (new typename
-           sparse_base_chol<chol_type, chol_elt, p_type>
-           ::sparse_base_chol_rep (a, info, natural, force))
-  { }
+  sparse_chol (const chol_type& a, octave_idx_type& info,
+               bool natural, bool force);
 
-  sparse_base_chol (const sparse_base_chol<chol_type, chol_elt, p_type>& a)
-    : rep (a.rep)
-  { rep->count++; }
+  sparse_chol (const chol_type& a, octave_idx_type& info, bool natural);
 
-  virtual ~sparse_base_chol (void)
-  {
-    if (--rep->count == 0)
-      delete rep;
-  }
+  sparse_chol (const chol_type& a, octave_idx_type& info);
 
-  sparse_base_chol& operator = (const sparse_base_chol& a)
-  {
-    if (this != &a)
-      {
-        if (--rep->count == 0)
-          delete rep;
+  sparse_chol (const sparse_chol<chol_type>& a);
 
-        rep = a.rep;
-        rep->count++;
-      }
+  virtual ~sparse_chol (void);
 
-    return *this;
-  }
+  sparse_chol& operator = (const sparse_chol& a);
 
   chol_type L (void) const;
 
   chol_type R (void) const { return L ().hermitian (); }
 
-  octave_idx_type P (void) const { return rep->P (); }
+  octave_idx_type P (void) const;
 
-  ColumnVector perm (void) const { return rep->perm (); }
+  ColumnVector perm (void) const;
 
-  p_type Q (void) const { return rep->Q (); }
+  SparseMatrix Q (void) const;
 
-  bool is_positive_definite (void) const
-  { return rep->is_positive_definite (); }
+  bool is_positive_definite (void) const;
 
-  double rcond (void) const { return rep->rcond (); }
+  double rcond (void) const;
 
   chol_type inverse (void) const;
+
+protected:
+
+  typedef typename chol_type::element_type chol_elt;
+
+  class sparse_chol_rep;
+
+private:
+
+  sparse_chol_rep *rep;
 };
 
+template <typename chol_type>
+chol_type
+chol2inv (const chol_type& r);
+
+// SparseComplexMatrix specialization.
+
+template <>
+sparse_chol<SparseComplexMatrix>::sparse_chol (const SparseComplexMatrix& a,
+                                               octave_idx_type& info);
+
 #endif
