# HG changeset patch
# User jwe
# Date 1148016739 0
#      Fri May 19 05:32:19 2006 +0000
# Node ID 080c08b192d8d0c62bcc8c069843185b5372b1de
# Parent  4fdc2515ebadf361b534f7c1d2a684427870487b
[project @ 2006-05-19 05:32:17 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,13 @@
+2006-05-19  John W. Eaton  <jwe@octave.org>
+
+	* mk-opts.pl (emit_print_function, emit_options_function):
+	Generate print_usage calls with no args.
+
 2006-05-11  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (localfcnfilepath, localoctfilepath, fcnfilepath,
 	imagepath): Delete variables.
 	* Makeconf.in (localfcnfilepath, localoctfilepath, fcnfilepath,
 	imagepath): Likewise.
 	(do-subst-default-vals): Don't substitute them.
 
diff --git a/mk-opts.pl b/mk-opts.pl
--- a/mk-opts.pl
+++ b/mk-opts.pl
@@ -672,17 +672,17 @@ print_${class_name} (void)
       else
         {
           die ("unknown type $type[$i]");
         }
 
       print "  }\n\n";
     }
 
-  print "print_usage (\"$opt_fcn_name\", true, buf.str ());
+  print "print_usage ();
 }\n\n";
 }
 
 sub emit_set_functions
 {
   print "static void
 set_${class_name} (const std::string& keyword, const octave_value& val)
 {
@@ -869,17 +869,17 @@ Options include\\n\\
             retval = show_${class_name} (keyword);
           else
             set_${class_name} (keyword, args(1));
         }
       else
         error (\"$opt_fcn_name: expecting keyword as first argument\");
     }
   else
-    print_usage (\"$opt_fcn_name\");
+    print_usage ();
 
   return retval;
 }\n";  
 }
 
 sub emit_options_debug
 {
   print "CLASS = \"$class\"\n";
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -33,17 +33,17 @@
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function [n, s] = weekday (d, form)
 
   if (nargin < 1 || nargin > 2)
-    usage("[n, s] = weekday (d, [form])");
+    print_usage ();
   endif
 
   if (nargin < 2)
     form = "short";
   endif
 
   v = datevec (d);
   t = strptime (sprintf ("%d-%d-%d", v(3), v(2), v(1)), "%d-%m-%Y");
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,21 @@
+2006-05-19  John W. Eaton  <jwe@octave.org>
+
+	* symtab.cc (SYMBOL_DEF::document): If definition is a function,
+	also pass doc string to function object.
+	* ov-fcn.h (octave_function::document): New function.
+	* defun.cc (print_usage (octave_function *)): New function.
+	(print_usage (void)): New function.
+	(print_usage (const std::string&)): Provide for backward
+	compatibility.  Ignore arg.
+	(Fprint_usage): Don't accept arg.
+	* defun-int.h (print_usage (void)): Provide decl.
+	(print_usage (const std::string&)): Tag with GCC_ATTR_DEPRECATED.
+
 2006-05-04  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/conv2.cc: New file from Octave Forge.
 	* Makefile.in (DLD_XSRC): Add it to the list
 
 2006-05-17  Bill Denney  <bill@givebillmoney.com>
 
 	* help.cc (keywords): Improve and Texinfoize.
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -420,17 +420,17 @@ You should be using using the @code{glpk
   octave_value_list retval;
 
 #if defined (HAVE_GLPK)
 
   int nrhs = args.length ();
 
   if (nrhs != 9)
     {
-      print_usage ("__glpk__");
+      print_usage ();
       return retval;
     }
 
   //-- 1nd Input. A column array containing the objective function
   //--            coefficients.
   int mrowsc = args(0).rows();
 
   Matrix C (args(0).matrix_value ());
diff --git a/src/DLD-FUNCTIONS/__gnuplot_raw__.l b/src/DLD-FUNCTIONS/__gnuplot_raw__.l
--- a/src/DLD-FUNCTIONS/__gnuplot_raw__.l
+++ b/src/DLD-FUNCTIONS/__gnuplot_raw__.l
@@ -1635,17 +1635,17 @@ Send @var{string} directly to gnuplot su
 {
   if (args.length () == 1 && args(0).is_string ())
     {
       std::string cmd = args(0).string_value ();
 
       gnuplot::send_raw (cmd);
     }
   else
-    print_usage ("__gnuplot_raw__");
+    print_usage ();
 
   return octave_value_list ();
 }
 
 DEFUN_DLD (__gnuplot_set__, args, ,
   "-*- texinfo -*-\n\
 @deffn {{Loadable Function} __gnuplot_set__ options\n\
 Set plotting options for gnuplot\n\
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -507,12 +507,12 @@ DEFUN_DLD (__qp__, args, ,
 	  retval(2) = info;
 	  retval(1) = lambda;
 	  retval(0) = x;
 	}
       else
 	error ("__qp__: invalid arguments");
     }
   else
-    print_usage ("__qp__");
+    print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -115,17 +115,17 @@ Generalized eigenvalue problem balancing
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout < 0 || nargout > 4)
     {
-      print_usage ("balance");
+      print_usage ();
       return retval;
     }
 
   // determine if it's AEP or GEP
   int AEPcase = nargin == 1 ? 1 : args(1).is_string ();
   std::string bal_job;
 
   // problem dimension
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -266,17 +266,17 @@ do_bessel (enum bessel_type type, const 
 		    }
 		}
 	      else
 		gripe_bessel_arg (fn, "first");
 	    }
 	}
     }
   else
-    print_usage (fn);
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (besselj, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
@@ -398,17 +398,17 @@ See besselj.\n\
 	    retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
 	  else
 	    error ("besselh: expecting K = 1 or 2");
 	}
       else
 	error ("besselh: invalid value of K");
     }
   else
-    print_usage ("besselh");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (airy, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
@@ -493,17 +493,17 @@ return @code{NaN}.\n\
 
 	      retval(0) = result;
 	    }
 	  else
 	    error ("airy: expecting complex matrix for Z");
 	}
     }
   else
-    print_usage ("airy");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -165,17 +165,17 @@ compatible dimensions.\n\
 		      if (! error_state)
 			retval = betainc (x, a, b);
 		    }
 		}
 	    }
 	}
     }
   else
-    print_usage ("betainc");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -86,17 +86,17 @@ cellfun (\"tolower(x)\", @{\"Foo\", \"Ba
 
   octave_function *func = 0;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     {
       error ("cellfun: you must supply at least 2 arguments");
-      print_usage ("cellfun");
+      print_usage ();
       return retval;
     }
 
   if (args(0).is_function_handle () || args(0).is_inline_function ())
     {
       func = args(0).function_value ();
 
       if (error_state)
@@ -253,17 +253,17 @@ value @var{c} is of dimension 1 in this 
 @var{m} are placed in slices in @var{c}.\n\
 @seealso{mat2cell}\n\
 @end deftypefn") 
 {
   int nargin =  args.length();
   octave_value retval;
 
   if (nargin < 1 || nargin > 2)
-    print_usage ("num2cell");
+    print_usage ();
   else
     {
       dim_vector dv = args(0).dims ();
       Array<int> sings;
 
       if (nargin == 2)
 	{
 	  ColumnVector dsings = ColumnVector (args(1).vector_value 
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -55,17 +55,17 @@ r' * r = a.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
-      print_usage ("chol");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
     
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
@@ -169,17 +169,17 @@ symmetric positive definite matrix @var{
 		    error ("cholinv: matrix not positive definite");
 		}
 	    }
 	  else
 	    gripe_wrong_type_arg ("chol", arg);
 	}
     }
   else
-    print_usage ("chol");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (chol2inv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} chol2inv (@var{u})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
@@ -219,17 +219,17 @@ using @code{inv}.\n\
 	      if (! error_state)
 		retval = chol2inv (r);
 	    }
 	  else
 	    gripe_wrong_type_arg ("chol2inv", arg);
 	}
     }
   else
-    print_usage ("chol2inv");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -269,17 +269,17 @@ Ng, Oak Ridge National Laboratory. (see\
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
  
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 2)
-    print_usage ("colamd");
+    print_usage ();
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);      
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
@@ -505,17 +505,17 @@ Ng, Oak Ridge National Laboratory. (see\
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
  
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 2)
-    print_usage ("symamd");
+    print_usage ();
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
@@ -650,17 +650,17 @@ Called with a second argument, @dfn{etre
 permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 2)
-    print_usage ("etree");
+    print_usage ();
   else
     {
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       bool is_sym = true;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -45,17 +45,17 @@ Polynomial Approximation}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
-      print_usage ("colloc");
+      print_usage ();
       return retval;
     }
 
   if (! args(0).is_scalar_type ())
     {
       error ("colloc: first argument must be a scalar");
       return retval;
     }
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -259,17 +259,17 @@ in the column direction and by vector @v
   octave_value tmp;
   int nargin = args.length ();
   std::string shape= "full"; //default
   bool separable= false;
   Shape ishape;
 
   if (nargin < 2)
     {
-     print_usage ("conv2");
+     print_usage ();
      return retval;
     }
   else if (nargin == 3)
     {
       if (args(2).is_string ())
         shape = args(2).string_value ();
       else
         separable = true;
@@ -284,28 +284,28 @@ in the column direction and by vector @v
     ishape = SHAPE_FULL;
   else if (shape == "same")
     ishape = SHAPE_SAME;
   else if (shape == "valid")
     ishape = SHAPE_VALID;
   else
     {
       error ("conv2: shape type not valid");
-      print_usage ("conv2");
+      print_usage ();
       return retval;
     }
 
    if (separable)
      {
       // If user requests separable, check first two params are vectors
 
        if (! (1 == args(0).rows () || 1 == args(0).columns ())
 	   || ! (1 == args(1).rows () || 1 == args(1).columns ()))
          {
-	   print_usage ("conv2");
+	   print_usage ();
 	   return retval;
          }
 
        if (args(0).is_complex_type ()
 	   || args(1).is_complex_type ()
 	   || args(2).is_complex_type ())
          {
            ComplexColumnVector v1 (args(0).complex_vector_value ());
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -469,17 +469,17 @@ parameters for @code{daspk}.\n\
 	      retval(0) = Matrix ();
 
 	      if (nargout < 3)
 		error ("daspk: %s", msg.c_str ());
 	    }
 	}
     }
   else
-    print_usage ("daspk");
+    print_usage ();
 
   unwind_protect::run_frame ("Fdaspk");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -358,17 +358,17 @@ parameters for @code{dasrt}.\n\
     DASRT_ABORT1 ("invalid recursive call");
 
   int argp = 0;
 
   int nargin = args.length ();
 
   if (nargin < 4 || nargin > 6)
     {
-      print_usage ("dasrt");
+      print_usage ();
       unwind_protect::run_frame ("Fdasrt");
       return retval;
     }
 
   std::string fcn_name, fname, jac_name, jname;
   dasrt_f = 0;
   dasrt_j = 0;
   dasrt_cf = 0;
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -475,17 +475,17 @@ parameters for @code{dassl}.\n\
 	      retval(0) = Matrix ();
 
 	      if (nargout < 3)
 		error ("dassl: %s", msg.c_str ());
 	    }
 	}
     }
   else
-    print_usage ("dassl");
+    print_usage ();
 
   unwind_protect::run_frame ("Fdassl");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -42,17 +42,17 @@ of the reciprocal condition number if re
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("det");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
     
   int nr = arg.rows ();
   int nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/dispatch.cc b/src/DLD-FUNCTIONS/dispatch.cc
--- a/src/DLD-FUNCTIONS/dispatch.cc
+++ b/src/DLD-FUNCTIONS/dispatch.cc
@@ -320,17 +320,17 @@ some other function for the given type s
 	    }
 	  else
 	    retval = feval (name, args, nargout);
 	}
       else
 	error ("builtin: lookup for symbol `%s' failed", name.c_str ());
     }
   else
-    print_usage ("builtin");
+    print_usage ();
 
   return retval;
 }
 
 static void
 dispatch_record (const std::string &f, const std::string &n, 
 		 const std::string &t)
 {
@@ -442,17 +442,17 @@ for @var{f}.\n\
 @seealso{builtin}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
-      print_usage ("dispatch");
+      print_usage ();
       return retval;
     }
 
   std::string f, t, n;
   if (nargin > 0)
     f = args(0).string_value ();
 
   if (nargin == 2)
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -45,17 +45,17 @@ Schur decomposition.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
-      print_usage ("eig");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/expm.cc b/src/DLD-FUNCTIONS/expm.cc
--- a/src/DLD-FUNCTIONS/expm.cc
+++ b/src/DLD-FUNCTIONS/expm.cc
@@ -120,17 +120,17 @@ is ill-conditioned.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("expm");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -44,17 +44,17 @@ static octave_value
 do_fft (const octave_value_list &args, const char *fcn, int type)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
-      print_usage (fcn);
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_points = -1;
   int dim = -1;
   
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -46,17 +46,17 @@ static octave_value
 do_fft2 (const octave_value_list &args, const char *fcn, int type)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
-      print_usage (fcn);
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
   
   if (nargin > 1)
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -45,17 +45,17 @@ static octave_value
 do_fftn (const octave_value_list &args, const char *fcn, int type)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
-      print_usage (fcn);
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
diff --git a/src/DLD-FUNCTIONS/fftw_wisdom.cc b/src/DLD-FUNCTIONS/fftw_wisdom.cc
--- a/src/DLD-FUNCTIONS/fftw_wisdom.cc
+++ b/src/DLD-FUNCTIONS/fftw_wisdom.cc
@@ -87,17 +87,17 @@ Octave.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length();
 
   if (nargin < 1 || nargin > 2)
     {
-      print_usage ("fftw_wisdom");
+      print_usage ();
       return retval;
     }
 
 #if defined (HAVE_FFTW3)
 
   if (args(0).is_string ())
     {
       bool overwrite = false;
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -362,17 +362,17 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 5)
     {
-      print_usage ("filter");
+      print_usage ();
       return retval;
     }
 
   const char *errmsg = "filter: arguments a and b must be vectors";
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -189,17 +189,17 @@ containing the nonzero values.  For exam
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
-      print_usage ("find");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   if (arg.is_real_type ())
     {
       NDArray nda = arg.array_value ();
diff --git a/src/DLD-FUNCTIONS/fsolve.cc b/src/DLD-FUNCTIONS/fsolve.cc
--- a/src/DLD-FUNCTIONS/fsolve.cc
+++ b/src/DLD-FUNCTIONS/fsolve.cc
@@ -405,17 +405,17 @@ parameters for @code{fsolve}.\n\
 
 	  retval(0) = soln;
 
 	  if (! nleqn.solution_ok () && nargout < 2)
 	    error ("fsolve: %s", msg.c_str ());
 	}
     }
   else
-    print_usage ("fsolve");
+    print_usage ();
 
   unwind_protect::run_frame ("Ffsolve");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -116,17 +116,17 @@ If neither @var{x} nor @var{a} is scalar
 
 		  if (! error_state)
 		    retval = gammainc (x, a);
 		}
 	    }
 	}
     }
   else
-    print_usage ("gammainc");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -88,17 +88,17 @@ all of the values of @var{v1}, @var{...}
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      print_usage ("gcd");
+      print_usage ();
       return retval;
     }
 
   bool all_args_scalar = true;
 
   dim_vector dv(1);
 
   for (int i = 0; i < nargin; i++)
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -82,17 +82,17 @@ Once the end of the data has been reache
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = mk_gr_map (octave_group::getgrent (msg));
       retval(1) = msg;
     }
   else
-    print_usage ("getgrent");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getgrgid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
@@ -122,17 +122,17 @@ Return the first entry from the group da
 	      retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
 	      retval(1) = msg;
 	    }
 	  else
 	    error ("getgrgid: argument must be an integer");
 	}
     }
   else
-    print_usage ("getgrgid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getgrnam, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
@@ -155,17 +155,17 @@ Return the first entry from the group da
 	{
 	  std::string msg;
 
 	  retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
 	  retval(1) = msg;
 	}
     }
   else
-    print_usage ("getgrnam");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (setgrent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
@@ -181,17 +181,17 @@ Return the internal pointer to the begin
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = static_cast<double> (octave_group::setgrent (msg));
       retval(1) = msg;
     }
   else
-    print_usage ("setgrent");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (endgrent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} endgrent ()\n\
 Close the group database.\n\
@@ -207,17 +207,17 @@ Close the group database.\n\
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = static_cast<double> (octave_group::endgrent (msg));
       retval(1) = msg;
     }
   else
-    print_usage ("endgrent");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -86,17 +86,17 @@ opening it if necessary. Once the end of
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
       retval(1) = msg;
     }
   else
-    print_usage ("getpwent");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getpwuid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{pw_struct} = } getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
@@ -126,17 +126,17 @@ database, @code{getpwuid} returns 0.\n\
 	      retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
 	      retval(1) = msg;
 	    }
 	  else
 	    error ("getpwuid: argument must be an integer");
 	}
     }
   else
-    print_usage ("getpwuid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getpwnam, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{pw_struct} = } getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
@@ -159,17 +159,17 @@ database, @code{getpwname} returns 0.\n\
 	{
 	  std::string msg;
 
 	  retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
 	  retval(1) = msg;
 	}
     }
   else
-    print_usage ("getpwnam");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (setpwent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
@@ -185,17 +185,17 @@ Return the internal pointer to the begin
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
       retval(1) = msg;
     }
   else
-    print_usage ("setpwent");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (endpwent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} endpwent ()\n\
 Close the password database.\n\
@@ -211,17 +211,17 @@ Close the password database.\n\
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = static_cast<double> (octave_passwd::endpwent (msg));
       retval(1) = msg;
     }
   else
-    print_usage ("endpwent");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -66,17 +66,17 @@ givens (1, 1)\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
     {
-      print_usage ("givens");
+      print_usage ();
       return retval;
     }
   else
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
 	{
 	  Complex cx = args(0).complex_value ();
 	  Complex cy = args(1).complex_value ();
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -62,17 +62,17 @@ is upper Hessenberg (@code{i >= j+1 => h
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
-      print_usage ("hess");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -41,17 +41,17 @@ ill-conditioned matrix if the reciprocal
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("inv");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -91,17 +91,17 @@ kron (1:4, ones (3, 1))\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 1)
     {
-      print_usage ("kron");
+      print_usage ();
     }
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     {
       ComplexMatrix a (args(0).complex_matrix_value());
       ComplexMatrix b (args(1).complex_matrix_value());
 
       if (! error_state)
 	{
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -462,17 +462,17 @@ parameters for @code{lsode}.\n\
 	      retval(0) = Matrix ();
 
 	      if (nargout < 2)
 		error ("lsode: %s", msg.c_str ());
 	    }
 	}
     }
   else
-    print_usage ("lsode");
+    print_usage ();
 
   unwind_protect::run_frame ("Flsode");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -71,17 +71,17 @@ The matrix is not required to be square.
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
-      print_usage ("lu");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -91,17 +91,17 @@ All other fields in @var{opts} are ignor
 are the same as for @dfn{lu}.\n\
 @seealso{sparse, lu, cholinc}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin == 0)
-    print_usage ("luinc");
+    print_usage ();
   else if (nargin != 2)
     error ("luinc: incorrect number of arguments");
   else
     {
       bool zero_level = false;
       bool milu = false;
       bool udiag = false;
       bool thresh = -1;
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -99,17 +99,17 @@ matrix type will result in incorrect res
 and so it is entirely the responsibility of the user to correctly indentify the\n\
 matrix type.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 0)
-    print_usage ("matrix_type");
+    print_usage ();
   else if (nargin > 4)
     error ("matrix_type: incorrect number of arguments");
   else
     {
       if (args(0).is_sparse_type ())
 	{
 	  if (nargin == 1)
 	    {
diff --git a/src/DLD-FUNCTIONS/minmax.cc b/src/DLD-FUNCTIONS/minmax.cc
--- a/src/DLD-FUNCTIONS/minmax.cc
+++ b/src/DLD-FUNCTIONS/minmax.cc
@@ -43,17 +43,17 @@ 02110-1301, USA.
 #define MINMAX_BODY(FCN) \
  \
   octave_value_list retval;  \
  \
   int nargin = args.length (); \
  \
   if (nargin < 1 || nargin > 3 || nargout > 2) \
     { \
-      print_usage (#FCN); \
+      print_usage (); \
       return retval; \
     } \
  \
   octave_value arg1; \
   octave_value arg2; \
   octave_value arg3; \
  \
   switch (nargin) \
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -48,17 +48,17 @@ where @code{sigma_max (@var{x})} is the 
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
-      print_usage ("pinv");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   double tol = 0.0;
   if (nargin == 2)
     tol = args(1).double_value ();
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -150,17 +150,17 @@ factorization allows the construction of
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2 || nargout > 3)
     {
-      print_usage ("qr");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("qr", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -304,17 +304,17 @@ parameters for @code{quad}.\n\
       retval(2) = static_cast<double> (nfun);
       retval(1) = static_cast<double> (ier);
       retval(0) = val;
 
       if (fcn_name.length())
 	clear_function (fcn_name);
     }
   else
-    print_usage ("quad");
+    print_usage ();
 
   unwind_protect::run_frame ("Fquad");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -287,17 +287,17 @@ Order of output arguments was selected f
   int nargin = args.length ();
 
 #ifdef DEBUG
   std::cout << "qz: nargin = " << nargin << ", nargout = " << nargout << std::endl;
 #endif
 
   if (nargin < 2 || nargin > 3 || nargout > 7)
     {
-      print_usage ("qz");
+      print_usage ();
       return retval;
     }
   else if (nargin == 3 && (nargout < 3 || nargout > 4))
     {
       error ("qz: invalid number of output arguments for form [3] call");
       return retval;
     }
 
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -90,17 +90,17 @@ octregexp_list (const octave_value_list 
   bool lineanchors = false;
   bool dotexceptnewline = false;
   bool freespacing = false;
 
   nopts = nargin - 2;
 
   if (nargin < 2)
     {
-      print_usage(nm);
+      print_usage ();
       return 0;
     }
 
   std::string buffer = args(0).string_value ();
   if (error_state)
     {
       gripe_wrong_type_arg (nm.c_str(), args(0));
       return 0;
@@ -1081,17 +1081,17 @@ Alternatively, use (?x) or (?-x) in the 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length();
 
   if (nargin < 3)
     {
-      print_usage("regexprep");
+      print_usage ();
       return retval;
     }
 
   // Make sure we have string,pattern,replacement
   const std::string buffer = args(0).string_value ();
   if (error_state) return retval;
   const std::string pattern = args(1).string_value ();
   if (error_state) return retval;
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -245,17 +245,17 @@ leading eigenvalues of\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
-      print_usage ("schur");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   std::string ord;
 
   if (nargin == 2)
diff --git a/src/DLD-FUNCTIONS/sort.cc b/src/DLD-FUNCTIONS/sort.cc
--- a/src/DLD-FUNCTIONS/sort.cc
+++ b/src/DLD-FUNCTIONS/sort.cc
@@ -730,17 +730,17 @@ ordered lists.\n\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   sortmode smode = ASCENDING;
 
   if (nargin < 1 || nargin > 3)
     {
-      print_usage ("sort");
+      print_usage ();
       return retval;
     }
 
   bool return_idx = nargout > 1;
 
   octave_value arg = args(0);
 
   int dim = 0;
@@ -762,17 +762,17 @@ ordered lists.\n\
       else
 	dim = args(1).nint_value () - 1;
     }
 
   if (nargin > 2)
     {
       if (args(1).is_string ())
 	{
-	  print_usage ("sort");
+	  print_usage ();
 	  return retval;
 	}
 
       if (! args(2).is_string ())
 	{
 	  error ("sort: mode must be a string");
 	  return retval;
 	}
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -47,17 +47,17 @@ is_sparse (const octave_value& arg)
 DEFUN_DLD (issparse, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} issparse (@var{expr})\n\
 Return 1 if the value of the expression @var{expr} is a sparse matrix.\n\
 @end deftypefn") 
 {
    if (args.length() != 1) 
      {
-       print_usage("issparse");
+       print_usage ();
        return octave_value ();
      }
    else 
      return octave_value (is_sparse (args(0)));
 }
 
 DEFUN_DLD (sparse, args, ,
     "-*- texinfo -*-\n\
@@ -115,17 +115,17 @@ which case they are expanded to all have
    //   retval = new octave_sparse_matrix (sm);
    // To avoid calling the maybe_mutate function. This is the only
    // function that should not call maybe_mutate, or at least only
    // in very particular cases.
 
    int nargin= args.length();
    if (nargin < 1 || (nargin == 4 && !args(3).is_string ()) || nargin > 6) 
      {
-       print_usage ("sparse");
+       print_usage ();
        return retval;
      }
 
    bool use_complex = false;
    bool use_bool = false;
    if (nargin > 2)
      {
        use_complex= args(2).is_complex_type();
@@ -371,17 +371,17 @@ DEFUN_DLD (full, args, ,
  returns a full storage matrix from a sparse one\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length() < 1)
     {
-      print_usage ("full");
+      print_usage ();
       return retval;
     }
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).type_name () == "sparse matrix") 
 	retval = args(0).matrix_value ();
       else if (args(0).type_name () == "sparse complex matrix")
@@ -549,17 +549,17 @@ returns column vectors @var{i},@var{j},@
 @seealso{sparse}\n\
 @end deftypefn")
 {
    octave_value_list retval;
    int nargin = args.length ();
 
    if (nargin != 1) 
      {
-       print_usage ("spfind");
+       print_usage ();
        return retval;
      }
       
 
    octave_value arg = args(0);
 
    if (arg.is_sparse_type ())
      {
@@ -585,33 +585,33 @@ returns column vectors @var{i},@var{j},@
 
    return retval;
 }
 
 #define SPARSE_DIM_ARG_BODY(NAME, FUNC) \
     int nargin = args.length(); \
     octave_value retval; \
     if ((nargin != 1 ) && (nargin != 2)) \
-      print_usage (#NAME); \
+      print_usage (); \
     else { \
       int dim = (nargin == 1 ? -1 : args(1).int_value(true) - 1); \
       if (error_state) return retval; \
       if (dim < -1 || dim > 1) { \
 	error (#NAME ": invalid dimension argument = %d", dim + 1); \
         return retval; \
       } \
       if (args(0).type_id () == \
 	  octave_sparse_matrix::static_type_id () || args(0).type_id () == \
 	  octave_sparse_bool_matrix::static_type_id ()) { \
 	  retval = args(0).sparse_matrix_value () .FUNC (dim); \
       } else if (args(0).type_id () == \
 		 octave_sparse_complex_matrix::static_type_id ()) { \
 	  retval = args(0).sparse_complex_matrix_value () .FUNC (dim); \
       } else \
-	  print_usage (#NAME); \
+	  print_usage (); \
     } \
     return retval
 
 // PKG_ADD: dispatch ("prod", "spprod", "sparse matrix");
 // PKG_ADD: dispatch ("prod", "spprod", "sparse complex matrix");
 // PKG_ADD: dispatch ("prod", "spprod", "sparse bool matrix");
 DEFUN_DLD (spprod, args, ,
   "-*- texinfo -*-\n\
@@ -689,17 +689,17 @@ real.\n\
 #define MINMAX_BODY(FCN) \
  \
   octave_value_list retval;  \
  \
   int nargin = args.length (); \
  \
   if (nargin < 1 || nargin > 3 || nargout > 2) \
     { \
-      print_usage (#FCN); \
+      print_usage (); \
       return retval; \
     } \
  \
   octave_value arg1; \
   octave_value arg2; \
   octave_value arg3; \
  \
   switch (nargin) \
@@ -1031,17 +1031,17 @@ The result is in range -pi to pi.\n\
     else if (is_double_a)
       retval = atan2 (da, b);
     else if (is_double_b)
       retval = atan2 (a, db);
     else
       retval = atan2 (a, b);
 
   } else
-    print_usage("spatan2");
+    print_usage ();
 
   return retval;
 }
 
 static octave_value
 make_spdiag (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
@@ -1245,17 +1245,17 @@ Compressed Column Sparse (rows=4, cols=4
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = make_spdiag (args(0), octave_value(0.));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     retval = make_spdiag (args(0), args(1));
   else
-    print_usage ("spdiag");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/spchol.cc b/src/DLD-FUNCTIONS/spchol.cc
--- a/src/DLD-FUNCTIONS/spchol.cc
+++ b/src/DLD-FUNCTIONS/spchol.cc
@@ -41,17 +41,17 @@ static octave_value_list
 sparse_chol (const octave_value_list& args, const int nargout, 
 	     const std::string& name, const bool LLt)
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
-      print_usage (name);
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
     
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   bool natural = (nargout != 3);
@@ -268,17 +268,17 @@ sparse symmetric positive definite matri
 		    error ("spcholinv: matrix not positive definite");
 		}
 	    }
 	  else
 	    gripe_wrong_type_arg ("spcholinv", arg);
 	}
     }
   else
-    print_usage ("spcholinv");
+    print_usage ();
 
   return retval;
 }
 
 // PKG_ADD: dispatch ("chol2inv", "spchol2inv", "sparse matrix");
 // PKG_ADD: dispatch ("chol2inv", "spchol2inv", "sparse complex matrix");
 // PKG_ADD: dispatch ("chol2inv", "spchol2inv", "sparse bool matrix");
 DEFUN_DLD (spchol2inv, args, ,
@@ -321,17 +321,17 @@ it is much faster than using @code{inv}.
 	      if (! error_state)
 		retval = chol2inv (r);
 	    }
 	  else
 	    gripe_wrong_type_arg ("spchol2inv", arg);
 	}
     }
   else
-    print_usage ("spchol2inv");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (symbfact, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}]} = symbfact (@var{s}, @var{typ}, @var{mode})\n\
 \n\
@@ -383,17 +383,17 @@ factorization as determined by @var{typ}
 @end table\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin < 1  || nargin > 3 || nargout > 5)
     {
-      print_usage ("symbfact");
+      print_usage ();
       return retval;
     }
 
 #ifdef HAVE_CHOLMOD
 
   cholmod_common Common;
   cholmod_common *cm = &Common;
   CHOLMOD_NAME(start) (cm);
diff --git a/src/DLD-FUNCTIONS/spdet.cc b/src/DLD-FUNCTIONS/spdet.cc
--- a/src/DLD-FUNCTIONS/spdet.cc
+++ b/src/DLD-FUNCTIONS/spdet.cc
@@ -47,17 +47,17 @@ an estimate of the reciprocal condition 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("spdet");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
     
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/spkron.cc b/src/DLD-FUNCTIONS/spkron.cc
--- a/src/DLD-FUNCTIONS/spkron.cc
+++ b/src/DLD-FUNCTIONS/spkron.cc
@@ -104,17 +104,17 @@ kron (1:4, ones (3, 1))\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 1)
     {
-      print_usage ("kron");
+      print_usage ();
     }
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     {
       SparseComplexMatrix a (args(0).sparse_complex_matrix_value());
       SparseComplexMatrix b (args(1).sparse_complex_matrix_value());
 
       if (! error_state)
 	{
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -72,17 +72,17 @@ be square.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout > 4)
     {
-      print_usage ("splu");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
@@ -411,17 +411,17 @@ than @code{@var{y} = spinv (@var{a}) * @
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("inv");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/spqr.cc b/src/DLD-FUNCTIONS/spqr.cc
--- a/src/DLD-FUNCTIONS/spqr.cc
+++ b/src/DLD-FUNCTIONS/spqr.cc
@@ -75,17 +75,17 @@ as\n\
 {
   int nargin = args.length ();
   octave_value_list retval;
   bool economy = false;
   bool is_cmplx = false;
   bool have_b = false;
 
   if (nargin < 1 || nargin > 3)
-    print_usage ("spqr");
+    print_usage ();
   else
     {
       if (args(0).is_complex_type ())
 	is_cmplx = true;
       if (nargin > 1)
 	{
 	  have_b = true;
 	  if (args(nargin-1).is_scalar_type ())
@@ -253,17 +253,17 @@ 16(4):303-324, 1990.\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
   
 #if HAVE_CXSPARSE
   if (nargin != 1)
     {
-      print_usage ("dmperm");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   SparseMatrix m;
   SparseComplexMatrix cm;
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -119,17 +119,17 @@ Manchester, England, January 1999.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("sqrtm");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type n = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -118,17 +118,17 @@ decomposition, eliminating the unnecessa
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
     {
-      print_usage ("svd");
+      print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -61,17 +61,17 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 3 || nargout > 1)
     {
-      print_usage ("syl");
+      print_usage ();
       return retval;
     }
 
   octave_value arg_a = args(0);
   octave_value arg_b = args(1);
   octave_value arg_c = args(2);
 
   octave_idx_type a_nr = arg_a.rows ();
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -86,17 +86,17 @@ value returned by @code{time} was 856163
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = static_cast<double> (octave_time ());
   else
-    print_usage ("time");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (gmtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} gmtime (@var{t})\n\
 Given a value returned from time (or any nonnegative integer),\n\
@@ -128,17 +128,17 @@ gmtime (time ())\n\
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
 	retval = octave_value (mk_tm_map (octave_gmtime (tmp)));
     }
   else
-    print_usage ("gmtime");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (localtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} localtime (@var{t})\n\
 Given a value returned from time (or any nonnegative integer),\n\
@@ -170,17 +170,17 @@ localtime (time ())\n\
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
 	retval = octave_value (mk_tm_map (octave_localtime (tmp)));
     }
   else
-    print_usage ("localtime");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (mktime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
@@ -209,17 +209,17 @@ mktime (localtime (time ())\n\
 	    retval = static_cast<double> (octave_time (tm));
 	  else
 	    error ("mktime: invalid TMSTRUCT argument");
 	}
       else
 	error ("mktime: expecting structure argument");
     }
   else
-    print_usage ("mktime");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (strftime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
 Format the time structure @var{tm_struct} in a flexible way using the\n\
@@ -393,17 +393,17 @@ Year (1970-).\n\
 	    }
 	  else
 	    error ("strftime: expecting structure as second argument");
 	}
       else
 	error ("strftime: expecting format string as first argument");
     }
   else
-    print_usage ("strftime");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (strptime, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
@@ -434,17 +434,17 @@ you're absolutely sure the date string w
 	    }
 	  else
 	    error ("strptime: expecting format string as second argument");
 	}
       else
 	error ("strptime: expecting string as first argument");
     }
   else
-    print_usage ("strptime");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/__gnuplot_raw__.l b/src/__gnuplot_raw__.l
--- a/src/__gnuplot_raw__.l
+++ b/src/__gnuplot_raw__.l
@@ -1742,17 +1742,17 @@ Send @var{string} directly to gnuplot su
 {
   if (args.length () == 1 && args(0).is_string ())
     {
       std::string cmd = args(0).string_value ();
 
       gnuplot::send_raw (cmd);
     }
   else
-    print_usage ("__gnuplot_raw__");
+    print_usage ();
 
   return octave_value_list ();
 }
 
 DEFUN (__gnuplot_set__, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} __gnuplot_set__ options\n\
 Set plotting options for gnuplot\n\
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -246,17 +246,17 @@ 02110-1301, USA.
 	    } \
 	  else \
 	    error ("%s: invalid operand type", FNAME); \
 	} \
       else \
 	error ("%s: must have matching operand types", FNAME); \
     } \
   else \
-    print_usage (FNAME); \
+    print_usage (); \
  \
   return retval
 
 DEFUN (bitand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
 Return the bitwise AND of nonnegative integers.\n\
 @var{x}, @var{y} must be in range [0..bitmax]\n\
@@ -465,31 +465,31 @@ bitshift ([1, 10], 2, [3,4])\n\
 	  int bits_in_type = 64;
 	  NDArray m = m_arg.array_value ();
 	  DO_BITSHIFT ( );
 	}
       else
 	error ("bitshift: not defined for %s objects", cname.c_str ());
     }
   else
-    print_usage ("bitshift");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (bitmax, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitmax ()\n\
 Return the largest integer that can be represented as a floating point\n\
 value.  On IEEE-754 compatiable systems, @code{bitmax} is @code{2^53 - 1}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () != 0)
-    print_usage ("bitmax");
+    print_usage ();
   else
     retval = (static_cast<double> (0x1FFFFFFFFFFFFFLL));
   return retval;
 }
 
 DEFUN (intmax, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} intmax (@var{type})\n\
@@ -522,17 +522,17 @@ The default for @var{type} is @code{uint
   octave_value retval;
   std::string cname = "int32";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
   else if (nargin != 0)
     {
-      print_usage ("intmax");
+      print_usage ();
       return retval;
     }
 
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<octave_uint8_t>::max ());
   else if (cname == "uint16")
     retval = octave_uint16 (std::numeric_limits<octave_uint16_t>::max ());
   else if (cname == "uint32")
@@ -585,17 +585,17 @@ The default for @var{type} is @code{uint
   octave_value retval;
   std::string cname = "int32";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
   else if (nargin != 0)
     {
-      print_usage ("intmin");
+      print_usage ();
       return retval;
     }
 
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<octave_uint8_t>::min ());
   else if (cname == "uint16")
     retval = octave_uint16 (std::numeric_limits<octave_uint16_t>::min());
   else if (cname == "uint32")
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -63,17 +63,17 @@ 02110-1301, USA.
 	    retval = args(0).FCN (dim); \
           else \
 	    error (#FCN ": invalid dimension argument = %d", dim + 1); \
         } \
       else \
         error (#FCN ": expecting dimension argument to be an integer"); \
     } \
   else \
-    print_usage (#FCN); \
+    print_usage (); \
  \
   return retval
 
 DEFUN (all, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} all (@var{x}, @var{dim})\n\
 The function @code{all} behaves like the function @code{any}, except\n\
 that it returns true only if all the elements of a vector, or all the\n\
@@ -257,17 +257,17 @@ and @var{x}.  The result is in range -pi
 	      if (! error_state)
 		retval = map_m_m (atan2, y, x);
 	    }
 	}
       else
 	error ("atan2: nonconformant matrices");
     }
   else
-    print_usage ("atan2");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fmod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})\n\
 Compute the floating point remainder of dividing @var{x} by @var{y}\n\
@@ -348,17 +348,17 @@ sign as @var{x}.  If @var{y} is zero, th
 	      if (! error_state)
 		retval = map_m_m (fmod, x, y);
 	    }
 	}
       else
 	error ("fmod: nonconformant matrices");
     }
   else
-    print_usage ("fmod");
+    print_usage ();
 
   return retval;
 }
 
 #define DATA_REDUCTION(FCN) \
  \
   octave_value retval; \
  \
@@ -394,17 +394,17 @@ sign as @var{x}.  If @var{y} is zero, th
 		  return retval; \
 		} \
 	    } \
 	  else \
 	    error (#FCN ": invalid dimension argument = %d", dim + 1); \
 	} \
     } \
   else \
-    print_usage (#FCN); \
+    print_usage (); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cumprod (@var{x}, @var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.  If\n\
 @var{dim} is omitted, it defaults to 1 (column-wise cumulative\n\
@@ -659,17 +659,17 @@ diag ([1, 2, 3], 1)\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = make_diag (args(0));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     retval = make_diag (args(0), args(1));
   else
-    print_usage ("diag");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (prod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is\n\
@@ -765,17 +765,17 @@ do_cat (const octave_value_list& args, s
 	    }
 
 	  retval = tmp;
 	}
       else
 	error ("%s: invalid dimension argument", fname.c_str ());
     }
   else
-    print_usage (fname);
+    print_usage ();
  
   return retval;
 }
 
 DEFUN (horzcat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the horizontal concatenation of N-d array objects, @var{array1},\n\
@@ -882,17 +882,17 @@ do_permute (const octave_value_list& arg
 	vec(i)--;
 
       octave_value ret = args(0).permute (vec, inv);
 
       if (! error_state)
 	retval = ret;
     }
   else
-    print_usage (fname);
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})\n\
 Return the generalized transpose for an N-d array object @var{a}.\n\
@@ -932,17 +932,17 @@ odd definition is used for compatibility
   if (args.length () == 1)
     {
       int len = args(0).length ();
 
       if (! error_state)
 	retval = len;
     }
   else
-    print_usage ("length");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (ndims, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Returns the number of dimensions of array @var{a}.\n\
@@ -955,17 +955,17 @@ Trailing singleton dimensions are not co
   if (args.length () == 1)
     {
       int n_dims = args(0).ndims ();
 
       if (! error_state)
 	retval = n_dims;
     }
   else
-    print_usage ("ndims");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (numel, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} numel (@var{a})\n\
 Returns the number of elements in the object @var{a}.\n\
@@ -982,17 +982,17 @@ Returns the number of elements in the ob
 	{
 	  if (numel < 0)
 	    numel = 0;
 
 	  retval = numel;
 	}
     }
   else
-    print_usage ("numel");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (size, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} size (@var{a}, @var{n})\n\
 Return the number rows and columns of @var{a}.\n\
@@ -1068,34 +1068,34 @@ returns the number of columns in the giv
 	      else 
 		retval(0) = 1;
 	    }
 	  else
 	    error ("size: requested dimension (= %d) out of range", nd);
 	}
     }
   else
-    print_usage ("size");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (nnz, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{scalar} =} nnz (@var{a})\n\
 returns number of non zero elements in @var{a}.\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).nnz ();
   else
-    print_usage ("nnz");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (nzmax, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{scalar} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
@@ -1106,51 +1106,51 @@ but in general they will give the same r
 @seealso{sparse, spalloc}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length() == 1)
     retval = args(0).nzmax ();
   else
-    print_usage ("nzmax");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (rows, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rows (@var{a})\n\
 Return the number of rows of @var{a}.\n\
 @seealso{size, numel, columns, length, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).rows ();
   else
-    print_usage ("rows");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} columns (@var{a})\n\
 Return the number of columns of @var{a}.\n\
 @seealso{size, numel, rows, length, isscalar, isvector, and ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).columns ();
   else
-    print_usage ("columns");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (sum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sum (@var{x}, @var{dim})\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
@@ -1188,17 +1188,17 @@ DEFUN (isbool, args, ,
 Return true if @var{x} is a boolean object.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_bool_type ();
   else
-    print_usage ("isbool");
+    print_usage ();
 
   return retval;
 }
 
 DEFALIAS (islogical, isbool);
 
 DEFUN (iscomplex, args, ,
   "-*- texinfo -*-\n\
@@ -1206,17 +1206,17 @@ DEFUN (iscomplex, args, ,
 Return true if @var{x} is a complex-valued numeric object.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_complex_type ();
   else
-    print_usage ("iscomplex");
+    print_usage ();
 
   return retval;
 }
 
 // FIXME -- perhaps this should be implemented with an
 // octave_value member function?
 
 DEFUN (complex, args, ,
@@ -1326,83 +1326,83 @@ Convert @var{x} to a complex value.\n\
 		}
 	    }
 	}
 
       if (error_state)
 	error ("complex: invalid conversion");
     }
   else
-    print_usage ("complex");
+    print_usage ();
 
   return retval;
 }
 
 
 DEFUN (isreal, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isreal (@var{x})\n\
 Return true if @var{x} is a real-valued numeric object.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_real_type ();
   else
-    print_usage ("isreal");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (isempty, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isempty (@var{a})\n\
 Return 1 if @var{a} is an empty matrix (either the number of rows, or\n\
 the number of columns, or both are zero).  Otherwise, return 0.\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     retval = args(0).is_empty ();
   else
-    print_usage ("isempty");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (isnumeric, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
 Return nonzero if @var{x} is a numeric object.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_numeric_type ();
   else
-    print_usage ("isnumeric");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (islist, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} islist (@var{x})\n\
 Return nonzero if @var{x} is a list.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_list ();
   else
-    print_usage ("islist");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (ismatrix, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return 1 if @var{a} is a matrix.  Otherwise, return 0.\n\
@@ -1415,17 +1415,17 @@ Return 1 if @var{a} is a matrix.  Otherw
       octave_value arg = args(0);
 
       if (arg.is_scalar_type () || arg.is_range ())
 	retval = true;
       else if (arg.is_matrix_type ())
 	retval = (arg.rows () >= 1 && arg.columns () >= 1);
     }
   else
-    print_usage ("ismatrix");
+    print_usage ();
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, int val, const char *fcn)
 {
   octave_value retval;
@@ -2234,17 +2234,17 @@ is equivalent to calling it with an argu
 	get_dimensions (args(0), args(1), "eye", nr, nc);
 
 	if (! error_state)
 	  retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     default:
-      print_usage ("eye");
+      print_usage ();
       break;
     }
 
   return retval;
 }
 
 DEFUN (linspace, args, ,
   "-*- texinfo -*-\n\
@@ -2262,17 +2262,17 @@ The @code{linspace} function always retu
   octave_value retval;
 
   int nargin = args.length ();
 
   int npoints = 100;
 
   if (nargin != 2 && nargin != 3)
     {
-      print_usage ("linspace");
+      print_usage ();
       return retval;
     }
 
   if (nargin == 3)
     npoints = args(2).int_value ();
 
   if (! error_state)
     {
@@ -2357,17 +2357,17 @@ dimensions of the resized matrix.\n\
 	(args(2).scalar_value());
       if (!error_state)
 	{
 	  retval = args(0);
 	  retval = retval.resize (dim_vector (m, n), true);
 	}
     }
   else
-    print_usage ("resize");
+    print_usage ();
   return retval;
 }
 
 // FIXME -- should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n\
@@ -2445,17 +2445,17 @@ by an empty argument.\n\
 		error ("reshape: size is not divisble by the product of known dimensions (= %d)", nel);
 	      else
 		new_size(empty_dim-1) = size_empty_dim;
 	    }
 	}
     }
   else
     {
-      print_usage ("reshape");
+      print_usage ();
       return retval;
     }
 
   if (error_state)
     {
       error ("reshape: invalid arguments");
       return retval;
     }
@@ -2504,17 +2504,17 @@ DEFUN (squeeze, args, ,
 Remove singleton dimensions from @var{x} and return the result.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).squeeze ();
   else
-    print_usage ("squeeze");    
+    print_usage ();    
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -565,17 +565,17 @@ Return a path constructed from @var{dir}
       std::string dirname = args(0).string_value ();
 
       if (! error_state)
 	retval = genpath (dirname);
       else
 	error ("genpath: expecting argument to be a character string");
     }
   else
-    print_usage ("genpath");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (rehash, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rehash ()\n\
 Reinitialize Octave's @code{LOADPATH} directory cache.\n\
@@ -745,17 +745,17 @@ DEFUN (OCTAVE_HOME, args, ,
 Return the name of the top-level Octave installation directory.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Voctave_home;
   else
-    print_usage ("OCTAVE_HOME");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave, as a string.\n\
@@ -763,17 +763,17 @@ Return the version number of Octave, as 
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = OCTAVE_VERSION;
   else
-    print_usage ("OCTAVE_VERSION");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -29,18 +29,18 @@ 02110-1301, USA.
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-mapper.h"
 #include "symtab.h"
 #include "version.h"
 
 class octave_value;
 
-extern void print_usage (const std::string& nm, bool just_usage = false,
-			 const std::string& extra_msg = std::string ());
+extern void print_usage (void);
+extern void print_usage (const std::string&) GCC_ATTR_DEPRECATED;
 
 extern void check_version (const std::string& version, const std::string& fcn);
 
 extern void
 install_builtin_mapper (octave_mapper *mf);
 
 extern void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -31,79 +31,88 @@ 02110-1301, USA.
 
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "help.h"
 #include "ov.h"
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
+#include "ov-fcn.h"
 #include "ov-mapper.h"
+#include "ov-usr-fcn.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "symtab.h"
+#include "toplev.h"
 #include "variables.h"
 
-// FIXME -- this function could probably share some code with
-// the help functions.
+// Print the usage part of the doc string of FCN (user-defined or DEFUN).
 
-void
-print_usage (const std::string& nm, bool just_usage,
-	     const std::string& extra_msg)
+static void
+print_usage (octave_function *fcn)
 {
-  symbol_record *sym_rec = fbi_sym_tab->lookup (nm);
-
-  if (sym_rec)
+  if (fcn)
     {
-      std::string h = sym_rec->help ();
+      std::string nm = fcn->name ();
 
-      if (h.length () > 0)
+      std::string doc = fcn->doc_string ();
+
+      if (doc.length () > 0)
 	{
 	  std::ostringstream buf;
 
 	  buf << "\nInvalid call to " << nm << ".  Correct usage is:\n\n";
 
-	  h = extract_help_from_dispatch (nm) + h;
-
-	  display_usage_text (buf, h);
+	  display_usage_text (buf, doc);
 
-	  buf << extra_msg << "\n";
+	  buf << "\n";
 
-	  if (! just_usage)
-	    additional_help_message (buf);
+	  additional_help_message (buf);
 
 	  defun_usage_message (buf.str ());
 	}
+      else
+	error ("no usage message found for `%s'", nm.c_str ());
     }
   else
-    warning ("no usage message found for `%s'", nm.c_str ());
+    error ("print_usage: invalid function");
+}
+
+// Print the usage part of the doc string of the current function
+// (user-defined or DEFUN).
+
+void
+print_usage (void)
+{
+  print_usage (octave_call_stack::current ());
+}
+
+// Deprecated.
+void
+print_usage (const std::string&)
+{
+  print_usage ();
 }
 
 DEFUN (print_usage, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} print_usage (@var{fname})\n\
-Print the usage message for the function named @var{fname}.  The\n\
-@code{print_usage} function is only intended to work inside the\n\
-named function.\n\
+@deftypefn {Loadable Function} {} print_usage ()\n\
+Print the usage message for the currently executing function.  The\n\
+@code{print_usage} function is only intended to work inside a\n\
+user-defined function.\n\
 @seealso{help}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      std::string fname = args(0).string_value ();
-
-      if (! error_state)
-	print_usage (fname);
-      else
-	error ("print_usage: expecting character string");
-    }
+  if (args.length () == 0)
+    print_usage (octave_call_stack::caller_user_function ());
   else
-    print_usage ("print_usage");
+    print_usage ();
 
   return retval;
 }
 
 void
 check_version (const std::string& version, const std::string& fcn)
 {
   if (version != OCTAVE_API_VERSION)
@@ -224,17 +233,17 @@ DEFUN (alias, args, ,
 		error ("alias: unable to insert `%s' in symbol table",
 		       alias.c_str ());
 	    }
 	  else
 	    error ("alias: function `%s' does not exist", name.c_str ());
 	}
     }
   else
-    print_usage ("alias");
+    print_usage ();
 
   return retval;
 }
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -276,17 +276,17 @@ system-dependent error message.\n\
 	    }
 	  else
 	    {
 	      retval(2) = dir.error ();
 	    }
 	}
     }
   else
-    print_usage ("readdir");
+    print_usage ();
 
   return retval;
 }
 
 // FIXME -- should maybe also allow second arg to specify
 // mode?  OTOH, that might cause trouble with compatibility later...
 
 DEFCMD (mkdir, args, ,
@@ -325,17 +325,17 @@ message identifier.\n\
 	      retval(2) = "mkdir";
 	      retval(1) = msg;
 	    }
 	  else
 	    retval(0) = true;
 	}
     }
   else
-    print_usage ("mkdir");
+    print_usage ();
 
   return retval;
 }
 
 DEFCMD (rmdir, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir}, @code{\"s\"})\n\
@@ -399,17 +399,17 @@ subdirectories as well.\n\
 	      retval(2) = "rmdir";
 	      retval(1) = msg;
 	    }
 	  else
 	    retval(0) = true;
 	}
     }
   else
-    print_usage ("rmdir");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (link, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
 Create a new link (also known as a hard link) to an existing file.\n\
@@ -446,17 +446,17 @@ system-dependent error message.\n\
 	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
-    print_usage ("link");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (symlink, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
 Create a symbolic link @var{new} which contains the string @var{old}.\n\
@@ -493,17 +493,17 @@ system-dependent error message.\n\
 	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
-    print_usage ("symlink");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (readlink, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
 Read the value of the symbolic link @var{symlink}.\n\
@@ -538,17 +538,17 @@ system-dependent error message.\n\
 
 	  retval(1) = status;
 
 	  if (status < 0)
 	    retval(2) = msg;
 	}
     }
   else
-    print_usage ("readlink");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (rename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
 Change the name of file @var{old} to @var{new}.\n\
@@ -585,17 +585,17 @@ system-dependent error message.\n\
 	      retval(0) = status;
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
-    print_usage ("rename");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (glob, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} glob (@var{pattern})\n\
 Given an array of strings (as a char array or a cell array) in\n\
@@ -624,17 +624,17 @@ glob (\"/vm*\")\n\
       else
 	{
 	  glob_match pattern (file_ops::tilde_expand (pat));
 
 	  retval = Cell (pattern.glob ());
 	}
     }
   else
-    print_usage ("glob");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fnmatch, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
 Return 1 or zero for each element of @var{string} that matches any of\n\
@@ -670,34 +670,34 @@ fnmatch (\"a*b\", [\"ab\"; \"axyzb\"; \"
 
 	  for (octave_idx_type i = 0; i < n; i++)
 	    result(i) = tmp(i);
 
 	  retval = result;
 	}
     }
   else
-    print_usage ("fnmatch");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (filesep, args, ,
     "-*- texinfo -*-\n\
 @detypefn {Built-in Function} {} filesep ()\n\
 Return the system-dependent character used to separate directory names.\n\
 @seealso{pathsep, dir, ls}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = file_ops::dir_sep_str;
   else
-    print_usage ("filesep");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (pathsep, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pathsep ()\n\
 Return the system-dependent character used to separate directories in\n\
@@ -705,17 +705,17 @@ a path.\n\
 @seealso{filesep, dir, ls}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = dir_path::path_sep_str;
   else
-    print_usage ("pathsep");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1142,17 +1142,17 @@ also set the last message identifier.\n\
 	      retval(1) = prev_error_id;
 	      retval(0) = prev_error_message;
 	    }
 	}
       else
 	error ("lasterr: expecting arguments to be character strings");
     }
   else
-    print_usage ("lasterr");
+    print_usage ();
 
   return retval;  
 }
 
 // For backward compatibility.
 DEFALIAS (error_text, lasterr);
 DEFALIAS (__error_text__, lasterr);
 
@@ -1189,17 +1189,17 @@ also set the last message identifier.\n\
 	      retval(1) = prev_warning_id;
 	      retval(0) = prev_warning_message;
 	    }
 	}
       else
 	error ("lastwarn: expecting arguments to be character strings");
     }
   else
-    print_usage ("lastwarn");
+    print_usage ();
 
   return retval;  
 }
 
 DEFUN (usage, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usage (@var{msg})\n\
 Print the message @var{msg}, prefixed by the string @samp{usage: }, and\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -197,17 +197,17 @@ otherwise, it returns -1.\n\
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = octave_stream_list::remove (args(0), "fclose");
   else
-    print_usage ("fclose");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fclear, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclear (@var{fid})\n\
 Clear the stream state for the specified file.\n\
@@ -222,17 +222,17 @@ Clear the stream state for the specified
       int fid = octave_stream_list::get_file_number (args (0));
 
       octave_stream os = octave_stream_list::lookup (fid, "fclear");
 
       if (! error_state)
 	os.clearerr ();
     }
   else
-    print_usage ("fclear");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fflush (@var{fid})\n\
 Flush output to @var{fid}.  This is useful for ensuring that all\n\
@@ -265,17 +265,17 @@ stream before calling @code{input}.\n\
 	{
 	  octave_stream os = octave_stream_list::lookup (fid, "fflush");
 
 	  if (! error_state)
 	    retval = os.flush ();
 	}
     }
   else
-    print_usage ("fflush");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fgetl (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
@@ -314,17 +314,17 @@ If there are no more characters to read,
 	  if (! err)
 	    {
 	      retval(1) = tmp.length ();
 	      retval(0) = tmp;
 	    }
 	}
     }
   else
-    print_usage (who);
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fgets (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
@@ -363,17 +363,17 @@ If there are no more characters to read,
 	  if (! err)
 	    {
 	      retval(1) = tmp.length ();
 	      retval(0) = tmp;
 	    }
 	}
     }
   else
-    print_usage (who);
+    print_usage ();
 
   return retval;
 }
 
 static octave_stream
 do_stream_open (const std::string& name, const std::string& mode,
 		const std::string& arch, int& fid)
 {
@@ -617,17 +617,17 @@ however, conversions are currently only 
 	{
 	  int error_number = 0;
 
 	  retval(1) = os.error (false, error_number);
 	  retval(0) = -1.0;
 	}
     }
   else
-    print_usage ("fopen");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (freport, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} freport ()\n\
 Print a list of which files have been opened, and whether they are open\n\
@@ -676,17 +676,17 @@ 0 for success, and -1 if an error was en
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "frewind");
 
       if (! error_state)
 	result = os.rewind ();
     }
   else
-    print_usage ("frewind");
+    print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fseek, args, ,
@@ -717,17 +717,17 @@ Return 0 on success and -1 on error.\n\
 	{
 	  octave_value origin_arg = (nargin == 3)
 	    ? args(2) : octave_value (-1.0);
 
 	  retval = os.seek (args(1), origin_arg);
 	}
     }
   else
-    print_usage ("fseek");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters\n\
@@ -742,17 +742,17 @@ from the beginning of the file @var{fid}
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
       if (! error_state)
 	retval = os.tell ();
     }
   else
-    print_usage ("ftell");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 This function is just like @code{printf}, except that the output is\n\
@@ -799,17 +799,17 @@ written to the stream @var{fid} instead 
 
 	      result = os.printf (args(fmt_n), tmp_args, who);
 	    }
 	  else
 	    ::error ("%s: format must be a string", who.c_str ());
 	}
     }
   else
-    print_usage (who);
+    print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (printf, args, nargout,
@@ -849,17 +849,17 @@ complete description of the syntax of th
 	    }
 
 	  result = stdout_stream.printf (args(0), tmp_args, who);
 	}
       else
 	::error ("%s: format must be a string", who.c_str ());
     }
   else
-    print_usage (who);
+    print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fputs, args, ,
@@ -879,17 +879,17 @@ Return a non-negative number on success 
   if (nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
 	retval = os.puts (args(1), who);
     }
   else
-    print_usage (who);
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (puts, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} puts (@var{string})\n\
 Write a string to the standard output with no formatting.\n\
@@ -899,17 +899,17 @@ Return a non-negative number on success 
 {
   static std::string who = "puts";
 
   octave_value retval = -1;
 
   if (args.length () == 1)
     retval = stdout_stream.puts (args(0), who);
   else
-    print_usage (who);
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (sprintf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
@@ -956,17 +956,17 @@ converted.\n\
 	    }
 	  else
 	    ::error ("%s: format must be a string", who.c_str ());
 	}
       else
 	::error ("%s: unable to create output buffer", who.c_str ());
     }
   else
-    print_usage (who);
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] = } fscanf (@var{fid}, @var{template}, \"C\")\n\
@@ -1060,17 +1060,17 @@ complete description of the syntax of th
 		      retval(0) = tmp;
 		    }
 		}
 	      else
 		::error ("%s: format must be a string", who.c_str ());
 	    }
 	}
       else
-	print_usage (who);
+	print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
@@ -1152,17 +1152,17 @@ string is treated as an end-of-file cond
 	      else
 		::error ("%s: unable to create temporary input buffer",
 			 who.c_str  ());
 	    }
 	  else
 	    ::error ("%s: first argument must be a string", who.c_str ());
 	}
       else
-	print_usage (who);
+	print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n\
@@ -1454,17 +1454,17 @@ values read is returned in @code{count}\
 
 	  octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
 	  retval(1) = count;
 	  retval(0) = tmp;
 	}
     }
   else
-    print_usage ("fread");
+    print_usage ();
 
   return retval;
 }
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
 	   const octave_value& prec_arg, const octave_value& skip_arg,
 	   const octave_value& arch_arg)
@@ -1552,17 +1552,17 @@ are too large to fit in the specified pr
 	    ? args(4) : octave_value ("unknown");
 
 	  double status = do_fwrite (os, data, prec, skip, arch);
 
 	  retval = status;
 	}
     }
   else
-    print_usage ("fwrite");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (feof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for a given\n\
@@ -1579,17 +1579,17 @@ result in an end-of-file condition.\n\
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "feof");
 
       if (! error_state)
 	retval = os.eof () ? 1.0 : 0.0;
     }
   else
-    print_usage ("feof");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (ferror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ferror (@var{fid})\n\
 Return 1 if an error condition has been encountered for a given file\n\
@@ -1624,17 +1624,17 @@ error condition.\n\
 
 	  std::string error_message = os.error (clear, error_number);
 
 	  retval(1) = error_number;
 	  retval(0) = error_message;
 	}
     }
   else
-    print_usage ("ferror");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (popen, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.  The name of the command to run is\n\
@@ -1698,17 +1698,17 @@ endwhile\n\
 	    }
 	  else
 	    ::error ("popen: mode must be a string");
 	}
       else
 	::error ("popen: name must be a string");
     }
   else
-    print_usage ("popen");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (pclose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pclose (@var{fid})\n\
 Close a file identifier that was opened by @code{popen}.  You may also\n\
@@ -1717,17 +1717,17 @@ use @code{fclose} for the same purpose.\
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = octave_stream_list::remove (args(0), "pclose");
   else
-    print_usage ("pclose");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (tmpnam, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tmpnam (@var{dir}, @var{prefix})\n\
 Return a unique temporary file name as a string.\n\
@@ -1758,17 +1758,17 @@ that it will not be available by the tim
 	    retval = file_ops::tempnam (dir, pfx);
 	  else
 	    ::error ("expecting second argument to be a string");
 	}
       else
 	::error ("expecting first argument to be a string");
     }
   else
-    print_usage ("tmpnam");
+    print_usage ();
 
   return retval;
 }
 
 DEFALIAS (octave_tmp_file_name, tmpnam);
 
 DEFUN (tmpfile, args, ,
   "-*- texinfo -*-\n\
@@ -1812,17 +1812,17 @@ system-dependent error message.\n\
       else
 	{
 	  using namespace std;
 	  retval(1) = ::strerror (errno);
 	  retval(0) = -1;
 	}
     }
   else
-    print_usage ("tmpfile");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (@var{template}, @var{delete})\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
@@ -1903,17 +1903,17 @@ error message.\n\
 		  retval(0) = -1;
 		}
 	    }
 	}
       else
 	error ("mkstemp: expecting string as first argument");
     }
   else
-    print_usage ("mkstemp");
+    print_usage ();
 
 #else
   retval(2) = "mkstemp: not supported on this sytem";
 #endif
 
   return retval;
 }
 
@@ -1980,17 +1980,17 @@ interpreted as an octal number); otherwi
 	}
       else
 	{
 	  status = -1;
 	  ::error ("umask: expecting integer argument");
 	}
     }
   else
-    print_usage ("umask");
+    print_usage ();
 
   if (status >= 0)
     retval(0) = status;
 
   return retval;
 }
 
 static octave_value
@@ -1998,17 +1998,17 @@ const_value (const char *nm, const octav
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = val;
   else
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 #if ! defined (P_tmpdir)
 #define P_tmpdir "/tmp"
 #endif
 
@@ -2021,17 +2021,17 @@ this system.  The name of this directory
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = P_tmpdir;
   else
-    print_usage ("P_tmpdir");
+    print_usage ();
 
   return retval;
 }
 
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
@@ -2080,17 +2080,17 @@ const_value (const char *nm, const octav
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = val;
   else
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("stdin", Fstdin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} stdin ()\n\
 Return the numeric value corresponding to the standard input stream.\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1205,20 +1205,20 @@ representation.  This problem may be fix
 		  if (error_state)
 		    goto abort;
 		}
 
 	      if (nargout != 0)
 		retval = output_buf.str ();
 	    }
 	  else
-	    print_usage ("type");
+	    print_usage ();
 	}
       else
-	print_usage ("type");
+	print_usage ();
     }
 
  abort:
 
   return retval;
 }
 
 static std::string
@@ -1289,17 +1289,17 @@ function file, the full name of the file
 
 	      if (nargout == 0)
 		do_which (octave_stdout, id);
 	      else
 		retval(i-1) = do_which (id);
 	    }
 	}
       else
-	print_usage (argv[0]);
+	print_usage ();
     }
 
   return retval;
 }
 
 // FIXME 
 // This function attempts to find the first sentence of a help string, though
 // given that the user can create the help in an arbitrary format, your
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -727,17 +727,17 @@ the screen before your prompt.  @xref{In
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     retval = get_user_input (args, false, nargout);
   else
-    print_usage ("input");
+    print_usage ();
 
   return retval;
 }
 
 bool
 octave_yes_or_no (const std::string& prompt)
 {
   std::string prompt_string = prompt + "(yes or no) ";
@@ -782,17 +782,17 @@ RET and can edit it until it has been co
 	      error ("yes_or_no: expecting argument to be character string");
 	      return retval;
 	    }
 	}
 
       retval = octave_yes_or_no (prompt);
     }
   else
-    print_usage ("yes_or_no");
+    print_usage ();
 
   return retval;
 }
 
 static void
 restore_command_history (void *)
 {
   command_history::ignore_entries (! Vsaving_history);
@@ -846,17 +846,17 @@ If @code{keyboard} is invoked without an
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     do_keyboard (args);
   else
-    print_usage ("keyboard");
+    print_usage ();
 
   return retval;
 }
 
 DEFCMD (echo, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} echo options\n\
 Control whether commands are displayed as they are executed.  Valid\n\
@@ -908,38 +908,38 @@ state.\n\
       {
 	std::string arg = argv[1];
 
 	if (arg == "on")
 	  Vecho_executing_commands = ECHO_SCRIPTS;
 	else if (arg == "off")
 	  Vecho_executing_commands = ECHO_OFF;
 	else
-	  print_usage ("echo");
+	  print_usage ();
       }
       break;
 
     case 3:
       {
 	std::string arg = argv[1];
 
 	if (arg == "on" && argv[2] == "all")
 	  {
 	    int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
 	    Vecho_executing_commands = tmp;
 	  }
 	else if (arg == "off" && argv[2] == "all")
 	  Vecho_executing_commands = ECHO_OFF;
 	else
-	  print_usage ("echo");
+	  print_usage ();
       }
       break;
 
     default:
-      print_usage ("echo");
+      print_usage ();
       break;
     }
 
   return retval;
 }
 
 DEFUN (completion_matches, args, nargout,
   "-*- texinfo -*-\n\
@@ -1007,17 +1007,17 @@ a feature, not a bug.\n\
 	      for (int i = 0; i < len; i++)
 		octave_stdout << list[i] << "\n";
 	    }
 
 	  octave_completion_matches_called = true;
 	}
     }
   else
-    print_usage ("completion_matches");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (read_readline_init_file, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} read_readline_init_file (@var{file})\n\
 Read the readline library initialiazation file @var{file}.  If\n\
@@ -1034,17 +1034,17 @@ Read the readline library initialiazatio
   else if (nargin == 1)
     {
       std::string file = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
 	command_editor::read_init_file (file);
     }
   else
-    print_usage ("read_readline_init_file");
+    print_usage ();
 
   return retval;
 }
 
 static std::string hook_fcn;
 static octave_value user_data;
 
 static int
@@ -1084,17 +1084,17 @@ clears the hook.  In all cases, the name
 and the user data are returned.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 2)
-    print_usage ("input_event_hook");
+    print_usage ();
   else
     {
       octave_value tmp_user_data;
 
       std::string tmp_hook_fcn;
 
       if (nargin > 1)
 	tmp_user_data = args(1);
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -2459,17 +2459,17 @@ is omitted, return a list of keywords.\n
 
       retval = Cell (lst.qsort ());
     }
   else if (argc == 2)
     {
       retval = is_keyword (argv[1]);
     }
   else
-    print_usage ("iskeyword");
+    print_usage ();
 
   return retval;
 }
 
 
 static void
 maybe_warn_separator_insert (char sep)
 {
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -775,17 +775,17 @@ Force Octave to assume the file is in Oc
 	  format = LS_ASCII;
 	}
       else
 	break;
     }
 
   if (i == argc)
     {
-      print_usage ("load");
+      print_usage ();
       return retval;
     }
 
   std::string orig_fname = argv[i];
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
 
   bool swap = false;
@@ -1590,17 +1590,17 @@ the file @file{data} in Octave's binary 
   int i = parse_save_options (argv, argc, format, append, save_as_floats, 
 			      use_zlib, 1);
 
   if (error_state)
     return retval;
 
   if (i == argc)
     {
-      print_usage ("save");
+      print_usage ();
       return retval;
     }
 
   if (save_as_floats && format == LS_ASCII)
     {
       error ("save: cannot specify both -ascii and -float-binary");
       return retval;
     }
@@ -1624,17 +1624,17 @@ the file @file{data} in Octave's binary 
 		     save_as_floats, true);
 	}
     }
 
   // Guard against things like `save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     {
-      print_usage ("save");
+      print_usage ();
       return retval;
     }
   else
     {
       std::string fname = file_ops::tilde_expand (argv[i]);
 
       i++;
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -245,17 +245,17 @@ DEFUN (__version_info__, args, ,
 	  vinfo.assign (idx, "Version", Cell (octave_value (args (1))));
 	  vinfo.assign (idx, "Release", Cell (octave_value (args (2))));
 	  vinfo.assign (idx, "Date", Cell (octave_value (args (3))));
 	}
     }
   else if (nargin == 0)
     retval = vinfo;
   else
-    print_usage ("__version_info__");
+    print_usage ();
 
   return retval;
 }
 
 static void
 initialize_version_info (void)
 {
   octave_value_list args;
@@ -786,17 +786,17 @@ list of arguments passed to the script. 
 for an example of how to create an executable Octave script.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Cell (octave_argv);
   else
-    print_usage ("argv");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (program_invocation_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} program_invocation_name ()\n\
 Return the name that was typed at the shell prompt to run Octave.\n\
@@ -808,17 +808,17 @@ how to create an executable Octave scrip
 @seealso{program_name}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_program_invocation_name;
   else
-    print_usage ("program_invocation_name");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (program_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_name ()\n\
 Return the last component of of the value returned by\n\
@@ -826,17 +826,17 @@ Return the last component of of the valu
 @seealso{program_invocation_name}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_program_name;
   else
-    print_usage ("program_name");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -911,17 +911,17 @@ Return true if @var{x} is a cell array o
 false.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_cell ();
   else
-    print_usage ("iscell");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (cell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell (@var{x})\n\
 @deftypefnx {Built-in Function} {} cell (@var{n}, @var{m})\n\
@@ -1023,17 +1023,17 @@ character string\n\
 	    }
 	  else
 	    retval = false;
 	}
       else
 	retval = false;
     }
   else
-    print_usage ("iscellstr");
+    print_usage ();
 
   return retval;
 }
 
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
@@ -1059,17 +1059,17 @@ array @var{string}.\n\
 
 	  if (! error_state)
 	    retval = Cell (s, true);
 	  else
 	    error ("cellstr: expecting argument to be a 2-d character array");
 	}
     }
   else
-    print_usage ("cellstr");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct2cell (@var{S})\n\
 Create a new cell array from the objects stored in the struct object.\n\
@@ -1142,17 +1142,17 @@ cell array will have a dimension vector 
 	    }
 
 	  retval = c;
 	}
       else
 	error ("struct2cell: expecting argument to be a cell array");
     }
   else
-    print_usage ("struct2cell");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -661,17 +661,17 @@ Return a struct containing information a
 	    }
 	  else
 	    error ("functions: invalid function handle object");
 	}
       else
 	error ("functions: argument must be a function handle object");
     }
   else
-    print_usage ("functions");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} func2str (@var{fcn_handle})\n\
 Return a string containing the name of the function referenced by\n\
@@ -688,17 +688,17 @@ the function handle @var{fcn_handle}.\n\
 	{
 	  std::string fh_nm = fh->fcn_name ();
 	  retval = fh_nm;
 	}
       else
 	error ("func2str: expecting valid function handle as first argument");
     }
   else
-    print_usage ("func2str");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} str2func (@var{fcn_name})\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
@@ -711,17 +711,17 @@ Return a function handle constructed fro
       std::string nm = args(0).string_value ();
 
       if (! error_state)
 	retval = make_fcn_handle (nm);
       else
 	error ("str2func: expecting string as first argument");
     }
   else
-    print_usage ("str2func");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -713,17 +713,17 @@ If the second argument is an integer @va
 	    }
 
 	  retval = octave_value (new octave_fcn_inline (fun, fargs));
 	}
       else
 	error ("inline: first argument must be a string");
     }
   else
-    print_usage ("inline");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (formula, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
@@ -741,17 +741,17 @@ Note that @code{char (@var{fun})} is equ
       octave_fcn_inline* fn = args(0).fcn_inline_value (true);
 
       if (fn)
 	retval = octave_value (fn->fcn_text ());
       else
 	error ("formula: must be an inline function");
     }
   else
-    print_usage ("formula");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (argnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of\n\
@@ -777,17 +777,17 @@ the arguments of the inline function @va
 	    t2(i) = t1(i);
 
 	  retval = t2;
 	}
       else
 	error ("argnames: argument must be an inline function");
     }
   else
-    print_usage ("argnames");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun}\n\
@@ -847,17 +847,17 @@ by replacing all occurrences of @code{*}
 	  if (func_is_string)
 	    retval = octave_value (new_func);
 	  else
 	    retval = octave_value (new octave_fcn_inline 
 				   (new_func, old->fcn_arg_names ()));
 	}
     }
   else
-    print_usage ("vectorize");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -86,16 +86,18 @@ public:
   virtual bool takes_var_return (void) const { return false; }
 
   virtual void octave_vr_val (const octave_value&) { }
 
   virtual bool has_varargout (void) const { return false; }
 
   std::string name (void) const { return my_name; }
 
+  void document (const std::string& ds) { doc = ds; }
+
   std::string doc_string (void) const { return doc; }
 
   virtual void unload (void) { }
 
   virtual void accept (tree_walker&) { }
 
 protected:
 
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -391,17 +391,17 @@ Return the @var{n}-th element of @var{li
 	    }
 	  else
 	    error ("nth: second argument must be an integer");
 	}
       else
 	error ("nth: first argument must be a list");
     }
   else
-    print_usage ("nth");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (append, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} append (@var{list}, @var{a1}, @var{a2}, @dots{})\n\
 Return a new list created by appending @var{a1}, @var{a1}, @dots{}, to\n\
@@ -438,17 +438,17 @@ a list containing the three elements @sa
 	      else
 		tmp.append (ov);
 	    }
 
 	  retval = octave_value (tmp);
 	}
     }
   else
-    print_usage ("append");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (reverse, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} reverse (@var{list})\n\
 Return a new list created by reversing the elements of @var{list}.\n\
@@ -461,17 +461,17 @@ Return a new list created by reversing t
   if (nargin == 1)
     {
       octave_value_list tmp = args(0).list_value ();
 
       if (! error_state)
 	  retval = octave_value (tmp.reverse ());
     }
   else
-    print_usage ("reverse");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (splice, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} splice (@var{list_1}, @var{offset}, @var{length}, @var{list_2})\n\
 Replace @var{length} elements of @var{list_1} beginning at\n\
@@ -527,17 +527,17 @@ is equivalent to @code{append (@var{list
 	    }
 	  else
 	    error ("splice: OFFSET must be an integer");
 	}
       else
 	error ("splice: first argument must be a list");      
     }
   else
-    print_usage ("splice");
+    print_usage ();
 
   return retval;
 }
 
 bool 
 octave_list::save_ascii (std::ostream& os, bool& infnan_warned, 
 			   bool strip_nan_and_inf)
 {
diff --git a/src/ov-streamoff.cc b/src/ov-streamoff.cc
--- a/src/ov-streamoff.cc
+++ b/src/ov-streamoff.cc
@@ -84,17 +84,17 @@ Return true if @var{x} is a streamoff ob
 false.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_streamoff ();
   else
-    print_usage ("isstreamoff");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (streamoff, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} streamoff (@var{x})\n\
 @deftypefnx {Built-in Function} {} streamoff (@var{n}, @var{m})\n\
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -651,17 +651,17 @@ DEFUN (isstruct, args, ,
 Return 1 if the value of the expression @var{expr} is a structure.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_map ();
   else
-    print_usage ("isstruct");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fieldnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fieldnames (@var{struct})\n\
 Return a cell array of strings naming the elements of the structure\n\
@@ -683,17 +683,17 @@ argument that is not a structure.\n\
 	    retval = Cell (0, 1);
 	  else
 	    retval = Cell (m.keys ());
 	}
       else
 	gripe_wrong_type_arg ("fieldnames", args(0));
     }
   else
-    print_usage ("fieldnames");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (isfield, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfield (@var{expr}, @var{name})\n\
 Return true if the expression @var{expr} is a structure and it includes an\n\
@@ -717,17 +717,17 @@ the second must be a string.\n\
 	  std::string key = args(1).string_value ();
 
 	  Octave_map m = args(0).map_value ();
 
 	  retval = m.contains (key) != 0;
 	}
     }
   else
-    print_usage ("isfield");
+    print_usage ();
 
   return retval;
 }
 
 // Check that the dimensions of the input arguments are correct.
 
 static bool
 cell2struct_check_args (const dim_vector& c_dv, const dim_vector& f_dv,
@@ -955,17 +955,17 @@ A(1)\n\
 	    }
 	  else
 	    error ("cell2struct: expecting second argument to be a cell or character array");
 	}
       else
 	error ("cell2struct: expecting first argument to be a cell array");
     }
   else
-    print_usage ("cell2struct");
+    print_usage ();
 
   return retval;
 }
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
@@ -1006,17 +1006,17 @@ named fields.\n\
 		}
 	    }
 
 	  if (! error_state)
 	    retval = m;
 	}
     }
   else
-    print_usage ("rmfield");
+    print_usage ();
 
   return retval;
 }
 
 bool
 octave_struct::save_ascii (std::ostream& os, bool& infnan_warned, 
 			   bool strip_nan_and_inf)
 {
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
--- a/src/ov-type-conv.h
+++ b/src/ov-type-conv.h
@@ -63,17 +63,17 @@ 02110-1301, USA.
 		? SCALAR_RESULT_T::static_type_name () \
 		: MATRIX_RESULT_T::static_type_name (); \
  \
 	      gripe_invalid_conversion (arg_tname, result_tname); \
 	    } \
 	} \
     } \
   else \
-    print_usage (#NAME); \
+    print_usage (); \
  \
   return retval
 
 #define OCTAVE_TYPE_CONV_BODY(NAME) \
   OCTAVE_TYPE_CONV_BODY3 (NAME, octave_ ## NAME ## _matrix, \
 			  octave_ ## NAME ## _scalar)
 
 /*
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -486,17 +486,17 @@ currently installed data types.\n\
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_value_typeinfo::installed_type_names ();
   else if (nargin == 1)
     retval = args(0).type_name ();
   else
-    print_usage ("typeinfo");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (class, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} class (@var{expr})\n\
 \n\
@@ -505,17 +505,17 @@ Return the class of the expression @var{
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = args(0).class_name ();
   else
-    print_usage ("class");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -641,17 +641,17 @@ function accepts a variable number of ar
     }
   else if (nargin == 0)
     {
       symbol_record *sr = curr_sym_tab->lookup ("__nargin__");
 
       retval = sr ? sr->def () : 0;
     }
   else
-    print_usage ("nargin");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} nargout ()\n\
 @deftypefnx {Built-in Function} {} nargout (@var{fcn_name})\n\
@@ -719,17 +719,17 @@ At the top level, @code{nargout} is unde
 	  symbol_record *sr = curr_sym_tab->lookup ("__nargout__");
 
 	  retval = sr ? sr->def () : 0;
 	}
       else
 	error ("nargout: invalid call at top level");
     }
   else
-    print_usage ("nargout");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("va_arg", Fva_arg, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} va_arg ()\n\
 Return the value of the next available argument and move the internal\n\
@@ -763,17 +763,17 @@ has not been declared to take a variable
 	      ::error ("va_arg only valid within function taking variable");
 	      ::error ("number of arguments");
 	    }
 	}
       else
 	::error ("va_arg only valid within function body");
     }
   else
-    print_usage ("va_arg");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (va_start, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} va_start ()\n\
 Position an internal pointer to the first unnamed argument in\n\
@@ -807,17 +807,17 @@ that has not been declared to take a var
 	      ::error ("va_start only valid within function taking variable");
 	      ::error ("number of arguments");
 	    }
 	}
       else
 	::error ("va_start only valid within function body");
     }
   else
-    print_usage ("va_start");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (vr_val, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vr_val (@var{x})\n\
 Each time this function is called, it places the value of its argument\n\
@@ -855,17 +855,17 @@ been declared to return an unspecified n
 	      ::error ("vr_val only valid within function declared to");
 	      ::error ("produce a variable number of values");
 	    }
 	}
       else
 	::error ("vr_val only valid within function body");
     }
   else
-    print_usage ("vr_val");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (max_recursion_depth, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1861,34 +1861,34 @@ Convert @var{val} to the new data type @
 @seealso{class, typeinfo}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     error ("cast: not implemented");
   else
-    print_usage ("cast");
+    print_usage ();
 
   return retval;
 }
 #endif
 
 DEFUN (sizeof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).byte_size ();
   else
-    print_usage ("sizeof");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -475,17 +475,17 @@ Without any arguments, @code{diary} togg
 	    diary_file = arg;
 	    write_to_diary_file = true;
 	    open_diary_file ();
 	  }
       }
       break;
 
     default:
-      print_usage ("diary");
+      print_usage ();
       break;
     }
 
   return retval;
 }
 
 DEFCMD (more, args, ,
   "-*- texinfo -*-\n\
@@ -514,17 +514,17 @@ toggles the current state.\n\
       else if (arg == "off")
 	Vpage_screen_output = false;
       else
 	error ("more: unrecognized argument `%s'", arg.c_str ());
     }
   else if (argc == 1)
     Vpage_screen_output = ! Vpage_screen_output;
   else
-    print_usage ("more");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (terminal_size, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} terminal_size ()\n\
 Return a two-element row vector containing the current size of the\n\
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -3502,17 +3502,17 @@ currently autoloaded functions.\n\
   else if (nargin == 2)
     {
       string_vector argv = args.make_argv ("autoload");
 
       if (! error_state)
 	autoload_map[argv[1]] = argv[2];
     }
   else
-    print_usage ("autoload");
+    print_usage ();
 
   return retval;
 }
 
 void
 source_file (const std::string file_name)
 {
   std::string file_full_name = file_ops::tilde_expand (file_name);
@@ -3547,17 +3547,17 @@ of the file name and the extension.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
-      print_usage ("mfilename");
+      print_usage ();
       return retval;
     }
 
   std::string arg;
 
   if (nargin == 1)
     {
       arg = args(0).string_value ();
@@ -3620,17 +3620,17 @@ be named @file{@var{file}.m}.\n\
       std::string file_name = args(0).string_value ();
 
       if (! error_state)
         source_file (file_name);
       else
 	error ("source: expecting file name as argument");
     }
   else
-    print_usage ("source");
+    print_usage ();
 
   return retval;
 }
 
 // Evaluate an Octave function (built-in or interpreted) and return
 // the list of result values.  NAME is the name of the function to
 // call.  ARGS are the arguments to the function.  NARGOUT is the
 // number of output arguments expected. 
@@ -3760,17 +3760,17 @@ by name, and use @code{feval} to call th
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     retval = feval (args, nargout);
   else
-    print_usage ("feval");
+    print_usage ();
 
   return retval;
 }
 
 octave_value_list
 eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   octave_value_list retval;
@@ -3908,17 +3908,17 @@ so any results remain available after @c
 	  eval_string (args(1), 0, parse_status, nargout);
 
 	  retval = octave_value_list ();
 	}
 
       unwind_protect::run_frame ("Feval");
     }
   else
-    print_usage ("eval");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (assignin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\n\
 Assign @var{value} to @var{varname} in context @var{context}, which\n\
@@ -3974,17 +3974,17 @@ may be either @code{\"base\"} or @code{\
 	    }
 
 	  unwind_protect::run_frame ("Fassignin");
 	}
       else
         error ("assignin: expecting string as first argument");
     }
   else
-    print_usage ("assignin");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
 Like @code{eval}, except that the expressions are evaluated in the\n\
@@ -4045,17 +4045,17 @@ context @var{context}, which may be eith
 	    }
 
 	  unwind_protect::run_frame ("Fevalin");
 	}
       else
         error ("evalin: expecting string as first argument");
     }
   else
-    print_usage ("evalin");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: text ***
 ;;; End: ***
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2537,17 +2537,17 @@ returns the formatted output in a string
       else
 	{
 	  std::ostringstream buf;
 	  args(0).print (buf);
 	  retval = buf.str ();
 	}
     }
   else
-    print_usage ("disp");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fdisp (@var{fid}, @var{x})\n\
 Display the value of @var{x} on the stream @var{fid}.  For example,\n\
@@ -2580,17 +2580,17 @@ Note that the output from @code{fdisp} a
 
 	  if (osp)
 	    args(1).print (*osp);
 	  else
 	    error ("fdisp: stream not open for writing");
 	}
     }
   else
-    print_usage ("fdisp");
+    print_usage ();
 
   return retval;
 }
 
 static void
 init_format_state (void)
 {
   free_format = false;
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -982,17 +982,17 @@ Return a structure containing Unix signa
 
   if (args.length () == 0)
     {
       static Octave_map m = make_sig_struct ();
 
       retval = m;
     }
   else
-    print_usage ("SIG");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (debug_on_interrupt, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -117,17 +117,17 @@ of the string array have the same length
 
 	      result[k++] = t;
 	    }
 	}
 
       retval = octave_value (result, '\'');
     }
   else
-    print_usage ("char");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (ischar, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ischar (@var{a})\n\
 Return 1 if @var{a} is a string.  Otherwise, return 0.\n\
@@ -135,17 +135,17 @@ Return 1 if @var{a} is a string.  Otherw
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).is_string ();
   else
-    print_usage ("ischar");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (strcmp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {} strcmp (@var{s1}, @var{s2})\n\
 Return 1 if the character strings @var{s1} and @var{s2} are the same,\n\
@@ -364,17 +364,17 @@ This is just the opposite of the corresp
 	    }
 
 	  retval = output;
 	}
       else
 	retval = false;
     }
   else
-    print_usage ("strcmp");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (list_in_columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width})\n\
 Return a string containing the elements of @var{arg} listed in\n\
@@ -410,17 +410,17 @@ If @var{width} is not specified, the wid
 	    }
 
 	  retval = buf.str ();
 	}
       else
 	error ("list_in_columns: expecting cellstr or char array");
     }
   else
-    print_usage ("list_in_columns");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -180,16 +180,31 @@ SYMBOL_DEF::which (std::ostream& os, con
 	  return;
 	}
     }
 
   os << " is a " << type_as_string () << "\n";
 }
 
 void
+SYMBOL_DEF::document (const std::string& h)
+{
+  help_string = h;
+
+  if (is_function ())
+    {
+      octave_function *defn = definition.function_value ();
+
+      if (defn)
+	defn->document (h);
+    }
+}
+
+
+void
 SYMBOL_DEF::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "symbol_def::count: " << count << "\n";
 
   definition.print_info (os, prefix + "  ");
 }
 
 // Individual records in a symbol table.
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -206,17 +206,17 @@ private:
     void unprotect (void) { read_only = 0; }
 
     void make_eternal (void) { eternal = 1; }
 
     octave_value& def (void) { return definition; }
 
     std::string help (void) const { return help_string; }
 
-    void document (const std::string& h) { help_string = h; }
+    void document (const std::string& h);
 
     unsigned int type (void) { return symbol_type; }
 
     void *operator new (size_t size)
       { return allocator.alloc (size); }
 
     void operator delete (void *p, size_t size)
       { allocator.free (p, size); }
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -132,17 +132,17 @@ system-dependent error message.\n\
 		  retval(1) = msg;
 		}
 	    }
 	}
       else
 	error ("dup2: invalid stream");
     }
   else
-    print_usage ("dup2");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (exec, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
 Replace current process with a new process.  Calling @code{exec} without\n\
@@ -210,17 +210,17 @@ error message.\n\
 	      retval(0) = status;
 	      retval(1) = msg;
 	    }
 	}
       else
 	error ("exec: first argument must be a string");
     }
   else
-    print_usage ("exec");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fcntl, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.  The following values\n\
@@ -310,17 +310,17 @@ system-dependent error message.\n\
 		  retval(1) = msg;
 		}
 	    }
 	}
       else
 	error ("fcntl: file id, request, and argument must be integers");
     }
   else
-    print_usage ("fcntl");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (fork, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} fork ()\n\
 Create a copy of the current process.\n\
@@ -355,17 +355,17 @@ action.  A system dependent error messag
       std::string msg;
 
       pid_t pid = octave_syscalls::fork (msg);
 
       retval(0) = pid;
       retval(1) = msg;
     }
   else
-    print_usage ("fork");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (getpgrp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pgid =} getpgrp ()\n\
 Return the process group id of the current process.\n\
@@ -381,17 +381,17 @@ Return the process group id of the curre
   if (nargin == 0)
     {
       std::string msg;
 
       retval(0) = octave_syscalls::getpgrp (msg);
       retval(1) = msg;
     }
   else
-    print_usage ("getpgrp");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (getpid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getpid ()\n\
 Return the process id of the current process.\n\
@@ -399,17 +399,17 @@ Return the process id of the current pro
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getpid ();
   else
-    print_usage ("getpid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (getppid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getppid ()\n\
 Return the process id of the parent process.\n\
@@ -417,17 +417,17 @@ Return the process id of the parent proc
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getppid ();
   else
-    print_usage ("getppid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (getegid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {egid =} getegid ()\n\
 Return the effective group id of the current process.\n\
@@ -435,17 +435,17 @@ Return the effective group id of the cur
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getegid ();
   else
-    print_usage ("getegid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (getgid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {gid =} getgid ()\n\
 Return the real group id of the current process.\n\
@@ -453,17 +453,17 @@ Return the real group id of the current 
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getgid ();
   else
-    print_usage ("getgid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (geteuid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {euid =} geteuid ()\n\
 Return the effective user id of the current process.\n\
@@ -471,17 +471,17 @@ Return the effective user id of the curr
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::geteuid ();
   else
-    print_usage ("geteuid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (getuid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {uid =} getuid ()\n\
 Return the real user id of the current process.\n\
@@ -489,17 +489,17 @@ Return the real user id of the current p
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getuid ();
   else
-    print_usage ("getuid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (kill, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} kill (@var{pid}, @var{sig})\n\
 Send signal @var{sig} to process @var{pid}.\n\
@@ -541,17 +541,17 @@ Return 0 if sucessful, otherwise return 
 	      int status = octave_syscalls::kill (pid, sig, msg);
 
 	      retval(1) = msg;
 	      retval(0) = status;
 	    }
 	}
     }
   else
-    print_usage ("kill");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (lstat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
 See stat.\n\
@@ -577,17 +577,17 @@ See stat.\n\
 	    {
 	      retval(2) = fs.error ();
 	      retval(1) = -1;
 	      retval(0) = Matrix ();
 	    }
 	}
     }
   else
-    print_usage ("lstat");
+    print_usage ();
 
   return retval;
 }
 
 
 
 DEFUN (mkfifo, args, ,
   "-*- texinfo -*-\n\
@@ -632,17 +632,17 @@ system-dependent error message.\n\
 	    }
 	  else
 	    error ("mkfifo: MODE must be an integer");
 	}
       else
 	error ("mkfifo: file name must be a string");
     }
   else
-    print_usage ("mkfifo");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (pipe, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{file_ids}, @var{err}, @var{msg}] =} pipe ()\n\
 Create a pipe and return the vector @var{file_ids}, which corresponding\n\
@@ -689,17 +689,17 @@ system-dependent error message.\n\
 	  file_ids(1) = octave_stream_list::insert (os);
 	  file_ids(0) = octave_stream_list::insert (is);
 
 	  retval(1) = status;
           retval(0) = octave_value (file_ids);
 	}
     }
   else
-    print_usage ("pipe");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (stat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
 @deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
@@ -814,17 +814,17 @@ For example,\n\
 	    {
 	      retval(2) = fs.error ();
 	      retval(1) = -1;
 	      retval(0) = Matrix ();
 	    }
 	}
     }
   else
-    print_usage ("stat");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISREG", FS_ISREG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISREG (@var{mode})\n\
 Return true if @var{mode} corresponds to a regular file.  The value\n\
@@ -839,17 +839,17 @@ of @var{mode} is assumed to be returned 
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_reg (static_cast<mode_t> (mode));
       else
 	error ("S_ISREG: invalid mode value");
     }
   else
-    print_usage ("S_ISREG");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISDIR (@var{mode})\n\
 Return true if @var{mode} corresponds to a directory.  The value\n\
@@ -864,17 +864,17 @@ of @var{mode} is assumed to be returned 
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_dir (static_cast<mode_t> (mode));
       else
 	error ("S_ISDIR: invalid mode value");
     }
   else
-    print_usage ("S_ISDIR");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISCHR (@var{mode})\n\
 Return true if @var{mode} corresponds to a character devicey.  The value\n\
@@ -889,17 +889,17 @@ of @var{mode} is assumed to be returned 
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_chr (static_cast<mode_t> (mode));
       else
 	error ("S_ISCHR: invalid mode value");
     }
   else
-    print_usage ("S_ISCHR");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISBLK (@var{mode})\n\
 Return true if @var{mode} corresponds to a block device.  The value\n\
@@ -914,17 +914,17 @@ of @var{mode} is assumed to be returned 
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_blk (static_cast<mode_t> (mode));
       else
 	error ("S_ISBLK: invalid mode value");
     }
   else
-    print_usage ("S_ISBLK");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISFIFO (@var{mode})\n\
 Return true if @var{mode} corresponds to a fifo.  The value\n\
@@ -939,17 +939,17 @@ of @var{mode} is assumed to be returned 
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_fifo (static_cast<mode_t> (mode));
       else
 	error ("S_ISFIFO: invalid mode value");
     }
   else
-    print_usage ("S_ISFIFO");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISLNK (@var{mode})\n\
 Return true if @var{mode} corresponds to a symbolic link.  The value\n\
@@ -964,17 +964,17 @@ of @var{mode} is assumed to be returned 
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_lnk (static_cast<mode_t> (mode));
       else
 	error ("S_ISLNK: invalid mode value");
     }
   else
-    print_usage ("S_ISLNK");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISSOCK (@var{mode})\n\
 @seealso{stat, lstat}\n\
@@ -987,17 +987,17 @@ DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
       double mode = args(0).double_value ();
 
       if (! error_state)
 	retval = file_stat::is_sock (static_cast<mode_t> (mode));
       else
 	error ("S_ISSOCK: invalid mode value");
     }
   else
-    print_usage ("S_ISSOCK");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (uname, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.  For example,\n\
@@ -1034,17 +1034,17 @@ system-dependent error message.\n\
       m.assign ("version", sysinfo.version ());
       m.assign ("machine", sysinfo.machine ());
 
       retval(2) = sysinfo.message ();
       retval(1) = sysinfo.error ();
       retval(0) = m;
     }
   else
-    print_usage ("uname");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (unlink, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} unlink (@var{file})\n\
 Delete the file named @var{file}.\n\
@@ -1073,17 +1073,17 @@ system-dependent error message.\n\
 
 	  retval(0) = status;
 	  retval(1) = msg;	    
 	}
       else
 	error ("unlink: file name must be a string");
     }
   else
-    print_usage ("unlink");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (waitpid, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{pid}, @var{status}, @var{msg}] =} waitpid (@var{pid}, @var{options})\n\
 Wait for process @var{pid} to terminate.  The @var{pid} argument can be:\n\
@@ -1161,17 +1161,17 @@ information about the subprocess that ex
 	    }
 	  else
 	    error ("waitpid: OPTIONS must be an integer");
 	}
       else
 	error ("waitpid: PID must be an integer value");
     }
   else
-    print_usage ("waitpid");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFEXITED", FWIFEXITED, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFEXITED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return true if the\n\
@@ -1416,32 +1416,32 @@ Return the canonical name of file @var{n
 	  retval(2) = msg;
 	  retval(1) = msg.empty () ? 0 : -1;
 	  retval(0) = result;
 	}
       else
 	error ("canonicalize_file_name: argument must be a character string");
     }
   else
-    print_usage ("canonicalize_file_name");
+    print_usage ();
 
   return retval;
 }
 
 static octave_value
 const_value (const char *nm, const octave_value_list& args, int val)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = val;
   else
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -475,17 +475,17 @@ returns a string containing the value of
   if (nargin == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
 	retval = octave_env::getenv (name);
     }
   else
-    print_usage ("getenv");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (putenv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} putenv (@var{var}, @var{value})\n\
 Set the value of the environment variable @var{var} to @var{value}.\n\
@@ -507,17 +507,17 @@ Set the value of the environment variabl
 	    octave_env::putenv (var, val);
 	  else
 	    error ("putenv: second argument should be a string");
 	}
       else
 	error ("putenv: first argument should be a string");
     }
   else
-    print_usage ("putenv");
+    print_usage ();
 
   return retval;
 }
 
 // FIXME -- perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
   "-*- texinfo -*-\n\
@@ -581,17 +581,17 @@ clc;\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (! (nargin == 0 || nargin == 1))
     {
-      print_usage ("pause");
+      print_usage ();
       return retval;
     }
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
@@ -632,17 +632,17 @@ Suspend the execution of the program for
 	{
 	  if (xisnan (dval))
 	    warning ("sleep: NaN is an invalid delay");
 	  else
 	    octave_sleep (dval);
 	}
     }
   else
-    print_usage ("sleep");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (usleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
@@ -666,17 +666,17 @@ of time less than one second, @code{usle
 	      int delay = NINT (dval);
 
 	      if (delay > 0)
 		octave_usleep (delay);
 	    }
 	}
     }
   else
-    print_usage ("usleep");
+    print_usage ();
 
   return retval;
 }
 
 // FIXME -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
@@ -726,17 +726,17 @@ tilde_expand (\"~/bin\")\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = file_ops::tilde_expand (args(0).all_strings ());
   else
-    print_usage ("tilde_expand");
+    print_usage ();
 
   return retval;
 }
 
 #if defined (__EMX__) && defined (OS2)
 
 DEFCMD (extproc, , ,
   "extproc: ignored by Octave")
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -310,17 +310,17 @@ Provided for compatibility with Matlab, 
   if (error_state)
     return retval;
 
   if (argc == 1 || (argc > 1 && argv[1] == "off"))
     warning ("casesen: sorry, Octave is always case sensitive");
   else if (argc > 1 && argv[1] == "on")
     ; // ok.
   else
-    print_usage ("casesen");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (quit, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} exit (@var{status})\n\
 @deftypefnx {Built-in Function} {} quit (@var{status})\n\
@@ -577,17 +577,17 @@ variable @code{status} to the integer @s
 	      if (WIFEXITED (status))
 		status = WEXITSTATUS (status);
 
 	      retval(0) = status;
 	    }
 	}
     }
   else
-    print_usage ("system");
+    print_usage ();
 
   unwind_protect::run_frame ("Fsystem");
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
 
@@ -676,17 +676,17 @@ will print a message when Octave exits.\
 	octave_atexit_functions.push (arg);
       else
 	error ("atexit: argument must be a string");
 #else
       gripe_not_supported ("atexit");
 #endif
     }
   else
-    print_usage ("atexit");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} octave_config_info (@var{option})\n\
 Return a structure containing configuration and installation\n\
@@ -873,17 +873,17 @@ specified option.\n\
 	    error ("octave_config_info: no info for `%s'", arg.c_str ());
 	  else
 	    retval = c(0);
 	}
     }
   else if (nargin == 0)
     retval = m;
   else
-    print_usage ("octave_config_info");
+    print_usage ();
 
   return retval;
 }
 
 #if defined (__GNUG__) && defined (DEBUG_NEW_DELETE)
 
 int debug_new_delete = 0;
 
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -102,17 +102,17 @@ Return true if @var{name} is a valid var
   string_vector argv = args.make_argv ("isvarname");
 
   if (error_state)
     return retval;
 
   if (argc == 2)
     retval = valid_identifier (argv[1]);
   else
-    print_usage ("isvarname");
+    print_usage ();
 
   return retval;
 }
 
 int
 almost_match (const std::string& std, const std::string& s, int min_match_len,
 	      int case_sens)
 {
@@ -312,17 +312,17 @@ name in the path.  If no files are found
 	      else
 		error ("file_in_loadpath: invalid option");
 	    }
 	}
       else
 	error ("file_in_loadpath: expecting string as first argument");
     }
   else
-    print_usage ("file_in_loadpath");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (file_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
@@ -381,17 +381,17 @@ name in the path.  If no files are found
 	    }
 	  else
 	    error ("file_in_path: expecting string as second argument");
 	}
       else
 	error ("file_in_path: expecting string as first argument");
     }
   else
-    print_usage ("file_in_path");
+    print_usage ();
 
   return retval;
 }
 
 std::string
 file_in_path (const std::string& name, const std::string& suffix)
 {
   std::string nm = name;
@@ -543,17 +543,17 @@ Convert special characters in @var{strin
   if (nargin == 1)
     {
       if (args(0).is_string ())
 	retval = do_string_escapes (args(0).string_value ());
       else
 	error ("do_string_escapes: argument must be a string");
     }
   else
-    print_usage ("do_string_escapes");
+    print_usage ();
 
   return retval;
 }
 
 const char *
 undo_string_escape (char c)
 {
   if (! c)
@@ -647,34 +647,34 @@ representation.\n\
   if (nargin == 1)
     {
       if (args(0).is_string ())
 	retval = undo_string_escapes (args(0).string_value ());
       else
 	error ("undo_string_escapes: argument must be a string");
     }
   else
-    print_usage ("undo_string_escapes");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (find_first_of_in_loadpath, args, , "")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       string_vector names = args(0).all_strings ();
 
       if (! error_state)
 	retval = Vload_path_dir_path.find_all_first_of (names);
     }
   else
-    print_usage ("find_first_of_in_loadpath");
+    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("errno", Ferrno, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{err} =} errno ()\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
@@ -708,33 +708,33 @@ if @var{name} is not found.\n\
 	    retval = octave_errno::set (val);
 	  else
 	    error ("errno: expecting integer argument");
 	}
     }
   else if (nargin == 0)
     retval = octave_errno::get ();
   else
-    print_usage ("errno");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (errno_list, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_errno::list ();
   else
-    print_usage ("errno_list");
+    print_usage ();
 
   return retval;
 }
 
 static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -153,17 +153,17 @@ Enter @var{name} into the list of comman
 
 	  if (! error_state)
 	    {
 	      for (int i = 1; i < argc; i++)
 		mark_as_command (argv[i]);
 	    }
 	}
       else
-	print_usage ("mark_as_command");
+	print_usage ();
     }
   else
     warning ("mark_as_command: invalid use inside function body");
 
   return retval;
 }
 
 DEFCMD (unmark_command, args, ,
@@ -187,17 +187,17 @@ Remove @var{name} from the list of comma
 
 	  if (! error_state)
 	    {
 	      for (int i = 1; i < argc; i++)
 		unmark_command (argv[i]);
 	    }
 	}
       else
-	print_usage ("unmark_command");
+	print_usage ();
     }
   else
     warning ("mark_as_command: invalid use inside function body");
 
   return retval;
 }
 
 bool
@@ -253,17 +253,17 @@ mark_as_command.\n\
 	  
       if (! error_state)
 	{
 	  std::string s = argv[1];
 	  retval = is_command_name(s);
 	}
     }
   else
-    print_usage ("iscommand");
+    print_usage ();
 
   return retval;
 }
 
 // Is this a raw input command?
 
 static std::set <std::string> rawcommand_set;
 
@@ -319,17 +319,17 @@ a continuation token ('\\' or '...').\n\
 
 	  if (! error_state)
 	    {
 	      for (int i = 1; i < argc; i++)
 		mark_as_rawcommand (argv[i]);
 	    }
 	}
       else
-	print_usage ("mark_as_rawcommand");
+	print_usage ();
     }
   else
     warning ("mark_as_rawcommand: invalid use inside function body");
 
   return retval;
 }
 
 DEFCMD (unmark_rawcommand, args, ,
@@ -355,17 +355,17 @@ functions.\n\
 
 	  if (! error_state)
 	    {
 	      for (int i = 1; i < argc; i++)
 		unmark_rawcommand (argv[i]);
 	    }
 	}
       else
-	print_usage ("unmark_rawcommand");
+	print_usage ();
     }
   else
     warning ("unmark_rawcommand: invalid use inside function body");
 
   return retval;
 }
 
 bool
@@ -422,17 +422,17 @@ raw input commands with mark_as_rawcomma
 	  
       if (! error_state)
 	{
 	  std::string s = argv[1];
 	  retval = is_rawcommand_name(s);
 	}
     }
   else
-    print_usage ("israwcommand");
+    print_usage ();
 
   return retval;
 }
 
 // Is this a built-in function?
 
 bool
 is_builtin_function_name (const std::string& s)
@@ -721,17 +721,17 @@ isglobal (\"x\")\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
-      print_usage ("isglobal");
+      print_usage ();
       return retval;
     }
 
   std::string name = args(0).string_value ();
 
   if (error_state)
     {
       error ("isglobal: expecting std::string argument");
@@ -936,17 +936,17 @@ Check only for directories.\n\
 	    retval = symbol_exist (name, type);
 	  else
 	    error ("exist: expecting second argument to be a string");
 	}
       else
 	error ("exist: expecting first argument to be a string");
     }
   else
-    print_usage ("exist");
+    print_usage ();
 
   return retval;
 }
 
 // Return TRUE if F and G are both names for the same file.
 
 static bool
 same_file (const std::string& f, const std::string& g)
@@ -1258,17 +1258,17 @@ set_internal_variable (bool& var, const 
       bool bval = args(0).bool_value ();
 
       if (! error_state)
 	var = bval;
       else
 	error ("%s: expecting arg to be a logical value", nm);
     }
   else if (nargin > 1)
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (char& var, const octave_value_list& args,
 		       int nargout, const char *nm)
 {
@@ -1299,17 +1299,17 @@ set_internal_variable (char& var, const 
 	      error ("%s: argument must be a single character", nm);
 	      break;
 	    }
 	}
       else
 	error ("%s: argument must be a single character", nm);
     }
   else if (nargin > 1)
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (int& var, const octave_value_list& args,
 		       int nargout, const char *nm,
 		       int minval, int maxval)
@@ -1333,17 +1333,17 @@ set_internal_variable (int& var, const o
 	    error ("%s: expecting arg to be less than or equal to %d", maxval);
 	  else
 	    var = ival;
 	}
       else
 	error ("%s: expecting arg to be an integer value", nm);
     }
   else if (nargin > 1)
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (double& var, const octave_value_list& args,
 		       int nargout, const char *nm,
 		       double minval, double maxval)
@@ -1367,17 +1367,17 @@ set_internal_variable (double& var, cons
 	    error ("%s: expecting arg to be less than or equal to %g", maxval);
 	  else
 	    var = dval;
 	}
       else
 	error ("%s: expecting arg to be a scalar value", nm);
     }
   else if (nargin > 1)
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
 		       int nargout, const char *nm, bool empty_ok)
 {
@@ -1398,17 +1398,17 @@ set_internal_variable (std::string& var,
 	    var = sval;
 	  else
 	    error ("%s: value must not be empty", nm);
 	}
       else
 	error ("%s: expecting arg to be a character string", nm);
     }
   else if (nargin > 1)
-    print_usage (nm);
+    print_usage ();
 
   return retval;
 }
 
 // Global stuff and links to builtin variables and functions.
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the global variable of the same name, creating it if
@@ -1519,17 +1519,17 @@ Set the documentation string for @var{sy
 		    sym_rec->document (help);
 		  else
 		    error ("document: no such symbol `%s'", name.c_str ());
 		}
 	    }
 	}
     }
   else
-    print_usage ("document");
+    print_usage ();
 
   return retval;
 }
 
 // FIXME -- this function is duplicated in symtab.cc with the
 // name maybe_list_cmp_fcn.
 
 static int
@@ -1818,17 +1818,17 @@ The command @kbd{whos} is equivalent to 
       string_vector argv = args.make_argv ("who");
 
       if (error_state)
 	return retval;
 
       retval = do_who (argc, argv, nargout == 1);
     }
   else
-    print_usage ("who");
+    print_usage ();
 
   return retval;
 }
 
 DEFCMD (whos, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} whos options pattern @dots{}\n\
 See who.\n\
@@ -1852,17 +1852,17 @@ See who.\n\
       string_vector argv = tmp_args.make_argv ("whos");
 
       if (error_state)
 	return retval;
 
       retval = do_who (argc, argv, nargout == 1);
     }
   else
-    print_usage ("whos");
+    print_usage ();
 
   return retval;
 }
 
 // Defining variables.
 
 void
 bind_ans (const octave_value& val, bool print)
@@ -1940,17 +1940,17 @@ then lock in the current function.\n\
       octave_user_function *fcn = octave_call_stack::caller_user_function ();
 
       if (fcn)
         mlock (fcn->name ());
       else
         error ("mlock: invalid use outside a function");
     }
   else
-    print_usage ("mlock");
+    print_usage ();
 
   return retval;
 }
 
 DEFCMD (munlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} munlock (@var{fcn})\n\
 Unlock the named function.  If no function is named\n\
@@ -1974,17 +1974,17 @@ then unlock the current function.\n\
       octave_user_function *fcn = octave_call_stack::caller_user_function ();
 
       if (fcn)
         mlock (fcn->name ());
       else
         error ("munlock: invalid use outside a function");
     }
   else
-    print_usage ("munlock");
+    print_usage ();
 
   return retval;
 }
 
 
 DEFCMD (mislocked, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mislocked (@var{fcn})\n\
@@ -2009,17 +2009,17 @@ then return true if the current function
       octave_user_function *fcn = octave_call_stack::caller_user_function ();
 
       if (fcn)
         retval = mislocked (fcn->name ());
       else
         error ("mislocked: invalid use outside a function");
     }
   else
-    print_usage ("mislocked");
+    print_usage ();
 
   return retval;
 }
 
 // Deleting names from the symbol tables.
 
 static inline bool
 name_matches_any_pattern (const std::string& nm,
@@ -2338,17 +2338,17 @@ do_matlab_compatible_clear (const string
     }
 }
 
 #define CLEAR_OPTION_ERROR(cond) \
   do \
     { \
       if (cond) \
         { \
-          print_usage ("clear"); \
+          print_usage (); \
           return retval; \
         } \
     } \
   while (0)
 
 bool
 clear_function (const std::string& nm)
 {
@@ -2554,17 +2554,17 @@ Print raw symbol table statistices.\n\
 	    }
 	  else
 	    error ("no user-defined function named %s", arg.c_str ());
 	}
     }
   else if (nargin == 0)
     curr_sym_tab->print_info (octave_stdout);
   else
-    print_usage ("__print_symtab_info__");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (__print_symbol_info__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __dump_symbol_info__ (@var{name})\n\
 Print symbol table information for the symbol @var{name}.\n\
@@ -2584,20 +2584,20 @@ Print symbol table information for the s
 
 	  if (sr)
 	    sr->print_info (octave_stdout);
 	  else
 	    error ("__print_symbol_info__: symbol %s not found",
 		   symbol_name.c_str ());
 	}
       else
-	print_usage ("__print_symbol_info__");
+	print_usage ();
     }
   else
-    print_usage ("__print_symbol_info__");
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
@@ -2650,17 +2650,17 @@ need to recompiled.\n\
 	    Vignore_function_time_stamp = 0;
 	  else
 	    error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
 	}
       else
 	error ("ignore_function_time_stamp: expecting argument to be character string");
     }
   else if (nargin > 1)
-    print_usage ("ignore_function_time_stamp");
+    print_usage ();
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
