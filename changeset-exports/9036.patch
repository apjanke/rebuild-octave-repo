# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1237675961 25200
#      Sat Mar 21 15:52:41 2009 -0700
# Node ID 58604c45ca74dbf82c31c848f01f363d63b58cad
# Parent  57649dcecb55d4c7ae987ab97b75ab253631d534
Cleanup of data types related documentation

Files: data.texi, numbers.texi, strings.texi, container.texi
Use two spaces after a period for increased readibility in Info browser
Spellcheck

diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -16,17 +16,17 @@
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Data Containers
 @chapter Data Containers
 @cindex containers
 
 Octave includes support for two different mechanisms to contain
-arbitrary data types in the same variable. Structures, which are C-like,
+arbitrary data types in the same variable.  Structures, which are C-like,
 and are indexed with named fields, and cell arrays, where each element
 of the array can have a different data type and or shape.
 
 @menu
 * Data Structures::
 * Cell Arrays::
 * Comma Separated Lists::
 @end menu
@@ -216,31 +216,31 @@ a loop, using a special form of the @cod
 * Manipulating Structures::
 * Processing Data in Structures::
 @end menu
 
 @node Structure Arrays
 @subsection Structure Arrays
 
 A structure array is a particular instance of a structure, where each of
-the fields of the structure is represented by a cell array. Each of
-these cell arrays has the same dimensions. An example of the creation of
+the fields of the structure is represented by a cell array.  Each of
+these cell arrays has the same dimensions.  An example of the creation of
 a structure array is
 
 @example
 @group
 x(1).a = "string1"
 x(2).a = "string2"
 x(1).b = 1
 x(2).b = 2
 @end group
 @end example
 
 @noindent
-which creates a 2-by-1 structure array with two fields. As previously,
+which creates a 2-by-1 structure array with two fields.  As previously,
 to print the value of the structure array, you can type its name:
 
 @example
 @group
 octave:1> x
 x =
 @{
   1x2 struct array containing the fields:
@@ -263,17 +263,17 @@ ans =
   a = string1
   b =  1
 @}
 @end group
 @end example
 
 Furthermore, the structure array can return a comma separated list
 (@pxref{Comma Separated Lists}), if indexed by one of its own field
-names. For example
+names.  For example
 
 @example
 @group
 octave:3> x.a
 ans = string1
 ans = string2
 @end group
 @end example
@@ -300,30 +300,30 @@ octave:8> [x([1,3]).a] = deal("other str
 octave:9> x.a
 ans = other string1
 ans = new string2
 ans = other string2
 ans = new string2
 @end group
 @end example
 
-The function @code{size} will return the size of the structure. For
+The function @code{size} will return the size of the structure.  For
 the example above
 
 @example
 @group
 octave:10> size(x)
 ans =
 
    1   4
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
-numerical array, by assigning the elements to an empty matrix. For
+numerical array, by assigning the elements to an empty matrix.  For
 example
 
 @example
 @group
 in = struct ("call1", @{x, Inf, "last"@}, 
              "call2", @{x, Inf, "first"@});
 in (1, :) = []
 @result{} in =
@@ -345,35 +345,35 @@ in (1, :) = []
       @}
 @end group
 @end example
 
 @node Creating Structures
 @subsection Creating Structures
 
 As well as indexing a structure with ".", Octave can create a structure
-with the @code{struct} command. @code{struct} takes pairs of arguments,
+with the @code{struct} command.  @code{struct} takes pairs of arguments,
 where the first argument in the pair is the fieldname to include in the
 structure and the second is a scalar or cell array, representing the
-values to include in the structure or structure array. For example
+values to include in the structure or structure array.  For example
 
 @example
 @group
 struct ("field1", 1, "field2", 2)
 @result{} ans =
       @{
         field1 =  1
         field2 =  2
       @}
 @end group
 @end example
 
 If the values passed to @code{struct} are a mix of scalar and cell
 arrays, then the scalar arguments are expanded to create a 
-structure array with a consistent dimension. For example
+structure array with a consistent dimension.  For example
 
 @example
 @group
 struct ("field1", @{1, "one"@}, "field2", @{2, "two"@},
         "field3", 3)
 @result{} ans =
       @{
         field1 =
@@ -426,34 +426,34 @@ Other functions that can manipulate the 
 @DOCSTRING(getfield)
 
 @DOCSTRING(substruct)
 
 @node Processing Data in Structures
 @subsection Processing Data in Structures
 
 The simplest way to process data in a structure is within a @code{for}
-loop (@pxref{Looping Over Structure Elements}). A similar effect can be
+loop (@pxref{Looping Over Structure Elements}).  A similar effect can be
 achieved with the @code{structfun} function, where a user defined
 function is applied to each field of the structure.
 
 @DOCSTRING(structfun)
 
 Alternatively, to process the data in a structure, the structure might
 be converted to another type of container before being treated.
 
 @DOCSTRING(struct2cell)
 
 @node Cell Arrays
 @section Cell Arrays
 @cindex cell arrays
 
 It can be both necessary and convenient to store several variables of
-different size or type in one variable. A cell array is a container
-class able to do just that. In general cell arrays work just like
+different size or type in one variable.  A cell array is a container
+class able to do just that.  In general cell arrays work just like
 @math{N}-dimensional arrays, with the exception of the use of @samp{@{}
 and @samp{@}} as allocation and indexing operators.
 
 As an example, the following code creates a cell array containing a
 string and a 2-by-2 random matrix
 
 @example
 c = @{"a string", rand(2, 2)@};
@@ -486,17 +486,17 @@ c@{1:2@}
                0.593993   0.627732
                0.377037   0.033643
           
           ,)
 @end group
 @end example
 
 The indexing operators can also be used to insert or overwrite elements
-of a cell array. The following code inserts the scalar 3 on the
+of a cell array.  The following code inserts the scalar 3 on the
 third place of the previously created cell array
 
 @example
 @group
 c@{3@} = 3
      @result{} c =
          
          @{
@@ -506,72 +506,72 @@ c@{3@} = 3
               0.593993   0.627732
               0.377037   0.033643
          
            [1,3] =  3
          @}
 @end group
 @end example
 
-In general nested cell arrays are displayed hierarchically as above. In
+In general nested cell arrays are displayed hierarchically as above.  In
 some circumstances it makes sense to reference them by their index, and
 this can be performed by the @code{celldisp} function.
 
 @DOCSTRING(celldisp)
 
 @menu
 * Creating Cell Arrays::                 
 * Indexing Cell Arrays::
 * Cell Arrays of Strings::
 * Processing Data in Cell Arrays::
 @end menu
 
 @node Creating Cell Arrays
 @subsection Creating Cell Array
 
 The introductory example showed how to create a cell array containing
-currently available variables. In many situations, however, it is useful
+currently available variables.  In many situations, however, it is useful
 to create a cell array and then fill it with data.
 
 The @code{cell} function returns a cell array of a given size, containing
-empty matrices. This function is similar to the @code{zeros}
-function for creating new numerical arrays. The following example creates
+empty matrices.  This function is similar to the @code{zeros}
+function for creating new numerical arrays.  The following example creates
 a 2-by-2 cell array containing empty matrices
 
 @example
 @group
 c = cell(2,2)
      @result{} c =
          
          @{
            [1,1] = [](0x0)
            [2,1] = [](0x0)
            [1,2] = [](0x0)
            [2,2] = [](0x0)
          @}
 @end group
 @end example
 
-Just like numerical arrays, cell arrays can be multidimensional. The
+Just like numerical arrays, cell arrays can be multidimensional.  The
 @code{cell} function accepts any number of positive integers to describe
-the size of the returned cell array. It is also possible to set the size
-of the cell array through a vector of positive integers. In the
+the size of the returned cell array.  It is also possible to set the size
+of the cell array through a vector of positive integers.  In the
 following example two cell arrays of equal size are created, and the size
 of the first one is displayed
 
 @example
 c1 = cell(3, 4, 5);
 c2 = cell( [3, 4, 5] );
 size(c1)
      @result{} ans =
          3   4   5
 @end example
 
 @noindent
-As can be seen, the @code{size} function also works for cell arrays. As
+As can be seen, the @code{size} function also works for cell arrays.  As
 do the other functions describing the size of an object, such as
 @code{length}, @code{numel}, @code{rows}, and @code{columns}.
 
 As an alternative to creating empty cell arrays, and then filling them,  it
 is possible to convert numerical arrays into cell arrays using the
 @code{num2cell} and @code{mat2cell} functions.
 
 @DOCSTRING(cell)
@@ -581,47 +581,47 @@ is possible to convert numerical arrays 
 @DOCSTRING(num2cell)
 
 @DOCSTRING(mat2cell)
 
 @node Indexing Cell Arrays
 @subsection Indexing Cell Arrays
 
 As shown in the introductory example elements can be inserted from cell
-arrays using the @samp{@{} and @samp{@}} operators. Besides the change
+arrays using the @samp{@{} and @samp{@}} operators.  Besides the change
 of operators, indexing works for cell arrays like for multidimensional
 arrays.  As an example, all the rows of the first and third column of a
 cell array can be set to @code{0} with the following code
 
 @example
 c@{:, [1, 3]@} = 0;
 @end example
 
 Accessing values in a cell array is, however, different from the same
-operation for numerical arrays. Accessing a single element of a cell
+operation for numerical arrays.  Accessing a single element of a cell
 array is very similar to numerical arrays, for example
 
 @example
 element = c@{1, 2@};
 @end example
 
 @noindent
 This will, however, @emph{not} work when accessing multiple elements of
 a cell array, because it might not be possible to represent all elements
 with a single variable as is the case with numerical arrays.
 
 Accessing multiple elements of a cell array with the @samp{@{} and
 @samp{@}} operators will result in a comma-separated list (@pxref{Comma
 Separated Lists}) of all the requested elements as discussed later. 
 
 One distinction between @samp{@{} and @samp{(} to index cell arrays is
-in the deletion of elements from the cell array. In a similar manner to
+in the deletion of elements from the cell array.  In a similar manner to
 a numerical array the @samp{()} operator can be used to delete elements
-from the cell array. The @samp{@{@}} operator however will remove the
-elements of the cell array, but not delete the space for them. For example
+from the cell array.  The @samp{@{@}} operator however will remove the
+elements of the cell array, but not delete the space for them.  For example
 
 @example
 @group
 x = @{"1", "2"; "3", "4"@};
 x@{1, :@} = []
 @result{} x =
       @{
         [1,1] = [](0x0)
@@ -638,37 +638,37 @@ x(1, :) = []
       @}
 @end group
 @end example
 
 @node Cell Arrays of Strings
 @subsection Cell Arrays of Strings
 
 One common use of cell arrays is to store multiple strings in the same
-variable. It is possible to store multiple strings in a character matrix
-by letting each row be a string. This, however, introduces the problem
-that all strings must be of equal length. Therefore it is recommended to
-use cell arrays to store multiple strings. If, however, the character
+variable.  It is possible to store multiple strings in a character matrix
+by letting each row be a string.  This, however, introduces the problem
+that all strings must be of equal length.  Therefore it is recommended to
+use cell arrays to store multiple strings.  If, however, the character
 matrix representation is required for an operation, it can be converted
 to a cell array of strings using the @code{cellstr} function
 
 @example
 a = ["hello"; "world"];
 c = cellstr (a)
      @result{} c =
          @{
            [1,1] = hello
            [2,1] = world
          @}
 @end example
 
 One further advantage of using cell arrays to store multiple strings is
 that most functions for string manipulations included with Octave
-support this representation. As an example, it is possible to compare
-one string with many others using the @code{strcmp} function. If one of
+support this representation.  As an example, it is possible to compare
+one string with many others using the @code{strcmp} function.  If one of
 the arguments to this function is a string and the other is a cell array
 of strings, each element of the cell array will be compared the string
 argument,
 
 @example
 c = @{"hello", "world"@};
 strcmp ("hello", c)
      @result{} ans =
@@ -686,18 +686,18 @@ strings, @code{strcmp}, @code{strcmpi}, 
 @DOCSTRING(iscellstr)
 
 @DOCSTRING(cellidx)
 
 @node Processing Data in Cell Arrays
 @subsection Processing Data in Cell Arrays
 
 Data that is stored in a cell array can be processed in several ways
-depending on the actual data. The simplest way to process that data
-is to iterate through it using one or more @code{for} loops. The same
+depending on the actual data.  The simplest way to process that data
+is to iterate through it using one or more @code{for} loops.  The same
 idea can be implemented more easily through the use of the @code{cellfun}
 function that calls a user-specified function on all elements of a cell
 array.
 
 @DOCSTRING(cellfun)
 
 An alternative is to convert the data to a different container, such as
 a matrix or a data structure.  Depending on the data this is possible
@@ -709,38 +709,38 @@ using the @code{cell2mat} and @code{cell
 
 @node Comma Separated Lists
 @section Comma Separated Lists
 @cindex comma separated lists
 @cindex cs-lists
 
 Comma separated lists@footnote{Comma-separated lists are also sometimes
 informally referred to as @dfn{cs-lists}.} are the basic argument type
-to all Octave functions. In the example
+to all Octave functions.  In the example
 
 @example
 max (@var{a}, @var{b})
 @end example
 
 @noindent
-@code{@var{a}, @var{b}} is a comma separated list. Comma separated lists
-can appear on both the right and left hand side of an equation. For
+@code{@var{a}, @var{b}} is a comma separated list.  Comma separated lists
+can appear on both the right and left hand side of an equation.  For
 example
 
 @example
 [@var{i}, @var{j}] = ceil (find (@var{x}, [], "last"));
 @end example
 
 @noindent
-where @code{@var{i}, @var{j}} is equally a comma separated list. Comma
-separated lists cannot be directly manipulated by the user. However,
+where @code{@var{i}, @var{j}} is equally a comma separated list.  Comma
+separated lists cannot be directly manipulated by the user.  However,
 both structures and cell arrays can be converted into comma
 separated lists, which makes them useful to keep the input arguments and
-return values of functions organized. Another example of where a comma
-separated list can be used is in the creation of a new array. If all the
+return values of functions organized.  Another example of where a comma
+separated list can be used is in the creation of a new array.  If all the
 accessed elements of a cell array are scalars or column vectors, they
 can be concatenated into a new column vector containing the elements, by
 surrounding the list with @code{[} and @code{]} as in the following
 example
 
 @example
 a = @{1, [2, 3], 4@};
 b = [a@{:@}]
@@ -759,66 +759,66 @@ c = @{"GNU", "Octave", "is", "Free", "So
 printf ("%s ", c@{1@}, c@{2@}, c@{3@}, c@{4@}, c@{5@});
      @print{} GNU Octave is Free Software 
 printf ("%s ", c@{:@});
      @print{} GNU Octave is Free Software 
 @end example
 
 Just like it is possible to create a numerical array from selected
 elements of a cell array, it is possible to create a new cell array
-containing the selected elements. By surrounding the list with 
+containing the selected elements.  By surrounding the list with 
 @samp{@{} and @samp{@}} a new cell array will be created, as the
 following example illustrates
 
 @example
 a = @{1, rand(2, 2), "three"@};
 b = @{ a@{ [1, 3] @} @}
      @result{} b =
          @{
            [1,1] =  1
            [1,2] = three
          @}
 @end example
 
 @noindent
 This syntax is however a bit cumbersome, and since this is a common
 operation, it is possible to achieve the same using the @samp{(}
-and @samp{)} operators for indexing. When a cell array is indexed
+and @samp{)} operators for indexing.  When a cell array is indexed
 using the @samp{(} and @samp{)} operators a new cell array containing
-the selected elements will be created. Using this syntax, the previous 
+the selected elements will be created.  Using this syntax, the previous 
 example can be simplified into the following
 
 @example
 a = @{1, rand(2, 2), "three"@};
 b = a( [1, 3] )
      @result{} b =
          @{
            [1,1] =  1
            [1,2] = three
          @}
 @end example
 
 A comma separated list can equally appear on the left-hand side of an
-assignment. An example is 
+assignment.  An example is 
 
 @example
 @group
 in @{1@} = ceil (rand (10, 1));
 in @{2@} = [];
 in @{3@} = "last";
 in @{4@} = "first";
 out = cell (4, 1);
 [out@{1:2@}] = find (in@{1 : 3@});
 [out@{3:4@}] = find (in@{[1, 2, 4]@});
 @end group
 @end example
 
 Structure arrays can equally be used to create comma separated
-lists. This is done by addressing one of the fields of a structure
-array. For example
+lists.  This is done by addressing one of the fields of a structure
+array.  For example
 
 @example
 @group
 x = ceil (randn (10, 1)); 
 in = struct ("call1", @{x, Inf, "last"@}, 
              "call2", @{x, Inf, "first"@});
 out = struct ("call1", cell (2, 1), "call2", cell (2, 1));
 [out.call1] = find (in.call1);
diff --git a/doc/interpreter/data.txi b/doc/interpreter/data.txi
--- a/doc/interpreter/data.txi
+++ b/doc/interpreter/data.txi
@@ -42,17 +42,17 @@ to define a new data type for Octave.
 
 @node Built-in Data Types
 @section Built-in Data Types
 @cindex data types, built-in
 @cindex built-in data types
 
 The standard built-in data types are real and complex scalars and
 matrices, ranges, character strings, a data structure type, and cell
-arrays. Additional built-in data types may be added in future versions.
+arrays.  Additional built-in data types may be added in future versions.
 If you need a specialized data type that is not currently provided as a
 built-in type, you are encouraged to write your own user-defined data
 type and contribute it for distribution in a future release of Octave.
 
 The data type of a variable can be determined and changed through the
 use of the following functions.
 
 @DOCSTRING(class)
@@ -108,18 +108,18 @@ using a variety of powerful indexing fea
 
 @xref{Numeric Data Types}, for more information.
 
 @node Missing Data
 @subsection Missing Data
 @cindex missing data
 
 It is possible to represent missing data explicitly in Octave using
-@code{NA} (short for ``Not Available''). Missing data can only be
-represented when data is represented as floating point numbers. In this
+@code{NA} (short for ``Not Available'').  Missing data can only be
+represented when data is represented as floating point numbers.  In this
 case missing data is represented as a special case of the representation
 of @code{NaN}.
 
 @DOCSTRING(NA)
 
 @DOCSTRING(isna)
 
 @node String Objects
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -301,17 +301,17 @@ easily be misinterpreted.
 * Empty Matrices::              
 @end menu
 
 @node Empty Matrices
 @subsection Empty Matrices
 
 A matrix may have one or both dimensions zero, and operations on empty
 matrices are handled as described by Carl de Boor in @cite{An Empty
-Exercise}, SIGNUM, Volume 25, pages 2--6, 1990 and C. N. Nett and W. M.
+Exercise}, SIGNUM, Volume 25, pages 2-6, 1990 and C. N. Nett and W. M.
 Haddad, in @cite{A System-Theoretic Appropriate Realization of the Empty
 Matrix Concept}, IEEE Transactions on Automatic Control, Volume 38,
 Number 5, May 1993.
 @iftex
 @tex
 Briefly, given a scalar $s$, an $m\times n$ matrix $M_{m\times n}$,
 and an $m\times n$ empty matrix $[\,]_{m\times n}$ (with either one or
 both dimensions equal to zero), the following are true:
@@ -407,33 +407,33 @@ When Octave parses a range expression, i
 expression to determine whether they are all constants.  If they are, it
 replaces the range expression with a single range constant.
 
 @node Single Precision Data Types
 @section Single Precision Data Types
 
 Octave includes support for single precision data types, and most of the
 functions in Octave accept single precision values and return single
-precion answers. A single precision variable is created with the
+precision answers.  A single precision variable is created with the
 @code{single} function.
 
 @DOCSTRING(single)
 
 for example
 
 @example
 sngl = single (rand (2, 2))
      @result{} sngl = 
         0.37569   0.92982
         0.11962   0.50876
 class (sngl)
     @result{} single
 @end example
 
-Many functions can also return single precision values directly. For
+Many functions can also return single precision values directly.  For
 example
 
 @example
 ones (2, 2, "single")
 zeros (2, 2, "single")
 eye (2, 2,  "single")
 rand (2, 2, "single")
 NaN (2, 2, "single")
@@ -443,25 +443,25 @@ Inf (2, 2, "single")
 
 @noindent
 will all return single precision matrices.
 
 @node Integer Data Types
 @section Integer Data Types
 
 Octave supports integer matrices as an alternative to using double
-precision. It is possible to use both signed and unsigned integers
-represented by 8, 16, 32, or 64 bits. It should be noted that most
+precision.  It is possible to use both signed and unsigned integers
+represented by 8, 16, 32, or 64 bits.  It should be noted that most
 computations require floating point data, meaning that integers will
-often change type when involved in numeric computations. For this
+often change type when involved in numeric computations.  For this
 reason integers are most often used to store data, and not for
 calculations.
 
 In general most integer matrices are created by casting
-existing matrices to integers. The following example shows how to cast
+existing matrices to integers.  The following example shows how to cast
 a matrix into 32 bit integers.
 
 @example
 float = rand (2, 2)
      @result{} float = 0.37569   0.92982
                 0.11962   0.50876
 integer = int32 (float)
      @result{} integer = 0  1
@@ -500,73 +500,73 @@ when converted.
 * Integer Arithmetic::
 @end menu
 
 @node Integer Arithmetic
 @subsection Integer Arithmetic
 
 While many numerical computations can't be carried out in integers,
 Octave does support basic operations like addition and multiplication
-on integers. The operators @code{+}, @code{-}, @code{.*}, and @code{./}
-work on integers of the same type. So, it is possible to add two 32 bit
+on integers.  The operators @code{+}, @code{-}, @code{.*}, and @code{./}
+work on integers of the same type.  So, it is possible to add two 32 bit
 integers, but not to add a 32 bit integer and a 16 bit integer.
 
 The arithmetic operations on integers are performed by casting the
 integer values to double precision values, performing the operation, and
-then re-casting the values back to the original integer type. As the
+then re-casting the values back to the original integer type.  As the
 double precision type of Octave is only capable of representing integers
 with up to 53 bits of precision, it is not possible to perform
 arithmetic with 64 bit integer types.
 
 When doing integer arithmetic one should consider the possibility of
-underflow and overflow. This happens when the result of the computation
-can't be represented using the chosen integer type. As an example it is
+underflow and overflow.  This happens when the result of the computation
+can't be represented using the chosen integer type.  As an example it is
 not possible to represent the result of @math{10 - 20} when using
-unsigned integers. Octave makes sure that the result of integer
-computations is the integer that is closest to the true result. So, the
+unsigned integers.  Octave makes sure that the result of integer
+computations is the integer that is closest to the true result.  So, the
 result of @math{10 - 20} when using unsigned integers is zero.
 
 When doing integer division Octave will round the result to the nearest
-integer. This is different from most programming languages, where the
-result is often floored to the nearest integer. So, the result of
+integer.  This is different from most programming languages, where the
+result is often floored to the nearest integer.  So, the result of
 @code{int32(5)./int32(8)} is @code{1}.
 
 @DOCSTRING(idivide)
 
 @node Bit Manipulations
 @section Bit Manipulations
 
 Octave provides a number of functions for the manipulation of numeric
-values on a bit by bit basis. The basic functions to set and obtain the
+values on a bit by bit basis.  The basic functions to set and obtain the
 values of individual bits are @code{bitset} and @code{bitget}.
 
 @DOCSTRING(bitset)
 
 @DOCSTRING(bitget)
 
 The arguments to all of Octave's bitwise operations can be scalar or
 arrays, except for @code{bitcmp}, whose @var{k} argument must a
-scalar. In the case where more than one argument is an array, then all
+scalar.  In the case where more than one argument is an array, then all
 arguments must have the same shape, and the bitwise operator is applied
-to each of the elements of the argument individually. If at least one
+to each of the elements of the argument individually.  If at least one
 argument is a scalar and one an array, then the scalar argument is
-duplicated. Therefore
+duplicated.  Therefore
 
 @example
 bitget (100, 8:-1:1)
 @end example
 
 is the same as
 
 @example
 bitget (100 * ones (1, 8), 8:-1:1)
 @end example
 
 It should be noted that all values passed to the bit manipulation
-functions of Octave are treated as integers. Therefore, even though the
+functions of Octave are treated as integers.  Therefore, even though the
 example for @code{bitset} above passes the floating point value
 @code{10}, it is treated as the bits @code{[1, 0, 1, 0]} rather than the
 bits of the native floating point format representation of @code{10}.
 
 As the maximum value that can be represented by a number is important
 for bit manipulation, particularly when forming masks, Octave supplies
 the function @code{bitmax}.
 
@@ -580,29 +580,29 @@ operators.
 
 @DOCSTRING(bitand)
 
 @DOCSTRING(bitor)
 
 @DOCSTRING(bitxor)
 
 The bitwise 'not' operator is a unary operator that performs a logical
-negation of each of the bits of the value. For this to make sense, the
-mask against which the value is negated must be defined. Octave's
+negation of each of the bits of the value.  For this to make sense, the
+mask against which the value is negated must be defined.  Octave's
 bitwise 'not' operator is @code{bitcmp}.
 
 @DOCSTRING(bitcmp)
 
 Octave also includes the ability to left-shift and right-shift values bitwise.
 
 @DOCSTRING(bitshift)
 
-Bits that are shifted out of either end of the value are lost. Octave
+Bits that are shifted out of either end of the value are lost.  Octave
 also uses arithmetic shifts, where the sign bit of the value is kept
-during a right shift. For example
+during a right shift.  For example
 
 @example
 @group
 bitshift (-10, -1)
 @result{} -5
 bitshift (int8 (-1), -1)
 @result{} -1
 @end group
@@ -610,29 +610,29 @@ bitshift (int8 (-1), -1)
 
 Note that @code{bitshift (int8 (-1), -1)} is @code{-1} since the bit
 representation of @code{-1} in the @code{int8} data type is @code{[1, 1,
 1, 1, 1, 1, 1, 1]}.
 
 @node Logical Values
 @section Logical Values
 
-Octave has built-in support for logical values, i.e. variables that
-are either @code{true} or @code{false}. When comparing two variables,
+Octave has built-in support for logical values, i.e., variables that
+are either @code{true} or @code{false}.  When comparing two variables,
 the result will be a logical value whose value depends on whether or
 not the comparison is true.
 
 The basic logical operations are @code{&}, @code{|}, and @code{!},
 which correspond to ``Logical And'', ``Logical Or'', and ``Logical
-Negation''. These operations all follow the usual rules of logic.
+Negation''.  These operations all follow the usual rules of logic.
 
 It is also possible to use logical values as part of standard numerical
-calculations. In this case @code{true} is converted to @code{1}, and
+calculations.  In this case @code{true} is converted to @code{1}, and
 @code{false} to 0, both represented using double precision floating
-point numbers. So, the result of @code{true*22 - false/6} is @code{22}.
+point numbers.  So, the result of @code{true*22 - false/6} is @code{22}.
 
 Logical values can also be used to index matrices and cell arrays.
 When indexing with a logical array the result will be a vector containing
 the values corresponding to @code{true} parts of the logical array.
 The following example illustrates this.
 
 @example
 data = [ 1, 2; 3, 4 ];
@@ -653,48 +653,48 @@ or @code{false} functions.
 
 @DOCSTRING(true)
 
 @DOCSTRING(false)
 
 @node Promotion and Demotion of Data Types
 @section Promotion and Demotion of Data Types
 
-Many operators and functions can work with mixed data types. For example
+Many operators and functions can work with mixed data types.  For example
 
 @example
 uint8 (1) + 1
     @result{} 2
 @end example
 
 @noindent
 where the above operator works with an 8-bit integer and a double precision
-value and returns an 8-bit integer value. Note that the type is demoted
+value and returns an 8-bit integer value.  Note that the type is demoted
 to an 8-bit integer, rather than promoted to a double precision value as
-might be expected. The reason is that if Octave promoted values in
+might be expected.  The reason is that if Octave promoted values in
 expressions like the above with all numerical constants would need to be
-explicitly cast to the appropriate data type type like
+explicitly cast to the appropriate data type like
 
 @example
 uint8 (1) + uint8 (1)
     @result{} 2
 @end example
 
 @noindent
 which becomes difficult for the user to apply uniformly and might allow
-hard to find bugs to be introduced. The same applies to single precision
+hard to find bugs to be introduced.  The same applies to single precision
 values where a mixed operation such as
 
 @example
 single (1) + 1
     @result{} 2
 @end example
 
 @noindent
-returns a single precision value. The mixed operations that are valid
+returns a single precision value.  The mixed operations that are valid
 and their returned data types are
 
 @multitable @columnfractions .2 .3 .3 .2
 @item @tab Mixed Operation @tab  Result @tab 
 @item @tab double OP single @tab single @tab
 @item @tab double OP integer @tab integer @tab
 @item @tab double OP char @tab double @tab
 @item @tab double OP logical @tab double @tab
@@ -709,35 +709,35 @@ The same logic applies to functions with
 min (single (1), 0)
    @result{} 0
 @end example
 
 @noindent
 where the returned value is single precision.
 
 In the case of mixed type indexed assignments, the type is not
-changed. For example
+changed.  For example
 
 @example
 x = ones (2, 2);
 x (1, 1) = single (2)
     @result{} x = 2   1
            1   1
 @end example
 
 @noindent
 where @code{x} remains of the double precision type. 
 
 @node Predicates for Numeric Objects
 @section Predicates for Numeric Objects
 
 Since the type of a variable may change during the execution of a
-program, it can be necessary to do type checking at run-time. Doing this
-also allows you to change the behaviour of a function depending on the
-type of the input. As an example, this naive implementation of @code{abs}
+program, it can be necessary to do type checking at run-time.  Doing this
+also allows you to change the behavior of a function depending on the
+type of the input.  As an example, this naive implementation of @code{abs}
 returns the absolute value of the input if it is a real number, and the
 length of the input if it is a complex number.
 
 @example
 function a = abs (x)
   if (isreal (x))
     a = sign (x) .* x;
   elseif (iscomplex (x))
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -309,17 +309,17 @@ strcat(@{"abc"; "ghi"@}, @{"def"; "jkl"@
          [1,1] = abcdef
          [2,1] = ghijkl
        @}
 @end group
 @end example
 
 @item @code{strcat} removes trailing white space in the arguments (except
 within cell arrays), while @code{cstrcat} leaves white space untouched.  Both
-kinds of behaviour can be useful as can be seen in the examples:
+kinds of behavior can be useful as can be seen in the examples:
 
 @example
 @group
 strcat(["dir1";"directory2"], ["/";"/"], ["file1";"file2"])
      @result{} ans =
        dir1/file1      
        directory2/file2
 @end group
@@ -372,17 +372,17 @@ element by element as the following exam
 GNU = "GNU's Not UNIX";
 spaces = (GNU == " ")
      @result{} spaces =
        0   0   0   0   0   1   0   0   0   1   0   0   0   0
 @end example
 
 @noindent To determine if two strings are identical it is necessary to use the
 @code{strcmp} function.  It compares complete strings and is case
-sensistive.  @code{strncmp} compares only the first @code{N} characters (with
+sensitive.  @code{strncmp} compares only the first @code{N} characters (with
 @code{N} given as a parameter).  @code{strcmpi} and @code{strncmpi} are the
 corresponding functions for case-insensitive comparison.
 
 @DOCSTRING(strcmp)
 
 @DOCSTRING(strncmp)
 
 @DOCSTRING(strcmpi)
@@ -391,25 +391,27 @@ corresponding functions for case-insensi
 
 @DOCSTRING(validatestring)
 
 @node Manipulating Strings
 @section Manipulating Strings
 
 Octave supports a wide range of functions for manipulating strings.
 Since a string is just a matrix, simple manipulations can be accomplished
-using standard operators. The following example shows how to replace
+using standard operators.  The following example shows how to replace
 all blank characters with underscores.
 
 @example
-quote = ...
+@group
+quote = @dots{}
   "First things first, but not necessarily in that order";
 quote( quote == " " ) = "_"
 @result{} quote = 
     First_things_first,_but_not_necessarily_in_that_order
+@end group
 @end example
 
 For more complex manipulations, such as searching, replacing, and
 general regular expressions, the following functions come with Octave.
 
 @DOCSTRING(deblank)
 
 @DOCSTRING(strtrim)
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} celldisp (@var{c}, @var{name})
-## Recursively display the contents of a cell array. By default the values
-## are displayed with the name of the variable @var{c}. However, this name
+## Recursively display the contents of a cell array.  By default the values
+## are displayed with the name of the variable @var{c}.  However, this name
 ## can be replaced with the variable @var{name}.
 ## @seealso{disp}
 ## @end deftypefn
 
 ## This is ugly, but seems to be what matlab does..
 
 function celldisp (c, name)
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -13,22 +13,22 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} idivide (@var{x}, @var{y}, @var{op})
-## Integer division with different round rules. The standard behavior of
+## Integer division with different round rules.  The standard behavior of
 ## the an integer division such as @code{@var{a} ./ @var{b}} is to round
-## the result to the nearest integer. This is not always the desired
+## the result to the nearest integer.  This is not always the desired
 ## behavior and @code{idivide} permits integer element-by-element
 ## division to be performed with different treatment for the fractional
-## part of the division as determined by the @var{op} flag. @var{op} is
+## part of the division as determined by the @var{op} flag.  @var{op} is
 ## a string with one of the values: 
 ##
 ## @table @asis
 ## @item "fix"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards zero.
 ## @item "round"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -18,49 +18,49 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} structfun (@var{func}, @var{s})
 ## @deftypefnx {Function File} {[@var{a}, @var{b}] =} structfun (@dots{})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "UniformOutput", @var{val})
 ## 
 ## Evaluate the function named @var{name} on the fields of the structure
-## @var{s}. The fields of @var{s} are passed to the function @var{func}
+## @var{s}.  The fields of @var{s} are passed to the function @var{func}
 ## individually.
 ##
 ## @code{structfun} accepts an arbitrary function @var{func} in the form of 
 ## an inline function, function handle, or the name of a function (in a 
-## character string). In the case of a character string argument, the 
+## character string).  In the case of a character string argument, the 
 ## function must accept a single argument named @var{x}, and it must return 
-## a string value. If the function returns more than one argument, they are
+## a string value.  If the function returns more than one argument, they are
 ## returned as separate output variables.
 ##
 ## If the parameter "UniformOutput" is set to true (the default), then the function
 ## must return a single element which will be concatenated into the
-## return value. If "UniformOutput" is false, the outputs placed in a structure
+## return value.  If "UniformOutput" is false, the outputs placed in a structure
 ## with the same fieldnames as the input structure.
 ## 
 ## @example
 ## @group
 ## s.name1 = "John Smith"; 
 ## s.name2 = "Jill Jones"; 
 ## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s, 
 ##            "UniformOutput", false)
 ## @end group
 ## @end example
 ## 
 ## Given the parameter "ErrorHandler", then @var{errfunc} defines a function to
-## call in case @var{func} generates an error. The form of the function is
+## call in case @var{func} generates an error.  The form of the function is
 ## 
 ## @example
 ## function [@dots{}] = errfunc (@var{se}, @dots{})
 ## @end example
 ## 
 ## where there is an additional input argument to @var{errfunc} relative to
-## @var{func}, given by @var{se}. This is a structure with the elements
+## @var{func}, given by @var{se}.  This is a structure with the elements
 ## "identifier", "message" and "index", giving respectively the error
 ## identifier, the error message, and the index into the input arguments
 ## of the element that caused the error.
 ## @seealso{cellfun, arrayfun}
 ## @end deftypefn
 
 function varargout = structfun (fun, s, varargin);
   if (nargin < 2)
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{}) 
-## Extract fields from a structure. For example
+## Extract fields from a structure.  For example
 ##
 ## @example
 ## @group
 ## ss(1,2).fd(3).b = 5;
 ## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
 ## @result{} ans = 5
 ## @end group
 ## @end example
diff --git a/scripts/miscellaneous/intwarning.m b/scripts/miscellaneous/intwarning.m
--- a/scripts/miscellaneous/intwarning.m
+++ b/scripts/miscellaneous/intwarning.m
@@ -21,46 +21,46 @@
 ## @deftypefnx {Function File} {} intwarning (@var{s})
 ## @deftypefnx {Function File} {@var{s} =} intwarning (@dots{})
 ## Control the state of the warning for integer conversions and math
 ## operations.
 ##
 ## @table @asis
 ## @item "query"
 ## The state of the Octave integer conversion and math warnings is
-## queried. If there is no output argument, then the state is printed.
+## queried.  If there is no output argument, then the state is printed.
 ## Otherwise it is returned in a structure with the fields "identifier"
 ## and "state".
 ##
 ## @smallexample
 ## @group
 ## intwarning ("query")
 ## The state of warning "Octave:int-convert-nan" is "off"
 ## The state of warning "Octave:int-convert-non-int-val" is "off"
 ## The state of warning "Octave:int-convert-overflow" is "off"
 ## The state of warning "Octave:int-math-overflow" is "off"
 ## @end group
 ## @end smallexample 
 ##
 ## @item "on"
-## Turn integer conversion and math warnings "on". If there is no output
-## argument, then nothing is printed. Otherwise the original state of
+## Turn integer conversion and math warnings "on".  If there is no output
+## argument, then nothing is printed.  Otherwise the original state of
 ## the state of the integer conversion and math warnings is returned in
 ## a structure array.
 ##
 ## @item "off"
-## Turn integer conversion and math warnings "on". If there is no output
-## argument, then nothing is printed. Otherwise the original state of
+## Turn integer conversion and math warnings "on".  If there is no output
+## argument, then nothing is printed.  Otherwise the original state of
 ## the state of the integer conversion and math warnings is returned in
 ## a structure array.
 ## @end table
 ##
 ## The original state of the integer warnings can be restored by passing
 ## the structure array returned by @code{intwarning} to a later call to
-## @code{intwarning}. For example
+## @code{intwarning}.  For example
 ##
 ## @example
 ## s = intwarning ("off");
 ## @dots{}
 ## intwarning (s);
 ## @end example
 ## @seealso{warning}
 ## @end deftypefn
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} swapbytes (@var{x})
 ## Swaps the byte order on values, converting from little endian to big 
-## endian and visa-versa. For example
+## endian and vice versa.  For example
 ##
 ## @example
 ## @group
 ## swapbytes (uint16 (1:4))
 ## @result{} [   256   512   768  1024]
 ## @end group
 ## @end example
 ##
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -27,17 +27,17 @@
 ## @end example
 ##
 ## If @var{s} is a matrix, returns a column vector with one value per
 ## row of @var{s}.  If a row contains invalid symbols then the
 ## corresponding value will be NaN.  Rows are right-justified before
 ## converting so that trailing spaces are ignored.
 ##
 ## If @var{b} is a string, the characters of @var{b} are used as the
-## symbols for the digits of @var{s}. Space (' ') may not be used as a
+## symbols for the digits of @var{s}.  Space (' ') may not be used as a
 ## symbol.
 ##
 ## @example
 ## base2dec ("yyyzx", "xyz")
 ##      @result{} 123
 ## @end example
 ## @seealso{dec2base, dec2bin, bin2dec, hex2dec, dec2hex}
 ## @end deftypefn
@@ -81,9 +81,9 @@ function out = base2dec (d, base)
   out = d * (base .^ (columns(d)-1 : -1 : 0)');
 
 endfunction
 
 %!error <Invalid call to base2dec.*> base2dec();
 %!error <Invalid call to base2dec.*> base2dec("11120");
 %!error <Invalid call to base2dec.*> base2dec("11120", 3, 4);
 %!assert(base2dec ("11120", 3), 123);
-%!assert(base2dec ("yyyzx", "xyz"), 123);
\ No newline at end of file
+%!assert(base2dec ("yyyzx", "xyz"), 123);
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cstrcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated
-## horizontally. Trailing white space is preserved. For example,
+## horizontally.  Trailing white space is preserved.  For example,
 ##
 ## @example
 ## @group
 ## cstrcat ("ab   ", "cd")
 ##      @result{} "ab   cd"
 ## @end group
 ## @end example
 ##
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -15,25 +15,25 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} mat2str (@var{x}, @var{n})
 ## @deftypefnx {Function File} {@var{s} =} mat2str (@dots{}, 'class')
 ##
-## Format real/complex numerical matrices as strings. This function
+## Format real/complex numerical matrices as strings.  This function
 ## returns values that are suitable for the use of the @code{eval}
 ## function.
 ##
-## The precision of the values is given by @var{n}. If @var{n} is a
+## The precision of the values is given by @var{n}.  If @var{n} is a
 ## scalar then both real and imaginary parts of the matrix are printed
-## to the same precision. Otherwise @code{@var{n} (1)} defines the
+## to the same precision.  Otherwise @code{@var{n} (1)} defines the
 ## precision of the real part and @code{@var{n} (2)} defines the
-## precision of the imaginary part. The default for @var{n} is 17.
+## precision of the imaginary part.  The default for @var{n} is 17.
 ##
 ## If the argument 'class' is given, then the class of @var{x} is
 ## included in the string in such a way that the eval will result in the
 ## construction of a matrix of the same class.
 ##
 ## @example
 ## @group
 ## mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -13,35 +13,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} regexptranslate (@var{op}, @var{s})
-## Translate a string for use in a regular expression. This might
+## Translate a string for use in a regular expression.  This might
 ## include either wildcard replacement or special character escaping.
 ## The behavior can be controlled by the @var{op} that can have the
 ## values
 ##
 ## @table @asis
 ## @item "wildcard"
 ## The wildcard characters @code{.}, @code{*} and @code{?} are replaced
-## with wildcards that are appropriate for a regular expression. For example:
+## with wildcards that are appropriate for a regular expression. 
+## For example:
 ## @example
 ## @group
 ## regexptranslate ("wildcard", "*.m")
 ##      @result{} ".*\.m"
 ## @end group
 ## @end example
 ## 
 ## @item "escape"
 ## The characters @code{$.?[]}, that have special meaning for regular
-## expressions are escaped so that they are treated literally. For example:
+## expressions are escaped so that they are treated literally.  For example:
 ## @example
 ## @group
 ## regexptranslate ("escape", "12.5")
 ##      @result{} "12\.5"
 ## @end group
 ## @end example
 ## @end table
 ## @seealso{regexp, regexpi, regexprep}
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} str2num (@var{s})
 ## Convert the string (or character array) @var{s} to a number (or an
-## array). Examples:  
+## array).  Examples:  
 ##
 ## @example
 ## @group
 ## str2num("3.141596")
 ##      @result{} 3.141596
 ## 
 ## str2num(["1, 2, 3"; "4, 5, 6"]);
 ##      @result{} ans =
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -18,17 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated
 ## horizontally.  If the arguments are cells strings,  @code{strcat}
 ## returns a cell string with the individual cells concatenated.
 ## For numerical input, each element is converted to the
-## corresponding ASCII character. Trailing white space is eliminated.
+## corresponding ASCII character.  Trailing white space is eliminated.
 ## For example,
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## strcat (s, s, s)
 ##      @result{} ans =
 ##         "ab ab ab "
diff --git a/scripts/strings/strchr.m b/scripts/strings/strchr.m
--- a/scripts/strings/strchr.m
+++ b/scripts/strings/strchr.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{idx} =} strchr (@var{str}, @var{chars})
 ## @deftypefnx {Function File} {@var{idx} =} strchr (@var{str}, @var{chars}, @var{n})
 ## @deftypefnx {Function File} {@var{idx} =} strchr (@var{str}, @var{chars}, @var{n}, @var{direction})
-## Search for the string @var{str} for occurences of characters from the set @var{chars}.
+## Search for the string @var{str} for occurrences of characters from the set @var{chars}.
 ## The return value, as well as the @var{n} and @var{direction} arguments behave
 ## identically as in @code{find}.
 ##
 ## This will be faster than using regexp in most cases.
 ##
 ## @seealso{find}
 ## @end deftypefn
 
diff --git a/scripts/strings/strcmpi.m b/scripts/strings/strcmpi.m
--- a/scripts/strings/strcmpi.m
+++ b/scripts/strings/strcmpi.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcmpi (@var{s1}, @var{s2})
 ## Ignoring case, return 1 if the character strings (or character
 ## arrays) @var{s1} and @var{s2} are the same, and 0 otherwise.
 ##
 ## If either @var{s1} or @var{s2} is a cell array of strings, then an array
 ## of the same size is returned, containing the values described above for
-## every member of the cell array. The other argument may also be a cell
+## every member of the cell array.  The other argument may also be a cell
 ## array of strings (of the same size or with only one element), char matrix
 ## or character string.
 ##
 ## @strong{Caution:} For compatibility with @sc{Matlab}, Octave's strcmpi
 ## function returns 1 if the character strings are equal, and 0 otherwise.
 ## This is just the opposite of the corresponding C library function.
 ## @seealso{strcmp, strncmp, strncmpi}
 ## @end deftypefn
diff --git a/scripts/strings/strfind.m b/scripts/strings/strfind.m
--- a/scripts/strings/strfind.m
+++ b/scripts/strings/strfind.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})
 ## Search for @var{pattern} in the string @var{str} and return the
 ## starting index of every such occurrence in the vector @var{idx}.
 ## If there is no such occurrence, or if @var{pattern} is longer
 ## than @var{str}, then @var{idx} is the empty array @code{[]}.
 ##
 ## If the cell array of strings @var{cellstr} is specified instead of the
 ## string @var{str}, then @var{idx} is a cell array of vectors, as specified
-## above. Examples:
+## above.  Examples:
 ##
 ## @example
 ## @group
 ## strfind ("abababa", "aba")
 ##      @result{} [1, 3, 5]
 ##
 ## strfind (@{"abababa", "bebebe", "ab"@}, "aba")
 ##      @result{} ans =
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strjust (@var{s}, ["left"|"right"|"center"])
 ## Shift the non-blank text of @var{s} to the left, right or center of
 ## the string.  If @var{s} is a string array, justify each string in the
 ## array.  Null characters are replaced by blanks.  If no justification
-## is specified, then all rows are right-justified. For example:
+## is specified, then all rows are right-justified.  For example:
 ##
 ## @example
 ## @group
 ## strjust (["a"; "ab"; "abc"; "abcd"])
 ##      @result{} ans =
 ##            a
 ##           ab
 ##          abc
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
 ## 
 ## Find all characters up to but not including the first character which
 ## is in the string delim.  If @var{rem} is requested, it contains the
-## remainder of the string, starting at the first deliminator. Leading
+## remainder of the string, starting at the first delimiter.  Leading
 ## delimiters are ignored.  If @var{delim} is not specified, space is
 ## assumed.  For example: 
 ##
 ## @example
 ## @group
 ## strtok ("this is the life")
 ##      @result{} "this"
 ##
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strtrim (@var{s})
 ## Remove leading and trailing blanks and nulls from @var{s}.  If
 ## @var{s} is a matrix, @var{strtrim} trims each row to the length of
 ## longest string.  If @var{s} is a cell array, operate recursively on
-## each element of the cell array. For example:
+## each element of the cell array.  For example:
 ##
 ## @example
 ## @group
 ## strtrim ("    abc  ")
 ##      @result{} "abc"
 ##
 ## strtrim ([" abc   "; "   def   "])
 ##      @result{} ["abc  "; "  def"]
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strtrunc (@var{s}, @var{n})
-## Truncate the character string @var{s} to length @var{n}. If @var{s}
+## Truncate the character string @var{s} to length @var{n}.  If @var{s}
 ## is a char matrix, then the number of columns is adjusted.
 ##
 ## If @var{s} is a cell array of strings, then the operation is performed
 ## on its members and the new cell array is returned.
 ## @end deftypefn
 
 function s = strtrunc (s, n)
 
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -70,57 +70,57 @@ Return the product of dimensions of each
 @item size\n\
 Return the size along the @var{k}-th dimension.\n\
 @item isclass\n\
 Return 1 for elements of @var{class}.\n\
 @end table\n\
 \n\
 Additionally, @code{cellfun} accepts an arbitrary function @var{func}\n\
 in the form of an inline function, function handle, or the name of a\n\
-function (in a character string). In the case of a character string\n\
+function (in a character string).  In the case of a character string\n\
 argument, the function must accept a single argument named @var{x}, and\n\
-it must return a string value. The function can take one or more arguments,\n\
-with the inputs args given by @var{c}, @var{d}, etc. Equally the function\n\
-can return one or more output arguments. For example\n\
+it must return a string value.  The function can take one or more arguments,\n\
+with the inputs args given by @var{c}, @var{d}, etc.  Equally the function\n\
+can return one or more output arguments.  For example\n\
 \n\
 @example\n\
 @group\n\
 cellfun (@@atan2, @{1, 0@}, @{0, 1@})\n\
 @result{}ans = [1.57080   0.00000]\n\
 @end group\n\
 @end example\n\
 \n\
 Note that the default output argument is an array of the same size as the\n\
 input arguments.\n\
 \n\
 If the parameter 'UniformOutput' is set to true (the default), then the function\n\
 must return a single element which will be concatenated into the\n\
-return value. If 'UniformOutput' is false, the outputs are concatenated in\n\
-a cell array. For example\n\
+return value.  If 'UniformOutput' is false, the outputs are concatenated in\n\
+a cell array.  For example\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower(x)\", @{\"Foo\", \"Bar\", \"FooBar\"@},\n\
          \"UniformOutput\",false)\n\
 @result{} ans = @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
 \n\
 Given the parameter 'ErrorHandler', then @var{errfunc} defines a function to\n\
-call in case @var{func} generates an error. The form of the function is\n\
+call in case @var{func} generates an error.  The form of the function is\n\
 \n\
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
 @end example\n\
 \n\
 where there is an additional input argument to @var{errfunc} relative to\n\
-@var{func}, given by @var{s}. This is a structure with the elements\n\
+@var{func}, given by @var{s}.  This is a structure with the elements\n\
 'identifier', 'message' and 'index', giving respectively the error\n\
 identifier, the error message, and the index into the input arguments\n\
-of the element that caused the error. For example\n\
+of the element that caused the error.  For example\n\
 \n\
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (@@factorial, @{-1,2@},'ErrorHandler',@@foo)\n\
 @result{} ans = [NaN 2]\n\
 @end group\n\
 @end example\n\
@@ -749,17 +749,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
 %! assert(c,{'.d','.h'})
 
 */
 
 DEFUN_DLD (num2cell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} num2cell (@var{m})\n\
 @deftypefnx {Loadable Function} {@var{c} =} num2cell (@var{m}, @var{dim})\n\
-Convert the matrix @var{m} into a cell array. If @var{dim} is defined, the\n\
+Convert the matrix @var{m} into a cell array.  If @var{dim} is defined, the\n\
 value @var{c} is of dimension 1 in this dimension and the elements of\n\
 @var{m} are placed in slices in @var{c}.\n\
 @seealso{mat2cell}\n\
 @end deftypefn") 
 {
   int nargin =  args.length();
   octave_value retval;
 
@@ -846,19 +846,19 @@ value @var{c} is of dimension 1 in this 
 
 */
 
 DEFUN_DLD (mat2cell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{m}, @var{n})\n\
 @deftypefnx {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{d1}, @var{d2}, @dots{})\n\
 @deftypefnx {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{r})\n\
-Convert the matrix @var{a} to a cell array. If @var{a} is 2-D, then\n\
+Convert the matrix @var{a} to a cell array.  If @var{a} is 2-D, then\n\
 it is required that @code{sum (@var{m}) == size (@var{a}, 1)} and\n\
-@code{sum (@var{n}) == size (@var{a}, 2)}. Similarly, if @var{a} is\n\
+@code{sum (@var{n}) == size (@var{a}, 2)}.  Similarly, if @var{a} is\n\
 a multi-dimensional and the number of dimensional arguments is equal\n\
 to the dimensions of @var{a}, then it is required that @code{sum (@var{di})\n\
 == size (@var{a}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
 arguments are assumed to equal @code{size (@var{a},@var{i})}.\n\
 \n\
 An example of the use of mat2cell is\n\
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (hex2num, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} hex2num (@var{s})\n\
 Typecast the 16 character hexadecimal character matrix to an IEEE 754\n\
-double precision number. If fewer than 16 characters are given the\n\
+double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
 hex2num ([\"4005bf0a8b145769\";\"4024000000000000\"])\n\
 @result{} [2.7183; 10.000]\n\
@@ -117,17 +117,17 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 /*
 %!assert (hex2num(['c00';'bff';'000';'3ff';'400']),[-2:2]')
 */
 
 DEFUN_DLD (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
-string of the IEEE 754 representation of the number. For example\n\
+string of the IEEE 754 representation of the number.  For example\n\
 \n\
 @example\n\
 num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
     4005bf0a8b145769\n\
     7ff0000000000000\n\
     fff8000000000000\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -871,17 +871,17 @@ octcellregexp (const octave_value_list &
 
 }
 
 DEFUN_DLD (regexp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexp (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, @var{opts}, @dots{})\n\
 \n\
-Regular expression string matching. Matches @var{pat} in @var{str} and\n\
+Regular expression string matching.  Matches @var{pat} in @var{str} and\n\
 returns the position and matching substrings or empty values if there are\n\
 none.\n\
 \n\
 The matched pattern @var{pat} can include any of the standard regex\n\
 operators, including:\n\
 \n\
 @table @code\n\
 @item .\n\
@@ -900,24 +900,24 @@ Match range operator, which is of the fo
 @var{n} times, @code{@{@var{m},@}} to match @var{m} or more times,\n\
 @code{@{@var{m},@var{n}@}} to match between @var{m} and @var{n} times.\n\
 @end table\n\
 @item [@dots{}] [^@dots{}]\n\
 List operators, where for example @code{[ab]c} matches @code{ac} and @code{bc}\n\
 @item ()\n\
 Grouping operator\n\
 @item |\n\
-Alternation operator. Match one of a choice of regular expressions. The\n\
+Alternation operator.  Match one of a choice of regular expressions.  The\n\
 alternatives must be delimited by the grouping operator @code{()} above\n\
 @item ^ $\n\
-Anchoring operator. @code{^} matches the start of the string @var{str} and\n\
+Anchoring operator.  @code{^} matches the start of the string @var{str} and\n\
 @code{$} the end\n\
 @end table\n\
 \n\
-In addition the following escaped characters have special meaning. It should\n\
+In addition the following escaped characters have special meaning.  It should\n\
 be noted that it is recommended to quote @var{pat} in single quotes rather\n\
 than double quotes, to avoid the escape sequences being interpreted by Octave\n\
 before being passed to @code{regexp}.\n\
 \n\
 @table @code\n\
 @item \\b\n\
 Match a word boundary\n\
 @item \\B\n\
@@ -956,36 +956,36 @@ The extents of each of the matched token
 @item @var{m}\n\
 A cell array of the text of each match.\n\
 \n\
 @item @var{t}\n\
 A cell array of the text of each token matched.\n\
 \n\
 @item @var{nm}\n\
 A structure containing the text of each matched named token, with the name\n\
-being used as the fieldname. A named token is denoted as\n\
+being used as the fieldname.  A named token is denoted as\n\
 @code{(?<name>@dots{})}\n\
 @end table\n\
 \n\
 Particular output arguments or the order of the output arguments can be\n\
-selected by additional @var{opts} arguments. These are strings and the\n\
+selected by additional @var{opts} arguments.  These are strings and the\n\
 correspondence between the output arguments and the optional argument\n\
 are\n\
 \n\
 @multitable @columnfractions 0.2 0.3 0.3 0.2\n\
 @item @tab 'start'        @tab @var{s}  @tab\n\
 @item @tab 'end'          @tab @var{e}  @tab\n\
 @item @tab 'tokenExtents' @tab @var{te} @tab\n\
 @item @tab 'match'        @tab @var{m}  @tab\n\
 @item @tab 'tokens'       @tab @var{t}  @tab\n\
 @item @tab 'names'        @tab @var{nm}  @tab\n\
 @end multitable\n\
 \n\
 A further optional argument is 'once', that limits the number of returned\n\
-matches to the first match. Additional arguments are\n\
+matches to the first match.  Additional arguments are\n\
 \n\
 @table @asis\n\
 @item matchcase\n\
 Make the matching case sensitive.\n\
 @item ignorecase\n\
 Make the matching case insensitive.\n\
 @item stringanchors\n\
 Match the anchor characters at the beginning and end of the string.\n\
@@ -1187,17 +1187,17 @@ The pattern is taken literally.\n\
 
 */
 
 DEFUN_DLD (regexpi, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexpi (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, @var{opts}, @dots{})\n\
 \n\
-Case insensitive regular expression string matching. Matches @var{pat} in\n\
+Case insensitive regular expression string matching.  Matches @var{pat} in\n\
 @var{str} and returns the position and matching substrings or empty values\n\
 if there are none.  @xref{doc-regexp,,regexp}, for more details\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length();
 
   if (nargin < 2)
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -127,17 +127,17 @@ typecast (const T& x, std::string type)
 
   return retval;
 }
 
 DEFUN_DLD (typecast, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} typecast (@var{x}, @var{type})\n\
 Convert from one datatype to another without changing the underlying\n\
-data. The argument @var{type} defines the type of the return argument\n\
+data.  The argument @var{type} defines the type of the return argument\n\
 and must be one of 'uint8', 'uint16', 'uint32', 'uint64', 'int8', 'int16',\n\
 'int32', 'int64', 'single' or 'double'.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -959,17 +959,17 @@ cell2struct_construct_idx (Array<octave_
       else
 	ra_idx1.elem (idx) = ra_idx2(iidx++);
     }
 }
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
-Convert @var{cell} to a structure. The number of fields in @var{fields}\n\
+Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
 \n\
 @example\n\
 @group\n\
 A = cell2struct (@{'Peter', 'Hannah', 'Robert';\n\
                    185, 170, 168@},\n\
                  @{'Name','Height'@}, 1);\n\
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -310,17 +310,17 @@ Return 1 if @var{a} is a character array
 DEFUN (strcmp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strcmp (@var{s1}, @var{s2})\n\
 Return 1 if the character strings @var{s1} and @var{s2} are the same,\n\
 and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
-every member of the cell array. The other argument may also be a cell\n\
+every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
 \n\
 @strong{Caution:} For compatibility with @sc{Matlab}, Octave's strcmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strcmpi, strncmp, strncmpi}\n\
 @end deftypefn")
@@ -617,17 +617,17 @@ and 0 otherwise.\n\
 @group\n\
 strncmp (\"abce\", \"abcd\", 3)\n\
      @result{} 1\n\
 @end group\n\
 @end example\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
-every member of the cell array. The other argument may also be a cell\n\
+every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", @{\"abcd\", \"bca\", \"abc\"@}, 3)\n\
      @result{} [1, 0, 1]\n\
 @end group\n\
