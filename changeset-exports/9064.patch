# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1238273842 25200
#      Sat Mar 28 13:57:22 2009 -0700
# Node ID 7c02ec148a3cde69aae831af90832597e7cecf2a
# Parent  a6cf0ad87eee95a5653a688c90b75ea070568ff0
Check grammar on all .cc files

Same check as previously done on .m files
Attempt to enforce some conformity in documentation text for rules
such as two spaces after a period, commas around latin abbreviations, etc.

diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -16,17 +16,17 @@
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Arithmetic
 @chapter Arithmetic
 
 Unless otherwise noted, all of the functions described in this chapter
-will work for real and complex scalar or matrix arguments. Functions described as @dfn{mapping functions} apply the given operation to each element when given a matrix argument.
+will work for real and complex scalar or matrix arguments.  Functions described as @dfn{mapping functions} apply the given operation to each element when given a matrix argument.
 
 @menu
 * Utility Functions::           
 * Complex Arithmetic::          
 * Trigonometry::                
 * Sums and Products::           
 * Special Functions::           
 * Coordinate Transformations::
@@ -147,17 +147,17 @@ specified in radians.  To convert from d
 @iftex
 @tex
 $\pi/180$
 @end tex
 @end iftex
 @ifinfo
 @code{pi/180}
 @end ifinfo
- (e.g. @code{sin (30 * pi/180)} returns the sine of 30 degrees).
+ (e.g., @code{sin (30 * pi/180)} returns the sine of 30 degrees).
 
 @DOCSTRING(sin)
 @DOCSTRING(cos)
 @DOCSTRING(tan)
 @DOCSTRING(sec)
 @DOCSTRING(csc)
 @DOCSTRING(cot)
 
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -344,17 +344,17 @@ read_images (const std::vector<Magick::I
 
 #endif
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
 @deftypefnx{Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
 @deftypefnx{Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
-Read images with ImageMagick++. In general you should not be using this function.\n\
+Read images with ImageMagick++.  In general you should not be using this function.\n\
 Instead you should use @code{imread}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
 
@@ -747,17 +747,17 @@ write_image (const std::string& filename
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
 @deftypefnx {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
-Write images with ImageMagick++. In general you should not be using this function.\n\
+Write images with ImageMagick++.  In general you should not be using this function.\n\
 Instead you should use @code{imwrite}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_MAGICK
   int nargin = args.length ();
@@ -875,17 +875,17 @@ magick_to_octave_value (const Magick::Im
     { \
     }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable File} {} __magick_finfo__(@var{fname})\n\
-Read image information with GraphicsMagick++. In general you should\n\
+Read image information with GraphicsMagick++.  In general you should\n\
 not be using this function.  Instead you should use @code{imfinfo}.\n\
 @seealso{imfinfo, imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -50,36 +50,36 @@ along with Octave; see the file COPYING.
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} amd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} amd (@var{s}, @var{opts})\n\
 \n\
-Returns the approximate minimum degree permutation of a matrix. This\n\
+Returns the approximate minimum degree permutation of a matrix.  This\n\
 permutation such that the Cholesky factorization of @code{@var{s} (@var{p},\n\
 @var{p})} tends to be sparser than the Cholesky factorization of @var{s}\n\
-itself. @code{amd} is typically faster than @code{symamd} but serves a\n\
+itself.  @code{amd} is typically faster than @code{symamd} but serves a\n\
 similar purpose.\n\
 \n\
 The optional parameter @var{opts} is a structure that controls the\n\
-behavior of @code{amd}. The fields of these structure are\n\
+behavior of @code{amd}.  The fields of these structure are\n\
 \n\
 @table @asis\n\
 @item opts.dense\n\
 Determines what @code{amd} considers to be a dense row or column of the\n\
-input matrix. Rows or columns with more that @code{max(16, (dense *\n\
+input matrix.  Rows or columns with more that @code{max(16, (dense *\n\
 sqrt (@var{n})} entries, where @var{n} is the order of the matrix @var{s},\n\
 are igorned by @code{amd} during the calculation of the permutation\n\
 The value of dense must be a positive scalar and its default value is 10.0\n\
 \n\
 @item opts.aggressive\n\
 If this value is a non zero scalar, then @code{amd} performs agressive\n\
-absorption. The default is not to perform agressive absorption.\n\
+absorption.  The default is not to perform agressive absorption.\n\
 @end table\n\
 \n\
 The author of the code itself is Timothy A. Davis (davis@@cise.ufl.edu),\n\
 University of Florida (see @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -57,19 +57,19 @@ DEFUN_DLD (balance, args, nargout,
 Compute @code{aa = dd \\ a * dd} in which @code{aa} is a matrix whose\n\
 row and column norms are roughly equal in magnitude, and\n\
 @code{dd} = @code{p * d}, in which @code{p} is a permutation\n\
 matrix and @code{d} is a diagonal matrix of powers of two.  This allows\n\
 the equilibration to be computed without roundoff.  Results of\n\
 eigenvalue calculation are typically improved by balancing first.\n\
 \n\
 If two output values are requested, @code{balance} returns \n\
-the diagonal @code{d} and the permutation @code{p} separately as vectors. \n\
+the diagonal @code{d} and the permutation @code{p} separately as vectors.  \n\
 In this case, @code{dd = eye(n)(p,:) * diag (d)}, where @code{n} is the matrix \n\
-size. \n\
+size.  \n\
 \n\
 If four output values are requested, compute @code{aa = cc*a*dd} and\n\
 @code{bb = cc*b*dd)}, in which @code{aa} and @code{bb} have non-zero\n\
 elements of approximately the same magnitude and @code{cc} and @code{dd}\n\
 are permuted diagonal matrices as in @code{dd} for the algebraic\n\
 eigenvalue problem.\n\
 \n\
 The eigenvalue balancing option @code{opt} may be one of:\n\
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -383,30 +383,30 @@ DEFUN_DLD (besselj, args, nargout,
 @deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
-Bessel functions of the first kind. If the argument @var{opt} is supplied, \n\
+Bessel functions of the first kind.  If the argument @var{opt} is supplied, \n\
 the result is multiplied by @code{exp(-abs(imag(x)))}.\n\
 @item bessely\n\
-Bessel functions of the second kind. If the argument @var{opt} is supplied,\n\
+Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
 the result is multiplied by @code{exp(-abs(imag(x)))}.\n\
 @item besseli\n\
 Modified Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
 the result is multiplied by @code{exp(-abs(real(x)))}.\n\
 @item besselk\n\
 Modified Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
 the result is multiplied by @code{exp(x)}.\n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
-= 2) kind. If the argument @var{opt} is supplied, the result is multiplied by\n\
+= 2) kind.  If the argument @var{opt} is supplied, the result is multiplied by\n\
 @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
 If @var{alpha} is a scalar, the result is the same size as @var{x}.\n\
 If @var{x} is a scalar, the result is the same size as @var{alpha}.\n\
 If @var{alpha} is a row vector and @var{x} is a column vector, the\n\
 result is a matrix with @code{length (@var{x})} rows and\n\
@@ -513,22 +513,24 @@ See besselj.\n\
 
 DEFUN_DLD (airy, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
+@group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
  1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
  2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
  3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+@end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
 If requested, @var{ierr} contains the following status information and\n\
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -53,34 +53,34 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (ccolamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} ccolamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
-Constrained column approximate minimum degree permutation. @code{@var{p} =\n\
+Constrained column approximate minimum degree permutation.  @code{@var{p} =\n\
 ccolamd (@var{s})} returns the column approximate minimum degree permutation\n\
-vector for the sparse matrix @var{s}. For a non-symmetric matrix @var{s},\n\
+vector for the sparse matrix @var{s}.  For a non-symmetric matrix @var{s},\n\
 @code{@var{s} (:, @var{p})} tends to have sparser LU factors than @var{s}.\n\
 @code{chol (@var{s} (:, @var{p})' * @var{s} (:, @var{p}))} also tends to be\n\
-sparser than @code{chol (@var{s}' * @var{s})}. @code{@var{p} = ccolamd\n\
+sparser than @code{chol (@var{s}' * @var{s})}.  @code{@var{p} = ccolamd\n\
 (@var{s}, 1)} optimizes the ordering for @code{lu (@var{s} (:, @var{p}))}.\n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 @var{knobs} is an optional one- to five-element input vector, with a default\n\
 value of @code{[0 10 10 1 0]} if not present or empty.  Entries not present\n\
 are set to their defaults.\n\
 \n\
 @table @code\n\
 @item @var{knobs}(1)\n\
-if nonzero, the ordering is optimized for @code{lu (S (:, p))}. It will be a\n\
+if nonzero, the ordering is optimized for @code{lu (S (:, p))}.  It will be a\n\
 poor ordering for @code{chol (@var{s} (:, @var{p})' * @var{s} (:,\n\
-@var{p}))}. This is the most important knob for ccolamd.\n\
+@var{p}))}.  This is the most important knob for ccolamd.\n\
 \n\
 @item @var{knob}(2)\n\
 if @var{s} is m-by-n, rows with more than @code{max (16, @var{knobs} (2) *\n\
 sqrt (n))} entries are ignored.\n\
 \n\
 @item @var{knob}(3)\n\
 columns with more than @code{max (16, @var{knobs} (3) * sqrt (min (@var{m},\n\
 @var{n})))} entries are ignored and ordered last in the output permutation\n\
@@ -98,44 +98,44 @@ if nonzero, statistics and knobs are pri
 on the column ordering.  If @code{@var{cmember} (j) = @var{c}}, then column\n\
 @var{j} is in constraint set @var{c} (@var{c} must be in the range 1 to\n\
 @var{n}).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
 ones(1,n)} if not present or empty.  @code{ccolamd (@var{s}, [], 1 :\n\
 @var{n})} returns @code{1 : @var{n}}\n\
 \n\
 @code{@var{p} = ccolamd (@var{s})} is about the same as @code{@var{p} =\n\
-colamd (@var{s})}. @var{knobs} and its default values differ. @code{colamd}\n\
+colamd (@var{s})}.  @var{knobs} and its default values differ.  @code{colamd}\n\
 always does aggressive absorption, and it finds an ordering suitable for\n\
 both @code{lu (@var{s} (:, @var{p}))} and @code{chol (@var{S} (:, @var{p})'\n\
 * @var{s} (:, @var{p}))}; it cannot optimize its ordering for\n\
 @code{lu (@var{s} (:, @var{p}))} to the extent that\n\
 @code{ccolamd (@var{s}, 1)} can.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
-about the ordering and the validity of the input matrix @var{s}. Ordering\n\
-statistics are in @code{@var{stats} (1 : 3)}. @code{@var{stats} (1)} and\n\
+about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
+statistics are in @code{@var{stats} (1 : 3)}.  @code{@var{stats} (1)} and\n\
 @code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
 ignored by CCOLAMD and @code{@var{stats} (3)} is the number of garbage\n\
 collections performed on the internal data structure used by CCOLAMD\n\
 (roughly of size @code{2.2 * nnz (@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
 integers).\n\
 \n\
 @code{@var{stats} (4 : 7)} provide information if CCOLAMD was able to\n\
-continue. The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
-invalid. @code{@var{stats} (5)} is the rightmost column index that is\n\
+continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
+invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
-such row index exists. @code{@var{stats} (7)} is the number of duplicate\n\
-or out-of-order row indices. @code{@var{stats} (8 : 20)} is always zero in\n\
+such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
+or out-of-order row indices.  @code{@var{stats} (8 : 20)} is always zero in\n\
 the current version of CCOLAMD (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
-and S. Rajamanickam in collaboration with J. Bilbert and E. Ng. Supported\n\
+and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
 @seealso{colamd, csymamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -335,20 +335,20 @@ DEFUN_DLD (csymamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} csymamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
 For a symmetric positive definite matrix @var{s}, returns the permutation\n\
 vector @var{p} such that @code{@var{s}(@var{p},@var{p})} tends to have a\n\
-sparser Cholesky factor than @var{s}. Sometimes @code{csymamd} works well\n\
-for symmetric indefinite matrices too. The matrix @var{s} is assumed to\n\
+sparser Cholesky factor than @var{s}.  Sometimes @code{csymamd} works well\n\
+for symmetric indefinite matrices too.  The matrix @var{s} is assumed to\n\
 be symmetric; only the strictly lower triangular part is referenced.\n\
-@var{s} must be square. The ordering is followed by an elimination tree\n\
+@var{s} must be square.  The ordering is followed by an elimination tree\n\
 post-ordering.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector, with a\n\
 default value of @code{[10 1 0]} if present or empty.  Entries not\n\
 present are set to their defaults.\n\
 \n\
 @table @code\n\
 @item @var{knobs}(1)\n\
@@ -360,37 +360,37 @@ last in the output permutation (subject 
 If nonzero, aggressive absorption is performed.\n\
 \n\
 @item @var{knobs}(3)\n\
 If nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length n. It defines the constraints\n\
-on the ordering. If @code{@var{cmember}(j) = @var{s}}, then row/column j is\n\
-in constraint set @var{c} (@var{c} must be in the range 1 to n). In the\n\
+on the ordering.  If @code{@var{cmember}(j) = @var{s}}, then row/column j is\n\
+in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
-by all rows/columns in set 2, and so on. @code{@var{cmember} = ones(1,n)}\n\
-if not present or empty. @code{csymamd(@var{s},[],1:n)} returns @code{1:n}.\n\
+by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)}\n\
+if not present or empty.  @code{csymamd(@var{s},[],1:n)} returns @code{1:n}.\n\
 \n\
 @code{@var{p} = csymamd(@var{s})} is about the same as @code{@var{p} =\n\
-symamd(@var{s})}. @var{knobs} and its default values differ.\n\
+symamd(@var{s})}.  @var{knobs} and its default values differ.\n\
 \n\
 @code{@var{stats} (4:7)} provide information if CCOLAMD was able to\n\
-continue. The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
-invalid. @code{@var{stats} (5)} is the rightmost column index that is\n\
+continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
+invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
-such row index exists. @code{@var{stats} (7)} is the number of duplicate\n\
-or out-of-order row indices. @code{@var{stats} (8:20)} is always zero in\n\
+such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
+or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in\n\
 the current version of CCOLAMD (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
-and S. Rajamanickam in collaboration with J. Bilbert and E. Ng. Supported\n\
+and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
 @seealso{symamd, ccolamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1248,21 +1248,23 @@ do_cellslices_nda (const NDA& array, con
 DEFUN_DLD (cellslices, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub})\n\
 Given a vector @var{x}, this function produces a cell array of slices from the vector\n\
 determined by the index vectors @var{lb}, @var{ub}, for lower and upper bounds, respectively.\n\
 In other words, it is equivalent to the following code:\n\
 \n\
 @example\n\
+@group\n\
 n = length (lb);\n\
 sl = cell (1, n);\n\
 for i = 1:length (lb)\n\
   sl@{i@} = x(lb(i):ub(i));\n\
 endfor\n\
+@end group\n\
 @end example\n\
 \n\
 If @var{X} is a matrix or array, indexing is done along the last dimension.\n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -63,23 +63,23 @@ matrix @var{a}, where\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{a}.\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 Called with one output argument @code{chol} fails if @var{a} or @var{s} is\n\
-not positive definite. With two or more output arguments @var{p} flags\n\
-whether the matrix was positive definite and @code{chol} does not fail. A\n\
+not positive definite.  With two or more output arguments @var{p} flags\n\
+whether the matrix was positive definite and @code{chol} does not fail.  A\n\
 zero value indicated that the matrix was positive definite and the @var{r}\n\
 gives the factorization, annd @var{p} will have a positive value otherwise.\n\
 \n\
 If called with 3 outputs then a sparsity preserving row/column permutation\n\
-is applied to @var{a} prior to the factorization. That is @var{r}\n\
+is applied to @var{a} prior to the factorization.  That is @var{r}\n\
 is the factorization of @code{@var{a}(@var{q},@var{q})} such that\n\
 @iftex\n\
 @tex\n\
 $ R^T R = Q^T A Q$.\n\
 @end tex\n\
 @end iftex\n\
 @ifnottex\n\
 \n\
@@ -799,17 +799,17 @@ If @var{info} is not present, an error m
 
 DEFUN_DLD (cholinsert, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
 return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
-@w{p = [1:j-1,j+1:n+1]}. @w{u(j)} should be positive.\n\
+@w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 On return, @var{info} is set to\n\
 @itemize\n\
 @item 0 if the insertion was successful,\n\
 @item 1 if @var{A1} is not positive definite,\n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
 If @var{info} is not present, an error message is printed in cases 1 and 2.\n\
@@ -1117,17 +1117,17 @@ DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
 return the Cholesky@tie{}factorization of\n\
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
-@code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}. @*\n\
+@code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
 @seealso{chol, cholinsert, choldelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -210,73 +210,73 @@ coletree (const octave_idx_type *ridx, c
 
 DEFUN_DLD (colamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} colamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s}, @var{knobs})\n\
 \n\
-Column approximate minimum degree permutation. @code{@var{p} = colamd\n\
+Column approximate minimum degree permutation.  @code{@var{p} = colamd\n\
 (@var{s})} returns the column approximate minimum degree permutation\n\
-vector for the sparse matrix @var{s}. For a non-symmetric matrix @var{s},\n\
+vector for the sparse matrix @var{s}.  For a non-symmetric matrix @var{s},\n\
 @code{@var{s} (:,@var{p})} tends to have sparser LU factors than @var{s}.\n\
 The Cholesky factorization of @code{@var{s} (:,@var{p})' * @var{s}\n\
 (:,@var{p})} also tends to be sparser than that of @code{@var{s}' *\n\
 @var{s}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{s} is\n\
 m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))} entries\n\
-are ignored. Columns with more than @code{max(16,knobs(2)*sqrt(min(m,n)))}\n\
+are ignored.  Columns with more than @code{max(16,knobs(2)*sqrt(min(m,n)))}\n\
 entries are removed prior to ordering, and ordered last in the output\n\
-permutation @var{p}. Only completely dense rows or columns are removed\n\
+permutation @var{p}.  Only completely dense rows or columns are removed\n\
 if @code{@var{knobs} (1)} and @code{@var{knobs} (2)} are < 0, respectively.\n\
 If @code{@var{knobs} (3)} is nonzero, @var{stats} and @var{knobs} are\n\
 printed.  The default is @code{@var{knobs} = [10 10 0]}.  Note that\n\
 @var{knobs} differs from earlier versions of colamd\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
-about the ordering and the validity of the input matrix @var{s}. Ordering\n\
-statistics are in @code{@var{stats} (1:3)}. @code{@var{stats} (1)} and\n\
+about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
+statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1)} and\n\
 @code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
 ignored by COLAMD and @code{@var{stats} (3)} is the number of garbage\n\
 collections performed on the internal data structure used by COLAMD\n\
 (roughly of size @code{2.2 * nnz(@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
 integers).\n\
 \n\
 Octave built-in functions are intended to generate valid sparse matrices,\n\
 with no duplicate entries, with ascending row indices of the nonzeros\n\
 in each column, with a non-negative number of entries in each column (!)\n\
 and so on.  If a matrix is invalid, then COLAMD may or may not be able\n\
 to continue.  If there are duplicate entries (a row index appears two or\n\
 more times in the same column) or if the row indices in a column are out\n\
 of order, then COLAMD can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix\n\
-@var{s} (the input matrix @var{s} is not repaired, however). If a matrix\n\
+@var{s} (the input matrix @var{s} is not repaired, however).  If a matrix\n\
 is invalid in other ways then COLAMD cannot continue, an error message is\n\
 printed, and no output arguments (@var{p} or @var{stats}) are returned.\n\
 COLAMD is thus a simple way to check a sparse matrix to see if it's\n\
 valid.\n\
 \n\
 @code{@var{stats} (4:7)} provide information if COLAMD was able to\n\
-continue. The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
-invalid. @code{@var{stats} (5)} is the rightmost column index that is\n\
+continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
+invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
-such row index exists. @code{@var{stats} (7)} is the number of duplicate\n\
-or out-of-order row indices. @code{@var{stats} (8:20)} is always zero in\n\
+such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
+or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in\n\
 the current version of COLAMD (reserved for future use).\n\
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
 Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
-Ng, Oak Ridge National Laboratory. (see\n\
+Ng, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, symamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
@@ -451,32 +451,32 @@ DEFUN_DLD (symamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} symamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s}, @var{knobs})\n\
 \n\
 For a symmetric positive definite matrix @var{s}, returns the permutation\n\
 vector p such that @code{@var{s} (@var{p}, @var{p})} tends to have a\n\
-sparser Cholesky factor than @var{s}. Sometimes SYMAMD works well for\n\
-symmetric indefinite matrices too. The matrix @var{s} is assumed to be\n\
-symmetric; only the strictly lower triangular part is referenced. @var{s}\n\
+sparser Cholesky factor than @var{s}.  Sometimes SYMAMD works well for\n\
+symmetric indefinite matrices too.  The matrix @var{s} is assumed to be\n\
+symmetric; only the strictly lower triangular part is referenced.  @var{s}\n\
 must be square.\n\
 \n\
 @var{knobs} is an optional one- to two-element input vector.  If @var{s} is\n\
 n-by-n, then rows and columns with more than\n\
 @code{max(16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
-and ordered last in the output permutation @var{p}. No rows/columns are\n\
+and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
 @code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs} \n\
 = [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
-about the ordering and the validity of the input matrix @var{s}. Ordering\n\
-statistics are in @code{@var{stats} (1:3)}. @code{@var{stats} (1) =\n\
+about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
+statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1) =\n\
 @var{stats} (2)} is the number of dense or empty rows and columns\n\
 ignored by SYMAMD and @code{@var{stats} (3)} is the number of garbage\n\
 collections performed on the internal data structure used by SYMAMD\n\
 (roughly of size @code{8.4 * nnz (tril (@var{s}, -1)) + 9 * @var{n}}\n\
 integers).\n\
 \n\
 Octave built-in functions are intended to generate valid sparse matrices,\n\
 with no duplicate entries, with ascending row indices of the nonzeros\n\
@@ -487,32 +487,32 @@ more times in the same column) or if the
 of order, then SYMAMD can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix S (the\n\
 input matrix S is not repaired, however).  If a matrix is invalid in\n\
 other ways then SYMAMD cannot continue, an error message is printed, and\n\
 no output arguments (@var{p} or @var{stats}) are returned.  SYMAMD is\n\
 thus a simple way to check a sparse matrix to see if it's valid.\n\
 \n\
 @code{@var{stats} (4:7)} provide information if SYMAMD was able to\n\
-continue. The matrix is OK if @code{@var{stats} (4)} is zero, or 1\n\
-if invalid. @code{@var{stats} (5)} is the rightmost column index that\n\
+continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1\n\
+if invalid.  @code{@var{stats} (5)} is the rightmost column index that\n\
 is unsorted or contains duplicate entries, or zero if no such column\n\
-exists. @code{@var{stats} (6)} is the last seen duplicate or out-of-order\n\
+exists.  @code{@var{stats} (6)} is the last seen duplicate or out-of-order\n\
 row index in the column index given by @code{@var{stats} (5)}, or zero\n\
-if no such row index exists. @code{@var{stats} (7)} is the number of\n\
-duplicate or out-of-order row indices. @code{@var{stats} (8:20)} is\n\
+if no such row index exists.  @code{@var{stats} (7)} is the number of\n\
+duplicate or out-of-order row indices.  @code{@var{stats} (8:20)} is\n\
 always zero in the current version of SYMAMD (reserved for future use).\n\
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
 Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
-Ng, Oak Ridge National Laboratory. (see\n\
+Ng, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, colamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
@@ -645,20 +645,20 @@ Ng, Oak Ridge National Laboratory. (see\
 }
 
 DEFUN_DLD (etree, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} etree (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{s}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{s}, @var{typ})\n\
 \n\
-Returns the elimination tree for the matrix @var{s}. By default @var{s}\n\
+Returns the elimination tree for the matrix @var{s}.  By default @var{s}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
-returned. The argument @var{typ} controls whether a symmetric or\n\
-column elimination tree is returned. Valid values of @var{typ} are\n\
+returned.  The argument @var{typ} controls whether a symmetric or\n\
+column elimination tree is returned.  Valid values of @var{typ} are\n\
 'sym' or 'col', for symmetric or column elimination tree respectively\n\
 \n\
 Called with a second argument, @dfn{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -261,17 +261,17 @@ of @var{c} is given by\n\
 @item @var{shape}= 'full'\n\
 returns full 2-D convolution\n\
 @item @var{shape}= 'same'\n\
 same size as a. 'central' part of convolution\n\
 @item @var{shape}= 'valid'\n\
 only parts which do not include zero-padded edges\n\
 @end table\n\
 \n\
-By default @var{shape} is 'full'. When the third argument is a matrix\n\
+By default @var{shape} is 'full'.  When the third argument is a matrix\n\
 returns the convolution of the matrix @var{M} by the vector @var{v1}\n\
 in the column direction and by vector @var{v2} in the row direction\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
   std::string shape= "full"; //default
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -226,28 +226,32 @@ function to compute the modified Jacobia
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
+@end group\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
+@group\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
 \n\
+@end group\n\
 @end example\n\
 \n\
 The second and third arguments to @code{daspk} specify the initial\n\
 condition of the states and their derivatives, and the fourth argument\n\
 specifies a vector of output times at which the solution is desired,\n\
 including the time corresponding to the initial condition.\n\
 \n\
 The set of initial states and derivatives are not strictly required to\n\
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -270,29 +270,33 @@ function to compute the modified Jacobia
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
+@end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
+@group\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
 \n\
+@end group\n\
 @end example\n\
 \n\
 The optional second argument names a function that defines the\n\
 constraint functions whose roots are desired during the integration.\n\
 This function must have the form\n\
 \n\
 @example\n\
 @var{g_out} = g (@var{x}, @var{t})\n\
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -231,28 +231,32 @@ function to compute the modified Jacobia
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
 @ifnottex\n\
 @example\n\
+@group\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
+@end group\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
+@group\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
 \n\
+@end group\n\
 @end example\n\
 \n\
 The second and third arguments to @code{dassl} specify the initial\n\
 condition of the states and their derivatives, and the fourth argument\n\
 specifies a vector of output times at which the solution is desired,\n\
 including the time corresponding to the initial condition.\n\
 \n\
 The set of initial states and derivatives are not strictly required to\n\
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -157,17 +157,17 @@ DEFUN_DLD (dlmread, args, ,
 Read the matrix @var{data} from a text file.  If not defined the separator\n\
 between fields is determined from the file itself.  Otherwise the\n\
 separation character is defined by @var{sep}.\n\
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
 such that the first row corresponds to an index of zero.\n\
 \n\
-The @var{range} parameter must be a 4 element vector containing  the upper\n\
+The @var{range} parameter must be a 4 element vector containing the upper\n\
 left and lower right corner @code{[@var{R0},@var{C0},@var{R1},@var{C1}]} or\n\
 a spreadsheet style range such as 'A2..Q15'.  The lowest index value is zero.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -139,18 +139,18 @@ DEFUN_DLD (dmperm, args, nargout,
 @cindex Dulmage-Mendelsohn decomposition\n\
 Perform a Dulmage-Mendelsohn permutation on the sparse matrix @var{s}.\n\
 With a single output argument @dfn{dmperm} performs the row permutations\n\
 @var{p} such that @code{@var{s} (@var{p},:)} has no zero elements on the\n\
 diagonal.\n\
 \n\
 Called with two or more output arguments, returns the row and column\n\
 permutations, such that @code{@var{s} (@var{p}, @var{q})} is in block\n\
-triangular form. The values of @var{r} and @var{s} define the boundaries\n\
-of the blocks. If @var{s} is square then @code{@var{r} == @var{s}}.\n\
+triangular form.  The values of @var{r} and @var{s} define the boundaries\n\
+of the blocks.  If @var{s} is square then @code{@var{r} == @var{s}}.\n\
 \n\
 The method used is described in: A. Pothen & C.-J. Fan. Computing the block\n\
 triangular form of a sparse matrix. ACM Trans. Math. Software,\n\
 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
   int nargin = args.length();
@@ -188,21 +188,21 @@ 16(4):303-324, 1990.\n\
 
 */
 
 DEFUN_DLD (sprank, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} sprank (@var{s})\n\
 \n\
 @cindex Structural Rank\n\
-Calculates the structural rank of a sparse matrix @var{s}. Note that\n\
+Calculates the structural rank of a sparse matrix @var{s}.  Note that\n\
 only the structure of the matrix is used in this calculation based on\n\
-a Dulmage-Mendelsohn permutation to block triangular form. As such the numerical\n\
+a Dulmage-Mendelsohn permutation to block triangular form.  As such the numerical\n\
 rank of the matrix @var{s} is bounded by @code{sprank (@var{s}) >=\n\
-rank (@var{s})}. Ignoring floating point errors @code{sprank (@var{s}) ==\n\
+rank (@var{s})}.  Ignoring floating point errors @code{sprank (@var{s}) ==\n\
 rank (@var{s})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
   
   if (nargin != 1)
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -147,17 +147,17 @@ DEFUN_DLD (eigs, args, nargout,
 @deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{b}, @var{k}, @var{sigma})\n\
 @deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})\n\
 @deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{b}, @var{k}, @var{sigma}, @var{opts})\n\
 @deftypefnx {Loadable Function} {[@var{v}, @var{d}]} = eigs (@var{a}, @dots{})\n\
 @deftypefnx {Loadable Function} {[@var{v}, @var{d}]} = eigs (@var{af}, @var{n}, @dots{})\n\
 @deftypefnx {Loadable Function} {[@var{v}, @var{d}, @var{flag}]} = eigs (@var{a}, @dots{})\n\
 @deftypefnx {Loadable Function} {[@var{v}, @var{d}, @var{flag}]} = eigs (@var{af}, @var{n}, @dots{})\n\
 Calculate a limited number of eigenvalues and eigenvectors of @var{a},\n\
-based on a selection criteria. The number eigenvalues and eigenvectors to\n\
+based on a selection criteria.  The number eigenvalues and eigenvectors to\n\
 calculate is given by @var{k} whose default value is 6.\n\
 \n\
 By default @code{eigs} solve the equation\n\
 @iftex\n\
 @tex\n\
 $A \\nu = \\lambda \\nu$\n\
 @end tex\n\
 @end iftex\n\
@@ -168,31 +168,31 @@ By default @code{eigs} solve the equatio
 @iftex\n\
 @tex\n\
 $\\lambda$ is a scalar representing one of the eigenvalues, and $\\nu$\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{lambda} is a scalar representing one of the eigenvalues, and @code{v}\n\
 @end ifinfo\n\
-is the corresponding eigenvector. If given the positive definite matrix\n\
+is the corresponding eigenvector.  If given the positive definite matrix\n\
 @var{B} then @code{eigs} solves the general eigenvalue equation\n\
 @iftex\n\
 @tex\n\
 $A \\nu = \\lambda B \\nu$\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{A * v = lambda * B * v}\n\
 @end ifinfo\n\
 .\n\
 \n\
 The argument @var{sigma} determines which eigenvalues are returned.\n\
-@var{sigma} can be either a scalar or a string. When @var{sigma} is a scalar,\n\
-the @var{k} eigenvalues closest to @var{sigma} are returned. If @var{sigma}\n\
+@var{sigma} can be either a scalar or a string.  When @var{sigma} is a scalar,\n\
+the @var{k} eigenvalues closest to @var{sigma} are returned.  If @var{sigma}\n\
 is a string, it must have one of the values\n\
 \n\
 @table @asis\n\
 @item 'lm'\n\
 Largest magnitude (default).\n\
 \n\
 @item 'sm'\n\
 Smallest magnitude.\n\
@@ -216,101 +216,101 @@ Smallest real part (valid only for compl
 @item 'li'\n\
 Largest imaginary part (valid only for complex or unsymmetric problems).\n\
 \n\
 @item 'si'\n\
 Smallest imaginary part (valid only for complex or unsymmetric problems).\n\
 @end table\n\
 \n\
 If @var{opts} is given, it is a structure defining some of the options that\n\
-@code{eigs} should use. The fields of the structure @var{opts} are\n\
+@code{eigs} should use.  The fields of the structure @var{opts} are\n\
 \n\
 @table @code\n\
 @item issym\n\
 If @var{af} is given, then flags whether the function @var{af} defines a\n\
-symmetric problem. It is ignored if @var{a} is given. The default is false.\n\
+symmetric problem.  It is ignored if @var{a} is given.  The default is false.\n\
 \n\
 @item isreal\n\
 If @var{af} is given, then flags whether the function @var{af} defines a\n\
-real problem. It is ignored if @var{a} is given. The default is true.\n\
+real problem.  It is ignored if @var{a} is given.  The default is true.\n\
 \n\
 @item tol\n\
 Defines the required convergence tolerance, given as @code{tol * norm (A)}.\n\
 The default is @code{eps}.\n\
 \n\
 @item maxit\n\
-The maximum number of iterations. The default is 300.\n\
+The maximum number of iterations.  The default is 300.\n\
 \n\
 @item p\n\
-The number of Lanzcos basis vectors to use. More vectors will result in\n\
-faster convergence, but a larger amount of memory. The optimal value of 'p'\n\
-is problem dependent and should be in the range @var{k} to @var{n}. The\n\
+The number of Lanzcos basis vectors to use.  More vectors will result in\n\
+faster convergence, but a larger amount of memory.  The optimal value of 'p'\n\
+is problem dependent and should be in the range @var{k} to @var{n}.  The\n\
 default value is @code{2 * @var{k}}.\n\
 \n\
 @item v0\n\
-The starting vector for the computation. The default is to have @sc{Arpack}\n\
+The starting vector for the computation.  The default is to have @sc{Arpack}\n\
 randomly generate a starting vector.\n\
 \n\
 @item disp\n\
-The level of diagnostic printout. If @code{disp} is 0 then there is no\n\
-printout. The default value is 1.\n\
+The level of diagnostic printout.  If @code{disp} is 0 then there is no\n\
+printout.  The default value is 1.\n\
 \n\
 @item cholB\n\
-Flag if @code{chol (@var{b})} is passed rather than @var{b}. The default is\n\
+Flag if @code{chol (@var{b})} is passed rather than @var{b}.  The default is\n\
 false.\n\
 \n\
 @item permB\n\
 The permutation vector of the Cholesky factorization of @var{b} if\n\
-@code{cholB} is true. That is @code{chol ( @var{b} (permB, permB))}. The\n\
+@code{cholB} is true.  That is @code{chol ( @var{b} (permB, permB))}.  The\n\
 default is @code{1:@var{n}}.\n\
 \n\
 @end table\n\
 \n\
 It is also possible to represent @var{a} by a function denoted @var{af}.\n\
 @var{af} must be followed by a scalar argument @var{n} defining the length\n\
-of the vector argument accepted by @var{af}. @var{af} can be passed either\n\
-as an inline function, function handle or as a string. In the case where\n\
+of the vector argument accepted by @var{af}.  @var{af} can be passed either\n\
+as an inline function, function handle or as a string.  In the case where\n\
 @var{af} is passed as a string, the name of the string defines the function\n\
 to use.\n\
 \n\
 @var{af} is a function of the form @code{function y = af (x), y = @dots{};\n\
 endfunction}, where the required return value of @var{af} is determined by\n\
 the value of @var{sigma}, and are\n\
 \n\
 @table @code\n\
 @item A * x\n\
 If @var{sigma} is not given or is a string other than 'sm'.\n\
 \n\
 @item A \\ x\n\
 If @var{sigma} is 'sm'.\n\
 \n\
 @item (A - sigma * I) \\ x\n\
 for standard eigenvalue problem, where @code{I} is the identity matrix of\n\
-the same size as @code{A}. If @var{sigma} is zero, this reduces the\n\
+the same size as @code{A}.  If @var{sigma} is zero, this reduces the\n\
 @code{A \\ x}.\n\
 \n\
 @item (A - sigma * B) \\ x\n\
 for the general eigenvalue problem.\n\
 @end table\n\
 \n\
 The return arguments of @code{eigs} depends on the number of return\n\
-arguments. With a single return argument, a vector @var{d} of length @var{k}\n\
-is returned, represent the @var{k} eigenvalues that have been found. With two\n\
+arguments.  With a single return argument, a vector @var{d} of length @var{k}\n\
+is returned, represent the @var{k} eigenvalues that have been found.  With two\n\
 return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns are\n\
-the @var{k} eigenvectors corresponding to the returned eigenvalues. The\n\
+the @var{k} eigenvectors corresponding to the returned eigenvalues.  The\n\
 eigenvalues themselves are then returned in @var{d} in the form of a\n\
 @var{n}-by-@var{k} matrix, where the elements on the diagonal are the\n\
 eigenvalues.\n\
 \n\
 Given a third return argument @var{flag}, @code{eigs} also returns the status\n\
-of the convergence. If @var{flag} is 0, then all eigenvalues have converged,\n\
+of the convergence.  If @var{flag} is 0, then all eigenvalues have converged,\n\
 otherwise not.\n\
 \n\
 This function is based on the @sc{Arpack} package, written by R Lehoucq,\n\
-K Maschhoff, D Sorensen and C Yang. For more information see\n\
+K Maschhoff, D Sorensen and C Yang.  For more information see\n\
 @url{http://www.caam.rice.edu/software/ARPACK/}.\n\
 \n\
 @end deftypefn\n\
 @seealso{eig, svds}")
 {
   octave_value_list retval;
 #ifdef HAVE_ARPACK
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -198,25 +198,25 @@ do_fft (const octave_value_list &args, c
 */
 
 
 DEFUN_DLD (fft, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fft (@var{a}, @var{n}, @var{dim})\n\
 Compute the FFT of @var{a} using subroutines from\n"
 FFTSRC
-". The FFT is calculated along the first non-singleton dimension of the\n\
-array. Thus if @var{a} is a matrix, @code{fft (@var{a})} computes the\n\
+".  The FFT is calculated along the first non-singleton dimension of the\n\
+array.  Thus if @var{a} is a matrix, @code{fft (@var{a})} computes the\n\
 FFT for each column of @var{a}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
 specifying the number of elements of @var{a} to use, or an empty\n\
-matrix to specify that its value should be ignored. If @var{n} is\n\
+matrix to specify that its value should be ignored.  If @var{n} is\n\
 larger than the dimension along which the FFT is calculated, then\n\
-@var{a} is resized and padded with zeros. Otherwise, if @var{n} is\n\
+@var{a} is resized and padded with zeros.  Otherwise, if @var{n} is\n\
 smaller than the dimension along which the FFT is calculated, then\n\
 @var{a} is truncated.\n\
 \n\
 If called with three arguments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the FFT is performed\n\
 @seealso{ifft, fft2, fftn, fftw}\n\
 @end deftypefn")
 {
@@ -224,25 +224,25 @@ dimension of the matrix along which the 
 }
 
 
 DEFUN_DLD (ifft, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} ifft (@var{a}, @var{n}, @var{dim})\n\
 Compute the inverse FFT of @var{a} using subroutines from\n"
 FFTSRC
-". The inverse FFT is calculated along the first non-singleton dimension\n\
-of the array. Thus if @var{a} is a matrix, @code{fft (@var{a})} computes\n\
+".  The inverse FFT is calculated along the first non-singleton dimension\n\
+of the array.  Thus if @var{a} is a matrix, @code{fft (@var{a})} computes\n\
 the inverse FFT for each column of @var{a}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
 specifying the number of elements of @var{a} to use, or an empty\n\
-matrix to specify that its value should be ignored. If @var{n} is\n\
+matrix to specify that its value should be ignored.  If @var{n} is\n\
 larger than the dimension along which the inverse FFT is calculated, then\n\
-@var{a} is resized and padded with zeros. Otherwise, if@var{n} is\n\
+@var{a} is resized and padded with zeros.  Otherwise, if@var{n} is\n\
 smaller than the dimension along which the inverse FFT is calculated,\n\
 then @var{a} is truncated.\n\
 \n\
 If called with three arguments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the inverse FFT is performed\n\
 @seealso{fft, ifft2, ifftn, fftw}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -150,36 +150,36 @@ do_fftn (const octave_value_list &args, 
 }
 
 DEFUN_DLD (fftn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fftn (@var{a}, @var{size})\n\
 Compute the N-dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ". The optional vector argument @var{size} may be used specify the\n\
-dimensions of the array to be used. If an element of @var{size} is\n\
+dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
-truncated prior to performing the FFT. Otherwise if an element\n\
+truncated prior to performing the FFT.  Otherwise if an element\n\
 of @var{size} is larger than the corresponding dimension @var{a}\n\
 is resized and padded with zeros.\n\
 @seealso {ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
 DEFUN_DLD (ifftn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} ifftn (@var{a}, @var{size})\n\
 Compute the inverse N-dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ". The optional vector argument @var{size} may be used specify the\n\
-dimensions of the array to be used. If an element of @var{size} is\n\
+dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
-truncated prior to performing the inverse FFT. Otherwise if an element\n\
+truncated prior to performing the inverse FFT.  Otherwise if an element\n\
 of @var{size} is larger than the corresponding dimension @var{a}\n\
 is resized and padded with zeros.\n\
 @seealso {fftn, ifft, ifft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "ifftn", 1);
 }
 
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -35,48 +35,48 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (fftw, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{method} =} fftw ('planner')\n\
 @deftypefnx {Loadable Function} {} fftw ('planner', @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom')\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom', @var{wisdom})\n\
 \n\
-Manage FFTW wisdom data. Wisdom data can be used to significantly\n\
+Manage FFTW wisdom data.  Wisdom data can be used to significantly\n\
 accelerate the calculation of the FFTs but implies an initial cost\n\
-in its calculation. When the FFTW libraries are initialized, they read\n\
+in its calculation.  When the FFTW libraries are initialized, they read\n\
 a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing wisdom\n\
-to be shared between applications other than Octave. Alternatively, the\n\
-@code{fftw} function can be used to import wisdom. For example\n\
+to be shared between applications other than Octave.  Alternatively, the\n\
+@code{fftw} function can be used to import wisdom.  For example\n\
 \n\
 @example\n\
 @var{wisdom} = fftw ('dwisdom')\n\
 @end example\n\
 \n\
 will save the existing wisdom used by Octave to the string @var{wisdom}.\n\
 This string can then be saved to a file and restored using the @code{save}\n\
-and @code{load} commands respectively. This existing wisdom can be reimported\n\
+and @code{load} commands respectively.  This existing wisdom can be reimported\n\
 as follows\n\
 \n\
 @example\n\
 fftw ('dwisdom', @var{wisdom})\n\
 @end example \n\
 \n\
 If @var{wisdom} is an empty matrix, then the wisdom used is cleared.\n\
 \n\
 During the calculation of fourier transforms further wisdom is generated.\n\
 The fashion in which this wisdom is generated is equally controlled by\n\
-the @code{fftw} function. There are five different manners in which the\n\
+the @code{fftw} function.  There are five different manners in which the\n\
 wisdom can be treated, these being\n\
 \n\
 @table @asis\n\
 @item 'estimate'\n\
 This specifies that no run-time measurement of the optimal means of\n\
 calculating a particular is performed, and a simple heuristic is used\n\
-to pick a (probably sub-optimal) plan. The advantage of this method is\n\
+to pick a (probably sub-optimal) plan.  The advantage of this method is\n\
 that there is little or no overhead in the generation of the plan, which\n\
 is appropriate for a fourier transform that will be calculated once.\n\
 \n\
 @item 'measure'\n\
 In this case a range of algorithms to perform the transform is considered\n\
 and the best is selected based on their execution time.\n\
 \n\
 @item 'patient'\n\
@@ -100,19 +100,19 @@ be probed with\n\
 @end example\n\
 \n\
 and the method used can be set using\n\
 \n\
 @example\n\
 fftw ('planner', @var{method})\n\
 @end example\n\
 \n\
-Note that calculated wisdom will be lost when restarting Octave. However,\n\
+Note that calculated wisdom will be lost when restarting Octave.  However,\n\
 the wisdom data can be reloaded if it is saved to a file as described\n\
-above. Saved wisdom files should not be used on different platforms since\n\
+above.  Saved wisdom files should not be used on different platforms since\n\
 they will not be efficient and the point of calculating the wisdom is lost.\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length();
 
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -309,17 +309,17 @@ where\n\
  N=length(a)-1 and M=length(b)-1.\n\
 @end ifnottex\n\
 @iftex\n\
 @tex\n\
  $a \\in \\Re^{N-1}$, $b \\in \\Re^{M-1}$, and $x \\in \\Re^P$.\n\
 @end tex\n\
 @end iftex\n\
 over the first non-singleton dimension of @var{x} or over @var{dim} if\n\
-supplied. An equivalent form of this equation is:\n\
+supplied.  An equivalent form of this equation is:\n\
 @iftex\n\
 @tex\n\
 $$\n\
 y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
@@ -359,23 +359,25 @@ system function:\n\
 H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
         \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
              M\n\
             SUM d(k+1) z^(-k)\n\
             k=0\n\
   H(z) = ----------------------\n\
                N\n\
           1 + SUM c(k+1) z^(-k)\n\
               k=1\n\
+@end group\n\
 @end example\n\
 @end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -51,17 +51,17 @@ Compute the normalized incomplete gamma 
                       1        /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
                   gamma (a)    /\n\
                             t=0\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 with the limiting value of 1 as @var{x} approaches infinity.\n\
-The standard notation is @math{P(a,x)}, e.g. Abramowitz and Stegun (6.5.1).\n\
+The standard notation is @math{P(a,x)}, e.g., Abramowitz and Stegun (6.5.1).\n\
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
 for each element of @var{x} and vice versa.\n\
 \n\
 If neither @var{x} nor @var{a} is scalar, the sizes of @var{x} and\n\
 @var{a} must agree, and @var{gammainc} is applied element-by-element.\n\
 @seealso{gamma, lgamma}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -50,20 +50,20 @@ is_integer_value (float x)
 }
 
 DEFUN_DLD (gcd, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{g} =} gcd (@var{a1}, @dots{})\n\
 @deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @dots{})\n\
 \n\
 If a single argument is given then compute the greatest common divisor of\n\
-the elements of this argument. Otherwise if more than one argument is\n\
-given all arguments must be the same size or scalar. In this case the\n\
-greatest common divisor is calculated for element individually. All\n\
-elements must be integers. For example,\n\
+the elements of this argument.  Otherwise if more than one argument is\n\
+given all arguments must be the same size or scalar.  In this case the\n\
+greatest common divisor is calculated for element individually.  All\n\
+elements must be integers.  For example,\n\
 \n\
 @example\n\
 @group\n\
 gcd ([15, 20])\n\
     @result{}  5\n\
 @end group\n\
 @end example\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -67,17 +67,17 @@ mk_pw_map (const octave_passwd& pw)
 
   return retval;
 }
 
 DEFUN_DLD (getpwent, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
-opening it if necessary. Once the end of the data has been reached,\n\
+opening it if necessary.  Once the end of the data has been reached,\n\
 @code{getpwent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = 0;
 
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -38,18 +38,20 @@ DEFUN_DLD (hex2num, args, ,
 Typecast the 16 character hexadecimal character matrix to an IEEE 754\n\
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
+@group\n\
 hex2num ([\"4005bf0a8b145769\";\"4024000000000000\"])\n\
 @result{} [2.7183; 10.000]\n\
+@end group\n\
 @end example\n\
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
@@ -120,23 +122,25 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 
 DEFUN_DLD (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
 string of the IEEE 754 representation of the number.  For example\n\
 \n\
 @example\n\
+@group\n\
 num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
     4005bf0a8b145769\n\
     7ff0000000000000\n\
     fff8000000000000\n\
     7ff00000000007a2\"\n\
+@end group\n\
 @end example\n\
 @seealso{hex2num, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -42,17 +42,17 @@ DEFUN_DLD (inv, args, nargout,
 @deftypefn {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inverse (@var{a})\n\
 Compute the inverse of the square matrix @var{a}.  Return an estimate\n\
 of the reciprocal condition number if requested, otherwise warn of an\n\
 ill-conditioned matrix if the reciprocal condition number is small.\n\
 \n\
 If called with a sparse matrix, then in general @var{x} will be a full\n\
 matrix, and so if possible forming the inverse of a sparse matrix should\n\
-be avoided. It is significantly more accurate and faster to do\n\
+be avoided.  It is significantly more accurate and faster to do\n\
 @code{@var{y} = @var{a} \\ @var{b}}, rather than\n\
 @code{@var{y} = inv (@var{a}) * @var{b}}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -119,25 +119,25 @@ There are no guarantees for tables which
 strictly monotonic.\n\
 \n\
 The algorithm used by lookup is standard binary search, with optimizations\n\
 to speed up the case of partially ordered arrays (dense downsampling).\n\
 In particular, looking up a single entry is of logarithmic complexity\n\
 (unless a conversion occurs due to non-numeric or unequal types).\n\
 \n\
 @var{table} and @var{y} can also be cell arrays of strings\n\
-(or @var{y} can be a single string). In this case, string lookup\n\
+(or @var{y} can be a single string).  In this case, string lookup\n\
 is performed using lexicographical comparison.\n\
 \n\
 If @var{opts} is specified, it shall be a string with letters indicating\n\
 additional options.\n\
 For numeric lookup, 'l' in @var{opts} indicates that\n\
-the leftmost subinterval shall be extended to infinity (i.e. all indices\n\
+the leftmost subinterval shall be extended to infinity (i.e., all indices\n\
 at least 1), and 'r' indicates that the rightmost subinterval shall be\n\
-extended to infinity (i.e. all indices at most n-1).\n\
+extended to infinity (i.e., all indices at most n-1).\n\
 \n\
 For string lookup, 'i' indicates case-insensitive comparison.\n\
 @end deftypefn") 
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -169,19 +169,21 @@ Solve the set of differential equations\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
 dx\n\
 -- = f(x, t)\n\
 dt\n\
+@end group\n\
 @end example\n\
 \n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0\n\
 @end example\n\
 \n\
@@ -228,31 +230,33 @@ in which @var{jac} is the matrix of part
 {\\partial f_3 \\over \\partial x_1}\n\
   & {\\partial f_3 \\over \\partial x_2}\n\
   & \\cdots\n\
   & {\\partial f_3 \\over \\partial x_N} \\cr}\\right]$$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
              | df_1  df_1       df_1 |\n\
              | ----  ----  ...  ---- |\n\
              | dx_1  dx_2       dx_N |\n\
              |                       |\n\
              | df_2  df_2       df_2 |\n\
              | ----  ----  ...  ---- |\n\
       df_i   | dx_1  dx_2       dx_N |\n\
 jac = ---- = |                       |\n\
       dx_j   |  .    .     .    .    |\n\
              |  .    .      .   .    |\n\
              |  .    .       .  .    |\n\
              |                       |\n\
              | df_N  df_N       df_N |\n\
              | ----  ----  ...  ---- |\n\
              | dx_1  dx_2       dx_N |\n\
+@end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 The second and third arguments specify the initial state of the system,\n\
 @math{x_0}, and the initial value of the independent variable @math{t_0}.\n\
 \n\
 The fourth argument is optional, and may be used to specify a set of\n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -67,75 +67,77 @@ DEFUN_DLD (lu, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} lu (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}, @var{r}] =} lu (@var{s})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{s}, @var{thres})\n\
 @deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, 'vector')\n\
 @cindex LU decomposition\n\
-Compute the LU decomposition of @var{a}. If @var{a} is full subroutines from\n\
+Compute the LU decomposition of @var{a}.  If @var{a} is full subroutines from\n\
 @sc{Lapack} are used and if @var{a} is sparse then UMFPACK is used.  The\n\
 result is returned in a permuted form, according to the optional return\n\
 value @var{p}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [l, u, p] = lu (a)\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
+@group\n\
 l =\n\
 \n\
   1.00000  0.00000\n\
   0.33333  1.00000\n\
 \n\
 u =\n\
 \n\
   3.00000  4.00000\n\
   0.00000  0.66667\n\
 \n\
 p =\n\
 \n\
   0  1\n\
   1  0\n\
+@end group\n\
 @end example\n\
 \n\
 The matrix is not required to be square.\n\
 \n\
 Called with two or three output arguments and a spare input matrix,\n\
 then @dfn{lu} does not attempt to perform sparsity preserving column\n\
-permutations. Called with a fourth output argument, the sparsity\n\
+permutations.  Called with a fourth output argument, the sparsity\n\
 preserving column transformation @var{Q} is returned, such that\n\
 @code{@var{p} * @var{a} * @var{q} = @var{l} * @var{u}}.\n\
 \n\
 Called with a fifth output argument and a sparse input matrix, then\n\
 @dfn{lu} attempts to use a scaling factor @var{r} on the input matrix\n\
 such that @code{@var{p} * (@var{r} \\ @var{a}) * @var{q} = @var{l} * @var{u}}.\n\
 This typically leads to a sparser and more stable factorsation.\n\
 \n\
 An additional input argument @var{thres}, that defines the pivoting\n\
-threshold can be given. @var{thres} can be a scalar, in which case\n\
+threshold can be given.  @var{thres} can be a scalar, in which case\n\
 it defines UMFPACK pivoting tolerance for both symmetric and unsymmetric\n\
-cases. If @var{thres} is a two element vector, then the first element\n\
+cases.  If @var{thres} is a two element vector, then the first element\n\
 defines the pivoting tolerance for the unsymmetric UMFPACK pivoting\n\
-strategy and the second the symmetric strategy. By default, the values\n\
+strategy and the second the symmetric strategy.  By default, the values\n\
 defined by @code{spparms} are used and are by default @code{[0.1, 0.001]}.\n\
 \n\
 Given the string argument 'vector', @dfn{lu} returns the values of @var{p}\n\
 @var{q} as vector values, such that for full matrix, @code{@var{a}\n\
 (@var{p},:) = @var{l} * @var{u}}, and @code{@var{r}(@var{p},:) * @var{a}\n\
 (:, @var{q}) = @var{l} * @var{u}}.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{a} = @var{l} * @var{u}}.\n\
 With one output argument @var{y}, then the matrix returned by the @sc{Lapack}\n\
-routines is returned. If the input matrix is sparse then the matrix @var{l}\n\
+routines is returned.  If the input matrix is sparse then the matrix @var{l}\n\
 is embedded into @var{u} to give a return value similar to the full case.\n\
 For both full and sparse matrices, @dfn{lu} looses the permutation\n\
 information.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -43,57 +43,57 @@ DEFUN_DLD (luinc, args, nargout,
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{droptol})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU factorization of the sparse matrix @var{a}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @dfn{luinc}.\n\
 \n\
 Called with a second argument of '0', the zero-level incomplete\n\
-LU factorization is produced. This creates a factorization of @var{a}\n\
+LU factorization is produced.  This creates a factorization of @var{a}\n\
 where the position of the non-zero arguments correspond to the same\n\
 positions as in the matrix @var{a}.\n\
 \n\
 Alternatively, the fill-in of the incomplete LU factorization can\n\
 be controlled through the variable @var{droptol} or the structure\n\
-@var{opts}. The UMFPACK multifrontal factorization code by Tim A.\n\
+@var{opts}.  The UMFPACK multifrontal factorization code by Tim A.\n\
 Davis is used for the incomplete LU factorization, (availability\n\
 @url{http://www.cise.ufl.edu/research/sparse/umfpack/})\n\
 \n\
 @var{droptol} determines the values below which the values in the LU\n\
-factorization are dropped and replaced by zero. It must be a positive\n\
+factorization are dropped and replaced by zero.  It must be a positive\n\
 scalar, and any values in the factorization whose absolute value are\n\
 less than this value are dropped, expect if leaving them increase the\n\
-sparsity of the matrix. Setting @var{droptol} to zero results in a\n\
+sparsity of the matrix.  Setting @var{droptol} to zero results in a\n\
 complete LU factorization which is the default.\n\
 \n\
 @var{opts} is a structure containing one or more of the fields\n\
 \n\
 @table @code\n\
 @item droptol\n\
-The drop tolerance as above. If @var{opts} only contains @code{droptol}\n\
+The drop tolerance as above.  If @var{opts} only contains @code{droptol}\n\
 then this is equivalent to using the variable @var{droptol}.\n\
 \n\
 @item milu\n\
 A logical variable flagging whether to use the modified incomplete LU\n\
-factorization. In the case that @code{milu} is true, the dropped values\n\
+factorization.  In the case that @code{milu} is true, the dropped values\n\
 are subtracted from the diagonal of the matrix U of the factorization.\n\
 The default is @code{false}.\n\
 \n\
 @item udiag\n\
 A logical variable that flags whether zero elements on the diagonal of U\n\
 should be replaced with @var{droptol} to attempt to avoid singular\n\
-factors. The default is @code{false}.\n\
+factors.  The default is @code{false}.\n\
 \n\
 @item thresh\n\
-Defines the pivot threshold in the interval [0,1]. Values outside that\n\
+Defines the pivot threshold in the interval [0,1].  Values outside that\n\
 range are ignored.\n\
 @end table\n\
 \n\
-All other fields in @var{opts} are ignored. The outputs from @dfn{luinc}\n\
+All other fields in @var{opts} are ignored.  The outputs from @dfn{luinc}\n\
 are the same as for @dfn{lu}.\n\
 \n\
 Given the string argument 'vector', @dfn{luinc} returns the values of @var{p}\n\
 @var{q} as vector values.\n\
 @seealso{sparse, lu}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -38,77 +38,77 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (matrix_type, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{type} =} matrix_type (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, @var{type})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'upper', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'lower', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'banded', @var{nl}, @var{nu})\n\
-Identify the matrix type or mark a matrix as a particular type. This allows rapid\n\
-for solutions of linear equations involving @var{a} to be performed. Called with a\n\
+Identify the matrix type or mark a matrix as a particular type.  This allows rapid\n\
+for solutions of linear equations involving @var{a} to be performed.  Called with a\n\
 single argument, @code{matrix_type} returns the type of the matrix and caches it for\n\
-future use. Called with more than one argument, @code{matrix_type} allows the type\n\
+future use.  Called with more than one argument, @code{matrix_type} allows the type\n\
 of the matrix to be defined.\n\
 \n\
 The possible matrix types depend on whether the matrix is full or sparse, and can be\n\
 one of the following\n\
 \n\
 @table @asis\n\
 @item 'unknown'\n\
 Remove any previously cached matrix type, and mark type as unknown\n\
 \n\
 @item 'full'\n\
 Mark the matrix as full.\n\
 \n\
 @item 'positive definite'\n\
 Probable full positive definite matrix.\n\
 \n\
 @item 'diagonal'\n\
-Diagonal Matrix. (Sparse matrices only)\n\
+Diagonal Matrix.  (Sparse matrices only)\n\
 \n\
 @item 'permuted diagonal'\n\
-Permuted Diagonal matrix. The permutation does not need to be specifically\n\
-indicated, as the structure of the matrix explicitly gives this. (Sparse matrices\n\
+Permuted Diagonal matrix.  The permutation does not need to be specifically\n\
+indicated, as the structure of the matrix explicitly gives this.  (Sparse matrices\n\
 only)\n\
 \n\
 @item 'upper'\n\
-Upper triangular. If the optional third argument @var{perm} is given, the matrix is\n\
+Upper triangular.  If the optional third argument @var{perm} is given, the matrix is\n\
 assumed to be a permuted upper triangular with the permutations defined by the\n\
 vector @var{perm}.\n\
 \n\
 @item 'lower'\n\
-Lower triangular. If the optional third argument @var{perm} is given, the matrix is\n\
+Lower triangular.  If the optional third argument @var{perm} is given, the matrix is\n\
 assumed to be a permuted lower triangular with the permutations defined by the\n\
 vector @var{perm}.\n\
 \n\
 @item 'banded'\n\
 @itemx 'banded positive definite'\n\
 Banded matrix with the band size of @var{nl} below the diagonal and @var{nu} above\n\
-it. If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and treated\n\
-with specialized code. In addition the matrix can be marked as probably a\n\
+it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and treated\n\
+with specialized code.  In addition the matrix can be marked as probably a\n\
 positive definite (Sparse matrices only)\n\
 \n\
 @item 'singular'\n\
 The matrix is assumed to be singular and will be treated with a minimum norm solution\n\
 \n\
 @end table\n\
 \n\
 Note that the matrix type will be discovered automatically on the first attempt to\n\
-solve a linear equation involving @var{a}. Therefore @code{matrix_type} is only\n\
-useful to give Octave hints of the matrix type. Incorrectly defining the\n\
+solve a linear equation involving @var{a}.  Therefore @code{matrix_type} is only\n\
+useful to give Octave hints of the matrix type.  Incorrectly defining the\n\
 matrix type will result in incorrect results from solutions of linear equations,\n\
 and so it is entirely the responsibility of the user to correctly identify the\n\
 matrix type.\n\
 \n\
 Also the test for positive definiteness is a low-cost test for a hermitian\n\
-matrix with a real positive diagonal. This does not guarantee that the matrix\n\
-is positive definite, but only that it is a probable candidate. When such a\n\
+matrix with a real positive diagonal.  This does not guarantee that the matrix\n\
+is positive definite, but only that it is a probable candidate.  When such a\n\
 matrix is factorized, a Cholesky factorization is first attempted, and if\n\
-that fails the matrix is then treated with an LU factorization. Once the\n\
+that fails the matrix is then treated with an LU factorization.  Once the\n\
 matrix has been factorized, @code{matrix_type} will return the correct\n\
 classification of the matrix.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 0)
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -686,17 +686,17 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (min, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
 @cindex Utility Functions\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
-vector, or over the dimension @var{dim} if defined. For two matrices\n\
+vector, or over the dimension @var{dim} if defined.  For two matrices\n\
 (or a matrix and scalar), return the pair-wise minimum.\n\
 Thus,\n\
 \n\
 @example\n\
 min (min (@var{x}))\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -712,17 +712,17 @@ min (2:5, pi)\n\
 compares each element of the range @code{2:5} with @code{pi}, and\n\
 returns a row vector of the minimum values.\n\
 \n\
 For complex arguments, the magnitude of the elements are used for\n\
 comparison.\n\
 \n\
 If called with one input and two output arguments,\n\
 @code{min} also returns the first index of the\n\
-minimum value(s). Thus,\n\
+minimum value(s).  Thus,\n\
 \n\
 @example\n\
 @group\n\
 [x, ix] = min ([1, 3, 0, 2, 5])\n\
     @result{}  x = 0\n\
         ix = 3\n\
 @end group\n\
 @end example\n\
@@ -760,17 +760,17 @@ minimum value(s). Thus,\n\
 
 DEFUN_DLD (max, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
 @cindex Utility Functions\n\
 For a vector argument, return the maximum value.  For a matrix\n\
 argument, return the maximum value from each column, as a row\n\
-vector, or over the dimension @var{dim} if defined. For two matrices\n\
+vector, or over the dimension @var{dim} if defined.  For two matrices\n\
 (or a matrix and scalar), return the pair-wise maximum.\n\
 Thus,\n\
 \n\
 @example\n\
 max (max (@var{x}))\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -786,17 +786,17 @@ max (2:5, pi)\n\
 compares each element of the range @code{2:5} with @code{pi}, and\n\
 returns a row vector of the maximum values.\n\
 \n\
 For complex arguments, the magnitude of the elements are used for\n\
 comparison.\n\
 \n\
 If called with one input and two output arguments,\n\
 @code{max} also returns the first index of the\n\
-maximum value(s). Thus,\n\
+maximum value(s).  Thus,\n\
 \n\
 @example\n\
 @group\n\
 [x, ix] = max ([1, 3, 5, 2, 5])\n\
     @result{}  x = 5\n\
         ix = 3\n\
 @end group\n\
 @end example\n\
@@ -914,62 +914,66 @@ maximum value(s). Thus,\n\
  \
  return retval;
 
 DEFUN_DLD (cummin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 @cindex Utility Functions\n\
-Return the cumulative minimum values. That means, the call\n\
+Return the cumulative minimum values.  That means, the call\n\
 @example\n\
   [w, iw] = cummin (x, dim)\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 @example\n\
+@group\n\
   w = iw = zeros (size (x));\n\
   idxw = idxx = repmat (@{':'@}, 1, ndims (x));\n\
   for i = 1:size (x, dim)\n\
     idxw@{dim@} = i; idxx@{dim@} = 1:i;\n\
-    [w(idxw@{:@}), iw(idxw@{:@})] =\
+    [w(idxw@{:@}), iw(idxw@{:@})] =\\n\
  min(x(idxx@{:@}), [], dim);\n\
   endfor\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but computed in a much faster manner.\n\
 The behaviour if @var{dim} or @var{iw} is unspecified is analogous\n\
 to @code{min}.\n\
 @end deftypefn")
 {
   CUMMINMAX_BODY (cummin);
 }
 
 DEFUN_DLD (cummax, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 @cindex Utility Functions\n\
-Return the cumulative maximum values. That means, the call\n\
+Return the cumulative maximum values.  That means, the call\n\
 @example\n\
   [w, iw] = cummax (x, dim)\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 @example\n\
+@group\n\
   w = iw = zeros (size (x));\n\
   idxw = idxx = repmat (@{':'@}, 1, ndims (x));\n\
   for i = 1:size (x, dim)\n\
     idxw@{dim@} = i; idxx@{dim@} = 1:i;\n\
-    [w(idxw@{:@}), iw(idxw@{:@})] =\
+    [w(idxw@{:@}), iw(idxw@{:@})] =\\n\
  max(x(idxx@{:@}), [], dim);\n\
   endfor\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but computed in a much faster manner.\n\
 The behaviour if @var{dim} or @var{iw} is unspecified is analogous\n\
 to @code{max}.\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 
 DEFUN_DLD (md5sum, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} md5sum (@var{file})\n\
 @deftypefnx {Loadable Function} {} md5sum (@var{str}, @var{opt})\n\
-Calculates the MD5 sum of the file @var{file}. If the second parameter\n\
+Calculates the MD5 sum of the file @var{file}.  If the second parameter\n\
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 DEFUN_DLD (pinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} pinv (@var{x}, @var{tol})\n\
 Return the pseudoinverse of @var{x}.  Singular values less than\n\
-@var{tol} are ignored. \n\
+@var{tol} are ignored.  \n\
 \n\
 If the second argument is omitted, it is assumed that\n\
 \n\
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
 @end example\n\
 \n\
 @noindent\n\
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -95,25 +95,27 @@ subroutines.  For example, given the mat
 @example\n\
 [q, r] = qr (a)\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
+@group\n\
 q =\n\
 \n\
   -0.31623  -0.94868\n\
   -0.94868   0.31623\n\
 \n\
 r =\n\
 \n\
   -3.16228  -4.42719\n\
    0.00000  -0.63246\n\
+@end group\n\
 @end example\n\
 \n\
 The @code{qr} factorization has applications in the solution of least\n\
 squares problems\n\
 @iftex\n\
 @tex\n\
 $$\n\
 \\min_x \\left\\Vert A x - b \\right\\Vert_2\n\
@@ -159,53 +161,57 @@ order.  For example,given the matrix @co
 @example\n\
 [q, r, p] = qr(a)\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
+@group\n\
 q = \n\
 \n\
   -0.44721  -0.89443\n\
   -0.89443   0.44721\n\
 \n\
 r =\n\
 \n\
   -4.47214  -3.13050\n\
    0.00000   0.44721\n\
 \n\
 p =\n\
 \n\
    0  1\n\
    1  0\n\
+@end group\n\
 @end example\n\
 \n\
 The permuted @code{qr} factorization @code{[q, r, p] = qr (a)}\n\
 factorization allows the construction of an orthogonal basis of\n\
 @code{span (a)}.\n\
 \n\
 If the matrix @var{a} is sparse, then compute the sparse QR factorization\n\
-of @var{a}, using @sc{CSparse}. As the matrix @var{Q} is in general a full\n\
+of @var{a}, using @sc{CSparse}.  As the matrix @var{Q} is in general a full\n\
 matrix, this function returns the @var{Q}-less factorization @var{r} of\n\
 @var{a}, such that @code{@var{r} = chol (@var{a}' * @var{a})}.\n\
 \n\
 If the final argument is the scalar @code{0} and the number of rows is\n\
 larger than the number of columns, then an economy factorization is\n\
-returned. That is @var{r} will have only @code{size (@var{a},1)} rows.\n\
+returned.  That is @var{r} will have only @code{size (@var{a},1)} rows.\n\
 \n\
 If an additional matrix @var{b} is supplied, then @code{qr} returns\n\
-@var{c}, where @code{@var{c} = @var{q}' * @var{b}}. This allows the\n\
+@var{c}, where @code{@var{c} = @var{q}' * @var{b}}.  This allows the\n\
 least squares approximation of @code{@var{a} \\ @var{b}} to be calculated\n\
 as\n\
 \n\
 @example\n\
+@group\n\
 [@var{c},@var{r}] = spqr (@var{a},@var{b})\n\
 @var{x} = @var{r} \\ @var{c}\n\
+@end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > (args(0).is_sparse_type() ? 3 : 2))
@@ -779,17 +785,17 @@ bool check_index (const octave_value& i,
 DEFUN_DLD (qrupdate, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
-(rank-k update). Notice that the latter case is done as a sequence of rank-1 updates;\n\
+(rank-k update).  Notice that the latter case is done as a sequence of rank-1 updates;\n\
 thus, for k large enough, it will be both faster and more accurate to recompute\n\
 the factorization from scratch.\n\
 \n\
 The QR factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 @seealso{qr, qrinsert, qrdelete}\n\
 @end deftypefn")
@@ -1173,19 +1179,19 @@ If @var{orient} is @code{\"row\"}, full 
 */
 
 DEFUN_DLD (qrdelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
-@w{[A(:,1:j-1) A(:,j+1:n)]}, i.e. @var{A} with one column deleted\n\
+@w{[A(:,1:j-1) A(:,j+1:n)]}, i.e., @var{A} with one column deleted\n\
 (if @var{orient} is \"col\"), or the QR@tie{}factorization of\n\
-@w{[A(1:j-1,:);A(:,j+1:n)]}, i.e. @var{A} with one row deleted (if\n\
+@w{[A(1:j-1,:);A(:,j+1:n)]}, i.e., @var{A} with one row deleted (if\n\
 @var{orient} is \"row\").\n\
 \n\
 The default value of @var{orient} is \"col\".\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
 @var{j} may be an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{A(:,@var{j}) = []} gives @var{B}.\n\
@@ -1426,17 +1432,17 @@ DEFUN_DLD (qrshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrshift (@var{Q}, @var{R}, @var{i}, @var{j})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A}(:,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
-@code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}. @*\n\
+@code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
 @seealso{qr, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 4)
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -173,17 +173,17 @@ quad_float_user_function (float x)
       QUAD_ABORT (); \
     } \
   while (0)
 
 DEFUN_DLD (quad, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{v}, @var{ier}, @var{nfun}, @var{err}] =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 Integrate a nonlinear function of one variable using Quadpack.\n\
-The first argument is the name of the  function, the function handle or\n\
+The first argument is the name of the function, the function handle or\n\
 the inline function to call to compute the value of the integrand.  It\n\
 must have the form\n\
 \n\
 @example\n\
 y = f (x)\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -192,17 +192,17 @@ where @var{y} and @var{x} are scalars.\n
 The second and third arguments are limits of integration.  Either or\n\
 both may be infinite.\n\
 \n\
 The optional argument @var{tol} is a vector that specifies the desired\n\
 accuracy of the result.  The first element of the vector is the desired\n\
 absolute tolerance, and the second element is the desired relative\n\
 tolerance.  To choose a relative test only, set the absolute\n\
 tolerance to zero.  To choose an absolute test only, set the relative\n\
-tolerance to zero. \n\
+tolerance to zero.  \n\
 \n\
 The optional argument @var{sing} is a vector of values at which the\n\
 integrand is known to be singular.\n\
 \n\
 The result of the integration is returned in @var{v} and @var{ier}\n\
 contains an integer error code (0 indicates a successful integration).\n\
 The value of @var{nfun} indicates how many function evaluations were\n\
 required, and @var{err} contains an estimate of the error in the\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -203,17 +203,17 @@ fout (const octave_idx_type& lsize, cons
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 DEFUN_DLD (qz, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{lambda} =} qz (@var{a}, @var{b})\n\
 Generalized eigenvalue problem @math{A x = s B x},\n\
-@var{QZ} decomposition. There are three ways to call this function:\n\
+@var{QZ} decomposition.  There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{lambda = qz(A,B)}\n\
 \n\
 Computes the generalized eigenvalues\n\
 @iftex\n\
 @tex\n\
 $\\lambda$\n\
 @end tex\n\
@@ -249,17 +249,17 @@ with @var{Q} and @var{Z} orthogonal (uni
 @item @code{[AA,BB,Z@{, lambda@}] = qz(A,B,opt)}\n\
 \n\
 As in form [2], but allows ordering of generalized eigenpairs\n\
 for (e.g.) solution of discrete time algebraic Riccati equations.\n\
 Form 3 is not available for complex matrices, and does not compute\n\
 the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix @var{Q}.\n\
 @table @var\n\
 @item opt\n\
-for ordering eigenvalues of the GEP pencil.  The leading  block\n\
+for ordering eigenvalues of the GEP pencil.  The leading block\n\
 of the revised pencil contains all eigenvalues that satisfy:\n\
 @table @code\n\
 @item \"N\"\n\
 = unordered (default) \n\
 \n\
 @item \"S\"\n\
 = small: leading block has all |lambda| <=1 \n\
 \n\
@@ -268,22 +268,22 @@ of the revised pencil contains all eigen
 \n\
 @item \"-\"\n\
 = negative real part: leading block has all eigenvalues\n\
 in the open left half-plane\n\
 \n\
 @item \"+\"\n\
 = nonnegative real part: leading block has all eigenvalues\n\
 in the closed right half-plane\n\
-@end  table\n\
+@end table\n\
 @end table\n\
 @end enumerate\n\
 \n\
 Note: qz performs permutation balancing, but not scaling (see balance).\n\
-Order of output arguments was selected for compatibility with MATLAB\n\
+Order of output arguments was selected for compatibility with @sc{matlab}\n\
 \n\
 @seealso{balance, eig, schur}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
 #ifdef DEBUG
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -319,17 +319,17 @@ for @code{eye}.\n\
 \n\
 You can query the state of the random number generator using the\n\
 form\n\
 \n\
 @example\n\
 v = rand (\"state\")\n\
 @end example\n\
 \n\
-This returns a column vector @var{v} of length 625. Later, you can\n\
+This returns a column vector @var{v} of length 625.  Later, you can\n\
 restore the random number generator to the state @var{v}\n\
 using the form\n\
 \n\
 @example\n\
 rand (\"state\", v)\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -358,17 +358,17 @@ some circumstances it might be desirable
 sequences as used by the old generators.  To do this the keyword\n\
 \"seed\" is used to specify that the old generators should be use,\n\
 as in\n\
 \n\
 @example\n\
 rand (\"seed\", val)\n\
 @end example\n\
 \n\
-which sets the seed of the generator to @var{val}. The seed of the\n\
+which sets the seed of the generator to @var{val}.  The seed of the\n\
 generator can be queried with\n\
 \n\
 @example\n\
 s = rand (\"seed\")\n\
 @end example\n\
 \n\
 However, it should be noted that querying the seed will not cause\n\
 @code{rand} to use the old generators, only setting the seed will.\n\
@@ -631,18 +631,20 @@ This can be used to generate many distri
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
 @example\n\
 r = b * randg (a)\n\
 @end example\n\
 @item @code{beta (a, b)} for @code{a > -1}, @code{b > -1}\n\
 @example\n\
+@group\n\
 r1 = randg (a, 1)\n\
 r = r1 / (r1 + randg (b, 1))\n\
+@end group\n\
 @end example\n\
 @item @code{Erlang (a, n)}\n\
 @example\n\
 r = a * randg (n)\n\
 @end example\n\
 @item @code{chisq (df)} for @code{df > 0}\n\
 @example\n\
 r = 2 * randg (df / 2)\n\
@@ -663,24 +665,28 @@ r = r1 / r2\n\n\
 @end example\n\
 @item negative @code{binomial (n, p)} for @code{n > 0}, @code{0 < p <= 1}\n\
 @example\n\
 r = randp ((1 - p) / p * randg (n))\n\
 @end example\n\
 @item non-central @code{chisq (df, L)}, for @code{df >= 0} and @code{L > 0}\n\
 (use chisq if @code{L = 0})\n\
 @example\n\
+@group\n\
 r = randp (L / 2)\n\
 r(r > 0) = 2 * randg (r(r > 0))\n\
 r(df > 0) += 2 * randg (df(df > 0)/2)\n\
+@end group\n\
 @end example\n\
 @item @code{Dirichlet (a1, @dots{} ak)}\n\
 @example\n\
+@group\n\
 r = (randg (a1), @dots{}, randg (ak))\n\
 r = r / sum (r)\n\
+@end group\n\
 @end example\n\
 @end table\n\
 @seealso{rand, randn, rande, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -864,17 +870,17 @@ r = r / sum (r)\n\
 
 
 DEFUN_DLD (randp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} randp (@var{l}, @var{x})\n\
 @deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", @var{x})\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", @var{x})\n\
-Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, @var{l}. The arguments\n\
+Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, @var{l}.  The arguments\n\
 are handled the same as the arguments for @code{rand}, except for the\n\
 argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l}\n\
 and whether or not @var{l} is a scalar or a matrix.\n\
 \n\
 @table @asis\n\
 @item For scalar @var{l} <= 12, use direct method.\n\
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -29,20 +29,20 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (rcond, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} rcond (@var{a})\n\
 Compute the 1-norm estimate of the reciprocal condition as returned\n\
-by LAPACK. If the matrix is well-conditioned then @var{c} will be near\n\
+by LAPACK.  If the matrix is well-conditioned then @var{c} will be near\n\
 1 and if the matrix is poorly conditioned it will be close to zero.\n\
 \n\
-The matrix @var{a} must not be sparse. If the matrix is sparse then\n\
+The matrix @var{a} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{a})} or @code{rcond (full (@var{a}))} should be used\n\
 instead.\n\
 @seealso{inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -1540,19 +1540,21 @@ DEFUN_DLD (regexprep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function}  {@var{string} =} regexprep (@var{string}, @var{pat}, @var{repstr}, @var{options})\n\
 Replace matches of @var{pat} in  @var{string} with @var{repstr}.\n\
 \n\
 \n\
 The replacement can contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  E.g.,\n\
 @example\n\
+@group\n\
 \n\
    regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
 \n\
+@end group\n\
 @end example\n\
 returns \"Dunn, Bill\"\n\
 \n\
 @var{options} may be zero or more of\n\
 @table @samp\n\
 \n\
 @item once\n\
 Replace only the first occurrence of @var{pat} in the result.\n\
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -63,17 +63,17 @@ DEFUN_DLD (sparse, args, ,
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
 Create a sparse matrix from the full matrix or row, column, value triplets.\n\
 If @var{a} is a full matrix, convert it to a sparse matrix representation,\n\
 removing all zero values in the process.\n\
 \n\
 Given the integer index vectors @var{i} and @var{j}, a 1-by-@code{nnz} vector\n\
 of real of complex values @var{sv}, overall dimensions @var{m} and @var{n}\n\
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
-compatibility with @sc{Matlab}. If @var{m} or @var{n} are not specified their\n\
+compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified their\n\
 values are derived from the maximum index in the vectors @var{i} and @var{j}\n\
 as given by @code{@var{m} = max (@var{i})}, @code{@var{n} = max (@var{j})}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
 be added.\n\
 \n\
 The following are all equivalent:\n\
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -39,36 +39,36 @@ DEFUN_DLD (spparms, args, nargout,
 @deftypefnx {Loadable Function} {@var{vals} =} spparms ()\n\
 @deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
 @deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})\n\
 @deftypefnx {Loadable Function} { } spparms (@var{vals})\n\
 @deftypefnx {Loadable Function} { } spparms ('defaults')\n\
 @deftypefnx {Loadable Function} { } spparms ('tight')\n\
 @deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})\n\
 Sets or displays the parameters used by the sparse solvers and factorization\n\
-functions. The first four calls above get information about the current\n\
-settings, while the others change the current settings. The parameters are\n\
+functions.  The first four calls above get information about the current\n\
+settings, while the others change the current settings.  The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the following strings:\n\
 \n\
 @table @code\n\
 @item spumoni\n\
 Printing level of debugging information of the solvers (default 0)\n\
 @item ths_rel\n\
-Included for compatibility. Not used. (default 1)\n\
+Included for compatibility.  Not used.  (default 1)\n\
 @item ths_abs\n\
-Included for compatibility. Not used. (default 1)\n\
+Included for compatibility.  Not used.  (default 1)\n\
 @item exact_d\n\
-Included for compatibility. Not used. (default 0)\n\
+Included for compatibility.  Not used.  (default 0)\n\
 @item supernd\n\
-Included for compatibility. Not used. (default 3)\n\
+Included for compatibility.  Not used.  (default 3)\n\
 @item rreduce\n\
-Included for compatibility. Not used. (default 3)\n\
+Included for compatibility.  Not used.  (default 3)\n\
 @item wh_frac\n\
-Included for compatibility. Not used. (default 0.5)\n\
+Included for compatibility.  Not used.  (default 0.5)\n\
 @item autommd\n\
 Flag whether the LU/QR and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving mmd functions (default 1)\n\
 @item autoamd\n\
 Flag whether the LU and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving amd functions (default 1)\n\
 @item piv_tol\n\
 The pivot tolerance of the UMFPACK solvers (default 0.1)\n\
@@ -78,18 +78,18 @@ The pivot tolerance of the UMFPACK symme
 The density of non-zero elements in a banded matrix before it is treated\n\
 by the LAPACK banded solvers (default 0.5)\n\
 @item umfpack\n\
 Flag whether the UMFPACK or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
 The value of individual keys can be set with @code{spparms (@var{key},\n\
-@var{val})}. The default values can be restored with the special keyword\n\
-'defaults'. The special keyword 'tight' can be used to set the mmd solvers\n\
+@var{val})}.  The default values can be restored with the special keyword\n\
+'defaults'.  The special keyword 'tight' can be used to set the mmd solvers\n\
 to attempt for a sparser solution at the potential cost of longer running\n\
 time.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -170,17 +170,17 @@ sqrtm_from_schur (const FloatComplexMatr
   return U * R * U.hermitian ();
 }
 
 DEFUN_DLD (sqrtm, args, nargout,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{result}, @var{error_estimate}] =} sqrtm (@var{a})\n\
 Compute the matrix square root of the square matrix @var{a}.\n\
 \n\
-Ref: Nicholas J. Higham. A new sqrtm for MATLAB. Numerical Analysis\n\
+Ref: Nicholas J. Higham.  A new sqrtm for @sc{matlab}.  Numerical Analysis\n\
 Report No. 336, Manchester Centre for Computational Mathematics,\n\
 Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -72,34 +72,37 @@ For example,\n\
 @example\n\
 svd (hilb (3))\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
+@group\n\
 ans =\n\
 \n\
   1.4083189\n\
   0.1223271\n\
   0.0026873\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 and\n\
 \n\
 @example\n\
 [u, s, v] = svd (hilb (3))\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
+@group\n\
 u =\n\
 \n\
   -0.82704   0.54745   0.12766\n\
   -0.45986  -0.52829  -0.71375\n\
   -0.32330  -0.64901   0.68867\n\
 \n\
 s =\n\
 \n\
@@ -107,16 +110,17 @@ s =\n\
   0.00000  0.12233  0.00000\n\
   0.00000  0.00000  0.00269\n\
 \n\
 v =\n\
 \n\
   -0.82704   0.54745   0.12766\n\
   -0.45986  -0.52829  -0.71375\n\
   -0.32330  -0.64901   0.68867\n\
+@end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{svd} returns an economy-sized\n\
 decomposition, eliminating the unnecessary rows or columns of @var{u} or\n\
 @var{v}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -50,30 +50,30 @@ Where\n\
 @item @var{s}\n\
 @var{s} is a complex or real sparse matrix.\n\
 \n\
 @item @var{typ}\n\
 Is the type of the factorization and can be one of\n\
 \n\
 @table @code\n\
 @item sym\n\
-Factorize @var{s}. This is the default.\n\
+Factorize @var{s}.  This is the default.\n\
 \n\
 @item col\n\
 Factorize @code{@var{s}' * @var{s}}.\n\
 @item row\n\
 Factorize @code{@var{s} * @var{s}'}.\n\
 @item lo\n\
 Factorize @code{@var{s}'}\n\
 @end table\n\
 \n\
 @item @var{mode}\n\
 The default is to return the Cholesky factorization for @var{r}, and if\n\
 @var{mode} is 'L', the conjugate transpose of the Cholesky factorization\n\
-is returned. The conjugate transpose version is faster and uses less\n\
+is returned.  The conjugate transpose version is faster and uses less\n\
 memory, but returns the same values for @var{count}, @var{h}, @var{parent}\n\
 and @var{post} outputs.\n\
 @end table\n\
 \n\
 The output variables are\n\
 \n\
 @table @asis\n\
 @item @var{count}\n\
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -55,19 +55,19 @@ inline double min(double a, double b, do
 // given point 
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
 
 DEFUN_DLD (tsearch, args, ,
 	"-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
-Searches for the enclosing Delaunay convex hull. For @code{@var{t} =\n\
+Searches for the enclosing Delaunay convex hull.  For @code{@var{t} =\n\
 delaunay (@var{x}, @var{y})}, finds the index in @var{t} containing the\n\
-points @code{(@var{xi}, @var{yi})}. For points outside the convex hull,\n\
+points @code{(@var{xi}, @var{yi})}.  For points outside the convex hull,\n\
 @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
   const double eps=1.0e-12;
 
   octave_value_list retval;
   const int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -204,43 +204,49 @@ DEFUN_DLD (urlwrite, args, nargout,
 @deftypefn {Loadable Function} {} urlwrite (@var{URL}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
 Download a remote file specified by its @var{URL} and save it as\n\
 @var{localfile}.  For example,\n\
 \n\
 @example\n\
+@group\n\
 urlwrite (\"ftp://ftp.octave.org/pub/octave/README\", \n\
           \"README.txt\");\n\
+@end group\n\
 @end example\n\
 \n\
 The full path of the downloaded file is returned in @var{f}.  The\n\
 variable @var{success} is 1 if the download was successful,\n\
 otherwise it is 0 in which case @var{message} contains an error\n\
 message.  If no output argument is specified and if an error occurs,\n\
 then the error is signaled through Octave's error handling mechanism.\n\
 \n\
 This function uses libcurl.  Curl supports, among others, the HTTP,\n\
 FTP and FILE protocols.  Username and password may be specified in\n\
 the URL, for example:\n\
 \n\
 @example\n\
+@group\n\
 urlwrite (\"http://username:password@@example.com/file.txt\",\n\
           \"file.txt\");\n\
+@end group\n\
 @end example\n\
 \n\
 GET and POST requests can be specified by @var{method} and @var{param}.\n\
 The parameter @var{method} is either @samp{get} or @samp{post}\n\
 and @var{param} is a cell array of parameter and value pairs.\n\
 For example:\n\
 \n\
 @example\n\
+@group\n\
 urlwrite (\"http://www.google.com/search\", \"search.html\",\n\
           \"get\", @{\"query\", \"octave\"@});\n\
+@end group\n\
 @end example\n\
 @seealso{urlread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #if defined (HAVE_CURL)
 
@@ -386,18 +392,20 @@ s = urlread (\"http://user:password@@exa
 @end example\n\
 \n\
 GET and POST requests can be specified by @var{method} and @var{param}.\n\
 The parameter @var{method} is either @samp{get} or @samp{post}\n\
 and @var{param} is a cell array of parameter and value pairs.\n\
 For example,\n\
 \n\
 @example\n\
+@group\n\
 s = urlread (\"http://www.google.com/search\", \"get\",\n\
              @{\"query\", \"octave\"@});\n\
+@end group\n\
 @end example\n\
 @seealso{urlwrite}\n\
 @end deftypefn")
 {
   // Octave's return value
   octave_value_list retval;
 
 #if defined (HAVE_CURL)
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -410,31 +410,33 @@ DEFUN (bitshift, args, ,
 @deftypefnx {Built-in Function} {} bitshift (@var{a}, @var{k}, @var{n})\n\
 Return a @var{k} bit shift of @var{n}-digit unsigned\n\
 integers in @var{a}.  A positive @var{k} leads to a left shift.\n\
 A negative value to a right shift.  If @var{n} is omitted it defaults\n\
 to log2(bitmax)+1.\n\
 @var{n} must be in the range [1,log2(bitmax)+1] usually [1,33]\n\
 \n\
 @example\n\
+@group\n\
 bitshift (eye (3), 1)\n\
 @result{}\n\
 @group\n\
 2 0 0\n\
 0 2 0\n\
 0 0 2\n\
 @end group\n\
 \n\
 bitshift (10, [-2, -1, 0, 1, 2])\n\
 @result{} 2   5  10  20  40\n\
 @c FIXME -- restore this example when third arg is allowed to be an array.\n\
 @c \n\
 @c \n\
 @c bitshift ([1, 10], 2, [3,4])\n\
 @c @result{} 4  8\n\
+@end group\n\
 @end example\n\
 @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -732,17 +732,17 @@ and @var{x}.  The result is in the range
 */
 
 
 
 DEFUN (hypot, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} hypot (@var{x}, @var{y})\n\
 Compute square-root of the squares of @var{x} and @var{y}\n\
-element-by-element. This equivalent to @code{sqrt (@var{x}.^ 2 + @var{y}\n\
+element-by-element.  This equivalent to @code{sqrt (@var{x}.^ 2 + @var{y}\n\
 .^ 2)}, but calculated in a manner that avoids overflows for large\n\
 values of @var{x} or @var{y}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -987,21 +987,21 @@ map_2_xlog2 (const Array<T>& x, Array<T>
       f.xelem (i) = xlog2 (x(i), exp);
       e.xelem (i) = exp;
     }
 }
 
 DEFUN (log2, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log2 (@var{x})\n\
-@deftypefnx {Mapping Function} {[@var{f}, @var{e}] = } log2 (@var{x})\n\
+@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
 Compute the base-2 logarithm for each element of @var{x}.\n\
 If called with two output arguments, split @var{x} to\n\
 binary mantissa and exponent so that @code{1/2 <= abs(f) < 1} and\n\
-@var{e} is an integer. If @code{x = 0}, @code{f = e = 0}.\n\
+@var{e} is an integer.  If @code{x = 0}, @code{f = e = 0}.\n\
 @seealso{log, log10, log2, exp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (nargout < 2)
@@ -2258,17 +2258,17 @@ returns the original array @var{a}.\n\
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
 Return the `length' of the object @var{a}.  For matrix objects, the\n\
 length is the number of rows or columns, whichever is greater (this\n\
-odd definition is used for compatibility with @sc{Matlab}).\n\
+odd definition is used for compatibility with @sc{matlab}).\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       int len = args(0).length ();
 
@@ -2351,18 +2351,20 @@ size ([1, 2; 3, 4; 5, 6])\n\
      @result{} nc = 2\n\
 @end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{size} will return the size of the\n\
 corresponding dimension.  For example\n\
 \n\
 @example\n\
+@group\n\
 size ([1, 2; 3, 4; 5, 6], 2)\n\
      @result{} 2\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the number of columns in the given matrix.\n\
 @seealso{numel}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -2485,17 +2487,17 @@ Returns the number of non zero elements 
   return retval;
 }
 
 DEFUN (nzmax, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{scalar} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
 Note that Octave tends to crop unused memory at the first opportunity\n\
-for sparse objects. There are some cases of user created sparse objects\n\
+for sparse objects.  There are some cases of user created sparse objects\n\
 where the value returned by @dfn{nzmaz} will not be the same as @dfn{nnz},\n\
 but in general they will give the same result.\n\
 @seealso{sparse, spalloc}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length() == 1)
@@ -2547,23 +2549,25 @@ DEFUN (sum, args, ,
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to 1 (column-wise sum).\n\
 \n\
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the sum of the elements.\n\
 \n\
 If the optional argument 'native' is given, then the sum is performed\n\
 in the same type as the original argument, rather than in the default\n\
-double type. For example\n\
+double type.  For example\n\
 \n\
 @example\n\
+@group\n\
 sum ([true, true])\n\
   @result{} 2\n\
 sum ([true, true], 'native')\n\
   @result{} true\n\
+@end group\n\
 @end example\n\
 @end deftypefn")
 {
   NATIVE_REDUCTION (sum, any);
 }
 
 /*
 
@@ -3797,17 +3801,17 @@ for double precision and\n\
 @ifnottex\n\
  1.1921e-07.\n\
 @end ifnottex\n\
 @iftex\n\
 @tex\n\
  $1.1921\\times10^{-7}$.\n\
 @end tex\n\
 @end iftex\n\
-for single precision. Given a single argument @var{x}, return the\n\
+for single precision.  Given a single argument @var{x}, return the\n\
 distance between @var{x} and the next largest value.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 && ! args(0).is_string ())
     {
@@ -4184,17 +4188,17 @@ The optional argument @var{class}, allow
 the specified type, like\n\
 \n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 \n\
 Calling @code{eye} with no arguments is equivalent to calling it\n\
 with an argument of 1.  This odd definition is for compatibility\n\
-with @sc{Matlab}.\n\
+with @sc{matlab}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
@@ -4268,17 +4272,17 @@ Return a row vector with @var{n} linearl
 @var{base} and @var{limit}.  If the number of elements is greater than one,\n\
 then the @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
 value of 100 is used.\n\
 \n\
 The @code{linspace} function always returns a row vector.\n\
 \n\
-For compatibility with @sc{Matlab}, return the second argument if\n\
+For compatibility with @sc{matlab}, return the second argument if\n\
 fewer than two values are requested.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   octave_idx_type npoints = 100;
@@ -4403,20 +4407,22 @@ In other words, the statement\n\
 @example\n\
   y = resize (x, dv);\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 \n\
 @example\n\
+@group\n\
   y = zeros (dv, class (x));\n\
   sz = min (dv, size (x));\n\
   for i = 1:length (sz), idx@{i@} = 1:sz(i); endfor\n\
   y(idx@{:@}) = x(idx@{:@});\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but is performed more efficiently.\n\
 \n\
 If only @var{m} is supplied and it is a scalar, the dimension of the\n\
 result is @var{m}-by-@var{m}.  If @var{m} is a vector, then the\n\
 dimensions of the result are given by the elements of @var{m}.\n\
@@ -4630,17 +4636,17 @@ by an empty argument.\n\
 %!error reshape (1, 2, 3, 4);
 
  */
 
 DEFUN (squeeze, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
-Note that for compatibility with @sc{Matlab}, all objects have\n\
+Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).squeeze ();
   else
@@ -4714,17 +4720,17 @@ Hamming norm - the number of nonzero ele
 @item other @var{p}, @code{@var{p} > 1}\n\
 p-norm of @var{a}, @code{(sum (abs (@var{a}) .^ @var{p})) ^ (1/@var{p})}.\n\
 \n\
 @item other @var{p} @code{@var{p} < 1}\n\
 the p-pseudonorm defined as above.\n\
 @end table\n\
 \n\
 If @code{\"rows\"} is given as @var{opt}, the norms of all rows of the matrix @var{a} are\n\
-returned as a column vector. Similarly, if @code{\"columns\"} or @code{\"cols\"} is passed\n\
+returned as a column vector.  Similarly, if @code{\"columns\"} or @code{\"cols\"} is passed\n\
 column norms are computed.\n\
 @seealso{cond, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -5124,19 +5130,21 @@ DEFUN (tic, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tic ()\n\
 @deftypefnx {Built-in Function} {} toc ()\n\
 Set or check a wall-clock timer.  Calling @code{tic} without an\n\
 output argument sets the timer.  Subsequent calls to @code{toc}\n\
 return the number of seconds since the timer was set.  For example,\n\
 \n\
 @example\n\
+@group\n\
 tic ();\n\
-# many computations later...\n\
+# many computations later@dots{}\n\
 elapsed_time = toc ();\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 will set the variable @code{elapsed_time} to the number of seconds since\n\
 the most recent call to the function @code{tic}.\n\
 \n\
 If called with one output argument then this function returns a scalar\n\
 of type @code{uint64} and the wall-clock timer is not started.\n\
@@ -5682,17 +5690,17 @@ Undocumented internal function.\n\
 
   return retval;
 }
 
 DEFUN (issorted, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {} issorted (@var{a}, @var{rows})\n\
 Returns true if the array is sorted, ascending or descending.\n\
-NaNs are treated is by @code{sort}. If @var{rows} is supplied and\n\
+NaNs are treated is by @code{sort}.  If @var{rows} is supplied and\n\
 has the value \"rows\", checks whether the array is sorted by rows\n\
 as if output by @code{sortrows} (with no options).\n\
 \n\
 This function does not yet support sparse matrices.\n\
 @seealso{sortrows, sort}\n\
 @end deftypefn\n")
 {
   octave_value retval;
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -636,17 +636,17 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
 
 DEFUN (filesep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} filesep ()\n\
 @deftypefnx {Built-in Function} {} filesep ('all')\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
 If 'all' is given, the function return all valid file separators in\n\
-the form of a string. The list of file separators is system-dependent.\n\
+the form of a string.  The list of file separators is system-dependent.\n\
 It is / (forward slash) under UNIX or Mac OS X, / and \\ (forward and\n\
 backward slashes) under Windows.\n\
 @seealso{pathsep, dir, ls}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -5106,21 +5106,23 @@ set to the object handle and the empty m
 is a string, it must be any valid octave expression.  If @var{fcn} is a cell\n\
 array, the first element must be a function handle with the same signature\n\
 as described above.  The next elements of the cell array are passed\n\
 as additional arguments to the function.\n\
 \n\
 Example:\n\
 \n\
 @example\n\
+@group\n\
 function my_listener (h, dummy, p1)\n\
   fprintf (\"my_listener called with p1=%s\\n\", p1);\n\
 endfunction\n\
 \n\
 addlistener (gcf, \"position\", @{@@my_listener, \"my string\"@})\n\
+@end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   gh_manager::autolock guard;
 
   octave_value retval;
 
@@ -5167,23 +5169,25 @@ be the same variable (not just the same 
 original call to @code{addlistener}.\n\
 \n\
 If @var{fcn} is not defined then all listener functions of @var{prop}\n\
 are removed.\n\
 \n\
 Example:\n\
 \n\
 @example\n\
+@group\n\
 function my_listener (h, dummy, p1)\n\
   fprintf (\"my_listener called with p1=%s\\n\", p1);\n\
 endfunction\n\
 \n\
 c = @{@@my_listener, \"my string\"@};\n\
 addlistener (gcf, \"position\", c);\n\
 dellistener (gcf, \"position\", c);\n\
+@end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   gh_manager::autolock guard;
 
   octave_value retval;
 
@@ -5272,19 +5276,21 @@ additional set of accepted string values
 a valid property name for that object type.  The property created\n\
 then has the same characteristics as the referenced property (type,\n\
 possible values, hidden state@dots{}).  This allows to clone an existing\n\
 property into the graphics object @var{h}.\n\
 \n\
 Examples:\n\
 \n\
 @example\n\
+@group\n\
 addproperty (\"my_property\", gcf, \"string\", \"a string value\");\n\
 addproperty (\"my_radio\", gcf, \"radio\", \"val_1|val_2|@{val_3@}\");\n\
 addproperty (\"my_style\", gcf, \"linelinestyle\", \"--\");\n\
+@end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   gh_manager::autolock guard;
 
   octave_value retval;
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -240,18 +240,18 @@ const static pair_type keywords[] =
 @deffn Keyword break\n\
 Exit the innermost enclosing do, while or for loop.\n\
 @seealso{do, while, for, continue}\n\
 @end deffn"),
 
   pair_type ("case",
     "-*- texinfo -*-\n\
 @deffn Keyword case @{@var{value}@}\n\
-A case statement in an switch. Octave cases are exclusive and do not\n\
-fall-through as do C-language cases. A switch statement must have at least\n\
+A case statement in an switch.  Octave cases are exclusive and do not\n\
+fall-through as do C-language cases.  A switch statement must have at least\n\
 one case.  See @code{switch} for an example.\n\
 @seealso{switch}\n\
 @end deffn"),
 
   pair_type ("catch",
     "-*- texinfo -*-\n\
 @deffn Keyword catch\n\
 Begin the cleanup part of a try-catch block.\n\
@@ -263,17 +263,17 @@ Begin the cleanup part of a try-catch bl
 @deffn Keyword continue\n\
 Jump to the end of the innermost enclosing do, while or for loop.\n\
 @seealso{do, while, for, break}\n\
 @end deffn"),
 
   pair_type ("do",
     "-*- texinfo -*-\n\
 @deffn Keyword do\n\
-Begin a do-until loop. This differs from a do-while loop in that the\n\
+Begin a do-until loop.  This differs from a do-while loop in that the\n\
 body of the loop is executed at least once.\n\
 @seealso{while}\n\
 @end deffn"),
 
   pair_type ("else",
     "-*- texinfo -*-\n\
 @deffn Keyword else\n\
 Alternate action for an if block.  See @code{if} for an example.\n\
@@ -343,62 +343,68 @@ Mark the end of a while loop.  See @code
 @seealso{do, while}\n\
 @end deffn"),
 
   pair_type ("for",
     "-*- texinfo -*-\n\
 @deffn Keyword for @var{i} = @var{range}\n\
 Begin a for loop.\n\
 @example\n\
+@group\n\
 for i = 1:10\n\
   i\n\
 endfor\n\
+@end group\n\
 @end example\n\
 @seealso{do, while}\n\
 @end deffn"),
 
   pair_type ("function",
     "-*- texinfo -*-\n\
-@deffn Keyword function @var{outputs} = function (@var{input}, ...)\n\
-@deffnx Keyword function {} function (@var{input}, ...)\n\
+@deffn Keyword function @var{outputs} = function (@var{input}, @dots{})\n\
+@deffnx Keyword function {} function (@var{input}, @dots{})\n\
 @deffnx Keyword function @var{outputs} = function\n\
 Begin a function body with @var{outputs} as results and @var{inputs} as\n\
 parameters.\n\
 @seealso{return}\n\
 @end deffn"),
 
   pair_type ("global",
     "-*- texinfo -*-\n\
 @deffn Keyword global\n\
 Declare variables to have global scope.\n\
 @example\n\
+@group\n\
 global @var{x};\n\
 if isempty (@var{x})\n\
   x = 1;\n\
 endif\n\
+@end group\n\
 @end example\n\
 @seealso{persistent}\n\
 @end deffn"),
 
   pair_type ("if",
     "-*- texinfo -*-\n\
 @deffn Keyword if (@var{cond}) @dots{} endif\n\
 @deffnx Keyword if (@var{cond}) @dots{} else @dots{} endif\n\
 @deffnx Keyword if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} endif\n\
 @deffnx Keyword if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} else @dots{} endif\n\
 Begin an if block.\n\
 @example\n\
+@group\n\
 x = 1;\n\
 if (x == 1)\n\
   disp (\"one\");\n\
 elseif (x == 2)\n\
   disp (\"two\");\n\
 else\n\
   disp (\"not one or two\");\n\
 endif\n\
+@end group\n\
 @end example\n\
 @seealso{switch}\n\
 @end deffn"),
 
   pair_type ("otherwise",
     "-*- texinfo -*-\n\
 @deffn Keyword otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
@@ -437,26 +443,28 @@ This function has been deprecated in fav
 @seealso{persistent}\n\
 @end deffn"),
 
   pair_type ("switch",
     "-*- texinfo -*-\n\
 @deffn Keyword switch @var{statement}\n\
 Begin a switch block.\n\
 @example\n\
+@group\n\
 yesno = \"yes\"\n\
 \n\
 switch yesno\n\
   case @{\"Yes\" \"yes\" \"YES\" \"y\" \"Y\"@}\n\
     value = 1;\n\
   case @{\"No\" \"no\" \"NO\" \"n\" \"N\"@}\n\
     value = 0;\n\
   otherwise\n\
     error (\"invalid value\");\n\
 endswitch\n\
+@end group\n\
 @end example\n\
 @seealso{if, case, otherwise}\n\
 @end deffn"),
 
   pair_type ("try",
     "-*- texinfo -*-\n\
 @deffn Keyword try\n\
 Begin a try-catch block.\n\
@@ -727,17 +735,17 @@ do_get_help_text (const std::string name
     }
 }
 
 DEFUN (get_help_text, args, , "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{text}, @var{format}] =} get_help_text (@var{name})\n\
 Returns the help text of a given function.\n\
 \n\
 This function returns the raw help text @var{text} and an indication of\n\
-its format for the function @var{name}. The format indication @var{format}\n\
+its format for the function @var{name}.  The format indication @var{format}\n\
 is a string that can be either @t{\"texinfo\"}, @t{\"html\"}, or\n\
 @t{\"plain text\"}.\n\
 \n\
 To convert the help text to other formats, use the @code{makeinfo} function.\n\
 \n\
 @seealso{makeinfo}\n\
 @end deftypefn")
 {
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1385,26 +1385,26 @@ Undocumented internal function.\n\
 
   return retval;
 }
 
 DEFUN (filemarker, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} filemarker ()\n\
 Returns or sets the character used to separate filename from the\n\
-the subfunction names contained within the file. This can be used in\n\
-a generic manner to interact with subfunctions. For example\n\
+the subfunction names contained within the file.  This can be used in\n\
+a generic manner to interact with subfunctions.  For example\n\
 \n\
 @example\n\
 help ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the help string associated with the sub-function @code{mysubfunc}\n\
-of the function @code{myfunc}. Another use of @code{filemarker} is when\n\
+of the function @code{myfunc}.  Another use of @code{filemarker} is when\n\
 debugging it allows easier placement of breakpoints within sub-functions.\n\
 For example\n\
 \n\
 @example\n\
 dbstop ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -575,17 +575,17 @@ they will generate warnings.\n\
 \n\
 If invoked with a single output argument, Octave returns data instead\n\
 of inserting variables in the symbol table.  If the data file contains\n\
 only numbers (TAB- or space-delimited columns), a matrix of values is\n\
 returned.  Otherwise, @code{load} returns a structure with members\n\
  corresponding to the names of the variables in the file.\n\
 \n\
 The @code{load} command can read data stored in Octave's text and\n\
-binary formats, and @sc{Matlab}'s binary format.  If compiled with zlib\n\
+binary formats, and @sc{matlab}'s binary format.  If compiled with zlib\n\
 support, it can load gzip-compressed files as well.  It will automatically\n\
 detect the type of file and do conversion from different floating point\n\
 formats (currently only IEEE big and little endian, though other formats\n\
 may added in the future).\n\
 \n\
 Valid options for @code{load} are listed in the following table.\n\
 \n\
 @table @code\n\
@@ -604,25 +604,25 @@ name of the file.\n\
 Force Octave to assume the file is in Octave's binary format.\n\
 \n\
 @item -mat\n\
 @itemx -mat-binary\n\
 @itemx -6\n\
 @itemx -v6\n\
 @itemx -7\n\
 @itemx -v7\n\
-Force Octave to assume the file is in @sc{Matlab}'s version 6 or 7 binary\n\
+Force Octave to assume the file is in @sc{matlab}'s version 6 or 7 binary\n\
 format.\n\
 \n\
 @item -V4\n\
 @itemx -v4\n\
 @itemx -4\n\
 @itemx -mat4-binary\n\
 Force Octave to assume the file is in the binary format written by\n\
-@sc{Matlab} version 4.\n\
+@sc{matlab} version 4.\n\
 \n\
 @item -hdf5\n\
 Force Octave to assume the file is in HDF5 format.\n\
 (HDF5 is a free, portable binary format developed by the National\n\
 Center for Supercomputing Applications at the University of Illinois.)\n\
 Note that Octave can read HDF5 files not created by itself, but may\n\
 skip some datasets in formats that it cannot support.\n"
 
@@ -1475,33 +1475,33 @@ Save the data in Octave's binary data fo
 Save the data in Octave's binary data format but only using single\n\
 precision.  You should use this format only if you know that all the\n\
 values to be saved can be represented in single precision.\n\
 \n\
 @item -V7\n\
 @itemx -v7\n\
 @itemx -7\n\
 @itemx -mat7-binary\n\
-Save the data in @sc{Matlab}'s v7 binary data format.\n"
+Save the data in @sc{matlab}'s v7 binary data format.\n"
 
 HAVE_ZLIB_HELP_STRING
 
 "\n\
 @item -V6\n\
 @itemx -v6\n\
 @itemx -6\n\
 @itemx -mat\n\
 @itemx -mat-binary\n\
-Save the data in @sc{Matlab}'s v6 binary data format.\n\
+Save the data in @sc{matlab}'s v6 binary data format.\n\
 \n\
 @item -V4\n\
 @itemx -v4\n\
 @itemx -4\n\
 @itemx -mat4-binary\n\
-Save the data in the binary format written by @sc{Matlab} version 4.\n\
+Save the data in the binary format written by @sc{matlab} version 4.\n\
 \n\
 @item -hdf5\n\
 Save the data in HDF5 format.\n\
 (HDF5 is a free, portable binary format developed by the National\n\
 Center for Supercomputing Applications at the University of Illinois.)\n"
 
 HAVE_HDF5_HELP_STRING
 
@@ -1529,26 +1529,26 @@ Match any single character.\n\
 \n\
 @item *\n\
 Match zero or more characters.\n\
 \n\
 @item [ @var{list} ]\n\
 Match the list of characters specified by @var{list}.  If the first\n\
 character is @code{!} or @code{^}, match all characters except those\n\
 specified by @var{list}.  For example, the pattern @samp{[a-zA-Z]} will\n\
-match all lower and upper case alphabetic characters. \n\
+match all lower and upper case alphabetic characters.  \n\
 \n\
 Wildcards may also be used in the field names specifications when using\n\
 the @code{-struct} modifier (but not in the struct name itself).\n\
 \n\
 @item -text\n\
 Save the data in Octave's text data format.\n\
 @end table\n\
 \n\
-Except when using the @sc{Matlab} binary data file format, saving global\n\
+Except when using the @sc{matlab} binary data file format, saving global\n\
 variables also saves the global status of the variable, so that if it is\n\
 restored at a later time using @samp{load}, it will be restored as a\n\
 global variable.\n\
 \n\
 The command\n\
 \n\
 @example\n\
 save -binary data a b*\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -171,17 +171,17 @@ See arg.\n\
 }
 
 DEFUN (arg, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} arg (@var{z})\n\
 @deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument of @var{z}, defined as\n\
 @var{theta} = @code{atan2 (@var{y}, @var{x})}.\n\
-in radians. \n\
+in radians.  \n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
@@ -729,21 +729,23 @@ Computes the Gamma function,\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
             infinity\n\
             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
          t=0\n\
+@end group\n\
 @end example\n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).gamma ();
@@ -1296,18 +1298,18 @@ Return the integer nearest to @var{x}.  
 %!error round ();
 %!error round (1, 2);
 
 */
 
 DEFUN (roundb, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} roundb (@var{x})\n\
-Return the integer nearest to @var{x}. If there are two nearest\n\
-integers, return the even one (banker's rounding). If @var{x} is complex,\n\
+Return the integer nearest to @var{x}.  If there are two nearest\n\
+integers, return the even one (banker's rounding).  If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{rem}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).roundb ();
   else
@@ -1325,19 +1327,21 @@ Compute the @dfn{signum} function, which
 $$\n\
 {\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
+@group\n\
            -1, x < 0;\n\
 sign (x) =  0, x = 0;\n\
             1, x > 0.\n\
+@end group\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1563,18 +1567,20 @@ DEFUNX ("tolower", Ftolower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tolower (@var{s})\n\
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each upper-case\n\
 character replaced by the corresponding lower-case one; nonalphabetic\n\
 characters are left unchanged.  For example,\n\
 \n\
 @example\n\
+@group\n\
 tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
+@end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtolower ();
   else
@@ -1602,17 +1608,17 @@ DEFALIAS (lower, tolower);
 
 */
 
 
 DEFUNX ("toupper", Ftoupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} toupper (@var{s})\n\
 @deftypefnx {Built-in Function} {} upper (@var{s})\n\
-Return a copy of the string or cell string @var{s}, with each  lower-case\n\
+Return a copy of the string or cell string @var{s}, with each lower-case\n\
 character replaced by the corresponding upper-case one; nonalphabetic\n\
 characters are left unchanged.  For example,\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1392,25 +1392,27 @@ DEFUN (sparse_auto_mutate, args, nargout
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to real matrices to save memory.\n\
 For example,\n\
 \n\
 @example\n\
+@group\n\
 s = speye(3);\n\
 sparse_auto_mutate (false)\n\
 s (:, 1) = 1;\n\
 typeinfo (s)\n\
 @result{} sparse matrix\n\
 sparse_auto_mutate (true)\n\
 s (1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
+@end group\n\
 @end example\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -393,19 +393,21 @@ Return the @var{n}-th element of @var{li
 DEFUN (append, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} append (@var{list}, @var{a1}, @var{a2}, @dots{})\n\
 Return a new list created by appending @var{a1}, @var{a2}, @dots{}, to\n\
 @var{list}.  If any of the arguments to be appended is a list, its\n\
 elements are appended individually.  For example,\n\
 \n\
 @example\n\
+@group\n\
 x = list (1, 2);\n\
 y = list (3, 4);\n\
 append (x, y);\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 results in the list containing the four elements @samp{(1 2 3 4)}, not\n\
 a list containing the three elements @samp{(1 2 (3 4))}.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2630,26 +2630,28 @@ fields @samp{type} and @samp{subs}.  Val
 are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
 The following example shows how to extract the two first columns of\n\
 a matrix\n\
 \n\
 @example\n\
+@group\n\
 val = magic(3)\n\
      @result{} val = [ 8   1   6\n\
                 3   5   7\n\
                 4   9   2 ]\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsref(val, idx)\n\
      @result{} [ 8   1 \n\
           3   5 \n\
           4   9 ]\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that this is the same as writing @code{val(:,1:2)}.\n\
 @seealso{subsasgn, substruct}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -2681,23 +2683,25 @@ fields @samp{type} and @samp{subs}.  Val
 are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
 The following example shows how to set the two first columns of a\n\
 3-by-3 matrix to zero.\n\
 \n\
 @example\n\
+@group\n\
 val = magic(3);\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsasgn (val, idx, 0)\n\
      @result{} [ 0   0   6\n\
           0   0   7\n\
           0   0   2 ]\n\
+@end group\n\
 @end example\n\
 \n\
 Note that this is the same as writing @code{val(:,1:2) = 0}.\n\
 @seealso{subsref, substruct}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3180,18 +3180,20 @@ octave_print_internal (std::ostream&, co
 
 DEFUN (rats, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rats (@var{x}, @var{len})\n\
 Convert @var{x} into a rational approximation represented as a string.\n\
 You can convert the string back into a matrix as follows:\n\
 \n\
 @example\n\
+@group\n\
    r = rats(hilb(4));\n\
    x = str2num(r)\n\
+@end group\n\
 @end example\n\
 \n\
 The optional second argument defines the maximum length of the string\n\
 representing the elements of @var{x}.  By default @var{len} is 9.\n\
 @seealso{format, rat}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -3259,20 +3261,22 @@ representing the elements of @var{x}.  B
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
 Display the value of @var{x}.  For example,\n\
 \n\
 @example\n\
+@group\n\
 disp (\"The value of pi is:\"), disp (pi)\n\
 \n\
      @print{} the value of pi is:\n\
      @print{} 3.1416\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the output from @code{disp} always ends with a newline.\n\
 \n\
 If an output value is requested, @code{disp} prints nothing and\n\
 returns the formatted output in a string.\n\
 @seealso{fdisp}\n\
@@ -3301,20 +3305,22 @@ returns the formatted output in a string
 }
 
 DEFUN (fdisp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fdisp (@var{fid}, @var{x})\n\
 Display the value of @var{x} on the stream @var{fid}.  For example,\n\
 \n\
 @example\n\
+@group\n\
 fdisp (stdout, \"The value of pi is:\"), fdisp (stdout, pi)\n\
 \n\
      @print{} the value of pi is:\n\
      @print{} 3.1416\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the output from @code{fdisp} always ends with a newline.\n\
 @seealso{disp}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -314,17 +314,17 @@ Return 1 if the character strings @var{s
 and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
 \n\
-@strong{Caution:} For compatibility with @sc{Matlab}, Octave's strcmp\n\
+@strong{Caution:} For compatibility with @sc{matlab}, Octave's strcmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strcmpi, strncmp, strncmpi}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
@@ -628,17 +628,17 @@ or character string.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", @{\"abcd\", \"bca\", \"abc\"@}, 3)\n\
      @result{} [1, 0, 1]\n\
 @end group\n\
 @end example\n\
 \n\
-@strong{Caution:} For compatibility with @sc{Matlab}, Octave's strncmp\n\
+@strong{Caution:} For compatibility with @sc{matlab}, Octave's strncmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strncmpi, strcmp, strcmpi}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -720,17 +720,17 @@ Return 0 if successful, otherwise return
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fstat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} fstat (@var{fid})\n\
-Return information about about the open file @var{fid}.  See @code{stat}\n\
+Return information about the open file @var{fid}.  See @code{stat}\n\
 for a description of the contents of @var{info}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       int fid = octave_stream_list::get_file_number (args(0));
@@ -1458,17 +1458,17 @@ child process was terminated by a signal
 
   return retval;
 }
 
 DEFUNX ("WTERMSIG", FWTERMSIG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WTERMSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return the number of\n\
-the signal that caused the child process to terminate. This function\n\
+the signal that caused the child process to terminate.  This function\n\
 should only be employed if @code{WIFSIGNALED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0.0;
 
 #if defined (WTERMSIG)
   if (args.length () == 1)
@@ -1717,17 +1717,17 @@ status flags.\n\
 #endif
 
 #if defined (O_APPEND)
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
-or that may be passed to @code{fcntl} to set the write mode to append.\
+or that may be passed to @code{fcntl} to set the write mode to append.\\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
   return const_value (args, O_APPEND);
 }
 #endif
 
 #if defined (O_ASYNC)
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -337,18 +337,20 @@ DEFUN (file_in_path, args, ,
 @deftypefn {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
 directories in the format described for @code{path}.  If no file\n\
 is found, return an empty matrix.  For example,\n\
 \n\
 @example\n\
+@group\n\
 file_in_path (EXEC_PATH, \"sh\")\n\
      @result{} \"/bin/sh\"\n\
+@end group\n\
 @end example\n\
 \n\
 If the second argument is a cell array of strings, search each\n\
 directory of the path for element of the cell array and return\n\
 the first that matches.\n\
 \n\
 If the third optional argument @code{\"all\"} is supplied, return\n\
 a cell array containing the list of all files that have the same\n\
@@ -708,18 +710,20 @@ bell = \"\\a\";\n\
 assigns the value of the alert character (control-g, ASCII code 7) to\n\
 the string variable @code{bell}.  If this string is printed, the\n\
 system will ring the terminal bell (if it is possible).  This is\n\
 normally the desired outcome.  However, sometimes it is useful to be\n\
 able to print the original representation of the string, with the\n\
 special characters replaced by their escape sequences.  For example,\n\
 \n\
 @example\n\
+@group\n\
 octave:13> undo_string_escapes (bell)\n\
 ans = \\a\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 replaces the unprintable alert character with its printable\n\
 representation.\n\
 @end deftypefn")
 {
   octave_value retval;
