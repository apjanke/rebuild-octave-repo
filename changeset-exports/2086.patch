# HG changeset patch
# User jwe
# Date 830411719 0
#      Thu Apr 25 05:55:19 1996 +0000
# Node ID bfb775fb6fe8fca11a6fbdb501c01fb1658567e3
# Parent  7603b37325dbfa6d0097d7b91a6c6ba5b20a7e35
[project @ 1996-04-25 05:55:19 by jwe]

diff --git a/src/Array-tc.cc b/src/Array-tc.cc
--- a/src/Array-tc.cc
+++ b/src/Array-tc.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-// Instantiate Arrays of tree_constants.
+// Instantiate Arrays of octave_values.
 
 #include "Array.h"
 #include "Array.cc"
 
 #include "pt-const.h"
 
 extern template class Array<int>;
 extern template class Array2<int>;
@@ -38,15 +38,15 @@ extern template class DiagArray2<int>;
 extern template class Array<double>;
 extern template class Array2<double>;
 extern template class DiagArray2<double>;
 
 extern template class Array<Complex>;
 extern template class Array2<Complex>;
 extern template class DiagArray2<Complex>;
 
-template class Array<tree_constant>;
+template class Array<octave_value>;
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/Map-i.cc b/src/Map-i.cc
--- a/src/Map-i.cc
+++ b/src/Map-i.cc
@@ -15,17 +15,17 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
-// Instantiate Maps of tree_constants.
+// Instantiate Maps of octave_values.
 
 #include "Map.h"
 #include "Map.cc"
 
 template class Map<int>;
 template class CHNode<int>;
 template class CHMap<int>;
 
diff --git a/src/Map-tc.cc b/src/Map-tc.cc
--- a/src/Map-tc.cc
+++ b/src/Map-tc.cc
@@ -15,27 +15,27 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
-// Instantiate Maps of tree_constants.
+// Instantiate Maps of octave_values.
 
 #include "Map.h"
 #include "Map.cc"
 
 #include "pt-const.h"
 
-template class Map<tree_constant>;
-template class CHNode<tree_constant>;
-template class CHMap<tree_constant>;
+template class Map<octave_value>;
+template class CHNode<octave_value>;
+template class CHMap<octave_value>;
 
-template static int goodCHptr (CHNode<tree_constant> *t);
-template static int CHptr_to_index (CHNode<tree_constant> *t);
+template static int goodCHptr (CHNode<octave_value> *t);
+template static int CHptr_to_index (CHNode<octave_value> *t);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/SLList-tc.cc b/src/SLList-tc.cc
--- a/src/SLList-tc.cc
+++ b/src/SLList-tc.cc
@@ -25,16 +25,16 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <SLList.h>
 
 #include "pt-const.h"
 
-template class SLNode<tree_constant>;
-template class SLList<tree_constant>;
+template class SLNode<octave_value>;
+template class SLList<octave_value>;
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -969,17 +969,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 
 // Unary operations.  One for each numeric data type:
 //
 //   scalar
 //   complex_scalar
 //   matrix
 //   complex_matrix
 
-tree_constant
+octave_value
 do_unary_op (double d, tree_expression::type t)
 {
   double result = 0.0;
 
   switch (t)
     {
     case tree_expression::not:
       result = (! d);
@@ -994,20 +994,20 @@ do_unary_op (double d, tree_expression::
       result = d;
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
-  return tree_constant (result);
+  return octave_value (result);
 }
 
-tree_constant
+octave_value
 do_unary_op (const Matrix& a, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::not:
       result = (! a);
@@ -1022,20 +1022,20 @@ do_unary_op (const Matrix& a, tree_expre
       result = a.transpose ();
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
-  return tree_constant (result);
+  return octave_value (result);
 }
 
-tree_constant
+octave_value
 do_unary_op (const Complex& c, tree_expression::type t)
 {
   Complex result = 0.0;
 
   switch (t)
     {
     case tree_expression::not:
       result = (c == 0.0);
@@ -1053,20 +1053,20 @@ do_unary_op (const Complex& c, tree_expr
       result = c;
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
-  return tree_constant (result);
+  return octave_value (result);
 }
 
-tree_constant
+octave_value
 do_unary_op (const ComplexMatrix& a, tree_expression::type t)
 {
   ComplexMatrix result;
 
   switch (t)
     {
     case tree_expression::not:
       result = (! a);
@@ -1084,17 +1084,17 @@ do_unary_op (const ComplexMatrix& a, tre
       result = a.transpose ();
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
-  return tree_constant (result);
+  return octave_value (result);
 }
 
 // Binary operations.  One for each type combination, in the order
 // given here:
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
 //   scalar   |     | 1 | 5 | 9  | 13 |
@@ -1102,17 +1102,17 @@ do_unary_op (const ComplexMatrix& a, tre
 //   matrix         | 2 | 6 | 10 | 14 |
 //                  +---+---+----+----+
 //   complex_scalar | 3 | 7 | 11 | 15 |
 //                  +---+---+----+----+
 //   complex_matrix | 4 | 8 | 12 | 16 |
 //                  +---+---+----+----+
 
 // -*- 1 -*-
-tree_constant
+octave_value
 do_binary_op (double a, double b, tree_expression::type t)
 {
   double result = 0.0;
 
   switch (t)
     {
     case tree_expression::add:
       result = a + b;
@@ -1179,23 +1179,23 @@ do_binary_op (double a, double b, tree_e
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
-
-  return tree_constant (result);
+    return octave_value ();
+
+  return octave_value (result);
 }
 
 // -*- 2 -*-
-tree_constant
+octave_value
 do_binary_op (double a, const Matrix& b, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
       result = a + b;
@@ -1266,23 +1266,23 @@ do_binary_op (double a, const Matrix& b,
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
-
-  return tree_constant (result);
+    return octave_value ();
+
+  return octave_value (result);
 }
 
 // -*- 3 -*-
-tree_constant
+octave_value
 do_binary_op (double a, const Complex& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
 
@@ -1366,28 +1366,28 @@ do_binary_op (double a, const Complex& b
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 4 -*-
-tree_constant
+octave_value
 do_binary_op (double a, const ComplexMatrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
@@ -1473,28 +1473,28 @@ do_binary_op (double a, const ComplexMat
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 5 -*-
-tree_constant
+octave_value
 do_binary_op (const Matrix& a, double b, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
       result = a + b;
@@ -1563,23 +1563,23 @@ do_binary_op (const Matrix& a, double b,
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
-
-  return tree_constant (result);
+    return octave_value ();
+
+  return octave_value (result);
 }
 
 // -*- 6 -*-
-tree_constant
+octave_value
 do_binary_op (const Matrix& a, const Matrix& b, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
       if (m_add_conform (a, b, 1))
@@ -1669,23 +1669,23 @@ do_binary_op (const Matrix& a, const Mat
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
-
-  return tree_constant (result);
+    return octave_value ();
+
+  return octave_value (result);
 }
 
 // -*- 7 -*-
-tree_constant
+octave_value
 do_binary_op (const Matrix& a, const Complex& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
@@ -1770,28 +1770,28 @@ do_binary_op (const Matrix& a, const Com
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 8 -*-
-tree_constant
+octave_value
 do_binary_op (const Matrix& a, const ComplexMatrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
@@ -1899,28 +1899,28 @@ do_binary_op (const Matrix& a, const Com
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 9 -*-
-tree_constant
+octave_value
 do_binary_op (const Complex& a, double b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
 
@@ -2004,28 +2004,28 @@ do_binary_op (const Complex& a, double b
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 10 -*-
-tree_constant
+octave_value
 do_binary_op (const Complex& a, const Matrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
@@ -2112,28 +2112,28 @@ do_binary_op (const Complex& a, const Ma
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 11 -*-
-tree_constant
+octave_value
 do_binary_op (const Complex& a, const Complex& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
 
@@ -2217,28 +2217,28 @@ do_binary_op (const Complex& a, const Co
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 12 -*-
-tree_constant
+octave_value
 do_binary_op (const Complex& a, const ComplexMatrix& b,
 	      tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -2326,28 +2326,28 @@ do_binary_op (const Complex& a, const Co
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 13 -*-
-tree_constant
+octave_value
 do_binary_op (const ComplexMatrix& a, double b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
@@ -2432,28 +2432,28 @@ do_binary_op (const ComplexMatrix& a, do
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 14 -*-
-tree_constant
+octave_value
 do_binary_op (const ComplexMatrix& a, const Matrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
 
@@ -2561,28 +2561,28 @@ do_binary_op (const ComplexMatrix& a, co
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 15 -*-
-tree_constant
+octave_value
 do_binary_op (const ComplexMatrix& a, const Complex& b,
 	      tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -2668,28 +2668,28 @@ do_binary_op (const ComplexMatrix& a, co
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 // -*- 16 -*-
-tree_constant
+octave_value
 do_binary_op (const ComplexMatrix& a, const ComplexMatrix& b,
 	      tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -2798,23 +2798,23 @@ do_binary_op (const ComplexMatrix& a, co
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
-    return tree_constant (result);
+    return octave_value (result);
   else
-    return tree_constant (complex_result);
+    return octave_value (complex_result);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/arith-ops.h b/src/arith-ops.h
--- a/src/arith-ops.h
+++ b/src/arith-ops.h
@@ -24,73 +24,73 @@ Software Foundation, 59 Temple Place - S
 #define octave_arith_ops_h 1
 
 #include "oct-cmplx.h"
 
 #include "pt-exp.h"
 
 class Matrix;
 class ComplexMatrix;
-class tree_constant;
+class octave_value;
 
-extern tree_constant do_unary_op (double d, tree_expression::type t);
+extern octave_value do_unary_op (double d, tree_expression::type t);
 
-extern tree_constant do_unary_op (const Matrix& a, tree_expression::type t);
+extern octave_value do_unary_op (const Matrix& a, tree_expression::type t);
 
-extern tree_constant do_unary_op (const Complex& c, tree_expression::type t);
+extern octave_value do_unary_op (const Complex& c, tree_expression::type t);
 
-extern tree_constant do_unary_op (const ComplexMatrix& a,
+extern octave_value do_unary_op (const ComplexMatrix& a,
 				  tree_expression::type t);
 
-extern tree_constant do_binary_op (double a, double b,
+extern octave_value do_binary_op (double a, double b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (double a, const Matrix& b,
+extern octave_value do_binary_op (double a, const Matrix& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (double a, const Complex& b,
+extern octave_value do_binary_op (double a, const Complex& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (double a, const ComplexMatrix& b,
+extern octave_value do_binary_op (double a, const ComplexMatrix& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Matrix& a, double b,
+extern octave_value do_binary_op (const Matrix& a, double b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Matrix& a, const Matrix& b,
+extern octave_value do_binary_op (const Matrix& a, const Matrix& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Matrix& a, const Complex& b,
+extern octave_value do_binary_op (const Matrix& a, const Complex& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Matrix& a, const ComplexMatrix& b,
+extern octave_value do_binary_op (const Matrix& a, const ComplexMatrix& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Complex& a, double b,
+extern octave_value do_binary_op (const Complex& a, double b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Complex& a, const Matrix& b,
+extern octave_value do_binary_op (const Complex& a, const Matrix& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Complex& a, const Complex& b,
+extern octave_value do_binary_op (const Complex& a, const Complex& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const Complex& a, const ComplexMatrix& b,
+extern octave_value do_binary_op (const Complex& a, const ComplexMatrix& b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const ComplexMatrix& a, double b,
+extern octave_value do_binary_op (const ComplexMatrix& a, double b,
 				   tree_expression::type t);
 
-extern tree_constant do_binary_op (const ComplexMatrix& a, const Matrix& b,
+extern octave_value do_binary_op (const ComplexMatrix& a, const Matrix& b,
 				   tree_expression::type t); 
 
-extern tree_constant do_binary_op (const ComplexMatrix& a, const Complex& b,
+extern octave_value do_binary_op (const ComplexMatrix& a, const Complex& b,
 				   tree_expression::type t); 
 
-extern tree_constant do_binary_op (const ComplexMatrix& a,
+extern octave_value do_binary_op (const ComplexMatrix& a,
 				   const ComplexMatrix& b,
 				   tree_expression::type t); 
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -56,17 +56,17 @@ where OPT is an optional single characte
   S: scale to improve accuracy of computed eigenvalues\n\
   B: (default) permute and scale, in that order.  Rows/columns\n\
      of a (and b) that are isolated by permutation are not scaled\n\
 \n\
 [DD, AA] = balance (A, OPT) returns aa = dd\a*dd,\n\
 \n\
 [CC, DD, AA, BB] = balance (A, B, OPT) returns AA (BB) = CC*A*DD (CC*B*DD)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout < 0 || nargout > 4)
     {
       print_usage ("balance");
       return retval;
     }
@@ -83,29 +83,29 @@ where OPT is an optional single characte
       my_nargin = nargin-1;
     }
   else
     {
       bal_job = "B";
       my_nargin = nargin;
     }
 
-  tree_constant arg_a = args(0);
+  octave_value arg_a = args(0);
 
   int a_nr = arg_a.rows ();
   int a_nc = arg_a.columns ();
 
   // Check argument 1 dimensions.
 
   int arg_is_empty = empty_arg ("balance", a_nr, a_nc);
 
   if (arg_is_empty < 0)
     return retval;
   if (arg_is_empty > 0)
-    return Octave_object (2, Matrix ());
+    return octave_value_list (2, Matrix ());
 
   if (a_nr != a_nc)
     {
       gripe_square_matrix_required ("balance");
       return retval;
     }
 
   // Extract argument 1 parameter for both AEP and GEP.
@@ -155,17 +155,17 @@ where OPT is an optional single characte
       break;
 
     case 2:
       {
 	// Generalized eigenvalue problem.
 
 	// 1st we have to check argument 2 dimensions and type...
 
-	tree_constant arg_b = args(1);
+	octave_value arg_b = args(1);
 
 	int b_nr = arg_b.rows ();
 	int b_nc = arg_b.columns ();
       
 	// Check argument 2 dimensions -- must match arg 1.
 
 	if (b_nr != b_nc || b_nr != a_nr)
 	  {
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -33,27 +33,27 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (chol, args, nargout,
   "R = chol (X): cholesky factorization")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 1)
     {
       print_usage ("chol");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
     
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("chol", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (colloc, args, ,
   "[R, A, B, Q] = colloc (N [, \"left\"] [, \"right\"]): collocation weights")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("colloc");
       return retval;
     }
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -48,46 +48,46 @@ ColumnVector
 dassl_user_function (const ColumnVector& x, const ColumnVector& xdot, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
   assert (nstates == xdot.capacity ());
 
-  Octave_object args;
+  octave_value_list args;
   args(2) = t;
 
   if (nstates > 1)
     {
       Matrix m1 (nstates, 1);
       Matrix m2 (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	{
 	  m1 (i, 0) = x.elem (i);
 	  m2 (i, 0) = xdot.elem (i);
 	}
-      tree_constant state (m1);
-      tree_constant deriv (m2);
+      octave_value state (m1);
+      octave_value deriv (m2);
       args(1) = deriv;
       args(0) = state;
     }
   else
     {
       double d1 = x.elem (0);
       double d2 = xdot.elem (0);
-      tree_constant state (d1);
-      tree_constant deriv (d2);
+      octave_value state (d1);
+      octave_value deriv (d2);
       args(1) = deriv;
       args(0) = state;
     }
 
   if (dassl_fcn)
     {
-      Octave_object tmp = dassl_fcn->eval (0, 1, args);
+      octave_value_list tmp = dassl_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("dassl");
 	  return retval;
 	}
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
@@ -110,17 +110,17 @@ dassl (F, X_0, XDOT_0, T_OUT, T_CRIT)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of residuals.  It must have the form\n\
 \n\
   res = f (x, xdot, t)\n\
 \n\
 where x, xdot, and res are vectors, and t is a scalar.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 4 || nargin > 5)
     {
       print_usage ("dassl");
       return retval;
     }
@@ -289,20 +289,20 @@ set_dassl_option (const string& keyword,
 	  return;
 	}
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword.c_str ());
 }
 
-static Octave_object
+static octave_value_list
 show_dassl_option (const string& keyword)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   DASSL_OPTIONS *list = dassl_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -317,17 +317,17 @@ show_dassl_option (const string& keyword
 }
 
 DEFUN_DLD_BUILTIN (dassl_options, args, ,
   "dassl_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for dassl.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       print_dassl_option_list ();
       return retval;
     }
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -52,32 +52,32 @@ Software Foundation, Inc.
 
 #ifndef ABS
 #define ABS(x) (((x) < 0) ? (-x) : (x))
 #endif
 
 DEFUN (all, args, ,
   "all (X): are all elements of X nonzero?")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).all ();
   else
     print_usage ("all");
 
   return retval;
 }
 
 DEFUN (any, args, ,
   "any (X): are any elements of X nonzero?")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).any ();
   else
     print_usage ("any");
 
@@ -136,24 +136,24 @@ map (d_dd_fcn f, const Matrix& x, const 
       retval.elem (i, j) = f (x.elem (i, j), y.elem (i, j));
 
   return retval;
 }
 
 DEFUN (atan2, args, ,
   "atan2 (Y, X): atan (Y / X) in range -pi to pi")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
-      tree_constant arg_y = args(0);
-      tree_constant arg_x = args(1);
+      octave_value arg_y = args(0);
+      octave_value arg_x = args(1);
 
       int y_nr = arg_y.rows ();
       int y_nc = arg_y.columns ();
 
       int x_nr = arg_x.rows ();
       int x_nc = arg_x.columns ();
 
       int arg_y_empty = empty_arg ("atan2", y_nr, y_nc);
@@ -222,23 +222,23 @@ DEFUN (atan2, args, ,
     print_usage ("atan2");
 
   return retval;
 }
 
 DEFUN (cumprod, args, ,
   "cumprod (X): cumulative products")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_real_type ())
 	{
 	  Matrix tmp = arg.matrix_value ();
 
 	  if (! error_state)
 	    retval(0) = tmp.cumprod ();
 	}
@@ -259,23 +259,23 @@ DEFUN (cumprod, args, ,
     print_usage ("cumprod");
 
   return retval;
 }
 
 DEFUN (cumsum, args, ,
   "cumsum (X): cumulative sums")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_real_type ())
 	{
 	  Matrix tmp = arg.matrix_value ();
 
 	  if (! error_state)
 	    retval(0) = tmp.cumsum ();
 	}
@@ -293,24 +293,24 @@ DEFUN (cumsum, args, ,
 	}
     }
   else
     print_usage ("cumsum");
 
   return retval;
 }
 
-static tree_constant
+static octave_value
 make_diag (const Matrix& v, int k)
 {
   int nr = v.rows ();
   int nc = v.columns ();
   assert (nc == 1 || nr == 1);
 
-  tree_constant retval;
+  octave_value retval;
 
   int roff = 0;
   int coff = 0;
   if (k > 0)
     {
       roff = 0;
       coff = k;
     }
@@ -321,38 +321,38 @@ make_diag (const Matrix& v, int k)
     }
 
   if (nr == 1)
     {
       int n = nc + ABS (k);
       Matrix m (n, n, 0.0);
       for (int i = 0; i < nc; i++)
 	m.elem (i+roff, i+coff) = v.elem (0, i);
-      retval = tree_constant (m);
+      retval = octave_value (m);
     }
   else
     {
       int n = nr + ABS (k);
       Matrix m (n, n, 0.0);
       for (int i = 0; i < nr; i++)
 	m.elem (i+roff, i+coff) = v.elem (i, 0);
-      retval = tree_constant (m);
+      retval = octave_value (m);
     }
 
   return retval;
 }
 
-static tree_constant
+static octave_value
 make_diag (const ComplexMatrix& v, int k)
 {
   int nr = v.rows ();
   int nc = v.columns ();
   assert (nc == 1 || nr == 1);
 
-  tree_constant retval;
+  octave_value retval;
 
   int roff = 0;
   int coff = 0;
   if (k > 0)
     {
       roff = 0;
       coff = k;
     }
@@ -363,34 +363,34 @@ make_diag (const ComplexMatrix& v, int k
     }
 
   if (nr == 1)
     {
       int n = nc + ABS (k);
       ComplexMatrix m (n, n, 0.0);
       for (int i = 0; i < nc; i++)
 	m.elem (i+roff, i+coff) = v.elem (0, i);
-      retval = tree_constant (m);
+      retval = octave_value (m);
     }
   else
     {
       int n = nr + ABS (k);
       ComplexMatrix m (n, n, 0.0);
       for (int i = 0; i < nr; i++)
 	m.elem (i+roff, i+coff) = v.elem (i, 0);
-      retval = tree_constant (m);
+      retval = octave_value (m);
     }
 
   return retval;
 }
 
-static tree_constant
-make_diag (const tree_constant& arg)
+static octave_value
+make_diag (const octave_value& arg)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  int nr = m.rows ();
@@ -434,20 +434,20 @@ make_diag (const tree_constant& arg)
 	gripe_wrong_type_arg ("diag", arg);
     }
   else
     gripe_wrong_type_arg ("diag", arg);
 
   return retval;
 }
 
-static tree_constant
-make_diag (const tree_constant& a, const tree_constant& b)
+static octave_value
+make_diag (const octave_value& a, const octave_value& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   double tmp = b.double_value ();
 
   if (error_state)
     {
       error ("diag: invalid second argument");      
       return retval;
     }
@@ -541,40 +541,40 @@ make_diag (const tree_constant& a, const
     gripe_wrong_type_arg ("diag", a);
 
   return retval;
 }
 
 DEFUN (diag, args, ,
   "diag (X [,k]): form/extract diagonals")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = make_diag (args(0));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     retval = make_diag (args(0), args(1));
   else
     print_usage ("diag");
 
   return retval;
 }
 
 DEFUN (prod, args, ,
   "prod (X): products")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_real_type ())
 	{
 	  Matrix tmp = arg.matrix_value ();
 
 	  if (! error_state)
 	    retval(0) = tmp.prod ();
 	}
@@ -600,17 +600,17 @@ DEFUN (prod, args, ,
 DEFUN (size, args, nargout,
   "[m, n] = size (x): return rows and columns of X\n\
 \n\
 d = size (x): return number of rows and columns of x as a row vector\n\
 \n\
 m = size (x, 1): return number of rows in x\n\
 m = size (x, 2): return number of columns in x")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && nargout < 3)
     {
       int nr = args(0).rows ();
       int nc = args(0).columns ();
 
@@ -647,23 +647,23 @@ m = size (x, 2): return number of column
     print_usage ("size");
 
   return retval;
 }
 
 DEFUN (sum, args, ,
   "sum (X): sum of elements")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_real_type ())
 	{
 	  Matrix tmp = arg.matrix_value ();
 
 	  if (! error_state)
 	    retval(0) = tmp.sum ();
 	}
@@ -684,23 +684,23 @@ DEFUN (sum, args, ,
     print_usage ("sum");
 
   return retval;
 }
 
 DEFUN (sumsq, args, ,
   "sumsq (X): sum of squares of elements")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_real_type ())
 	{
 	  Matrix tmp = arg.matrix_value ();
 
 	  if (! error_state)
 	    retval(0) = tmp.sumsq ();
 	}
@@ -721,23 +721,23 @@ DEFUN (sumsq, args, ,
     print_usage ("sumsq");
 
   return retval;
 }
 
 DEFUN (is_struct, args, ,
   "is_struct (x): return nonzero if x is a structure")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_map ())
 	retval = 1.0;
       else
 	retval = 0.0;
     }
   else
     print_usage ("is_struct");
@@ -745,17 +745,17 @@ DEFUN (is_struct, args, ,
   return retval;
 }
 
 DEFUN (struct_elements, args, ,
   "struct_elements (S)\n\
 \n\
 Return a list of the names of the elements of the structure S.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args (0).is_map ())
 	{
 	  Octave_map m = args(0).map_value ();
@@ -770,27 +770,27 @@ Return a list of the names of the elemen
   return retval;
 }
 
 DEFUN (struct_contains, args, ,
   "struct_contains (S, NAME)\n\
 \n\
 return nonzero if S is a structure with element NAME")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       retval = 0.0;
       if (args(0).is_map () && args(1).is_string ())
 	{
 	  string s = args(1).string_value ();
-	  tree_constant tmp = args(0).lookup_map_element (s, 0, 1);
+	  octave_value tmp = args(0).lookup_map_element (s, 0, 1);
 	  retval = (double) tmp.is_defined ();
 	}
     }
   else
     print_usage ("struct_contains");
 
   return retval;
 }
@@ -811,17 +811,17 @@ check_dimensions (int& nr, int& nc, cons
 	}
       else
 	error ("%s: can't create a matrix with negative dimensions",
 	       warnfor);
     }
 }
 
 static void
-get_dimensions (const tree_constant& a, const char *warn_for,
+get_dimensions (const octave_value& a, const char *warn_for,
 		int& nr, int& nc)
 {
   if (a.is_scalar_type ())
     {
       double tmp = a.double_value ();
       nr = nc = NINT (tmp);
     }
   else
@@ -842,61 +842,61 @@ get_dimensions (const tree_constant& a, 
       else
 	warning ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
   check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 static void
-get_dimensions (const tree_constant& a, const tree_constant& b,
+get_dimensions (const octave_value& a, const octave_value& b,
 		const char *warn_for, int& nr, int& nc)
 {
   nr = NINT (a.double_value ());
   nc = NINT (b.double_value ());
 
   if (error_state)
     error ("%s: expecting two scalar arguments", warn_for);
   else
     check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
-static tree_constant
-fill_matrix (const tree_constant& a, double val, const char *warn_for)
+static octave_value
+fill_matrix (const octave_value& a, double val, const char *warn_for)
 {
   int nr, nc;
   get_dimensions (a, warn_for, nr, nc);
 
   if (error_state)
-    return  tree_constant ();
+    return  octave_value ();
 
   Matrix m (nr, nc, val);
 
   return m;
 }
 
-static tree_constant
-fill_matrix (const tree_constant& a, const tree_constant& b,
+static octave_value
+fill_matrix (const octave_value& a, const octave_value& b,
 	     double val, const char *warn_for)
 {
   int nr, nc;
   get_dimensions (a, b, warn_for, nr, nc); // May set error_state.
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   Matrix m (nr, nc, val);
 
   return m;
 }
 
 DEFUN (ones, args, ,
   "ones (N), ones (N, M), ones (X): create a matrix of all ones")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
     case 0:
       retval = 1.0;
       break;
@@ -915,17 +915,17 @@ DEFUN (ones, args, ,
     }
 
   return retval;
 }
 
 DEFUN (zeros, args, ,
   "zeros (N), zeros (N, M), zeros (X): create a matrix of all zeros")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
     case 0:
       retval = 0.0;
       break;
@@ -941,62 +941,62 @@ DEFUN (zeros, args, ,
     default:
       print_usage ("zeros");
       break;
     }
 
   return retval;
 }
 
-static tree_constant
-identity_matrix (const tree_constant& a)
+static octave_value
+identity_matrix (const octave_value& a)
 {
   int nr, nc;
   get_dimensions (a, "eye", nr, nc); // May set error_state.
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
     }
 
   return m;
 }
 
-static tree_constant
-identity_matrix (const tree_constant& a, const tree_constant& b)
+static octave_value
+identity_matrix (const octave_value& a, const octave_value& b)
 {
   int nr, nc;
   get_dimensions (a, b, "eye", nr, nc);  // May set error_state.
 
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
     }
 
   return m;
 }
 
 DEFUN (eye, args, ,
   "eye (N), eye (N, M), eye (X): create an identity matrix")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
     case 0:
       retval = 1.0;
       break;
@@ -1024,17 +1024,17 @@ Return a vector of n equally spaced poin
 inclusive.\n\
 \n\
 If the final argument is omitted, n = 100 is assumed.\n\
 \n\
 All three arguments must be scalars.\n\
 \n\
 See also: logspace")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   int npoints = 100;
 
   if (nargin != 2 && nargin != 3)
     {
       print_usage ("linspace");
@@ -1048,43 +1048,43 @@ See also: logspace")
       if (! error_state)
 	npoints = NINT (n);
     }
 
   if (! error_state)
     {
       if (npoints > 1)
 	{
-	  tree_constant arg_1 = args(0);
-	  tree_constant arg_2 = args(1);
+	  octave_value arg_1 = args(0);
+	  octave_value arg_2 = args(1);
 
 	  if (arg_1.is_complex_type () || arg_2.is_complex_type ())
 	    {
 	      Complex x1 = arg_1.complex_value ();
 	      Complex x2 = arg_2.complex_value ();
 
 	      if (! error_state)
 		{
 		  ComplexRowVector rv = linspace (x1, x2, npoints);
 
 		  if (! error_state)
-		    retval (0) = tree_constant (rv, 0);
+		    retval (0) = octave_value (rv, 0);
 		}
 	    }
 	  else
 	    {
 	      double x1 = arg_1.double_value ();
 	      double x2 = arg_2.double_value ();
 
 	      if (! error_state)
 		{
 		  RowVector rv = linspace (x1, x2, npoints);
 
 		  if (! error_state)
-		    retval (0) = tree_constant (rv, 0);
+		    retval (0) = octave_value (rv, 0);
 		}
 	    }
 	}
       else
 	error ("linspace: npoints must be greater than 2");
     }
 
   return retval;
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -70,17 +70,17 @@ Software Foundation, 59 Temple Place - S
 #define DEFINE_FUN_STRUCT_FUN(name) \
   builtin_function& \
   FS ## name (void) \
   { \
     return S ## name; \
   }
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
-  Octave_object F ## name (const Octave_object& args_name, int nargout_name)
+  octave_value_list F ## name (const octave_value_list& args_name, int nargout_name)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -72,28 +72,28 @@ Software Foundation, 59 Temple Place - S
   DEFVAR_INT (name, sname, defn, inst_as_fcn, 0, sv_fcn, doc); \
   DEFVAR_INT ("__" ## name ## "__", X ## sname, defn, 0, 1, sv_fcn, doc)
 
 // How builtin variables are actually installed.
 
 #define DEFVAR_INT(name, sname, defn, inst_as_fcn, protect, sv_fcn, doc) \
   do \
     { \
-      builtin_variable sname (name, new tree_constant (defn), \
+      builtin_variable sname (name, new octave_value (defn), \
 			      inst_as_fcn, protect, (sv_fcn ? 1 : 0), \
 			      sv_fcn, doc); \
       install_builtin_variable (sname); \
     } \
   while (0)
 
 // Define a builtin function.
 //
 //   name is the name of the function, unqouted.
 //
-//   args_name is the name of the Octave_object variable used to pass
+//   args_name is the name of the octave_value_list variable used to pass
 //     the argument list to this function.
 //
 //   nargout_name is the name of the int variable used to pass the
 //     number of output arguments this function is expected to produce.
 //
 //   doc is the simple help text for the function.
 
 #define DEFUN(name, args_name, nargout_name, doc) \
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -33,27 +33,27 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (det, args, ,
   "det (X): determinant of a square matrix")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("det");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
     
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
     {
       retval = 1.0;
       return retval;
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -308,17 +308,17 @@ octave_change_to_directory (const string
 
 DEFUN_TEXT (cd, args, ,
   "cd [dir]\n\
 \n\
 change current working directory\n\
 if no arguments are given, the current directory is changed to the\n\
 users home directory")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("cd");
 
   if (error_state)
     return retval;
 
@@ -337,17 +337,17 @@ users home directory")
       if (home_directory.empty ()
 	  || ! octave_change_to_directory (home_directory))
 	{
 	  return retval;
 	}
     }
 
   string directory = get_working_directory ("cd");
-  tree_constant *dir = new tree_constant (directory);
+  octave_value *dir = new octave_value (directory);
   bind_builtin_variable ("PWD", dir, 1);
 
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 // Get a directory listing.
@@ -358,17 +358,17 @@ cleanup_iprocstream (void *p)
   delete (iprocstream *) p;
 }
 
 DEFUN_TEXT (ls, args, ,
   "ls [options]\n\
 \n\
 print a directory listing")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("ls");
 
   if (error_state)
     return retval;
 
@@ -405,17 +405,17 @@ print a directory listing")
   return retval;
 }
 
 DEFALIAS (dir, ls);
 
 DEFUN (pwd, , nargout,
   "pwd (): print current working directory")
 {
-  Octave_object retval;
+  octave_value_list retval;
   string directory;
 
   if (verbatim_pwd)
     {
       directory = octave_getcwd ();
 
       if (directory.empty ())
 	warning ("pwd: can't find working directory!");
@@ -440,17 +440,17 @@ DEFUN (pwd, , nargout,
 
 DEFUN (readdir, args, ,
   "readdir (NAME)\n\
 \n\
 Return an array of strings containing the list of all files in the
 named directory.  If sucessful, returns 0; otherwise an error message
 is printed.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (args.length () == 1)
     {
       string dirname = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("readdir", args(0));
       else
@@ -479,17 +479,17 @@ is printed.")
 // mode.
 
 DEFUN (mkdir, args, ,
   "mkdir (NAME)\n\
 \n\
 Create the directory named by NAME.  If successful, returns 0;\n\
 otherwise prints an error message.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
       string dirname = args(0).string_value ();
 
       if (error_state)
@@ -515,17 +515,17 @@ otherwise prints an error message.")
 }
 
 DEFUN (rmdir, args, ,
   "rmdir (NAME)\n\
 \n\
 Remove the directory named by NAME.  If successful, returns 0;\n\
 otherwise prints an error message.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
       string dirname = args(0).string_value ();
 
       if (error_state)
@@ -551,17 +551,17 @@ otherwise prints an error message.")
 }
 
 DEFUN (rename, args, ,
   "rename (FROM, TO)\n\
 \n\
 Rename a file.  If successful, returns 0;\n\
 otherwise prints an error message and returns -1.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int status = 0;
 
   if (args.length () == 2)
     {
       string from = args(0).string_value ();
 
       if (error_state)
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -20,17 +20,17 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_dynamic_ld_h)
 #define octave_dynamic_ld_h 1
 
 #include "oct-obj.h"
 
-typedef Octave_object (*Octave_builtin_fcn)(const Octave_object&, int);
+typedef octave_value_list (*Octave_builtin_fcn)(const octave_value_list&, int);
 
 extern int load_octave_oct_file (const string& name);
 
 extern void init_dynamic_linker (void);
 
 #endif
 
 /*
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -32,36 +32,36 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (eig, args, nargout,
   "eig (X) or [V, D] = eig (X): compute eigenvalues and eigenvectors of X")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
       print_usage ("eig");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("eig", nr, nc);
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Octave_object (2, Matrix ());
+    return octave_value_list (2, Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("eig");
       return retval;
     }
 
   Matrix tmp;
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -191,28 +191,28 @@ panic (const char *fmt, ...)
   va_start (args, fmt);
   verror ("panic", fmt, args);
   va_end (args);
   abort ();
 }
 
 typedef void (*error_fun)(const char *, ...);
 
-extern Octave_object Fsprintf (const Octave_object&, int);
+extern octave_value_list Fsprintf (const octave_value_list&, int);
 
-static Octave_object
-handle_message (error_fun f, const char *msg, const Octave_object& args)
+static octave_value_list
+handle_message (error_fun f, const char *msg, const octave_value_list& args)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   string tstr;
 
   int nargin = args.length ();
 
-  tree_constant arg = ((nargin > 1) ? Fsprintf (args, 1) : args) (0);
+  octave_value arg = ((nargin > 1) ? Fsprintf (args, 1) : args) (0);
 
   if (arg.is_defined ())
     {
       if (arg.is_string ())
 	{
 	  tstr = arg.string_value ();
 	  msg = tstr.c_str ();
 
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -31,27 +31,27 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (expm, args, ,
   "expm (X): matrix exponential, e^A")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("expm");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("expm", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -33,27 +33,27 @@ Software Foundation, 59 Temple Place - S
 #include "user-prefs.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 DEFUN_DLD_BUILTIN (fft, args, ,
   "fft (X [, N]): fast fourier transform of a vector")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("fft");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int n_points = arg.rows ();
   if (n_points == 1)
     n_points = arg.columns ();
 
   if (nargin == 2)
     {
       double dval = args(1).double_value ();
diff --git a/src/fft2.cc b/src/fft2.cc
--- a/src/fft2.cc
+++ b/src/fft2.cc
@@ -35,27 +35,27 @@ Software Foundation, 59 Temple Place - S
 
 // This function should be merged with Fifft2.
 
 DEFUN_DLD_BUILTIN (fft2, args, ,
   "fft2 (X [, N] [, M])\n\
 \n\
 two dimensional fast fourier transform of a vector")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("fft2");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int n_rows = arg.rows ();
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
 	error ("fft2: NaN is invalid as N_ROWS");
       else
diff --git a/src/filter.cc b/src/filter.cc
--- a/src/filter.cc
+++ b/src/filter.cc
@@ -161,17 +161,17 @@ where la = length (a) and lb = length (b
 and returns the final state, sf.  The state vector is a column vector\n\
 whose length is equal to the length of the longest coefficient vector\n\
 minus one.  If si is not set, the initial state vector is set to all\n\
 zeros.\n\
 \n\
 The particular algorithm employed is known as a transposed Direct Form II\n\
 implementation.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 4)
     {
       print_usage ("filter");
       return retval;
     }
@@ -194,35 +194,35 @@ implementation.")
 
       if (! error_state)
 	{
 	  if (nargin == 3)
 	    {
 	      ComplexColumnVector y (filter (b, a, x));
 
 	      if (x_is_vector)
-		retval (0) = tree_constant (y, (args(2).columns () == 1));
+		retval (0) = octave_value (y, (args(2).columns () == 1));
 	      else
 		retval (0) = y;
 	    }
 	  else
 	    {
 	      ComplexColumnVector si = args(3).complex_vector_value ();
 
 	      if (! error_state)
 		{
 		  ComplexColumnVector y (filter (b, a, x, si));
 
 		  if (si_is_vector)
-		    retval (1) = tree_constant (si, (args(3).columns () == 1));
+		    retval (1) = octave_value (si, (args(3).columns () == 1));
 		  else
 		    retval (1) = si;
 
 		  if (x_is_vector)
-		    retval (0) = tree_constant (y, (args(2).columns () == 1));
+		    retval (0) = octave_value (y, (args(2).columns () == 1));
 		  else
 		    retval (0) = y;
 		}
 	      else
 		error (errmsg);
 	    }
 	}
       else
@@ -236,35 +236,35 @@ implementation.")
 
       if (! error_state)
 	{
 	  if (nargin == 3)
 	    {
 	      ColumnVector y (filter (b, a, x));
 
 	      if (x_is_vector)
-		retval (0) = tree_constant (y, (args(2).columns () == 1));
+		retval (0) = octave_value (y, (args(2).columns () == 1));
 	      else
 		retval (0) = y;
 	    }
 	  else
 	    {
 	      ColumnVector si = args(3).vector_value ();
 
 	      if (! error_state)
 		{
 		  ColumnVector y (filter (b, a, x, si));
 
 		  if (si_is_vector)
-		    retval (1) = tree_constant (si, (args(3).columns () == 1));
+		    retval (1) = octave_value (si, (args(3).columns () == 1));
 		  else
 		    retval (1) = si;
 
 		  if (x_is_vector)
-		    retval (0) = tree_constant (y, (args(2).columns () == 1));
+		    retval (0) = octave_value (y, (args(2).columns () == 1));
 		  else
 		    retval (0) = y;
 		}
 	      else
 		error (errmsg);
 	    }
 	}
       else
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -25,77 +25,77 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 
-static Octave_object
+static octave_value_list
 find_to_fortran_idx (const ColumnVector i_idx, const ColumnVector j_idx,
-		     const tree_constant& val, int nr, int nargout)
+		     const octave_value& val, int nr, int nargout)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   switch (nargout)
     {
     case 0:
     case 1:
       {
 	int count = i_idx.length ();
 	ColumnVector tmp (count);
 	for (int i = 0; i < count; i++)
 	  tmp (i) = nr * (j_idx (i) - 1.0) + i_idx (i);
 
 	// If the original argument was a row vector, force a row
 	// vector of indices to be returned.
 
-	retval(0) = tree_constant (tmp, (nr != 1));
+	retval(0) = octave_value (tmp, (nr != 1));
       }
       break;
 
     case 3:
       retval(2) = val;
       // Fall through!
 
     case 2:
-      retval(1) = tree_constant (j_idx, 1);
-      retval(0) = tree_constant (i_idx, 1);
+      retval(1) = octave_value (j_idx, 1);
+      retval(0) = octave_value (i_idx, 1);
 
       // If you want this to work more like Matlab, use
       //
-      //    retval(0) = tree_constant (i_idx, (nr != 1));
+      //    retval(0) = octave_value (i_idx, (nr != 1));
       //
       // instead of the previous statement.
 
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
-static Octave_object
+static octave_value_list
 find_nonzero_elem_idx (const Matrix& m, int nargout)
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
 
   int i, j;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
       if (m.elem (i, j) != 0.0)
 	count++;
 
-  Octave_object retval (((nargout == 0) ? 1 : nargout), Matrix ());
+  octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
   if (count == 0)
     return retval;
 
   ColumnVector i_idx (count);
   ColumnVector j_idx (count);
   ColumnVector v (count);
 
@@ -108,34 +108,34 @@ find_nonzero_elem_idx (const Matrix& m, 
 	  {
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = d;
 	    count++;
 	  }
       }
 
-  tree_constant tmp (v, 1);
+  octave_value tmp (v, 1);
   return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, nargout);
 }
 
-static Octave_object
+static octave_value_list
 find_nonzero_elem_idx (const ComplexMatrix& m, int nargout)
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
 
   int i, j;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
       if (m.elem (i, j) != 0.0)
 	count++;
 
-  Octave_object retval (((nargout == 0) ? 1 : nargout), Matrix ());
+  octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
   if (count == 0)
     return retval;
 
   ColumnVector i_idx (count);
   ColumnVector j_idx (count);
   ComplexColumnVector v (count);
 
@@ -148,34 +148,34 @@ find_nonzero_elem_idx (const ComplexMatr
 	  {
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = c;
 	    count++;
 	  }
       }
 
-  tree_constant tmp (v, 1);
+  octave_value tmp (v, 1);
   return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, nargout);
 }
 
 DEFUN_DLD_BUILTIN (find, args, nargout,
   "find (X) or [I, J, V] = find (X): Return indices of nonzero elements")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
       print_usage ("find");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	retval = find_nonzero_elem_idx (m, nargout);
     }
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -80,37 +80,37 @@ hybrd_info_to_fsolve_info (int info)
 
 ColumnVector
 fsolve_user_function (const ColumnVector& x)
 {
   ColumnVector retval;
 
   int n = x.capacity ();
 
-  Octave_object args;
+  octave_value_list args;
   args.resize (1);
 
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
-      tree_constant vars (m);
+      octave_value vars (m);
       args(0) = vars;
     }
   else
     {
       double d = x.elem (0);
-      tree_constant vars (d);
+      octave_value vars (d);
       args(0) = vars;
     }
 
   if (fsolve_fcn)
     {
-      Octave_object tmp = fsolve_fcn->eval (0, 1, args);
+      octave_value_list tmp = fsolve_fcn->eval (0, 1, args);
       if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
 	  retval = tmp(0).vector_value ();
 
 	  if (error_state || retval.length () <= 0)
 	    gripe_user_supplied_eval ("fsolve");
 	}
       else
@@ -127,17 +127,17 @@ DEFUN_DLD_BUILTIN (fsolve, args, nargout
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the vector of function values.  It must have the form\n\
 \n\
   y = f (x)
 \n\
 where y and x are vectors.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 3)
     {
       print_usage ("fsolve");
       return retval;
     }
@@ -255,20 +255,20 @@ set_fsolve_option (const string& keyword
 	  return;
 	}
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword.c_str ());
 }
 
-static Octave_object
+static octave_value_list
 show_fsolve_option (const string& keyword)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   NLEQN_OPTIONS *list = fsolve_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -283,17 +283,17 @@ show_fsolve_option (const string& keywor
 }
 
 DEFUN_DLD_BUILTIN (fsolve_options, args, ,
   "fsolve_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for fsolve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       print_fsolve_option_list ();
       return retval;
     }
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -75,17 +75,17 @@ Handle all of the following:
   4. fsqp (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
   5. fsqp (x, phi, lb, ub,              nllb, g, nlub)
   6. fsqp (x, phi,         llb, c, lub, nllb, g, nlub)
   7. fsqp (x, phi,         llb, c, lub)
   8. fsqp (x, phi,                      nllb, g, nlub)
 
 */
 
-  Octave_object retval;
+  octave_value_list retval;
 
   error ("fsqp: not implemented yet");
 
   return retval;
 }
 
 #if defined (FSQP_MISSING)
 DEFUN_DLD_BUILTIN (fsqp_options, , ,
@@ -95,17 +95,17 @@ libcruft/fsqp/README.MISSING in the sour
 #else
 DEFUN_DLD_BUILTIN (fsqp_options, , ,
   "fsqp_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for fsqp.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   error ("fsqp_options: not implemented yet");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -34,17 +34,17 @@ Software Foundation, 59 Temple Place - S
 DEFUN_DLD_BUILTIN (givens, args, nargout,
   "G = givens (X, Y)\n\
 \n\
 compute orthogonal matrix G = [c s; -conj (s) c]\n\
 such that G [x; y] = [*; 0]  (x, y scalars)\n\
 \n\
 [c, s] = givens (x, y) returns the (c, s) values themselves.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
     {
       print_usage ("givens");
       return retval;
     }
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -118,29 +118,29 @@ gripe_unrecognized_data_fmt (const char 
 
 void
 gripe_data_conversion (const char *from, const char *to)
 {
   error ("unable to convert from %s to %s format", from, to);
 }
 
 void
-gripe_wrong_type_arg (const char *name, const tree_constant& tc)
+gripe_wrong_type_arg (const char *name, const octave_value& tc)
 {
   error ("%s: wrong type argument `%s'", name, tc.type_as_string ());
 }
 
 void
-gripe_wrong_type_arg_for_unary_op (const tree_constant& op)
+gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
   error ("invalid operand `%s' for unary operator", op.type_as_string ());
 }
 
 void
-gripe_wrong_type_arg_for_binary_op (const tree_constant& op)
+gripe_wrong_type_arg_for_binary_op (const octave_value& op)
 {
   error ("invalid operand `%s' for binary operator", op.type_as_string ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -18,36 +18,36 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_gripes_h)
 #define octave_gripes_h 1
 
-class tree_constant;
+class octave_value;
 
 extern void gripe_not_supported (void);
 extern void gripe_string_invalid (void);
 extern void gripe_range_invalid (void);
 extern void gripe_nonconformant (void);
 extern void gripe_nonconformant (int r1, int c1, int r2, int c2);
 extern void gripe_empty_arg (const char *name, int is_error);
 extern void gripe_square_matrix_required (const char *name);
 extern void gripe_user_supplied_eval (const char *name);
 extern void gripe_user_returned_invalid (const char *name);
 extern void gripe_invalid_conversion (const char *from, const char *to);
 extern void gripe_invalid_value_specified (const char *name);
 extern void gripe_2_or_3_dim_plot (void);
 extern void gripe_unrecognized_float_fmt (void);
 extern void gripe_unrecognized_data_fmt (const char *warn_for);
 extern void gripe_data_conversion (const char *from, const char *to);
-extern void gripe_wrong_type_arg (const char *name, const tree_constant& tc);
-extern void gripe_wrong_type_arg_for_unary_op (const tree_constant& op);
-extern void gripe_wrong_type_arg_for_binary_op (const tree_constant& op);
+extern void gripe_wrong_type_arg (const char *name, const octave_value& tc);
+extern void gripe_wrong_type_arg_for_unary_op (const octave_value& op);
+extern void gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -672,17 +672,17 @@ DEFUN_TEXT (help, args, ,
 print cryptic yet witty messages")
 #else
 DEFUN_TEXT (help, args, ,
   "help [topic ...]\n\
 \n\
 print cryptic yet witty messages")
 #endif
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("help");
 
   if (error_state)
     return retval;
 
@@ -705,17 +705,17 @@ print cryptic yet witty messages")
   return retval;
 }
 
 DEFUN_TEXT (type, args, nargout,
   "type NAME ...]\n\
 \n\
 display the definition of each NAME that refers to a function")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   begin_unwind_frame ("Ftype");
 
   unwind_protect_str (user_pref.ps4);
   user_pref.ps4 = "";
 
   int argc = args.length () + 1;
 
@@ -777,24 +777,24 @@ display the definition of each NAME that
 		output_buf << argv[i] << " is a builtin function\n";
 	      else if (sym_rec->is_user_variable ()
 		       || sym_rec->is_builtin_variable ())
 		{
 		  tree_fvc *defn = sym_rec->def ();
 
 		  assert (defn && defn->is_constant ());
 
-		  tree_constant *tmp = (tree_constant *) defn;
+		  octave_value *tmp = (octave_value *) defn;
 
 		  int var_ok = 1;
 		  if (tmp && tmp->is_map ())
 		    {
 		      if (! elts.empty ())
 			{
-			  tree_constant ult =
+			  octave_value ult =
 			    tmp->lookup_map_element (elts, 0, 1);
 
 			  if (! ult.is_defined ())
 			    var_ok = 0;			    
 			}
 		    }
 
 		  if (nargout == 0 && ! quiet)
@@ -852,17 +852,17 @@ display the definition of each NAME that
 }
 
 DEFUN_TEXT (which, args, nargout,
   "which NAME ...\n\
 \n\
 display the type of each NAME.  If NAME is defined from an function\n\
 file, print the full name of the file.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("which");
 
   if (error_state)
     return retval;
 
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -33,37 +33,37 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (hess, args, nargout,
   "[P, H] = hess (A) or H = hess (A): Hessenberg decomposition")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
       print_usage ("hess");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("hess", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Octave_object (2, Matrix ());
+    return octave_value_list (2, Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("hess");
       return retval;
     }
 
   if (arg.is_real_type ())
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -33,27 +33,27 @@ Software Foundation, 59 Temple Place - S
 #include "user-prefs.h"
 #include "utils.h"
 
 // This function should be merged with Ffft.
 
 DEFUN_DLD_BUILTIN (ifft, args, ,
   "ifft (X [, N]): inverse fast fourier transform of a vector")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("ifft");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
     
   int n_points = arg.rows ();
   if (n_points == 1)
     n_points = arg.columns ();
 
   if (nargin == 2)
     {
       double dval = args(1).double_value ();
diff --git a/src/ifft2.cc b/src/ifft2.cc
--- a/src/ifft2.cc
+++ b/src/ifft2.cc
@@ -35,27 +35,27 @@ Software Foundation, 59 Temple Place - S
 
 // This function should be merged with Ffft2.
 
 DEFUN_DLD_BUILTIN (ifft2, args, ,
   "ifft2 (X [, N] [, M])\n\
 \n\
 two dimensional inverse fast fourier transform of a vector") 
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("ifft2");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int n_rows = arg.rows ();
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
 	error ("fft2: NaN is invalid as N_ROWS");
       else
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -656,27 +656,27 @@ generate_struct_completions (const char 
   symbol_record *sr = curr_sym_tab->lookup (id, 0, 0);
   if (! sr)
     sr = global_sym_tab->lookup (id, 0, 0);
 
   if (sr && sr->is_defined ())
     {
       tree_fvc *tmp_fvc = sr->def ();
 
-      tree_constant *def = 0;
+      octave_value *def = 0;
       if (tmp_fvc->is_constant ())
-	def = (tree_constant *) tmp_fvc;
+	def = (octave_value *) tmp_fvc;
 
       if (def && def->is_map ())
 	{
 	  string_vector tmp_names;
 
 	  if (elts && *elts)
 	    {
-	      tree_constant ult = def->lookup_map_element (elts, 0, 1);
+	      octave_value ult = def->lookup_map_element (elts, 0, 1);
 
 	      if (ult.is_map ())
 		{
 		  Octave_map m = ult.map_value ();
 		  tmp_names = m.make_name_list ();
 		}
 	    }
 	  else
@@ -751,25 +751,25 @@ looks_like_struct (const char *nm)
   symbol_record *sr = curr_sym_tab->lookup (id, 0, 0);
   if (! sr)
     sr = global_sym_tab->lookup (id, 0, 0);
 
   if (sr && sr->is_defined ())
     {
       tree_fvc *tmp_fvc = sr->def ();
 
-      tree_constant *def = 0;
+      octave_value *def = 0;
       if (tmp_fvc->is_constant ())
-	def = (tree_constant *) tmp_fvc;
+	def = (octave_value *) tmp_fvc;
 
       if (def && def->is_map ())
 	{
 	  if (elts && *elts)
 	    {
-	      tree_constant ult = def->lookup_map_element (elts, 0, 1);
+	      octave_value ult = def->lookup_map_element (elts, 0, 1);
 
 	      if (ult.is_map ())
 		retval = 1;
 	    }
 	  else
 	    retval = 1;
 	}
     }
@@ -998,20 +998,20 @@ match_sans_spaces (const char *standard,
   delete [] tmp;
 
   return retval;
 
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
-static Octave_object
-get_user_input (const Octave_object& args, int debug = 0)
+static octave_value_list
+get_user_input (const octave_value_list& args, int debug = 0)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   int read_as_string = 0;
 
   if (nargin == 2)
     read_as_string++;
 
@@ -1087,34 +1087,34 @@ get_user_input (const Octave_object& arg
 }
 
 DEFUN (input, args, ,
   "input (PROMPT [, S])\n\
 \n\
 Prompt user for input.  If the second argument is present, return
 value as a string.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     retval = get_user_input (args);
   else
     print_usage ("input");
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
   "keyboard (PROMPT)\n\
 \n\
 maybe help in debugging function files")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     retval = get_user_input (args, 1);
   else
     print_usage ("keyboard");
 
@@ -1127,17 +1127,17 @@ DEFUN_TEXT(echo, args, ,
   echo [on|off]         -- enable or disable echoing of commands as\n\
                            they are executed in script files\n\
 \n\
   echo [on all|off all] -- enable or disable echoing of commands as they\n\
                            are executed in script files and functions\n\
 \n\
 Without any arguments, toggle the current echo state.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("echo");
 
   if (error_state)
     return retval;
 
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -30,27 +30,27 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (inv, args, ,
   "inv (X): inverse of a square matrix")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("inv");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -74,17 +74,17 @@ enum load_save_format
 
 // Install a variable with name NAME and the value specified TC in the
 // symbol table.  If FORCE is nonzero, replace any existing definition
 // for NAME.  If GLOBAL is nonzero, make the variable global.
 //
 // Assumes TC is defined.
 
 static void
-install_loaded_variable (int force, char *name, const tree_constant& tc,
+install_loaded_variable (int force, char *name, const octave_value& tc,
 			 int global, char *doc)
 {
   // Is there already a symbol by this name?  If so, what is it?
 
   symbol_record *lsr = curr_sym_tab->lookup (name, 0, 0);
 
   int is_undefined = 1;
   int is_variable = 0;
@@ -192,17 +192,17 @@ install_loaded_variable (int force, char
 	    }
 	}
       else
 	error ("load: unable to load data for unknown symbol type");
     }
 
   if (sr)
     {
-      tree_constant *tmp_tc = new tree_constant (tc);
+      octave_value *tmp_tc = new octave_value (tc);
       sr->define (tmp_tc);
       if (doc)
 	sr->document (doc);
       return;
     }
   else
     error ("load: unable to load variable `%s'", name);
 
@@ -430,17 +430,17 @@ extract_keyword (istream& is, char *keyw
 //  # length: 5
 //  array
 //
 // XXX FIXME XXX -- this format is fairly rigid, and doesn't allow for
 // arbitrary comments, etc.  Someone should fix that.
 
 static char *
 read_ascii_data (istream& is, const string& filename, int& global,
-		 tree_constant& tc)
+		 octave_value& tc)
 {
   // Read name for this entry or break on EOF.
 
   char *name = extract_keyword (is, "name");
 
   if (! name)
     return 0;
 
@@ -694,17 +694,17 @@ read_ascii_data (istream& is, const stri
 //         length         int                 4
 //         data           string         length
 //
 // FILENAME is used for error messages.
 
 static char *
 read_binary_data (istream& is, int swap, floating_point_format fmt,
 		  const string& filename, int& global,
-		  tree_constant& tc, char *&doc)
+		  octave_value& tc, char *&doc)
 {
   char tmp = 0;
 
   FOUR_BYTE_INT name_len = 0, doc_len = 0;
   char *name = 0;
 
   doc = 0;
 
@@ -1052,17 +1052,17 @@ get_floating_point_format (int mach)
 // the features of that format are supported.
 //
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 static char *
 read_mat_binary_data (istream& is, const string& filename,
-		      tree_constant& tc)
+		      octave_value& tc)
 {
   // These are initialized here instead of closer to where they are
   // first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
   Matrix re;
   floating_point_format flt_fmt = OCTAVE_UNKNOWN_FLT_FMT;
   char *name = 0;
@@ -1251,30 +1251,30 @@ get_file_format (const string& fname, co
 
   if (retval == LS_UNKNOWN)
     error ("load: unable to determine file format for `%s'",
 	   orig_fname.c_str ());
 
   return retval;
 }
 
-static Octave_object
+static octave_value_list
 do_load (istream& stream, const string& orig_fname, int force,
 	 load_save_format format, floating_point_format flt_fmt,
 	 int list_only, int swap, int verbose, const string_vector& argv,
 	 int argv_idx, int argc, int nargout)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   ostrstream output_buf;
   int count = 0;
   for (;;)
     {
       int global = 0;
-      tree_constant tc;
+      octave_value tc;
 
       char *name = 0;
       char *doc = 0;
 
       switch (format)
 	{
 	case LS_ASCII:
 	  name = read_ascii_data (stream, orig_fname, global, tc);
@@ -1371,17 +1371,17 @@ Load variables from a file.\n\
 \n\
 If no argument is supplied to select a format, load tries to read the
 named file as an Octave binary, then as a .mat file, and then as an
 Octave text file.\n\
 \n\
 If the option -force is given, variables with the same names as those
 found in the file will be replaced with the values read from the file.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("load");
 
   if (error_state)
     return retval;
 
@@ -1564,17 +1564,17 @@ get_save_type (double max_val, double mi
   return st;
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
 
 static int
-save_binary_data (ostream& os, const tree_constant& tc,
+save_binary_data (ostream& os, const octave_value& tc,
 		  const string& name, const string& doc,
 		  int mark_as_global, int save_as_floats) 
 {
   int fail = 0;
 
   FOUR_BYTE_INT name_len = name.length ();
 
   os.write (&name_len, 4);
@@ -1706,17 +1706,17 @@ save_binary_data (ostream& os, const tre
 
   return (os && ! fail);
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS 
 // in the MatLab binary format.
 
 static int
-save_mat_binary_data (ostream& os, const tree_constant& tc,
+save_mat_binary_data (ostream& os, const octave_value& tc,
 		      const string& name) 
 {
   int fail = 0;
 
   FOUR_BYTE_INT mopt = 0;
 
   mopt += tc.is_string () ? 1 : 0;
   mopt += 1000 * get_floating_point_format (native_float_format);
@@ -1884,17 +1884,17 @@ strip_infnan (const ComplexMatrix& m)
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
 // XXX FIXME XXX -- should probably write the help string here too.
 
 int
-save_ascii_data (ostream& os, const tree_constant& tc,
+save_ascii_data (ostream& os, const octave_value& tc,
 		 const string& name, int strip_nan_and_inf,
 		 int mark_as_global, int precision) 
 {
   int success = 1;
 
   if (! precision)
     precision = user_pref.save_precision;
 
@@ -2023,17 +2023,17 @@ do_save (ostream& os, symbol_record *sr,
     {
       error ("save: can only save variables, not functions");
       return;
     }
 
   string name = sr->name ();
   string help = sr->help ();
   int global = sr->is_linked_to_global ();
-  tree_constant tc = *((tree_constant *) sr->def ());
+  octave_value tc = *((octave_value *) sr->def ());
 
   if (tc.is_undefined ())
     return;
 
   switch (fmt)
     {
     case LS_ASCII:
       save_ascii_data (os, tc, name, 0, global);
@@ -2178,17 +2178,17 @@ save_user_variables (void)
 }
 
 DEFUN_TEXT (save, args, ,
   "save [-ascii] [-binary] [-float-binary] [-mat-binary] \n\
      [-save-builtins] file [pattern ...]\n\
 \n\
 save variables in a file")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("save");
 
   if (error_state)
     return retval;
 
@@ -2241,17 +2241,17 @@ save variables in a file")
       return retval;
     }
 
   if (argv[i] == "-")
     {
       i++;
 
       // XXX FIXME XXX -- should things intended for the screen end up
-      // in a tree_constant (string)?
+      // in a octave_value (string)?
 
       ostrstream buf;
 
       save_vars (argv, i, argc, buf, save_builtins, format,
 		 save_as_floats);
 
       maybe_page_output (buf);
     }
@@ -2292,17 +2292,17 @@ save variables in a file")
 
 // Maybe this should be a static function in tree-plot.cc?
 
 // If TC is matrix, save it on stream OS in a format useful for
 // making a 3-dimensional plot with gnuplot.  If PARAMETRIC is
 // nonzero, assume a parametric 3-dimensional plot will be generated.
 
 int
-save_three_d (ostream& os, const tree_constant& tc, int parametric)
+save_three_d (ostream& os, const octave_value& tc, int parametric)
 {
   int fail = 0;
 
   int nr = tc.rows ();
   int nc = tc.columns ();
 
   if (tc.is_real_matrix ())
     {
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -20,26 +20,26 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_load_save_h)
 #define octave_load_save_h 1
 
 class ostream;
 
-class tree_constant;
+class octave_value;
 
 #include <string>
 
-extern int save_ascii_data (ostream& os, const tree_constant& t,
+extern int save_ascii_data (ostream& os, const octave_value& t,
 			    const string& name = string (),
 			    int strip_nan_and_inf = 0,
 			    int mark_as_global = 0, int precision = 0);
 
-extern int save_three_d (ostream& os, const tree_constant& t,
+extern int save_three_d (ostream& os, const octave_value& t,
 			 int parametric = 0);
 
 extern void save_user_variables (void);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/log.cc b/src/log.cc
--- a/src/log.cc
+++ b/src/log.cc
@@ -35,27 +35,27 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 
 // XXX FIXME XXX -- the next two functions should really be just
 // one...
 
 DEFUN_DLD_BUILTIN (logm, args, ,
   "logm (X): matrix logarithm")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("logm");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("logm", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return Matrix ();
 
@@ -147,27 +147,27 @@ DEFUN_DLD_BUILTIN (logm, args, ,
     }
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN (sqrtm, args, ,
  "sqrtm (X): matrix sqrt")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("sqrtm");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("sqrtm", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return Matrix ();
 
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "oct-obj.h"
 
 DEFUN_DLD_BUILTIN (lp_solve, , ,
   "lp_solve (): solve linear programs using lp_solve.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   // Force a bad value of inform, and empty matrices for x and phi.
 
   Matrix m;
   retval(2) = -1.0;
   retval(1) = m;
   retval(0) = m;
 
@@ -49,17 +49,17 @@ DEFUN_DLD_BUILTIN (lp_solve, , ,
 }
 
 DEFUN_DLD_BUILTIN (lp_solve_options, , ,
   "lp_solve_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for lp_solve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   error ("lp_solve_options: not implemented yet");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -46,37 +46,37 @@ static LSODE_options lsode_opts;
 
 ColumnVector
 lsode_user_function (const ColumnVector& x, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
-  Octave_object args;
+  octave_value_list args;
   args(1) = t;
 
   if (nstates > 1)
     {
       Matrix m (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	m (i, 0) = x.elem (i);
-      tree_constant state (m);
+      octave_value state (m);
       args(0) = state;
     }
   else
     {
       double d = x.elem (0);
-      tree_constant state (d);
+      octave_value state (d);
       args(0) = state;
     }
 
   if (lsode_fcn)
     {
-      Octave_object tmp = lsode_fcn->eval (0, 1, args);
+      octave_value_list tmp = lsode_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("lsode");
 	  return retval;
 	}
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
@@ -98,17 +98,17 @@ DEFUN_DLD_BUILTIN (lsode, args, nargout,
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of right hand sides.  It must have the form\n\
 \n\
   xdot = f (x, t)\n\
 \n\
 where xdot and x are vectors and t is a scalar.\n")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 4 || nargout > 1)
     {
       print_usage ("lsode");
       return retval;
     }
@@ -270,20 +270,20 @@ set_lsode_option (const string& keyword,
 	  return;
 	}
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword.c_str ());
 }
 
-static Octave_object
+static octave_value_list
 show_lsode_option (const string& keyword)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   LSODE_OPTIONS *list = lsode_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -298,17 +298,17 @@ show_lsode_option (const string& keyword
 }
 
 DEFUN_DLD_BUILTIN (lsode_options, args, ,
   "lsode_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for lsode.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       print_lsode_option_list ();
       return retval;
     }
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -33,37 +33,37 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (lu, args, nargout,
   "[L, U, P] = lu (A): LU factorization")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
       print_usage ("lu");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("lu", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Octave_object (3, Matrix ());
+    return octave_value_list (3, Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("lu");
       return retval;
     }
 
   if (arg.is_real_type ())
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -359,28 +359,28 @@ max (const ComplexMatrix& a, const Compl
     }
 
   return result;
 }
 
 DEFUN_DLD_BUILTIN (min, args, nargout,
   "min (X): minimum value(s) of a vector (matrix)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("min");
       return retval;
     }
 
-  tree_constant arg1;
-  tree_constant arg2;
+  octave_value arg1;
+  octave_value arg2;
 
   switch (nargin)
     {
     case 2:
       arg2 = args(1);
       // Fall through...
 
     case 1:
@@ -406,29 +406,29 @@ DEFUN_DLD_BUILTIN (min, args, nargout,
 	{
 	  Matrix m = arg1.matrix_value ();
 
 	  if (! error_state)
 	    {
 	      if (m.rows () == 1)
 		retval(0) = m.row_min ();
 	      else
-		retval(0) = tree_constant (m.column_min (), 0);
+		retval(0) = octave_value (m.column_min (), 0);
 	    }
 	}
       else if (arg1.is_complex_type ())
 	{
 	  ComplexMatrix m = arg1.complex_matrix_value ();
 
 	  if (! error_state)
 	    {
 	      if (m.rows () == 1)
 		retval(0) = m.row_min ();
 	      else
-		retval(0) = tree_constant (m.column_min (), 0);
+		retval(0) = octave_value (m.column_min (), 0);
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("min", arg1);
 	  return retval;
 	}
     }
@@ -452,36 +452,36 @@ DEFUN_DLD_BUILTIN (min, args, nargout,
 	    {
 	      if (m.rows () == 1)
 		{
 		  retval(1) = m.row_min_loc ();
 		  retval(0) = m.row_min ();
 		}
 	      else
 		{
-		  retval(1) = tree_constant (m.column_min_loc (), 0);
-		  retval(0) = tree_constant (m.column_min (), 0);
+		  retval(1) = octave_value (m.column_min_loc (), 0);
+		  retval(0) = octave_value (m.column_min (), 0);
 		}
 	    }
 	}
       else if (arg1.is_complex_type ())
 	{
 	  ComplexMatrix m = arg1.complex_matrix_value ();
 
 	  if (! error_state)
 	    {
 	      if (m.rows () == 1)
 		{
 		  retval(1) = m.row_min_loc ();
 		  retval(0) = m.row_min ();
 		}
 	      else
 		{
-		  retval(1) = tree_constant (m.column_min_loc (), 0);
-		  retval(0) = tree_constant (m.column_min (), 0);
+		  retval(1) = octave_value (m.column_min_loc (), 0);
+		  retval(0) = octave_value (m.column_min (), 0);
 		}
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("min", arg1);
 	  return retval;
 	}
@@ -587,28 +587,28 @@ DEFUN_DLD_BUILTIN (min, args, nargout,
     panic_impossible ();
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN (max, args, nargout,
   "max (X): maximum value(s) of a vector (matrix)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("max");
       return retval;
     }
 
-  tree_constant arg1;
-  tree_constant arg2;
+  octave_value arg1;
+  octave_value arg2;
 
   switch (nargin)
     {
     case 2:
       arg2 = args(1);
       // Fall through...
 
     case 1:
@@ -634,29 +634,29 @@ DEFUN_DLD_BUILTIN (max, args, nargout,
 	{
 	  Matrix m = arg1.matrix_value ();
 
 	  if (! error_state)
 	    {
 	      if (m.rows () == 1)
 		retval(0) = m.row_max ();
 	      else
-		retval(0) = tree_constant (m.column_max (), 0);
+		retval(0) = octave_value (m.column_max (), 0);
 	    }
 	}
       else if (arg1.is_complex_type ())
 	{
 	  ComplexMatrix m = arg1.complex_matrix_value ();
 
 	  if (! error_state)
 	    {
 	      if (m.rows () == 1)
 		retval(0) = m.row_max ();
 	      else
-		retval(0) = tree_constant (m.column_max (), 0);
+		retval(0) = octave_value (m.column_max (), 0);
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("max", arg1);
 	  return retval;
 	}
     }
@@ -680,36 +680,36 @@ DEFUN_DLD_BUILTIN (max, args, nargout,
 	    {
 	      if (m.rows () == 1)
 		{
 		  retval(1) = m.row_max_loc ();
 		  retval(0) = m.row_max ();
 		}
 	      else
 		{
-		  retval(1) = tree_constant (m.column_max_loc (), 0);
-		  retval(0) = tree_constant (m.column_max (), 0);
+		  retval(1) = octave_value (m.column_max_loc (), 0);
+		  retval(0) = octave_value (m.column_max (), 0);
 		}
 	    }
 	}
       else if (arg1.is_complex_type ())
 	{
 	  ComplexMatrix m = arg1.complex_matrix_value ();
 
 	  if (! error_state)
 	    {
 	      if (m.rows () == 1)
 		{
 		  retval(1) = m.row_max_loc ();
 		  retval(0) = m.row_max ();
 		}
 	      else
 		{
-		  retval(1) = tree_constant (m.column_max_loc (), 0);
-		  retval(0) = tree_constant (m.column_max (), 0);
+		  retval(1) = octave_value (m.column_max_loc (), 0);
+		  retval(0) = octave_value (m.column_max (), 0);
 		}
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("max", arg1);
 	  return retval;
 	}
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -48,40 +48,40 @@ static tree_fvc *npsol_constraints;
 
 static NPSOL_options npsol_opts;
 
 double
 npsol_objective_function (const ColumnVector& x)
 {
   int n = x.capacity ();
 
-  tree_constant decision_vars;
+  octave_value decision_vars;
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
       decision_vars = m;
     }
   else
     {
       double d = x.elem (0);
       decision_vars = d;
     }
 
-  Octave_object args;
+  octave_value_list args;
   args(0) = decision_vars;
 
   static double retval;
   retval = 0.0;
 
-  tree_constant objective_value;
+  octave_value objective_value;
   if (npsol_objective)
     {
-      Octave_object tmp = npsol_objective->eval (0, 1, args);
+      octave_value_list tmp = npsol_objective->eval (0, 1, args);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating objective function");
 	  npsol_objective_error = 1; // XXX FIXME XXX
 	  return retval;
 	}
 
@@ -121,36 +121,36 @@ npsol_objective_function (const ColumnVe
 
 ColumnVector
 npsol_constraint_function (const ColumnVector& x)
 {
   ColumnVector retval;
 
   int n = x.capacity ();
 
-  tree_constant decision_vars;
+  octave_value decision_vars;
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
       decision_vars = m;
     }
   else
     {
       double d = x.elem (0);
       decision_vars = d;
     }
 
-  Octave_object args;
+  octave_value_list args;
   args(0) = decision_vars;
 
   if (npsol_constraints)
     {
-      Octave_object tmp = npsol_constraints->eval (0, 1, args);
+      octave_value_list tmp = npsol_constraints->eval (0, 1, args);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating constraints");
 	  return retval;
 	}
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
@@ -267,17 +267,17 @@ Handle all of the following:
   4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
   5. npsol (x, phi, lb, ub,              nllb, g, nlub)
   6. npsol (x, phi,         llb, c, lub, nllb, g, nlub)
   7. npsol (x, phi,         llb, c, lub)
   8. npsol (x, phi,                      nllb, g, nlub)
 
 */
 
-  Octave_object retval;
+  octave_value_list retval;
 
 #if defined (NPSOL_MISSING)
 
   // Force a bad value of inform, and empty matrices for x, phi, and
   // lambda.
 
   retval.resize (4, Matrix ());
 
@@ -739,20 +739,20 @@ set_npsol_option (const string& keyword,
 	  return;
 	}
       list++;
     }
 
   warning ("npsol_options: no match for `%s'", keyword.c_str ());
 }
 
-static Octave_object
+static octave_value_list
 show_npsol_option (const string& keyword)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   NPSOL_OPTIONS *list = npsol_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -779,17 +779,17 @@ libcruft/npsol/README.MISSING in the sou
 #else
 DEFUN_DLD_BUILTIN (npsol_options, args, ,
   "npsol_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for npsol.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
-  Octave_object retval;
+  octave_value_list retval;
 
 #if defined (NPSOL_MISSING)
 
   print_usage ("npsol_options");
 
 #else
 
   int nargin = args.length ();
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -516,17 +516,17 @@ do_run_history (int argc, const string_v
   unlink (name.c_str ());
 }
 
 DEFUN_TEXT (edit_history, args, ,
   "edit_history [first] [last]\n\
 \n\
 edit commands from the history list")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("edit_history");
 
   if (error_state)
     return retval;
 
@@ -535,17 +535,17 @@ edit commands from the history list")
   return retval;
 }
 
 DEFUN_TEXT (history, args, ,
   "history [N] [-w file] [-r file] [-q]\n\
 \n\
 display, save, or load command history")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("history");
 
   if (error_state)
     return retval;
 
@@ -554,17 +554,17 @@ display, save, or load command history")
   return retval;
 }
 
 DEFUN_TEXT (run_history, args, ,
   "run_history [first] [last]\n\
 \n\
 run commands from the history list")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("run_history");
 
   if (error_state)
     return retval;
 
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -29,28 +29,28 @@ Software Foundation, 59 Temple Place - S
 
 #include "Map.h"
 
 #include "pt-const.h"
 
 class string_vector;
 
 class
-Octave_map : public CHMap<tree_constant>
+Octave_map : public CHMap<octave_value>
 {
  public:
-  Octave_map (void) : CHMap<tree_constant> (tree_constant ()) { }
+  Octave_map (void) : CHMap<octave_value> (octave_value ()) { }
 
-  Octave_map (const string& key, const tree_constant& value)
-    : CHMap<tree_constant> (tree_constant ())
+  Octave_map (const string& key, const octave_value& value)
+    : CHMap<octave_value> (octave_value ())
       {
-	CHMap<tree_constant>::operator [] (key) = value;
+	CHMap<octave_value>::operator [] (key) = value;
       }
 
-  Octave_map (const Octave_map& m) : CHMap<tree_constant> (m) { }
+  Octave_map (const Octave_map& m) : CHMap<octave_value> (m) { }
 
   ~Octave_map (void) { }
 
   string_vector make_name_list (void);
 };
 
 #endif
 
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -27,29 +27,29 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "error.h"
 #include "oct-obj.h"
 
 int
-Octave_object::all_strings (void) const
+octave_value_list::all_strings (void) const
 {
   int n = length ();
 
   for (int i = 0; i < n; i++)
     if (! elem(i).is_string ())
       return 0;
 
   return 1;
 }
 
 string_vector
-Octave_object::make_argv (const string& fcn_name) const
+octave_value_list::make_argv (const string& fcn_name) const
 {
   string_vector argv;
 
   if (all_strings ())
     {
       int n = length ();
       argv.resize (n+1);
       argv[0] = fcn_name;
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -33,134 +33,134 @@ Software Foundation, 59 Temple Place - S
 #include "str-vec.h"
 
 // Including this is all we need because pt-const.h gives us
 // declarations for all the data types Octave knows about.
 
 #include "pt-const.h"
 
 class
-Octave_object : public Array<tree_constant>
+octave_value_list : public Array<octave_value>
 {
 public:
 
-  Octave_object (void)
-    : Array<tree_constant> () { }
+  octave_value_list (void)
+    : Array<octave_value> () { }
 
-  Octave_object (int n, const tree_constant& val)
-    : Array<tree_constant> (n, val) { }
+  octave_value_list (int n, const octave_value& val)
+    : Array<octave_value> (n, val) { }
 
-  Octave_object (const tree_constant& tc)
-    : Array<tree_constant> (1, tc) { }
+  octave_value_list (const octave_value& tc)
+    : Array<octave_value> (1, tc) { }
 
-  Octave_object (double d)
-    : Array<tree_constant> (1, tree_constant (d)) { }
+  octave_value_list (double d)
+    : Array<octave_value> (1, octave_value (d)) { }
 
-  Octave_object (const Matrix& m)
-    : Array<tree_constant> (1, tree_constant (m)) { }
+  octave_value_list (const Matrix& m)
+    : Array<octave_value> (1, octave_value (m)) { }
 
-  Octave_object (const DiagMatrix& d)
-    : Array<tree_constant> (1, tree_constant (d)) { }
+  octave_value_list (const DiagMatrix& d)
+    : Array<octave_value> (1, octave_value (d)) { }
 
-  Octave_object (const RowVector& v, int pcv)
-    : Array<tree_constant> (1, tree_constant (v, pcv)) { }
+  octave_value_list (const RowVector& v, int pcv)
+    : Array<octave_value> (1, octave_value (v, pcv)) { }
 
-  Octave_object (const ColumnVector& v, int pcv)
-    : Array<tree_constant> (1, tree_constant (v, pcv)) { }
+  octave_value_list (const ColumnVector& v, int pcv)
+    : Array<octave_value> (1, octave_value (v, pcv)) { }
 
-  Octave_object (const Complex& c)
-    : Array<tree_constant> (1, tree_constant (c)) { }
+  octave_value_list (const Complex& c)
+    : Array<octave_value> (1, octave_value (c)) { }
 
-  Octave_object (const ComplexMatrix& m)
-    : Array<tree_constant> (1, tree_constant (m)) { }
+  octave_value_list (const ComplexMatrix& m)
+    : Array<octave_value> (1, octave_value (m)) { }
 
-  Octave_object (const ComplexDiagMatrix& d)
-    : Array<tree_constant> (1, tree_constant (d)) { }
+  octave_value_list (const ComplexDiagMatrix& d)
+    : Array<octave_value> (1, octave_value (d)) { }
 
-  Octave_object (const ComplexRowVector& v, int pcv)
-    : Array<tree_constant> (1, tree_constant (v, pcv)) { }
+  octave_value_list (const ComplexRowVector& v, int pcv)
+    : Array<octave_value> (1, octave_value (v, pcv)) { }
 
-  Octave_object (const ComplexColumnVector& v, int pcv)
-    : Array<tree_constant> (1, tree_constant (v, pcv)) { }
+  octave_value_list (const ComplexColumnVector& v, int pcv)
+    : Array<octave_value> (1, octave_value (v, pcv)) { }
 
-  Octave_object (const char *s)
-    : Array<tree_constant> (1, tree_constant (s)) { }
+  octave_value_list (const char *s)
+    : Array<octave_value> (1, octave_value (s)) { }
 
-  Octave_object (const string& s)
-    : Array<tree_constant> (1, tree_constant (s)) { }
+  octave_value_list (const string& s)
+    : Array<octave_value> (1, octave_value (s)) { }
 
-  Octave_object (const string_vector& s)
-    : Array<tree_constant> (1, tree_constant (s)) { }
+  octave_value_list (const string_vector& s)
+    : Array<octave_value> (1, octave_value (s)) { }
 
-  Octave_object (double base, double limit, double inc)
-    : Array<tree_constant> (1, tree_constant (base, limit, inc)) { }
+  octave_value_list (double base, double limit, double inc)
+    : Array<octave_value> (1, octave_value (base, limit, inc)) { }
 
-  Octave_object (const Range& r)
-    : Array<tree_constant> (1, tree_constant (r)) { }
+  octave_value_list (const Range& r)
+    : Array<octave_value> (1, octave_value (r)) { }
 
-  Octave_object (const Octave_object& obj)
-    : Array<tree_constant> (obj) { }
+  octave_value_list (const octave_value_list& obj)
+    : Array<octave_value> (obj) { }
 
-  Octave_object& operator = (const Octave_object& obj)
+  octave_value_list& operator = (const octave_value_list& obj)
     {
       if (this != &obj)
-	Array<tree_constant>::operator = (obj);
+	Array<octave_value>::operator = (obj);
 
       return *this;
     }
 
 // Assignment will resize on range errors.
 
-  tree_constant& operator () (int n) { return elem (n); }
+  octave_value& operator () (int n) { return elem (n); }
 
-  tree_constant operator () (int n) const { return elem (n); }
+  octave_value operator () (int n) const { return elem (n); }
 
   int all_strings (void) const;
 
   string_vector make_argv (const string&) const;
 
 private:
 
 // This constructor is private with no definition to keep statements
 // like
 //
-//   Octave_object foo = 5;
-//   Octave_object foo = 5.0;
+//   octave_value_list foo = 5;
+//   octave_value_list foo = 5.0;
 //
 // from doing different things.  Instead, you have to use the
 // constructor
 //
-//   Octave_object (n, val);
+//   octave_value_list (n, val);
 //
-// and supply a default value to create a vector-valued Octave_object.
+// and supply a default value to create a vector-valued octave_value_list.
 
-  Octave_object (int n);
+  octave_value_list (int n);
 
   void maybe_resize (int n)
     {
       if (n >= length ())
 	resize (n + 1, Matrix ());
     }
 
-  tree_constant& elem (int n)
+  octave_value& elem (int n)
     {
       maybe_resize (n);
-      return Array<tree_constant>::elem (n);
+      return Array<octave_value>::elem (n);
     }
 
-  tree_constant& checkelem (int n);
+  octave_value& checkelem (int n);
 
-  tree_constant& xelem (int n);
+  octave_value& xelem (int n);
 
-  tree_constant elem (int n) const
+  octave_value elem (int n) const
     {
-      return Array<tree_constant>::operator () (n);
+      return Array<octave_value>::operator () (n);
     }
 
-  tree_constant checkelem (int n) const;
+  octave_value checkelem (int n) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -199,17 +199,17 @@ maybe_write_to_diary_file (const string&
 }
 
 DEFUN_TEXT (diary, args, ,
   "diary [on|off]\n\
 diary [file]\n\
 \n\
 redirect all input and screen output to a file.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("diary");
 
   if (error_state)
     return retval;
 
@@ -251,17 +251,17 @@ redirect all input and screen output to 
 }
 
 DEFUN_TEXT (more, args, ,
   "more on\n\
 more off\n\
 \n\
 Turn output pagination on or off.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("more");
 
   if (error_state)
     return retval;
 
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -92,17 +92,17 @@ static void maybe_warn_assign_as_truth_v
 // Create a plot command.
 static tree_plot_command *make_plot_command
 	 (token *tok, plot_limits *range, subplot_list *list);
 
 // Finish building a range.
 static tree_expression *finish_colon_expression (tree_colon_expression *e);
 
 // Build a constant.
-static tree_constant *make_constant (int op, token *tok_val);
+static octave_value *make_constant (int op, token *tok_val);
 
 // Build a binary expression.
 static tree_expression *make_binary_op
 	 (int op, tree_expression *op1,	token *tok_val, tree_expression *op2);
 
 // Build a prefix expression.
 static tree_expression *make_prefix_op
 	 (int op, tree_identifier *op1, token *tok_val);
@@ -216,17 +216,17 @@ static void maybe_warn_missing_semi (tre
 // The type of the basic tokens returned by the lexer.
   token *tok_val;
 
 // Types for the nonterminals we generate.
   tree *tree_type;
   tree_matrix *tree_matrix_type;
   tree_matrix_row *tree_matrix_row_type;
   tree_expression *tree_expression_type;
-  tree_constant *tree_constant_type;
+  octave_value *octave_value_type;
   tree_identifier *tree_identifier_type;
   tree_indirect_ref *tree_indirect_ref_type;
   tree_function *tree_function_type;
   tree_index_expression *tree_index_expression_type;
   tree_colon_expression *tree_colon_expression_type;
   tree_argument_list *tree_argument_list_type;
   tree_parameter_list *tree_parameter_list_type;
   tree_command *tree_command_type;
@@ -768,19 +768,19 @@ simple_expr1	: NUM
 		  }
 		| word_list_cmd
 		  { $$ = $1; }
 		| variable
 		  { $$ = $1; }
 		| matrix
 		  { $$ = $1; }
 		| '[' ']'
-		  { $$ = new tree_constant (Matrix ()); }
+		  { $$ = new octave_value (Matrix ()); }
 		| '[' ';' ']'
-		  { $$ = new tree_constant (Matrix ()); }
+		  { $$ = new octave_value (Matrix ()); }
 		| colon_expr
 		  { $$ = finish_colon_expression ($1); }
 		| PLUS_PLUS identifier %prec UNARY
 		  { $$ = make_prefix_op (PLUS_PLUS, $2, $1); }
 		| MINUS_MINUS identifier %prec UNARY
 		  { $$ = make_prefix_op (MINUS_MINUS, $2, $1); }
 		| EXPR_NOT simple_expr
 		  { $$ = make_unary_op (EXPR_NOT, $2, $1); }
@@ -865,22 +865,22 @@ word_list_cmd	: identifier word_list
 		  {
 		    $$ = new tree_index_expression
 		      ($1, $2, $1->line (), $1->column ());
 		  }
 		;
 
 word_list	: TEXT
 		  {
-		    tree_constant *tmp = make_constant (TEXT, $1);
+		    octave_value *tmp = make_constant (TEXT, $1);
 		    $$ = new tree_argument_list (tmp);
 		  }
 		| word_list TEXT
 		  {
-		    tree_constant *tmp = make_constant (TEXT, $2);
+		    octave_value *tmp = make_constant (TEXT, $2);
 		    $1->append (tmp);
 		    $$ = $1;
 		  }
 		;
 
 // This is truly disgusting.
 
 g_symtab	: // empty
@@ -1065,48 +1065,48 @@ identifier	: NAME
 		  {
 		    $$ = new tree_identifier
 		      ($1->sym_rec (), $1->line (), $1->column ());
 		  }
 		;
 
 arg_list	: ':'
 		  {
-		    tree_constant *colon;
-		    tree_constant::magic_colon t;
-		    colon = new tree_constant (t);
+		    octave_value *colon;
+		    octave_value::magic_colon t;
+		    colon = new octave_value (t);
 		    $$ = new tree_argument_list (colon);
 		  }
 		| expression
 		  { $$ = new tree_argument_list ($1); }
 		| ALL_VA_ARGS
 		  {
-		    tree_constant *all_va_args;
-		    tree_constant::all_va_args t;
-		    all_va_args = new tree_constant (t);
+		    octave_value *all_va_args;
+		    octave_value::all_va_args t;
+		    all_va_args = new octave_value (t);
 		    $$ = new tree_argument_list (all_va_args);
 		  }
 		| arg_list ',' ':'
 		  {
-		    tree_constant *colon;
-		    tree_constant::magic_colon t;
-		    colon = new tree_constant (t);
+		    octave_value *colon;
+		    octave_value::magic_colon t;
+		    colon = new octave_value (t);
 		    $1->append (colon);
 		    $$ = $1;
 		  }
 		| arg_list ',' expression
 		  {
 		    $1->append ($3);
 		    $$ = $1;
 		  }
 		| arg_list ',' ALL_VA_ARGS
 		  {
-		    tree_constant *all_va_args;
-		    tree_constant::all_va_args t;
-		    all_va_args = new tree_constant (t);
+		    octave_value *all_va_args;
+		    octave_value::all_va_args t;
+		    all_va_args = new octave_value (t);
 		    $1->append (all_va_args);
 		    $$ = $1;
 		  }
 		;
 
 matrix		: '[' screwed_again rows ']'
 		  { $$ = finish_matrix ($3); }
 		;
@@ -1365,56 +1365,56 @@ make_plot_command (token *tok, plot_limi
 
 static tree_expression *
 finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = 0;
 
   if (e->is_range_constant ())
     {
-      tree_constant tmp = e->eval (0);
+      octave_value tmp = e->eval (0);
 
       delete e;
 
       if (! error_state)
-	retval = new tree_constant (tmp);
+	retval = new octave_value (tmp);
     }
   else
     retval = e;
 
   return retval;
 }
 
 // Make a constant.
 
-static tree_constant *
+static octave_value *
 make_constant (int op, token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
-  tree_constant *retval;
+  octave_value *retval;
 
   switch (op)
     {
     case NUM:
-      retval = new tree_constant (tok_val->number (), l, c);
+      retval = new octave_value (tok_val->number (), l, c);
       retval->stash_original_text (tok_val->text_rep ());
       break;
 
     case IMAG_NUM:
       {
 	Complex C (0.0, tok_val->number ());
-	retval = new tree_constant (C, l, c);
+	retval = new octave_value (C, l, c);
 	retval->stash_original_text (tok_val->text_rep ());
       }
       break;
 
     case TEXT:
-      retval = new tree_constant (tok_val->text (), l, c);
+      retval = new octave_value (tok_val->text (), l, c);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
@@ -1519,23 +1519,23 @@ make_binary_op (int op, tree_expression 
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   retval = new tree_binary_expression (op1, op2, t, l, c);
 
   if (op1->is_constant () && op2->is_constant ())
     {
-      tree_constant tmp = retval->eval (0);
+      octave_value tmp = retval->eval (0);
 
       delete retval;
       retval = 0;
 
       if (! error_state)
-	retval = new tree_constant (tmp);
+	retval = new octave_value (tmp);
     }
 
   return retval;
 }
 
 // Build a prefix expression.
 
 static tree_expression *
@@ -1624,23 +1624,23 @@ make_unary_op (int op, tree_expression *
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   retval = new tree_unary_expression (op1, t, l, c);
 
   if (op1->is_constant ())
     {
-      tree_constant tmp = retval->eval (0);
+      octave_value tmp = retval->eval (0);
 
       delete retval;
       retval = 0;
 
       if (! error_state)
-	retval = new tree_constant (tmp);
+	retval = new octave_value (tmp);
     }
 
   return retval;
 }
 
 // Build an unwind-protect command.
 
 static tree_command *
@@ -2037,22 +2037,22 @@ static tree_expression *
 finish_matrix (tree_matrix *m)
 {
   tree_expression *retval = 0;
 
   lexer_flags.maybe_screwed_again--;
 
   if (m->is_matrix_constant ())
     {
-      tree_constant tmp = m->eval (0);
+      octave_value tmp = m->eval (0);
 
       delete m;
 
       if (! error_state)
-	retval = new tree_constant (tmp);
+	retval = new octave_value (tmp);
     }
   else
     retval = m;
 
   return retval;
 }
 
 static void
diff --git a/src/pinv.cc b/src/pinv.cc
--- a/src/pinv.cc
+++ b/src/pinv.cc
@@ -31,27 +31,27 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (pinv, args, ,
   "pinv ( [, tol])\n\
 Returns the pseudoinverse of X; singular values less than tol are ignored.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("pinv");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   double tol = 0.0;
   if (nargin == 2)
     tol = args(1).double_value ();
 
   if (error_state)
     return retval;
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1568,17 +1568,17 @@ octave_print_internal (ostream& os, cons
     {
       os << "sorry, printing char matrices not implemented yet\n";
     }
 }
 
 DEFUN (disp, args, ,
   "disp (X): display value without name tag")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     args(0).eval (1);
   else
     print_usage ("disp");
 
@@ -1595,22 +1595,22 @@ init_format_state (void)
   bit_format = 0;
   print_e = 0;
   print_big_e = 0;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
 {
-  tree_constant *tmp = 0;
+  octave_value *tmp = 0;
 
-  tmp = new tree_constant ((double) prec);
+  tmp = new octave_value ((double) prec);
   bind_builtin_variable ("output_precision", tmp);
 
-  tmp = new tree_constant ((double) fw);
+  tmp = new octave_value ((double) fw);
   bind_builtin_variable ("output_max_field_width", tmp);
 }
 
 static void
 set_format_style (int argc, const string_vector& argv)
 {
   int idx = 1;
   string arg = argv[idx++];
@@ -1733,17 +1733,17 @@ set_format_style (int argc, const string
     }
 }
 
 DEFUN_TEXT (format, args, ,
   "format [style]\n\
 \n\
 set output formatting style")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("format");
 
   if (error_state)
     return retval;
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -206,17 +206,17 @@ tree_for_command::~tree_for_command (voi
   delete id;
   delete id_list;
   delete expr;
   delete list;
 }
 
 inline void
 tree_for_command::do_for_loop_once (tree_return_list *lst,
-				    const Octave_object& rhs, bool& quit)
+				    const octave_value_list& rhs, bool& quit)
 {
   quit = false;
 
   tree_oct_obj *tmp = new tree_oct_obj (rhs);
   tree_multi_assignment_expression tmp_ass (lst, tmp, 1);
   tmp_ass.eval (false);
 
   if (error_state)
@@ -236,21 +236,21 @@ tree_for_command::do_for_loop_once (tree
 	}
     }
 
   quit = quit_loop_now ();
 }
 
 inline void
 tree_for_command::do_for_loop_once (tree_index_expression *idx_expr,
-				    const tree_constant& rhs, bool& quit)
+				    const octave_value& rhs, bool& quit)
 {
   quit = false;
 
-  tree_constant *tmp = new tree_constant (rhs);
+  octave_value *tmp = new octave_value (rhs);
   tree_simple_assignment_expression tmp_ass (idx_expr, tmp, true);
   tmp_ass.eval (false);
 
   if (error_state)
     {
       eval_error ();
       return;
     }
@@ -266,17 +266,17 @@ tree_for_command::do_for_loop_once (tree
 	}
     }
 
   quit = quit_loop_now ();
 }
 
 inline void
 tree_for_command::do_for_loop_once (tree_identifier *ident,
-				    tree_constant& rhs, bool& quit)
+				    octave_value& rhs, bool& quit)
 {
   quit = false;
 
   ident->assign (rhs);
 
   if (error_state)
     {
       eval_error ();
@@ -298,50 +298,50 @@ tree_for_command::do_for_loop_once (tree
 }
 
 #define DO_LOOP(val) \
   do \
     { \
       if (ident) \
 	for (int i = 0; i < steps; i++) \
 	  { \
-	    tree_constant rhs (val); \
+	    octave_value rhs (val); \
 	    bool quit = false; \
 	    do_for_loop_once (ident, rhs, quit); \
 	    if (quit) \
 	      break; \
 	  } \
       else if (id_list) \
 	for (int i = 0; i < steps; i++) \
 	  { \
-	    Octave_object rhs (val); \
+	    octave_value_list rhs (val); \
 	    bool quit = false; \
 	    do_for_loop_once (id_list, rhs, quit); \
 	    if (quit) \
 	      break; \
 	  } \
       else \
 	for (int i = 0; i < steps; i++) \
 	  { \
-	    tree_constant rhs (val); \
+	    octave_value rhs (val); \
 	    bool quit = false; \
 	    do_for_loop_once (tmp_id, rhs, quit); \
 	    if (quit) \
 	      break; \
 	  } \
     } \
   while (0)
 
 void
 tree_for_command::eval (void)
 {
   if (error_state || ! expr)
     return;
 
-  tree_constant tmp_expr = expr->eval (false);
+  octave_value tmp_expr = expr->eval (false);
 
   if (error_state || tmp_expr.is_undefined ())
     {
       eval_error ();
       return;
     }
 
   tree_index_expression *tmp_id = id;
@@ -364,17 +364,17 @@ tree_for_command::eval (void)
 
   if (tmp_expr.is_scalar_type ())
     {
       bool quit = false;
       if (ident)
 	do_for_loop_once (ident, tmp_expr, quit);
       else if (id_list)
 	{
-	  Octave_object rhs (tmp_expr);
+	  octave_value_list rhs (tmp_expr);
 	  do_for_loop_once (id_list, rhs, quit);
 	}
       else
 	do_for_loop_once (tmp_id, tmp_expr, quit);
     }
   else if (tmp_expr.is_matrix_type ())
     {
       Matrix m_tmp;
@@ -422,47 +422,47 @@ tree_for_command::eval (void)
       double increment = rng.inc ();
 
       if (ident)
 	{
 	  for (int i = 0; i < steps; i++)
 	    {
 	      double tmp_val = b + i * increment;
 
-	      tree_constant rhs (tmp_val);
+	      octave_value rhs (tmp_val);
 
 	      bool quit = false;
 	      do_for_loop_once (ident, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else if (id_list)
 	{
 	  for (int i = 0; i < steps; i++)
 	    {
 	      double tmp_val = b + i * increment;
 
-	      Octave_object rhs (tmp_val);
+	      octave_value_list rhs (tmp_val);
 
 	      bool quit = false;
 	      do_for_loop_once (id_list, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else
 	{
 	  for (int i = 0; i < steps; i++)
 	    {
 	      double tmp_val = b + i * increment;
 
-	      tree_constant rhs (tmp_val);
+	      octave_value rhs (tmp_val);
 
 	      bool quit = false;
 	      do_for_loop_once (tmp_id, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
@@ -470,17 +470,17 @@ tree_for_command::eval (void)
   else if (tmp_expr.is_map ())
     {
       if (ident)
 	{
 	  Octave_map tmp_val (tmp_expr.map_value ());
 
 	  for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
 	    {
-	      tree_constant rhs (tmp_val.contents (p));
+	      octave_value rhs (tmp_val.contents (p));
 
 	      bool quit = false;
 	      do_for_loop_once (ident, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
@@ -489,34 +489,34 @@ tree_for_command::eval (void)
 	  // Cycle through structure elements.  First element of
 	  // id_list is set to value and the second is set to the name
 	  // of the structure element.
 
 	  Octave_map tmp_val (tmp_expr.map_value ());
 
 	  for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
 	    {
-	      Octave_object tmp;
+	      octave_value_list tmp;
 	      tmp (1) = tmp_val.key (p);
 	      tmp (0) = tmp_val.contents (p);
 
 	      bool quit = false;
 	      do_for_loop_once (id_list, tmp, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else
 	{
 	  Octave_map tmp_val (tmp_expr.map_value ());
 
 	  for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
 	    {
-	      tree_constant rhs = tmp_val.contents (p);
+	      octave_value rhs = tmp_val.contents (p);
 
 	      bool quit = false;
 	      do_for_loop_once (tmp_id, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -24,26 +24,26 @@ Software Foundation, 59 Temple Place - S
 #define octave_tree_cmd_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 class ostream;
 
-class Octave_object;
+class octave_value_list;
 
 class tree_statement_list;
 class tree_global_init_list;
 class tree_if_command_list;
 class tree_expression;
 class tree_index_expression;
 class tree_identifier;
 class tree_return_list;
-class tree_constant;
+class octave_value;
 class symbol_record;
 
 class tree_command;
 class tree_global_command;
 class tree_while_command;
 class tree_for_command;
 class tree_if_command;
 class tree_try_catch_command;
@@ -140,23 +140,23 @@ public:
   void eval (void);
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
 private:
   void do_for_loop_once (tree_return_list *lst,
-			 const Octave_object& rhs, bool& quit);
+			 const octave_value_list& rhs, bool& quit);
 
   void do_for_loop_once (tree_index_expression *idx_expr,
-			 const tree_constant& rhs, bool& quit);
+			 const octave_value& rhs, bool& quit);
 
   void do_for_loop_once (tree_identifier *ident,
-			 tree_constant& rhs, bool& quit);
+			 octave_value& rhs, bool& quit);
 
   tree_index_expression *id;	// Identifier to modify.
   tree_return_list *id_list;	// List of identifiers to modify.
   tree_expression *expr;	// Expression to evaluate.
   tree_statement_list *list;	// List of commands to execute.
 };
 
 // If.
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -54,37 +54,37 @@ Software Foundation, 59 Temple Place - S
 #include "pr-output.h"
 #include "sysdep.h"
 #include "pt-const.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
-#ifndef TC_REP
-#define TC_REP tree_constant::tree_constant_rep
+#ifndef OCT_VAL_REP
+#define OCT_VAL_REP octave_value::octave_value_rep
 #endif
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
-#ifndef TC_REP
-#define TC_REP tree_constant::tree_constant_rep
+#ifndef OCT_VAL_REP
+#define OCT_VAL_REP octave_value::octave_value_rep
 #endif
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
 // The following three variables could be made static members of the
-// TC_REP class.
+// OCT_VAL_REP class.
 
 // Pointer to the blocks of memory we manage.
-static TC_REP *tc_rep_newlist = 0;
+static OCT_VAL_REP *tc_rep_newlist = 0;
 
 // Multiplier for allocating new blocks.
 static const int tc_rep_newlist_grow_size = 128;
 
 // Indentation level for structures.
 static int struct_indent = 0;
 
 static void
@@ -109,95 +109,95 @@ any_element_is_complex (const ComplexMat
     for (int i = 0; i < nr; i++)
       if (imag (a.elem (i, j)) != 0.0)
 	return true;
 
   return false;
 }
 
 // The following three variables could be made static members of the
-// tree_constant class.
+// octave_value class.
 
 // Pointer to the blocks of memory we manage.
-static tree_constant *tc_newlist = 0;
+static octave_value *tc_newlist = 0;
 
 // Multiplier for allocating new blocks.
 static const int tc_newlist_grow_size = 128;
 
 Octave_map
-tree_constant::map_value (void) const
+octave_value::map_value (void) const
 {
   return rep->map_value ();
 }
 
-tree_constant::~tree_constant (void)
+octave_value::~octave_value (void)
 {
 #if defined (MDEBUG)
-  cerr << "~tree_constant: rep: " << rep
+  cerr << "~octave_value: rep: " << rep
        << " rep->count: " << rep->count << "\n";
 #endif
 
   if (--rep->count <= 0)
     {
       delete rep;
       rep = 0;
     }
 }
 
 void *
-tree_constant::operator new (size_t size)
+octave_value::operator new (size_t size)
 {
-  assert (size == sizeof (tree_constant));
+  assert (size == sizeof (octave_value));
 
   if (! tc_newlist)
     {
-      int block_size = tc_newlist_grow_size * sizeof (tree_constant);
-      tc_newlist = (tree_constant *) new char [block_size];
+      int block_size = tc_newlist_grow_size * sizeof (octave_value);
+      tc_newlist = (octave_value *) new char [block_size];
 
       int i = 0;
 
       for (i = 0; i < tc_newlist_grow_size - 1; i++)
 	tc_newlist[i].freeptr = &tc_newlist[i+1];
 
       tc_newlist[i].freeptr = 0;
     }
 
-  tree_constant *tmp = tc_newlist;
+  octave_value *tmp = tc_newlist;
   tc_newlist = tc_newlist->freeptr;
   return tmp;
 }
 
 void
-tree_constant::operator delete (void *p, size_t /* size */)
+octave_value::operator delete (void *p, size_t /* size */)
 {
-  tree_constant *tmp = (tree_constant *) p;
+  octave_value *tmp = (octave_value *) p;
   tmp->freeptr = tc_newlist;
   tc_newlist = tmp;
 }
 
 // Simple assignment.
 
-tree_constant
-tree_constant::operator = (const tree_constant& a)
+octave_value
+octave_value::operator = (const octave_value& a)
 {
   if (rep != a.rep)
     {
       if (--rep->count <= 0)
 	delete rep;
       rep = a.rep;
       rep->count++;
     }
   return *this;  
 }
 
-tree_constant
-tree_constant::lookup_map_element (const string& ref, bool insert,
+octave_value
+octave_value::lookup_map_element (const string& ref, bool insert,
 				   bool silent)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (! ref.empty ())
     {
       SLList<string> list;
 
       size_t beg = 0;
       size_t end;
 
@@ -213,67 +213,67 @@ tree_constant::lookup_map_element (const
       while (end != NPOS && (beg = end + 1));
 
       retval = lookup_map_element (list, insert, silent);
     }
 
   return retval;
 }
 
-tree_constant
-tree_constant::lookup_map_element (SLList<string>& list, bool insert,
+octave_value
+octave_value::lookup_map_element (SLList<string>& list, bool insert,
 				   bool silent)
 {
-  tree_constant retval;
-
-  tree_constant_rep *tmp_rep = rep;
+  octave_value retval;
+
+  octave_value_rep *tmp_rep = rep;
 
   Pix p = list.first ();
   while (p)
     {
       string elt = list (p);
 
       list.next (p);
 
-      tree_constant tmp;
+      octave_value tmp;
 
       tmp = tmp_rep->lookup_map_element (elt, insert, silent);
 
       if (error_state)
 	break;
 
       tmp_rep = tmp.rep;
 
       if (! p)
 	retval = tmp;
     }
 
   return retval;
 }
 
 void
-tree_constant::print (void)
+octave_value::print (void)
 {
   ostrstream output_buf;
   print (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 void
-tree_constant::print_with_name (const string& name, bool print_padding)
+octave_value::print_with_name (const string& name, bool print_padding)
 {
   ostrstream output_buf;
   print_with_name (output_buf, name, print_padding);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 void
-tree_constant::print_with_name (ostream& output_buf, const string& name,
+octave_value::print_with_name (ostream& output_buf, const string& name,
 				bool print_padding) 
 {
   bool pad_after = false;
 
   if (user_pref.print_answer_id_name)
     {
       if (print_as_scalar ())
 	output_buf << name << " = ";
@@ -293,188 +293,188 @@ tree_constant::print_with_name (ostream&
 
   if (print_padding && pad_after)
     output_buf << "\n";
 }
 
 // Simple structure assignment.
 
 void
-tree_constant::make_unique (void)
+octave_value::make_unique (void)
 {
   if (rep->count > 1)
     {
       --rep->count;
-      rep = new tree_constant_rep (*rep);
+      rep = new octave_value_rep (*rep);
       rep->count = 1;
     }
 
   if (rep->is_map ())
     {
       for (Pix p = rep->a_map->first (); p != 0; rep->a_map->next (p))
 	{
 	  rep->a_map->contents (p) . make_unique ();
 	}
     }
 }
 
-tree_constant::tree_constant_rep *
-tree_constant::make_unique_map (void)
+octave_value::octave_value_rep *
+octave_value::make_unique_map (void)
 {
   if (! rep->is_map ())
     {
       if (--rep->count <= 0)
 	delete rep;
 
       Octave_map m;
-      rep = new tree_constant_rep (m);
+      rep = new octave_value_rep (m);
       rep->count = 1;
     }
 
   make_unique ();
 
   return rep;
 }
 
-tree_constant
-tree_constant::assign_map_element (SLList<string>& list,
-				   tree_constant& rhs)
+octave_value
+octave_value::assign_map_element (SLList<string>& list,
+				   octave_value& rhs)
 {
-  tree_constant_rep *tmp_rep = make_unique_map ();
+  octave_value_rep *tmp_rep = make_unique_map ();
 
   if (rhs.is_map ())
     rhs.make_unique ();
 
   Pix p = list.first ();
   while (p)
     {
       string elt = list (p);
 
       list.next (p);
 
-      tree_constant& tmp = tmp_rep->lookup_map_element (elt, 1);
+      octave_value& tmp = tmp_rep->lookup_map_element (elt, 1);
 
       if (! p)
 	{
 	  tmp = rhs;
 	  return tmp;
 	}
 
       tmp_rep = tmp.make_unique_map ();
     }
 
-  return tree_constant ();
+  return octave_value ();
 }
 
 // Indexed structure assignment.
 
-tree_constant
-tree_constant::assign_map_element (SLList<string>& list,
-				   tree_constant& rhs,
-				   const Octave_object& args)
+octave_value
+octave_value::assign_map_element (SLList<string>& list,
+				   octave_value& rhs,
+				   const octave_value_list& args)
 {
-  tree_constant_rep *tmp_rep = make_unique_map ();
+  octave_value_rep *tmp_rep = make_unique_map ();
 
   if (rhs.is_map ())
     rhs.make_unique ();
 
   Pix p = list.first ();
   while (p)
     {
       string elt = list (p);
 
       list.next (p);
 
-      tree_constant& tmp = tmp_rep->lookup_map_element (elt, 1);
+      octave_value& tmp = tmp_rep->lookup_map_element (elt, 1);
 
       if (! p)
 	{
 	  tmp.assign (rhs, args);
 	  return tmp;
 	}
 
       tmp_rep = tmp.make_unique_map ();
     }
 
-  return tree_constant ();
+  return octave_value ();
 }
 
-Octave_object
-tree_constant::eval (bool print, int, const Octave_object& args)
+octave_value_list
+octave_value::eval (bool print, int, const octave_value_list& args)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (args.length () > 0)
     retval(0) = rep->do_index (args);
   else
     retval(0) = *this;
 
   if (retval(0).is_defined ())
     retval(0).eval (print);
 
   return retval;
 }
 
 void
-tree_constant::print_code (ostream& os)
+octave_value::print_code (ostream& os)
 {
   print_code_indent (os);
 
   if (in_parens)
     os << "(";
 
   if (rep)
     rep->print_code (os);
 
   if (in_parens)
     os << ")";
 }
 
 // The real representation of constants.
 
-TC_REP::tree_constant_rep (void)
+OCT_VAL_REP::octave_value_rep (void)
 {
   type_tag = unknown_constant;
 }
 
-TC_REP::tree_constant_rep (double d)
+OCT_VAL_REP::octave_value_rep (double d)
 {
   scalar = d;
   type_tag = scalar_constant;
 }
 
-TC_REP::tree_constant_rep (const Matrix& m)
+OCT_VAL_REP::octave_value_rep (const Matrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
       scalar = m.elem (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (m);
       type_tag = matrix_constant;
     }
 }
 
-TC_REP::tree_constant_rep (const DiagMatrix& d)
+OCT_VAL_REP::octave_value_rep (const DiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
       scalar = d.elem (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (d);
       type_tag = matrix_constant;
     }
 }
 
-TC_REP::tree_constant_rep (const RowVector& v, int prefer_column_vector)
+OCT_VAL_REP::octave_value_rep (const RowVector& v, int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
       scalar = v.elem (0);
       type_tag = scalar_constant;
     }
   else
@@ -497,17 +497,17 @@ TC_REP::tree_constant_rep (const RowVect
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
 }
 
-TC_REP::tree_constant_rep (const ColumnVector& v, int prefer_column_vector)
+OCT_VAL_REP::octave_value_rep (const ColumnVector& v, int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
       scalar = v.elem (0);
       type_tag = scalar_constant;
     }
   else
@@ -530,31 +530,31 @@ TC_REP::tree_constant_rep (const ColumnV
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
 }
 
-TC_REP::tree_constant_rep (const Complex& c)
+OCT_VAL_REP::octave_value_rep (const Complex& c)
 {
   if (::imag (c) == 0.0)
     {
       scalar = ::real (c);
       type_tag = scalar_constant;
     }
   else
     {
       complex_scalar = new Complex (c);
       type_tag = complex_scalar_constant;
     }
 }
 
-TC_REP::tree_constant_rep (const ComplexMatrix& m)
+OCT_VAL_REP::octave_value_rep (const ComplexMatrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
       Complex c = m.elem (0, 0);
 
       if (::imag (c) == 0.0)
 	{
 	  scalar = ::real (c);
@@ -568,17 +568,17 @@ TC_REP::tree_constant_rep (const Complex
     }
   else
     {
       complex_matrix = new ComplexMatrix (m);
       type_tag = complex_matrix_constant;
     }
 }
 
-TC_REP::tree_constant_rep (const ComplexDiagMatrix& d)
+OCT_VAL_REP::octave_value_rep (const ComplexDiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
       Complex c = d.elem (0, 0);
 
       if (::imag (c) == 0.0)
 	{
 	  scalar = ::real (c);
@@ -592,17 +592,17 @@ TC_REP::tree_constant_rep (const Complex
     }
   else
     {
       complex_matrix = new ComplexMatrix (d);
       type_tag = complex_matrix_constant;
     }
 }
 
-TC_REP::tree_constant_rep (const ComplexRowVector& v,
+OCT_VAL_REP::octave_value_rep (const ComplexRowVector& v,
 			   int prefer_column_vector) 
 {
   int len = v.capacity ();
   if (len == 1)
     {
       Complex c = v.elem (0);
 
       if (::imag (c) == 0.0)
@@ -636,17 +636,17 @@ TC_REP::tree_constant_rep (const Complex
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
 }
 
-TC_REP::tree_constant_rep (const ComplexColumnVector& v, int
+OCT_VAL_REP::octave_value_rep (const ComplexColumnVector& v, int
 			   prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
       Complex c = v.elem (0);
 
       if (::imag (c) == 0.0)
@@ -680,49 +680,49 @@ TC_REP::tree_constant_rep (const Complex
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
 }
 
-TC_REP::tree_constant_rep (const char *s)
+OCT_VAL_REP::octave_value_rep (const char *s)
 {
   char_matrix = new charMatrix (s);
   type_tag = char_matrix_constant_str;
 }
 
-TC_REP::tree_constant_rep (const string& s)
+OCT_VAL_REP::octave_value_rep (const string& s)
 {
   char_matrix = new charMatrix (s);
   type_tag = char_matrix_constant_str;
 }
 
-TC_REP::tree_constant_rep (const string_vector& s)
+OCT_VAL_REP::octave_value_rep (const string_vector& s)
 {
   int nr = s.length ();
   int nc = s.max_length ();
   char_matrix = new charMatrix (nr, nc, 0);
   for (int i = 0; i < nr; i++)
     {
       nc = s[i].length ();
       for (int j = 0; j < nc; j++)
 	char_matrix->elem (i, j) = s[i][j];
     }
   type_tag = char_matrix_constant_str;
 }
 
-TC_REP::tree_constant_rep (const charMatrix& chm, bool is_str)
+OCT_VAL_REP::octave_value_rep (const charMatrix& chm, bool is_str)
 {
   char_matrix = new charMatrix (chm);
   type_tag = is_str ? char_matrix_constant_str : char_matrix_constant;
 }
 
-TC_REP::tree_constant_rep (double b, double l, double i)
+OCT_VAL_REP::octave_value_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel > 1)
     type_tag = range_constant;
   else
     {
       delete range;
@@ -742,17 +742,17 @@ TC_REP::tree_constant_rep (double b, dou
 	  if (nel == -1)
 	    ::error ("number of elements in range exceeds INT_MAX");
 	  else
 	    ::error ("invalid range");
 	}
     }
 }
 
-TC_REP::tree_constant_rep (const Range& r)
+OCT_VAL_REP::octave_value_rep (const Range& r)
 {
   int nel = r.nelem ();
   if (nel > 1)
     {
       range = new Range (r);
       type_tag = range_constant;
     }
   else if (nel == 1)
@@ -770,29 +770,29 @@ TC_REP::tree_constant_rep (const Range& 
       type_tag = unknown_constant;
       if (nel == -1)
 	::error ("number of elements in range exceeds INT_MAX");
       else
 	::error ("invalid range");
     }
 }
 
-TC_REP::tree_constant_rep (const Octave_map& m)
+OCT_VAL_REP::octave_value_rep (const Octave_map& m)
 {
   a_map = new Octave_map (m);
   type_tag = map_constant;
 }
 
-TC_REP::tree_constant_rep (TC_REP::constant_type t)
+OCT_VAL_REP::octave_value_rep (OCT_VAL_REP::constant_type t)
 {
   assert (t == magic_colon || t == all_va_args);
   type_tag = t;
 }
 
-TC_REP::tree_constant_rep (const tree_constant_rep& t)
+OCT_VAL_REP::octave_value_rep (const octave_value_rep& t)
 {
   type_tag = t.type_tag;
 
   switch (t.type_tag)
     {
     case unknown_constant:
       break;
 
@@ -831,17 +831,17 @@ TC_REP::tree_constant_rep (const tree_co
     case magic_colon:
     case all_va_args:
       break;
     }
 
   orig_text = t.orig_text;
 }
 
-TC_REP::~tree_constant_rep (void)
+OCT_VAL_REP::~octave_value_rep (void)
 {
   switch (type_tag)
     {
     case matrix_constant:
       delete matrix;
       break;
 
     case complex_scalar_constant:
@@ -869,48 +869,48 @@ TC_REP::~tree_constant_rep (void)
     case scalar_constant:
     case magic_colon:
     case all_va_args:
       break;
     }
 }
 
 void *
-TC_REP::operator new (size_t size)
+OCT_VAL_REP::operator new (size_t size)
 {
-  assert (size == sizeof (TC_REP));
+  assert (size == sizeof (OCT_VAL_REP));
 
   if (! tc_rep_newlist)
     {
-      int block_size = tc_rep_newlist_grow_size * sizeof (TC_REP);
-      tc_rep_newlist = (TC_REP *) new char [block_size];
+      int block_size = tc_rep_newlist_grow_size * sizeof (OCT_VAL_REP);
+      tc_rep_newlist = (OCT_VAL_REP *) new char [block_size];
 
       int i = 0;
 
       for (i = 0; i < tc_rep_newlist_grow_size - 1; i++)
 	tc_rep_newlist[i].freeptr = &tc_rep_newlist[i+1];
 
       tc_rep_newlist[i].freeptr = 0;
     }
 
-  TC_REP *tmp = tc_rep_newlist;
+  OCT_VAL_REP *tmp = tc_rep_newlist;
   tc_rep_newlist = tc_rep_newlist->freeptr;
   return tmp;
 }
 
 void
-TC_REP::operator delete (void *p, size_t /* size */)
+OCT_VAL_REP::operator delete (void *p, size_t /* size */)
 {
-  TC_REP *tmp = (TC_REP *) p;
+  OCT_VAL_REP *tmp = (OCT_VAL_REP *) p;
   tmp->freeptr = tc_rep_newlist;
   tc_rep_newlist = tmp;
 }
 
 int
-TC_REP::rows (void) const
+OCT_VAL_REP::rows (void) const
 {
   int retval = -1;
 
   switch (type_tag)
     {
     case scalar_constant:
     case complex_scalar_constant:
       retval = 1;
@@ -936,17 +936,17 @@ TC_REP::rows (void) const
     default:
       break;
     }
 
   return retval;
 }
 
 int
-TC_REP::columns (void) const
+OCT_VAL_REP::columns (void) const
 {
   int retval = -1;
 
   switch (type_tag)
     {
     case scalar_constant:
     case complex_scalar_constant:
       retval = 1;
@@ -971,27 +971,27 @@ TC_REP::columns (void) const
 
     default:
       break;
     }
 
   return retval;
 }
 
-tree_constant
-TC_REP::all (void) const
+octave_value
+OCT_VAL_REP::all (void) const
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (! is_numeric_type ())
     {
-      tree_constant tmp = make_numeric ();
+      octave_value tmp = make_numeric ();
 
       if (error_state)
 	return retval;
 
       return tmp.all ();
     }
 
   switch (type_tag)
@@ -1015,27 +1015,27 @@ TC_REP::all (void) const
     default:
       gripe_wrong_type_arg ("all", *this);
       break;
     }
 
   return retval;
 }
 
-tree_constant
-TC_REP::any (void) const
+octave_value
+OCT_VAL_REP::any (void) const
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (! is_numeric_type ())
     {
-      tree_constant tmp = make_numeric ();
+      octave_value tmp = make_numeric ();
 
       if (error_state)
 	return retval;
 
       return tmp.any ();
     }
 
   switch (type_tag)
@@ -1060,54 +1060,54 @@ TC_REP::any (void) const
       gripe_wrong_type_arg ("any", *this);
       break;
     }
 
   return retval;
 }
 
 bool
-TC_REP::valid_as_scalar_index (void) const
+OCT_VAL_REP::valid_as_scalar_index (void) const
 {
   return (type_tag == magic_colon
 	  || (type_tag == scalar_constant 
 	      && ! xisnan (scalar)
 	      && NINT (scalar) == 1)
 	  || (type_tag == range_constant
 	      && range->nelem () == 1
 	      && ! xisnan (range->base ())
 	      && NINT (range->base ()) == 1));
 }
 
 bool
-TC_REP::valid_as_zero_index (void) const
+OCT_VAL_REP::valid_as_zero_index (void) const
 {
   return ((type_tag == scalar_constant
 	   && ! xisnan (scalar)
 	   && NINT (scalar) == 0)
 	  || (type_tag == matrix_constant
 	      && matrix->rows () == 0
 	      && matrix->columns () == 0)
 	  || (type_tag == range_constant
 	      && range->nelem () == 1
 	      && ! xisnan (range->base ())
 	      && NINT (range->base ()) == 0));
 }
 
 bool
-TC_REP::is_true (void) const
+OCT_VAL_REP::is_true (void) const
 {
   int retval = false;
 
   if (error_state)
     return retval;
 
   if (! is_numeric_type ())
     {
-      tree_constant tmp = make_numeric ();
+      octave_value tmp = make_numeric ();
 
       if (error_state)
 	return retval;
 
       return tmp.is_true ();
     }
 
   switch (type_tag)
@@ -1150,17 +1150,17 @@ static void
 warn_implicit_conversion (const char *from, const char *to)
 {
   warning ("implicit conversion from %s to %s", from, to);
 }
 
 // XXX FIXME XXX -- we need a better way of handling conversions.
 
 double
-TC_REP::double_value (bool force_string_conv) const
+OCT_VAL_REP::double_value (bool force_string_conv) const
 {
   double retval = octave_NaN;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = scalar;
       break;
@@ -1246,17 +1246,17 @@ TC_REP::double_value (bool force_string_
       gripe_invalid_conversion (type_as_string (), "real scalar");
       break;
     }
 
   return retval;
 }
 
 Matrix
-TC_REP::matrix_value (bool force_string_conv) const
+OCT_VAL_REP::matrix_value (bool force_string_conv) const
 {
   Matrix retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = Matrix (1, 1, scalar);
       break;
@@ -1314,17 +1314,17 @@ TC_REP::matrix_value (bool force_string_
       gripe_invalid_conversion (type_as_string (), "real matrix");
       break;
     }
 
   return retval;
 }
 
 Complex
-TC_REP::complex_value (bool force_string_conv) const
+OCT_VAL_REP::complex_value (bool force_string_conv) const
 {
   Complex retval (octave_NaN, octave_NaN);
 
   switch (type_tag)
     {
     case complex_scalar_constant:
       retval = *complex_scalar;
       break;
@@ -1392,17 +1392,17 @@ TC_REP::complex_value (bool force_string
       gripe_invalid_conversion (type_as_string (), "complex scalar");
       break;
     }
 
   return retval;
 }
 
 ComplexMatrix
-TC_REP::complex_matrix_value (bool force_string_conv) const
+OCT_VAL_REP::complex_matrix_value (bool force_string_conv) const
 {
   ComplexMatrix retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = ComplexMatrix (1, 1, Complex (scalar));
       break;
@@ -1449,17 +1449,17 @@ TC_REP::complex_matrix_value (bool force
     }
 
   return retval;
 }
 
 // XXX FIXME XXX -- this needs to try to do some conversions...
 
 charMatrix
-TC_REP::char_matrix_value (bool force_string_conv) const
+OCT_VAL_REP::char_matrix_value (bool force_string_conv) const
 {
   charMatrix retval;
 
   int flag = force_string_conv;
   if (! flag)
     flag = user_pref.implicit_str_to_num_ok;
 
   switch (type_tag)
@@ -1474,58 +1474,58 @@ TC_REP::char_matrix_value (bool force_st
 	gripe_invalid_conversion (type_as_string (), "string");
       break;
     }
 
   return retval;
 }
 
 charMatrix
-TC_REP::all_strings (void) const
+OCT_VAL_REP::all_strings (void) const
 {
   if (type_tag == char_matrix_constant_str)
     return *char_matrix;
   else
     {
       gripe_invalid_conversion (type_as_string (), "string");
       return 0;
     }
 }
 
 string
-TC_REP::string_value (void) const
+OCT_VAL_REP::string_value (void) const
 {
   string retval;
 
   if (type_tag == char_matrix_constant_str)
     retval = char_matrix->row_as_string (0);  // XXX FIXME??? XXX
   else
     gripe_invalid_conversion (type_as_string (), "string");
 
   return retval;
 }
 
 Range
-TC_REP::range_value (void) const
+OCT_VAL_REP::range_value (void) const
 {
   assert (type_tag == range_constant);
   return *range;
 }
 
 Octave_map
-TC_REP::map_value (void) const
+OCT_VAL_REP::map_value (void) const
 {
   assert (type_tag == map_constant);
   return *a_map;
 }
 
-tree_constant&
-TC_REP::lookup_map_element (const string& name, bool insert, bool silent)
+octave_value&
+OCT_VAL_REP::lookup_map_element (const string& name, bool insert, bool silent)
 {
-  static tree_constant retval;
+  static octave_value retval;
 
   if (type_tag == map_constant)
     {
       Pix idx = a_map->seek (name);
 
       if (idx)
 	return a_map->contents (idx);
       else if (insert)
@@ -1538,17 +1538,17 @@ TC_REP::lookup_map_element (const string
 
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
 // than relying on matrix_value() to do any possible type conversions.
 
 ColumnVector
-TC_REP::vector_value (bool force_string_conv,
+OCT_VAL_REP::vector_value (bool force_string_conv,
 		      bool force_vector_conversion) const
 {
   ColumnVector retval;
 
   Matrix m = matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
@@ -1582,17 +1582,17 @@ TC_REP::vector_value (bool force_string_
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
 // than relying on complex_matrix_value() to do any possible type
 // conversions.
 
 ComplexColumnVector
-TC_REP::complex_vector_value (bool force_string_conv,
+OCT_VAL_REP::complex_vector_value (bool force_string_conv,
 			      bool force_vector_conversion) const
 {
   ComplexColumnVector retval;
 
   ComplexMatrix m = complex_matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
@@ -1621,20 +1621,20 @@ TC_REP::complex_vector_value (bool force
 	  retval.elem (k++) = m.elem (i, j);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex vector");
 
   return retval;
 }
 
-tree_constant
-TC_REP::convert_to_str (void) const
+octave_value
+OCT_VAL_REP::convert_to_str (void) const
 {
-  tree_constant retval;
+  octave_value retval;
 
   switch (type_tag)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	double d = double_value ();
 
@@ -1646,40 +1646,40 @@ TC_REP::convert_to_str (void) const
 	else
 	  {
 	    // XXX FIXME XXX -- warn about out of range conversions?
 
 	    int i = NINT (d);
 	    char s[2];
 	    s[0] = (char) i;
 	    s[1] = '\0';
-	    retval = tree_constant (s, 1);
+	    retval = octave_value (s, 1);
 	  }
       }
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       {
 	if (rows () == 0 && columns () == 0)
 	  {
 	    char s = '\0';
-	    retval = tree_constant (&s, 1);
+	    retval = octave_value (&s, 1);
 	  }
 	else
 	  {
 	    Matrix m = matrix_value ();
 
 	    int nr = m.rows ();
 	    int nc = m.columns ();
 
 	    if (nr == 0 || nc == 0)
 	      {
 		char s = '\0';
-		retval = tree_constant (&s, 1);
+		retval = octave_value (&s, 1);
 	      }
 	    else
 	      {
 		charMatrix chm (nr, nc);
 
 		for (int j = 0; j < nc; j++)
 		  {
 		    for (int i = 0; i < nr; i++)
@@ -1697,17 +1697,17 @@ TC_REP::convert_to_str (void) const
 			    // range conversions?
 
 			    int ival = NINT (d);
 			    chm.elem (i, j) = (char) ival;
 			  }
 		      }
 		  }
 
-		retval = tree_constant (chm, 1);
+		retval = octave_value (chm, 1);
 	      }
 	  }
       }
       break;
 
     case range_constant:
       {
 	Range r = range_value ();
@@ -1730,39 +1730,39 @@ TC_REP::convert_to_str (void) const
 	      {
 		// XXX FIXME XXX -- warn about out of range
 		// conversions?
 
 		int ival = NINT (d);
 		s[i] = (char) ival;
 	      }
 	  }
-	retval = tree_constant (s, 1);
+	retval = octave_value (s, 1);
 	delete [] s;
       }
       break;
 
     case char_matrix_constant:
-      retval = tree_constant (*char_matrix, 1);
+      retval = octave_value (*char_matrix, 1);
       break;
 
     case char_matrix_constant_str:
-      retval = tree_constant (*char_matrix, 1);
+      retval = octave_value (*char_matrix, 1);
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "string");
       break;
     }
 
   return retval;
 }
 
 void
-TC_REP::convert_to_row_or_column_vector (void)
+OCT_VAL_REP::convert_to_row_or_column_vector (void)
 {
   assert (type_tag == matrix_constant || type_tag == complex_matrix_constant);
 
   int nr = rows ();
   int nc = columns ();
 
   if (nr == 1 || nc == 1)
     return;
@@ -1811,17 +1811,17 @@ TC_REP::convert_to_row_or_column_vector 
 	}
 
       delete complex_matrix;
       complex_matrix = cm;
     }
 }
 
 void
-TC_REP::convert_to_matrix_type (bool make_complex)
+OCT_VAL_REP::convert_to_matrix_type (bool make_complex)
 {
   switch (type_tag)
     {
     case complex_scalar_constant:
       {
 	Complex *old_complex = complex_scalar;
 	complex_matrix = new ComplexMatrix (1, 1, *complex_scalar);
 	type_tag = complex_matrix_constant;
@@ -1880,17 +1880,17 @@ TC_REP::convert_to_matrix_type (bool mak
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::force_numeric (bool force_string_conv)
+OCT_VAL_REP::force_numeric (bool force_string_conv)
 {
   switch (type_tag)
     {
     case scalar_constant:
     case matrix_constant:
     case complex_scalar_constant:
     case complex_matrix_constant:
     case char_matrix_constant:
@@ -1966,20 +1966,20 @@ TC_REP::force_numeric (bool force_string
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "numeric type");
       break;
     }
 }
 
-tree_constant
-TC_REP::make_numeric (bool force_string_conv) const
+octave_value
+OCT_VAL_REP::make_numeric (bool force_string_conv) const
 {
-  tree_constant retval;
+  octave_value retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = scalar;
       break;
 
     case matrix_constant:
@@ -2026,17 +2026,17 @@ TC_REP::make_numeric (bool force_string_
       gripe_invalid_conversion (type_as_string (), "numeric value");
       break;
     }
 
   return retval;
 }
 
 void
-TC_REP::bump_value (tree_expression::type etype)
+OCT_VAL_REP::bump_value (tree_expression::type etype)
 {
   switch (etype)
     {
     case tree_expression::increment:
       switch (type_tag)
 	{
 	case scalar_constant:
 	  scalar++;
@@ -2089,17 +2089,17 @@ TC_REP::bump_value (tree_expression::typ
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::resize (int i, int j)
+OCT_VAL_REP::resize (int i, int j)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->resize (i, j);
       break;
 
     case complex_matrix_constant:
@@ -2108,17 +2108,17 @@ TC_REP::resize (int i, int j)
 
     default:
       gripe_wrong_type_arg ("resize", type_as_string ());
       break;
     }
 }
 
 void
-TC_REP::resize (int i, int j, double val)
+OCT_VAL_REP::resize (int i, int j, double val)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->resize (i, j, val);
       break;
 
     case complex_matrix_constant:
@@ -2127,23 +2127,23 @@ TC_REP::resize (int i, int j, double val
 
     default:
       gripe_wrong_type_arg ("resize", type_as_string ());
       break;
     }
 }
 
 void
-TC_REP::stash_original_text (const string &s)
+OCT_VAL_REP::stash_original_text (const string &s)
 {
   orig_text = s;
 }
 
 void
-TC_REP::maybe_mutate (void)
+OCT_VAL_REP::maybe_mutate (void)
 {
   switch (type_tag)
     {
     case complex_scalar_constant:
       if (::imag (*complex_scalar) == 0.0)
 	{
 	  double d = ::real (*complex_scalar);
 	  delete complex_scalar;
@@ -2211,17 +2211,17 @@ TC_REP::maybe_mutate (void)
       break;
 
     default:
       break;
     }
 }
 
 void
-TC_REP::print (ostream& output_buf)
+OCT_VAL_REP::print (ostream& output_buf)
 {
   if (error_state)
     return;
 
   switch (type_tag)
     {
     case scalar_constant:
       octave_print_internal (output_buf, scalar, false);
@@ -2256,17 +2256,17 @@ TC_REP::print (ostream& output_buf)
       break;
 
     case map_constant:
       {
 	// XXX FIXME XXX -- would be nice to print the output in some
 	// standard order.  Maybe all substructures first, maybe
 	// alphabetize entries, etc.
 
-	begin_unwind_frame ("TC_REP_print");
+	begin_unwind_frame ("OCT_VAL_REP_print");
 
 	unwind_protect_int (struct_indent);
 	unwind_protect_int (user_pref.struct_levels_to_print);
 
 	if (user_pref.struct_levels_to_print-- > 0)
 	  {
 	    output_buf.form ("\n%*s{\n", struct_indent, "");
 
@@ -2274,17 +2274,17 @@ TC_REP::print (ostream& output_buf)
 
 	    Pix p = a_map->first ();
 
 	    while (p)
 	      {
 		bool pad_after = false;
 
 		string key = a_map->key (p);
-		tree_constant val = a_map->contents (p);
+		octave_value val = a_map->contents (p);
 
 		a_map->next (p);
 
 		output_buf.form ("%*s%s =", struct_indent,
 				 "", key.c_str ());
 
 		if (val.print_as_scalar ())
 		  output_buf << " ";
@@ -2309,30 +2309,30 @@ TC_REP::print (ostream& output_buf)
 
 	    decrement_struct_indent ();
 
 	    output_buf.form ("%*s%s", struct_indent, "", "}\n");
 	  }
 	else
 	  output_buf << " <structure>\n";
 
-	run_unwind_frame ("TC_REP_print");
+	run_unwind_frame ("OCT_VAL_REP_print");
       }
       break;
 
     case unknown_constant:
     case magic_colon:
     case all_va_args:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::print_code (ostream& os)
+OCT_VAL_REP::print_code (ostream& os)
 {
   switch (type_tag)
     {
     case scalar_constant:
       if (orig_text.empty ())
 	octave_print_internal (os, scalar, 1);
       else
 	os << orig_text;
@@ -2385,27 +2385,27 @@ TC_REP::print_code (ostream& os)
     case map_constant:
     case unknown_constant:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::gripe_wrong_type_arg (const char *name,
-			      const tree_constant_rep& tcr) const
+OCT_VAL_REP::gripe_wrong_type_arg (const char *name,
+			      const octave_value_rep& tcr) const
 {
   if (name)
     ::error ("%s: wrong type argument `%s'", name, tcr.type_as_string ());
   else
     ::error ("wrong type argument `%s'", name, tcr.type_as_string ());
 }
 
 char *
-TC_REP::type_as_string (void) const
+OCT_VAL_REP::type_as_string (void) const
 {
   switch (type_tag)
     {
     case scalar_constant:
       return "real scalar";
 
     case matrix_constant:
       return "real matrix";
@@ -2428,179 +2428,179 @@ TC_REP::type_as_string (void) const
     case map_constant:
       return "structure";
 
     default:
       return "<unknown type>";
     }
 }
 
-tree_constant
-do_binary_op (tree_constant& a, tree_constant& b, tree_expression::type t)
+octave_value
+do_binary_op (octave_value& a, octave_value& b, tree_expression::type t)
 {
-  tree_constant retval;
+  octave_value retval;
 
   bool first_empty = (a.rows () == 0 || a.columns () == 0);
   bool second_empty = (b.rows () == 0 || b.columns () == 0);
 
   if (first_empty || second_empty)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("binary operation on empty matrix");
       else if (flag == 0)
 	{
 	  ::error ("invalid binary operation on empty matrix");
 	  return retval;
 	}
     }
 
-  tree_constant tmp_a = a.make_numeric ();
+  octave_value tmp_a = a.make_numeric ();
 
   if (error_state)
     return retval;
 
-  tree_constant tmp_b = b.make_numeric ();
+  octave_value tmp_b = b.make_numeric ();
 
   if (error_state)
     return retval;
 
-  TC_REP::constant_type a_type = tmp_a.const_type ();
-  TC_REP::constant_type b_type = tmp_b.const_type ();
+  OCT_VAL_REP::constant_type a_type = tmp_a.const_type ();
+  OCT_VAL_REP::constant_type b_type = tmp_b.const_type ();
 
   double d1, d2;
   Matrix m1, m2;
   Complex c1, c2;
   ComplexMatrix cm1, cm2;
 
   switch (a_type)
     {
-    case TC_REP::scalar_constant:
+    case OCT_VAL_REP::scalar_constant:
 
       d1 = tmp_a.double_value ();
 
       switch (b_type)
 	{
-	case TC_REP::scalar_constant:
+	case OCT_VAL_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (d1, d2, t);
 	  break;
 
-	case TC_REP::matrix_constant:
-	case TC_REP::char_matrix_constant:
+	case OCT_VAL_REP::matrix_constant:
+	case OCT_VAL_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (d1, m2, t);
 	  break;
 
-	case TC_REP::complex_scalar_constant:
+	case OCT_VAL_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (d1, c2, t);
 	  break;
 
-	case TC_REP::complex_matrix_constant:
+	case OCT_VAL_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
 	  retval = do_binary_op (d1, cm2, t);
 	  break;
 
 	default:
 	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
-    case TC_REP::matrix_constant:
-    case TC_REP::char_matrix_constant:
+    case OCT_VAL_REP::matrix_constant:
+    case OCT_VAL_REP::char_matrix_constant:
 
       m1 = tmp_a.matrix_value ();
 
       switch (b_type)
 	{
-	case TC_REP::scalar_constant:
+	case OCT_VAL_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (m1, d2, t);
 	  break;
 
-	case TC_REP::matrix_constant:
-	case TC_REP::char_matrix_constant:
+	case OCT_VAL_REP::matrix_constant:
+	case OCT_VAL_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (m1, m2, t);
 	  break;
 
-	case TC_REP::complex_scalar_constant:
+	case OCT_VAL_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (m1, c2, t);
 	  break;
 
-	case TC_REP::complex_matrix_constant:
+	case OCT_VAL_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
 	  retval = do_binary_op (m1, cm2, t);
 	  break;
 
 	default:
 	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
-    case TC_REP::complex_scalar_constant:
+    case OCT_VAL_REP::complex_scalar_constant:
 
       c1 = tmp_a.complex_value ();
 
       switch (b_type)
 	{
-	case TC_REP::scalar_constant:
+	case OCT_VAL_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (c1, d2, t);
 	  break;
 
-	case TC_REP::matrix_constant:
-	case TC_REP::char_matrix_constant:
+	case OCT_VAL_REP::matrix_constant:
+	case OCT_VAL_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (c1, m2, t);
 	  break;
 
-	case TC_REP::complex_scalar_constant:
+	case OCT_VAL_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (c1, c2, t);
 	  break;
 
-	case TC_REP::complex_matrix_constant:
+	case OCT_VAL_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
 	  retval = do_binary_op (c1, cm2, t);
 	  break;
 
 	default:
 	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
 
       cm1 = tmp_a.complex_matrix_value ();
 
       switch (b_type)
 	{
-	case TC_REP::scalar_constant:
+	case OCT_VAL_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (cm1, d2, t);
 	  break;
 
-	case TC_REP::matrix_constant:
-	case TC_REP::char_matrix_constant:
+	case OCT_VAL_REP::matrix_constant:
+	case OCT_VAL_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (cm1, m2, t);
 	  break;
 
-	case TC_REP::complex_scalar_constant:
+	case OCT_VAL_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (cm1, c2, t);
 	  break;
 
-	case TC_REP::complex_matrix_constant:
+	case OCT_VAL_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
 	  retval = do_binary_op (cm1, cm2, t);
 	  break;
 
 	default:
 	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
@@ -2609,56 +2609,56 @@ do_binary_op (tree_constant& a, tree_con
     default:
       gripe_wrong_type_arg_for_binary_op (tmp_a);
       break;
     }
 
   return retval;
 }
 
-tree_constant
-do_unary_op (tree_constant& a, tree_expression::type t)
+octave_value
+do_unary_op (octave_value& a, tree_expression::type t)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (a.rows () == 0 || a.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("unary operation on empty matrix");
       else if (flag == 0)
 	{
 	  ::error ("invalid unary operation on empty matrix");
 	  return retval;
 	}
     }
 
-  tree_constant tmp_a = a.make_numeric ();
+  octave_value tmp_a = a.make_numeric ();
 
   if (error_state)
     return retval;
 
   switch (tmp_a.const_type ())
     {
-    case TC_REP::scalar_constant:
+    case OCT_VAL_REP::scalar_constant:
       retval = do_unary_op (tmp_a.double_value (), t);
       break;
 
-    case TC_REP::matrix_constant:
+    case OCT_VAL_REP::matrix_constant:
       {
 	Matrix m = tmp_a.matrix_value ();
 	retval = do_unary_op (m, t);
       }
       break;
 
-    case TC_REP::complex_scalar_constant:
+    case OCT_VAL_REP::complex_scalar_constant:
       retval = do_unary_op (tmp_a.complex_value (), t);
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp_a.complex_matrix_value ();
 	retval = do_unary_op (m, t);
       }
       break;
 
     default:
       gripe_wrong_type_arg_for_unary_op (tmp_a);
@@ -2666,174 +2666,174 @@ do_unary_op (tree_constant& a, tree_expr
     }
 
   return retval;
 }
 
 // Indexing operations for the tree-constant representation class.
 
 void
-TC_REP::clear_index (void)
+OCT_VAL_REP::clear_index (void)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->clear_index ();
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
       complex_matrix->clear_index ();
       break;
 
     case char_matrix_constant:
     case char_matrix_constant_str:
       char_matrix->clear_index ();
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 #if 0
 void
-TC_REP::set_index (double d)
+OCT_VAL_REP::set_index (double d)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->set_index (d);
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
       complex_matrix->set_index (d);
       break;
 
-    case TC_REP::char_matrix_constant:
-    case TC_REP::char_matrix_constant_str:
+    case OCT_VAL_REP::char_matrix_constant:
+    case OCT_VAL_REP::char_matrix_constant_str:
       char_matrix->set_index (d);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 #endif
 
 void
-TC_REP::set_index (const Range& r)
+OCT_VAL_REP::set_index (const Range& r)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->set_index (r);
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
       complex_matrix->set_index (r);
       break;
 
-    case TC_REP::char_matrix_constant:
-    case TC_REP::char_matrix_constant_str:
+    case OCT_VAL_REP::char_matrix_constant:
+    case OCT_VAL_REP::char_matrix_constant_str:
       char_matrix->set_index (r);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::set_index (const ColumnVector& v)
+OCT_VAL_REP::set_index (const ColumnVector& v)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->set_index (v);
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
       complex_matrix->set_index (v);
       break;
 
-    case TC_REP::char_matrix_constant:
-    case TC_REP::char_matrix_constant_str:
+    case OCT_VAL_REP::char_matrix_constant:
+    case OCT_VAL_REP::char_matrix_constant_str:
       char_matrix->set_index (v);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::set_index (const Matrix& m)
+OCT_VAL_REP::set_index (const Matrix& m)
 {
   int nr = m.rows ();
   int nc = m.cols ();
 
   if (nr <= 1 || nc <= 1
       || user_pref.do_fortran_indexing)
     {
       switch (type_tag)
 	{
 	case matrix_constant:
 	  matrix->set_index (m);
 	  break;
 
-	case TC_REP::complex_matrix_constant:
+	case OCT_VAL_REP::complex_matrix_constant:
 	  complex_matrix->set_index (m);
 	  break;
 
-	case TC_REP::char_matrix_constant:
-	case TC_REP::char_matrix_constant_str:
+	case OCT_VAL_REP::char_matrix_constant:
+	case OCT_VAL_REP::char_matrix_constant_str:
 	  char_matrix->set_index (m);
 	  break;
 
 	default:
 	  panic_impossible ();
 	  break;
 	}
     }
   else
     ::error ("invalid matrix used as index");
 }
 
 // XXX FIXME XXX -- this should probably be handled some other way...
 // The arg here is expected to be ':'.
 void
-TC_REP::set_index (char c)
+OCT_VAL_REP::set_index (char c)
 {
   switch (type_tag)
     {
     case matrix_constant:
       matrix->set_index (c);
       break;
 
-    case TC_REP::complex_matrix_constant:
+    case OCT_VAL_REP::complex_matrix_constant:
       complex_matrix->set_index (c);
       break;
 
-    case TC_REP::char_matrix_constant:
-    case TC_REP::char_matrix_constant_str:
+    case OCT_VAL_REP::char_matrix_constant:
+    case OCT_VAL_REP::char_matrix_constant_str:
       char_matrix->set_index (c);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::set_index (const Octave_object& args, bool rhs_is_complex)
+OCT_VAL_REP::set_index (const octave_value_list& args, bool rhs_is_complex)
 {
   switch (type_tag)
     {
     case unknown_constant:
     case scalar_constant:
     case complex_scalar_constant:
     case range_constant:
       convert_to_matrix_type (rhs_is_complex);
@@ -2842,17 +2842,17 @@ TC_REP::set_index (const Octave_object& 
     default:
       break;
     }
 
   int n = args.length ();
 
   for (int i = 0; i < n; i++)
     {
-      tree_constant arg = args (i);
+      octave_value arg = args (i);
 
       switch (arg.const_type ())
 	{
 	case range_constant:
 	  set_index (arg.range_value ());
 	  break;
 
 	case magic_colon:
@@ -2868,31 +2868,31 @@ TC_REP::set_index (const Octave_object& 
 	{
 	  clear_index ();
 	  break;
 	}
     }
 }
 
 static inline bool
-valid_scalar_indices (const Octave_object& args)
+valid_scalar_indices (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (! args(i).valid_as_scalar_index ())
       return false;
 
   return true;
 }
 
-tree_constant
-TC_REP::do_index (const Octave_object& args)
+octave_value
+OCT_VAL_REP::do_index (const octave_value_list& args)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   bool originally_scalar_type = is_scalar_type ();
 
   if (originally_scalar_type && valid_scalar_indices (args))
     {
@@ -2931,31 +2931,31 @@ TC_REP::do_index (const Octave_object& a
 	      retval = ComplexMatrix (complex_matrix->value ());
 	      break;
 
 	    case char_matrix_constant:
 	      retval = charMatrix (char_matrix->value ());
 	      break;
 
 	    case char_matrix_constant_str:
-	      retval = tree_constant (charMatrix (char_matrix->value ()), 1);
+	      retval = octave_value (charMatrix (char_matrix->value ()), 1);
 	      break;
 
 	    default:
 	      error ("can't index %s variables", type_as_string ());
 	      break;
 	    }
 	}
     }
 
   return retval;
 }
 
 void
-TC_REP::maybe_widen (TC_REP::constant_type rhs_type)
+OCT_VAL_REP::maybe_widen (OCT_VAL_REP::constant_type rhs_type)
 {
   switch (type_tag)
     {
     case matrix_constant:
       switch (rhs_type)
 	{
 	case complex_scalar_constant:
 	case complex_matrix_constant:
@@ -3019,23 +3019,23 @@ extern void assign (Array2<Complex>&, co
 extern void assign (Array2<Complex>&, const Array2<char>&);
 
 extern void assign (Array2<double>&, const Array2<double>&);
 extern void assign (Array2<double>&, const Array2<char>&);
 
 extern void assign (Array2<char>&, const Array2<char>&);
 
 void
-TC_REP::assign (tree_constant& rhs, const Octave_object& args)
+OCT_VAL_REP::assign (octave_value& rhs, const octave_value_list& args)
 {
   // XXX FIXME XXX -- we should probably have special cases for rhs
   // being a range type, since converting to a matrix can waste a lot
   // of memory.
 
-  tree_constant rhs_tmp = rhs;
+  octave_value rhs_tmp = rhs;
 
   if (! (is_string ()
 	 && (rhs_tmp.is_string ()
 	     || rhs_tmp.is_zero_by_zero ())))
     {
       rhs_tmp.force_numeric ();
 
       if (error_state)
@@ -3142,31 +3142,31 @@ TC_REP::assign (tree_constant& rhs, cons
   // Do the right thing for assignments like `x(1) = pi' when x is
   // undefined before the assignment.
 
   if (is_matrix_type () || is_range ())
     maybe_mutate ();
 }
 
 bool
-TC_REP::print_as_scalar (void)
+OCT_VAL_REP::print_as_scalar (void)
 {
   int nr = rows ();
   int nc = columns ();
 
   return (is_scalar_type ()
 	  || (is_string () && nr <= 1)
 	  || (is_matrix_type ()
 	      && ((nr == 1 && nc == 1)
 		  || nr == 0
 		  || nc == 0)));
 }
 
 bool
-TC_REP::print_as_structure (void)
+OCT_VAL_REP::print_as_structure (void)
 {
   return is_map ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -35,29 +35,29 @@ class ostream;
 
 #include "Range.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "pt-fvc.h"
 
 class Octave_map;
-class Octave_object;
+class octave_value_list;
 
 // Constants.
 
 class
-tree_constant : public tree_fvc
+octave_value : public tree_fvc
 {
 private:
 
-// The actual representation of the tree_constant.
+// The actual representation of the octave_value.
 
   class
-  tree_constant_rep
+  octave_value_rep
   {
   public:
 
     enum constant_type
       {
 	unknown_constant,
 	scalar_constant,
 	matrix_constant,
@@ -73,45 +73,45 @@ private:
 
     enum force_orient
       {
 	no_orient,
 	row_orient,
 	column_orient,
       };
 
-    tree_constant_rep (void);
+    octave_value_rep (void);
 
-    tree_constant_rep (double d);
-    tree_constant_rep (const Matrix& m);
-    tree_constant_rep (const DiagMatrix& d);
-    tree_constant_rep (const RowVector& v, int pcv);
-    tree_constant_rep (const ColumnVector& v, int pcv);
+    octave_value_rep (double d);
+    octave_value_rep (const Matrix& m);
+    octave_value_rep (const DiagMatrix& d);
+    octave_value_rep (const RowVector& v, int pcv);
+    octave_value_rep (const ColumnVector& v, int pcv);
 
-    tree_constant_rep (const Complex& c);
-    tree_constant_rep (const ComplexMatrix& m);
-    tree_constant_rep (const ComplexDiagMatrix& d);
-    tree_constant_rep (const ComplexRowVector& v, int pcv);
-    tree_constant_rep (const ComplexColumnVector& v, int pcv);
+    octave_value_rep (const Complex& c);
+    octave_value_rep (const ComplexMatrix& m);
+    octave_value_rep (const ComplexDiagMatrix& d);
+    octave_value_rep (const ComplexRowVector& v, int pcv);
+    octave_value_rep (const ComplexColumnVector& v, int pcv);
 
-    tree_constant_rep (const char *s);
-    tree_constant_rep (const string& s);
-    tree_constant_rep (const string_vector& s);
-    tree_constant_rep (const charMatrix& chm, bool is_string);
+    octave_value_rep (const char *s);
+    octave_value_rep (const string& s);
+    octave_value_rep (const string_vector& s);
+    octave_value_rep (const charMatrix& chm, bool is_string);
 
-    tree_constant_rep (double base, double limit, double inc);
-    tree_constant_rep (const Range& r);
+    octave_value_rep (double base, double limit, double inc);
+    octave_value_rep (const Range& r);
 
-    tree_constant_rep (const Octave_map& m);
+    octave_value_rep (const Octave_map& m);
 
-    tree_constant_rep (tree_constant_rep::constant_type t);
+    octave_value_rep (octave_value_rep::constant_type t);
 
-    tree_constant_rep (const tree_constant_rep& t);
+    octave_value_rep (const octave_value_rep& t);
 
-    ~tree_constant_rep (void);
+    ~octave_value_rep (void);
 
     void *operator new (size_t size);
     void operator delete (void *p, size_t size);
 
     int rows (void) const;
     int columns (void) const;
 
     bool is_defined (void) const
@@ -148,18 +148,18 @@ private:
       { return type_tag == map_constant; }
 
     bool is_magic_colon (void) const
       { return type_tag == magic_colon; }
 
     bool is_all_va_args (void) const
       { return type_tag == all_va_args; }
 
-    tree_constant all (void) const;
-    tree_constant any (void) const;
+    octave_value all (void) const;
+    octave_value any (void) const;
 
     bool is_real_type (void) const
       {
 	return (type_tag == scalar_constant
 		|| type_tag == matrix_constant
 		|| type_tag == range_constant
 		|| type_tag == char_matrix_constant
 		|| type_tag == char_matrix_constant_str);
@@ -212,28 +212,28 @@ private:
     Complex complex_value (bool frc_str_conv = false) const;
     ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const;
     charMatrix char_matrix_value (bool frc_str_conv = false) const;
     charMatrix all_strings (void) const;
     string string_value (void) const;
     Range range_value (void) const;
     Octave_map map_value (void) const;
 
-    tree_constant& lookup_map_element (const string& name,
+    octave_value& lookup_map_element (const string& name,
 				       bool insert = false,
 				       bool silent = false);
 
     ColumnVector vector_value (bool frc_str_conv = false,
 			       bool frc_vec_conv = false) const;
 
     ComplexColumnVector
     complex_vector_value (bool frc_str_conv = false,
 			  bool frc_vec_conv = false) const;
 
-    tree_constant convert_to_str (void) const;
+    octave_value convert_to_str (void) const;
 
     void convert_to_row_or_column_vector (void);
 
     void bump_value (tree_expression::type);
 
     void resize (int i, int j);
     void resize (int i, int j, double val);
 
@@ -242,59 +242,59 @@ private:
     void maybe_mutate (void);
 
     void print (void);
     void print (ostream& os);
 
     void print_code (ostream& os);
 
     void gripe_wrong_type_arg (const char *name,
-			       const tree_constant_rep& tcr) const;
+			       const octave_value_rep& tcr) const;
 
     char *type_as_string (void) const;
 
     // Binary and unary operations.
 
-    friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
-				       tree_expression::type t);
+    friend octave_value do_binary_op (octave_value& a, octave_value& b,
+				      tree_expression::type t);
 
-    friend tree_constant do_unary_op (tree_constant& a,
-				      tree_expression::type t);
+    friend octave_value do_unary_op (octave_value& a,
+				     tree_expression::type t);
 
     // We want to eliminate this.
 
     constant_type const_type (void) const { return type_tag; }
 
     // We want to get rid of these too:
 
     void force_numeric (bool frc_str_conv = false);
-    tree_constant make_numeric (bool frc_str_conv = false) const;
+    octave_value make_numeric (bool frc_str_conv = false) const;
 
     // But not this.
 
     void convert_to_matrix_type (bool make_complex);
 
     // Indexing and assignment.
 
     void clear_index (void);
 
     // void set_index (double d);
     void set_index (const Range& r);
     void set_index (const ColumnVector& v);
     void set_index (const Matrix& m);
     void set_index (char c);
 
-    void set_index (const Octave_object& args,
+    void set_index (const octave_value_list& args,
 		    bool rhs_is_complex = false);
 
-    tree_constant do_index (const Octave_object& args);
+    octave_value do_index (const octave_value_list& args);
 
     void maybe_widen (constant_type t);
 
-    void assign (tree_constant& rhs, const Octave_object& args);
+    void assign (octave_value& rhs, const octave_value_list& args);
 
     bool print_as_scalar (void);
 
     bool print_as_structure (void);
 
     // Data.
 
     union
@@ -302,30 +302,30 @@ private:
 	double scalar;			// A real scalar constant.
 	Matrix *matrix;			// A real matrix constant.
 	Complex *complex_scalar;	// A real scalar constant.
 	ComplexMatrix *complex_matrix;	// A real matrix constant.
 	charMatrix *char_matrix;	// A character string constant.
 	Range *range;			// A set of evenly spaced values.
 	Octave_map *a_map;		// An associative array.
 
-	tree_constant_rep *freeptr;	// For custom memory management.
+	octave_value_rep *freeptr;	// For custom memory management.
       };
 
     constant_type type_tag;
 
     int count;
 
     string orig_text;
   };
 
   union
     {
-      tree_constant *freeptr;  // For custom memory management.
-      tree_constant_rep *rep;  // The real representation.
+      octave_value *freeptr;  // For custom memory management.
+      octave_value_rep *rep;  // The real representation.
     };
 
 public:
 
   enum magic_colon { magic_colon_t };
   enum all_va_args { all_va_args_t };
 
   // Constructors.  It is possible to create the following types of
@@ -346,133 +346,133 @@ public:
   //                  ComplexColumnVector
   // char matrix      charMatrix
   // string           char* (null terminated)
   //                  string
   //                  charMatrix
   // range            double, double, double
   //                  Range
   // map              Octave_map
-  // magic colon      tree_constant::magic_colon
-  // all_va_args      tree_constant::all_va_args
+  // magic colon      octave_value::magic_colon
+  // all_va_args      octave_value::all_va_args
 
-  tree_constant (void) : tree_fvc ()
-    { rep = new tree_constant_rep (); rep->count = 1; }
+  octave_value (void) : tree_fvc ()
+    { rep = new octave_value_rep (); rep->count = 1; }
 
-  tree_constant (double d, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new tree_constant_rep (d); rep->count = 1; }
+  octave_value (double d, int l = -1, int c = -1) : tree_fvc (l, c)
+    { rep = new octave_value_rep (d); rep->count = 1; }
 
-  tree_constant (const Matrix& m) : tree_fvc ()
-    { rep = new tree_constant_rep (m); rep->count = 1; }
+  octave_value (const Matrix& m) : tree_fvc ()
+    { rep = new octave_value_rep (m); rep->count = 1; }
 
-  tree_constant (const DiagMatrix& d) : tree_fvc ()
-    { rep = new tree_constant_rep (d); rep->count = 1; }
+  octave_value (const DiagMatrix& d) : tree_fvc ()
+    { rep = new octave_value_rep (d); rep->count = 1; }
 
-  tree_constant (const RowVector& v, int pcv = -1) : tree_fvc ()
-    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+  octave_value (const RowVector& v, int pcv = -1) : tree_fvc ()
+    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
 
-  tree_constant (const ColumnVector& v, int pcv = -1) : tree_fvc ()
-    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+  octave_value (const ColumnVector& v, int pcv = -1) : tree_fvc ()
+    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
 
-  tree_constant (const Complex& C, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new tree_constant_rep (C); rep->count = 1; }
+  octave_value (const Complex& C, int l = -1, int c = -1) : tree_fvc (l, c)
+    { rep = new octave_value_rep (C); rep->count = 1; }
 
-  tree_constant (const ComplexMatrix& m) : tree_fvc ()
-    { rep = new tree_constant_rep (m); rep->count = 1; }
+  octave_value (const ComplexMatrix& m) : tree_fvc ()
+    { rep = new octave_value_rep (m); rep->count = 1; }
 
-  tree_constant (const ComplexDiagMatrix& d) : tree_fvc ()
-    { rep = new tree_constant_rep (d); rep->count = 1; }
+  octave_value (const ComplexDiagMatrix& d) : tree_fvc ()
+    { rep = new octave_value_rep (d); rep->count = 1; }
 
-  tree_constant (const ComplexRowVector& v, int pcv = -1) : tree_fvc ()
-    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+  octave_value (const ComplexRowVector& v, int pcv = -1) : tree_fvc ()
+    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
 
-  tree_constant (const ComplexColumnVector& v, int pcv = -1) : tree_fvc () 
-    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+  octave_value (const ComplexColumnVector& v, int pcv = -1) : tree_fvc () 
+    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
 
-  tree_constant (const char *s, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new tree_constant_rep (s); rep->count = 1; }
+  octave_value (const char *s, int l = -1, int c = -1) : tree_fvc (l, c)
+    { rep = new octave_value_rep (s); rep->count = 1; }
 
-  tree_constant (const string& s, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new tree_constant_rep (s); rep->count = 1; }
+  octave_value (const string& s, int l = -1, int c = -1) : tree_fvc (l, c)
+    { rep = new octave_value_rep (s); rep->count = 1; }
 
-  tree_constant (const string_vector& s, int l = -1, int c = -1)
+  octave_value (const string_vector& s, int l = -1, int c = -1)
     : tree_fvc (l, c)
-    { rep = new tree_constant_rep (s); rep->count = 1; }
+    { rep = new octave_value_rep (s); rep->count = 1; }
 
-  tree_constant (const charMatrix& chm, bool is_string = false) : tree_fvc ()
-    { rep = new tree_constant_rep (chm, is_string); rep->count = 1; }
+  octave_value (const charMatrix& chm, bool is_string = false) : tree_fvc ()
+    { rep = new octave_value_rep (chm, is_string); rep->count = 1; }
 
-  tree_constant (double base, double limit, double inc) : tree_fvc ()
-    { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
+  octave_value (double base, double limit, double inc) : tree_fvc ()
+    { rep = new octave_value_rep (base, limit, inc); rep->count = 1; }
 
-  tree_constant (const Range& r) : tree_fvc ()
-    { rep = new tree_constant_rep (r); rep->count = 1; }
+  octave_value (const Range& r) : tree_fvc ()
+    { rep = new octave_value_rep (r); rep->count = 1; }
 
-  tree_constant (const Octave_map& m) : tree_fvc ()
-    { rep = new tree_constant_rep (m); rep->count = 1; }
+  octave_value (const Octave_map& m) : tree_fvc ()
+    { rep = new octave_value_rep (m); rep->count = 1; }
 
-  tree_constant (tree_constant::magic_colon) : tree_fvc ()
+  octave_value (octave_value::magic_colon) : tree_fvc ()
     {
-      tree_constant_rep::constant_type tmp;
-      tmp = tree_constant_rep::magic_colon;
-      rep = new tree_constant_rep (tmp);
+      octave_value_rep::constant_type tmp;
+      tmp = octave_value_rep::magic_colon;
+      rep = new octave_value_rep (tmp);
       rep->count = 1;
     }
 
-  tree_constant (tree_constant::all_va_args) : tree_fvc ()
+  octave_value (octave_value::all_va_args) : tree_fvc ()
     {
-      tree_constant_rep::constant_type tmp;
-      tmp = tree_constant_rep::all_va_args;
-      rep = new tree_constant_rep (tmp);
+      octave_value_rep::constant_type tmp;
+      tmp = octave_value_rep::all_va_args;
+      rep = new octave_value_rep (tmp);
       rep->count = 1;
     }
 
   // Copy constructor.
 
-  tree_constant (const tree_constant& a) : tree_fvc ()
+  octave_value (const octave_value& a) : tree_fvc ()
     { rep = a.rep; rep->count++; }
 
   // Delete the representation of this constant if the count drops to
   // zero.
 
-  ~tree_constant (void);
+  ~octave_value (void);
 
   void *operator new (size_t size);
   void operator delete (void *p, size_t size);
 
   // Simple assignment.
 
-  tree_constant operator = (const tree_constant& a);
+  octave_value operator = (const octave_value& a);
 
   // Indexed assignment.
 
-  tree_constant assign (tree_constant& rhs, const Octave_object& args)
+  octave_value assign (octave_value& rhs, const octave_value_list& args)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
-	  rep = new tree_constant_rep (*rep);
+	  rep = new octave_value_rep (*rep);
 	  rep->count = 1;
 	}
 
       rep->assign (rhs, args);
 
       return *this;
     }
 
   // Simple structure assignment.
 
-  tree_constant assign_map_element (SLList<string>& list,
-				    tree_constant& rhs);
+  octave_value assign_map_element (SLList<string>& list,
+				    octave_value& rhs);
 
   // Indexed structure assignment.
 
-  tree_constant assign_map_element (SLList<string>& list,
-				    tree_constant& rhs,
-				    const Octave_object& args);
+  octave_value assign_map_element (SLList<string>& list,
+				    octave_value& rhs,
+				    const octave_value_list& args);
 
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const { return true; }
 
   // Size.
 
   int rows (void) const { return rep->rows (); }
@@ -496,18 +496,18 @@ public:
   bool is_string (void) const { return rep->is_string (); }
   bool is_range (void) const { return rep->is_range (); }
   bool is_map (void) const { return rep->is_map (); }
   bool is_magic_colon (void) const { return rep->is_magic_colon (); }
   bool is_all_va_args (void) const { return rep->is_all_va_args (); }
 
   // Are any or all of the elements in this constant nonzero?
 
-  tree_constant all (void) const { return rep->all (); }
-  tree_constant any (void) const { return rep->any (); }
+  octave_value all (void) const { return rep->all (); }
+  octave_value any (void) const { return rep->any (); }
 
   // Other type stuff.
 
   bool is_real_type (void) const { return rep->is_real_type (); }
 
   bool is_complex_type (void) const { return rep->is_complex_type (); }
 
   bool is_scalar_type (void) const { return rep->is_scalar_type (); }
@@ -562,87 +562,87 @@ public:
   string string_value (void) const
     { return rep->string_value (); }
 
   Range range_value (void) const
     { return rep->range_value (); }
 
   Octave_map map_value (void) const;
 
-  tree_constant lookup_map_element (const string& ref,
+  octave_value lookup_map_element (const string& ref,
 				    bool insert = false,
 				    bool silent = false);
 
-  tree_constant lookup_map_element (SLList<string>& list,
+  octave_value lookup_map_element (SLList<string>& list,
 				    bool insert = false,
 				    bool silent = false);
 
   ColumnVector vector_value (bool /* frc_str_conv */ = false,
 			     bool /* frc_vec_conv */ = false) const 
     { return rep->vector_value (); }
 
   ComplexColumnVector
   complex_vector_value (bool /* frc_str_conv */ = false,
 			bool /* frc_vec_conv */ = false) const
     { return rep->complex_vector_value (); }
 
   // Binary and unary operations.
 
-  friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
+  friend octave_value do_binary_op (octave_value& a, octave_value& b,
 				     tree_expression::type t);
 
-  friend tree_constant do_unary_op (tree_constant& a,
+  friend octave_value do_unary_op (octave_value& a,
 				    tree_expression::type t);
 
   // Conversions.  These should probably be private.  If a user of this
   // class wants a certain kind of constant, he should simply ask for
   // it, and we should convert it if possible.
 
-  tree_constant convert_to_str (void)
+  octave_value convert_to_str (void)
     { return rep->convert_to_str (); }
 
   void convert_to_row_or_column_vector (void)
     { rep->convert_to_row_or_column_vector (); }
 
   // Increment or decrement this constant.
 
   void bump_value (tree_expression::type et)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
-	  rep = new tree_constant_rep (*rep);
+	  rep = new octave_value_rep (*rep);
 	  rep->count = 1;
 	}
 
       rep->bump_value (et);
     }
 
   void print (void);
   void print (ostream& os) { rep->print (os); }
 
   void print_with_name (const string& name, bool print_padding = true);
   void print_with_name (ostream& os, const string& name,
 			bool print_padding = true);
 
   // Evaluate this constant, possibly converting complex to real, or
   // matrix to scalar, etc.
 
-  tree_constant eval (bool print_result)
+  octave_value eval (bool print_result)
     {
       if (print_result)
 	{
 	  rep->maybe_mutate ();  // XXX FIXME XXX -- is this necessary?
 	  print ();
 	}
 
       return *this;
     }
 
-  Octave_object eval (bool, int, const Octave_object&);
+  octave_value_list eval (bool, int, const octave_value_list&);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
   void stash_original_text (const string& s)
     { rep->stash_original_text (s); }
 
   // Pretty print this constant.
@@ -653,34 +653,34 @@ public:
     { return rep->type_as_string (); }
 
   // We really do need this, and it should be private:
 
 private:
 
   void make_unique (void);
 
-  tree_constant_rep *make_unique_map (void);
+  octave_value_rep *make_unique_map (void);
 
   // We want to eliminate this, or at least make it private.
 
-  tree_constant_rep::constant_type const_type (void) const
+  octave_value_rep::constant_type const_type (void) const
     { return rep->const_type (); }
 
   void convert_to_matrix_type (bool make_complex)
     { rep->convert_to_matrix_type (make_complex); }
 
   // Can we make these go away?
 
   // These need better names, since a range really is a numeric type.
 
   void force_numeric (bool frc_str_conv = false)
     { rep->force_numeric (frc_str_conv); }
 
-  tree_constant make_numeric (bool frc_str_conv = false) const
+  octave_value make_numeric (bool frc_str_conv = false) const
     {
       if (is_numeric_type ())
 	return *this;
       else
 	return rep->make_numeric (frc_str_conv);
     }
 
   bool print_as_scalar (void) { return rep->print_as_scalar (); }
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -39,17 +39,17 @@ Software Foundation, 59 Temple Place - S
 
 // Expressions.
 
 bool
 tree_expression::is_logically_true (const char *warn_for)
 {
   bool expr_value = false;
 
-  tree_constant t1 = eval (false);
+  octave_value t1 = eval (false);
 
   if (! error_state)
     {
       if (t1.is_defined ())
 	{
 	  if (t1.rows () == 0 || t1.columns () == 0)
 	    {
 	      t1 = 0.0;
@@ -61,17 +61,17 @@ tree_expression::is_logically_true (cons
 		{
 		  ::error ("%s: empty matrix used in conditional expression",
 			   warn_for);
 		  return expr_value;
 		}
 	    }
 	  else if (! t1.is_scalar_type ())
 	    {
-	      tree_constant t2 = t1.all ();
+	      octave_value t2 = t1.all ();
 	      if (! error_state)
 		t1 = t2.all ();
 	    }
 
 	  if (! error_state)
 	    {
 	      if (t1.is_real_scalar ())
 		expr_value = t1.double_value () != 0.0;
@@ -94,20 +94,20 @@ tree_expression::is_logically_true (cons
 }
 
 void
 tree_expression::mark_for_possible_ans_assign (void)
 {
   panic_impossible ();
 }
 
-tree_constant
+octave_value
 tree_expression::eval (bool /* print */)
 {
   panic ("invalid evaluation of generic expression");
-  return tree_constant ();
+  return octave_value ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -22,17 +22,17 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_expr_h)
 #define octave_tree_expr_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-class tree_constant;
+class octave_value;
 
 #include "pt-base.h"
 
 // A base class for expressions.
 
 class
 tree_expression : public tree
 {
@@ -107,17 +107,17 @@ public:
 
   virtual bool is_prefix_expression (void) const
     { return false; }
 
   virtual bool is_logically_true (const char *);
 
   virtual void mark_for_possible_ans_assign (void);
 
-  virtual tree_constant eval (bool print) = 0;
+  virtual octave_value eval (bool print) = 0;
 
 protected:
   type etype;
 };
 
 #endif
 
 /*
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -54,35 +54,35 @@ extern int breaking;
 
 // Prefix expressions.
 
 tree_prefix_expression::~tree_prefix_expression (void)
 {
   delete id;
 }
 
-tree_constant
+octave_value
 tree_prefix_expression::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (id)
     {
       id->bump_value (etype);
       if (error_state)
 	eval_error ();
       else
 	{
 	  retval = id->eval (print);
 	  if (error_state)
 	    {
-	      retval = tree_constant ();
+	      retval = octave_value ();
 	      if (error_state)
 		eval_error ();
 	    }
 	}
     }
   return retval;
 }
 
@@ -138,31 +138,31 @@ tree_prefix_expression::print_code (ostr
 
 // Postfix expressions.
 
 tree_postfix_expression::~tree_postfix_expression (void)
 {
   delete id;
 }
 
-tree_constant
+octave_value
 tree_postfix_expression::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (id)
     {
       retval = id->eval (print);
       id->bump_value (etype);
       if (error_state)
 	{
-	  retval = tree_constant ();
+	  retval = octave_value ();
 	  if (error_state)
 	    eval_error ();
 	}
     }
   return retval;
 }
 
 char *
@@ -212,41 +212,41 @@ tree_postfix_expression::print_code (ost
   os << oper ();
 
   if (in_parens)
     os << ")";
 }
 
 // Unary expressions.
 
-tree_constant
+octave_value
 tree_unary_expression::eval (bool /* print */)
 {
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
-  tree_constant retval;
+  octave_value retval;
 
   switch (etype)
     {
     case tree_expression::not:
     case tree_expression::uminus:
     case tree_expression::hermitian:
     case tree_expression::transpose:
       if (op)
 	{
-	  tree_constant u = op->eval (false);
+	  octave_value u = op->eval (false);
 	  if (error_state)
 	    eval_error ();
 	  else if (u.is_defined ())
 	    {
 	      retval = do_unary_op (u, etype);
 	      if (error_state)
 		{
-		  retval = tree_constant ();
+		  retval = octave_value ();
 		  if (error_state)
 		    eval_error ();
 		}
 	    }
 	}
       break;
 
     default:
@@ -330,23 +330,23 @@ tree_unary_expression::print_code (ostre
     }
 
   if (in_parens)
     os << ")";
 }
 
 // Binary expressions.
  
-tree_constant
+octave_value
 tree_binary_expression::eval (bool /* print */)
 {
   if (error_state)
-    return tree_constant ();
+    return octave_value ();
 
-  tree_constant retval;
+  octave_value retval;
 
   switch (etype)
     {
     case tree_expression::add:
     case tree_expression::subtract:
     case tree_expression::multiply:
     case tree_expression::el_mul:
     case tree_expression::divide:
@@ -360,45 +360,45 @@ tree_binary_expression::eval (bool /* pr
     case tree_expression::cmp_eq:
     case tree_expression::cmp_ge:
     case tree_expression::cmp_gt:
     case tree_expression::cmp_ne:
     case tree_expression::and:
     case tree_expression::or:
       if (op1)
 	{
-	  tree_constant a = op1->eval (false);
+	  octave_value a = op1->eval (false);
 	  if (error_state)
 	    eval_error ();
 	  else if (a.is_defined () && op2)
 	    {
-	      tree_constant b = op2->eval (false);
+	      octave_value b = op2->eval (false);
 	      if (error_state)
 		eval_error ();
 	      else if (b.is_defined ())
 		{
 		  retval = do_binary_op (a, b, etype);
 		  if (error_state)
 		    {
-		      retval = tree_constant ();
+		      retval = octave_value ();
 		      if (error_state)
 			eval_error ();
 		    }
 		}
 	    }
 	}
       break;
 
     case tree_expression::and_and:
     case tree_expression::or_or:
       {
 	bool result = false;
 	if (op1)
 	  {
-	    tree_constant a = op1->eval (false);
+	    octave_value a = op1->eval (false);
 	    if (error_state)
 	      {
 		eval_error ();
 		break;
 	      }
 
 	    bool a_true = a.is_true ();
 	    if (error_state)
@@ -421,33 +421,33 @@ tree_binary_expression::eval (bool /* pr
 		  {
 		    result = false;
 		    goto done;
 		  }
 	      }
 
 	    if (op2)
 	      {
-		tree_constant b = op2->eval (false);
+		octave_value b = op2->eval (false);
 		if (error_state)
 		  {
 		    eval_error ();
 		    break;
 		  }
 
 		result = b.is_true ();
 		if (error_state)
 		  {
 		    eval_error ();
 		    break;
 		  }
 	      }
 	  }
       done:
-	retval = tree_constant ((double) result);
+	retval = octave_value ((double) result);
       }
       break;
 
     default:
       ::error ("binary operator %d not implemented", etype);
       break;
     }
 
@@ -623,29 +623,29 @@ tree_simple_assignment_expression::left_
 }
 
 tree_identifier *
 tree_simple_assignment_expression::left_hand_side_id (void)
 {
   return lhs->ident ();
 }
 
-tree_constant
+octave_value
 tree_simple_assignment_expression::eval (bool print)
 {
   assert (etype == tree_expression::assignment);
 
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (rhs)
     {
-      tree_constant rhs_val = rhs->eval (false);
+      octave_value rhs_val = rhs->eval (false);
       if (error_state)
 	{
 	  eval_error ();
 	}
       else if (rhs_val.is_undefined ())
 	{
 	  error ("value on right hand side of assignment is undefined");
 	  eval_error ();
@@ -655,17 +655,17 @@ tree_simple_assignment_expression::eval 
 	  retval = lhs->assign (rhs_val);
 	  if (error_state)
 	    eval_error ();
 	}
       else
 	{
 	  // Extract the arguments into a simple vector.
 
-	  Octave_object args = index->convert_to_const_vector ();
+	  octave_value_list args = index->convert_to_const_vector ();
 
 	  if (error_state)
 	    eval_error ();
 	  else
 	    {
 	      int nargin = args.length ();
 
 	      if (error_state)
@@ -752,25 +752,25 @@ tree_colon_expression::chain (tree_expre
       op3 = op2;	// Stupid syntax.
       op2 = t;
 
       retval = this;
     }
   return retval;
 }
 
-tree_constant
+octave_value
 tree_colon_expression::eval (bool /* print */)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state || ! op1 || ! op2)
     return retval;
 
-  tree_constant tmp = op1->eval (false);
+  octave_value tmp = op1->eval (false);
 
   if (tmp.is_undefined ())
     {
       eval_error ("invalid null value in colon expression");
       return retval;
     }
 
   double base = tmp.double_value ();
@@ -815,23 +815,23 @@ tree_colon_expression::eval (bool /* pri
       if (error_state)
 	{
 	  error ("colon expression elements must be scalars");
 	  eval_error ("evaluating colon expression");
 	  return retval;
 	}
     }
 
-  retval = tree_constant (base, limit, inc);
+  retval = octave_value (base, limit, inc);
 
   if (error_state)
     {
       if (error_state)
 	eval_error ("evaluating colon expression");
-      return tree_constant ();
+      return octave_value ();
     }
 
   return retval;
 }
 
 void
 tree_colon_expression::eval_error (const char *s)
 {
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -46,17 +46,17 @@ tree_prefix_expression : public tree_exp
     : tree_expression (l, c), id (0) { }
 
   tree_prefix_expression (tree_identifier *t, tree_expression::type et,
 			  int l = -1, int c = -1)
     : tree_expression (l, c, et), id (t) { }
 
   ~tree_prefix_expression (void);
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   void eval_error (void);
 
   bool is_prefix_expression (void) const
     { return true; }
 
   char *oper (void) const;
 
@@ -76,17 +76,17 @@ tree_postfix_expression : public tree_ex
     : tree_expression (l, c), id (0) { }
 
   tree_postfix_expression (tree_identifier *t, tree_expression::type et,
 			   int l = -1, int c = -1)
     : tree_expression (l, c, et), id (t) { }
 
   ~tree_postfix_expression (void);
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   void eval_error (void);
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
@@ -104,17 +104,17 @@ tree_unary_expression : public tree_expr
 
   tree_unary_expression (tree_expression *a, tree_expression::type t,
 			 int l = -1, int c = -1)
     : tree_expression (l, c, t), op (a) { }
 
   ~tree_unary_expression (void)
     { delete op; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   void eval_error (void);
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
@@ -135,17 +135,17 @@ tree_binary_expression : public tree_exp
     : tree_expression (l, c, t), op1 (a), op2 (b) { }
 
   ~tree_binary_expression (void)
     {
       delete op1;
       delete op2;
     }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   void eval_error (void);
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
@@ -205,17 +205,17 @@ private:
 
   bool left_hand_side_is_identifier_only (void);
 
   tree_identifier *left_hand_side_id (void);
 
   bool is_ans_assign (void)
     { return ans_ass; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   bool is_assignment_expression (void) const
     { return true; }
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
@@ -249,17 +249,17 @@ tree_colon_expression : public tree_expr
       delete op2;
       delete op3;
     }
 
   bool is_range_constant (void) const;
 
   tree_colon_expression *chain (tree_expression *t);
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   void eval_error (const char *s);
 
   void print_code (ostream& os);
 
  private:
   tree_expression *op1;
   tree_expression *op2;
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -60,22 +60,22 @@ tree_function::install_nargin_and_nargou
 {
   nargin_sr = sym_tab->lookup ("nargin", 1, 0);
   nargout_sr = sym_tab->lookup ("nargout", 1, 0);
 }
 
 void
 tree_function::bind_nargin_and_nargout (int nargin, int nargout)
 {
-  tree_constant *tmp;
+  octave_value *tmp;
 
-  tmp = new tree_constant (nargin);
+  tmp = new octave_value (nargin);
   nargin_sr->define (tmp);
 
-  tmp = new tree_constant (nargout);
+  tmp = new octave_value (nargout);
   nargout_sr->define (tmp);
 }
 
 tree_function::~tree_function (void)
 {
   delete param_list;
   delete ret_list;
   delete sym_tab;
@@ -152,34 +152,34 @@ tree_function::mark_as_system_fcn_file (
 }
 
 bool
 tree_function::takes_varargs (void) const
 {
   return (param_list && param_list->takes_varargs ());
 }
 
-tree_constant
+octave_value
 tree_function::octave_va_arg (void)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (curr_va_arg_number < num_args_passed)
     retval = args_passed (curr_va_arg_number++);
   else
     ::error ("va_arg: error getting arg number %d -- only %d provided",
 	     curr_va_arg_number + 1, num_args_passed);
 
   return retval;
 }
 
-Octave_object
+octave_value_list
 tree_function::octave_all_va_args (void)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   retval.resize (num_args_passed - num_named_args);
 
   int k = 0;
   for (int i = num_named_args; i < num_args_passed; i++)
     retval(k++) = args_passed(i);
 
   return retval;
@@ -187,39 +187,39 @@ tree_function::octave_all_va_args (void)
 
 bool
 tree_function::takes_var_return (void) const
 {
   return (ret_list && ret_list->takes_varargs ());
 }
 
 void
-tree_function::octave_vr_val (const tree_constant& val)
+tree_function::octave_vr_val (const octave_value& val)
 {
   assert (vr_list);
 
   vr_list->append (val);
 }
 
 void
 tree_function::stash_function_name (const string& s)
 {
   fcn_name = s;
 }
 
-tree_constant
+octave_value
 tree_function::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state || ! cmd_list)
     return retval;
 
-  Octave_object tmp_args;
-  Octave_object tmp = eval (print, 0, tmp_args);
+  octave_value_list tmp_args;
+  octave_value_list tmp = eval (print, 0, tmp_args);
 
   if (! error_state && tmp.length () > 0)
     retval = tmp(0);
 
   return retval;
 }
 
 // For unwind protect.
@@ -241,20 +241,20 @@ delete_vr_list (void *list)
 
 static void
 clear_symbol_table (void *table)
 {
   symbol_table *tmp = (symbol_table *) table;
   tmp->clear ();
 }
 
-Octave_object
-tree_function::eval (bool /* print */, int nargout, const Octave_object& args)
+octave_value_list
+tree_function::eval (bool /* print */, int nargout, const octave_value_list& args)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
   int nargin = args.length ();
@@ -328,17 +328,17 @@ tree_function::eval (bool /* print */, i
       = (user_pref.echo_executing_commands & ECHO_FUNCTIONS);
 
     if (echo_commands)
       print_code_function_header ();
 
     // Evaluate the commands that make up the function.
 
     bool pf = ! user_pref.silent_functions;
-    tree_constant last_computed_value = cmd_list->eval (pf);
+    octave_value last_computed_value = cmd_list->eval (pf);
 
     if (echo_commands)
       print_code_function_trailer ();
 
     if (returning)
       returning = 0;
 
     if (breaking)
@@ -351,17 +351,17 @@ tree_function::eval (bool /* print */, i
       }
     
     // Copy return values out.
 
     if (ret_list)
       {
 	if (nargout > 0 && user_pref.define_all_return_values)
 	  {
-	    tree_constant tmp = builtin_any_variable ("default_return_value");
+	    octave_value tmp = builtin_any_variable ("default_return_value");
 	    if (tmp.is_defined ())
 	      ret_list->initialize_undefined_elements (tmp);
 	  }
 
 	retval = ret_list->convert_to_const_vector (vr_list);
       }
     else if (user_pref.return_last_computed_value)
       retval(0) = last_computed_value;
@@ -485,17 +485,17 @@ tree_function::print_code_function_trail
 
   print_code_new_line (os);
 }
 
 DEFUN (va_arg, args, ,
   "va_arg (): return next argument in a function that takes a\n\
 variable number of parameters")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       if (curr_function)
 	{
 	  if (curr_function->takes_varargs ())
@@ -514,17 +514,17 @@ variable number of parameters")
 
   return retval;
 }
 
 DEFUN (va_start, args, ,
   "va_start (): reset the pointer to the list of optional arguments\n\
 to the beginning")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       if (curr_function)
 	{
 	  if (curr_function->takes_varargs ())
@@ -543,17 +543,17 @@ to the beginning")
 
   return retval;
 }
 
 DEFUN (vr_val, args, ,
   "vr_val (X): append X to the list of optional return values for a
 function that allows a variable number of return values")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (curr_function)
 	{
 	  if (curr_function->takes_var_return ())
diff --git a/src/pt-fcn.h b/src/pt-fcn.h
--- a/src/pt-fcn.h
+++ b/src/pt-fcn.h
@@ -102,49 +102,49 @@ public:
   bool is_system_fcn_file (void) const
     { return system_fcn_file; }
 
   bool takes_varargs (void) const;
 
   void octave_va_start (void)
     { curr_va_arg_number = num_named_args; }
 
-  tree_constant octave_va_arg (void);
+  octave_value octave_va_arg (void);
 
-  Octave_object octave_all_va_args (void);
+  octave_value_list octave_all_va_args (void);
 
   bool takes_var_return (void) const;
 
-  void octave_vr_val (const tree_constant& val);
+  void octave_vr_val (const octave_value& val);
 
   void stash_function_name (const string& s);
 
   string function_name (void)
     { return fcn_name; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   void traceback_error (void);
 
   void print_code (ostream& os);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
   tree_parameter_list *ret_list;
   symbol_table *sym_tab;
   tree_statement_list *cmd_list;
   string file_name;
   string fcn_name;
   time_t t_parsed;
   bool system_fcn_file;
   int num_named_args;
-  Octave_object args_passed;
+  octave_value_list args_passed;
   int num_args_passed;
   int curr_va_arg_number;
   tree_va_return_list *vr_list;
   symbol_record *nargin_sr;
   symbol_record *nargout_sr;
 
   void print_code_function_header (void);
   void print_code_function_header (ostream& os);
diff --git a/src/pt-fvc-base.cc b/src/pt-fvc-base.cc
--- a/src/pt-fvc-base.cc
+++ b/src/pt-fvc-base.cc
@@ -34,41 +34,41 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "oct-obj.h"
 #include "pt-const.h"
 #include "pt-fvc-base.h"
 
 // A base class for objects that can be evaluated with argument lists.
 
-tree_constant
-tree_fvc::assign (tree_constant&, const Octave_object&)
+octave_value
+tree_fvc::assign (octave_value&, const octave_value_list&)
 {
   panic_impossible ();
-  return tree_constant ();
+  return octave_value ();
 }
 
 string
 tree_fvc::name (void) const
 {
   string retval;
   panic_impossible ();
   return retval;
 }
 
 void
 tree_fvc::bump_value (tree_expression::type)
 {
   panic_impossible ();
 }
 
-tree_constant
+octave_value
 tree_fvc::lookup_map_element (SLList<string>&, bool, bool)
 {
-  static tree_constant retval;
+  static octave_value retval;
 
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("invalid structure reference");
   else
     ::error ("invalid structure reference near line %d column %d", l, c);
diff --git a/src/pt-fvc-base.h b/src/pt-fvc-base.h
--- a/src/pt-fvc-base.h
+++ b/src/pt-fvc-base.h
@@ -30,39 +30,39 @@ Software Foundation, 59 Temple Place - S
 #include <ctime>
 
 class ostream;
 
 #include <string>
 
 #include <SLList.h>
 
-class tree_constant;
-class Octave_object;
+class octave_value;
+class octave_value_list;
 
 #include "pt-mvr-base.h"
 
 // A base class for objects that can be evaluated with argument lists.
 
 class
 tree_fvc : public tree_multi_val_ret
 {
 public:
   tree_fvc (int l = -1, int c = -1) : tree_multi_val_ret (l, c) { }
 
   ~tree_fvc (void) { }
 
-  virtual tree_constant assign (tree_constant& t,
-				const Octave_object& args);
+  virtual octave_value assign (octave_value& t,
+				const octave_value_list& args);
 
   virtual string name (void) const;
 
   virtual void bump_value (tree_expression::type);
 
-  virtual tree_constant lookup_map_element (SLList<string>& list,
+  virtual octave_value lookup_map_element (SLList<string>& list,
 					    bool insert = false,
 					    bool silent = false);
 
   virtual string fcn_file_name (void)
     { return string (); }
 
   virtual time_t time_parsed (void);
 
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -74,17 +74,17 @@ any_element_greater_than (const Matrix& 
   return false;
 }
 
 // Make sure that all arguments have values.
 
 // Are any of the arguments `:'?
 
 static bool
-any_arg_is_magic_colon (const Octave_object& args)
+any_arg_is_magic_colon (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (args(i).is_magic_colon ())
 	return true;
 
   return false;
@@ -97,17 +97,17 @@ tree_identifier::name (void) const
 {
   string retval;
   if (sym)
     retval = sym->name ();
   return retval;
 }
 
 tree_identifier *
-tree_identifier::define (tree_constant *t)
+tree_identifier::define (octave_value *t)
 {
   int status = sym->define (t);
   return status ? this : 0;
 }
 
 tree_identifier *
 tree_identifier::define (tree_function *t)
 {
@@ -117,51 +117,51 @@ tree_identifier::define (tree_function *
 
 void
 tree_identifier::document (const string& s)
 {
   if (sym)
     sym->document (s);
 }
 
-tree_constant
-tree_identifier::assign (tree_constant& rhs)
+octave_value
+tree_identifier::assign (octave_value& rhs)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
 		 || sym->is_linked_to_global ()))
 	    {
 	      link_to_builtin_variable (sym);
 	    }
 	}
       else if (sym->is_function ())
 	{
 	  sym->clear ();
 	}
 
-      tree_constant *tmp = new tree_constant (rhs);
+      octave_value *tmp = new octave_value (rhs);
 
       if (sym->define (tmp))
 	retval = rhs;
       else
 	delete tmp;
     }
 
   return retval;
 }
 
-tree_constant
-tree_identifier::assign (tree_constant& rhs, const Octave_object& args)
+octave_value
+tree_identifier::assign (octave_value& rhs, const octave_value_list& args)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
 		 || sym->is_linked_to_global ()))
 	    {
@@ -184,94 +184,94 @@ tree_identifier::assign (tree_constant& 
 
 	  if (! user_pref.resize_on_range_error)
 	    {
 	      ::error ("indexed assignment to previously undefined variables");
 	      ::error ("is only possible when resize_on_range_error is true");
 	    }
 	  else
 	    {
-	      tree_constant *tmp = new tree_constant ();
+	      octave_value *tmp = new octave_value ();
 	      retval = tmp->assign (rhs, args);
 	      if (retval.is_defined ())
 		sym->define (tmp);
 	    }
 	}
     }
 
   return retval;
 }
 
-tree_constant
-tree_identifier::assign (SLList<string> list, tree_constant& rhs)
+octave_value
+tree_identifier::assign (SLList<string> list, octave_value& rhs)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
 
       tree_fvc *curr_val = sym->def ();
 
-      tree_constant *tmp = 0;
+      octave_value *tmp = 0;
       if (curr_val && curr_val->is_constant ())
-	tmp = (tree_constant *) curr_val;
+	tmp = (octave_value *) curr_val;
       else
 	{
-	  tmp = new tree_constant ();
+	  tmp = new octave_value ();
 	  if (! sym->define (tmp))
 	    {
 	      delete tmp;
 	      tmp = 0;
 	    }
 	}
 
       if (tmp)
 	retval = tmp->assign_map_element (list, rhs);
     }
 
   return retval;
 }
 
-tree_constant
-tree_identifier::assign (SLList<string> list, tree_constant& rhs,
-			 const Octave_object& args)
+octave_value
+tree_identifier::assign (SLList<string> list, octave_value& rhs,
+			 const octave_value_list& args)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
 
       if (sym->is_variable () && sym->is_defined ())
 	{
 	  tree_fvc *curr_val = sym->def ();
 
-	  tree_constant *tmp;
+	  octave_value *tmp;
 	  if (curr_val && curr_val->is_constant ())
-	    tmp = (tree_constant *) curr_val;
+	    tmp = (octave_value *) curr_val;
 	  else
 	    panic_impossible ();
 
 	  retval = tmp->assign_map_element (list, rhs, args);
 	}
       else
 	{
 	  assert (! sym->is_defined ());
 
 	  if (! user_pref.resize_on_range_error)
 	    {
 	      ::error ("indexed assignment to previously undefined variables");
 	      ::error ("is only possible when resize_on_range_error is true");
 	    }
 	  else
 	    {
-	      tree_constant *tmp = new tree_constant ();
+	      octave_value *tmp = new octave_value ();
 
 	      retval = tmp->assign_map_element (list, rhs, args);
 
 	      if (retval.is_defined ())
 		sym->define (tmp);
 	    }
 	}
     }
@@ -354,38 +354,38 @@ tree_identifier::link_to_global (void)
 
 void
 tree_identifier::mark_as_formal_parameter (void)
 {
   if (sym)
     sym->mark_as_formal_parameter ();
 }
 
-tree_constant
+octave_value
 tree_identifier::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   bool script_file_executed = false;
 
   tree_fvc *object_to_eval = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
       if (object_to_eval)
 	{
 	  int nargout = maybe_do_ans_assign ? 0 : 1;
 
 	  if (nargout)
 	    {
-	      Octave_object tmp_args;
-	      Octave_object tmp = object_to_eval->eval (0, nargout, tmp_args);
+	      octave_value_list tmp_args;
+	      octave_value_list tmp = object_to_eval->eval (0, nargout, tmp_args);
 
 	      if (tmp.length () > 0)
 		retval = tmp(0);
 	    }
 	  else
 	    retval = object_to_eval->eval (false);
 	}
       else
@@ -398,20 +398,20 @@ tree_identifier::eval (bool print)
 	bind_ans (retval, print);
       else if (print)
 	retval.print_with_name (name ());
     }
 
   return retval;
 }
 
-Octave_object
-tree_identifier::eval (bool print, int nargout, const Octave_object& args)
+octave_value_list
+tree_identifier::eval (bool print, int nargout, const octave_value_list& args)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (error_state)
     return retval;
 
   bool script_file_executed = false;
 
   tree_fvc *object_to_eval = do_lookup (script_file_executed);
 
@@ -486,46 +486,46 @@ tree_indirect_ref::name (void) const
 	  id_nm.append (".");
 	  id_nm.append (refs (p));
 	}
 
       return id_nm;
     }
 }
 
-tree_constant
-tree_indirect_ref::assign (tree_constant& t)
+octave_value
+tree_indirect_ref::assign (octave_value& t)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (refs.empty ())
     retval = id->assign (t);
   else
     retval = id->assign (refs, t);
 
   return retval;
 }
 
-tree_constant
-tree_indirect_ref::assign (tree_constant& t, const Octave_object& args)
+octave_value
+tree_indirect_ref::assign (octave_value& t, const octave_value_list& args)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (refs.empty ())
     retval = id->assign (t, args);
   else
     retval = id->assign (refs, t, args);
 
   return retval;
 }
 
-tree_constant
+octave_value
 tree_indirect_ref::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (refs.empty ())
     {
       retval = id->eval (print);
     }
@@ -544,37 +544,37 @@ tree_indirect_ref::eval (bool print)
 	}
       else
 	id->eval_undefined_error ();
     }
 
   return retval;
 }
 
-Octave_object
-tree_indirect_ref::eval (bool print, int nargout, const Octave_object& args)
+octave_value_list
+tree_indirect_ref::eval (bool print, int nargout, const octave_value_list& args)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (refs.empty ())
     {
       retval = id->eval (print, nargout, args);
     }
   else
     {
       bool script_file_executed;
 
       tree_fvc *object_to_eval = id->do_lookup (script_file_executed, 0);
 
       if (object_to_eval)
 	{
-	  tree_constant tmp = object_to_eval->lookup_map_element (refs);
+	  octave_value tmp = object_to_eval->lookup_map_element (refs);
 
 	  if (! error_state)
 	    {
 	      retval = tmp.eval (0, nargout, args);
 
 	      if (! error_state && print)
 		{
 		  tmp = retval (0);
@@ -627,46 +627,46 @@ tree_builtin::tree_builtin (Mapper_fcn& 
 
 tree_builtin::tree_builtin (Octave_builtin_fcn g_fcn, const string& nm)
 {
   is_mapper = 0;
   fcn = g_fcn;
   my_name = nm;
 }
 
-tree_constant
+octave_value
 tree_builtin::eval (bool /* print */)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (fcn)
     {
-      Octave_object args;
-      Octave_object tmp = (*fcn) (args, 0);
+      octave_value_list args;
+      octave_value_list tmp = (*fcn) (args, 0);
       if (tmp.length () > 0)
 	retval = tmp(0);
     }
   else if (is_mapper)
     {
       ::error ("%s: too few arguments", my_name.c_str ());
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
-static tree_constant
-apply_mapper_fcn (const tree_constant& arg, Mapper_fcn& m_fcn,
+static octave_value
+apply_mapper_fcn (const octave_value& arg, Mapper_fcn& m_fcn,
 		  bool /* print */)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (arg.is_real_type ())
     {
       if (arg.is_scalar_type ())
 	{
 	  double d = arg.double_value ();
 
 	  if (m_fcn.can_return_complex_for_real_arg
@@ -739,20 +739,20 @@ apply_mapper_fcn (const tree_constant& a
 	}
     }
   else
     gripe_wrong_type_arg ("mapper", arg);
 
   return retval;
 }
 
-Octave_object
-tree_builtin::eval (bool /* print */, int nargout, const Octave_object& args)
+octave_value_list
+tree_builtin::eval (bool /* print */, int nargout, const octave_value_list& args)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (error_state)
     return retval;
 
   int nargin = args.length ();
 
   if (fcn)
     {
@@ -765,17 +765,17 @@ tree_builtin::eval (bool /* print */, in
     {
 // XXX FIXME XXX -- should we just assume nargin_max == 1?
 //
 //      if (nargin > nargin_max)
 //	::error ("%s: too many arguments", my_name.c_str ());
 //      else
       if (nargin > 0 && args(0).is_defined ())
 	{
-	  tree_constant tmp = apply_mapper_fcn (args(0), mapper_fcn, 0);
+	  octave_value tmp = apply_mapper_fcn (args(0), mapper_fcn, 0);
 	  retval(0) = tmp;
 	}
       else
 	{
 	  ::error ("%s: too few arguments", my_name.c_str ());
 	}
     }
   else
diff --git a/src/pt-fvc.h b/src/pt-fvc.h
--- a/src/pt-fvc.h
+++ b/src/pt-fvc.h
@@ -54,44 +54,44 @@ public:
 
   ~tree_identifier (void) { }
 
   bool is_identifier (void) const
     { return true; }
 
   string name (void) const;
 
-  tree_identifier *define (tree_constant *t);
+  tree_identifier *define (octave_value *t);
   tree_identifier *define (tree_function *t);
 
   void document (const string& s);
 
-  tree_constant assign (tree_constant& t);
-  tree_constant assign (tree_constant& t, const Octave_object& args);
+  octave_value assign (octave_value& t);
+  octave_value assign (octave_value& t, const octave_value_list& args);
 
-  tree_constant assign (SLList<string> list, tree_constant& t);
-  tree_constant assign (SLList<string> list, tree_constant& t,
-			const Octave_object& args); 
+  octave_value assign (SLList<string> list, octave_value& t);
+  octave_value assign (SLList<string> list, octave_value& t,
+			const octave_value_list& args); 
 
   bool is_defined (void);
 
   void bump_value (tree_expression::type);
 
   tree_fvc *do_lookup (bool& script_file_executed, bool exec_script = true);
 
   void link_to_global (void);
 
   void mark_as_formal_parameter (void);
 
   void mark_for_possible_ans_assign (void)
     { maybe_do_ans_assign = true; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   void eval_undefined_error (void);
 
   void print_code (ostream& os);
 
 private:
   symbol_record *sym;
   bool maybe_do_ans_assign;
@@ -122,25 +122,25 @@ public:
   tree_identifier *ident (void)
     { return id; }
 
   void preserve_identifier (void)
     { preserve_ident = true; }
 
   string name (void) const;
 
-  tree_constant assign (tree_constant& t);
-  tree_constant assign (tree_constant& t, const Octave_object& args);
+  octave_value assign (octave_value& t);
+  octave_value assign (octave_value& t, const octave_value_list& args);
 
   void mark_for_possible_ans_assign (void)
     { id->mark_for_possible_ans_assign (); }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   void print_code (ostream& os);
 
 private:
   tree_identifier *id;
   SLList<string> refs;
   bool preserve_ident;
 };
@@ -159,19 +159,19 @@ public:
 
   ~tree_builtin (void) { }  // XXX ?? XXX
 
 //  int is_builtin (void) const;
 
   bool is_mapper_function (void) const
     { return is_mapper; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   string name (void) const
     { return my_name; }
 
   void print_code (ostream& os);
 
 private:
   bool is_mapper;
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -48,26 +48,26 @@ Software Foundation, 59 Temple Place - S
 // But first, some internal classes that make our job much easier.
 
 class
 tm_row_const
 {
 private:
 
   class
-  tm_row_const_rep : public SLList<tree_constant>
+  tm_row_const_rep : public SLList<octave_value>
   {
   public:
 
     tm_row_const_rep (void)
-      : SLList<tree_constant> (), count (1), nr (0), nc (0),
+      : SLList<octave_value> (), count (1), nr (0), nc (0),
 	all_str (false), is_cmplx (false), ok (false) { }
 
     tm_row_const_rep (const tree_matrix_row& mr)
-      : SLList<tree_constant> (), count (1), nr (0), nc (0),
+      : SLList<octave_value> (), count (1), nr (0), nc (0),
 	all_str (false), is_cmplx (false), ok (false)
         { init (mr); }
 
     ~tm_row_const_rep (void) { }
 
     int count;
 
     int nr;
@@ -124,19 +124,19 @@ public:
     }
 
   int rows (void) { return rep->nr; }
   int cols (void) { return rep->nc; }
 
   bool all_strings (void) const { return rep->all_str; }
   bool is_complex (void) const { return rep->is_cmplx; }
 
-  tree_constant& operator () (Pix p) { return rep->operator () (p); }
+  octave_value& operator () (Pix p) { return rep->operator () (p); }
 
-  const tree_constant& operator () (Pix p) const
+  const octave_value& operator () (Pix p) const
     { return rep->operator () (p); }
 
   Pix first (void) const { return rep->first (); }
   void next (Pix& p) const { rep->next (p); }
   
   operator void* () const
     {
       return (rep && rep->ok) ? (void *) -1 : (void *) 0;
@@ -155,17 +155,17 @@ tm_row_const::tm_row_const_rep::init (co
   int empties_ok = user_pref.empty_list_elements_ok;
 
   bool first_elem = true;
 
   for (Pix p = mr.first (); p != 0; mr.next (p))
     {
       tree_expression *elt = mr (p);
 
-      tree_constant tmp = elt->eval (false);
+      octave_value tmp = elt->eval (false);
 
       if (error_state || tmp.is_undefined ())
 	break;
       else
 	{
 	  int this_elt_nr = tmp.rows ();
 	  int this_elt_nc = tmp.columns ();
 
@@ -426,20 +426,20 @@ tree_matrix::is_matrix_constant (void) c
 
   return true;
 }
 
 // Just about as ugly as it gets.
 // Less ugly than before, anyway.
 // Looking better all the time.
 
-tree_constant
+octave_value
 tree_matrix::eval (bool /* print */)
 {
-  tree_constant retval;
+  octave_value retval;
 
   tm_const tmp (*this);
 
   if (tmp)
     {
       int nr = tmp.rows ();
       int nc = tmp.cols ();
 
@@ -465,17 +465,17 @@ tree_matrix::eval (bool /* print */)
       for (Pix p = tmp.first (); p != 0; tmp.next (p))
 	{
 	  int put_col = 0;
 
 	  tm_row_const row = tmp (p);
 
 	  for (Pix q = row.first (); q != 0; row.next (q))
 	    {
-	      tree_constant elt = row (q);
+	      octave_value elt = row (q);
 
 	      if (found_complex)
 		{
 		  if (elt.is_real_scalar ())
 		    cm (put_row, put_col) = elt.double_value ();
 		  else if (elt.is_real_matrix () || elt.is_range ())
 		    cm.insert (elt.matrix_value (), put_row, put_col);
 		  else if (elt.is_complex_scalar ())
@@ -510,17 +510,17 @@ tree_matrix::eval (bool /* print */)
 		      if (error_state)
 			goto done;
 
 		      m.insert (m_elt, put_row, put_col);
 		    }
 		}
 
 	      if (all_strings && chm.rows () > 0 && chm.cols () > 0)
-		retval = tree_constant (chm, true);
+		retval = octave_value (chm, true);
 	      else if (found_complex)
 		retval = cm;
 	      else
 		retval = m;
 
 	      put_col += elt.columns ();
 	    }
 
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #define octave_tree_mat_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 class ostream;
 
-class tree_constant;
+class octave_value;
 class tree_return_list;
 
 #include <SLList.h>
 
 #include "pt-exp.h"
 
 // General matrices.  This allows us to construct matrices from
 // other matrices, variables, and functions.
@@ -70,17 +70,17 @@ public:
 	if (mr)
 	  append (mr);
       }
 
   ~tree_matrix (void) { }
 
   bool is_matrix_constant (void) const;
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
   void print_code (ostream& os);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -111,21 +111,21 @@ tree_statement::print_code (ostream& os)
 
       if (! print_flag)
 	os << ";";
 
       expression->print_code_new_line (os);
     }
 }
 
-tree_constant
+octave_value
 tree_statement_list::eval (bool print)
 {
   bool pf;
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   for (Pix p = first (); p != 0; next (p))
     {
       tree_statement *elt = this->operator () (p);
 
@@ -142,34 +142,34 @@ tree_statement_list::eval (bool print)
 	  elt->maybe_echo_code (function_body);
 
 	  if (cmd)
 	    cmd->eval ();
 	  else
 	    retval = expr->eval (pf);
 
 	  if (error_state)
-	    return tree_constant ();
+	    return octave_value ();
 
 	  if (breaking || continuing)
 	    break;
 
 	  if (returning)
 	    break;
 	}
       else
-	retval = tree_constant ();
+	retval = octave_value ();
     }
   return retval;
 }
 
-Octave_object
+octave_value_list
 tree_statement_list::eval (bool print, int nargout)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (nargout > 1)
     {
       bool pf;
 
       if (error_state)
 	return retval;
 
@@ -190,35 +190,35 @@ tree_statement_list::eval (bool print, i
 	      elt->maybe_echo_code (function_body);
 
 	      if (cmd)
 		cmd->eval ();
 	      else
 		{
 		  if (expr->is_multi_val_ret_expression ())
 		    {
-		      Octave_object args;
+		      octave_value_list args;
 		      tree_multi_val_ret *t = (tree_multi_val_ret *) expr;
 		      retval = t->eval (pf, nargout, args);
 		    }
 		  else
 		    retval = expr->eval (pf);
 		}
 
 	      if (error_state)
-		return tree_constant ();
+		return octave_value ();
 
 	      if (breaking || continuing)
 		break;
 
 	      if (returning)
 		break;
 	    }
 	  else
-	    retval = Octave_object ();
+	    retval = octave_value_list ();
 	}
       return retval;
     }
   else
     retval = eval (print);
 
   return retval;
 }
@@ -230,69 +230,69 @@ tree_statement_list::print_code (ostream
     {
       tree_statement *elt = this->operator () (p);
 
       if (elt)
 	elt->print_code (os);
     }
 }
 
-Octave_object
+octave_value_list
 tree_argument_list::convert_to_const_vector (void)
 {
   int len = length ();
 
   // XXX FIXME XXX -- would be nice to know in advance how largs args
   // needs to be even when we have a list containing an all_va_args
   // token.
 
-  Octave_object args;
+  octave_value_list args;
   args.resize (len);
 
   Pix p = first ();
   int j = 0;
   for (int k = 0; k < len; k++)
     {
       tree_expression *elt = this->operator () (p);
       if (elt)
 	{
-	  tree_constant tmp = elt->eval (false);
+	  octave_value tmp = elt->eval (false);
 	  if (error_state)
 	    {
 	      ::error ("evaluating argument list element number %d", k);
-	      args = Octave_object ();
+	      args = octave_value_list ();
 	      break;
 	    }
 	  else
 	    {
 	      if (tmp.is_all_va_args ())
 		{
 		  if (curr_function)
 		    {
-		      Octave_object tva;
+		      octave_value_list tva;
 		      tva = curr_function->octave_all_va_args ();
 		      int n = tva.length ();
 		      for (int i = 0; i < n; i++)
 			args(j++) = tva(i);
 		    }
 		  else
 		    {
 		      ::error ("all_va_args is only valid inside functions");
-		      args = Octave_object ();
+		      args = octave_value_list ();
 		      break;
 		    }
 		}
 	      else
 		args(j++) = tmp;
 	    }
 	  next (p);
 	}
       else
 	{
-	  args(j++) = tree_constant ();
+	  args(j++) = octave_value ();
 	  break;
 	}
     }
 
   args.resize (j);
 
   return args;
 }
@@ -335,69 +335,69 @@ tree_parameter_list::mark_as_formal_para
   for (Pix p = first (); p != 0; next (p))
     {
       tree_identifier *elt = this->operator () (p);
       elt->mark_as_formal_parameter ();
     }
 }
 
 void
-tree_parameter_list::initialize_undefined_elements (tree_constant& val)
+tree_parameter_list::initialize_undefined_elements (octave_value& val)
 {
   for (Pix p = first (); p != 0; next (p))
     {
       tree_identifier *elt = this->operator () (p);
       if (! elt->is_defined ())
 	elt->assign (val);
     }
 }
 
 void
-tree_parameter_list::define_from_arg_vector (const Octave_object& args)
+tree_parameter_list::define_from_arg_vector (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   if (nargin <= 0)
     return;
 
   int expected_nargin = length ();
 
   Pix p = first ();
 
   for (int i = 0; i < expected_nargin; i++)
     {
       tree_identifier *elt = this->operator () (p);
 
-      tree_constant *tmp = 0;
+      octave_value *tmp = 0;
 
       if (i < nargin)
 	{
 	  if (args(i).is_defined () && args(i).is_magic_colon ())
 	    {
 	      ::error ("invalid use of colon in function argument list");
 	      return;
 	    }
-	  tmp = new tree_constant (args(i));
+	  tmp = new octave_value (args(i));
 	}
 
       elt->define (tmp);
 
       next (p);
     }
 }
 
-Octave_object
+octave_value_list
 tree_parameter_list::convert_to_const_vector (tree_va_return_list *vr_list)
 {
   int nout = length ();
 
   if (vr_list)
     nout += vr_list->length ();
 
-  Octave_object retval;
+  octave_value_list retval;
   retval.resize (nout);
 
   int i = 0;
 
   for (Pix p = first (); p != 0; next (p))
     {
       tree_identifier *elt = this->operator () (p);
 
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -24,18 +24,18 @@ Software Foundation, 59 Temple Place - S
 #define octave_tree_misc_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 class ostream;
 
-class Octave_object;
-class tree_constant;
+class octave_value_list;
+class octave_value;
 class tree_command;
 class tree_expression;
 class tree_simple_assignment_expression;
 class tree_index_expression;
 class tree_identifier;
 class symbol_record;
 class symbol_table;
 
@@ -111,19 +111,19 @@ public:
 	{
 	  tree_statement *t = remove_front ();
 	  delete t;
 	}
     }
 
   void mark_as_function_body (void) { function_body = true; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout);
+  octave_value_list eval (bool print, int nargout);
 
   void print_code (ostream& os);
 
 private:
   bool function_body;
 };
 
 // Argument lists.  Used to hold the list of expressions that are the
@@ -144,17 +144,17 @@ public:
     {
       while (! empty ())
 	{
 	  tree_expression *t = remove_front ();
 	  delete t;
 	}
     }
 
-  Octave_object convert_to_const_vector (void);
+  octave_value_list convert_to_const_vector (void);
 
   void print_code (ostream& os);
 };
 
 // Parameter lists.  Used to hold the list of input and output
 // parameters in a function definition.  Elements are identifiers
 // only.
 
@@ -184,23 +184,23 @@ public:
     { return marked_for_varargs != 0; }
 
   void mark_varargs_only (void)
     { marked_for_varargs = -1; }
 
   bool varargs_only (void)
     { return (marked_for_varargs < 0); }
 
-  void initialize_undefined_elements (tree_constant& val);
+  void initialize_undefined_elements (octave_value& val);
 
-  void define_from_arg_vector (const Octave_object& args);
+  void define_from_arg_vector (const octave_value_list& args);
 
   bool is_defined (void);
 
-  Octave_object convert_to_const_vector (tree_va_return_list *vr_list);
+  octave_value_list convert_to_const_vector (tree_va_return_list *vr_list);
 
   void print_code (ostream& os);
 
 private:
   int marked_for_varargs;
 };
 
 // Return lists.  Used to hold the right hand sides of multiple
@@ -219,20 +219,20 @@ public:
       { append (t); }
 
   ~tree_return_list (void);
 
   void print_code (ostream& os);
 };
 
 class
-tree_va_return_list : public SLList<tree_constant>
+tree_va_return_list : public SLList<octave_value>
 {
 public:
-  tree_va_return_list (void) : SLList<tree_constant> () { }
+  tree_va_return_list (void) : SLList<octave_value> () { }
 
   ~tree_va_return_list (void) { }
 };
 
 // List of expressions that make up a global statement.
 
 class
 tree_global : public tree_print_code
diff --git a/src/pt-mvr-base.cc b/src/pt-mvr-base.cc
--- a/src/pt-mvr-base.cc
+++ b/src/pt-mvr-base.cc
@@ -29,20 +29,20 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "error.h"
 #include "pt-const.h"
 #include "pt-mvr-base.h"
 
 // A base class for objects that can be return multiple values
 
-tree_constant
+octave_value
 tree_multi_val_ret::eval (bool /* print */)
 {
   panic ("invalid evaluation of generic expression");
-  return tree_constant ();
+  return octave_value ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-mvr-base.h b/src/pt-mvr-base.h
--- a/src/pt-mvr-base.h
+++ b/src/pt-mvr-base.h
@@ -22,18 +22,18 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_mvr_h)
 #define octave_tree_mvr_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-class tree_constant;
-class Octave_object;
+class octave_value;
+class octave_value_list;
 
 #include "pt-exp-base.h"
 
 // A base class for objects that can be return multiple values
 
 class
 tree_multi_val_ret : public tree_expression
 {
@@ -43,20 +43,20 @@ public:
   tree_multi_val_ret (int l = -1, int c = -1, tree_expression::type et)
     : tree_expression (l, c, et) { }
 
   ~tree_multi_val_ret (void) { }
 
   bool is_multi_val_ret_expression (void) const
     { return true; }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  virtual Octave_object eval (bool print, int nargout,
-			      const Octave_object& args) = 0;
+  virtual octave_value_list eval (bool print, int nargout,
+			      const octave_value_list& args) = 0;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pt-mvr.cc b/src/pt-mvr.cc
--- a/src/pt-mvr.cc
+++ b/src/pt-mvr.cc
@@ -41,38 +41,38 @@ Software Foundation, 59 Temple Place - S
 #include "pt-mvr.h"
 #include "user-prefs.h"
 
 // But first, some extra functions used by the tree classes.
 
 // Make sure that all arguments have values.
 
 static bool
-all_args_defined (const Octave_object& args)
+all_args_defined (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (args(i).is_undefined ())
       return false;
 
   return true;
 }
 
 // Used internally.
 
-tree_constant
+octave_value
 tree_oct_obj::eval (bool /* print */)
 {
   return values(0);
 }
 
-Octave_object
+octave_value_list
 tree_oct_obj::eval (bool /* print */, int /* nargout */,
-		    const Octave_object& /* args */)
+		    const octave_value_list& /* args */)
 {
   return values;
 }
 
 // Index expressions.
 
 tree_index_expression::tree_index_expression
   (tree_identifier *i, int l = -1, int c = -1)
@@ -104,42 +104,42 @@ tree_index_expression::name (void)
 
 void
 tree_index_expression::mark_for_possible_ans_assign (void)
 {
   if (id)
     id->mark_for_possible_ans_assign ();
 }
 
-tree_constant
+octave_value
 tree_index_expression::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
       // Extract the arguments into a simple vector.  Don't pass null
       // args.
 
-      Octave_object args = list->convert_to_const_vector ();
+      octave_value_list args = list->convert_to_const_vector ();
 
       if (error_state)
 	eval_error ();
       else
 	{
 	  if (error_state)
 	    eval_error ();
 	  else
 	    {
 	      if (all_args_defined (args))
 		{
-		  Octave_object tmp = id->eval (print, 1, args);
+		  octave_value_list tmp = id->eval (print, 1, args);
 
 		  if (error_state)
 		    eval_error ();
 		  else if (tmp.length () > 0)
 		    retval = tmp(0);
 		}
 	      else
 		{
@@ -155,31 +155,31 @@ tree_index_expression::eval (bool print)
 
       if (error_state)
 	eval_error ();
     }
 
   return retval;
 }
 
-Octave_object
+octave_value_list
 tree_index_expression::eval (bool print, int nargout,
-			     const Octave_object& /* args */)
+			     const octave_value_list& /* args */)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
       // Extract the arguments into a simple vector.  Don't pass null
       // args.
 
-      Octave_object tmp_args = list->convert_to_const_vector ();
+      octave_value_list tmp_args = list->convert_to_const_vector ();
 
       if (error_state)
 	eval_error ();
       else
 	{
 	  if (error_state)
 	    eval_error ();
 	  else
@@ -196,17 +196,17 @@ tree_index_expression::eval (bool print,
 		  ::error ("undefined arguments found in index expression");
 		  eval_error ();
 		}
 	    }
 	}
     }
   else
     {
-      Octave_object tmp_args;
+      octave_value_list tmp_args;
 
       retval = id->eval (print, nargout, tmp_args);
 
       if (error_state)
 	eval_error ();
     }
 
   return retval;
@@ -266,45 +266,45 @@ tree_index_expression::print_code (ostre
 tree_multi_assignment_expression::~tree_multi_assignment_expression (void)
 {
   if (! preserve)
     delete lhs;
 
   delete rhs;
 }
 
-tree_constant
+octave_value
 tree_multi_assignment_expression::eval (bool print)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (error_state)
     return retval;
 
-  Octave_object tmp_args;
-  Octave_object result = eval (print, 1, tmp_args);
+  octave_value_list tmp_args;
+  octave_value_list result = eval (print, 1, tmp_args);
 
   if (result.length () > 0)
     retval = result(0);
 
   return retval;
 }
 
-Octave_object
+octave_value_list
 tree_multi_assignment_expression::eval (bool print, int nargout,
-					const Octave_object& /* args */)
+					const octave_value_list& /* args */)
 {
   assert (etype == tree_expression::multi_assignment);
 
   if (error_state || ! rhs)
-    return Octave_object ();
+    return octave_value_list ();
 
   nargout = lhs->length ();
-  Octave_object tmp_args;
-  Octave_object results = rhs->eval (0, nargout, tmp_args);
+  octave_value_list tmp_args;
+  octave_value_list results = rhs->eval (0, nargout, tmp_args);
 
   if (error_state)
     eval_error ();
 
   int ma_line = line ();
   int ma_column = column ();
 
   if (results.length () > 0)
@@ -318,25 +318,25 @@ tree_multi_assignment_expression::eval (
 	  tree_index_expression *lhs_expr = lhs->operator () (p);
 
 	  if (i < nargout)
 	    {
 	      // XXX FIXME? XXX -- this is apparently the way Matlab
 	      // works, but maybe we should have the option of
 	      // skipping the assignment instead.
 
-	      tree_constant *tmp = 0;
+	      octave_value *tmp = 0;
 	      if (results(i).is_undefined ())
 		{
 		  error ("element number %d undefined in return list", i+1);
 		  eval_error ();
 		  break;
 		}
 	      else
-		tmp = new tree_constant (results(i));
+		tmp = new octave_value (results(i));
 
 	      tree_simple_assignment_expression tmp_expr
 		(lhs_expr, tmp, 1, 0, ma_line, ma_column);
 
 	      results(i) = tmp_expr.eval (false); // May change
 
 	      if (error_state)
 		break;
diff --git a/src/pt-mvr.h b/src/pt-mvr.h
--- a/src/pt-mvr.h
+++ b/src/pt-mvr.h
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #define octave_tree_mvr2_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 class ostream;
 
-class Octave_object;
+class octave_value_list;
 
 class tree_argument_list;
 class tree_identifier;
 class tree_index_expression;
 class tree_indirect_ref;
 class tree_return_list;
 
 #include <string>
@@ -46,29 +46,29 @@ class tree_return_list;
 // Used internally.
 
 class
 tree_oct_obj : public tree_multi_val_ret
 {
 public:
   tree_oct_obj (int l = -1, int c = -1) : tree_multi_val_ret (l, c) { }
 
-  tree_oct_obj (const Octave_object& v, int l = -1, int c = -1)
+  tree_oct_obj (const octave_value_list& v, int l = -1, int c = -1)
     : tree_multi_val_ret (l, c), values (v) { }
 
   ~tree_oct_obj (void) { }
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   void print_code (ostream&) { }
 
 private:
-  Octave_object values;
+  octave_value_list values;
 };
 
 // Index expressions.
 
 class
 tree_index_expression : public tree_multi_val_ret
 {
 public:
@@ -97,19 +97,19 @@ public:
 
   string name (void);
 
   tree_argument_list *arg_list (void)
     { return list; }
 
   void mark_for_possible_ans_assign (void);
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
  private:
   tree_indirect_ref *id;
   tree_argument_list *list;
@@ -129,19 +129,19 @@ tree_multi_assignment_expression : publi
 				    tree_multi_val_ret *r,
 				    bool plhs = false,
 				    int l = -1, int c = -1)
     : tree_multi_val_ret (l, c, tree_expression::multi_assignment),
       preserve (plhs), lhs (lst), rhs (r) { }
 
   ~tree_multi_assignment_expression (void);
 
-  tree_constant eval (bool print);
+  octave_value eval (bool print);
 
-  Octave_object eval (bool print, int nargout, const Octave_object& args);
+  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   bool is_assignment_expression (void) const
     { return true; }
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -399,34 +399,34 @@ plot_range::~plot_range (void)
 
 void
 plot_range::print (ostrstream& plot_buf)
 {
   plot_buf << " [";
 
   if (lower)
     {
-      tree_constant lower_val = lower->eval (false);
+      octave_value lower_val = lower->eval (false);
       if (error_state)
 	{
 	  ::error ("evaluating lower bound of plot range");
 	  return;
 	}
       else
 	{
 	  double lo = lower_val.double_value ();
 	  plot_buf << lo;
 	}
     }
 
   plot_buf << ":";
 
   if (upper)
     {
-      tree_constant upper_val = upper->eval (false);
+      octave_value upper_val = upper->eval (false);
       if (error_state)
 	{
 	  ::error ("evaluating upper bound of plot range");
 	  return;
 	}
       else
 	{
 	  double hi = upper_val.double_value ();
@@ -467,17 +467,17 @@ subplot_using::eval (int ndim, int n_max
 
   if (qualifier_count > 0)
     val.resize (qualifier_count);
 
   for (int i = 0; i < qualifier_count; i++)
     {
       if (x[i])
 	{
-	  tree_constant tmp = x[i]->eval (false);
+	  octave_value tmp = x[i]->eval (false);
 	  if (error_state)
 	    {
 	      ::error ("evaluating plot using command");
 	      return -1;
 	    }
 
 	  double val_tmp;
 	  if (tmp.is_defined ())
@@ -594,17 +594,17 @@ int
 subplot_style::print (ostrstream& plot_buf)
 {
   if (! style.empty ())
     {
       plot_buf << " " << GNUPLOT_COMMAND_WITH << " " << style;
 
       if (linetype)
 	{
-	  tree_constant tmp = linetype->eval (false);
+	  octave_value tmp = linetype->eval (false);
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.double_value ();
 	      if (xisnan (val))
 		{
 		  ::error ("NaN is invalid a plotting line style");
 		  return -1;
 		}
@@ -615,17 +615,17 @@ subplot_style::print (ostrstream& plot_b
 	    {
 	      ::error ("evaluating plot style command");
 	      return -1;
 	    }
 	}
 
       if (pointtype)
 	{
-	  tree_constant tmp = pointtype->eval (false);
+	  octave_value tmp = pointtype->eval (false);
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.double_value ();
 	      if (xisnan (val))
 		{
 		  ::error ("NaN is invalid a plotting point style");
 		  return -1;
 		}
@@ -673,61 +673,61 @@ subplot_style::print_code (ostream& os)
 subplot::~subplot (void)
 {
   delete plot_data;
   delete using_clause;
   delete title_clause;
   delete style_clause;
 }
 
-tree_constant
-subplot::extract_plot_data (int ndim, tree_constant& data)
+octave_value
+subplot::extract_plot_data (int ndim, octave_value& data)
 {
-  tree_constant retval;
+  octave_value retval;
 
   if (using_clause)
     {
       ColumnVector val = using_clause->values (ndim);
 
-      Octave_object args;
+      octave_value_list args;
       args(1) = val;
-      args(0) = tree_constant::magic_colon_t;
+      args(0) = octave_value::magic_colon_t;
 
-      Octave_object tmp = data.eval (0, 1, args);
+      octave_value_list tmp = data.eval (0, 1, args);
       retval = tmp(0);
 
       if (error_state)
-	return tree_constant ();
+	return octave_value ();
     }
   else
     {
       retval = data;
     }
 
   if (ndim == 2 && style_clause && style_clause->errorbars ())
     {
       int nc = retval.columns ();
 
       if (nc < 3 || nc > 4)
 	{
 	  error ("plots with errorbars require 3 or 4 columns of data");
 	  error ("but %d were provided", nc);
-	  return tree_constant ();
+	  return octave_value ();
 	}
     }
 
   return retval;
 }
 
 int
 subplot::handle_plot_data (int ndim, ostrstream& plot_buf)
 {
   if (plot_data)
     {
-      tree_constant data = plot_data->eval (false);
+      octave_value data = plot_data->eval (false);
 
       if (! error_state && data.is_defined ())
 	{
 	  string file;
 
 	  if (data.is_string ())
 	    {
 	      // Should really try to look at data file to determine
@@ -762,17 +762,17 @@ subplot::handle_plot_data (int ndim, ost
 		    return -1;
 		}
 	    }
 	  else
 	    {
 	      // Eliminate the need for printing a using clause to
 	      // plot_buf.
 
-	      tree_constant tmp_data = extract_plot_data (ndim, data);
+	      octave_value tmp_data = extract_plot_data (ndim, data);
 
 	      if (tmp_data.is_defined ())
 		{
 		  switch (ndim)
 		    {
 		    case 2:
 		      file = save_in_tmp_file (tmp_data, ndim);
 		      break;
@@ -809,17 +809,17 @@ subplot::print (int ndim, ostrstream& pl
 {
   int status = handle_plot_data (ndim, plot_buf);
 
   if (status < 0)
     return -1;
 
   if (title_clause)
     {
-      tree_constant tmp = title_clause->eval (false);
+      octave_value tmp = title_clause->eval (false);
       if (! error_state && tmp.is_string ())
 	plot_buf << " " << GNUPLOT_COMMAND_TITLE << " "
 	  << '"' << tmp.string_value () << '"';
       else
 	{
 	  warning ("line title must be a string");
 	  plot_buf << " " << GNUPLOT_COMMAND_TITLE << " "
 	    << '"' << "line " << plot_line_count << '"';
@@ -907,17 +907,17 @@ subplot_list::print_code (ostream& os)
 
 	  if (p)
 	    os << ",";
 	}
     }
 }
 
 string
-save_in_tmp_file (tree_constant& t, int ndim, bool parametric)
+save_in_tmp_file (octave_value& t, int ndim, bool parametric)
 {
   string name = oct_tempnam ();
 
   if (! name.empty ())
     {
       ofstream file (name.c_str ());
 
       if (file)
@@ -986,17 +986,17 @@ do_external_plotter_cd (const string& ne
       send_to_plot_stream (message);
       delete [] message;
     }
 }
 
 DEFUN (clearplot, , ,
   "clearplot (): clear the plot window")
 {
-  Octave_object retval;
+  octave_value_list retval;
   send_to_plot_stream ("clear\n");
 
   // XXX FIXME XXX -- instead of just clearing these things, it would
   // be nice if we could reset things to a user-specified default
   // state.
 
   send_to_plot_stream ("set title\n");
   send_to_plot_stream ("set xlabel\n");
@@ -1012,28 +1012,28 @@ DEFUN (clearplot, , ,
   return retval;
 }
 
 DEFALIAS (clg, clearplot);
 
 DEFUN (closeplot, , ,
   "closeplot (): close the stream to plotter")
 {
-  Octave_object retval;
+  octave_value_list retval;
   close_plot_stream ();
   return retval;
 }
 
 DEFUN_TEXT (hold, args, ,
   "hold [on|off]\n\
 \n\
 determine whether the plot window is cleared before the next line is\n\
 drawn.  With no argument, toggle the current state.") 
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("hold");
 
   if (error_state)
     return retval;
 
@@ -1066,27 +1066,27 @@ DEFUN (ishold, , ,
 Return 1 if hold is on, otherwise return 0.")
 {
   return (double) (! clear_before_plotting);
 }
 
 DEFUN (purge_tmp_files, , ,
   "delete temporary data files used for plotting")
 {
-  Octave_object retval;
+  octave_value_list retval;
   cleanup_tmp_files ();
   return retval;
 }
 
 DEFUN_TEXT (set, args, ,
   "set [options]\n\
 \n\
 set plotting options")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("set");
 
   if (error_state)
     return retval;
 
@@ -1122,17 +1122,17 @@ set plotting options")
   return retval;
 }
 
 DEFUN_TEXT (show, args, ,
   "show [options]\n\
 \n\
 show plotting options")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("show");
 
   if (error_state)
     return retval;
 
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -197,17 +197,17 @@ public:
   ~subplot (void);
 
   subplot *set_data (tree_expression *data)
     {
       plot_data = data;
       return this;
     }
 
-  tree_constant extract_plot_data (int ndim, tree_constant& data);
+  octave_value extract_plot_data (int ndim, octave_value& data);
 
   int handle_plot_data (int ndim, ostrstream& plot_buf);
 
   int print (int ndim, ostrstream& plot_buf);
 
   void print_code (ostream& os);
 
 private:
@@ -228,17 +228,17 @@ public:
 
   ~subplot_list (void);
 
   int print (int ndim, ostrstream& plot_buf);
 
   void print_code (ostream& os);
 };
 
-extern string save_in_tmp_file (tree_constant& t, int ndim = 2,
+extern string save_in_tmp_file (octave_value& t, int ndim = 2,
 				bool parametric = false);
 
 extern void mark_for_deletion (const string&);
 
 extern void cleanup_tmp_files (void);
 
 extern void close_plot_stream (void);
 
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -98,17 +98,17 @@ Handle all of the following:
 
   1. qpsol (x, H, c)
   2. qpsol (x, H, c, lb, ub)
   3. qpsol (x, H, c, lb, ub, llb, A, lub)
   4. qpsol (x, H, c,         llb, A, lub)
 
 */
 
-  Octave_object retval;
+  octave_value_list retval;
 
 #if defined (QPSOL_MISSING)
 
   // Force a bad value of inform, and empty matrices for x, phi, and
   // lambda.
 
   retval.resize (4, Matrix ());
 
@@ -380,20 +380,20 @@ set_qpsol_option (const string& keyword,
 	  return;
 	}
       list++;
     }
 
   warning ("qpsol_options: no match for `%s'", keyword.c_str ());
 }
 
-static Octave_object
+static octave_value_list
 show_qpsol_option (const string& keyword)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   QPSOL_OPTIONS *list = qpsol_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -420,17 +420,17 @@ libcruft/qpsol/README.MISSING in the sou
 #else
 DEFUN_DLD_BUILTIN (qpsol_options, args, ,
   "qpsol_options (KEYWORD, VALUE)\n
 \n\
 Set or show options for qpsol.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
-  Octave_object retval;
+  octave_value_list retval;
 
 #if defined (QPSOL_MISSING)
 
   print_usage ("qpsol");
 
 #else
 
   int nargin = args.length ();
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -50,34 +50,34 @@ DEFUN_DLD_BUILTIN (qr, args, nargout,
                        A * P = Q * R\n\
 \n\
 [Q, R, P] = qr (X, 0): form the economy decomposition with \n\
                        permutation vector P such that Q * R = X (:, P)\n\
 \n\
 qr (X) alone returns the output of the LAPACK routine dgeqrf, such\n\
 that R = triu (qr (X))")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2 || nargout > 3)
     {
       print_usage ("qr");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("qr", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Octave_object (3, Matrix ());
+    return octave_value_list (3, Matrix ());
 
   QR::type type = nargout == 1 ? QR::raw
     : (nargin == 2 ? QR::economy : QR::std);
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -45,22 +45,22 @@ static tree_fvc *quad_fcn;
 
 static Quad_options quad_opts;
 
 double
 quad_user_function (double x)
 {
   double retval = 0.0;
 
-  Octave_object args;
+  octave_value_list args;
   args(0) = x;
 
   if (quad_fcn)
     {
-      Octave_object tmp = quad_fcn->eval (0, 1, args);
+      octave_value_list tmp = quad_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	  return retval;
 	}
 
@@ -100,17 +100,17 @@ both may be infinite.\n\
 The optional argument tol is a vector that specifies the desired\n\
 accuracy of the result.  The first element of the vector is the desired\n\
 absolute tolerance, and the second element is the desired relative\n\
 tolerance.\n\
 \n\
 The optional argument @var{sing} is a vector of values at which the\n\
 integrand is singular.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 5 || nargout > 4)
     {
       print_usage ("quad");
       return retval;
     }
@@ -327,20 +327,20 @@ set_quad_option (const string& keyword, 
 	  return;
 	}
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword.c_str ());
 }
 
-static Octave_object
+static octave_value_list
 show_quad_option (const string& keyword)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   QUAD_OPTIONS *list = quad_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -355,17 +355,17 @@ show_quad_option (const string& keyword)
 }
 
 DEFUN_DLD_BUILTIN (quad_options, args, ,
   "quad_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for quad.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       print_quad_option_list ();
       return retval;
     }
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -35,24 +35,24 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 
 DEFUN_DLD_BUILTIN (qzval, args, ,
   "X = qzval (A, B)\n\
 \n\
 compute generalized eigenvalues of the matrix pencil (A - lambda B).\n\
 A and B must be real matrices.")
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      tree_constant arg_a = args(0);
-      tree_constant arg_b = args(1);
+      octave_value arg_a = args(0);
+      octave_value arg_b = args(1);
 
       Matrix a = arg_a.matrix_value ();
       Matrix b = arg_b.matrix_value ();
 
       if (! error_state)
 	retval = Qzval (a, b);
     }
   else
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -145,34 +145,34 @@ do_initialization (void)
   s0 = force_to_fit_range (s0, 1, 2147483563);
   s1 = force_to_fit_range (s1, 1, 2147483399);
 
   F77_FCN (setall, SETALL) (s0, s1);
 
   initialized = 1;
 }
 
-static Octave_object
-do_rand (const Octave_object& args, int nargin)
+static octave_value_list
+do_rand (const octave_value_list& args, int nargin)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int n = 0;
   int m = 0;
 
   if (nargin == 0)
     {
       n = 1;
       m = 1;
 
       goto gen_matrix;
     }
   else if (nargin == 1)
     {
-      tree_constant tmp = args(0);
+      octave_value tmp = args(0);
 
       if (tmp.is_string ())
 	{
 	  string s_arg = tmp.string_value ();
 
 	  if (s_arg == "dist")
 	    {
 	      retval(0) = curr_rand_dist ();
@@ -336,17 +336,17 @@ DEFUN_DLD_BUILTIN (rand, args, nargout,
 rand (N)        -- generate N x N matrix\n\
 rand (size (A)) -- generate matrix the size of A\n\
 rand (N, M)     -- generate N x M matrix\n\
 rand (SEED)     -- get current seed\n\
 rand (SEED, N)  -- set seed\n\
 \n\
 See also: randn")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 2 || nargout > 1)
     print_usage ("rand");
   else
     {
       if (! initialized)
@@ -370,17 +370,17 @@ DEFUN_DLD_BUILTIN (randn, args, nargout,
 randn (N)        -- generate N x N matrix\n\
 randn (size (A)) -- generate matrix the size of A\n\
 randn (N, M)     -- generate N x M matrix\n\
 randn (SEED)     -- get current seed\n\
 randn (SEED, N)  -- set seed\n\
 \n\
 See also: rand")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 2 || nargout > 1)
     print_usage ("randn");
   else
     {
       if (! initialized)
diff --git a/src/resource.cc b/src/resource.cc
--- a/src/resource.cc
+++ b/src/resource.cc
@@ -75,21 +75,21 @@ Return system resource statistics.")
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
   tv_tmp ["sec"] = (double) ru.ru_utime.tv_sec;
   tv_tmp ["usec"] = (double) ru.ru_utime.tv_usec;
-  m ["utime"] = tree_constant (tv_tmp);
+  m ["utime"] = octave_value (tv_tmp);
 
   tv_tmp ["sec"] = (double) ru.ru_stime.tv_sec;
   tv_tmp ["usec"] = (double) ru.ru_stime.tv_usec;
-  m ["stime"] = tree_constant (tv_tmp);
+  m ["stime"] = octave_value (tv_tmp);
 
   m ["maxrss"] = (double) ru.ru_maxrss;
   m ["ixrss"] = (double) ru.ru_ixrss;
   m ["idrss"] = (double) ru.ru_idrss;
   m ["isrss"] = (double) ru.ru_isrss;
   m ["minflt"] = (double) ru.ru_minflt;
   m ["majflt"] = (double) ru.ru_majflt;
   m ["nswap"] = (double) ru.ru_nswap;
@@ -113,35 +113,35 @@ Return system resource statistics.")
   unsigned long fraction;
 
   ticks = t.tms_utime + t.tms_cutime;
   fraction = ticks % HZ;
   seconds = ticks / HZ;
 
   tv_tmp ["sec"] = (double) seconds;
   tv_tmp ["usec"] = (double) (fraction * 1e6 / HZ);
-  m ["utime"] = tree_constant (tv_tmp);
+  m ["utime"] = octave_value (tv_tmp);
 
   ticks = t.tms_stime + t.tms_cstime;
   fraction = ticks % HZ;
   seconds = ticks / HZ;
 
   tv_tmp ["sec"] = (double) seconds;
   tv_tmp ["usec"] = (double) (fraction * 1e6 / HZ);
-  m ["stime"] = tree_constant (tv_tmp);
+  m ["stime"] = octave_value (tv_tmp);
 
 #else
 
   tv_tmp ["sec"] = 0.0;
   tv_tmp ["usec"] = 0.0;
-  m ["utime"] = tree_constant (tv_tmp);
+  m ["utime"] = octave_value (tv_tmp);
 
   tv_tmp ["sec"] = 0.0;
   tv_tmp ["usec"] = 0.0;
-  m ["stime"] = tree_constant (tv_tmp);
+  m ["stime"] = octave_value (tv_tmp);
 
 #endif
 
   m ["maxrss"] = octave_NaN;
   m ["ixrss"] = octave_NaN;
   m ["idrss"] = octave_NaN;
   m ["isrss"] = octave_NaN;
   m ["minflt"] = octave_NaN;
@@ -152,16 +152,16 @@ Return system resource statistics.")
   m ["msgsnd"] = octave_NaN;
   m ["msgrcv"] = octave_NaN;
   m ["nsignals"] = octave_NaN;
   m ["nvcsw"] = octave_NaN;
   m ["nivcsw"] = octave_NaN;
 
 #endif
 
-  return tree_constant (m);
+  return octave_value (m);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -45,27 +45,27 @@ or, for ordered Schur:\n\
   [U, S] = schur (A, TYPE) or S = schur (A, TYPE)\n\
 where TYPE is a string that begins with one of the following\n\
 characters:\n\
 \n\
   A = continuous time poles\n\
   D = discrete time poles\n\
   U = unordered schur (default)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("schur");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   string ord;
 
   if (nargin == 2)
     {
       ord = args(1).string_value (); 
 
       if (error_state)
@@ -88,17 +88,17 @@ characters:\n\
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("schur", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Octave_object (2, Matrix ());
+    return octave_value_list (2, Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("schur");
       return retval;
     }
 
   if (arg.is_real_type ())
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -147,20 +147,20 @@ create_index_array (int n)
   ms.elem (0, j) = m.elem (k-1, j); \
   for (int i = 1; i < nr; i++) \
     { \
       k = l.elem ((int) idx.elem (i-1, j)); \
       idx.elem (i, j) = k; \
       ms.elem (i, j) = m.elem (k-1, j); \
     }
 
-static Octave_object
+static octave_value_list
 mx_sort (const Matrix& m)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
 
   Matrix ms (nr, nc);
   Matrix idx (nr, nc);
 
   if (nr == 1 && nc > 0)
@@ -183,20 +183,20 @@ mx_sort (const Matrix& m)
     }
 
   retval (1) = idx;
   retval (0) = ms;
 
   return retval;
 }
 
-static Octave_object
+static octave_value_list
 mx_sort (const RowVector& v)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int n = v.capacity ();
 
   RowVector vs (n);
   RowVector idx (n);
 
   if (n == 1)
     {
@@ -209,26 +209,26 @@ mx_sort (const RowVector& v)
     {
       Array<int> l = create_index_array (n);
 
       DO_SORT (n, (v.elem (p-1) > v.elem (q-1)));
 
       VECTOR_CREATE_RETURN_VALUES (vs, v);
     }
 
-  retval (1) = tree_constant (idx, 0);
-  retval (0) = tree_constant (vs, 0);
+  retval (1) = octave_value (idx, 0);
+  retval (0) = octave_value (vs, 0);
 
   return retval;
 }
 
-static Octave_object
+static octave_value_list
 mx_sort (const ComplexMatrix& cm)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nr = cm.rows ();
   int nc = cm.columns ();
 
   ComplexMatrix cms (nr, nc);
   Matrix idx (nr, nc);
 
   if (nr == 1 && nc > 0)
@@ -261,20 +261,20 @@ mx_sort (const ComplexMatrix& cm)
     }
 
   retval (1) = idx;
   retval (0) = cms;
 
   return retval;
 }
 
-static Octave_object
+static octave_value_list
 mx_sort (ComplexRowVector& cv)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int n = cv.capacity ();
 
   ComplexRowVector cvs (n);
   RowVector idx (n);
 
   if (n == 1)
     {
@@ -297,44 +297,44 @@ mx_sort (ComplexRowVector& cv)
 
       DO_SORT (n, ((all_elts_real
 		    && real (cv.elem (p-1)) > real (cv.elem (q-1)))
 		   || abs (cv.elem (p-1)) > abs (cv.elem (q-1))));
 
       VECTOR_CREATE_RETURN_VALUES (cvs, cv);
     }
 
-  retval (1) = tree_constant (idx, 0);
-  retval (0) = tree_constant (cvs, 0);
+  retval (1) = octave_value (idx, 0);
+  retval (0) = octave_value (cvs, 0);
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN (sort, args, nargout,
   "[S, I] = sort (X)\n\
 \n\
 sort the columns of X, optionally return sort index")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("sort");
       return retval;
     }
 
   int return_idx = nargout > 1;
   if (return_idx)
     retval.resize (2);
   else
     retval.resize (1);
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  if (m.rows () == 1)
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -34,53 +34,53 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "pt-const.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (isstr, args, ,
   "isstr (X): return 1 if X is a string, 0 otherwise")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = (double) args(0).is_string ();
   else
     print_usage ("isstr");
 
   return retval;
 }
 
 DEFUN (setstr, args, ,
   "setstr (V): convert a vector to a string")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).convert_to_str ();
   else
     print_usage ("setstr");
 
   return retval;
 }
 
 DEFUN (toascii, args, ,
   "toascii (STRING): return ASCII representation of STRING in a matrix")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      tree_constant arg = args(0);
+      octave_value arg = args(0);
 
       if (arg.is_string ())
 	{
 	  charMatrix chm = args(0).all_strings ();
 
 	  retval = Matrix (chm);
 	}
       else
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -41,34 +41,34 @@ DEFUN_DLD_BUILTIN (svd, args, nargout,
   "S = svd (X) or [U, S, V] = svd (X [, 0])\n\
 \n\
 Compute the singular value decomposition of X.  Given a second input\n\
 argument, an `economy' sized factorization is computed that omits\n\
 unnecessary rows and columns of U and V.\n\
 \n\
 X may not contain any Inf or NaN values.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
     {
       print_usage ("svd");
       return retval;
     }
 
-  tree_constant arg = args(0);
+  octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("svd", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
-    return Octave_object (3, Matrix ());
+    return octave_value_list (3, Matrix ());
 
   SVD::type type = ((nargout == 0 || nargout == 1)
 		    ? SVD::sigma_only
 		    : (nargin == 2) ? SVD::economy : SVD::std);
 
   if (arg.is_real_type ())
     {
       Matrix tmp = arg.matrix_value ();
@@ -83,17 +83,17 @@ X may not contain any Inf or NaN values.
 	    }
 
 	  SVD result (tmp, type);
 
 	  DiagMatrix sigma = result.singular_values ();
 
 	  if (nargout == 0 || nargout == 1)
 	    {
-	      retval(0) = tree_constant (sigma.diag (), 1);
+	      retval(0) = octave_value (sigma.diag (), 1);
 	    }
 	  else
 	    {
 	      retval(2) = result.right_singular_matrix ();
 	      retval(1) = sigma;
 	      retval(0) = result.left_singular_matrix ();
 	    }
 	}
@@ -112,17 +112,17 @@ X may not contain any Inf or NaN values.
 	    }
 
 	  ComplexSVD result (ctmp, type);
 
 	  DiagMatrix sigma = result.singular_values ();
 
 	  if (nargout == 0 || nargout == 1)
 	    {
-	      retval(0) = tree_constant (sigma.diag (), 1);
+	      retval(0) = octave_value (sigma.diag (), 1);
 	    }
 	  else
 	    {
 	      retval(2) = result.right_singular_matrix ();
 	      retval(1) = sigma;
 	      retval(0) = result.left_singular_matrix ();
 	    }
 	}
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -31,29 +31,29 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD_BUILTIN (syl, args, nargout,
   "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 3 || nargout > 1)
     {
       print_usage ("syl");
       return retval;
     }
 
-  tree_constant arg_a = args(0);
-  tree_constant arg_b = args(1);
-  tree_constant arg_c = args(2);
+  octave_value arg_a = args(0);
+  octave_value arg_b = args(1);
+  octave_value arg_c = args(2);
 
   int a_nr = arg_a.rows ();
   int a_nc = arg_a.columns ();
 
   int b_nr = arg_b.rows ();
   int b_nc = arg_b.columns ();
 
   int c_nr = arg_c.rows ();
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -44,17 +44,17 @@ Software Foundation, 59 Temple Place - S
 
 // Variables and functions.
 
 symbol_def::symbol_def (void)
 {
   init_state ();
 }
 
-symbol_def::symbol_def (tree_constant *t)
+symbol_def::symbol_def (octave_value *t)
 {
   init_state ();
   definition = t;
   type = USER_VARIABLE;
 }
 
 symbol_def::symbol_def (tree_builtin *t, unsigned fcn_type)
 {
@@ -131,17 +131,17 @@ symbol_def::is_builtin_variable (void) c
 
 int
 symbol_def::is_builtin_function (void) const
 {
   return (type & BUILTIN_FUNCTION);
 }
 
 void
-symbol_def::define (tree_constant *t)
+symbol_def::define (octave_value *t)
 {
   definition = t;
   if (! is_builtin_variable ())
     type = USER_VARIABLE;
 }
 
 void
 symbol_def::define (tree_builtin *t, unsigned fcn_type)
@@ -365,17 +365,17 @@ symbol_record::make_eternal (void)
 
 void
 symbol_record::set_sv_function (sv_Function f)
 {
   sv_fcn = f;
 }
 
 int
-symbol_record::define (tree_constant *t)
+symbol_record::define (octave_value *t)
 {
   if (is_variable () && read_only_error ())
     return 0;
 
   tree_fvc *saved_def = 0;
   if (! definition)
     {
       definition = new symbol_def ();
@@ -393,17 +393,17 @@ symbol_record::define (tree_constant *t)
     }
 
   definition->define (t);
 
   if (sv_fcn && sv_fcn () < 0)
     {
       // Would be nice to be able to avoid this cast.  XXX FIXME XXX
 
-      definition->define ((tree_constant *) saved_def);
+      definition->define ((octave_value *) saved_def);
       return 0;
     }
 
   delete saved_def;
 
   return 1;
 }
 
@@ -460,17 +460,17 @@ symbol_record::define (tree_function *t,
   symbol_def *new_def = new symbol_def (t, fcn_type);
   push_def (new_def);
   definition->count = 1;
 
   return 1;
 }
 
 int
-symbol_record::define_as_fcn (tree_constant *t)
+symbol_record::define_as_fcn (octave_value *t)
 {
   if (is_variable () && read_only_error ())
     return 0;
 
   if (is_variable ())
     {
       symbol_def *old_def = pop_def ();
       maybe_delete (old_def);
@@ -486,17 +486,17 @@ symbol_record::define_as_fcn (tree_const
   push_def (new_def);
   definition->count = 1;
   definition->type = symbol_def::BUILTIN_FUNCTION;
 
   return 1;
 }
 
 int
-symbol_record::define_builtin_var (tree_constant *t)
+symbol_record::define_builtin_var (octave_value *t)
 {
   define (t);
   if (is_variable ())
     definition->type = symbol_def::BUILTIN_VARIABLE;
   return 1;
 }
 
 void
@@ -685,17 +685,17 @@ symbol_record_info::symbol_record_info (
   init_state ();
 
   type = sr.type ();
 
   if (sr.is_variable () && sr.is_defined ())
     {
       // Would be nice to avoid this cast.  XXX FIXME XXX
 
-      tree_constant *tmp = (tree_constant *) sr.def ();
+      octave_value *tmp = (octave_value *) sr.def ();
       if (tmp->is_real_scalar ())
 	const_type = SR_INFO_SCALAR;
       else if (tmp->is_complex_scalar ())
 	const_type = SR_INFO_COMPLEX_SCALAR;
       else if (tmp->is_real_matrix ())
 	const_type = SR_INFO_MATRIX;
       else if (tmp->is_complex_matrix ())
 	const_type = SR_INFO_COMPLEX_MATRIX;
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -37,17 +37,17 @@ Software Foundation, 59 Temple Place - S
 
 // Must be multiple of 2.
 #define HASH_TABLE_SIZE 1024
 #define HASH_MASK (HASH_TABLE_SIZE - 1)
 
 class tree;
 class tree_fvc;
 class tree_builtin;
-class tree_constant;
+class octave_value;
 class tree_function;
 
 class string_vector;
 
 class symbol_def;
 class symbol_record;
 class symbol_record_info;
 class symbol_table;
@@ -57,32 +57,32 @@ class symbol_table;
 class symbol_def
 {
   friend class symbol_record;
   friend class symbol_record_info;
 
 public:
 
   symbol_def (void);
-  symbol_def (tree_constant *t);
+  symbol_def (octave_value *t);
   symbol_def (tree_builtin *t, unsigned fcn_type = 0);
   symbol_def (tree_function *t, unsigned fcn_type = 0);
 
   ~symbol_def (void);
 
   int is_variable (void) const;
   int is_function (void) const;
   int is_text_function (void) const;
   int is_mapper_function (void) const;
   int is_user_variable (void) const;
   int is_user_function (void) const;
   int is_builtin_variable (void) const;
   int is_builtin_function (void) const;
 
-  void define (tree_constant *t);
+  void define (octave_value *t);
   void define (tree_builtin *t, unsigned fcn_type = 0);
   void define (tree_function *t, unsigned fcn_type = 0);
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   tree_fvc *def (void) const;
@@ -154,21 +154,21 @@ public:
   int is_eternal (void) const;
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   void set_sv_function (sv_Function f);
 
-  int define (tree_constant *t);
+  int define (octave_value *t);
   int define (tree_builtin *t, int text_fcn = 0);
   int define (tree_function *t, int text_fcn = 0);
-  int define_as_fcn (tree_constant *t);
-  int define_builtin_var (tree_constant *t);
+  int define_as_fcn (octave_value *t);
+  int define_builtin_var (octave_value *t);
 
   void document (const string& h);
 
   int clear (void);
 
   void alias (symbol_record *s, int force = 0);
 
   void mark_as_formal_parameter (void);
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -307,28 +307,28 @@ DEFUN(getppid, args, ,
 }
 
 DEFUN (lstat, args, ,
   "lstat (NAME)\n\
 \n\
   Like stat (NAME), but if NAME refers to a symbolic link, returns\n\
   information about the link itself, not the file that it points to.")
 {
-  tree_constant retval = -1.0;
+  octave_value retval = -1.0;
 
   if (args.length () == 1)
     {
       string fname = oct_tilde_expand (args(0).string_value ());
 
       if (! error_state)
 	{
 	  file_stat fs (fname, false);
 
 	  if (fs)
-	    retval = tree_constant (mk_stat_map (fs));
+	    retval = octave_value (mk_stat_map (fs));
 	}
     }
   else
     print_usage ("lstat");
 
   return retval;
 }
 
@@ -369,17 +369,17 @@ DEFUN (mkfifo, args, ,
     print_usage ("mkfifo");
 
   return retval;
 }
 
 DEFUN (pipe, args, ,
   "[file_ids, status] = pipe (): create an interprocess channel")
 {
-  Octave_object retval (2, tree_constant (-1.0));
+  octave_value_list retval (2, octave_value (-1.0));
 
 #if defined (HAVE_PIPE)
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       int fid[2];
 
@@ -429,28 +429,28 @@ DEFUN (stat, args, ,
     atime   : time of last access\n\
     mtime   : time of last modification\n\
     ctime   : time of last file status change\n\
     blksize : size of blocks in the file\n\
     blocks  : number of blocks allocated for file\n\
 \n\
   If the file does not exist, -1 is returned.")
 {
-  tree_constant retval = -1.0;
+  octave_value retval = -1.0;
 
   if (args.length () == 1)
     {
       string fname = oct_tilde_expand (args(0).string_value ());
 
       if (! error_state)
 	{
 	  file_stat fs (fname);
 
 	  if (fs)
-	    retval = tree_constant (mk_stat_map (fs));
+	    retval = octave_value (mk_stat_map (fs));
 	}
     }
   else
     print_usage ("stat");
 
   return retval;
 }
 
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -384,17 +384,17 @@ octave_chdir (const string& path)
 #else
   return chdir (path.c_str ());
 #endif
 }
 
 DEFUN (clc, , ,
   "clc (): clear screen")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   rl_beg_of_line ();
   rl_kill_line (1);
 
 #if ! defined (_GO32_)
   if (term_clrpag)
     tputs (term_clrpag, 1, _rl_output_character_function);
   else
@@ -408,17 +408,17 @@ DEFUN (clc, , ,
   return retval;
 }
 
 DEFALIAS (home, clc);
 
 DEFUN (getenv, args, ,
   "getenv (STRING): get environment variable values")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       string tstr = args(0).string_value ();
       const char *name = tstr.c_str ();
 
@@ -435,17 +435,17 @@ DEFUN (getenv, args, ,
     print_usage ("getenv");
 
   return retval;
 }
 
 DEFUN (putenv, args, ,
   "putenv (VAR, VALUE): define environment variable VAR=VALUE")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       string var = args(0).string_value (); 
 
       if (! error_state)
@@ -464,17 +464,17 @@ DEFUN (putenv, args, ,
     print_usage ("putenv");
 
   return retval;
 }
 
 DEFUN (kbhit, , ,
   "kbhit: get a single character from the terminal")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   // XXX FIXME XXX -- add timeout and default value args?
 
   if (interactive)
     {
       int c = kbhit ();
       char *s = new char [2];
       s[0] = c;
@@ -483,17 +483,17 @@ DEFUN (kbhit, , ,
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
   "pause (seconds): suspend program execution")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (! (nargin == 0 || nargin == 1))
     {
       print_usage ("pause");
       return retval;
     }
@@ -571,17 +571,17 @@ oct_tilde_expand (const string& name)
     }
 
   return retval;
 }
 
 DEFUN (tilde_expand, args, ,
   "tilde_expand (STRING): perform tilde expansion on STRING")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = oct_tilde_expand (args(0).string_value ());
   else
     print_usage ("tilde_expand");
 
diff --git a/src/timefns.cc b/src/timefns.cc
--- a/src/timefns.cc
+++ b/src/timefns.cc
@@ -123,29 +123,29 @@ DEFUN (time, , ,
 
 DEFUN (gmtime, args, ,
   "gmtime (TIME)\n\
 \n\
   Given a value returned from time(), return a structure like that\n\
   returned from localtime() but with values corresponding to\n\
   Coordinated Universal Time (UTC).")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
 	{
 	  time_t timeval = NINT (tmp);
 	  double ip;
 	  double fraction = modf (tmp, &ip); 
 
-	  retval = tree_constant (mk_tm_map (gmtime (&timeval), fraction));
+	  retval = octave_value (mk_tm_map (gmtime (&timeval), fraction));
 	}
     }
   else
     print_usage ("gmtime");
 
   return retval;
 }
 
@@ -162,41 +162,41 @@ DEFUN (localtime, args, ,
     mday  : day of the month (1, 31)\n\
     mon   : months since January (0, 11)\n\
     year  : years since 1900\n\
     wday  : days since Sunday (0, 6)\n\
     yday  : days since January 1 (0, 365)\n\
     isdst : Daylight Savings Time flag\n\
     zone  : Time zone")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
 	{
 	  time_t timeval = NINT (tmp);
 	  double ip;
 	  double fraction = modf (tmp, &ip); 
 
-	  retval = tree_constant (mk_tm_map (localtime (&timeval), fraction));
+	  retval = octave_value (mk_tm_map (localtime (&timeval), fraction));
 	}
     }
   else
     print_usage ("localtime");
 
   return retval;
 }
 
 DEFUN (mktime, args, ,
   "mktime (TMSTRUCT)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (args.length () == 1 && args(0).is_map ()) 
     {
       Octave_map map = args(0).map_value ();
 
       double fraction;
 
       struct tm *tm = extract_tm (map, fraction);
@@ -266,17 +266,17 @@ DEFUN (strftime, args, ,
     %m	month (01..12)\n\
     %U	week number of year with Sunday as first day of week (00..53)\n\
     %w	day of week (0..6)\n\
     %W	week number of year with Monday as first day of week (00..53)\n\
     %x	locale's date representation (mm/dd/yy)\n\
     %y	last two digits of year (00..99)\n\
     %Y	year (1970...)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   if (args.length () == 2 && args(0).is_string () && args(1).is_map ()) 
     {
       string fmt = args(0).string_value ();
 
       Octave_map map = args(1).map_value ();
 
       double fraction;
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -266,17 +266,17 @@ main_loop (void)
 }
 
 DEFUN (source, args, ,
   "source (FILE)\n\
 \n\
 Parse and execute the contents of FILE.  Like executing commands in a\n\
 script file but without requiring the file to be named `FILE.m'.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       string file = args(0).string_value ();
 
       if (! error_state)
@@ -326,17 +326,17 @@ clean_up_and_exit (int retval)
   // that this volatile function does return.
 
   panic_impossible ();
 }
 
 DEFUN_TEXT (casesen, args, ,
   "casesen [on|off]")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("casesen");
 
   if (error_state)
     return retval;
 
@@ -350,17 +350,17 @@ DEFUN_TEXT (casesen, args, ,
   return retval;
 }
 
 DEFUN (computer, args, nargout,
   "computer ():\n\
 \n\
 Have Octave ask the system, \"What kind of computer are you?\"")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 0)
     warning ("computer: ignoring extra arguments");
 
   ostrstream output_buf;
 
@@ -385,17 +385,17 @@ Have Octave ask the system, \"What kind 
   return retval;
 }
 
 DEFUN (quit, args, ,
   "quit (STATUS): exit Octave gracefully, returning STATUS to the system.\n\
 \n\
 STATUS should be an integer value.  If STATUS is missing, 0 is assumed.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int exit_status = 0;
 
   quitting_gracefully = 1;
 
   int nargin = args.length ();
 
   if (nargin > 0)
@@ -413,17 +413,17 @@ STATUS should be an integer value.  If S
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
 DEFUN (warranty, , ,
   "warranty (): describe copying conditions")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   ostrstream output_buf;
   output_buf << "\n" OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n\n\
 This program is free software; you can redistribute it and/or modify\n\
 it under the terms of the GNU General Public License as published by\n\
 the Free Software Foundation; either version 2 of the License, or\n\
 (at your option) any later version.\n\
 \n\
@@ -440,53 +440,53 @@ Foundation, 59 Temple Place - Suite 330,
   output_buf << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
 // XXX FIXME XXX -- this may not be the best place for these...
 
-Octave_object
-feval (const Octave_object& args, int nargout)
+octave_value_list
+feval (const octave_value_list& args, int nargout)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   tree_fvc *fcn = is_valid_function (args(0), "feval", 1);
   if (fcn)
     {
       int tmp_nargin = args.length () - 1;
-      Octave_object tmp_args;
+      octave_value_list tmp_args;
       tmp_args.resize (tmp_nargin);
       for (int i = 0; i < tmp_nargin; i++)
 	tmp_args(i) = args(i+1);
       retval = fcn->eval (0, nargout, tmp_args);
     }
 
   return retval;
 }
 
 DEFUN (feval, args, nargout,
   "feval (NAME, ARGS, ...)\n\
 \n\
 evaluate NAME as a function, passing ARGS as its arguments")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     retval = feval (args, nargout);
   else
     print_usage ("feval");
 
   return retval;
 }
 
-static Octave_object
+static octave_value_list
 eval_string (const string& s, int print, int& parse_status,
 	     int nargout) 
 {
   begin_unwind_frame ("eval_string");
 
   unwind_protect_int (get_input_from_eval_string);
   unwind_protect_int (input_from_command_line_file);
   unwind_protect_ptr (global_command);
@@ -513,41 +513,41 @@ eval_string (const string& s, int print,
   // Important to reset the idea of where input is coming from before
   // trying to eval the command we just parsed -- it might contain the
   // name of an function file that still needs to be parsed!
 
   tree_statement_list *command = global_command;
 
   run_unwind_frame ("eval_string");
 
-  Octave_object retval;
+  octave_value_list retval;
 
   if (parse_status == 0 && command)
     {
       retval = command->eval (print, nargout);
       delete command;
     }
 
   return retval;
 }
 
-tree_constant
+octave_value
 eval_string (const string& s, int print, int& parse_status)
 {
-  tree_constant retval;
+  octave_value retval;
 
-  Octave_object tmp = eval_string (s, print, parse_status, 1);
+  octave_value_list tmp = eval_string (s, print, parse_status, 1);
 
   retval = tmp(0);
 
   return retval;
 }
 
-static Octave_object
-eval_string (const tree_constant& arg, int& parse_status, int nargout)
+static octave_value_list
+eval_string (const octave_value& arg, int& parse_status, int nargout)
 {
   string s = arg.string_value ();
 
   if (error_state)
     {
       error ("eval: expecting string argument");
       return -1.0;
     }
@@ -558,17 +558,17 @@ eval_string (const tree_constant& arg, i
 }
 
 DEFUN (eval, args, nargout,
   "eval (TRY, CATCH)\n\
 \n\
 Evaluate the string TRY as octave code.  If that fails, evaluate the\n\
 string CATCH.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       begin_unwind_frame ("Feval");
 
       if (nargin > 1)
@@ -589,17 +589,17 @@ string CATCH.")
 	  // errors that occurred in the first part of this eval().
 
 	  buffer_error_messages = 0;
 	  bind_global_error_variable ();
 	  add_unwind_protect (clear_global_error_variable, 0);
 
 	  eval_string (args(1), parse_status, nargout);
 
-	  retval = Octave_object ();
+	  retval = octave_value_list ();
 	}
 
       run_unwind_frame ("Feval");
     }
   else
     print_usage ("eval");
 
   return retval;
@@ -608,20 +608,20 @@ string CATCH.")
 // Execute a shell command.
 
 static void
 cleanup_iprocstream (void *p)
 {
   delete (iprocstream *) p;
 }
 
-static Octave_object
+static octave_value_list
 do_system (const string& cmd_str, bool return_output)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
   add_unwind_protect (cleanup_iprocstream, cmd);
 
   int status = 127;
 
   if (cmd && *cmd)
@@ -680,17 +680,17 @@ is omitted, a value of \"sync\" is assum
 \n\
 If NARGIN == 2 (the actual value of RETURN_OUTPUT is irrelevant) and\n\
 the subprocess is started synchronously, or if system() is called with\n\
 NARGIN == 1 and NARGOUT > 0, the output from the command is returned.\n\
 Otherwise, if the subprocess is executed synchronously, it's output is\n\
 sent to Octave's standard output (possibly being passed through the\n\
 pager).")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargout > 0 || nargin > 1);
 
       string cmd_str = args(0).string_value ();
@@ -752,29 +752,29 @@ DEFALIAS (shell_cmd, system);
 
 static SLStack<string> octave_atexit_functions;
 
 void
 do_octave_atexit (void)
 {
   while (! octave_atexit_functions.empty ())
     {
-      Octave_object fcn = octave_atexit_functions.pop ();
+      octave_value_list fcn = octave_atexit_functions.pop ();
 
       feval (fcn, 0);
     }
 }
 
 DEFUN(atexit, args, ,
   "atexit (NAME): register NAME as a function to call when Octave exits\n\
 \n\
 Functions are called with no arguments in the reverse of the order in
 which they were registered with atexit()")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
 #if defined (HAVE_ATEXIT) || defined (HAVE_ON_EXIT)
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       string arg = args(0).string_value ();
 
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -20,32 +20,32 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_toplev_h)
 #define octave_toplev_h 1
 
 #include <cstdio>
 
-class tree_constant;
+class octave_value;
 class tree_function;
 class tree_statement_list;
 class charMatrix;
 
 #include <string>
 
 extern void clean_up_and_exit (int) NORETURN;
 
 extern void parse_and_execute (FILE *f, int print = 0);
 
 extern void parse_and_execute (const string& s, int print = 0,
 			       int verbose = 0,
 			       const char *warn_for = 0);
 
-extern tree_constant eval_string (const string&, int print,
+extern octave_value eval_string (const string&, int print,
 				  int& parse_status);
 
 extern int main_loop (void);
 
 extern void do_octave_atexit (void);
 
 // argv[0] for this program.
 extern string raw_prog_name;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -332,17 +332,17 @@ search_path_for_file (const string& path
   dir_path p (path);
 
   return make_absolute (p.find (name), the_current_working_directory);
 }
 
 DEFUN (file_in_path, args, ,
   "file_in_path (PATH, NAME)")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("file_in_path");
 
   if (error_state)
     return retval;
 
@@ -472,17 +472,17 @@ undo_string_escapes (const string& s)
     retval.append (undo_string_escape (s[i]));
 
   return retval;
 }
 
 DEFUN (undo_string_escapes, args, ,
   "undo_string_escapes (STRING)")
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     retval = undo_string_escapes (args(0).string_value ());
   else
     print_usage ("undo_string_escapes");
 
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -25,17 +25,17 @@ Software Foundation, 59 Temple Place - S
 
 class istream;
 class ostrstream;
 
 #include <string>
 
 #include "lo-utils.h"
 
-class Octave_object;
+class octave_value_list;
 class string_vector;
 
 extern char *strsave (const char *);
 
 extern string search_path_for_file (const string&, const string&);
 extern string file_in_path (const string&, const string&);
 extern string fcn_file_in_path (const string&);
 extern string oct_file_in_path (const string&);
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -119,20 +119,20 @@ is_text_function_name (const string& s)
 
 bool
 is_globally_visible (const string& name)
 {
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
   return (sr && sr->is_linked_to_global ());
 }
 
-// Is this tree_constant a valid function?
+// Is this octave_value a valid function?
 
 tree_fvc *
-is_valid_function (const tree_constant& arg, const string& warn_for, int warn)
+is_valid_function (const octave_value& arg, const string& warn_for, int warn)
 {
   tree_fvc *ans = 0;
 
   string fcn_name;
 
   if (arg.is_string ())
     fcn_name = arg.string_value ();
 
@@ -162,17 +162,17 @@ is_valid_function (const tree_constant& 
 
   return ans;
 }
 
 DEFUN (is_global, args, ,
   "is_global (X): return 1 if the string X names a global variable\n\
 otherwise, return 0.")
 {
-  Octave_object retval = 0.0;
+  octave_value_list retval = 0.0;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("is_global");
       return retval;
     }
@@ -198,17 +198,17 @@ DEFUN (exist, args, ,
 returns:\n\
 \n\
    0 : NAME is undefined\n\
    1 : NAME is a variable\n\
    2 : NAME is a function\n\
    3 : NAME is a .oct file in the current LOADPATH\n\
    5 : NAME is a built-in function")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("exist");
       return retval;
     }
@@ -242,19 +242,19 @@ returns:\n\
       retval = 1.0;
       tree_fvc *def = sr->def ();
 
       if (! struct_elts.empty ())
 	{
 	  retval = 0.0;
 	  if (def->is_constant ())
 	    {
-	      tree_constant *tmp = (tree_constant *) def;
+	      octave_value *tmp = (octave_value *) def;
 
-	      tree_constant ult	= tmp->lookup_map_element (struct_elts, 0, 1);
+	      octave_value ult	= tmp->lookup_map_element (struct_elts, 0, 1);
 
 	      if (ult.is_defined ())
 		retval = 1.0;
 	    }
 	}
     }
   else if (sr && sr->is_builtin_function ())
     {
@@ -897,17 +897,17 @@ builtin_string_variable (const string& n
   assert (sr);
 
   string retval;
 
   tree_fvc *defn = sr->def ();
 
   if (defn)
     {
-      tree_constant val = defn->eval (0);
+      octave_value val = defn->eval (0);
 
       if (! error_state && val.is_string ())
 	retval = val.string_value ();
     }
 
   return retval;
 }
 
@@ -924,34 +924,34 @@ builtin_real_scalar_variable (const stri
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   tree_fvc *defn = sr->def ();
 
   if (defn)
     {
-      tree_constant val = defn->eval (0);
+      octave_value val = defn->eval (0);
 
       if (! error_state && val.is_scalar_type ())
 	{
 	  d = val.double_value ();
 	  status = 1;
 	}
     }
 
   return status;
 }
 
 // Look for the given name in the global symbol table.
 
-tree_constant
+octave_value
 builtin_any_variable (const string& name)
 {
-  tree_constant retval;
+  octave_value retval;
 
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   tree_fvc *defn = sr->def ();
@@ -985,31 +985,31 @@ link_to_global_variable (symbol_record *
     }
 
   // There must be a better way to do this.   XXX FIXME XXX
 
   if (sr->is_variable ())
     {
       // Would be nice not to have this cast.  XXX FIXME XXX
 
-      tree_constant *tmp = (tree_constant *) sr->def ();
+      octave_value *tmp = (octave_value *) sr->def ();
       if (tmp)
-	tmp = new tree_constant (*tmp);
+	tmp = new octave_value (*tmp);
       else
-	tmp = new tree_constant ();
+	tmp = new octave_value ();
       gsr->define (tmp);
     }
   else
     sr->clear ();
 
   // If the global symbol is currently defined as a function, we need
   // to hide it with a variable.
 
   if (gsr->is_function ())
-    gsr->define ((tree_constant *) 0);
+    gsr->define ((octave_value *) 0);
 
   sr->alias (gsr, 1);
   sr->mark_as_linked_to_global ();
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable of the same name.
 
@@ -1190,17 +1190,17 @@ maybe_list (const char *header, const st
   return status;
 }
 
 DEFUN_TEXT (document, args, ,
   "document symbol string ...\n\
 \n\
 Associate a cryptic message with a variable name.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("document");
 
   if (error_state)
     return retval;
 
@@ -1225,20 +1225,20 @@ Associate a cryptic message with a varia
     print_usage ("document");
 
   return retval;
 }
 
 // XXX FIXME XXX -- this should take a list of regular expressions
 // naming the variables to look for.
 
-static Octave_object
+static octave_value_list
 do_who (int argc, const string_vector& argv)
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int show_builtins = 0;
   int show_functions = (curr_sym_tab == top_level_sym_tab);
   int show_variables = 1;
   int show_verbose = 0;
 
   string my_name = argv[0];
 
@@ -1333,17 +1333,17 @@ do_who (int argc, const string_vector& a
 }
 
 DEFUN_TEXT (who, args, ,
   "who [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("who");
 
   if (error_state)
     return retval;
 
@@ -1353,21 +1353,21 @@ character, but may not be combined.")
 }
 
 DEFUN_TEXT (whos, args, ,
   "whos [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int nargin = args.length ();
 
-  Octave_object tmp_args;
+  octave_value_list tmp_args;
   for (int i = nargin; i > 0; i--)
     tmp_args(i) = args(i-1);
   tmp_args(0) = "-long";
 
   int argc = tmp_args.length () + 1;
 
   string_vector argv = tmp_args.make_argv ("whos");
 
@@ -1428,17 +1428,17 @@ install_builtin_variable (const builtin_
     install_builtin_variable_as_function (v.name, v.value, v.protect,
 					  v.eternal, v.help_string);
   else
     bind_builtin_variable (v.name, v.value, v.protect, v.eternal,
 			   v.sv_function, v.help_string);
 }
 
 void
-install_builtin_variable_as_function (const string& name, tree_constant *val,
+install_builtin_variable_as_function (const string& name, octave_value *val,
 				      int protect, int eternal,
 				      const string& help)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, 1);
   sym_rec->unprotect ();
 
   string tmp_help = help.empty () ? sym_rec->help () : help;
 
@@ -1471,38 +1471,38 @@ alias_builtin (const string& alias, cons
 }
 
 // Defining variables.
 
 #if 0
 void
 bind_nargin_and_nargout (symbol_table *sym_tab, int nargin, int nargout)
 {
-  tree_constant *tmp;
+  octave_value *tmp;
   symbol_record *sr;
 
   sr = sym_tab->lookup ("nargin", 1, 0);
   sr->unprotect ();
-  tmp = new tree_constant (nargin);
+  tmp = new octave_value (nargin);
   sr->define (tmp);
 
   sr = sym_tab->lookup ("nargout", 1, 0);
   sr->unprotect ();
-  tmp = new tree_constant (nargout);
+  tmp = new octave_value (nargout);
   sr->define (tmp);
 }
 #endif
 
 void
-bind_ans (const tree_constant& val, int print)
+bind_ans (const octave_value& val, int print)
 {
   static symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
   tree_identifier *ans_id = new tree_identifier (sr);
-  tree_constant *tmp = new tree_constant (val);
+  octave_value *tmp = new octave_value (val);
 
   // XXX FIXME XXX -- making ans_id static, passing its address to
   // tree_simple_assignment_expression along with a flag to not delete
   // it seems to create a memory leak.  Hmm.
 
   tree_simple_assignment_expression tmp_ass (ans_id, tmp, false, true);
 
   tmp_ass.eval (print);
@@ -1535,17 +1535,17 @@ clear_global_error_variable (void *)
 
 // Give a global variable a definition.  This will insert the symbol
 // in the global table if necessary.
 
 // How is this different than install_builtin_variable?  Are both
 // functions needed?
 
 void
-bind_builtin_variable (const string& varname, tree_constant *val,
+bind_builtin_variable (const string& varname, octave_value *val,
 		       int protect, int eternal, sv_Function sv_fcn,
 		       const string& help)
 {
   symbol_record *sr = global_sym_tab->lookup (varname, 1, 0);
 
   // It is a programming error for a builtin symbol to be missing.
   // Besides, we just inserted it, so it must be there.
 
@@ -1567,21 +1567,21 @@ bind_builtin_variable (const string& var
 
   if (eternal)
     sr->make_eternal ();
 
   sr->document (help);
 }
 
 void
-bind_builtin_variable (const string& varname, const tree_constant& val,
+bind_builtin_variable (const string& varname, const octave_value& val,
 		       int protect, int eternal, sv_Function sv_fcn,
 		       const string& help)
 {
-  tree_constant *tc = new tree_constant (val);
+  octave_value *tc = new octave_value (val);
   bind_builtin_variable (varname, tc, protect, eternal, sv_fcn, help);
 }
 
 // XXX FIXME XX -- these should probably be moved to where they
 // logically belong instead of being all grouped here.
 
 // This is split up to try to make compiling with gcc consume less
 // memory and go a little faster.
@@ -1894,17 +1894,17 @@ DEFUN_TEXT (clear, args, ,
 \n\
 Clear symbol(s) matching a list of globbing patterns.\n\
 \n\
 If no arguments are given, clear all user-defined variables and
 functions.\n\
 \n\
 With -x, exclude the named variables")
 {
-  Octave_object retval;
+  octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
   if (error_state)
     return retval;
 
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -22,43 +22,43 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_variables_h)
 #define octave_variables_h 1
 
 class symbol_record;
 class symbol_table;
 
 class tree_fvc;
-class tree_constant;
-class Octave_object;
+class octave_value;
+class octave_value_list;
 class string_vector;
 
 #include <string>
 
 struct builtin_mapper_function;
 
 typedef int (*sv_Function)(void);
 
 struct builtin_variable
 {
-  builtin_variable (const string& n, tree_constant *v, int iaf, int p,
+  builtin_variable (const string& n, octave_value *v, int iaf, int p,
 		    int e, sv_Function svf, const string& h)
     : name (n), value (v), install_as_function (iaf), protect (p),
       eternal (e), sv_function (svf), help_string (h) { }
 
   string name;
-  tree_constant *value;
+  octave_value *value;
   int install_as_function;
   int protect;
   int eternal;
   sv_Function sv_function;
   string help_string;
 };
 
-typedef Octave_object (*Octave_builtin_fcn)(const Octave_object&, int);
+typedef octave_value_list (*Octave_builtin_fcn)(const octave_value_list&, int);
 
 struct builtin_function
 {
   builtin_function (const string& n, int itf, Octave_builtin_fcn f,
 		    const string& h)
     : name (n), is_text_fcn (itf), fcn (f), help_string (h) { }
 
   string name;
@@ -72,63 +72,63 @@ extern void initialize_symbol_tables (vo
 extern bool lookup (symbol_record *s, int exec_script = 1);
 
 extern symbol_record *lookup_by_name (const string& nm, int exec_script = 1);
 
 extern string get_help_from_file (const string& f);
 
 extern string builtin_string_variable (const string&);
 extern int builtin_real_scalar_variable (const string&, double&);
-extern tree_constant builtin_any_variable (const string&);
+extern octave_value builtin_any_variable (const string&);
 
 extern void link_to_global_variable (symbol_record *sr);
 extern void link_to_builtin_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
 extern void force_link_to_function (const string&);
 
 extern bool is_builtin_variable (const string&);
 extern bool is_text_function_name (const string&);
 extern bool is_globally_visible (const string&);
 
-extern tree_fvc *is_valid_function (const tree_constant&, const string&,
+extern tree_fvc *is_valid_function (const octave_value&, const string&,
 				    int warn = 0); 
 
 extern string_vector make_name_list (void);
 
 extern void install_builtin_mapper (const builtin_mapper_function& mf);
 
 extern void install_builtin_function (const builtin_function& gf);
 
 extern void install_builtin_variable (const builtin_variable& v);
 
 extern void
 install_builtin_variable_as_function
-  (const string& name, tree_constant *val, int protect = 0,
+  (const string& name, octave_value *val, int protect = 0,
    int eternal = 0, const string& help = string ());
 
 extern void alias_builtin (const string& alias, const string& name);
 
 #if 0
 extern void bind_nargin_and_nargout (symbol_table *sym_tab,
 				     int nargin, int nargout);
 #endif
 
-extern void bind_ans (const tree_constant& val, int print);
+extern void bind_ans (const octave_value& val, int print);
 
 extern void bind_global_error_variable (void);
 
 extern void clear_global_error_variable (void *);
 
-extern void bind_builtin_variable (const string&, tree_constant *,
+extern void bind_builtin_variable (const string&, octave_value *,
 				   int protect = 0, int eternal = 0,
 				   sv_Function f = (sv_Function) 0,
 				   const string& help = string ());
 
-extern void bind_builtin_variable (const string&, const tree_constant&,
+extern void bind_builtin_variable (const string&, const octave_value&,
 				   int protect = 0, int eternal = 0,
 				   sv_Function f = (sv_Function) 0,
 				   const string& help = string ());
 
 extern void install_builtin_variables (void);
 
 extern string maybe_add_default_load_path (const string& p);
 
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -74,33 +74,33 @@ xisint (double x)
 //   complex_scalar | 3 | 6 |  9 | 12 |
 //                  +---+---+----+----+
 //   complex_matrix | 4 | E | 10 |  E |
 //                  +---+---+----+----+
 //
 //   E -> error, trapped in arith-ops.cc.
 
 // -*- 1 -*-
-tree_constant
+octave_value
 xpow (double a, double b)
 {
   if (a < 0.0 && (int) b != b)
     {
       Complex atmp (a);
       return pow (atmp, b);
     }
   else
     return pow (a, b);
 }
 
 // -*- 2 -*-
-tree_constant
+octave_value
 xpow (double a, const Matrix& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
@@ -120,30 +120,30 @@ xpow (double a, const Matrix& b)
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 3 -*-
-tree_constant
+octave_value
 xpow (double a, const Complex& b)
 {
   Complex result;
   Complex atmp (a);
   result = pow (atmp, b);
   return result;
 }
 
 // -*- 4 -*-
-tree_constant
+octave_value
 xpow (double a, const ComplexMatrix& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for x^A, A must be square");
     }
@@ -165,20 +165,20 @@ xpow (double a, const ComplexMatrix& b)
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 5 -*-
-tree_constant
+octave_value
 xpow (const Matrix& a, double b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for A^b, A must be square");
     }
@@ -235,20 +235,20 @@ xpow (const Matrix& a, double b)
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
   return retval;
 }
 
 // -*- 6 -*-
-tree_constant
+octave_value
 xpow (const Matrix& a, const Complex& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for A^b, A must be square");
     }
@@ -265,34 +265,34 @@ xpow (const Matrix& a, const Complex& b)
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 7 -*-
-tree_constant
+octave_value
 xpow (const Complex& a, double b)
 {
   Complex result;
 
   if (xisint (b))
     result = pow (a, (int) b);
   else
     result = pow (a, b);
 
   return result;
 }
 
 // -*- 8 -*-
-tree_constant
+octave_value
 xpow (const Complex& a, const Matrix& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for x^A, A must be square");
     }
@@ -314,29 +314,29 @@ xpow (const Complex& a, const Matrix& b)
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 9 -*-
-tree_constant
+octave_value
 xpow (const Complex& a, const Complex& b)
 {
   Complex result;
   result = pow (a, b);
   return result;
 }
 
 // -*- 10 -*-
-tree_constant
+octave_value
 xpow (const Complex& a, const ComplexMatrix& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for x^A, A must be square");
     }
@@ -358,20 +358,20 @@ xpow (const Complex& a, const ComplexMat
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 11 -*-
-tree_constant
+octave_value
 xpow (const ComplexMatrix& a, double b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for A^b, A must be square");
     }
@@ -428,20 +428,20 @@ xpow (const ComplexMatrix& a, double b)
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
   return retval;
 }
 
 // -*- 12 -*-
-tree_constant
+octave_value
 xpow (const ComplexMatrix& a, const Complex& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       error ("for A^b, A must be square");
     }
@@ -473,20 +473,20 @@ xpow (const ComplexMatrix& a, const Comp
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
 // -*- 1 -*-
-tree_constant
+octave_value
 elem_xpow (double a, const Matrix& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
   // For now, assume the worst.
 
   if (a < 0.0)
     {
@@ -507,35 +507,35 @@ elem_xpow (double a, const Matrix& b)
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
-tree_constant
+octave_value
 elem_xpow (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return result;
 }
 
 // -*- 3 -*-
-tree_constant
+octave_value
 elem_xpow (const Matrix& a, double b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   if ((int) b != b && any_element_is_negative (a))
     {
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
@@ -556,20 +556,20 @@ elem_xpow (const Matrix& a, double b)
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 4 -*-
-tree_constant
+octave_value
 elem_xpow (const Matrix& a, const Matrix& b)
 {
-  tree_constant retval;
+  octave_value retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   int convert_to_complex = 0;
   for (int j = 0; j < nc; j++)
@@ -610,49 +610,49 @@ elem_xpow (const Matrix& a, const Matrix
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
-tree_constant
+octave_value
 elem_xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return result;
 }
 
 // -*- 6 -*-
-tree_constant
+octave_value
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
   return result;
 }
 
 // -*- 7 -*-
-tree_constant
+octave_value
 elem_xpow (const Complex& a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
@@ -663,32 +663,32 @@ elem_xpow (const Complex& a, const Matri
 	else
 	  result.elem (i, j) = pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
-tree_constant
+octave_value
 elem_xpow (const Complex& a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return result;
 }
 
 // -*- 9 -*-
-tree_constant
+octave_value
 elem_xpow (const ComplexMatrix& a, double b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
@@ -703,17 +703,17 @@ elem_xpow (const ComplexMatrix& a, doubl
 	for (int i = 0; i < nr; i++)
 	  result.elem (i, j) = pow (a.elem (i, j), b);
     }
 
   return result;
 }
 
 // -*- 10 -*-
-tree_constant
+octave_value
 elem_xpow (const ComplexMatrix& a, const Matrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
@@ -726,32 +726,32 @@ elem_xpow (const ComplexMatrix& a, const
 	else
 	  result.elem (i, j) = pow (a.elem (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
-tree_constant
+octave_value
 elem_xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return result;
 }
 
 // -*- 12 -*-
-tree_constant
+octave_value
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
diff --git a/src/xpow.h b/src/xpow.h
--- a/src/xpow.h
+++ b/src/xpow.h
@@ -22,49 +22,49 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_xpow_h)
 #define octave_xpow_h 1
 
 #include "oct-cmplx.h"
 
 class Matrix;
 class ComplexMatrix;
-class tree_constant;
+class octave_value;
 
-extern tree_constant xpow (double a, double b);
-extern tree_constant xpow (double a, const Matrix& b);
-extern tree_constant xpow (double a, const Complex& b);
-extern tree_constant xpow (double a, const ComplexMatrix& b);
+extern octave_value xpow (double a, double b);
+extern octave_value xpow (double a, const Matrix& b);
+extern octave_value xpow (double a, const Complex& b);
+extern octave_value xpow (double a, const ComplexMatrix& b);
 
-extern tree_constant xpow (const Matrix& a, double b);
-extern tree_constant xpow (const Matrix& a, const Complex& b);
+extern octave_value xpow (const Matrix& a, double b);
+extern octave_value xpow (const Matrix& a, const Complex& b);
 
-extern tree_constant xpow (const Complex& a, double b);
-extern tree_constant xpow (const Complex& a, const Matrix& b);
-extern tree_constant xpow (const Complex& a, const Complex& b);
-extern tree_constant xpow (const Complex& a, const ComplexMatrix& b);
+extern octave_value xpow (const Complex& a, double b);
+extern octave_value xpow (const Complex& a, const Matrix& b);
+extern octave_value xpow (const Complex& a, const Complex& b);
+extern octave_value xpow (const Complex& a, const ComplexMatrix& b);
 
-extern tree_constant xpow (const ComplexMatrix& a, double b);
-extern tree_constant xpow (const ComplexMatrix& a, const Complex& b);
+extern octave_value xpow (const ComplexMatrix& a, double b);
+extern octave_value xpow (const ComplexMatrix& a, const Complex& b);
 
-extern tree_constant elem_xpow (double a, const Matrix& b);
-extern tree_constant elem_xpow (double a, const ComplexMatrix& b);
+extern octave_value elem_xpow (double a, const Matrix& b);
+extern octave_value elem_xpow (double a, const ComplexMatrix& b);
 
-extern tree_constant elem_xpow (const Matrix& a, double b);
-extern tree_constant elem_xpow (const Matrix& a, const Matrix& b);
-extern tree_constant elem_xpow (const Matrix& a, const Complex& b);
-extern tree_constant elem_xpow (const Matrix& a, const ComplexMatrix& b);
+extern octave_value elem_xpow (const Matrix& a, double b);
+extern octave_value elem_xpow (const Matrix& a, const Matrix& b);
+extern octave_value elem_xpow (const Matrix& a, const Complex& b);
+extern octave_value elem_xpow (const Matrix& a, const ComplexMatrix& b);
 
-extern tree_constant elem_xpow (const Complex& a, const Matrix& b);
-extern tree_constant elem_xpow (const Complex& a, const ComplexMatrix& b);
+extern octave_value elem_xpow (const Complex& a, const Matrix& b);
+extern octave_value elem_xpow (const Complex& a, const ComplexMatrix& b);
 
-extern tree_constant elem_xpow (const ComplexMatrix& a, double b);
-extern tree_constant elem_xpow (const ComplexMatrix& a, const Matrix& b);
-extern tree_constant elem_xpow (const ComplexMatrix& a, const Complex& b);
-extern tree_constant elem_xpow (const ComplexMatrix& a,
+extern octave_value elem_xpow (const ComplexMatrix& a, double b);
+extern octave_value elem_xpow (const ComplexMatrix& a, const Matrix& b);
+extern octave_value elem_xpow (const ComplexMatrix& a, const Complex& b);
+extern octave_value elem_xpow (const ComplexMatrix& a,
 				const ComplexMatrix& b);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
