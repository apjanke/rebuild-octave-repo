# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1395333079 14400
#      Thu Mar 20 12:31:19 2014 -0400
# Node ID cd83730e5e38ba0d9ef0516c24c9a787371aa995
# Parent  89a8a90ac8508a3ddfde0867eeb50dc9e73dbe98
# Parent  ebd063b7b1c67aa83d349cd59d5679ecf5bb6684
maint: Periodic merge of gui-release to default.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -60,16 +60,20 @@ Summary of important user-visible change
 
     is now enabled by default and the warning ID
 
       Octave:noninteger-range-as-index
 
     is now set to "on" by default instead of "error" by default and "on"
     for --traditional.
 
+ ** polyeig now returns a row vector of eigenvalues rather than a matrix
+    with the eigenvalues on the diagonal.  This change was made for Matlab
+    compatibility.
+
  ** Other new functions added in 4.0.0:
 
       validateattributes
 
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.6 and have been
     removed from Octave 4.0.
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -1,15 +1,16 @@
 Ben Abbott
 Andy Adler
 Adam H. Aitkenhead
 Giles Anderson
 Joel Andersson
 Muthiah Annamalai
 Markus Appel
+Branden Archer
 Marco Atzeri
 Shai Ayal
 Roger Banks
 Ben Barrowes
 Alexander Barth
 David Bateman
 Heinz Bauschke
 Julien Bect
diff --git a/libgui/qterminal/libqterminal/QTerminal.h b/libgui/qterminal/libqterminal/QTerminal.h
--- a/libgui/qterminal/libqterminal/QTerminal.h
+++ b/libgui/qterminal/libqterminal/QTerminal.h
@@ -88,16 +88,18 @@ signals:
   void interrupt_signal (void);
 
 public slots:
 
   virtual void copyClipboard (void) = 0;
 
   virtual void pasteClipboard (void) = 0;
 
+  virtual void selectAll (void) = 0;
+
   virtual void handleCustomContextMenuRequested (const QPoint& at)
   {
     QClipboard * cb = QApplication::clipboard ();
 
     _paste_action->setEnabled (cb->text().length() > 0);
     _copy_action->setEnabled (selectedText().length() > 0);
 
     _contextMenu->move (mapToGlobal (at));
@@ -121,16 +123,22 @@ protected:
                      tr ("Copy"), this, SLOT (copyClipboard ()));
 
     _paste_action = _contextMenu->addAction (
                       QIcon (":/actions/icons/editpaste.png"),
                       tr ("Paste"), this, SLOT (pasteClipboard ()));
 
     _contextMenu->addSeparator ();
 
+    _selectall_action = _contextMenu->addAction (
+                      tr ("Select All"), this, SLOT (selectAll ()));
+
+
+    _contextMenu->addSeparator ();
+
     _contextMenu->addAction (tr ("Clear All"), parent (),
                              SLOT (handle_clear_command_window_request ()));
 
     connect (this, SIGNAL (customContextMenuRequested (QPoint)),
              this, SLOT (handleCustomContextMenuRequested (QPoint)));
 
     connect (this, SIGNAL (report_status_message (const QString&)),
              xparent, SLOT (report_status_message (const QString&)));
@@ -138,18 +146,22 @@ protected:
     connect (xparent, SIGNAL (settings_changed (const QSettings *)),
              this, SLOT (notice_settings (const QSettings *)));
 
     connect (xparent, SIGNAL (copyClipboard_signal ()),
              this, SLOT (copyClipboard ()));
 
     connect (xparent, SIGNAL (pasteClipboard_signal ()),
              this, SLOT (pasteClipboard ()));
+
+    connect (xparent, SIGNAL (selectAll_signal ()),
+             this, SLOT (selectAll ()));
   }
 
 private:
 
   QMenu *_contextMenu;
   QAction * _copy_action;
   QAction * _paste_action;
+  QAction * _selectall_action;
 };
 
 #endif // QTERMINAL_H
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
@@ -200,12 +200,18 @@ void QUnixTerminalImpl::copyClipboard()
     m_terminalView->copyClipboard();
 }
 
 void QUnixTerminalImpl::pasteClipboard()
 {
     m_terminalView->pasteClipboard();
 }
 
+void QUnixTerminalImpl::selectAll()
+{
+    m_terminalView->selectAll();
+}
+
+
 QString QUnixTerminalImpl::selectedText ()
 {
   return m_terminalView->selectedText ();
 }
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
@@ -48,16 +48,17 @@ public:
     void setSelectionColor (const QColor& color);
     void setCursorColor (bool useForegroundColor, const QColor& color);
 
     QString selectedText();
 
 public slots:
     void copyClipboard();
     void pasteClipboard();
+    void selectAll();
 
 protected:
     void showEvent(QShowEvent *);
     virtual void resizeEvent(QResizeEvent *);   
 
 private:
     void initialize();
     void connectToPty();
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.cpp b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalView.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
@@ -2282,16 +2282,30 @@ void TerminalView::copyClipboard()
 void TerminalView::pasteClipboard()
 {
   if(hasFocus ())
     {
       emitSelection(false,false);
     }
 }
 
+void TerminalView::selectAll()
+{
+  if ( !_screenWindow || !hasFocus())
+    return;
+
+  _screenWindow->setSelectionStart(0,-_screenWindow->currentLine(), false);
+  //_screenWindow->setSelectionEnd(_screenWindow->windowColumns(),
+  //                               _screenWindow->windowLines());
+
+  _screenWindow->setSelectionEnd(_screenWindow->columnCount(),
+                                 _screenWindow->windowLines());
+}
+
+
 void TerminalView::pasteSelection()
 {
   emitSelection(true,false);
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Keyboard                                   */
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.h b/libgui/qterminal/libqterminal/unix/TerminalView.h
--- a/libgui/qterminal/libqterminal/unix/TerminalView.h
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.h
@@ -411,16 +411,21 @@ public slots:
      */
     void pasteClipboard();
     /**
      * Pastes the content of the selection into the
      * display.
      */
     void pasteSelection();
 
+    /**
+     * selects all content 
+     */
+    void selectAll();
+
 	 /**
 	 * Causes the widget to display or hide a message informing the user that terminal
 	 * output has been suspended (by using the flow control key combination Ctrl+S)
 	 *
 	 * @param suspended True if terminal output has been suspended and the warning message should
 	 *				 	be shown or false to indicate that terminal output has been resumed and that
 	 *				 	the warning message should disappear.
 	 */
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
@@ -178,16 +178,17 @@ public:
   void grabConsoleBuffer (CHAR_INFO* buf = 0);
   void updateScrollBar (void);
   void setScrollValue (int value);
   void updateConsoleView (bool grab = true);
   void monitorConsole (void);
   void startCommand (void);
   void sendConsoleText (const QString& s);
   QRect cursorRect (void);
+  void selectAll();
 
   void log (const char* fmt, ...);
 
   void closeStandardIO (int fd, DWORD stdHandleId, const char* name);
   void setupStandardIO (DWORD stdHandleId, int fd, const char* name,
                         const char* devName);
 
   QPoint posToCell (const QPoint& pt);
@@ -652,16 +653,24 @@ void QConsolePrivate::drawTextBackground
           if (attr & 0x00f0)
             p.fillRect (x, y-ascent, len * cw, ch, p.brush ());
         }
     }
 
   p.restore ();
 }
 
+void QConsolePrivate::selectAll()
+{
+  m_beginSelection = QPoint (0,0);
+  m_endSelection = QPoint(m_bufferSize.width (), 
+                          m_cursorPos.y());
+  updateSelection();
+}
+
 void QConsolePrivate::drawSelection (QPainter& p, int cx1, int cy1,
                                      int cx2, int cy2, int cw, int ch)
 {
   p.save ();
 
   QPoint begin = m_beginSelection;
   QPoint end = m_endSelection;
 
@@ -1547,16 +1556,26 @@ void QWinTerminalImpl::pasteClipboard (v
   if(!hasFocus()) return;
 
   QString text = QApplication::clipboard()->text (QClipboard::Clipboard);
 
   if (! text.isEmpty ())
     sendText (text);
 }
 
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::selectAll (void)
+{
+  if(!hasFocus()) return;
+
+  d->selectAll();
+}
+
+
 
 //////////////////////////////////////////////////////////////////////////////
 
 QString QWinTerminalImpl::selectedText ()
 {
   QString selection = d->getSelection ();
   return selection;
 }
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
@@ -61,16 +61,17 @@ public:
   void setSelectionColor (const QColor& color);
   void setCursorColor (bool useForegoundColor, const QColor& color);
 
   QString selectedText ();
 
 public slots:
   void copyClipboard (void);
   void pasteClipboard (void);
+  void selectAll (void);
   void blinkCursorEvent (void);
 
 signals:
   void terminated (void);
   void titleChanged (const QString&);
   void set_global_shortcuts_signal (bool);
 
 protected:
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -47,16 +47,22 @@ documentation_dock_widget::copyClipboard
   _webinfo->copyClipboard ();
 }
 void
 documentation_dock_widget::pasteClipboard ()
 {
   _webinfo->pasteClipboard ();
 }
 void
+documentation_dock_widget::selectAll ()
+{
+  _webinfo->selectAll ();
+}
+
+void
 documentation_dock_widget::showDoc (const QString &name)
 {
   // show the doc pane
   if (!isVisible ())
     setVisible (true);
   setFocus ();
   raise ();
 
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -33,16 +33,17 @@ class documentation_dock_widget : public
 
 public:
 
   documentation_dock_widget (QWidget *parent = 0);
 
 protected slots:
   void copyClipboard ();
   void pasteClipboard ();
+  void selectAll ();
 
   void showDoc (const QString & name);
 private:
 
   webinfo *_webinfo;
 };
 
 #endif // DOCUMENTATIONDOCKWIDGET_H
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -919,10 +919,25 @@ files_dock_widget::pasteClipboard ()
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
       QLineEdit * edit = _current_directory->lineEdit ();
       if (edit && str.length () > 0)
         edit->insert (str);
     }
 }
 
+void
+files_dock_widget::selectAll ()
+{
+  if (_file_tree_view->hasFocus ())
+    _file_tree_view->selectAll ();
+  if (_current_directory->hasFocus ())
+    {
+      QLineEdit * edit = _current_directory->lineEdit ();
+      if (edit)
+        {
+          edit->selectAll ();
+        }
+    }
+}
 
 
+
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -108,16 +108,17 @@ private slots:
   void popdownmenu_newdir (bool);
   void popdownmenu_search_dir (bool);
   void popdownmenu_findfiles (bool);
   void popdownmenu_home (bool);
 
   /* from octave_doc_widget */
   void copyClipboard ();
   void pasteClipboard ();
+  void selectAll ();
 
 signals:
 
   /** Emitted, whenever the user requested to open a file. */
   void open_file (const QString& fileName);
 
   /** Emitted, whenever the currently displayed directory changed. */
   void displayed_directory_changed (const QString& dir);
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -217,8 +217,21 @@ history_dock_widget::pasteClipboard ()
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
       if (str.length () > 0)
         _filter_line_edit->insert (str);
     }
 }
 
+void
+history_dock_widget::selectAll ()
+{
+  if (_filter_line_edit->hasFocus ())
+    {
+        _filter_line_edit->selectAll ();
+    }
+  if (_history_list_view->hasFocus ())
+    {
+        _history_list_view->selectAll ();
+    }
+}
+
diff --git a/libgui/src/history-dock-widget.h b/libgui/src/history-dock-widget.h
--- a/libgui/src/history-dock-widget.h
+++ b/libgui/src/history-dock-widget.h
@@ -59,16 +59,17 @@ private slots:
   void handle_double_click (QModelIndex modelIndex);
   void handle_contextmenu_copy (bool flag);
   void handle_contextmenu_evaluate (bool flag);
   void handle_contextmenu_create_script (bool flag);
   void ctxMenu (const QPoint &pos);
 
   void copyClipboard ();
   void pasteClipboard ();
+  void selectAll ();
 
 private:
 
   void construct ();
   QListView *_history_list_view;
   QLineEdit *_filter_line_edit;
   QSortFilterProxyModel _sort_filter_proxy_model;
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -446,16 +446,26 @@ file_editor_tab::paste (const QWidget *I
 {
   if (ID != this)
     return;
 
   _edit_area->paste ();
 }
 
 void
+file_editor_tab::select_all (const QWidget *ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->selectAll ();
+}
+
+
+void
 file_editor_tab::context_help (const QWidget *ID, bool doc)
 {
   if (ID != this)
     return;
 
   _edit_area->context_help_doc (doc);
 }
 
@@ -761,16 +771,47 @@ file_editor_tab::unindent_selected_text 
   if (ID != this)
     return;
 
   do_indent_selected_text (false);
 }
 
 
 void
+file_editor_tab::zoom_in (const QWidget *ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->zoomIn (1);
+  auto_margin_width ();
+}
+
+void
+file_editor_tab::zoom_out (const QWidget *ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->zoomOut (1);
+  auto_margin_width ();
+}
+
+void
+file_editor_tab::zoom_normal (const QWidget *ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->zoomTo (0);
+  auto_margin_width ();
+}
+
+
+void
 file_editor_tab::handle_find_dialog_finished (int)
 {
   // Find dialog is going to hide.  Save location of window for
   // when it is reshown.
   _find_dialog_geometry = _find_dialog->geometry ();
   _find_dialog_is_visible = false;
 }
 
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -67,16 +67,17 @@ public slots:
   void file_name_query (const QWidget *ID);
 
   void set_focus (const QWidget *ID);
   void undo (const QWidget *ID);
   void redo (const QWidget *ID);
   void copy (const QWidget *ID);
   void cut (const QWidget *ID);
   void paste (const QWidget *ID);
+  void select_all (const QWidget *ID);
   void context_help (const QWidget *ID, bool);
   void context_edit (const QWidget *ID);
   void save_file (const QWidget *ID);
   void save_file (const QWidget *ID, const QString& fileName,
                   bool remove_on_success);
   void save_file_as (const QWidget *ID);
   void print_file (const QWidget *ID);
   void run_file (const QWidget *ID);
@@ -92,16 +93,20 @@ public slots:
   void remove_all_breakpoints (const QWidget *ID);
 
   void comment_selected_text (const QWidget *ID);
   void uncomment_selected_text (const QWidget *ID);
 
   void indent_selected_text (const QWidget *ID);
   void unindent_selected_text (const QWidget *ID);
 
+  void zoom_in (const QWidget *ID);
+  void zoom_out (const QWidget *ID);
+  void zoom_normal (const QWidget *ID);
+
   void find (const QWidget *ID);
   void goto_line (const QWidget *ID, int line = -1);
   void show_auto_completion (const QWidget *ID);
 
   void insert_debugger_pointer (const QWidget *ID, int line = -1);
   void delete_debugger_pointer (const QWidget *ID, int line = -1);
 
   void do_breakpoint_marker (bool insert, const QWidget *ID, int line = -1);
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -590,16 +590,23 @@ file_editor::request_cut (void)
 
 void
 file_editor::request_paste (void)
 {
   emit fetab_paste (_tab_widget->currentWidget ());
 }
 
 void
+file_editor::request_selectall (void)
+{
+  emit fetab_selectall (_tab_widget->currentWidget ());
+}
+
+
+void
 file_editor::request_context_help (bool)
 {
   emit fetab_context_help (_tab_widget->currentWidget (), false);
 }
 void
 file_editor::request_context_doc (bool)
 {
   emit fetab_context_help (_tab_widget->currentWidget (), true);
@@ -858,16 +865,34 @@ file_editor::handle_add_filename_to_list
 
 void
 file_editor::active_tab_changed (int index)
 {
   emit fetab_change_request (_tab_widget->widget (index));
 }
 
 void
+file_editor::zoom_in (bool)
+{
+  emit fetab_zoom_in (_tab_widget->currentWidget ());
+}
+
+void
+file_editor::zoom_out (bool)
+{
+  emit fetab_zoom_out (_tab_widget->currentWidget ());
+}
+
+void
+file_editor::zoom_normal (bool)
+{
+  emit fetab_zoom_normal (_tab_widget->currentWidget ());
+}
+
+void
 file_editor::handle_editor_state_changed (bool copy_available,
                                           const QString& file_name)
 {
   // In case there is some scenario where traffic could be coming from
   // all the file editor tabs, just process info from the current active tab.
   if (sender () == _tab_widget->currentWidget ())
     {
       _copy_action->setEnabled (copy_available);
@@ -935,18 +960,20 @@ file_editor::request_styles_preferences 
 
 void
 file_editor::construct (void)
 {
   QWidget *editor_widget = new QWidget (this);
 
   // FIXME: what was the intended purpose of this unused variable?
   // QStyle *editor_style = QApplication::style ();
-
   _menu_bar = new QMenuBar (editor_widget);
+#if defined (Q_OS_MAC)
+  _menu_bar->setNativeMenuBar (false);
+#endif
   _tool_bar = new QToolBar (editor_widget);
   _tool_bar->setMovable (true);
   _tab_widget = new QTabWidget (editor_widget);
   _tab_widget->setTabsClosable (true);
 #ifdef HAVE_QTABWIDGET_SETMOVABLE
   _tab_widget->setMovable (true);
 #endif
 
@@ -1001,16 +1028,19 @@ file_editor::construct (void)
                    tr ("Pre&vious Breakpoint"), _tool_bar);
   QAction *toggle_breakpoint_action
     = new QAction (QIcon (":/actions/icons/bp_toggle.png"),
                    tr ("Toggle &Breakpoint"), _tool_bar);
   QAction *remove_all_breakpoints_action
     = new QAction (QIcon (":/actions/icons/bp_rm_all.png"),
                    tr ("&Remove All Breakpoints"), _tool_bar);
 
+  _selectall_action
+    = new QAction (tr ("Select All"), _tool_bar);
+
   _comment_selection_action
     = new QAction (tr ("&Comment"), _tool_bar);
   _uncomment_selection_action
     = new QAction (tr ("&Uncomment"), _tool_bar);
 
   _indent_selection_action
     = new QAction (tr ("&Indent"), _tool_bar);
   _unindent_selection_action
@@ -1123,16 +1153,18 @@ file_editor::construct (void)
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
   editMenu->addAction (_undo_action);
   editMenu->addAction (_redo_action);
   editMenu->addSeparator ();
   editMenu->addAction (_copy_action);
   editMenu->addAction (_cut_action);
   editMenu->addAction (_paste_action);
   editMenu->addSeparator ();
+  editMenu->addAction (_selectall_action);
+  editMenu->addSeparator ();
   editMenu->addAction (_find_action);
   editMenu->addSeparator ();
   editMenu->addAction (_comment_selection_action);
   editMenu->addAction (_uncomment_selection_action);
   editMenu->addAction (_indent_selection_action);
   editMenu->addAction (_unindent_selection_action);
   editMenu->addSeparator ();
   editMenu->addAction (_completion_action);
@@ -1149,16 +1181,25 @@ file_editor::construct (void)
                          tr ("&Preferences..."),
                          this, SLOT (request_preferences (bool)));
   _styles_preferences_action =
     editMenu->addAction (QIcon (":/actions/icons/configure.png"),
                          tr ("&Styles Preferences..."),
                          this, SLOT (request_styles_preferences (bool)));
   _menu_bar->addMenu (editMenu);
 
+  QMenu *view_menu = new QMenu (tr ("&View"), _menu_bar);
+  _zoom_in_action = view_menu->addAction (QIcon (), tr ("Zoom &In"),
+                                this, SLOT (zoom_in (bool)));
+  _zoom_out_action = view_menu->addAction (QIcon (), tr ("Zoom &Out"),
+                                this, SLOT (zoom_out (bool)));
+  _zoom_normal_action = view_menu->addAction (QIcon (), tr ("&Normal Size"),
+                                this, SLOT (zoom_normal (bool)));
+  _menu_bar->addMenu (view_menu);
+
   _debug_menu = new QMenu (tr ("&Debug"), _menu_bar);
   _debug_menu->addAction (toggle_breakpoint_action);
   _debug_menu->addAction (next_breakpoint_action);
   _debug_menu->addAction (previous_breakpoint_action);
   _debug_menu->addAction (remove_all_breakpoints_action);
   _debug_menu->addSeparator ();
   // The other debug actions will be added by the main window.
   _menu_bar->addMenu (_debug_menu);
@@ -1219,16 +1260,19 @@ file_editor::construct (void)
            this, SLOT (request_copy ()));
 
   connect (_cut_action, SIGNAL (triggered ()),
            this, SLOT (request_cut ()));
 
   connect (_paste_action, SIGNAL (triggered ()),
            this, SLOT (request_paste ()));
 
+  connect (_selectall_action, SIGNAL (triggered ()),
+           this, SLOT (request_selectall ()));
+
   connect (_save_action, SIGNAL (triggered ()),
            this, SLOT (request_save_file ()));
 
   connect (_save_as_action, SIGNAL (triggered ()),
            this, SLOT (request_save_file_as ()));
 
   connect (_print_action, SIGNAL (triggered ()),
            this, SLOT (request_print_file ()));
@@ -1372,16 +1416,26 @@ file_editor::add_file_editor_tab (file_e
            f, SLOT (copy (const QWidget*)));
 
   connect (this, SIGNAL (fetab_cut (const QWidget*)),
            f, SLOT (cut (const QWidget*)));
 
   connect (this, SIGNAL (fetab_paste (const QWidget*)),
            f, SLOT (paste (const QWidget*)));
 
+  connect (this, SIGNAL (fetab_selectall (const QWidget*)),
+           f, SLOT (select_all (const QWidget*)));
+
+  connect (this, SIGNAL (fetab_zoom_in (const QWidget*)),
+           f, SLOT (zoom_in (const QWidget*)));
+  connect (this, SIGNAL (fetab_zoom_out (const QWidget*)),
+           f, SLOT (zoom_out (const QWidget*)));
+  connect (this, SIGNAL (fetab_zoom_normal (const QWidget*)),
+           f, SLOT (zoom_normal (const QWidget*)));
+
   connect (this, SIGNAL (fetab_context_help (const QWidget*, bool)),
            f, SLOT (context_help (const QWidget*, bool)));
 
   connect (this, SIGNAL (fetab_context_edit (const QWidget*)),
            f, SLOT (context_edit (const QWidget*)));
 
   connect (this, SIGNAL (fetab_save_file (const QWidget*)),
            f, SLOT (save_file (const QWidget*)));
@@ -1476,16 +1530,27 @@ file_editor::pasteClipboard ()
 {
   QWidget * foc_w = focusWidget ();
 
   if (foc_w && foc_w->inherits ("octave_qscintilla"))
     {
       request_paste ();
     }
 }
+void
+file_editor::selectAll ()
+{
+  QWidget * foc_w = focusWidget ();
+
+  if (foc_w && foc_w->inherits ("octave_qscintilla"))
+    {
+      request_selectall ();
+    }
+}
+
 
 void
 file_editor::set_shortcuts (bool set)
 {
   if (set)
     {
       _comment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_R);
       _uncomment_selection_action->setShortcut (Qt::SHIFT
@@ -1495,19 +1560,24 @@ file_editor::set_shortcuts (bool set)
       _indent_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_Tab);
       _unindent_selection_action->setShortcut (Qt::SHIFT
                                                 + Qt::ControlModifier
                                                 + Qt::Key_Tab);
 
       _copy_action->setShortcut (QKeySequence::Copy);
       _cut_action->setShortcut (QKeySequence::Cut);
       _paste_action->setShortcut (QKeySequence::Paste);
+      _selectall_action->setShortcut (QKeySequence::SelectAll);
       _context_help_action->setShortcut (QKeySequence::HelpContents);
       _context_doc_action->setShortcut (Qt::SHIFT + Qt::Key_F1);
 
+      _zoom_in_action->setShortcuts (QKeySequence::ZoomIn);
+      _zoom_out_action->setShortcuts (QKeySequence::ZoomOut);
+      _zoom_normal_action->setShortcut (Qt::ControlModifier + Qt::Key_Slash);
+
       _find_action->setShortcut (QKeySequence::Find);
       _goto_line_action->setShortcut (Qt::ControlModifier+ Qt::Key_G);
       _completion_action->setShortcut (Qt::ControlModifier + Qt::Key_Space);
 
       _next_bookmark_action->setShortcut (Qt::Key_F2);
       _previous_bookmark_action->setShortcut (Qt::SHIFT + Qt::Key_F2);
       _toggle_bookmark_action->setShortcut (Qt::Key_F7);
 
@@ -1531,18 +1601,23 @@ file_editor::set_shortcuts (bool set)
       _uncomment_selection_action->setShortcut (no_key);
 
       _indent_selection_action->setShortcut (no_key);
       _unindent_selection_action->setShortcut (no_key);
 
       _copy_action->setShortcut (no_key);
       _cut_action->setShortcut (no_key);
       _paste_action->setShortcut (no_key);
+      _selectall_action->setShortcut (no_key);
       _context_help_action->setShortcut (no_key);
 
+      _zoom_in_action->setShortcut (no_key);
+      _zoom_out_action->setShortcut (no_key);
+      _zoom_normal_action->setShortcut (no_key);
+
       _find_action->setShortcut (no_key);
       _goto_line_action->setShortcut (no_key);
       _completion_action->setShortcut (no_key);
 
       _next_bookmark_action->setShortcut (no_key);
       _previous_bookmark_action->setShortcut (no_key);
       _toggle_bookmark_action->setShortcut (no_key);
 
@@ -1570,16 +1645,20 @@ file_editor::check_actions ()
 
   _indent_selection_action->setEnabled (have_tabs);
   _unindent_selection_action->setEnabled (have_tabs);
 
   _paste_action->setEnabled (have_tabs);
   _context_help_action->setEnabled (have_tabs);
   _context_doc_action->setEnabled (have_tabs);
 
+  _zoom_in_action->setEnabled (have_tabs);
+  _zoom_out_action->setEnabled (have_tabs);
+  _zoom_normal_action->setEnabled (have_tabs);
+
   _find_action->setEnabled (have_tabs);
   _goto_line_action->setEnabled (have_tabs);
   _completion_action->setEnabled (have_tabs);
 
   _next_bookmark_action->setEnabled (have_tabs);
   _previous_bookmark_action->setEnabled (have_tabs);
   _toggle_bookmark_action->setEnabled (have_tabs);
   _remove_bookmark_action->setEnabled (have_tabs);
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -71,16 +71,17 @@ signals:
                         bool remove_on_success);
   // No fetab_open, functionality in editor
   // No fetab_new, functionality in editor
   void fetab_undo (const QWidget* ID);
   void fetab_redo (const QWidget* ID);
   void fetab_copy (const QWidget* ID);
   void fetab_cut (const QWidget* ID);
   void fetab_paste (const QWidget* ID);
+  void fetab_selectall (const QWidget* ID);
   void fetab_context_help (const QWidget* ID, bool);
   void fetab_context_edit (const QWidget* ID);
   void fetab_save_file (const QWidget* ID);
   void fetab_save_file_as (const QWidget* ID);
   void fetab_print_file (const QWidget* ID);
   void fetab_run_file (const QWidget* ID);
   void fetab_context_run (const QWidget* ID);
   void fetab_toggle_bookmark (const QWidget* ID);
@@ -98,16 +99,21 @@ signals:
   void fetab_find (const QWidget* ID);
   void fetab_goto_line (const QWidget* ID, int line = -1);
   void fetab_completion (const QWidget*);
   void fetab_insert_debugger_pointer (const QWidget* ID, int line = -1);
   void fetab_delete_debugger_pointer (const QWidget* ID, int line = -1);
   void fetab_do_breakpoint_marker (bool insert, const QWidget* ID,
                                    int line = -1);
   void fetab_set_focus (const QWidget* ID);
+
+  void fetab_zoom_in (const QWidget* ID);
+  void fetab_zoom_out (const QWidget* ID);
+  void fetab_zoom_normal (const QWidget* ID);
+
   void request_settings_dialog (const QString&);
   void execute_command_in_terminal_signal (const QString&);
   void file_loaded_signal ();
 
 public slots:
   void focus (void);
 
   void request_new_file (const QString& commands);
@@ -120,16 +126,17 @@ public slots:
   void request_mru_open_file (QAction *action);
   void request_print_file (void);
 
   void request_undo (void);
   void request_redo (void);
   void request_copy (void);
   void request_cut (void);
   void request_paste (void);
+  void request_selectall (void);
   void request_context_help (bool);
   void request_context_doc (bool);
   void request_context_edit (bool);
   void request_save_file (void);
   void request_save_file_as (void);
   void request_run_file (void);
   void request_context_run (bool);
   void request_toggle_bookmark (void);
@@ -177,27 +184,32 @@ public slots:
   void set_shortcuts (bool set_shortcuts);
 
   void handle_visibility (bool visible);
 
 
 protected slots:
   void copyClipboard ();
   void pasteClipboard ();
+  void selectAll ();
 
 private slots:
 
   void request_open_files (const QStringList&);
   void request_open_file (const QString& fileName, int line = -1,
                           bool debug_pointer = false,
                           bool breakpoint_marker = false, bool insert = true);
   void request_preferences (bool);
   void request_styles_preferences (bool);
   void restore_create_file_setting ();
 
+  void zoom_in (bool);
+  void zoom_out (bool);
+  void zoom_normal (bool);
+
 private:
 
   bool is_editor_console_tabbed ();
   void construct (void);
   void add_file_editor_tab (file_editor_tab *f, const QString& fn);
   void save_file_as (QWidget *fetabID = 0);
   void mru_menu_update (void);
   bool call_custom_editor (const QString& file_name = QString (), int line = -1);
@@ -216,19 +228,24 @@ private:
   QAction *_uncomment_selection_action;
 
   QAction *_indent_selection_action;
   QAction *_unindent_selection_action;
 
   QAction *_copy_action;
   QAction *_cut_action;
   QAction *_paste_action;
+  QAction *_selectall_action;
   QAction *_context_help_action;
   QAction *_context_doc_action;
 
+  QAction *_zoom_in_action;
+  QAction *_zoom_out_action;
+  QAction *_zoom_normal_action;
+
   QAction *_find_action;
   QAction *_goto_line_action;
   QAction *_completion_action;
 
   QAction *_next_bookmark_action;
   QAction *_previous_bookmark_action;
   QAction *_toggle_bookmark_action;
   QAction * _remove_bookmark_action;
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -24,23 +24,29 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #ifdef HAVE_QSCINTILLA
 
 #include <Qsci/qscilexer.h>
+#include <QShortcut>
 
 #include "octave-qscintilla.h"
 #include "file-editor-tab.h"
 
 octave_qscintilla::octave_qscintilla (QWidget *p)
   : QsciScintilla (p)
-{ }
+{
+  // disable zoom-in/out shortcuts, these are handled by octave
+  SendScintilla (QsciScintillaBase::SCI_CLEARCMDKEY, '+' + (QsciScintillaBase::SCMOD_CTRL << 16) );
+  SendScintilla (QsciScintillaBase::SCI_CLEARCMDKEY, '-' + (QsciScintillaBase::SCMOD_CTRL << 16) );
+  SendScintilla (QsciScintillaBase::SCI_CLEARCMDKEY, '/' + (QsciScintillaBase::SCMOD_CTRL << 16) );
+}
 
 octave_qscintilla::~octave_qscintilla ()
 { }
 
 void
 octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
                                               QPoint *local_pos)
 {
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1033,16 +1033,32 @@ main_window::pasteClipboard (void)
         {
           edit->insert (str);
         }
     }
   else
     emit pasteClipboard_signal ();
 }
 
+void
+main_window::selectAll (void)
+{
+  if (_current_directory_combo_box->hasFocus ())
+    {
+      QLineEdit * edit = _current_directory_combo_box->lineEdit ();
+      if (edit)
+        {
+          edit->selectAll ();
+        }
+    }
+  else
+    emit selectAll_signal ();
+}
+
+
 // Connect the signals emitted when the Octave thread wants to create
 // a dialog box of some sort.  Perhaps a better place for this would be
 // as part of the QUIWidgetCreator class.  However, mainWindow currently
 // is not a global variable and not accessible for connecting.
 
 void
 main_window::connect_uiwidget_links ()
 {
@@ -1509,16 +1525,19 @@ main_window::construct_edit_menu (QMenuB
   _copy_action->setShortcut (QKeySequence::Copy);
 
 
   _paste_action
     = edit_menu->addAction (QIcon (":/actions/icons/editpaste.png"),
                             tr ("Paste"), this, SLOT (pasteClipboard ()));
   _paste_action->setShortcut (QKeySequence::Paste);
 
+  QAction * select_all_action
+    = edit_menu->addAction (tr ("Select All"), this, SLOT (selectAll ()));
+
   _clear_clipboard_action
     = edit_menu->addAction (tr ("Clear Clipboard"), this,
                             SLOT (clear_clipboard ()));
 
   edit_menu->addSeparator ();
 
   _find_files_action = edit_menu->addAction (tr ("Find Files..."));
 
@@ -1989,18 +2008,25 @@ main_window::show_gui_info (void)
          "Octave development takes a lot of time and expertise.  "
          "Your contributions help to ensure that Octave will continue "
          "to improve.</li></ul></p>"
          "<p>We hope you find Octave to be useful.  Please help us make "
          "it even better for the future!</p>"));
 
   QMessageBox gui_info_dialog (QMessageBox::Warning,
                                tr ("Experimental GUI Info"),
-                               gui_info, QMessageBox::Close);
-
+                               QString (gui_info.length (),' '), QMessageBox::Close);
+  QGridLayout *box_layout
+      = qobject_cast<QGridLayout *>(gui_info_dialog.layout());
+  if (box_layout)
+    {
+      QTextEdit *text = new QTextEdit(gui_info);
+      text->setReadOnly(true);
+      box_layout->addWidget(text, 0, 1);
+    }
   gui_info_dialog.exec ();
 }
 
 void
 main_window::construct_tool_bar (void)
 {
   _main_tool_bar = addToolBar ("Main");
 
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -87,16 +87,17 @@ signals:
 
   void insert_debugger_pointer_signal (const QString& file, int line);
   void delete_debugger_pointer_signal (const QString& file, int line);
   void update_breakpoint_marker_signal (bool insert, const QString& file,
                                         int line);
 
   void copyClipboard_signal (void);
   void pasteClipboard_signal (void);
+  void selectAll_signal (void);
 
   void set_widget_shortcuts_signal (bool);
 
 public slots:
   void report_status_message (const QString& statusMessage);
   void handle_save_workspace_request (void);
   void handle_load_workspace_request (const QString& file = QString ());
   void handle_clear_command_window_request (void);
@@ -153,16 +154,17 @@ public slots:
 
   void read_settings (void);
   void set_window_layout (QSettings *settings);
   void write_settings (void);
   void connect_visibility_changed (void);
 
   void copyClipboard (void);
   void pasteClipboard (void);
+  void selectAll (void);
 
   void connect_uiwidget_links ();
 
   void handle_create_dialog (const QString& message, const QString& title,
                              const QString& icon, const QStringList& button,
                              const QString& defbutton,
                              const QStringList& role);
 
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -100,16 +100,18 @@ octave_dock_widget::octave_dock_widget (
 
 #endif
 
   // copy & paste handling
   connect (p, SIGNAL (copyClipboard_signal ()),
            this, SLOT (copyClipboard ()));
   connect (p, SIGNAL (pasteClipboard_signal ()),
            this, SLOT (pasteClipboard ()));
+  connect (p, SIGNAL (selectAll_signal ()),
+           this, SLOT (selectAll ()));
 }
 
 octave_dock_widget::~octave_dock_widget ()
 {
   // save state of this dock-widget
   QString name = objectName ();
   QSettings *settings = resource_manager::get_settings ();
 
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -96,16 +96,19 @@ protected slots:
   }
   /** slots to handle copy & paste */
   virtual void copyClipboard ()
   {
   }
   virtual void pasteClipboard ()
   {
   }
+  virtual void selectAll ()
+  {
+  }
 
 private slots:
 
   void change_floating (bool);
   void change_visibility (bool);
 
 private:
 
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -80,53 +80,69 @@ protected:
 
 private:
 
   int m_argc;
   char** m_argv;
   int m_result;
 };
 
+#if ! defined (__WIN32__) || defined (__CYGWIN__)
+static int fdstderr = -1;
+#endif
 
 // Custom message handler for filtering some messages from Qt.
 
-void message_handler (QtMsgType type, const char *msg)
+void
+message_handler (QtMsgType type, const char *msg)
 {
+#if ! defined (__WIN32__) || defined (__CYGWIN__)
+  static FILE *errstream = fdopen (fdstderr, "a+");
+#else
+  static FILE *errstream = stderr;
+#endif
+
   switch (type)
     {
     case QtDebugMsg:
-      if (strncmp (msg, "QFileSystemWatcher: skipping native engine",42) != 0)
-        std::cerr << "Debug: " << msg << std::endl;
+      gnulib::fprintf (errstream, "Debug: %s\n", msg);
       break;
 
     case QtWarningMsg:
-      std::cerr << "Warning: " << msg << std::endl;
+      gnulib::fprintf (errstream, "Warning: %s\n", msg);
       break;
 
     case QtCriticalMsg:
-      std::cerr << "Critical: " << msg << std::endl;
+      gnulib::fprintf (errstream, "Critical: %s\n", msg);
       break;
 
     case QtFatalMsg:
-      std::cerr << "Fatal: " << msg << std::endl;
+      gnulib::fprintf (errstream, "Fatal: %s\n", msg);
       abort ();
 
     default:
       break;
     }
 }
 
 // If START_GUI is false, we still set up the QApplication so that we
 // can use Qt widgets for plot windows.
 
 int
 octave_start_gui (int argc, char *argv[], bool start_gui)
 {
   octave_thread_manager::block_interrupt_signal ();
 
+#if ! defined (__WIN32__) || defined (__CYGWIN__)
+  // Store the file descriptor associated with the STDERR stream.  Send
+  // Qt messages there instead of to the STDERR stream that will be
+  // associated with the GUI command window.
+  fdstderr = gnulib::dup (STDERR_FILENO);
+#endif
+
   qInstallMsgHandler (message_handler);
 
   if (start_gui)
     {
       QApplication application (argc, argv);
       QTranslator gui_tr, qt_tr, qsci_tr;
 
       // Set the codec for all strings (before wizard)
@@ -177,23 +193,23 @@ octave_start_gui (int argc, char *argv[]
 #endif
 
       // Create and show main window.
 
       main_window w;
 
       w.read_settings ();
 
-      w.focus_command_window ();
-
       // Connect signals for changes in visibility not before w
       // is shown.
 
       w.connect_visibility_changed ();
 
+      w.focus_command_window ();
+
       return application.exec ();
     }
   else
     {
       QApplication application (argc, argv);
 
       octave_cli_thread main_thread (argc, argv);
       
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -279,16 +279,30 @@ webinfo::copyClipboard ()
     }
   if (_text_browser->hasFocus ())
     {
       _text_browser->copy ();
     }
 }
 
 void
+webinfo::selectAll ()
+{
+  if (_search_line_edit->hasFocus ())
+    {
+      _search_line_edit->selectAll ();
+    }
+  if (_text_browser->hasFocus ())
+    {
+      _text_browser->selectAll ();
+    }
+}
+
+
+void
 webinfo::pasteClipboard ()
 {
   if (_search_line_edit->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
       if (str.length () > 0)
         _search_line_edit->insert (str);
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -48,16 +48,17 @@ public slots:
   void current_tab_changed (int index);
   void close_tab (int index);
   void search ();
   void zoom_in ();
   void zoom_out ();
 
   void copyClipboard ();
   void pasteClipboard ();
+  void selectAll ();
 
 private:
   QTextBrowser        *_text_browser;
   QTabBar             *_tab_bar;
   QStackedWidget      *_stacked_widget;
   QLineEdit           *_search_line_edit;
   QCheckBox           *_search_check_box;
   QToolButton         *_zoom_in_button;
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -271,8 +271,15 @@ workspace_view::notice_settings (const Q
 
 void
 workspace_view::copyClipboard ()
 {
   if (view->hasFocus ())
     handle_contextmenu_copy ();
 }
 
+void
+workspace_view::selectAll ()
+{
+  if (view->hasFocus ())
+    view->selectAll ();
+}  
+
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -65,16 +65,17 @@ protected slots:
   void handle_contextmenu_rename (void);
   void handle_contextmenu_disp (void);
   void handle_contextmenu_plot (void);
   void handle_contextmenu_stem (void);
 
   void handle_model_changed (void);
 
   void copyClipboard ();
+  void selectAll ();
 
 private:
 
   void relay_contextmenu_command (const QString& cmdname);
 
   QTableView *view;
   int view_previous_row_count;
   workspace_model *_model;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9727,28 +9727,16 @@ Internal function: returns the pixel siz
   else
     print_usage ();
 
   return retval;
 }
 
 gtk_manager *gtk_manager::instance = 0;
 
-gtk_manager::gtk_manager (void)
-  : dtk (), available_toolkits (), loaded_toolkits ()
-{
-#if defined (HAVE_QT)
-  dtk = display_info::display_available () ? "qt" : "gnuplot";
-#elif defined (HAVE_FLTK)
-  dtk = display_info::display_available () ? "fltk" : "gnuplot";
-#else
-  dtk = "gnuplot";
-#endif
-}
-
 void
 gtk_manager::create_instance (void)
 {
   instance = new gtk_manager ();
 
   if (instance)
     singleton_cleanup_list::add (cleanup_instance);
 }
@@ -9783,16 +9771,55 @@ gtk_manager::do_get_toolkit (void) const
                dtk.c_str ());
     }
   else
     retval = pl->second;
 
   return retval;
 }
 
+void 
+gtk_manager::do_register_toolkit (const std::string& name)
+{
+  if (dtk.empty () || name == "qt"
+      || (name == "fltk"
+          && available_toolkits.find ("qt") == available_toolkits.end ()))
+    dtk = name;
+
+  available_toolkits.insert (name);
+}
+
+void 
+gtk_manager::do_unregister_toolkit (const std::string& name)
+{
+  available_toolkits.erase (name);
+
+  if (dtk == name)
+    {
+      if (available_toolkits.empty ())
+        dtk.clear ();
+      else
+        {
+          const_available_toolkits_iterator pa = available_toolkits.begin ();
+
+          dtk = *pa++;
+
+          while (pa != available_toolkits.end ())
+            {
+              std::string name = *pa++;
+
+              if (name == "qt"
+                  || (name == "fltk"
+                      && available_toolkits.find ("qt") == available_toolkits.end ()))
+                dtk = name;
+            }
+        }
+    }
+}
+
 DEFUN (available_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
 @seealso{graphics_toolkit, register_graphics_toolkit}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2268,17 +2268,17 @@ public:
 
   static std::string default_toolkit (void)
   {
     return instance_ok () ? instance->do_default_toolkit () : std::string ();
   }
 
 private:
 
-  gtk_manager (void);
+  gtk_manager (void) { }
 
   ~gtk_manager (void) { }
 
   OCTINTERP_API static void create_instance (void);
 
   static bool instance_ok (void)
   {
     bool retval = true;
@@ -2317,25 +2317,19 @@ private:
   typedef std::map<std::string, graphics_toolkit>::iterator
     loaded_toolkits_iterator;
 
   typedef std::map<std::string, graphics_toolkit>::const_iterator
     const_loaded_toolkits_iterator;
 
   graphics_toolkit do_get_toolkit (void) const;
 
-  void do_register_toolkit (const std::string& name)
-  {
-    available_toolkits.insert (name);
-  }
-
-  void do_unregister_toolkit (const std::string& name)
-  {
-    available_toolkits.erase (name);
-  }
+  void do_register_toolkit (const std::string& name);
+
+  void do_unregister_toolkit (const std::string& name);
 
   void do_load_toolkit (const graphics_toolkit& tk)
   {
     loaded_toolkits[tk.get_name ()] = tk;
   }
 
   void do_unload_toolkit (const std::string& name)
   {
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -846,16 +846,21 @@ classes.\n\
 %!test
 %! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (10, 1, 6), [6.566435813903809 10.11648464202881 10.73162078857422 7.747178077697754 6.278522491455078 6.240195751190186], 1e-5);
 %!test
 %! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (100, 1, 6), [89.40208435058594 101.4734725952148 103.4020004272461 93.62763214111328 88.33104705810547 88.1871337890625], 1e-4);
+%!test
+%! ## Test out-of-bounds values produce NaN w/old-style generators & floats
+%! randg ("seed", 1);
+%! result = randg ([-2 Inf], "single");
+%! assert (result, single ([NaN NaN]));
 
 %!test
 %! if (__random_statistical_tests__)
 %!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 0.1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -219,16 +219,17 @@ read_indexed_images (const std::vector<M
   const octave_idx_type col_cache = region["col_cache"];
 
   // When reading PixelPackets from the Image Pixel Cache, they come in
   // row major order. So we keep moving back and forth there so we can
   // write the image in column major order.
   octave_idx_type idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
+      OCTAVE_QUIT;
       imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                              col_cache, row_cache);
 
       const Magick::IndexPacket *pix
         = imvec[frameidx(frame)].getConstIndexes ();
 
       for (octave_idx_type col = 0; col < nCols; col++)
         {
@@ -423,16 +424,17 @@ read_images (std::vector<Magick::Image>&
     case Magick::GrayscaleType:         // Grayscale image
       {
         img = T (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         octave_idx_type idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
@@ -450,16 +452,17 @@ read_images (std::vector<Magick::Image>&
         img   = T (dim_vector (nRows, nCols, 1, nFrames));
         T alpha   (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
         octave_idx_type idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
@@ -479,16 +482,17 @@ read_images (std::vector<Magick::Image>&
     case Magick::TrueColorType:         // Truecolor image
       {
         img = T (dim_vector (nRows, nCols, 3, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         const octave_idx_type frame_stride  = colour_stride * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
             P *rbuf   = img_fvec;
             P *gbuf   = img_fvec + colour_stride;
             P *bbuf   = img_fvec + colour_stride * 2;
@@ -520,16 +524,17 @@ read_images (std::vector<Magick::Image>&
 
         const octave_idx_type frame_stride  = colour_stride * 3;
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
             P *rbuf   = img_fvec;
             P *gbuf   = img_fvec + colour_stride;
             P *bbuf   = img_fvec + colour_stride * 2;
@@ -556,16 +561,17 @@ read_images (std::vector<Magick::Image>&
     case Magick::ColorSeparationType:  // Cyan/Magenta/Yellow/Black (CMYK) image
       {
         img   = T (dim_vector (nRows, nCols, 4, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         const octave_idx_type frame_stride  = colour_stride * 4;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
             P *cbuf   = img_fvec;
             P *mbuf   = img_fvec + colour_stride;
             P *ybuf   = img_fvec + colour_stride * 2;
@@ -599,16 +605,17 @@ read_images (std::vector<Magick::Image>&
 
         const octave_idx_type frame_stride  = colour_stride * 4;
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
             // Note that for CMYKColorspace + matte (CMYKA), the opacity is
             // stored in the assocated IndexPacket.
             const Magick::IndexPacket *apix
               = imvec[frameidx(frame)].getConstIndexes ();
 
@@ -917,16 +924,17 @@ encode_indexed_images (std::vector<Magic
     for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
       colormap.push_back (Magick::ColorRGB (cmap_fvec[map_idx],
                                             cmap_fvec[map_idx + G_offset],
                                             cmap_fvec[map_idx + B_offset]));
   }
 
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
+      OCTAVE_QUIT;
       Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                 Magick::PaletteType,
                                                 Magick::PseudoClass);
 
       // Insert colormap.
       m_img.colorMapSize (cmap_size);
       for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
         m_img.colorMap (map_idx, colormap[map_idx]);
@@ -972,16 +980,17 @@ encode_bool_image (std::vector<Magick::I
 
   // The initialized image will be black, this is for the other pixels
   const Magick::Color white ("white");
 
   const bool *img_fvec = img.fortran_vec ();
   octave_idx_type img_idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
+      OCTAVE_QUIT;
       // For some reason, we can't set the type to Magick::BilevelType or
       // the output image will be black, changing to white has no effect.
       // However, this will still work fine and a binary image will be
       // saved because we are setting the bitdepth to 1.
       Magick::Image m_img = init_enconde_image (nCols, nRows, 1,
                                                 Magick::GrayscaleType,
                                                 Magick::DirectClass);
 
@@ -1066,16 +1075,17 @@ encode_uint_image (std::vector<Magick::I
   const P *img_fvec = img.fortran_vec ();
   const P *a_fvec   = alpha.fortran_vec ();
   switch (type)
     {
     case Magick::GrayscaleType:
       {
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1095,16 +1105,17 @@ encode_uint_image (std::vector<Magick::I
           }
         break;
       }
 
     case Magick::GrayscaleMatteType:
       {
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1129,16 +1140,17 @@ encode_uint_image (std::vector<Magick::I
 
     case Magick::TrueColorType:
       {
         // The fortran_vec offset for the green and blue channels
         const octave_idx_type G_offset = nCols * nRows;
         const octave_idx_type B_offset = nCols * nRows * 2;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1163,16 +1175,17 @@ encode_uint_image (std::vector<Magick::I
 
     case Magick::TrueColorMatteType:
       {
         // The fortran_vec offset for the green and blue channels
         const octave_idx_type G_offset = nCols * nRows;
         const octave_idx_type B_offset = nCols * nRows * 2;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1200,16 +1213,17 @@ encode_uint_image (std::vector<Magick::I
     case Magick::ColorSeparationType:
       {
         // The fortran_vec offset for the Magenta, Yellow, and blacK channels
         const octave_idx_type M_offset = nCols * nRows;
         const octave_idx_type Y_offset = nCols * nRows * 2;
         const octave_idx_type K_offset = nCols * nRows * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1236,16 +1250,17 @@ encode_uint_image (std::vector<Magick::I
     case Magick::ColorSeparationMatteType:
       {
         // The fortran_vec offset for the Magenta, Yellow, and blacK channels
         const octave_idx_type M_offset = nCols * nRows;
         const octave_idx_type Y_offset = nCols * nRows * 2;
         const octave_idx_type K_offset = nCols * nRows * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
+            OCTAVE_QUIT;
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             Magick::IndexPacket *ind = m_img.getIndexes ();
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
@@ -1875,16 +1890,17 @@ use @code{imfinfo}.\n\
     {
       error ("imfinfo: error reading '%s': %s",
              filename.c_str (), fs.error ().c_str ());
       return retval;
     }
 
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
+      OCTAVE_QUIT;
       octave_scalar_map info_frame (template_info);
       const Magick::Image img = imvec[frame];
 
       info_frame.setfield ("Width",  octave_value (img.columns ()));
       info_frame.setfield ("Height", octave_value (img.rows ()));
       info_frame.setfield ("BitDepth",
                            octave_value (get_depth (const_cast<Magick::Image&> (img))));
 
diff --git a/liboctave/cruft/misc/r1mach.f b/liboctave/cruft/misc/r1mach.f
--- a/liboctave/cruft/misc/r1mach.f
+++ b/liboctave/cruft/misc/r1mach.f
@@ -1,13 +1,13 @@
-      double precision function r1mach (i)
+      real function r1mach (i)
       integer i
       logical init
-      double precision rmach(5)
-      double precision slamch
+      real rmach(5)
+      real slamch
       external slamch
       save init, rmach
       data init /.false./
       if (.not. init) then
         rmach(1) = slamch ('u')
         rmach(2) = slamch ('o')
         rmach(3) = slamch ('e')
         rmach(4) = slamch ('p')
@@ -15,10 +15,10 @@
         init = .true.
       endif
       if (i .lt. 1 .or. i .gt. 5) goto 999
       r1mach = rmach(i)
       return
   999 write (*, 1999) i
  1999 format (' r1mach - i out of bounds', i10)
       call xstopx (' ')
-      d1mach = 0
+      r1mach = 0
       end
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -450,17 +450,17 @@ octave_rand::do_float_scalar (float a)
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, dretval);
               F77_FUNC (dignpoi, DIGNPOI) (da, dretval);
             }
           break;
 
         case gamma_dist:
           if (da <= 0.0 || ! xfinite (a))
-            retval = octave_NaN;
+            dretval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, da, dretval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
           break;
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -95,16 +95,18 @@ function h = imagesc (varargin)
 
     if (do_new)
       htmp = image (x, y, img, "cdatamapping", "scaled", varargin{chararg:end});
     else
       htmp = image ("cdatamapping", "scaled", varargin{:});
     endif
 
     if (do_new && ! ishold (hax))
+      ## Turn off axis equal which is set by image() call
+      axis ("normal");
       ## use given climits or guess them from the matrix
       if (numel (climits) == 2 && climits(1) <= climits(2))
         set (hax, "clim", climits);
       elseif (! isempty (climits))
         error ("imagesc: CLIMITS must be in form [lo, hi]");
       endif
     endif
   unwind_protect_cleanup
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -525,16 +525,33 @@ function [local_packages, global_package
           global_packages = flag;
         otherwise
           error ("you can request at most two outputs when calling 'pkg describe'");
       endswitch
 
     case "update"
       if (nargout == 0)
         installed_pkgs_lst = installed_packages (local_list, global_list);
+        if (length (files) > 0)
+           update_lst = {}; 
+           for i = 1:length (files)
+             is_installed = false;
+             for j = 1:length (installed_pkgs_lst)
+               if (strcmp (files{i}, installed_pkgs_lst{j}.name))
+                 update_lst = { update_lst{:}, installed_pkgs_lst{j} };
+                 is_installed = true;
+               endif
+             endfor
+             if (is_installed == false)
+               s = sprintf ("Package %s is not installed - not updating this package", files{i});
+               warning (s);
+             endif
+           endfor
+           installed_pkgs_lst = update_lst;
+        endif
         for i = 1:length (installed_pkgs_lst)
           installed_pkg_name = installed_pkgs_lst{i}.name;
           installed_pkg_version = installed_pkgs_lst{i}.version;
           forge_pkg_version = get_forge_pkg (installed_pkg_name);
           if (compare_versions (forge_pkg_version, installed_pkg_version, ">"))
             feval (@pkg, "install", "-forge", installed_pkg_name);
           endif
         endfor
diff --git a/scripts/polynomial/polyeig.m b/scripts/polynomial/polyeig.m
--- a/scripts/polynomial/polyeig.m
+++ b/scripts/polynomial/polyeig.m
@@ -21,73 +21,82 @@
 ## @deftypefnx {Function File} {[@var{v}, @var{z}] =} polyeig (@var{C0}, @var{C1}, @dots{}, @var{Cl})
 ##
 ## Solve the polynomial eigenvalue problem of degree @var{l}.
 ##
 ## Given an @var{n*n} matrix polynomial
 ## @code{@var{C}(s) = @var{C0} + @var{C1} s + @dots{} + @var{Cl} s^l}
 ## polyeig solves the eigenvalue problem
 ## @code{(@var{C0} + @var{C1} + @dots{} + @var{Cl})v = 0}.
+##
 ## Note that the eigenvalues @var{z} are the zeros of the matrix polynomial.
-## @var{z} is an @var{lxn} vector and @var{v} is an (@var{n} x @var{n})l matrix
-## with columns that correspond to the eigenvectors.
+## @var{z} is a row vector with @var{n*l} elements.  @var{v} is a matrix 
+## (@var{n} x @var{n}*@var{l}) with columns that correspond to the
+## eigenvectors.
 ##
 ## @seealso{eig, eigs, compan}
 ## @end deftypefn
 
 ## Author: Fotios Kasolis
 
-function [ z, varargout ] = polyeig (varargin)
+function [z, v] = polyeig (varargin)
   
-  if ( nargout > 2 )
+  if (nargin < 1 || nargout > 2)
     print_usage ();
   endif
 
   nin = numel (varargin);
-
-  n = zeros (1, nin);
+  n = rows (varargin{1});
 
-  for cnt = 1 : nin
-    if (! issquare (varargin{cnt}))
-       error ("polyeig: coefficients must be square matrices");
+  for i = 1 : nin
+    if (! issquare (varargin{i}))
+      error ("polyeig: coefficients must be square matrices");
     endif
-    n(cnt) = size (varargin{cnt}, 1);
+    if (rows (varargin{i}) != n)
+      error ("polyeig: coefficients must have the same dimensions");
+    endif
   endfor
 
-  if (numel (unique (n)) > 1)
-       error ("polyeig: coefficients must have the same dimensions");
-  endif
-  n = unique (n);
-
   ## matrix polynomial degree
   l = nin - 1;
 
   ## form needed matrices
   C = [ zeros(n * (l - 1), n), eye(n * (l - 1));
-       -cell2mat(varargin(1 : end - 1)) ];
+       -cell2mat(varargin(1:end-1)) ];
 
   D = [ eye(n * (l - 1)), zeros(n * (l - 1), n);
        zeros(n, n * (l - 1)), varargin{end} ];
 
   ## solve generalized eigenvalue problem
-  if ( isequal (nargout, 1) )
-    z = eig (C, D);
-  else
-    [ z, v ] = eig (C, D);
-    varargout{1} = v;
-    ## return n-element eigenvectors normalized so
-    ## that the infinity-norm = 1
+  if (nargout == 2)
+    [z, v] = eig (C, D);
+    v = diag (v);
+    ## return n-element eigenvectors normalized so that the infinity-norm = 1
     z = z(1:n,:);
     ## max() takes the abs if complex:
     t = max (z);
     z /= diag (t);
+  else
+    z = eig (C, D);
   endif
 
 endfunction
 
 
+%!shared C0, C1
+%! C0 = [8, 0; 0, 4]; C1 = [1, 0; 0, 1];
+
 %!test
-%! C0 = [8, 0; 0, 4]; C1 = [1, 0; 0, 1];
+%! z = polyeig (C0, C1);
+%! assert (z, [-8; -4]);
+
+%!test
 %! [v,z] = polyeig (C0, C1);
-%! assert (isequal (z(1), -8), true);
+%! assert (z, [-8; -4]);
+%! z = diag (z);
 %! d = C0*v + C1*v*z;
-%! assert (isequal (norm(d), 0.0), true);
+%! assert (norm (d), 0.0);
 
+%% Input validation tests
+%!error polyeig ()
+%!error [a,b,c] = polyeig (1)
+%!error <coefficients must be square matrices> polyeig (ones (3,2))
+%!error <coefficients must have the same dimensions> polyeig (ones (3,3), ones (2,2))
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -52,17 +52,17 @@ function [pval, b, n] = sign_test (x, y,
     error ("sign_test: X and Y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
   y   = reshape (y, 1, n);
   n   = sum (x != y);
   b   = sum (x > y);
-  cdf = binomial_cdf (b, n, 1/2);
+  cdf = binocdf (b, n, 1/2);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
     error ("sign_test: ALT must be a string");
   endif
