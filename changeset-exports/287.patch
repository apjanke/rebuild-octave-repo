# HG changeset patch
# User jwe
# Date 758425330 0
#      Thu Jan 13 01:42:10 1994 +0000
# Node ID 6027a905fc06698af314c5365eeb392698328c37
# Parent  9c74d7d76f3dc8b9d754a9c46e5435261bdc3b8a
[project @ 1994-01-13 01:41:00 by jwe]

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -240,16 +240,17 @@ AC_SUBST(DEFAULT_DOT_O_FROM_DOT_F)dnl
 
 AC_PROG_INSTALL
 AC_PROG_RANLIB
 AC_STDC_HEADERS
 AC_HAVE_HEADERS(string.h varargs.h unistd.h)
 AC_HAVE_HEADERS(sys/time.h sys/fcntl.h sys/ttold.h sys/ptem.h sys/select.h)
 AC_DIR_HEADER
 AC_HAVE_FUNCS(setvbuf getcwd bzero rindex vfprintf vsprintf)
+AC_HAVE_FUNCS(strcasecmp strncasecmp)
 AC_STRUCT_TM
 AC_SETVBUF_REVERSED
 TERMLIBS=""
 for termlib in termcap terminfo curses termlib ; do
   AC_HAVE_LIBRARY(${termlib}, [TERMLIBS="${TERMLIBS} -l${termlib}"])
   case "${TERMLIBS}" in
     *-l${termlib}*)
       break
diff --git a/liboctave/NLP.h b/liboctave/NLP.h
--- a/liboctave/NLP.h
+++ b/liboctave/NLP.h
@@ -55,16 +55,20 @@ class NLP
   NLP (const Vector& x, const Objective& phi, const LinConst& lc,
        const NLConst& nlc);
 
   NLP (const Vector& x, const Objective& phi, const NLConst& nlc); 
 
   NLP (const Vector& x, const Objective& phi, const Bounds& b, const
        NLConst& nlc);
 
+  ~NLP (void);
+
+  NLP& operator = (const NLP& a);
+
   int size (void) const;
 
  protected:
 
   Vector x;
   Objective phi;  
   Bounds bnds;
   LinConst lc;
@@ -96,16 +100,33 @@ inline NLP::NLP (const Vector& xx, const
 
 inline NLP::NLP (const Vector& xx, const Objective& obj, const NLConst& nl)
   : x (xx), phi (obj), nlc (nl) {}
 
 inline NLP::NLP (const Vector& xx, const Objective& obj, const Bounds& b,
 		 const NLConst& nl) 
   : x (xx), phi (obj), bnds (b), nlc (nl) {}
 
+inline NLP::~NLP (void) { }
+
+inline NLP&
+NLP::operator = (const NLP& a)
+{
+  if (this != &a)
+    {
+      x = a.x;
+      phi = a.phi;  
+      bnds = a.bnds;
+      lc = a.lc;
+      nlc = a.nlc;
+    }
+
+  return *this;
+}
+
 inline int
 NLP::size (void) const
 {
   return x.capacity ();
 }
 
 #endif
 
diff --git a/liboctave/NPSOL.cc b/liboctave/NPSOL.cc
--- a/liboctave/NPSOL.cc
+++ b/liboctave/NPSOL.cc
@@ -21,16 +21,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <math.h>
+#include <string.h>
+#include <strstream.h>
 
 #ifndef NPSOL_MISSING
 
 #include "NPSOL.h"
 #include "f77-uscore.h"
 #include "sun-utils.h"
 
 extern "C"
@@ -40,33 +42,33 @@ extern "C"
   int F77_FCN (npsol) (int *, int *, int *, int *, int *, int *,
 		       double *, double *, double *,
 		       int (*)(int*, int*, int*, int*, int*, double*,
 			       double*, double*, int*),
 		       int (*)(int*, int*, double*, double*, double*, int*),
 		       int *, int *, int *, double *,
 		       double *, double *, double *, double *,
 		       double *, double *, int *, int *, double *,
-		       int *); 
+		       int *);
 }
 
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the objective
 // function, and the user wants us to quit.
 int npsol_objective_error = 0;
 
 static objective_fcn user_phi;
 static gradient_fcn user_grad;
 static nonlinear_fcn user_g;
 static jacobian_fcn user_jac;
 
 int
 npsol_objfun (int *mode, int *n, double *xx, double *objf,
-	      double *objgrd, int *nstate) 
+	      double *objgrd, int *nstate)
 {
   int nn = *n;
   Vector tmp_x (nn);
 
   npsol_objective_error = 0;
 
   for (int i = 0; i < nn; i++)
     tmp_x.elem (i) = xx[i];
@@ -275,26 +277,26 @@ NPSOL::minimize (double& objf, int& info
   int *iw = new int [leniw];
   double *w = new double [lenw];
 
   user_phi  = phi.objective_function ();
   user_grad = phi.gradient_function ();
   user_g    = nlc.function ();
   user_jac  = nlc.jacobian_function ();
 
-  // Solve the damn thing.
+  pass_options_to_npsol ();
 
   if (user_jac == NULL && user_grad == NULL)
-    F77_FCN (npoptn) ("Derivative Level = 0", 20L);
+    F77_FCN (npoptn) ("Derivative Level 0", 18L);
   else if (user_jac == NULL && user_grad != NULL)
-    F77_FCN (npoptn) ("Derivative Level = 1", 20L);
+    F77_FCN (npoptn) ("Derivative Level 1", 18L);
   else if (user_jac != NULL && user_grad == NULL)
-    F77_FCN (npoptn) ("Derivative Level = 2", 20L);
+    F77_FCN (npoptn) ("Derivative Level 2", 18L);
   else if (user_jac != NULL && user_grad != NULL)
-    F77_FCN (npoptn) ("Derivative Level = 3", 20L);
+    F77_FCN (npoptn) ("Derivative Level 3", 18L);
 
   int attempt = 0;
   while (attempt++ < 5)
     {
 
       F77_FCN (npsol) (&n, &nclin, &ncnln, &nrowa, &nrowj, &nrowr, pclin,
 		       clow, cup, npsol_confun, npsol_objfun, &inform,
 		       &iter, istate, c, cjac, pclambda, &objf, objgrd, r,
@@ -337,27 +339,419 @@ NPSOL::minimize (const Vector& xnew, dou
 {
   x = xnew;
   return minimize (objf, inform, lambda);
 }
 
 NPSOL&
 NPSOL::option (char *s)
 {
-  long len = strlen (s);
-  F77_FCN (npoptn) (s, len);
+  cerr << "This function no longer has any effect.\n"
+       << "Use the NPSOL_option class instead\n";
+
+  return *this;
+}
+
+NPSOL_options::NPSOL_options (void)
+{
+  init ();
+}
+
+NPSOL_options::NPSOL_options (const NPSOL_options& opt)
+{
+  copy (opt);
+}
+
+NPSOL_options&
+NPSOL_options::operator = (const NPSOL_options& opt)
+{
+  if (this != &opt)
+    copy (opt);
+
   return *this;
 }
 
+NPSOL_options::~NPSOL_options (void)
+{
+}
+
+void
+NPSOL_options::init (void)
+{
+  x_central_difference_interval = -1.0;
+  x_crash_tolerance = 0.1;
+  x_difference_interval = -1.0;
+  x_function_precision = pow (DBL_EPSILON, 0.9);
+  x_infinite_bound = 1.0e+30;
+  x_infinite_step = 1.0e+30;
+  x_linear_feasibility_tolerance = sqrt (DBL_EPSILON);
+  x_linesearch_tolerance = 0.9;
+  x_nonlinear_feasibility_tolerance = sqrt (DBL_EPSILON);
+  x_optimality_tolerance = pow (DBL_EPSILON, 0.8);
+  x_derivative_level = 0;
+  x_major_iteration_limit = -1;
+  x_minor_iteration_limit = -1;
+  x_major_print_level = 0;
+  x_minor_print_level = 0;
+  x_start_objective_check = 1;
+  x_start_constraint_check = 1;
+  x_stop_objective_check = -1;
+  x_stop_constraint_check = -1;
+  x_verify_level = 0;
+}
+
+void
+NPSOL_options::copy (const NPSOL_options& opt)
+{
+  x_central_difference_interval = opt.x_central_difference_interval;
+  x_crash_tolerance = opt.x_crash_tolerance;
+  x_difference_interval = opt.x_difference_interval;
+  x_function_precision = opt.x_function_precision;
+  x_infinite_bound = opt.x_infinite_bound;
+  x_infinite_step = opt.x_infinite_step;
+  x_linear_feasibility_tolerance = opt.x_linear_feasibility_tolerance;
+  x_linesearch_tolerance = opt.x_linesearch_tolerance;
+  x_nonlinear_feasibility_tolerance = opt.x_nonlinear_feasibility_tolerance;
+  x_optimality_tolerance = opt.x_optimality_tolerance;
+  x_derivative_level = opt.x_derivative_level;
+  x_major_iteration_limit = opt.x_major_iteration_limit;
+  x_minor_iteration_limit = opt.x_minor_iteration_limit;
+  x_major_print_level = opt.x_major_print_level;
+  x_minor_print_level = opt.x_minor_print_level;
+  x_start_objective_check = opt.x_start_objective_check;
+  x_start_constraint_check = opt.x_start_constraint_check;
+  x_stop_objective_check = opt.x_stop_objective_check;
+  x_stop_constraint_check = opt.x_stop_constraint_check;
+  x_verify_level = opt.x_verify_level;
+}
+
+void
+NPSOL_options::set_default_options (void)
+{
+  init ();
+}
+
+/*
+ * Passing invalid values to the set_* functions will result in
+ * setting the default option.
+ */
+
+void
+NPSOL_options::set_central_difference_interval (double val)
+{
+  x_central_difference_interval = (val > 0.0) ? val : -1.0;
+}
+
+void
+NPSOL_options::set_crash_tolerance (double val)
+{
+  x_crash_tolerance = (val >= 0.0) ? val : 0.1;
+}
+
+void
+NPSOL_options::set_difference_interval (double val)
+{
+  x_difference_interval = (val > 0.0) ? val : -1.0;
+}
+
+void
+NPSOL_options::set_function_precision (double val)
+{
+  x_function_precision = (val > 0.0) ? val : pow (DBL_EPSILON, 0.9);
+}
+
+void
+NPSOL_options::set_infinite_bound (double val)
+{
+  x_infinite_bound = (val > 0.0) ? val : 1.0e+30;
+}
+
+void
+NPSOL_options::set_infinite_step (double val)
+{
+  x_infinite_step = (val > 0.0) ? val : 1.0e+30;
+}
+
+void
+NPSOL_options::set_linear_feasibility_tolerance (double val)
+{
+  x_linear_feasibility_tolerance = (val > 0.0) ? val : sqrt (DBL_EPSILON);
+}
+
+void
+NPSOL_options::set_linesearch_tolerance (double val)
+{
+  x_linesearch_tolerance = (val >= 0.0 && val < 1.0) ? val : 0.9;
+}
+
+void
+NPSOL_options::set_nonlinear_feasibility_tolerance (double val)
+{
+  x_nonlinear_feasibility_tolerance = (val > 0.0) ? val : sqrt (DBL_EPSILON);
+}
+
+void
+NPSOL_options::set_optimality_tolerance (double val)
+{
+  x_optimality_tolerance = (val > 0.0) ? val : pow (DBL_EPSILON, 0.8);
+}
+
+void
+NPSOL_options::set_derivative_level (int val)
+{
+  x_derivative_level = (val >= 0 && val < 4) ? val : 0;
+}
+
+void
+NPSOL_options::set_major_iteration_limit (int val)
+{
+  x_major_iteration_limit = (val > 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_minor_iteration_limit (int val)
+{
+  x_minor_iteration_limit = (val > 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_major_print_level (int val)
+{
+  x_major_print_level = (val >= 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_minor_print_level (int val)
+{
+  x_minor_print_level = (val >= 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_start_objective_check (int val)
+{
+  x_start_objective_check = (val >= 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_start_constraint_check (int val)
+{
+  x_start_constraint_check = (val >= 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_stop_objective_check (int val)
+{
+  x_stop_objective_check = (val >= 0) ? val : -1;
+}
+
 void
-NPSOL::set_default_options (void)
+NPSOL_options::set_stop_constraint_check (int val)
+{
+  x_stop_constraint_check = (val >= 0) ? val : -1;
+}
+
+void
+NPSOL_options::set_verify_level (int val)
+{
+  x_verify_level = ((val > -1 && val < 4) || (val > 9 && val < 14)) ? val : 0;
+}
+
+double
+NPSOL_options::central_difference_interval (void) const
+{
+  return x_central_difference_interval;
+}
+
+double
+NPSOL_options::crash_tolerance (void) const
+{
+  return x_crash_tolerance;
+}
+
+double
+NPSOL_options::difference_interval (void) const
+{
+  return x_difference_interval;
+}
+
+double
+NPSOL_options::function_precision (void) const
+{
+  return x_function_precision;
+}
+
+double
+NPSOL_options::infinite_bound (void) const
+{
+  return x_infinite_bound;
+}
+
+double
+NPSOL_options::infinite_step (void) const
+{
+  return x_infinite_step;
+}
+
+double
+NPSOL_options::linear_feasibility_tolerance (void) const
+{
+  return x_linear_feasibility_tolerance;
+}
+
+double
+NPSOL_options::linesearch_tolerance (void) const
+{
+  return x_linesearch_tolerance;
+}
+
+double
+NPSOL_options::nonlinear_feasibility_tolerance (void) const
+{
+  return x_nonlinear_feasibility_tolerance;
+}
+
+double
+NPSOL_options::optimality_tolerance (void) const
+{
+  return x_optimality_tolerance;
+}
+
+int
+NPSOL_options::derivative_level (void) const
+{
+  return x_derivative_level;
+}
+
+int
+NPSOL_options::major_iteration_limit (void) const
+{
+  return x_major_iteration_limit;
+}
+
+int
+NPSOL_options::minor_iteration_limit (void) const
+{
+  return x_minor_iteration_limit;
+}
+
+int
+NPSOL_options::major_print_level (void) const
+{
+  return x_major_print_level;
+}
+
+int
+NPSOL_options::minor_print_level (void) const
+{
+  return x_minor_print_level;
+}
+
+int
+NPSOL_options::start_objective_check (void) const
+{
+  return x_start_objective_check;
+}
+
+int
+NPSOL_options::start_constraint_check (void) const
+{
+  return x_start_constraint_check;
+}
+
+int
+NPSOL_options::stop_objective_check (void) const
+{
+  return x_stop_objective_check;
+}
+
+int
+NPSOL_options::stop_constraint_check (void) const
+{
+  return x_stop_constraint_check;
+}
+
+int
+NPSOL_options::verify_level (void) const
+{
+  return x_verify_level;
+}
+
+void
+NPSOL_options::pass_options_to_npsol (void)
 {
   F77_FCN (npoptn) ("Nolist", 6L);
   F77_FCN (npoptn) ("Defaults", 8L);
-  F77_FCN (npoptn) ("Print Level 0", 13L);
+
+  if (x_central_difference_interval > 0.0)
+    set_option ("Central Difference", x_central_difference_interval);
+
+  set_option ("Crash Tolerance", x_crash_tolerance);
+
+  if (x_difference_interval > 0.0)
+    set_option ("Difference Interval", x_difference_interval);
+
+  set_option ("Function Precision", x_function_precision);
+
+  set_option ("Infinite Bound", x_infinite_bound);
+
+  set_option ("Infinite Step", x_infinite_step);
+
+  set_option ("Linear Feasibility", x_linear_feasibility_tolerance);
+
+  set_option ("Linesearch Tolerance", x_linesearch_tolerance);
+
+  set_option ("Nonlinear Feasibility", x_nonlinear_feasibility_tolerance);
+
+  set_option ("Optimality Tolerance", x_optimality_tolerance);
+
+  set_option ("Derivative Level", x_derivative_level);
+
+  if (x_major_iteration_limit > 0)
+    set_option ("Major Iteration", x_major_iteration_limit);
+
+  if (x_minor_iteration_limit > 0)
+    set_option ("Minor Iteration", x_minor_iteration_limit);
+
+  set_option ("Major Print", x_major_print_level);
+
+  set_option ("Minor Print", x_minor_print_level);
+
+  set_option ("Start Objective", x_start_objective_check);
+
+  set_option ("Start Constraint", x_start_constraint_check);
+
+  if (x_stop_objective_check > 0)
+    set_option ("Stop Objective", x_stop_objective_check);
+
+  if (x_stop_constraint_check > 0)
+    set_option ("Stop Constraint", x_stop_constraint_check);
+
+  set_option ("Verify Level", x_verify_level);
+}
+
+void
+NPSOL_options::set_option (const char *key, int opt)
+{
+  ostrstream buf;
+  buf << key << " " << opt << ends;
+  char *command = buf.str ();
+  size_t len = strlen (command);
+  F77_FCN (npoptn) (command, (long) len);
+  delete [] command;
+}
+
+void
+NPSOL_options::set_option (const char *key, double opt)
+{
+  ostrstream buf;
+  buf << key << " " << opt << ends;
+  char *command = buf.str ();
+  size_t len = strlen (command);
+  F77_FCN (npoptn) (command, (long) len);
+  delete [] command;
 }
 
 #endif /* NPSOL_MISSING */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/liboctave/NPSOL.h b/liboctave/NPSOL.h
--- a/liboctave/NPSOL.h
+++ b/liboctave/NPSOL.h
@@ -28,99 +28,168 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "Matrix.h"
 #include "NLP.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
-class NPSOL : public NLP
+class NPSOL_options
 {
  public:
 
-  NPSOL (void) : NLP ()
-    { set_default_options (); }
+  NPSOL_options (void);
+  NPSOL_options (const NPSOL_options& opt);
+
+  NPSOL_options& operator = (const NPSOL_options& opt);
+
+  ~NPSOL_options (void);
+
+  void init (void);
+  void copy (const NPSOL_options& opt);
+
+  void set_default_options (void);
+
+  void set_central_difference_interval (double val);
+  void set_crash_tolerance (double val);
+  void set_difference_interval (double val);
+  void set_function_precision (double val);
+  void set_infinite_bound (double val);
+  void set_infinite_step (double val);
+  void set_linear_feasibility_tolerance (double val);
+  void set_linesearch_tolerance (double val);
+  void set_nonlinear_feasibility_tolerance (double val);
+  void set_optimality_tolerance (double val);
+
+  void set_derivative_level (int val);
+  void set_major_iteration_limit (int val);
+  void set_minor_iteration_limit (int val);
+  void set_major_print_level (int val);
+  void set_minor_print_level (int val);
+  void set_start_objective_check (int val);
+  void set_start_constraint_check (int val);
+  void set_stop_objective_check (int val);
+  void set_stop_constraint_check (int val);
+  void set_verify_level (int val);
+
+  double central_difference_interval (void) const;
+  double crash_tolerance (void) const;
+  double difference_interval (void) const;
+  double function_precision (void) const;
+  double infinite_bound (void) const;
+  double infinite_step (void) const;
+  double linear_feasibility_tolerance (void) const;
+  double linesearch_tolerance (void) const;
+  double nonlinear_feasibility_tolerance (void) const;
+  double optimality_tolerance (void) const;
 
-  NPSOL (const Vector& x, const Objective& phi) : NLP (x, phi)
-    { set_default_options (); }
+  int derivative_level (void) const;
+  int major_iteration_limit (void) const;
+  int minor_iteration_limit (void) const;
+  int major_print_level (void) const;
+  int minor_print_level (void) const;
+  int start_objective_check (void) const;
+  int start_constraint_check (void) const;
+  int stop_objective_check (void) const;
+  int stop_constraint_check (void) const;
+  int verify_level (void) const;
+
+ protected:
+
+  void pass_options_to_npsol (void);
+
+  void set_option (const char *key, int opt);
+  void set_option (const char *key, double opt);
+
+ private:
+
+  double x_central_difference_interval;
+  double x_crash_tolerance;
+  double x_difference_interval;
+  double x_function_precision;
+  double x_infinite_bound;
+  double x_infinite_step;
+  double x_linear_feasibility_tolerance;
+  double x_linesearch_tolerance;
+  double x_nonlinear_feasibility_tolerance;
+  double x_optimality_tolerance;
+  int x_derivative_level;
+  int x_major_iteration_limit;
+  int x_minor_iteration_limit;
+  int x_major_print_level;
+  int x_minor_print_level;
+  int x_start_objective_check;
+  int x_start_constraint_check;
+  int x_stop_objective_check;
+  int x_stop_constraint_check;
+  int x_verify_level;
+};
+
+class NPSOL : public NLP, public NPSOL_options
+{
+ public:
+
+  NPSOL (void) : NLP () { }
+
+  NPSOL (const Vector& x, const Objective& phi) : NLP (x, phi) { }
 
   NPSOL (const Vector& x, const Objective& phi,
 	 const Bounds& b) : NLP (x, phi, b)
-    { set_default_options (); }
+    { }
 
   NPSOL (const Vector& x, const Objective& phi, const Bounds& b,
 	 const LinConst& lc) : NLP (x, phi, b, lc)
-    { set_default_options (); }
+    { }
 
   NPSOL (const Vector& x, const Objective& phi, const Bounds& b,
 	 const LinConst& lc, const NLConst& nlc) : NLP (x, phi, b, lc, nlc)
-    { set_default_options (); }
+    { }
 
   NPSOL (const Vector& x, const Objective& phi,
 	 const LinConst& lc) : NLP (x, phi, lc)
-    { set_default_options (); }
+    { }
 
   NPSOL (const Vector& x, const Objective& phi, const LinConst& lc,
 	 const NLConst& nlc) : NLP (x, phi, lc, nlc)
-    { set_default_options (); }
+    { }
 
   NPSOL (const Vector& x, const Objective& phi,
 	 const NLConst& nlc) : NLP (x, phi, nlc)
-    { set_default_options (); }
+    { }
 
   NPSOL (const Vector& x, const Objective& phi, const Bounds& b,
 	 const NLConst& nlc) : NLP (x, phi, b, nlc)
-    { set_default_options (); }
+    { }
 
   NPSOL (const NPSOL& a);
 
-  NPSOL& operator = (const NPSOL& a);
-
   Vector minimize (void);
   Vector minimize (double& objf);
   Vector minimize (double& objf, int& inform);
   Vector minimize (double& objf, int& inform, Vector& lambda);
 
   Vector minimize (const Vector& x);
   Vector minimize (const Vector& x, double& objf);
   Vector minimize (const Vector& x, double& objf, int& inform);
   Vector minimize (const Vector& x, double& objf, int& inform, Vector& lambda);
 
   NPSOL& option (char *s);
 
-private:
-  void set_default_options (void);
-
+ private:
 };
 
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the objective
 // function, and the user wants us to quit.
 extern int npsol_objective_error;
 
 inline NPSOL::NPSOL (const NPSOL& a) : NLP (a.x, a.phi, a.bnds, a.lc, a.nlc)
-  { set_default_options (); }
-
-inline NPSOL&
-NPSOL::operator = (const NPSOL& a)
-{
-  x = a.x;
-  phi = a.phi;
-  bnds = a.bnds;
-  lc = a.lc;
-  nlc = a.nlc;
-
-  cerr << "warning: NPSOL options reset to default values\n";
-
-  set_default_options ();
-
-  return *this;
-}
+  { }
 
 #endif /* NPSOL_MISSING */
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/octMakefile.in b/octMakefile.in
--- a/octMakefile.in
+++ b/octMakefile.in
@@ -8,21 +8,21 @@
 
 TOPDIR = .
 
 srcdir = @srcdir@
 VPATH = @srcdir@
 
 include Makeconf
 
-DISTFILES = COPYING ChangeLog Makefile.in Makeconf.in NEWS README \
-	README.NLP THANKS INSTALL INSTALL.OCTAVE BUGS PLOTTING \
-	PROJECTS f2c-compat.sh flibs.sh configure configure.in \
-	config.guess octave.sh octave-mode.el doinstall.sh mkpath.c \
-	config.h.in acconfig.h
+DISTFILES = BUGS COPYING ChangeLog INSTALL INSTALL.OCTAVE \
+	Makefile.in Makeconf.in NEWS PLOTTING PROJECTS README \
+	README.NLP SENDING-PATCHES THANKS f2c-compat.sh flibs.sh \
+	configure configure.in config.guess octave.sh octave-mode.el \
+	doinstall.sh mkpath.c config.h.in acconfig.h
 
 # Complete directory trees to distribute.
 DISTDIRS = bsd-math dld
 
 # Subdirectories to run make in for the primary targets.
 SUBDIRS = libcruft liboctave @DLD_DIR@ info readline src doc scripts 
 
 # Subdirectories to run `make dist' in
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -54,61 +54,62 @@ LIBOBJS = @LIBOBJS@
 	    mv $@.tmp $@ ; \
 	else \
 	  $(CC) -MM $(CPPFLAGS) $(ALL_CFLAGS) $< | \
 	    sed -e 's/$*\.o/& $@/g' -e 's,$(srcdir)/,,g' > $@.tmp && \
 	    mv $@.tmp $@ ; \
 	fi
 
 INCLUDES = arith-ops.h builtins.h dynamic-ld.h defaults.h.in \
-	defaults.h f-balance.h f-chol.h f-colloc.h f-dassl.h \
+	defaults.h error.h f-balance.h f-chol.h f-colloc.h f-dassl.h \
 	f-det.h f-eig.h f-expm.h f-fft.h f-fsolve.h f-fsqp.h f-givens.h \
 	f-hess.h f-ifft.h f-inv.h f-lpsolve.h f-lsode.h f-lu.h \
 	f-npsol.h f-qpsol.h f-qr.h f-quad.h f-qzval.h f-rand.h \
 	f-schur.h f-svd.h f-syl.h file-io.h fnmatch.h g-builtins.h \
 	getopt.h gripes.h help.h idx-vector.h input.h lex.h mappers.h \
 	missing-math.h octave.h octave-hist.h pager.h parse.h \
 	pr-output.h procstream.h sighandlers.h statdefs.h symtab.h \
 	sysdep.h t-builtins.h token.h tree-base.h tree-const.h tree.h \
 	unwind-prot.h user-prefs.h utils.h variables.h version.h \
 	xdiv.h xpow.h SLStack.h Stack.h
 
-SOURCES = arith-ops.cc builtins.cc dynamic-ld.cc f-chol.cc \
+SOURCES = arith-ops.cc builtins.cc dynamic-ld.cc error.cc f-chol.cc \
 	f-colloc.cc f-balance.cc f-dassl.cc f-det.cc f-eig.cc \
 	f-expm.cc f-fft.cc f-fsolve.cc f-fsqp.cc f-givens.cc \
 	f-hess.cc f-ifft.cc f-inv.cc f-lpsolve.cc f-lsode.cc f-lu.cc \
 	f-npsol.cc f-qpsol.cc f-qr.cc f-quad.cc f-qzval.cc f-rand.cc \
 	f-schur.cc f-svd.cc f-syl.cc file-io.cc	fnmatch.c \
 	g-builtins.cc getopt.c getopt1.c gripes.cc help.cc \
 	idx-vector.cc input.cc lex.l mappers.cc octave.cc \
 	octave-hist.cc pager.cc parse.y pr-output.cc procstream.cc \
-	sighandlers.cc symtab.cc sysdep.cc t-builtins.cc tc-assign.cc \
-	tc-extras.cc tc-index.cc tc-inlines.cc token.cc tree.cc \
-	tree-const.cc tree-plot.cc unwind-prot.cc user-prefs.cc \
-	utils.cc variables.cc xdiv.cc xpow.cc SLStack.cc
+	sighandlers.cc strcasecmp.c strncase.c symtab.cc sysdep.cc \
+	t-builtins.cc tc-assign.cc tc-extras.cc tc-index.cc \
+	tc-inlines.cc token.cc tree.cc tree-const.cc tree-plot.cc \
+	unwind-prot.cc user-prefs.cc utils.cc variables.cc xdiv.cc \
+	xpow.cc SLStack.cc
 
 DEP_SOURCES_2 = $(patsubst %.l, %.cc, $(SOURCES))
 DEP_SOURCES_1 = $(patsubst %.y, %.cc, $(DEP_SOURCES_2))
 DEP_SOURCES = $(patsubst %.c, %.d, $(DEP_SOURCES_1))
 MAKEDEPS = $(patsubst %.cc, %.d, $(DEP_SOURCES))
 
 DLD_OBJECTS = f-balance.o f-chol.o f-colloc.o f-dassl.o f-det.o \
 	f-eig.o f-expm.o f-fft.o f-fsolve.o f-fsqp.o f-givens.o \
 	f-hess.o f-ifft.o f-inv.o f-lpsolve.o f-lsode.o f-lu.o \
 	f-npsol.o f-qpsol.o f-qr.o f-quad.o f-qzval.o f-rand.o \
 	f-schur.o f-svd.o f-syl.o 
 
 OBJECTS = arith-ops.o builtins.o error.o file-io.o fnmatch.o \
 	g-builtins.o getopt.o getopt1.o gripes.o help.o idx-vector.o \
 	input.o lex.o mappers.o octave.o octave-hist.o pager.o \
-	parse.o pr-output.o procstream.o sighandlers.o symtab.o \
-	sysdep.o t-builtins.o tc-assign.o tc-extras.o tc-index.o \
-	token.o tree.o tree-const.o tree-plot.o unwind-prot.o \
-	user-prefs.o utils.o variables.o xdiv.o xpow.o SLStack.o \
-	@DYNAMIC_LD_OBJ@
+	parse.o pr-output.o procstream.o sighandlers.o strcasecmp.o \
+	strncase.o symtab.o sysdep.o t-builtins.o tc-assign.o \
+	tc-extras.o tc-index.o token.o tree.o tree-const.o tree-plot.o \
+	unwind-prot.o user-prefs.o utils.o variables.o xdiv.o xpow.o \
+	SLStack.o @DYNAMIC_LD_OBJ@
 
 OCTAVE_LIBS = ../liboctave.a ../libcruft.a ../libinfo.a \
 	../libreadline.a @LIBDLD@
 
 DISTFILES = Makefile.in move-if-change parse.cc lex.cc y.tab.h \
 	$(INCLUDES) $(SOURCES)
 
 all: defaults.h octave
diff --git a/src/builtins.cc b/src/builtins.cc
--- a/src/builtins.cc
+++ b/src/builtins.cc
@@ -258,17 +258,19 @@ where \"opt\" is an optional single char
 The first argument is the name of the function to call to\n\
 compute the vector of residuals.  It must have the form\n\
 \n\
   res = f (x, xdot, t)\n\
 \n\
 where x, xdot, and res are vectors, and t is a scalar.", },
 
   { "dassl_options", -1, 1, builtin_dassl_options,
-    "dassl_options (keyword, value): set or show options for dassl", },
+    "dassl_options (keyword, value)\n\n\
+       Set or show options for dassl.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 
   { "date", 1, 0, builtin_date,
     "date (): return current date in a string", },
 
   { "det", 2, 1, builtin_det,
     "det (X): determinant of a square matrix", },
 
   { "diag", 3, 1, builtin_diag,
@@ -353,17 +355,19 @@ where x, xdot, and res are vectors, and 
 Where the first argument is the name of the  function to call to\n\
 compute the vector of function values.  It must have the form\n\
 \n\
   y = f (x)
 \n\
 where y and x are vectors.", },
 
   { "fsolve_options", -1, 1, builtin_fsolve_options,
-    "fsolve_options (keyword, value): set or show options for fsolve", },
+    "fsolve_options (keyword, value)\n\n\
+       Set or show options for fsolve.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 
   { "fsqp", 11, 3, builtin_fsqp,
 #if defined (FSQP_MISSING)
     "This function requires FSQP, which is not freely\n\
        redistributable.  For more information, read the file\n\
        libcruft/fsqp/README.MISSING in the source distribution.", },
 #else
   "[x, phi] = fsqp (x, \"phi\" [, lb, ub] [, lb, A, ub] [, lb, \"g\", ub])\n\n\
@@ -372,17 +376,19 @@ where y and x are vectors.", },
 #endif
 
   { "fsqp_options", -1, 1, builtin_fsqp_options,
 #if defined (FSQP_MISSING)
     "This function requires FSQP, which is not freely\n\
        redistributable.  For more information, read the file\n\
        libcruft/fsqp/README.MISSING in the source distribution.", },
 #else
-    "fsqp_options (keyword, value): set or show options for fsqp", },
+    "fsqp_options (keyword, value)\n\n\
+       Set or show options for fsqp.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 #endif
 
   { "ftell", 2, 1, builtin_ftell,
     "position = ftell (\"filename\" or filenum): returns the current file position", },
 
   { "getenv", 2, 1, builtin_getenv,
     "getenv (\"string\"): get environment variable values", },
 
@@ -421,30 +427,34 @@ where y and x are vectors.", },
 
   { "logm", 2, 1, builtin_logm,
     "logm (x): matrix logarithm", },
 
   { "lp_solve", 11, 3, builtin_lpsolve,
     "lp_solve (): solve linear programs using lp_solve.", },
 
   { "lp_solve_options", -1, 1, builtin_lpsolve_options,
-    "lp_solve_options (keyword, value): set or show options for lp_solve", },
+    "lp_solve_options (keyword, value)\n\n\
+       Set or show options for lp_solve.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 
   { "lsode", 6, 1, builtin_lsode,
     "lsode (\"function_name\", x0, t_out, t_crit)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of right hand sides.  It must have the form\n\
 \n\
   xdot = f (x, t)\n\
 \n\
 where xdot and x are vectors and t is a scalar.\n", },
 
   { "lsode_options", -1, 1, builtin_lsode_options,
-    "lsode_options (keyword, value): set or show options for lsode", },
+    "lsode_options (keyword, value)\n\n\
+       Set or show options for lsode.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 
   { "lu", 2, 3, builtin_lu,
     "[L, U, P] = lu (A): LU factorization", },
 
   { "max", 3, 2, builtin_max,
     "max (x): maximum value(s) of a vector (matrix)", },
 
   { "min", 3, 2, builtin_min,
@@ -469,17 +479,19 @@ where xdot and x are vectors and t is a 
 #endif
 
   { "npsol_options", -1, 1, builtin_npsol_options,
 #if defined (NPSOL_MISSING)
     "This function requires NPSOL, which is not freely\n\
        redistributable.  For more information, read the file\n\
        libcruft/npsol/README.MISSING in the source distribution.", },
 #else
-    "npsol_options (keyword, value): set or show options for npsol", },
+    "npsol_options (keyword, value)\n\n\
+       Set or show options for npsol.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 #endif
 
   { "ones", 3, 1, builtin_ones,
     "ones (n), ones (n, m), ones (x): create a matrix of all ones", },
 
   { "pause", 1, 0, builtin_pause,
     "pause (seconds): suspend program execution", },
 
@@ -508,17 +520,19 @@ where xdot and x are vectors and t is a 
 #endif
 
   { "qpsol_options", -1, 1, builtin_qpsol_options,
 #if defined (QPSOL_MISSING)
     "This function requires QPSOL, which is not freely\n\
        redistributable.  For more information, read the file\n\
        libcruft/qpsol/README.MISSING in the source distribution.", },
 #else
-    "qpsol_options (keyword, value): set or show options for qpsol", },
+    "qpsol_options (keyword, value)\n\n\
+       Set or show options for qpsol.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 #endif
 
   { "qr", 2, 2, builtin_qr,
     "[q, r] = qr (X): form QR factorization of X", },
 
   { "quad", 6, 3, builtin_quad,
     "[v, ier, nfun] = quad (\"f\", a, b [, tol] [, sing])\n\
 \n\
@@ -530,17 +544,19 @@ compute the value of the integrand.  It 
 where y and x are scalars.\n\
 \n\
 The second and third arguments are limits of integration.  Either or\n\
 both may be infinite.  The optional argument tol specifies the desired\n\
 accuracy of the result.  The optional argument sing is a vector of\n\
 at which the integrand is singular.\n", },
 
   { "quad_options", -1, 1, builtin_quad_options,
-    "quad_options (keyword, value): set or show options for quad", },
+    "quad_options (keyword, value)\n\n\
+       Set or show options for quad.  Keywords may be abbreviated\n\
+       to the shortest match.", },
 
   { "quit", 1, 0, builtin_quit,
     "quit (): exit Octave gracefully", },
 
   { "qzval", 3, 1, builtin_qzval,
     "x = qzval (A,B): compute generalized eigenvalues of \n\
   the matrix pencil (A - lambda B).  A and B must be real matrices.", },
 
@@ -1111,29 +1127,30 @@ additional_help_message (ostrstream& out
     << "\n"
     << "Additional help for builtin functions, operators, and variables\n"
     << "is available in the on-line version of the manual.\n"
     << "\n"
     << "Use the command `help -i <topic>' to search the manual index.\n";
 }
 
 void
-print_usage (const char *string)
+print_usage (const char *string, int just_usage = 0)
 {
   ostrstream output_buf;
 
   help_list *gf_help_list = builtin_general_functions_help ();
   help_list *tf_help_list = builtin_text_functions_help ();
   help_list *mf_help_list = builtin_mapper_functions_help ();
 
   if (help_from_list (output_buf, gf_help_list, string, 1)
       || help_from_list (output_buf, tf_help_list, string, 1)
       || help_from_list (output_buf, mf_help_list, string, 1))
     {
-      additional_help_message (output_buf);
+      if (! just_usage)
+	additional_help_message (output_buf);
       output_buf << ends;
       maybe_page_output (output_buf);
     }
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -81,17 +81,17 @@ extern help_list *builtin_text_functions
 extern help_list *builtin_variables_help (void);
 
 extern int help_from_list (ostrstream& output_buf,
 			   const help_list *list, const char *string,
 			   int usage);
 
 extern void additional_help_message (ostrstream& output_buf);
 
-extern void print_usage (const char *s);
+extern void print_usage (const char *s, int just_usage = 0);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -125,17 +125,17 @@ char *current_input_line = (char *) NULL
 
 // A line of input from readline.
 static char *octave_gets_line = (char *) NULL;
 
 /*
  * Use GNU readline to get an input line and store it in the history
  * list.
  */
-char *
+static char *
 octave_gets (void)
 {
   if (octave_gets_line != NULL)
     {
       free (octave_gets_line);
       octave_gets_line = (char *) NULL;
     }
 
@@ -159,20 +159,20 @@ octave_gets (void)
   current_input_line = octave_gets_line;
 
   if (octave_gets_line && *octave_gets_line)
     {
       maybe_save_history (octave_gets_line);
 
       if (echo_input)
 	{
-	  if (!forced_interactive)
+	  if (! forced_interactive)
 	    cout << "+ ";
-	  if (octave_gets_line != (char *) NULL)
-	    cout << octave_gets_line << "\n";
+
+	  cout << octave_gets_line << "\n";
 	}
     }
   return octave_gets_line;
 }
 
 /*
  * Read a line from the input stream.
  */
@@ -249,16 +249,24 @@ octave_read (char *buf, int max_size)
       else
 	status = 0; // Tell yylex that we found EOF.
 
       if (stashed_line)
 	delete [] stashed_line;
 
       stashed_line = strsave (buf);
       current_input_line = stashed_line;
+
+      if (echo_input && current_input_line && *current_input_line)
+	{
+	  if (! forced_interactive)
+	    cout << "+ ";
+
+	  cout << current_input_line << "\n";
+	}
     }
   input_line_number++;
   return status;
 }
 
 /*
  * Fix things up so that input can come from file `name', printing a
  * warning if the file doesn't exist.
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -23,17 +23,16 @@ Software Foundation, 675 Mass Ave, Cambr
 
 // Use the GNU readline library for command line editing and hisory.
 
 #if !defined (_input_h)
 #define _input_h 1
 
 #include <stdio.h>
 
-extern char *octave_gets (void);
 extern int octave_read (char *buf, int max_size);
 extern FILE *get_input_from_file (char *name, int warn = 1);
 extern FILE *get_input_from_stdin (void);
 extern void initialize_readline (void);
 
 // Global pointer for eval().
 extern const char *current_eval_string;
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -622,53 +622,82 @@ void
 do_comma_insert_check (void)
 {
   int c = yyinput ();
   yyunput (c, yytext);
   do_comma_insert = (braceflag && c == '[');
 }
 
 /*
- * Fix things up for errors or interrupts.  This could use a few
- * comments now, eh?
+ * Fix things up for errors or interrupts.  The parser is never called
+ * recursively, so it is always safe to reinitialize its state before
+ * doing any parsing.
  */
 void
 reset_parser (void)
 {
+// Start off on the right foot.
   BEGIN 0;
   error_state = 0;
+
+// We do want a prompt by default.
   promptflag = 1;
-  doing_set = 0;
-  braceflag = 0;
+
+// Not initially screwed by `function [...] = f (...)' syntax.
   maybe_screwed = 0;
   maybe_screwed_again = 0;
+
+// Not initially inside a loop or if statement.
   looping = 0;
   iffing = 0;
+
+// Quote marks strings intially.
+  quote_is_transpose = 0;
+
+// Next token can be identifier.
+  cant_be_identifier = 0;
+
+// No need to do comma insert or convert spaces to comma at beginning
+// of input. 
+  do_comma_insert = 0;
+  convert_spaces_to_comma = 1;
+
+// Not initially defining a function.
+  beginning_of_function = 0;
+  defining_func = 0;
+
+// Not initially doing any plotting or setting of plot attributes.
+  plotting = 0;
+  in_plot_range = 0;
+  past_plot_range = 0;
+  in_plot_using = 0;
+  in_plot_style = 0;
+  doing_set = 0;
+
+// Error may have occurred inside some parentheses or braces.
+  in_brace_or_paren.clear ();
+
+// Not initially defining a matrix list.
+  braceflag = 0;
   ml.clear ();
   mlnm.clear ();
-  defining_func = 0;
-  curr_sym_tab = top_level_sym_tab;
-  get_input_from_eval_string = 0;
-  quote_is_transpose = 0;
-  current_input_column = 1;
-// Might have been reset by defining a function.
-  input_line_number = current_command_number - 1;
-  do_comma_insert = 0;
-  plotting = 0;
-  past_plot_range = 0;
-  in_plot_range = 0;
-  in_plot_using = 0;
-  in_plot_style = 0;
-  cant_be_identifier = 0;
-  convert_spaces_to_comma = 1;
-  beginning_of_function = 0;
-  in_brace_or_paren.clear ();
+
+// Clear out the stack of token info used to track line and column
+// numbers.
   while (! token_stack.empty ())
     delete token_stack.pop ();
-  yyrestart (stdin);
+
+// Can be reset by defining a function.
+  current_input_column = 1;
+  input_line_number = current_command_number - 1;
+
+// Only ask for input from stdin if we are expecting interactive
+// input.
+  if (interactive && ! (reading_m_file || get_input_from_eval_string))
+    yyrestart (stdin);
 }
 
 /*
  * Replace backslash escapes in a string with the real values.
  */
 static void
 do_string_escapes (char *s)
 {
@@ -756,19 +785,24 @@ fixup_column_count (char *s)
  */
 
 #ifdef yywrap
 #undef yywrap
 #endif
 static int
 yywrap (void)
 {
-  return 0;
+  return 1;
 }
 
+/*
+ * These are not needed with flex-2.4.6, but may be needed with
+ * earlier 2.4.x versions.
+ */
+#if 0
 static void *
 yy_flex_alloc (int size)
 {
   return (void *) malloc ((unsigned) size);
 }
 
 static void *
 yy_flex_realloc (void *ptr, int size)
@@ -776,16 +810,17 @@ yy_flex_realloc (void *ptr, int size)
   return (void *) realloc (ptr, (unsigned) size);
 }
 
 static void
 yy_flex_free (void *ptr)
 {
   free (ptr);
 }
+#endif
 
 /*
  * Tell us all what the current buffer is.
  */
 YY_BUFFER_STATE
 current_buffer (void)
 {
   return YY_CURRENT_BUFFER;
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -22,22 +22,26 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #ifndef NPSOL_MISSING
 
+#include <strstream.h>
+
 #include "NPSOL.h"
 
 #include "tree-const.h"
 #include "variables.h"
+#include "builtins.h"
 #include "gripes.h"
 #include "error.h"
+#include "pager.h"
 #include "utils.h"
 #include "f-npsol.h"
 
 // Global pointers for user defined functions required by npsol.
 static tree *npsol_objective;
 static tree *npsol_constraints;
 
 #ifdef WITH_DLD
@@ -49,16 +53,18 @@ builtin_npsol_2 (const tree_constant *ar
 
 tree_constant *
 builtin_npsol_options_2 (const tree_constant *args, int nargin, int nargout)
 {
   return npsol_options (args, nargin, nargout);
 }
 #endif
 
+static NPSOL_options npsol_opts;
+
 double
 npsol_objective_function (const ColumnVector& x)
 {
   int n = x.capacity ();
 
   tree_constant decision_vars;
   if (n > 1)
     {
@@ -317,26 +323,28 @@ Handle all of the following:
   ColumnVector lambda;
   int inform;
 
   if (nargin == 3)
     {
       // 1. npsol (x, phi)
 
       NPSOL nlp (x, func);
+      nlp.copy (npsol_opts);
       soln = nlp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
   if (nargin == 5)
     {
       // 2. npsol (x, phi, lb, ub)
 
       NPSOL nlp (x, func, bounds);
+      nlp.copy (npsol_opts);
       soln = nlp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
   npsol_constraints = NULL_TREE;
   if (nargin == 6 || nargin == 8 || nargin == 9 || nargin == 11)
     npsol_constraints = is_valid_function (args[nargin-2], "npsol", 0);
@@ -360,23 +368,25 @@ Handle all of the following:
 
 	  LinConst linear_constraints (llb, c, lub);
 
 	  if (nargin == 6)
 	    {
 	      // 7. npsol (x, phi, llb, c, lub)
 
 	      NPSOL nlp (x, func, linear_constraints);
+	      nlp.copy (npsol_opts);
 	      soln = nlp.minimize (objf, inform, lambda);
 	    }
 	  else
 	    {
 	      // 3. npsol (x, phi, lb, ub, llb, c, lub)
 
 	      NPSOL nlp (x, func, bounds, linear_constraints);
+	      nlp.copy (npsol_opts);
 	      soln = nlp.minimize (objf, inform, lambda);
 	    }
 	  goto solved;
 	}
       else
 	{
 	  if (takes_correct_nargs (npsol_constraints, 2, "npsol", 1))
 	    {
@@ -391,23 +401,25 @@ Handle all of the following:
 
 	      NLConst nonlinear_constraints (nllb, const_func, nlub);
 
 	      if (nargin == 6)
 		{
 		  // 8. npsol (x, phi, nllb, g, nlub)
 
 		  NPSOL nlp (x, func, nonlinear_constraints);
+		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
 	      else
 		{
 		  // 5. npsol (x, phi, lb, ub, nllb, g, nlub)
 
 		  NPSOL nlp (x, func, bounds, nonlinear_constraints);
+		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
 	      goto solved;
 	    }
 	}
     }
 
   if (nargin == 9 || nargin == 11)
@@ -448,26 +460,26 @@ Handle all of the following:
 	      LinConst linear_constraints (llb, c, lub);
 
 	      if (nargin == 9)
 		{
 		  // 6. npsol (x, phi, llb, c, lub, nllb, g, nlub)
 
 		  NPSOL nlp (x, func, linear_constraints,
 			     nonlinear_constraints);
-
+		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
 	      else
 		{
 		  // 4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
 
 		  NPSOL nlp (x, func, bounds, linear_constraints,
 			     nonlinear_constraints);
-
+		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
 	      goto solved;
 	    }
 	}
     }
 
   return retval;
@@ -481,23 +493,253 @@ Handle all of the following:
   if (nargout > 2)
     retval[2] = tree_constant ((double) inform);
   if (nargout > 3)
     retval[3] = tree_constant (lambda);
 
   return retval;
 }
 
+typedef void (NPSOL_options::*d_set_opt_mf) (double);
+typedef void (NPSOL_options::*i_set_opt_mf) (int);
+typedef double (NPSOL_options::*d_get_opt_mf) (void);
+typedef int (NPSOL_options::*i_get_opt_mf) (void);
+
+#define MAX_TOKENS 5
+
+struct NPSOL_OPTIONS
+{
+  char *keyword;
+  char *kw_tok[MAX_TOKENS + 1];
+  int min_len[MAX_TOKENS + 1];
+  int min_toks_to_match;
+  d_set_opt_mf d_set_fcn;
+  i_set_opt_mf i_set_fcn;
+  d_get_opt_mf d_get_fcn;
+  i_get_opt_mf i_get_fcn;
+};
+
+static NPSOL_OPTIONS npsol_option_table[] =
+{
+  { "central difference interval",
+    { "central", "difference", "interval", NULL, NULL, NULL, },
+    { 2, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_central_difference_interval, NULL,
+    NPSOL_options::central_difference_interval, NULL, },
+
+  { "crash tolerance",
+    { "crash", "tolerance", NULL, NULL, NULL, NULL, },
+    { 2, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_crash_tolerance, NULL,
+    NPSOL_options::crash_tolerance, NULL, },
+
+  { "derivative level",
+    { "derivative", "level", NULL, NULL, NULL, NULL, },
+    { 1, 0, 0, 0, 0, 0, }, 1,
+    NULL, NPSOL_options::set_derivative_level,
+    NULL, NPSOL_options::derivative_level, },
+
+  { "difference interval",
+    { "difference", "interval", NULL, NULL, NULL, NULL, },
+    { 3, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_difference_interval, NULL,
+    NPSOL_options::difference_interval, NULL, },
+
+  { "function precision",
+    { "function", "precision", NULL, NULL, NULL, NULL, },
+    { 2, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_function_precision, NULL,
+    NPSOL_options::function_precision, NULL, },
+
+  { "infinite bound size",
+    { "infinite", "bound", "size", NULL, NULL, NULL, },
+    { 1, 1, 0, 0, 0, 0, }, 2,
+    NPSOL_options::set_infinite_bound, NULL,
+    NPSOL_options::infinite_bound, NULL, },
+
+  { "infinite step size",
+    { "infinite", "step", "size", NULL, NULL, NULL, },
+    { 1, 1, 0, 0, 0, 0, }, 2,
+    NPSOL_options::set_infinite_step, NULL,
+    NPSOL_options::infinite_step, NULL, },
+
+  { "linear feasibility tolerance",
+    { "linear", "feasibility", "tolerance", NULL, NULL, NULL, },
+    { 5, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_linear_feasibility_tolerance, NULL,
+    NPSOL_options::linear_feasibility_tolerance, NULL, },
+
+  { "linesearch tolerance",
+    { "linesearch", "tolerance", NULL, NULL, NULL, NULL, },
+    { 5, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_linesearch_tolerance, NULL,
+    NPSOL_options::linesearch_tolerance, NULL, },
+
+  { "major iteration limit",
+    { "major", "iteration", "limit", NULL, NULL, NULL, },
+    { 2, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_major_iteration_limit,
+    NULL, NPSOL_options::major_iteration_limit, },
+
+  { "minor iteration limit",
+    { "minor", "iteration", "limit", NULL, NULL, NULL, },
+    { 2, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_minor_iteration_limit,
+    NULL, NPSOL_options::minor_iteration_limit, },
+
+  { "major print level",
+    { "major", "print", "level", NULL, NULL, NULL, },
+    { 2, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_major_print_level,
+    NULL, NPSOL_options::major_print_level, },
+
+  { "minor print level",
+    { "minor", "print", "level", NULL, NULL, NULL, },
+    { 2, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_minor_print_level,
+    NULL, NPSOL_options::minor_print_level, },
+
+  { "nonlinear feasibility tolerance",
+    { "nonlinear", "feasibility", "tolerance", NULL, NULL, },
+    { 1, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_nonlinear_feasibility_tolerance, NULL,
+    NPSOL_options::nonlinear_feasibility_tolerance, NULL, },
+
+  { "optimality tolerance",
+    { "optimality", "tolerance", NULL, NULL, NULL, NULL, },
+    { 1, 0, 0, 0, 0, 0, }, 1,
+    NPSOL_options::set_optimality_tolerance, NULL,
+    NPSOL_options::optimality_tolerance, NULL, },
+
+  { "start objective check at variable",
+    { "start", "objective", "check", "at", "variable", NULL, },
+    { 3, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_start_objective_check,
+    NULL, NPSOL_options::start_objective_check, },
+
+  { "start constraint check at variable",
+    { "start", "constraint", "check", "at", "variable", NULL, },
+    { 3, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_start_constraint_check,
+    NULL, NPSOL_options::start_constraint_check, },
+
+  { "stop objective check at variable",
+    { "stop", "objective", "check", "at", "variable", NULL, },
+    { 3, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_stop_objective_check,
+    NULL, NPSOL_options::stop_objective_check, },
+
+  { "stop constraint check at variable",
+    { "stop", "constraint", "check", "at", "variable", NULL, },
+    { 3, 1, 0, 0, 0, 0, }, 2,
+    NULL, NPSOL_options::set_stop_constraint_check,
+    NULL, NPSOL_options::stop_constraint_check, },
+
+  { "verify level",
+    { "verify", "level", NULL, NULL, NULL, NULL, },
+    { 1, 0, 0, 0, 0, 0, }, 1,
+    NULL, NPSOL_options::set_verify_level,
+    NULL, NPSOL_options::verify_level, },
+
+  { NULL,
+    { NULL, NULL, NULL, NULL, NULL, NULL, },
+    { 0, 0, 0, 0, 0, 0, }, 0,
+    NULL, NULL, NULL, NULL, },
+};
+
+static void
+print_npsol_option_list (void)
+{
+  ostrstream output_buf;
+
+  print_usage ("npsol_options", 1);
+
+  output_buf << "\n"
+	     << "Options for npsol include:\n\n"
+	     << "  keyword                                  value\n"
+	     << "  -------                                  -----\n\n";
+
+  NPSOL_OPTIONS *list = npsol_option_table;
+
+  char *keyword;
+  while ((keyword = list->keyword) != (char *) NULL)
+    {
+      output_buf.form ("  %-40s ", keyword);
+      if (list->d_get_fcn)
+	{
+	  double val = (npsol_opts.*list->d_get_fcn) ();
+	  if (val < 0.0)
+	    output_buf << "computed automatically";
+	  else
+	    output_buf << val;
+	}
+      else
+	{
+	  int val = (npsol_opts.*list->i_get_fcn) ();
+	  if (val < 0)
+	    output_buf << "depends on problem size";
+	  else
+	    output_buf << val;
+	}
+      output_buf << "\n";
+      list++;
+    }
+
+  output_buf << "\n" << ends;
+  maybe_page_output (output_buf);
+}
+
+static void
+do_npsol_option (char *keyword, double val)
+{
+  NPSOL_OPTIONS *list = npsol_option_table;
+
+  while (list->keyword != (char *) NULL)
+    {
+      if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
+				list->min_toks_to_match, MAX_TOKENS))
+	{
+	  if (list->d_set_fcn)
+	    (npsol_opts.*list->d_set_fcn) (val);
+	  else
+	    (npsol_opts.*list->i_set_fcn) (NINT (val));
+
+	  return;
+	}
+      list++;
+    }
+
+  warning ("npsol_options: no match for `%s'", keyword);
+}
+
 tree_constant *
 npsol_options (const tree_constant *args, int nargin, int nargout)
 {
-// Assumes that we have been given the correct number of arguments.
+  tree_constant *retval = NULL_TREE_CONST;
 
-  tree_constant *retval = NULL_TREE_CONST;
-  error ("npsol_options: not implemented yet");
+  if (nargin == 1)
+    {
+      print_npsol_option_list ();
+    }
+  else if (nargin == 3)
+    {
+      if (args[1].is_string_type ())
+	{
+	  char *keyword = args[1].string_value ();
+	  double val = args[2].double_value ();
+	  do_npsol_option (keyword, val);
+	}
+      else
+	print_usage ("npsol_options");
+    }
+  else
+    {
+      print_usage ("npsol_options");
+    }
+
   return retval;
 }
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -123,16 +123,19 @@ tree_function *curr_function = (tree_fun
 // Top level context (?)
 jmp_buf toplevel;
 
 // This is not really the right place to do this...
 typedef void (*one_arg_error_handler_t) (const char*);
 extern one_arg_error_handler_t set_Complex_error_handler
   (one_arg_error_handler_t f);
 
+// This is from readline's paren.c:
+extern int rl_blink_matching_paren;
+
 static void
 octave_Complex_error_handler (const char* msg)
 {
   warning (msg);
 }
 
 // Nonzero means we read ~/.octaverc and ./.octaverc.
 static int read_init_files = 1;
@@ -319,18 +322,16 @@ verbose_usage (void)
        << "     i : force interactive behavior\n"
        << "     q : don't print message at startup\n"
        << "     v : print version number and exit\n"
        << "     x : echo commands as they are executed\n"
        << "\n"
        << "  file : execute commands from named file\n"
        << "\n";
 
-  cout.flush ();
-
   exit (1);
 }
 
 /*
  * Terse usage messsage.
  */
 static void
 usage (void)
@@ -468,46 +469,52 @@ main (int argc, char **argv)
       usage ();
     }
   else if (remaining_args == 1)
     {
       FILE *infile = get_input_from_file (argv[optind]);
       if (infile == (FILE *) NULL)
 	clean_up_and_exit (1);
       else
-	switch_to_buffer (create_buffer (infile));
+	{
+	  rl_blink_matching_paren = 0;
+	  switch_to_buffer (create_buffer (infile));
+	}
     }
   else
     {
       switch_to_buffer (create_buffer (get_input_from_stdin ()));
 
 // Is input coming from a terminal?  If so, we are probably
 // interactive.
 
       interactive = (isatty (fileno (stdin)) && isatty (fileno (stdout)));
     }
 
 // Force input to be echoed if not really interactive, but the user
 // has forced interactive behavior.
 
   if (!interactive && forced_interactive)
-    echo_input = 1;
+    {
+      rl_blink_matching_paren = 0;
+      echo_input = 1;
+    }
 
   if (! (interactive || forced_interactive))
     using_readline = 0;
 
   install_signal_handlers ();
 
   if (! inhibit_startup_message)
     {
       cout << "Octave, version " << version_string
 	   << ".  Copyright (C) 1992, 1993, 1994 John W. Eaton.\n"
 	   << "This is free software with ABSOLUTELY NO WARRANTY.\n"
 	   << "For details, type `warranty'.\n"
-	   << "\n";
+	   << endl;
     }
 
 // Allow the user to interrupt us without exiting.
 
   volatile sig_handler *saved_sigint_handler = signal (SIGINT, SIG_IGN);
 
   if (setjmp (toplevel) != 0)
     {
@@ -520,18 +527,22 @@ main (int argc, char **argv)
 
   signal (SIGINT, saved_sigint_handler);
 
 // The big loop.
 
   int retval;
   do
     {
+      curr_sym_tab = top_level_sym_tab;
+
       reset_parser ();
+
       retval = yyparse ();
+
       if (retval == 0 && global_command != NULL_TREE)
 	{
 	  global_command->eval (1);
 	  delete global_command;
 	  current_command_number++;
 	}
     }
   while (retval == 0);
diff --git a/src/tc-extras.cc b/src/tc-extras.cc
--- a/src/tc-extras.cc
+++ b/src/tc-extras.cc
@@ -1231,22 +1231,21 @@ eval_string (const char *string, int pri
   YY_BUFFER_STATE new_buf = create_buffer ((FILE *) NULL);
 
   add_unwind_protect (restore_input_buffer, (void *) old_buf);
   add_unwind_protect (delete_input_buffer, (void *) new_buf);
 
   switch_to_buffer (new_buf);
 
   unwind_protect_ptr (curr_sym_tab);
-  symbol_table *prev_sym_tab = curr_sym_tab;
+
+  reset_parser ();
 
   parse_status = yyparse ();
 
-  curr_sym_tab = prev_sym_tab;
-
 // Important to reset the idea of where input is coming from before
 // trying to eval the command we just parsed -- it might contain the
 // name of an m-file that still needs to be parsed!
 
   tree *command = global_command;
 
   run_unwind_frame ("eval_string");
 
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -52,16 +52,30 @@ Free Software Foundation, Inc.
 #include <time.h>
 #include <math.h>
 #include <limits.h>
 #include <iostream.h>
 #include <strstream.h>
 #include <fstream.h>
 #include <dirent.h>
 
+#ifndef HAVE_STRCASECMP
+extern "C"
+{
+extern int strcasecmp (const char*, const char*);
+}
+#endif
+
+#ifndef HAVE_STRNCASECMP
+extern "C"
+{
+extern int strncasecmp (const char*, const char*, size_t);
+}
+#endif
+
 #define NLENGTH(dirent) (strlen((dirent)->d_name))
 
 extern "C"
 {
 #if defined (HAVE_TERMIOS_H)
 #include <termios.h>
 #elif defined (HAVE_TERMIO_H)
 #include <termio.h>
@@ -212,17 +226,17 @@ check_dimensions (int& nr, int& nc, cons
 void
 raw_mode (int on)
 {
   static int curr_on = 0;
 
   int tty_fd = STDIN_FILENO;
   if (! isatty (tty_fd))
     {
-      if (interactive || forced_interactive)
+      if (interactive)
 	error ("stdin is not a tty!");
       return;
     }
 
   if (on == curr_on)
     return;
 
 #if defined (HAVE_TERMIOS_H)
@@ -1266,24 +1280,117 @@ send_to_plot_stream (const char *cmd)
 void
 close_plot_stream (void)
 {
   if (plot_stream.is_open ())
     plot_stream.close ();
 }
 
 int
-almost_match (const char *std, const char *s, int min_match_len = 1)
+almost_match (const char *std, const char *s,
+	      int min_match_len = 1, int case_sens = 1)
 {
   int stdlen = strlen (std);
   int slen = strlen (s);
 
   return (slen <= stdlen
 	  && slen >= min_match_len
-	  && strncmp (std, s, slen) == 0);
+	  && (case_sens
+	      ? (strncmp (std, s, slen) == 0)
+	      : (strncasecmp (std, s, slen) == 0)));
+}
+
+/*
+ * Ugh.
+ */
+int
+keyword_almost_match (const char **std, int *min_len, const char *s,
+		      int min_toks_to_match, int max_toks)
+{
+  int status = 0;
+  int tok_count = 0;
+  int toks_matched = 0;
+
+  if (s == NULL || *s == '\0' || max_toks < 1)
+    return status;
+
+  char *kw = strsave (s);
+
+  char *t = kw;
+  while (*t != '\0')
+    {
+      if (*t == '\t')
+	*t = ' ';
+      t++;
+    }
+
+  char *beg = kw;
+  while (*beg == ' ')
+    beg++;
+
+  if (*beg == '\0')
+    return status;
+
+
+  char **to_match = new char * [max_toks + 1];
+  char **s1 = std;
+  char **s2 = to_match;
+
+  if (s1 == NULL || s2 == NULL)
+    goto done;
+
+  s2[tok_count] = beg;
+  char *end;
+  while ((end = strchr (beg, ' ')) != NULL)
+    {
+      *end = '\0';
+      beg = end + 1;
+
+      while (*beg == ' ')
+	beg++;
+
+      if (*beg == '\0')
+	break;
+
+      tok_count++;
+      if (tok_count >= max_toks)
+	goto done;
+
+      s2[tok_count] = beg;
+    }
+  s2[tok_count+1] = NULL;
+
+  s2 = to_match;
+
+  for (;;)
+    {
+      if (! almost_match (*s1, *s2, min_len[toks_matched], 0))
+	goto done;
+
+      toks_matched++;
+
+      s1++;
+      s2++;
+
+      if (! *s2)
+	{
+	  status = (toks_matched >= min_toks_to_match);
+	  goto done;
+	}
+
+      if (! *s1)
+	goto done;
+    }
+
+ done:
+
+  delete [] kw;
+  delete [] to_match;
+
+  return status;
 }
 
 char **
 get_m_file_names (int& num, const char *dir, int no_suffix)
 {
   static int num_max = 256;
   char **retval = new char * [num_max];
   int i = 0;
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -70,17 +70,20 @@ extern void jump_to_top_level (void);
 extern char *s_plural (int);
 extern char *es_plural (int);
 extern char *save_in_tmp_file (tree_constant& t, int nd = 2, int para = 0); 
 extern void mark_for_deletion (const char *);
 extern void cleanup_tmp_files (void);
 extern int send_to_plot_stream (const char *cmd);
 extern void close_plot_stream (void);
 extern int almost_match (const char *std, const char *s,
-			 int min_match_len = 1); 
+			 int min_match_len = 1, int case_sens = 1);
+extern int keyword_almost_match (const char **std, int *min_len,
+				 const char *s, int min_toks_to_match,
+				 int max_toks);
 extern char **get_m_file_names (int& mfl_len, const char *dir, int no_suffix);
 extern char **get_m_file_names (int& mfl_len, int no_suffix);
 extern int NINT (double x);
 extern double D_NINT (double x);
 extern void delete_ppchar (char **);
 
 #endif
 
