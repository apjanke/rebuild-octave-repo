# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1363061908 14400
#      Tue Mar 12 00:18:28 2013 -0400
# Node ID 04a7953496a7ae1584a7add975c5b296c4dc4a40
# Parent  3389152014cade1b88f8ac8cec5e2660d2477b26
create base class for parser; use reference for curr_lexer

* lex.h, lex.ll (octave_base_parser): New base class for parser
class.  Move most of previous octave_parser class here.  Use reference
for curr_lexer object instead of pointer.  Change all uses.
(octave_parser): Derive from octave_base_parser.

diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -615,17 +615,17 @@ main_loop (void)
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
-              else if (curr_parser.curr_lexer->end_of_input)
+              else if (curr_parser.curr_lexer.end_of_input)
                 break;
             }
         }
       catch (octave_interrupt_exception)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -102,17 +102,17 @@ bool reading_startup_message_printed = f
 symtab_context parser_symtab_context;
 
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
-static void yyerror (octave_parser& curr_parser, const char *s);
+static void yyerror (octave_base_parser& curr_parser, const char *s);
 
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
@@ -121,25 +121,25 @@ make_statement (T *arg)
 
 #define ABORT_PARSE \
   do \
     { \
       yyerrok; \
       if (! parser_symtab_context.empty ()) \
         parser_symtab_context.pop (); \
       if ((interactive || forced_interactive)   \
-          && ! (curr_lexer)->input_from_eval_string ()) \
+          && ! curr_lexer.input_from_eval_string ()) \
         YYACCEPT; \
       else \
         YYABORT; \
     } \
   while (0)
 
 #define curr_lexer curr_parser.curr_lexer
-#define scanner curr_lexer->scanner
+#define scanner curr_lexer.scanner
 
 %}
 
 // Bison declarations.
 
 // Don't add spaces around the = here; it causes some versions of
 // bison to fail to properly recognize the directive.
 
@@ -151,17 +151,17 @@ make_statement (T *arg)
 // safe to create a parser object and call it while anotehr parser
 // object is active (to parse a callback function while the main
 // interactive parser is waiting for input, for example) if you take
 // care to properly save and restore (typically with an unwind_protect
 // object) relevant global values before and after the nested call.
 
 %define api.pure
 %PUSH_PULL_DECL%
-%parse-param { octave_parser& curr_parser }
+%parse-param { octave_base_parser& curr_parser }
 %lex-param { void *scanner }
 
 %union
 {
   // The type of the basic tokens returned by the lexer.
   token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
@@ -321,17 +321,17 @@ input           : input1
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
                 | END_OF_INPUT
                   {
-                    curr_lexer->end_of_input = true;
+                    curr_lexer.end_of_input = true;
                     $$ = 0;
                   }
                 | simple_list
                   { $$ = $1; }
                 | simple_list '\n'
                   { $$ = $1; }
                 | simple_list END_OF_INPUT
                   { $$ = $1; }
@@ -479,36 +479,36 @@ cell_or_matrix_row
                   { $$ = $1; }
                 | arg_list ','          // Ignore trailing comma.
                   { $$ = $1; }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
                     $$ = curr_parser.make_fcn_handle ($2);
-                    curr_lexer->looking_at_function_handle--;
+                    curr_lexer.looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   {
                     $$ = curr_parser.make_anon_fcn_handle ($2, $3);
-                    curr_lexer->nesting_level.remove ();
+                    curr_lexer.nesting_level.remove ();
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
                   { $$ = $1; }
                 | matrix
                   {
-                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer.looking_at_matrix_or_assign_lhs = false;
                     $$ = $1;
                   }
                 | cell
                   { $$ = $1; }
                 | meta_identifier
                   { $$ = $1; }
                 | superclass_identifier
                   { $$ = $1; }
@@ -548,17 +548,17 @@ arg_list        : expression
                 | arg_list ',' expression
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 indirect_ref_op : '.'
-                  { curr_lexer->looking_at_indirect_ref = true; }
+                  { curr_lexer.looking_at_indirect_ref = true; }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
                   { $$ = curr_parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
                   { $$ = curr_parser.make_postfix_op (MINUS_MINUS, $1, $2); }
@@ -655,17 +655,17 @@ simple_expr     : colon_expr
                   { $$ = curr_parser.make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
 assign_lhs      : simple_expr
                   {
                     $$ = curr_parser.validate_matrix_for_assignment ($1);
 
                     if ($$)
-                      { curr_lexer->looking_at_matrix_or_assign_lhs = false; }
+                      { curr_lexer.looking_at_matrix_or_assign_lhs = false; }
                     else
                       {
                         // validate_matrix_for_assignment deleted $1.
                         ABORT_PARSE;
                       }
                   }
                 ;
 
@@ -746,42 +746,42 @@ command         : declaration
 
 // =====================
 // Declaration statemnts
 // =====================
 
 declaration     : GLOBAL decl1
                   {
                     $$ = curr_parser.make_decl_command (GLOBAL, $1, $2);
-                    curr_lexer->looking_at_decl_list = false;
+                    curr_lexer.looking_at_decl_list = false;
                   }
                 | PERSISTENT decl1
                   {
                     $$ = curr_parser.make_decl_command (PERSISTENT, $1, $2);
-                    curr_lexer->looking_at_decl_list = false;
+                    curr_lexer.looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 decl_param_init : // empty
-                { curr_lexer->looking_at_initializer_expression = true; }
+                { curr_lexer.looking_at_initializer_expression = true; }
 
 decl2           : identifier
                   { $$ = new tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
-                    curr_lexer->looking_at_initializer_expression = false;
+                    curr_lexer.looking_at_initializer_expression = false;
                     $$ = new tree_decl_elt ($1, $4);
                   }
                 | magic_tilde
                   {
                     $$ = new tree_decl_elt ($1);
                   }
                 ;
 
@@ -812,30 +812,30 @@ if_cmd_list     : if_cmd_list1
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 if_cmd_list1    : expression opt_sep opt_list
                   {
-                    $1->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
+                    $1->mark_braindead_shortcircuit (curr_lexer.fcn_file_full_name);
 
                     $$ = curr_parser.start_if_command ($1, $3);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
                   {
-                    $4->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
+                    $4->mark_braindead_shortcircuit (curr_lexer.fcn_file_full_name);
 
                     $$ = curr_parser.make_elseif_clause ($1, $4, $6, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
@@ -884,17 +884,17 @@ default_case    : OTHERWISE stash_commen
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression opt_sep opt_list END
                   {
-                    $3->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
+                    $3->mark_braindead_shortcircuit (curr_lexer.fcn_file_full_name);
 
                     if (! ($$ = curr_parser.make_while_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
                     if (! ($$ = curr_parser.make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
@@ -981,49 +981,49 @@ push_fcn_symtab : // empty
                       curr_parser.max_fcn_depth = curr_parser.curr_fcn_depth;
 
                     parser_symtab_context.push ();
 
                     symbol_table::set_scope (symbol_table::alloc_scope ());
 
                     curr_parser.function_scopes.push_back (symbol_table::current_scope ());
 
-                    if (! curr_lexer->reading_script_file
+                    if (! curr_lexer.reading_script_file
                         && curr_parser.curr_fcn_depth == 1
                         && ! curr_parser.parsing_subfunctions)
                       curr_parser.primary_fcn_scope = symbol_table::current_scope ();
 
-                    if (curr_lexer->reading_script_file
+                    if (curr_lexer.reading_script_file
                         && curr_parser.curr_fcn_depth > 1)
                       curr_parser.bison_error ("nested functions not implemented in this context");
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
                   {
-                    curr_lexer->looking_at_parameter_list = true;
-
-                    if (curr_lexer->looking_at_function_handle)
+                    curr_lexer.looking_at_parameter_list = true;
+
+                    if (curr_lexer.looking_at_function_handle)
                       {
                         parser_symtab_context.push ();
                         symbol_table::set_scope (symbol_table::alloc_scope ());
-                        curr_lexer->looking_at_function_handle--;
-                        curr_lexer->looking_at_anon_fcn_args = true;
+                        curr_lexer.looking_at_function_handle--;
+                        curr_lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
-                    curr_lexer->looking_at_parameter_list = false;
-                    curr_lexer->looking_for_object_index = false;
+                    curr_lexer.looking_at_parameter_list = false;
+                    curr_lexer.looking_for_object_index = false;
                   }
                 ;
 
 param_list      : param_list_beg param_list1 param_list_end
                   { $$ = $2; }
                 | param_list_beg error
                   {
                     curr_parser.bison_error ("invalid parameter list");
@@ -1054,30 +1054,30 @@ param_list2     : decl2
                 ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
-                    curr_lexer->looking_at_return_list = false;
+                    curr_lexer.looking_at_return_list = false;
                     $$ = new tree_parameter_list ();
                   }
                 | return_list1
                   {
-                    curr_lexer->looking_at_return_list = false;
+                    curr_lexer.looking_at_return_list = false;
                     if ($1->validate (tree_parameter_list::out))
                       $$ = $1;
                     else
                       ABORT_PARSE;
                   }
                 | '[' return_list1 ']'
                   {
-                    curr_lexer->looking_at_return_list = false;
+                    curr_lexer.looking_at_return_list = false;
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 return_list1    : identifier
@@ -1090,40 +1090,40 @@ return_list1    : identifier
                 ;
 
 // =======================
 // Script or function file
 // =======================
 
 file            : INPUT_FILE opt_nl opt_list END_OF_INPUT
                   {
-                    if (! curr_lexer->reading_fcn_file)
+                    if (! curr_lexer.reading_fcn_file)
                       {
                         tree_statement *end_of_script
                           = curr_parser.make_end ("endscript",
-                                                  curr_lexer->input_line_number,
-                                                  curr_lexer->current_input_column);
+                                                  curr_lexer.input_line_number,
+                                                  curr_lexer.current_input_column);
 
                         curr_parser.make_script ($3, end_of_script);
                       }
 
                     $$ = 0;
                   }
                 ;
 
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN stash_comment
                   {
                     $$ = $3;
-                    if (curr_lexer->reading_classdef_file
-                        || curr_lexer->parsing_classdef)
-                      curr_lexer->maybe_classdef_get_set_method = true;
+                    if (curr_lexer.reading_classdef_file
+                        || curr_lexer.parsing_classdef)
+                      curr_lexer.maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
                     $$ = curr_parser.finish_function (0, $2, $1);
                     curr_parser.recover_from_parsing_function ();
                   }
@@ -1133,31 +1133,31 @@ function        : function_beg function1
                     curr_parser.recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
-                    curr_lexer->parsed_function_name.top () = true;
-                    curr_lexer->maybe_classdef_get_set_method = false;
+                    curr_lexer.parsed_function_name.top () = true;
+                    curr_lexer.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
-                    curr_lexer->parsed_function_name.top () = true;
-                    curr_lexer->maybe_classdef_get_set_method = false;
+                    curr_lexer.parsed_function_name.top () = true;
+                    curr_lexer.maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
-                    curr_lexer->parsed_function_name.top () = true;
-                    curr_lexer->maybe_classdef_get_set_method = false;
+                    curr_lexer.parsed_function_name.top () = true;
+                    curr_lexer.maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
@@ -1180,63 +1180,63 @@ function_end    : END
                     if (curr_parser.end_token_ok ($1, token::function_end))
                       $$ = curr_parser.make_end ("endfunction", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
-//                  if (curr_lexer->reading_script_file)
+//                  if (curr_lexer.reading_script_file)
 //                    {
 //                      curr_parser.bison_error ("function body open at end of script");
 //                      YYABORT;
 //                    }
 
                     if (curr_parser.endfunction_found)
                       {
                         curr_parser.bison_error ("inconsistent function endings -- "
                                  "if one function is explicitly ended, "
                                  "so must all the others");
                         YYABORT;
                       }
 
-                    if (! (curr_lexer->reading_fcn_file || curr_lexer->reading_script_file
-                           || (curr_lexer)->input_from_eval_string ()))
+                    if (! (curr_lexer.reading_fcn_file || curr_lexer.reading_script_file
+                           || curr_lexer.input_from_eval_string ()))
                       {
                         curr_parser.bison_error ("function body open at end of input");
                         YYABORT;
                       }
 
-                    if (curr_lexer->reading_classdef_file)
+                    if (curr_lexer.reading_classdef_file)
                       {
                         curr_parser.bison_error ("classdef body open at end of input");
                         YYABORT;
                       }
 
                     $$ = curr_parser.make_end ("endfunction",
-                                                curr_lexer->input_line_number,
-                                                curr_lexer->current_input_column);
+                                                curr_lexer.input_line_number,
+                                                curr_lexer.current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF stash_comment
                   {
                     $$ = 0;
-                    curr_lexer->parsing_classdef = true;
+                    curr_lexer.parsing_classdef = true;
                   }
                 ;
 
 classdef_end    : END
                   {
-                    curr_lexer->parsing_classdef = false;
+                    curr_lexer.parsing_classdef = false;
 
                     if (curr_parser.end_token_ok ($1, token::classdef_end))
                       $$ = curr_parser.make_end ("endclassdef", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 ;
 
@@ -1438,83 +1438,56 @@ opt_sep         : // empty
 
 %%
 
 // Generic error messages.
 
 #undef curr_lexer
 
 static void
-yyerror (octave_parser& curr_parser, const char *s)
+yyerror (octave_base_parser& curr_parser, const char *s)
 {
   curr_parser.bison_error (s);
 }
 
-octave_parser::~octave_parser (void)
+octave_base_parser::~octave_base_parser (void)
 {
 #if defined (OCTAVE_USE_PUSH_PARSER)
   yypstate_delete (static_cast<yypstate *> (parser_state));
 #endif
 
   delete stmt_list;
 
-  delete curr_lexer;
+  delete &curr_lexer;
 }
-void octave_parser::init (void)
+
+void octave_base_parser::init (void)
 {
 #if defined (OCTAVE_USE_PUSH_PARSER)
   parser_state = yypstate_new ();
 #endif
 
-  CURR_LEXER = curr_lexer;
+  CURR_LEXER = &curr_lexer;
 }
 
 void
-octave_parser::reset (void)
+octave_base_parser::reset (void)
 {
   delete stmt_list;
 
   stmt_list = 0;
 
-  curr_lexer->reset ();
-}
-
-int
-octave_parser::run (void)
-{
-  int status = 0;
-
-#if defined (OCTAVE_USE_PUSH_PARSER)
-
-  do
-    {
-      YYSTYPE lval;
-
-      int token = octave_lex (&lval, scanner);
-
-      yypstate *pstate = static_cast<yypstate *> (parser_state);
-
-      status = octave_push_parse (pstate, token, &lval, *this);
-    }
-  while (status == YYPUSH_MORE);
-
-#else
-
-  status = octave_parse (*this);
-
-#endif
-
-  return status;
+  curr_lexer.reset ();
 }
 
 // Error mesages for mismatched end tokens.
 
 void
-octave_parser::end_error (const char *type, token::end_tok_type ettype,
-                          int l, int c)
+octave_base_parser::end_error (const char *type, token::end_tok_type ettype,
+                               int l, int c)
 {
   static const char *fmt
     = "'%s' command matched by '%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
@@ -1556,17 +1529,17 @@ octave_parser::end_error (const char *ty
       panic_impossible ();
       break;
     }
 }
 
 // Check to see that end tokens are properly matched.
 
 bool
-octave_parser::end_token_ok (token *tok, token::end_tok_type expected)
+octave_base_parser::end_token_ok (token *tok, token::end_tok_type expected)
 {
   bool retval = true;
 
   token::end_tok_type ettype = tok->ettype ();
 
   if (ettype != expected && ettype != token::simple_end)
     {
       retval = false;
@@ -1626,48 +1599,48 @@ octave_parser::end_token_ok (token *tok,
 
   return retval;
 }
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 
 void
-octave_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
+octave_base_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
-      if (curr_lexer->fcn_file_full_name.empty ())
+      if (curr_lexer.fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
       else
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
-           expr->line (), expr->column (), curr_lexer->fcn_file_full_name.c_str ());
+           expr->line (), expr->column (), curr_lexer.fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 void
-octave_parser::maybe_warn_variable_switch_label (tree_expression *expr)
+octave_base_parser::maybe_warn_variable_switch_label (tree_expression *expr)
 {
   if (! expr->is_constant ())
     {
-      if (curr_lexer->fcn_file_full_name.empty ())
+      if (curr_lexer.fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
           ("Octave:variable-switch-label",
            "variable switch label near line %d, column %d in file '%s'",
-           expr->line (), expr->column (), curr_lexer->fcn_file_full_name.c_str ());
+           expr->line (), expr->column (), curr_lexer.fcn_file_full_name.c_str ());
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
 
@@ -1753,17 +1726,17 @@ fold (tree_unary_expression *e)
     }
 
   return retval;
 }
 
 // Finish building a range.
 
 tree_expression *
-octave_parser::finish_colon_expression (tree_colon_expression *e)
+octave_base_parser::finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -1817,17 +1790,17 @@ octave_parser::finish_colon_expression (
     }
 
   return retval;
 }
 
 // Make a constant.
 
 tree_constant *
-octave_parser::make_constant (int op, token *tok_val)
+octave_base_parser::make_constant (int op, token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_constant *retval = 0;
 
   switch (op)
     {
@@ -1880,35 +1853,35 @@ octave_parser::make_constant (int op, to
     }
 
   return retval;
 }
 
 // Make a function handle.
 
 tree_fcn_handle *
-octave_parser::make_fcn_handle (token *tok_val)
+octave_base_parser::make_fcn_handle (token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_fcn_handle *retval = new tree_fcn_handle (tok_val->text (), l, c);
 
   return retval;
 }
 
 // Make an anonymous function handle.
 
 tree_anon_fcn_handle *
-octave_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
-                                     tree_statement *stmt)
+octave_base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
+                                          tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
-  int l = curr_lexer->input_line_number;
-  int c = curr_lexer->current_input_column;
+  int l = curr_lexer.input_line_number;
+  int c = curr_lexer.current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
@@ -1919,26 +1892,26 @@ octave_parser::make_anon_fcn_handle (tre
   tree_statement_list *body = new tree_statement_list (stmt);
 
   body->mark_as_anon_function_body ();
 
   tree_anon_fcn_handle *retval
     = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope, l, c);
   // FIXME: Stash the filename.  This does not work and produces
   // errors when executed.
-  //retval->stash_file_name (curr_lexer->fcn_file_name);
+  //retval->stash_file_name (curr_lexer.fcn_file_name);
 
   return retval;
 }
 
 // Build a binary expression.
 
 tree_expression *
-octave_parser::make_binary_op (int op, tree_expression *op1, token *tok_val,
-                               tree_expression *op2)
+octave_base_parser::make_binary_op (int op, tree_expression *op1,
+                                    token *tok_val, tree_expression *op2)
 {
   octave_value::binary_op t = octave_value::unknown_binary_op;
 
   switch (op)
     {
     case POW:
       t = octave_value::op_pow;
       break;
@@ -2031,18 +2004,18 @@ octave_parser::make_binary_op (int op, t
     = maybe_compound_binary_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a boolean expression.
 
 tree_expression *
-octave_parser::make_boolean_op (int op, tree_expression *op1, token *tok_val,
-                                tree_expression *op2)
+octave_base_parser::make_boolean_op (int op, tree_expression *op1,
+                                     token *tok_val, tree_expression *op2)
 {
   tree_boolean_expression::type t;
 
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
@@ -2063,17 +2036,18 @@ octave_parser::make_boolean_op (int op, 
     = new tree_boolean_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a prefix expression.
 
 tree_expression *
-octave_parser::make_prefix_op (int op, tree_expression *op1, token *tok_val)
+octave_base_parser::make_prefix_op (int op, tree_expression *op1,
+                                    token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case EXPR_NOT:
       t = octave_value::op_not;
       break;
@@ -2106,17 +2080,18 @@ octave_parser::make_prefix_op (int op, t
     = new tree_prefix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build a postfix expression.
 
 tree_expression *
-octave_parser::make_postfix_op (int op, tree_expression *op1, token *tok_val)
+octave_base_parser::make_postfix_op (int op, tree_expression *op1,
+                                     token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case HERMITIAN:
       t = octave_value::op_hermitian;
       break;
@@ -2145,22 +2120,22 @@ octave_parser::make_postfix_op (int op, 
     = new tree_postfix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build an unwind-protect command.
 
 tree_command *
-octave_parser::make_unwind_command (token *unwind_tok,
-                                    tree_statement_list *body,
-                                    tree_statement_list *cleanup_stmts,
-                                    token *end_tok,
-                                    octave_comment_list *lc,
-                                    octave_comment_list *mc)
+octave_base_parser::make_unwind_command (token *unwind_tok,
+                                         tree_statement_list *body,
+                                         tree_statement_list *cleanup_stmts,
+                                         token *end_tok,
+                                         octave_comment_list *lc,
+                                         octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::unwind_protect_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = unwind_tok->line ();
@@ -2171,21 +2146,22 @@ octave_parser::make_unwind_command (toke
     }
 
   return retval;
 }
 
 // Build a try-catch command.
 
 tree_command *
-octave_parser::make_try_command (token *try_tok, tree_statement_list *body,
-                                 tree_statement_list *cleanup_stmts,
-                                 token *end_tok,
-                                 octave_comment_list *lc,
-                                 octave_comment_list *mc)
+octave_base_parser::make_try_command (token *try_tok,
+                                      tree_statement_list *body,
+                                      tree_statement_list *cleanup_stmts,
+                                      token *end_tok,
+                                      octave_comment_list *lc,
+                                      octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::try_catch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = try_tok->line ();
@@ -2196,82 +2172,85 @@ octave_parser::make_try_command (token *
     }
 
   return retval;
 }
 
 // Build a while command.
 
 tree_command *
-octave_parser::make_while_command (token *while_tok, tree_expression *expr,
-                                   tree_statement_list *body, token *end_tok,
-                                   octave_comment_list *lc)
+octave_base_parser::make_while_command (token *while_tok,
+                                        tree_expression *expr,
+                                        tree_statement_list *body,
+                                        token *end_tok,
+                                        octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (end_token_ok (end_tok, token::while_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      curr_lexer->looping--;
+      curr_lexer.looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a do-until command.
 
 tree_command *
-octave_parser::make_do_until_command (token *until_tok,
-                                      tree_statement_list *body,
-                                      tree_expression *expr,
-                                      octave_comment_list *lc)
+octave_base_parser::make_do_until_command (token *until_tok,
+                                           tree_statement_list *body,
+                                           tree_expression *expr,
+                                           octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-  curr_lexer->looping--;
+  curr_lexer.looping--;
 
   int l = until_tok->line ();
   int c = until_tok->column ();
 
   retval = new tree_do_until_command (expr, body, lc, tc, l, c);
 
   return retval;
 }
 
 // Build a for command.
 
 tree_command *
-octave_parser::make_for_command (int tok_id, token *for_tok,
-                                 tree_argument_list *lhs,
-                                 tree_expression *expr,
-                                 tree_expression *maxproc,
-                                 tree_statement_list *body, token *end_tok,
-                                 octave_comment_list *lc)
+octave_base_parser::make_for_command (int tok_id, token *for_tok,
+                                      tree_argument_list *lhs,
+                                      tree_expression *expr,
+                                      tree_expression *maxproc,
+                                      tree_statement_list *body,
+                                      token *end_tok,
+                                      octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   bool parfor = tok_id == PARFOR;
 
   if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      curr_lexer->looping--;
+      curr_lexer.looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       if (lhs->length () == 1)
         {
           tree_expression *tmp = lhs->remove_front ();
 
@@ -2291,76 +2270,78 @@ octave_parser::make_for_command (int tok
     }
 
   return retval;
 }
 
 // Build a break command.
 
 tree_command *
-octave_parser::make_break_command (token *break_tok)
+octave_base_parser::make_break_command (token *break_tok)
 {
   tree_command *retval = 0;
 
   int l = break_tok->line ();
   int c = break_tok->column ();
 
   retval = new tree_break_command (l, c);
 
   return retval;
 }
 
 // Build a continue command.
 
 tree_command *
-octave_parser::make_continue_command (token *continue_tok)
+octave_base_parser::make_continue_command (token *continue_tok)
 {
   tree_command *retval = 0;
 
   int l = continue_tok->line ();
   int c = continue_tok->column ();
 
   retval = new tree_continue_command (l, c);
 
   return retval;
 }
 
 // Build a return command.
 
 tree_command *
-octave_parser::make_return_command (token *return_tok)
+octave_base_parser::make_return_command (token *return_tok)
 {
   tree_command *retval = 0;
 
   int l = return_tok->line ();
   int c = return_tok->column ();
 
   retval = new tree_return_command (l, c);
 
   return retval;
 }
 
 // Start an if command.
 
 tree_if_command_list *
-octave_parser::start_if_command (tree_expression *expr,
-                                 tree_statement_list *list)
+octave_base_parser::start_if_command (tree_expression *expr,
+                                      tree_statement_list *list)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   tree_if_clause *t = new tree_if_clause (expr, list);
 
   return new tree_if_command_list (t);
 }
 
 // Finish an if command.
 
 tree_if_command *
-octave_parser::finish_if_command (token *if_tok, tree_if_command_list *list,
-                                  token *end_tok, octave_comment_list *lc)
+octave_base_parser::finish_if_command (token *if_tok,
+                                       tree_if_command_list *list,
+                                       token *end_tok,
+                                       octave_comment_list *lc)
 {
   tree_if_command *retval = 0;
 
   if (end_token_ok (end_tok, token::if_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = if_tok->line ();
@@ -2381,34 +2362,37 @@ octave_parser::finish_if_command (token 
     }
 
   return retval;
 }
 
 // Build an elseif clause.
 
 tree_if_clause *
-octave_parser::make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                                   tree_statement_list *list,
-                                   octave_comment_list *lc)
+octave_base_parser::make_elseif_clause (token *elseif_tok,
+                                        tree_expression *expr,
+                                        tree_statement_list *list,
+                                        octave_comment_list *lc)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   int l = elseif_tok->line ();
   int c = elseif_tok->column ();
 
   return new tree_if_clause (expr, list, lc, l, c);
 }
 
 // Finish a switch command.
 
 tree_switch_command *
-octave_parser::finish_switch_command (token *switch_tok, tree_expression *expr,
-                                      tree_switch_case_list *list,
-                                      token *end_tok, octave_comment_list *lc)
+octave_base_parser::finish_switch_command (token *switch_tok,
+                                           tree_expression *expr,
+                                           tree_switch_case_list *list,
+                                           token *end_tok,
+                                           octave_comment_list *lc)
 {
   tree_switch_command *retval = 0;
 
   if (end_token_ok (end_tok, token::switch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = switch_tok->line ();
@@ -2429,33 +2413,34 @@ octave_parser::finish_switch_command (to
     }
 
   return retval;
 }
 
 // Build a switch case.
 
 tree_switch_case *
-octave_parser::make_switch_case (token *case_tok, tree_expression *expr,
-                                 tree_statement_list *list,
-                                 octave_comment_list *lc)
+octave_base_parser::make_switch_case (token *case_tok,
+                                      tree_expression *expr,
+                                      tree_statement_list *list,
+                                      octave_comment_list *lc)
 {
   maybe_warn_variable_switch_label (expr);
 
   int l = case_tok->line ();
   int c = case_tok->column ();
 
   return new tree_switch_case (expr, list, lc, l, c);
 }
 
 // Build an assignment to a variable.
 
 tree_expression *
-octave_parser::make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-                               tree_expression *rhs)
+octave_base_parser::make_assign_op (int op, tree_argument_list *lhs,
+                                    token *eq_tok, tree_expression *rhs)
 {
   tree_expression *retval = 0;
 
   octave_value::assign_op t = octave_value::unknown_assign_op;
 
   switch (op)
     {
     case '=':
@@ -2540,44 +2525,44 @@ octave_parser::make_assign_op (int op, t
     bison_error ("computed multiple assignment not allowed");
 
   return retval;
 }
 
 // Define a script.
 
 void
-octave_parser::make_script (tree_statement_list *cmds,
-                            tree_statement *end_script)
+octave_base_parser::make_script (tree_statement_list *cmds,
+                                 tree_statement *end_script)
 {
   if (! cmds)
     cmds = new tree_statement_list ();
 
   cmds->append (end_script);
 
   octave_user_script *script
-    = new octave_user_script (curr_lexer->fcn_file_full_name,
-                              curr_lexer->fcn_file_name,
-                              cmds, curr_lexer->help_text);
-
-  curr_lexer->help_text = "";
+    = new octave_user_script (curr_lexer.fcn_file_full_name,
+                              curr_lexer.fcn_file_name,
+                              cmds, curr_lexer.help_text);
+
+  curr_lexer.help_text = "";
 
   octave_time now;
 
   script->stash_fcn_file_time (now);
 
   primary_fcn_ptr = script;
 }
 
 // Begin defining a function.
 
 octave_user_function *
-octave_parser::start_function (tree_parameter_list *param_list,
-                               tree_statement_list *body,
-                               tree_statement *end_fcn_stmt)
+octave_base_parser::start_function (tree_parameter_list *param_list,
+                                    tree_statement_list *body,
+                                    tree_statement *end_fcn_stmt)
 {
   // We'll fill in the return list later.
 
   if (! body)
     body = new tree_statement_list ();
 
   body->append (end_fcn_stmt);
 
@@ -2591,80 +2576,80 @@ octave_parser::start_function (tree_para
 
       fcn->stash_trailing_comment (tc);
     }
 
   return fcn;
 }
 
 tree_statement *
-octave_parser::make_end (const std::string& type, int l, int c)
+octave_base_parser::make_end (const std::string& type, int l, int c)
 {
   return make_statement (new tree_no_op_command (type, l, c));
 }
 
 // Do most of the work for defining a function.
 
 octave_user_function *
-octave_parser::frob_function (const std::string& fname,
-                              octave_user_function *fcn)
+octave_base_parser::frob_function (const std::string& fname,
+                                   octave_user_function *fcn)
 {
   std::string id_name = fname;
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
-  if (! autoloading && curr_lexer->reading_fcn_file
+  if (! autoloading && curr_lexer.reading_fcn_file
       && curr_fcn_depth == 1 && ! parsing_subfunctions)
   {
-    // FIXME -- should curr_lexer->fcn_file_name already be
+    // FIXME -- should curr_lexer.fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
     // problem with relative file names.
 
-    std::string nm = curr_lexer->fcn_file_name;
+    std::string nm = curr_lexer.fcn_file_name;
 
     size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
-      nm = curr_lexer->fcn_file_name.substr (pos+1);
+      nm = curr_lexer.fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
            "function name '%s' does not agree with function file name '%s'",
-           id_name.c_str (), curr_lexer->fcn_file_full_name.c_str ());
+           id_name.c_str (), curr_lexer.fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
-  if (curr_lexer->reading_fcn_file || curr_lexer->reading_classdef_file || autoloading)
+  if (curr_lexer.reading_fcn_file || curr_lexer.reading_classdef_file || autoloading)
     {
       octave_time now;
 
-      fcn->stash_fcn_file_name (curr_lexer->fcn_file_full_name);
+      fcn->stash_fcn_file_name (curr_lexer.fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
       if (curr_fcn_depth > 1 || parsing_subfunctions)
         {
-          fcn->stash_parent_fcn_name (curr_lexer->fcn_file_name);
+          fcn->stash_parent_fcn_name (curr_lexer.fcn_file_name);
 
           if (curr_fcn_depth > 1)
             fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
-      if (curr_lexer->parsing_class_method)
+      if (curr_lexer.parsing_class_method)
         {
           if (curr_class_name == id_name)
             fcn->mark_as_class_constructor ();
           else
             fcn->mark_as_class_method ();
 
           fcn->stash_dispatch_class (curr_class_name);
         }
@@ -2673,47 +2658,47 @@ octave_parser::frob_function (const std:
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
                          "time stamp for '%s' is in the future", nm.c_str ());
     }
   else if (! input_from_tmp_history_file
-           && ! curr_lexer->force_script
-           && curr_lexer->reading_script_file
-           && curr_lexer->fcn_file_name == id_name)
+           && ! curr_lexer.force_script
+           && curr_lexer.reading_script_file
+           && curr_lexer.fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
-               id_name.c_str (), curr_lexer->fcn_file_full_name.c_str ());
+               id_name.c_str (), curr_lexer.fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
-  fcn->stash_fcn_location (curr_lexer->input_line_number,
-                           curr_lexer->current_input_column);
-
-  if (! curr_lexer->help_text.empty () && curr_fcn_depth == 1
+  fcn->stash_fcn_location (curr_lexer.input_line_number,
+                           curr_lexer.current_input_column);
+
+  if (! curr_lexer.help_text.empty () && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     {
-      fcn->document (curr_lexer->help_text);
-
-      curr_lexer->help_text = "";
+      fcn->document (curr_lexer.help_text);
+
+      curr_lexer.help_text = "";
     }
 
-  if (curr_lexer->reading_fcn_file && curr_fcn_depth == 1
+  if (curr_lexer.reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
 
   return fcn;
 }
 
 tree_function_def *
-octave_parser::finish_function (tree_parameter_list *ret_list,
-                                octave_user_function *fcn,
-                                octave_comment_list *lc)
+octave_base_parser::finish_function (tree_parameter_list *ret_list,
+                                     octave_user_function *fcn,
+                                     octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
@@ -2746,17 +2731,17 @@ octave_parser::finish_function (tree_par
           else
             symbol_table::install_subfunction (nm, octave_value (fcn),
                                                primary_fcn_scope);
         }
 
       if (curr_fcn_depth == 1 && fcn)
         symbol_table::update_nest (fcn->scope ());
 
-      if (! curr_lexer->reading_fcn_file && curr_fcn_depth == 1)
+      if (! curr_lexer.reading_fcn_file && curr_fcn_depth == 1)
         {
           // We are either reading a script file or defining a function
           // at the command line, so this definition creates a
           // tree_function object that is placed in the parse tree.
           // Otherwise, it is just inserted in the symbol table,
           // either as a subfunction or nested function (see above),
           // or as the primary function for the file, via
           // primary_fcn_ptr (see also load_fcn_from_file,,
@@ -2766,41 +2751,42 @@ octave_parser::finish_function (tree_par
           retval = new tree_function_def (fcn);
         }
     }
 
   return retval;
 }
 
 void
-octave_parser::recover_from_parsing_function (void)
+octave_base_parser::recover_from_parsing_function (void)
 {
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
   parser_symtab_context.pop ();
 
-  if (curr_lexer->reading_fcn_file && curr_fcn_depth == 1
+  if (curr_lexer.reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     parsing_subfunctions = true;
 
   curr_fcn_depth--;
   function_scopes.pop_back ();
 
-  curr_lexer->defining_func--;
-  curr_lexer->parsed_function_name.pop ();
-  curr_lexer->looking_at_return_list = false;
-  curr_lexer->looking_at_parameter_list = false;
+  curr_lexer.defining_func--;
+  curr_lexer.parsed_function_name.pop ();
+  curr_lexer.looking_at_return_list = false;
+  curr_lexer.looking_at_parameter_list = false;
 }
 
 // Make an index expression.
 
 tree_index_expression *
-octave_parser::make_index_expression (tree_expression *expr,
-                                      tree_argument_list *args, char type)
+octave_base_parser::make_index_expression (tree_expression *expr,
+                                           tree_argument_list *args,
+                                           char type)
 {
   tree_index_expression *retval = 0;
 
   if (args && args->has_magic_tilde ())
     {
       bison_error ("invalid use of empty argument (~) in index expression");
       return retval;
     }
@@ -2822,18 +2808,18 @@ octave_parser::make_index_expression (tr
     retval = new tree_index_expression (expr, args, l, c, type);
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
 tree_index_expression *
-octave_parser::make_indirect_ref (tree_expression *expr,
-                                  const std::string& elt)
+octave_base_parser::make_indirect_ref (tree_expression *expr,
+                                       const std::string& elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (expr->is_index_expression ())
     {
@@ -2841,25 +2827,25 @@ octave_parser::make_indirect_ref (tree_e
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  curr_lexer->looking_at_indirect_ref = false;
+  curr_lexer.looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make an indirect reference expression with dynamic field name.
 
 tree_index_expression *
-octave_parser::make_indirect_ref (tree_expression *expr, tree_expression *elt)
+octave_base_parser::make_indirect_ref (tree_expression *expr, tree_expression *elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (expr->is_index_expression ())
     {
@@ -2867,26 +2853,26 @@ octave_parser::make_indirect_ref (tree_e
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  curr_lexer->looking_at_indirect_ref = false;
+  curr_lexer.looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make a declaration command.
 
 tree_decl_command *
-octave_parser::make_decl_command (int tok, token *tok_val,
-                                  tree_decl_init_list *lst)
+octave_base_parser::make_decl_command (int tok, token *tok_val,
+                                       tree_decl_init_list *lst)
 {
   tree_decl_command *retval = 0;
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   switch (tok)
     {
@@ -2894,34 +2880,34 @@ octave_parser::make_decl_command (int to
       retval = new tree_global_command (lst, l, c);
       break;
 
     case PERSISTENT:
       if (curr_fcn_depth > 0)
         retval = new tree_persistent_command (lst, l, c);
       else
         {
-          if (curr_lexer->reading_script_file)
+          if (curr_lexer.reading_script_file)
             warning ("ignoring persistent declaration near line %d of file '%s'",
-                     l, curr_lexer->fcn_file_full_name.c_str ());
+                     l, curr_lexer.fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
         }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 bool
-octave_parser::validate_array_list (tree_expression *e)
+octave_base_parser::validate_array_list (tree_expression *e)
 {
   bool retval = true;
 
   tree_array_list *al = dynamic_cast<tree_array_list *> (e);
 
   for (tree_array_list::iterator i = al->begin (); i != al->end (); i++)
     {
       tree_argument_list *row = *i;
@@ -2936,17 +2922,17 @@ octave_parser::validate_array_list (tree
           break;
         }
     }
 
   return retval;
 }
 
 tree_argument_list *
-octave_parser::validate_matrix_for_assignment (tree_expression *e)
+octave_base_parser::validate_matrix_for_assignment (tree_expression *e)
 {
   tree_argument_list *retval = 0;
 
   if (e->is_constant ())
     {
       octave_value ov = e->rvalue1 ();
 
       if (ov.is_empty ())
@@ -2990,17 +2976,17 @@ octave_parser::validate_matrix_for_assig
     }
 
   return retval;
 }
 
 // Finish building an array_list.
 
 tree_expression *
-octave_parser::finish_array_list (tree_array_list *array_list)
+octave_base_parser::finish_array_list (tree_array_list *array_list)
 {
   tree_expression *retval = array_list;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -3035,47 +3021,47 @@ octave_parser::finish_array_list (tree_a
     }
 
   return retval;
 }
 
 // Finish building a matrix list.
 
 tree_expression *
-octave_parser::finish_matrix (tree_matrix *m)
+octave_base_parser::finish_matrix (tree_matrix *m)
 {
   return finish_array_list (m);
 }
 
 // Finish building a cell list.
 
 tree_expression *
-octave_parser::finish_cell (tree_cell *c)
+octave_base_parser::finish_cell (tree_cell *c)
 {
   return finish_array_list (c);
 }
 
 void
-octave_parser::maybe_warn_missing_semi (tree_statement_list *t)
+octave_base_parser::maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (curr_fcn_depth > 0)
     {
       tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file '%s'",
-            tmp->line (), tmp->column (), curr_lexer->fcn_file_full_name.c_str ());
+            tmp->line (), tmp->column (), curr_lexer.fcn_file_full_name.c_str ());
     }
 }
 
 tree_statement_list *
-octave_parser::set_stmt_print_flag (tree_statement_list *list, char sep,
-                                    bool warn_missing_semi)
+octave_base_parser::set_stmt_print_flag (tree_statement_list *list,
+                                         char sep, bool warn_missing_semi)
 {
   tree_statement *tmp = list->back ();
 
   switch (sep)
     {
     case ';':
       tmp->set_print_flag (false);
       break;
@@ -3101,52 +3087,52 @@ octave_parser::set_stmt_print_flag (tree
       list->pop_back ();
       delete tmp;
     }
 
   return list;
 }
 
 tree_statement_list *
-octave_parser::make_statement_list (tree_statement *stmt)
+octave_base_parser::make_statement_list (tree_statement *stmt)
 {
   return new tree_statement_list (stmt);
 }
 
 tree_statement_list *
-octave_parser::append_statement_list (tree_statement_list *list, char sep,
-                                      tree_statement *stmt,
-                                      bool warn_missing_semi)
+octave_base_parser::append_statement_list (tree_statement_list *list,
+                                           char sep, tree_statement *stmt,
+                                           bool warn_missing_semi)
 {
   set_stmt_print_flag (list, sep, warn_missing_semi);
 
   list->append (stmt);
 
   return list;
 }
 
 void
-octave_parser::bison_error (const char *s)
+octave_base_parser::bison_error (const char *s)
 {
-  int err_col = curr_lexer->current_input_column - 1;
+  int err_col = curr_lexer.current_input_column - 1;
 
   std::ostringstream output_buf;
 
-  if (curr_lexer->reading_fcn_file || curr_lexer->reading_script_file || curr_lexer->reading_classdef_file)
-    output_buf << "parse error near line " << curr_lexer->input_line_number
-               << " of file " << curr_lexer->fcn_file_full_name;
+  if (curr_lexer.reading_fcn_file || curr_lexer.reading_script_file || curr_lexer.reading_classdef_file)
+    output_buf << "parse error near line " << curr_lexer.input_line_number
+               << " of file " << curr_lexer.fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
 
-  std::string curr_line = curr_lexer->current_input_line;
+  std::string curr_line = curr_lexer.current_input_line;
 
   if (! curr_line.empty ())
     {
       size_t len = curr_line.length ();
 
       if (curr_line[len-1] == '\n')
         curr_line.resize (len-1);
 
@@ -3165,16 +3151,22 @@ octave_parser::bison_error (const char *
 
   output_buf << "\n";
 
   std::string msg = output_buf.str ();
 
   parse_error ("%s", msg.c_str ());
 }
 
+int
+octave_parser::run (void)
+{
+  return octave_parse (*this);
+}
+
 static void
 safe_fclose (FILE *f)
 {
   // FIXME -- comments at the end of an input file are
   // discarded (otherwise, they would be appended to the next
   // statement, possibly from the command line or another file, which
   // can be quite confusing).
 
@@ -3211,31 +3203,31 @@ parse_fcn_file (const std::string& full_
 
   if (! full_file.empty ())
     ffile = gnulib::fopen (full_file.c_str (), "rb");
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
-      // octave_parser constructor sets this for us.
+      // octave_base_parser constructor sets this for us.
       frame.protect_var (CURR_LEXER);
 
       octave_parser curr_parser (ffile);
 
       curr_parser.curr_class_name = dispatch_type;
       curr_parser.autoloading = autoload;
       curr_parser.fcn_file_from_relative_lookup = relative_lookup;
 
-      curr_parser.curr_lexer->force_script = force_script;
-      curr_parser.curr_lexer->prep_for_file ();
-      curr_parser.curr_lexer->parsing_class_method = ! dispatch_type.empty ();
-
-      curr_parser.curr_lexer->fcn_file_name = file;
-      curr_parser.curr_lexer->fcn_file_full_name = full_file;
+      curr_parser.curr_lexer.force_script = force_script;
+      curr_parser.curr_lexer.prep_for_file ();
+      curr_parser.curr_lexer.parsing_class_method = ! dispatch_type.empty ();
+
+      curr_parser.curr_lexer.fcn_file_name = file;
+      curr_parser.curr_lexer.fcn_file_full_name = full_file;
 
       int status = curr_parser.run ();
 
       fcn_ptr = curr_parser.primary_fcn_ptr;
 
       if (status != 0)
         error ("parse error while reading file %s", full_file.c_str ());
     }
@@ -3907,17 +3899,17 @@ another function for the given type sign
 octave_value_list
 eval_string (const std::string& eval_str, bool silent,
              int& parse_status, int nargout)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
-  // octave_parser constructor sets this for us.
+  // octave_base_parser constructor sets this for us.
   frame.protect_var (CURR_LEXER);
 
   octave_parser curr_parser (eval_str);
 
   do
     {
       curr_parser.reset ();
 
@@ -3967,17 +3959,17 @@ eval_string (const std::string& eval_str
                 error ("eval: invalid use of statement list");
 
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
-          else if (curr_parser.curr_lexer->end_of_input)
+          else if (curr_parser.curr_lexer.end_of_input)
             break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -121,64 +121,38 @@ eval_string (const std::string&, bool si
 
 extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
 
 // Global access to currently active lexer.
 // FIXME -- to be removed after more parser+lexer refactoring.
 extern octave_lexer *CURR_LEXER;
 
 class
-octave_parser
+octave_base_parser
 {
 public:
 
-  octave_parser (void)
-    : endfunction_found (false),
-      autoloading (false), fcn_file_from_relative_lookup (false),
-      parsing_subfunctions (false), max_fcn_depth (0),
-      curr_fcn_depth (0), primary_fcn_scope (-1),
-      curr_class_name (), function_scopes (), primary_fcn_ptr (0),
-      stmt_list (0),
-      curr_lexer (new octave_lexer ()), parser_state (0)
-  {
-    init ();
-  }
-
-  octave_parser (FILE *file)
+  octave_base_parser (octave_lexer& lxr)
     : endfunction_found (false),
       autoloading (false), fcn_file_from_relative_lookup (false),
       parsing_subfunctions (false), max_fcn_depth (0),
       curr_fcn_depth (0), primary_fcn_scope (-1),
       curr_class_name (), function_scopes (), primary_fcn_ptr (0),
       stmt_list (0),
-      curr_lexer (new octave_lexer (file)), parser_state (0)
+      curr_lexer (lxr), parser_state (0)
   {
     init ();
   }
 
-  octave_parser (const std::string& eval_string)
-    : endfunction_found (false),
-      autoloading (false), fcn_file_from_relative_lookup (false),
-      parsing_subfunctions (false), max_fcn_depth (0),
-      curr_fcn_depth (0), primary_fcn_scope (-1),
-      curr_class_name (), function_scopes (), primary_fcn_ptr (0),
-      stmt_list (0),
-      curr_lexer (new octave_lexer (eval_string)), parser_state (0)
-  {
-    init ();
-  }
-
-  ~octave_parser (void);
+  virtual ~octave_base_parser (void);
 
   void init (void);
 
   void reset (void);
 
-  int run (void);
-
   // Error mesages for mismatched end tokens.
   void end_error (const char *type, token::end_tok_type ettype, int l, int c);
 
   // Check to see that end tokens are properly matched.
   bool end_token_ok (token *tok, token::end_tok_type expected);
 
   // Maybe print a warning if an assignment expression is used as the
   // test in a logical expression.
@@ -402,24 +376,51 @@ public:
 
   // Pointer to the primary user function or user script function.
   octave_function *primary_fcn_ptr;
 
   // Result of parsing input.
   tree_statement_list *stmt_list;
 
   // State of the lexer.
-  octave_lexer *curr_lexer;
+  octave_lexer& curr_lexer;
 
   // Internal state of the parser.  Only used if USE_PUSH_PARSER is
   // defined.
   void *parser_state;
 
-  // For unwind protect.
-  static void cleanup (octave_parser *parser) { delete parser; }
+private:
+
+  // No copying!
+
+  octave_base_parser (const octave_base_parser&);
+
+  octave_base_parser& operator = (const octave_base_parser&);
+};
+
+class
+octave_parser : public octave_base_parser
+{
+public:
+
+  octave_parser (void)
+    : octave_base_parser (*(new octave_lexer ()))
+  { }
+
+  octave_parser (FILE *file)
+    : octave_base_parser (*(new octave_lexer (file)))
+  { }
+
+  octave_parser (const std::string& eval_string)
+    : octave_base_parser (*(new octave_lexer (eval_string)))
+  { }
+
+  ~octave_parser (void) { }
+
+  int run (void);
 
 private:
 
   // No copying!
 
   octave_parser (const octave_parser&);
 
   octave_parser& operator = (const octave_parser&);
