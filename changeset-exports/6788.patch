# HG changeset patch
# User dbateman
# Date 1185228330 0
#      Mon Jul 23 22:05:30 2007 +0000
# Node ID c81a0f3f5a8266f0749190e4891884f32b9ca1db
# Parent  963a19576024c2b2d6d2d78b7b35160d954201a0
[project @ 2007-07-23 22:05:29 by dbateman]

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,12 +1,19 @@
 2007-07-23  David Bateman  <dbateman@free.fr>
 
 	* interpreter/Makefile.in (SUB_SOURCE): remove bit.txi.
-
+	* interpreter/io.txi: Document rat and rats in new sub-section.
+	* interpreter/plot.txi: New section for test functions. Document
+	peaks and meshc.
+	* interpreter/octave.texi: Add test plotting section.
+	* interpreter/image.txi: Document the functions autumn, bone,
+	cool, copper, hot, hsv, jet, pink, prism, rainbow, spring, 
+	summer, white and winter.
+	
 2007-07-19  David Bateman  <dbateman@free.fr>
 
 	* interpreter/bit.xi: Remove.
 	* interpreter/numbers.txi: Move here, and add examples.
 	* interpreter/octave.texi: Remove "Bit manipulation" chapter and make
 	it a sub-section of the "Numeric Data Types" chapter.
 
 2007-07-06  David Bateman  <dbateman@free.fr>
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -25,16 +25,18 @@ The following functions are available fo
 Each expects a single argument.  They are called @dfn{mapping functions}
 because when given a matrix argument, they apply the given function to
 each element of the matrix.
 
 @DOCSTRING(ceil)
 
 @DOCSTRING(cplxpair)
 
+@DOCSTRING(del2)
+
 @DOCSTRING(exp)
 
 @DOCSTRING(factor)
 
 @DOCSTRING(factorial)
 
 @DOCSTRING(fix)
 
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -101,20 +101,48 @@ between 0 and 1.
 @DOCSTRING(ind2gray)
 
 @DOCSTRING(rgb2ind)
 
 @DOCSTRING(ind2rgb)
 
 @DOCSTRING(colormap)
 
+@DOCSTRING(autumn)
+
+@DOCSTRING(bone)
+
+@DOCSTRING(cool)
+
+@DOCSTRING(copper)
+
 @DOCSTRING(gray)
 
+@DOCSTRING(hot)
+
+@DOCSTRING(hsv)
+
+@DOCSTRING(jet)
+
 @DOCSTRING(ocean)
 
+@DOCSTRING(pink)
+
+@DOCSTRING(prism)
+
+@DOCSTRING(rainbow)
+
+@DOCSTRING(spring)
+
+@DOCSTRING(summer)
+
+@DOCSTRING(white)
+
+@DOCSTRING(winter)
+
 @node Plotting on top of Images
 @section Plotting on top of Images
 
 If gnuplot is being used to display images it is possible to plot on
 top of images. Since an image is a matrix it is indexed by row and
 column values. The plotting system is, however, based on the 
 traditional @math{(x, y)} system. To minimize the difference between
 the two systems Octave places the origin of the coordinate system in
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -20,16 +20,17 @@ after the C standard library are also pr
 @section Basic Input and Output
 
 @c We could use a two-line introduction here...
 
 @menu
 * Terminal Output::             
 * Terminal Input::              
 * Simple File I/O::             
+* Rational Approximations::
 @end menu
 
 @node Terminal Output
 @subsection Terminal Output
 
 Since Octave normally prints the value of an expression as soon as it
 has been evaluated, the simplest of all I/O functions is a simple
 expression.  For example, the following expression will display the
@@ -208,16 +209,22 @@ functions.
 @DOCSTRING(sigterm_dumps_octave_core)
 
 @DOCSTRING(octave_core_file_options)
 
 @DOCSTRING(octave_core_file_limit)
 
 @DOCSTRING(octave_core_file_name)
 
+@node Rational Approximations
+@subsection Rational Approximations
+
+@DOCSTRING(rat)
+
+@DOCSTRING(rats)
 
 @node C-Style I/O Functions
 @section C-Style I/O Functions
 
 Octave's C-style input and output functions provide most of the
 functionality of the C programming language's standard I/O library.  The
 argument lists for some of the input functions are slightly different,
 however, because Octave has no way of passing arguments by reference.
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -375,16 +375,17 @@ C-Style I/O Functions
 Plotting
 
 * Two-Dimensional Plotting::    
 * Specialized Two-Dimensional Plots::  
 * Three-Dimensional Plotting::  
 * Plot Annotations::            
 * Multiple Plots on One Page::  
 * Multiple Plot Windows::       
+* Test Plotting Functions::
 * Interaction with gnuplot::    
 
 Matrix Manipulation
 
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
 * Applying a Function to an Array::
 * Special Utility Matrices::    
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -9,16 +9,17 @@
 * Two-Dimensional Plotting::    
 * Specialized Two-Dimensional Plots::  
 * Three-Dimensional Plotting::  
 * Manipulating Existing Plots::
 * Plot Annotations::            
 * Multiple Plots on One Page::  
 * Multiple Plot Windows::       
 * Printing Plots::
+* Test Plotting Functions::
 * Interaction with gnuplot::    
 @end menu
 
 @node Two-Dimensional Plotting
 @section Two-Dimensional Plotting
 
 The basic plotting commands are:
 
@@ -76,16 +77,18 @@ The basic plotting commands are:
 
 @node Three-Dimensional Plotting
 @section Three-Dimensional Plotting
 
 @DOCSTRING(plot3)
 
 @DOCSTRING(mesh)
 
+@DOCSTRING(meshc)
+
 @DOCSTRING(meshgrid)
 
 @DOCSTRING(ndgrid)
 
 @DOCSTRING(view)
 
 @node Manipulating Existing Plots
 @section Manipulating Existing Plots
@@ -137,14 +140,19 @@ The basic plotting commands are:
 
 @node Printing Plots
 @section Printing Plots
 
 @DOCSTRING(print)
 
 @DOCSTRING(orient)
 
+@node Test Plotting Functions
+@section Test Plotting Functions
+
+@DOCSTRING(peaks)
+
 @node Interaction with gnuplot
 @section Interaction with @code{gnuplot}
 
 @DOCSTRING(gnuplot_binary)
 
 @DOCSTRING(gnuplot_use_title_option)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,30 @@
+2007-07-23  David Bateman  <dbateman@free.fr>
+
+	* general/rat.m: New function for ration approximation imported
+	from octave-forge.
+	* general/del2.m: New function for discrete laplacian operator.
+	* general/Makefile.in: Include rat.m and del2.m  in SOURCES.
+
+	 * image/autumn.m image/bone.m image/cool.m image/copper.m 
+	image/hot.m image/hsv.m image/jet.m image/pink.m image/prism.m 
+	image/rainbow.m image/spring.m image/summer.m image/white.m 
+	image/winter.m, image/brighten.m: Port image functions from
+	octave-forge.
+	* image/Makefile.in: Add ported functions to SOURCES.
+	* image/gray.m, image/ocean.m: Don't set the colormap for
+	compatibility with matlab.
+	
+	* plot/meshc.m, plot/peaks.m: Port plotting function from
+	octave-forge
+	* plot/Makefile.in: Add ported functions to SOURCES.
+	* plot/__go_draw_axes__.m: Set the palette for the surfaces if
+	using gnuplot 4.2 or greater.
+	
 2007-07-23  Claudio Belotti <c.belotti@imperial.ac.uk>
 
 	* general/cart2sph.m: Fix unbalanced paranthesis.
 
 2007-07-19  David Bateman  <dbateman@free.fr>
 
 	* plot/fplot.m: More compatible version.
 
diff --git a/scripts/general/Makefile.in b/scripts/general/Makefile.in
--- a/scripts/general/Makefile.in
+++ b/scripts/general/Makefile.in
@@ -17,27 +17,27 @@ VPATH = @srcdir@
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 SOURCES = __isequal__.m __splinen__.m accumarray.m arrayfun.m bicubic.m \
   bitcmp.m bitget.m bitset.m blkdiag.m cart2pol.m cart2sph.m cell2mat.m \
-  circshift.m common_size.m cplxpair.m cumtrapz.m deal.m diff.m flipdim.m \
-  fliplr.m flipud.m gradient.m ind2sub.m int2str.m interp1.m \
+  circshift.m common_size.m cplxpair.m cumtrapz.m deal.m del2.m diff.m \
+  flipdim.m fliplr.m flipud.m gradient.m ind2sub.m int2str.m interp1.m \
   interp2.m interp3.m interpn.m interpft.m is_duplicate_entry.m isa.m \
   isdefinite.m isdir.m isequal.m isequalwithequalnans.m isscalar.m \
   issquare.m issymmetric.m isvector.m logical.m logspace.m lookup.m mod.m \
   nargchk.m nextpow2.m nthroot.m num2str.m perror.m pol2cart.m \
-  polyarea.m postpad.m prepad.m quadl.m randperm.m rem.m \
+  polyarea.m postpad.m prepad.m quadl.m randperm.m rat.m rem.m \
   repmat.m rot90.m rotdim.m shift.m shiftdim.m sortrows.m \
   sph2cart.m strerror.m sub2ind.m trapz.m tril.m triu.m
 
-DISTFILES = Makefile.in $(SOURCES)
+DISTFILES = $(addprefix $(srcdir)/,Makefile.in $(SOURCES))
 
 FCN_FILES = $(addprefix $(srcdir)/, $(SOURCES))
 FCN_FILES_NO_DIR = $(notdir $(FCN_FILES))
 
 all: PKG_ADD
 .PHONY: all
 
 install install-strip:
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
new file mode 100644
--- /dev/null
+++ b/scripts/general/del2.m
@@ -0,0 +1,156 @@
+## Copyright (C) 2000  Kai Habel
+## Copyright (C) 2007  David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{d} =} del2 (@var{m})
+## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{h})
+## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{dx}, @var{dy}, @dots{})
+##
+## Calculates the discrete Laplace operator. If @var{m} is a matrix this is
+## defined as
+##
+## @iftex
+## @tex
+## $d = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$
+## @end tex
+## @end iftex
+## @ifnottex
+## @example
+## @group
+##       1    / d^2            d^2         \
+## D  = --- * | ---  M(x,y) +  ---  M(x,y) | 
+##       4    \ dx^2           dy^2        /
+## @end group
+## @end example
+## @end ifnottex
+##
+## The above to continued to N-dimensional arrays calculating the second
+## derivative over the higher dimensions.
+##
+## The spacing between evaluation points may be defined by @var{h}, which is a
+## scalar defining the spacing in all dimensions. Or alternative, the spacing
+## in each dimension may be defined separately by @var{dx}, @var{dy}, etc. 
+## Scalar spacing values give equidistant spacing, whereas vector spacing 
+## values can be used to specify variable spacing. The length of the vectors
+## must match the respective dimension of @var{m}. The default spacing value
+## is 1.
+##
+## You need at least 3 data points for each dimension. Boundary points are
+## calculated as the linear extrapolation of the interior points.
+##
+## @seealso{gradient, diff}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function D = del2 (M, varargin)
+  
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  nd = ndims (M);
+  sz = size (M);
+  dx = cell (1, nd);
+  if (nargin == 2 || nargin == 1)
+    if (nargin == 1)
+      h = 1;
+    else
+      h = varargin{1}
+    endif
+    for i = 1 : nd
+      if (isscalar (h))
+	dx{i} = h * ones (sz (i), 1);
+      else
+	if (length (h) == sz (i))
+	  dx{i} = diff (h)(:);
+	else
+	  error ("dimensionality mismatch in %d-th spacing vector", i);
+	endif
+      endif
+    endfor
+  elseif (nargin - 1 == nd)
+    ## Reverse dx{1} and dx{2} as the X-dim is the 2nd dim of the ND array
+    tmp = varargin{1};
+    varargin{1} = varargin{2};
+    varargin{2} = tmp;
+
+    for i = 1 : nd
+      if (isscalar (varargin{i}))
+	dx{i} = varargin{i} * ones (sz (i), 1);
+      else
+	if (length (varargin{i}) == sz (i))
+	  dx{i} = diff (varargin{i})(:);
+	else
+	  error ("dimensionality mismatch in %d-th spacing vector", i);
+	endif
+      endif
+    endfor
+  else
+    print_usage ();
+  endif
+
+  idx = cell (1, nd);
+  for i = 1: nd
+    idx{i} = ":";
+  endfor
+
+  D = zeros (sz);
+  for i = 1: nd
+    if (sz(i) >= 3)
+      DD = zeros (sz);
+      idx1 = idx2 = idx3 = idx;
+
+      ## interior points
+      idx1{i} = 1 : sz(i) - 2;
+      idx2{i} = 2 : sz(i) - 1;
+      idx3{i} = 3 : sz(i);
+      szi = sz;
+      szi (i) = 1;
+
+      h1 = repmat (shiftdim (dx{i}(1 : sz(i) - 2), 1 - i), szi);
+      h2 = repmat (shiftdim (dx{i}(2 : sz(i) - 1), 1 - i), szi);
+      DD(idx2{:}) = ((M(idx1{:}) - M(idx2{:})) ./ h1 + ...
+		     (M(idx3{:}) - M(idx2{:})) ./ h2) ./ (h1 + h2);
+
+      ## left and right boundary
+      if (sz(i) == 3)
+	DD(idx1{:}) = DD(idx3{:}) = DD(idx2{:});
+      else
+	idx1{i} = 1;
+	idx2{i} = 2;
+	idx3{i} = 3;
+	DD(idx1{:}) = (dx{i}(1) + dx{i}(2)) / dx{i}(2) * DD (idx2{:}) - ...
+	    dx{i}(1) / dx{i}(2) * DD (idx3{:});
+
+	idx1{i} = sz(i);
+	idx2{i} = sz(i) - 1;
+	idx3{i} = sz(i) - 2;
+	DD(idx1{:}) =  (dx{i}(sz(i) - 1) + dx{i}(sz(i) - 2)) / ...
+	    dx{i}(sz(i) - 2) * DD (idx2{:}) - ...
+	    dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD (idx3{:});
+      endif
+
+      D += DD;
+    endif
+  endfor
+
+  D = D ./ nd;
+endfunction
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
new file mode 100644
--- /dev/null
+++ b/scripts/general/rat.m
@@ -0,0 +1,135 @@
+## Copyright (C) 2001 Paul Kienzle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{s} =} rat (@var{x}, @var{tol})
+## @deftypefnx {Function File} {[@var{n}, @var{d}] =} rat (@var{x}, @var{tol})
+##
+## Find a rational approximation to @var{x} within tolerance defined
+## by @var{tol} using a continued fraction expansion. E.g,
+##
+## @example
+##    rat(pi) = 3 + 1/(7 + 1/16) = 355/113
+##    rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7))))) = 1457/536
+## @end example
+##
+## Called with two arguments returns the numerator and deniminator seperately
+## as two matrices.
+## @end deftypefn
+## @seealso{rats}
+
+function [n,d] = rat(x,tol)
+
+  if (nargin != [1,2] || nargout > 2)
+    print_usage ();
+  endif
+
+  y = x(:);
+
+  ## replace inf with 0 while calculating ratios
+  y(isinf(y)) = 0;
+
+  ## default norm
+  if (nargin < 2)
+    tol = 1e-6 * norm(y,1);
+  endif
+
+  ## First step in the approximation is the integer portion
+  n = round(y);  # first element in the continued fraction
+  d = ones(size(y));
+  frac = y-n;
+  lastn = ones(size(y));
+  lastd = zeros(size(y));
+
+  nd = ndims(y);
+  nsz = prod (size (y));
+  steps = zeros([nsz, 0]);
+
+  ## grab new factors until all continued fractions converge
+  while (1)
+    ## determine which fractions have not yet converged
+    idx = find (abs(y-n./d) >= tol);
+    if (isempty(idx)) break; endif
+
+    ## grab the next step in the continued fraction
+    flip = 1./frac(idx);
+    step = round(flip); # next element in the continued fraction
+
+    if (nargout < 2)
+      tsteps = NaN .* ones (nsz, 1);
+      tsteps (idx) = step;
+      steps = [steps, tsteps];
+    endif
+
+    frac(idx) = flip-step;
+
+    ## update the numerator/denominator
+    nextn = n;
+    nextd = d;
+    n(idx) = n(idx).*step + lastn(idx);
+    d(idx) = d(idx).*step + lastd(idx);
+    lastn = nextn;
+    lastd = nextd;
+  endwhile
+
+  if (nargout == 2)
+    ## move the minus sign to the top
+    n = n.*sign(d);
+    d = abs(d);
+
+    ## return the same shape as you receive
+    n = reshape(n, size(x));
+    d = reshape(d, size(x));
+
+    ## use 1/0 for Inf
+    n(isinf(x)) = sign(x(isinf(x)));
+    d(isinf(x)) = 0;
+
+    ## reshape the output
+    n = reshape (n, size (x));
+    d = reshape (d, size (x));
+  else
+    n = "";
+    nsteps = size(steps, 2);
+    for i = 1: nsz
+      s = [int2str(y(i))," "];
+      j = 1;
+
+      while (true)
+	step = steps(i, j++);
+	if (isnan (step))
+	  break;
+	endif
+	if (j > nsteps || isnan (steps(i, j)))
+	  if (step < 0)
+	    s = [s(1:end-1), " + 1/(", int2str(step), ")"];
+	  else
+	    s = [s(1:end-1), " + 1/", int2str(step)];
+	  endif
+	  break;
+	else
+	  s = [s(1:end-1), " + 1/(", int2str(step), ")"];
+        endif
+      endwhile
+      s = [s, repmat(")", 1, j-2)];
+      n = cat (1, n, s);
+    endfor
+  endif
+
+endfunction
diff --git a/scripts/image/Makefile.in b/scripts/image/Makefile.in
--- a/scripts/image/Makefile.in
+++ b/scripts/image/Makefile.in
@@ -15,24 +15,25 @@ top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
-SOURCES = __img__.m __img_via_file__.m colormap.m gray.m gray2ind.m \
-  hsv2rgb.m image.m image_viewer.m imagesc.m imshow.m ind2gray.m \
-  ind2rgb.m loadimage.m ntsc2rgb.m ocean.m rgb2hsv.m rgb2ind.m \
-  rgb2ntsc.m saveimage.m
+SOURCES = __img__.m __img_via_file__.m autumn.m bone.m brighten.m colormap.m \
+  cool.m copper.m gray.m gray2ind.m hot.m hsv.m hsv2rgb.m image.m \
+  image_viewer.m imagesc.m imshow.m ind2gray.m ind2rgb.m jet.m loadimage.m \
+  ntsc2rgb.m ocean.m pink.m prism.m rainbow.m rgb2hsv.m rgb2ind.m \
+  rgb2ntsc.m saveimage.m spring.m summer.m white.m winter.m
 
 IMAGES = default.img
 
-DISTFILES = Makefile.in $(SOURCES) $(IMAGES)
+DISTFILES = $(addprefix $(srcdir)/,Makefile.in $(SOURCES))
 
 FCN_FILES = $(addprefix $(srcdir)/, $(SOURCES))
 FCN_FILES_NO_DIR = $(notdir $(FCN_FILES))
 
 IMAGE_FILES = $(wildcard $(srcdir)/*.img)
 IMAGE_FILES_NO_DIR = $(notdir $(IMAGE_FILES))
 
 all: PKG_ADD
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/autumn.m
@@ -0,0 +1,53 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} autumn (@var{n})
+## Create color colormap. This colormap is red through orange to yellow.
+## The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = autumn (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("autumn: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [1, 0, 0];  
+  elseif (number > 1)
+    r = ones (number, 1);
+    g = (0:number - 1)' ./ (number - 1);
+    b = zeros (number, 1);
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/bone.m
@@ -0,0 +1,56 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} bone (@var{n})
+## Create color colormap. This colormap is a gray colormap with a light 
+## blue tone. The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = bone (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("bone: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0, 0];  
+  elseif (number > 1)
+    x = linspace (0, 1, number)';
+
+    r = (x < 3/4) .* (7/8 * x) + (x >= 3/4) .* (11/8 * x - 3/8);
+    g = (x < 3/8) .* (7/8 * x)\
+      + (x >= 3/8 & x < 3/4) .* (29/24 * x - 1/8)\
+      + (x >= 3/4) .* (7/8 * x + 1/8);
+    b = (x < 3/8) .* (29/24 * x) + (x >= 3/8) .* (7/8 * x + 1/8);
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+endfunction
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/brighten.m
@@ -0,0 +1,75 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{map_out} =} brighten (@var{map}, @var{beta})
+## @deftypefn {Function File} {@var{map_out} =} brighten (@var{h}, @var{beta})
+## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{beta})
+## Darkens or brightens the given colormap. If the @var{map} argument 
+## is omitted, the function is applied to the current colormap. The first
+## argument can also be a valid graphics handle @var{h}, in which case 
+## @code{brighten} is applied to the colormap associated with this handle.
+##
+## Should the resulting colormap @var{map_out} not be assigned, it will be
+## written to the current colormap.
+##
+## The argument @var{beta} should be a scalar between -1 and 1,
+## where a negative value darkens and a positive value brightens
+## the colormap.
+## @seealso{colormap}
+## @end deftypefn
+
+function Rmap = brighten (m, beta)
+  h = -1;
+  if (nargin == 1)
+    beta = m;
+    m = colormap;
+    h = gcf ();
+  elseif (nargin == 2)
+    if (ishandle (m))
+      h = m;
+      m = get (h, "colormap");
+    elseif ((!is_matrix (m)) || (size (m, 2) != 3))
+      error ("First argument must be a matrix of size nx3 or a handle.");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if ( (!is_scalar (beta)) || (beta <= -1) || (beta >= 1) )
+    error ("brighten(...,beta) beta must be a scalar in the range (-1,1).");
+  endif
+
+  if (beta > 0)
+    gamma = 1 - beta;
+  else
+    gamma = 1 / (1 + beta);
+  endif
+
+  if (nargout == 0)
+    if (ishandle (h))
+      set (h, "colormap", m .^ gamma);
+    else
+      colormap (m .^ gamma);
+    endif
+  else
+    Rmap = m .^ gamma;
+  endif
+
+endfunction
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/cool.m
@@ -0,0 +1,53 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cool (@var{n})
+## Create color colormap. The colormap is cyan to magenta. The argument 
+## @var{n} should be a scalar.  If it is omitted, the length of the current
+## colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = cool (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("cool: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 1, 1];  
+  elseif (number > 1)
+    r = (0:number - 1)' ./ (number - 1);
+    g = 1 - r;
+    b = ones (number, 1);
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/copper.m
@@ -0,0 +1,54 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} copper (@var{n})
+## Create color colormap. This colormap is black to a light copper tone.
+## The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = copper (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("copper: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0, 0];  
+  elseif (number > 1)
+    x = linspace (0, 1, number)';
+    r = (x < 4/5) .* (5/4 * x) + (x >= 4/5);
+    g = 4/5 * x;
+    b = 1/2 * x;
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -33,11 +33,11 @@ function map = gray (number)
   if (nargin == 0)
     number = 64;
   elseif (nargin > 1)
     print_usage ();
   endif
 
   gr = [0:(number-1)]';
 
-  map = colormap ([ gr, gr, gr ] / (number - 1));
+  map = [ gr, gr, gr ] / (number - 1);
 
 endfunction
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/hot.m
@@ -0,0 +1,54 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} hot (@var{n})
+## Create color colormap. This colormap is black through dark red, red, 
+## orange, yellow to white. The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = hot (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1) 
+	if (! is_scalar (number))
+      error ("hot: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0, 0];  
+  elseif (number > 1)
+    x = linspace (0, 1, number)';
+    r = (x < 2/5) .* (5/2 * x) + (x >= 2/5);
+    g = (x >= 2/5 & x < 4/5) .* (5/2 * x - 1) + (x >= 4/5);
+    b = (x >= 4/5) .* (5*x - 4);
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/hsv.m
@@ -0,0 +1,51 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} hsv (@var{n})
+## Create color colormap. This colormap is red through yellow, green, cyan,
+## blue, magenta to red. The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = hsv (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("hsv: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [1, 0, 0];  
+  elseif (number > 1)
+    h = linspace (0, 1, number)';
+    map = hsv2rgb ([h, ones(number, 1), ones(number, 1)]);
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/jet.m
@@ -0,0 +1,57 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} jet (@var{n})
+## Create color colormap. This colormap is dark blue through blue, cyan, 
+## green, yellow, red to dark red. The argument @var{n} should be a scalar. 
+## If it is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = jet (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("jet: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0, 0.5];  
+  elseif (number > 1)
+    x = linspace(0, 1, number)';
+    r = (x >= 3/8 & x < 5/8) .* (4 * x - 3/2)\
+      + (x >= 5/8 & x < 7/8) + (x >= 7/8) .* (-4 * x + 9/2);
+    g = (x >= 1/8 & x < 3/8) .* (4 * x - 1/2)\
+      + (x >= 3/8 & x < 5/8) + (x >= 5/8 & x < 7/8) .* (-4 * x + 7/2);
+    b = (x < 1/8) .* (4 * x + 1/2) + (x >= 1/8 & x < 3/8)\
+      + (x >= 3/8 & x < 5/8) .* (-4 * x + 5/2);
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -46,11 +46,11 @@ function map = ocean (number)
   r = prepad ([0:dr:(number-1)], number)';
 
   dg = (number - 1) / (2 * cutin);
 
   g = prepad([0:dg:(number-1)], number)';
 
   b = [0:(number-1)]';
 
-  map = colormap ([ r, g, b ] / (number - 1));
+  map = [ r, g, b ] / (number - 1);
 
 endfunction
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/pink.m
@@ -0,0 +1,57 @@
+## Copyright (C) 2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} pink (@var{n})
+## Create color colormap. This colormap gives a sephia tone on black and
+## white images. The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = pink (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("pink: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0, 0];  
+  elseif (number > 1)
+    x = linspace (0, 1, number)';
+    r = (x < 3/8) .* (14/9 * x) + (x >= 3/8) .* (2/3 * x + 1/3);
+    g = (x < 3/8) .* (2/3 * x)\
+      + (x >= 3/8 & x < 3/4) .* (14/9 * x - 1/3)\
+      + (x >= 3/4) .* (2/3 * x + 1/3);
+    b = (x < 3/4) .* (2/3 * x) + (x >= 3/4) .* (2 * x - 1);
+
+    map = sqrt ([r, g, b]);
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/prism.m
@@ -0,0 +1,50 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} prism (@var{n})
+## Create color colormap. This colormap cycles trough red, orange, yellow,
+## green, blue and violet. The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = prism (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("prism: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  p = [1, 0, 0; 1, 1/2, 0; 1, 1, 0; 0, 1, 0; 0, 0, 1; 2/3, 0, 1];
+
+  if (rem (number, 6) == 0)
+    map = kron(ones (fix (number / 6), 1), p);
+  else
+    map = [kron(ones (fix (number / 6), 1), p); p(1:rem (number, 6), :)];
+  endif
+
+endfunction
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/rainbow.m
@@ -0,0 +1,58 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} rainbow (@var{n})
+## Create color colormap. This colormap is red through orange, yellow, green, 
+## blue to violet. The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = rainbow (number)
+## this colormap is not part of matlab, it is like the prism
+## colormap map but with a continuous map
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("rainbow: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [1, 0, 0];  
+  elseif (number > 1)
+    x = linspace (0, 1, number)';
+    r = (x < 2/5) + (x >= 2/5 & x < 3/5) .* (-5 * x + 3)\
+      + (x >= 4/5) .* (10/3 * x - 8/3);
+    g = (x < 2/5) .* (5/2 * x) + (x >= 2/5 & x < 3/5)\
+      + (x >= 3/5 & x < 4/5) .* (-5 * x + 4);
+    b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/spring.m
@@ -0,0 +1,53 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} spring (@var{n})
+## Create color colormap. This colormap is magenta to yellow.
+## The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = spring (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("spring: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [1, 0, 1];  
+  elseif (number > 1)
+    r = ones (number, 1);
+    g = (0:number - 1)' ./ (number - 1);
+    b = 1 - g;
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/summer.m
@@ -0,0 +1,54 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} summer (@var{n})
+## Create color colormap. This colormap is green to yellow.
+## The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+## Date:  06/03/2000
+function map = summer (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("summer: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0.5, 0.4];  
+  elseif (number > 1)
+    r = (0:number - 1)' ./ (number - 1);
+    g = 0.5 + r ./ 2;
+    b = 0.4 * ones (number, 1);
+
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/white.m b/scripts/image/white.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/white.m
@@ -0,0 +1,48 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} white (@var{n})
+## Create color colormap.  This colormap is completely white.
+## The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = white (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("white: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number > 0)
+    map = ones (number, 3);
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/winter.m
@@ -0,0 +1,54 @@
+## Copyright (C) 1999,2000  Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} winter (@var{n})
+## Create color colormap. This colormap is blue to green.
+## The argument @var{n} should be a scalar.  If it
+## is omitted, the length of the current colormap or 64 is assumed.
+## @seealso{colormap}
+## @end deftypefn
+
+## Author:  Kai Habel <kai.habel@gmx.de>
+
+function map = winter (number)
+
+  if (nargin == 0)
+    number = rows (colormap);
+  elseif (nargin == 1)
+    if (! is_scalar (number))
+      error ("winter: argument must be a scalar");
+    endif
+  else
+    print_usage ();
+  endif
+
+  if (number == 1)
+    map = [0, 0, 1];  
+  elseif (number > 1)
+    r = zeros (number, 1);
+    g = (0:number - 1)' ./ (number - 1);
+    b = 1 - g ./ 2;
+
+    map = [r, g, b];
+  else
+    map = [];
+  endif
+
+endfunction
diff --git a/scripts/plot/Makefile.in b/scripts/plot/Makefile.in
--- a/scripts/plot/Makefile.in
+++ b/scripts/plot/Makefile.in
@@ -67,20 +67,22 @@ SOURCES = \
   hold.m \
   isfigure.m \
   ishold.m \
   legend.m \
   line.m \
   loglog.m \
   loglogerr.m \
   mesh.m \
+  meshc.m \
   meshgrid.m \
   ndgrid.m \
   newplot.m \
   orient.m \
+  peaks.m \
   plot.m \
   plot3.m \
   polar.m \
   print.m \
   replot.m \
   semilogx.m \
   semilogxerr.m \
   semilogy.m \
@@ -92,17 +94,17 @@ SOURCES = \
   subplot.m \
   text.m \
   title.m \
   view.m \
   xlabel.m \
   ylabel.m \
   zlabel.m
 
-DISTFILES = Makefile.in include-globals.awk $(SOURCES)
+DISTFILES = $(addprefix $(srcdir)/,Makefile.in $(SOURCES))
 
 FCN_FILES = $(addprefix $(srcdir)/, $(SOURCES))
 FCN_FILES_NO_DIR = $(notdir $(FCN_FILES))
 
 all: PKG_ADD
 .PHONY: all
 
 install install-strip:
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -477,17 +477,30 @@ function __go_draw_axes__ (h, plot_strea
 	  usingclause{data_idx} = "using ($1):($2):($3)";
 	  withclause{data_idx} = "with line palette";
 
 	  fputs (plot_stream, "unset parametric;\n");
 	  fputs (plot_stream, "set hidden3d;\n");
 	  fputs (plot_stream, "set style data lines;\n");
 	  fputs (plot_stream, "set surface;\n");
 	  fputs (plot_stream, "unset contour;\n");
-	  fputs (plot_stream, "set palette defined (0 \"dark-blue\", 1 \"blue\", 2 \"cyan\", 3 \"yellow\", 4 \"red\" , 5 \"dark-red\");\n");
+
+	  if (have_newer_gnuplot)
+	    surf_colormap = parent_figure_obj.colormap;
+	    palette_size = rows (surf_colormap);
+	    fprintf (plot_stream,
+		     "set palette positive color model RGB maxcolors %i;\n",
+		     palette_size);
+	    fprintf (plot_stream,
+		     "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
+		     palette_size);
+	    fwrite (plot_stream, [1:palette_size; surf_colormap'], "float32");
+	  else
+	    fputs (plot_stream, "set palette defined (0 \"dark-blue\", 1 \"blue\", 2 \"cyan\", 3 \"yellow\", 4 \"red\" , 5 \"dark-red\");\n");
+	  endif
 	  fputs (plot_stream, "unset colorbox;\n");
 
 	case "text"
 	  lpos = obj.position;
 	  label = obj.string;
 	  halign = obj.horizontalalignment;
 	  angle = obj.rotation;
           units = obj.units;
diff --git a/scripts/plot/meshc.m b/scripts/plot/meshc.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/meshc.m
@@ -0,0 +1,109 @@
+## Copyright (C) 1996, 1997 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} meshc (@var{x}, @var{y}, @var{z})
+## Plot a mesh and contour given matrices @var{x}, and @var{y} from 
+## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and 
+## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors, 
+## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
+## columns of @var{z} correspond to different @var{x} values and rows of 
+## @var{z} correspond to different @var{y} values.
+## @seealso{meshgrid, mesh, contour}
+## @end deftypefn
+
+function h = meshc (varargin)
+
+  newplot ();
+
+  if (nargin == 1)
+    z = varargin{1};
+    if (ismatrix (z))
+      [nr, nc] = size (z);
+      x = 1:nc;
+      y = (1:nr)';
+    else
+      error ("meshc: argument must be a matrix");
+    endif
+  elseif (nargin == 3)
+    x = varargin{1};
+    y = varargin{2};
+    z = varargin{3};
+
+    if (isvector (x) && isvector (y) && ismatrix (z))
+      if (rows (z) == length (y) && columns (z) == length (x))
+        x = x(:)';
+        y = y(:);
+      else
+        msg = "meshc: rows (z) must be the same as length (y) and";
+        msg = sprintf ("%s\ncolumns (z) must be the same as length (x)", msg);
+        error (msg);
+      endif
+    elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
+      if (! (size_equal (x, y) && size_equal (x, z)))
+        error ("meshc: x, y, and z must have same dimensions");
+      endif
+    else
+      error ("meshc: x and y must be vectors and z must be a matrix");
+    endif
+  else
+    print_usage ();
+  endif
+
+  ## make a default line object, and make it the current axes for the
+  ## current figure.
+  ca = gca ();
+
+  tmp = __go_surface__ (ca, "xdata", x, "ydata", y, "zdata", z);
+
+  set (ca, "view", [-37.5, 30]);
+
+  hold on;
+
+  [c, lev] = contourc (varargin{:});
+
+  cmap = get (gcf(), "colormap");
+  
+  levx = linspace (min (lev), max (lev), size (cmap, 1));
+
+  drawnow();
+  ax = axis();
+  zmin = 2 * ax(5) - ax(6);
+
+  ## decode contourc output format
+  i1 = 1;
+  while (i1 < length (c))
+
+    clev = c(1,i1);
+    clen = c(2,i1);
+
+    ccr = interp1 (levx, cmap(:,1), clev);
+    ccg = interp1 (levx, cmap(:,2), clev);
+    ccb = interp1 (levx, cmap(:,3), clev);
+
+    ii = i1+1:i1+clen;
+    line (c(1,ii), c(2,ii), zmin*ones(size(ii)), "color", [ccr, ccg, ccb]);
+
+    i1 += c(2,i1)+1;
+  endwhile
+  
+  if (nargout > 0)
+    h = tmp;
+  endif
+endfunction
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/peaks.m
@@ -0,0 +1,88 @@
+## Copyright (C) 2007  Paul Kienzle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} peaks ()
+## @deftypefnx {Function File} {} peaks (@var{n})
+## @deftypefnx {Function File} {} peaks (@var{x}, @var{y})
+## @deftypefnx {Function File} {@var{z} =} peaks (@dots{})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} peaks (@dots{})
+## Generate a function with lots of local maxima and minima. The function
+## has the form
+##
+## @iftex
+## @tex
+## $f(x,y) = 3 (1 - x) ^ 2 e ^ {\left(-x^2 - (y+1)^2\right)} - 10 \left({x \over 5} - x^3 - y^5)\right) - {1 \over 3} e^{\left(-(x+1)^2 - y^2\right)}$
+## @end tex
+## @end iftex
+## @ifnottex
+## @verbatim
+## f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
+##          - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
+##          - 1/3*exp(-(x+1)^2 - y^2)
+## @end verbatim
+## @end ifnottex
+##
+## Called without a return argument, @code{peaks} plots the surface of the 
+## above function using @code{mesh}. If @var{n} is a scalar, the @code{peaks}
+## returns the values of the above funxtion on a @var{n}-by-@var{n} mesh over
+## the range @code{[-3,3]}. The default value for @var{n} is 49.
+##
+## If @var{n} is a vector, then it represents the @var{x} and @var{y} values
+## of the grid on which to calculate the above function. The @var{x} and 
+## @var{y} values can be specified separately.
+## @seealso{mesh}
+## @end deftypefn
+
+## Expression for peaks function was taken from the following paper:
+##   http://www.control.hut.fi/Kurssit/AS-74.115/Material/GENALGgoga.pdf
+function [X_out, Y_out, Z_out] = peaks (x, y)
+
+  if nargin == 0
+    x = y = linspace(-3,3,49);
+  elseif nargin == 1
+    if length(x) > 1
+      y = x;
+    else
+      x = y = linspace(-3,3,x);
+    endif
+  endif
+
+  if (isvector(x) && isvector(y))
+    [X, Y] = meshgrid (x, y);
+  else
+    X = x;
+    Y = y;
+  endif
+
+  Z = 3 * (1 - X) .^ 2 .* exp(- X .^ 2 - (Y + 1) .^ 2) \
+      - 10 * (X / 5 - X .^ 3 - Y .^ 5) .* exp(- X .^ 2 - Y .^ 2) \
+      - 1 / 3 * exp(- (X + 1) .^ 2 - Y .^ 2);
+
+  if nargout == 0
+    mesh (x, y, Z);
+  elseif nargout == 1
+    X_out = Z;
+  else
+    X_out = X;
+    Y_out = Y;
+    Z_out = Z;
+  endif
+
+endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,24 @@
+2007-07-23  David Bateman  <dbateman@free.fr>
+
+	* pr-output.cc (rat_format, rat_string_len): Global variable
+	controlling behavior of rational approximation. Use throughout.
+	(class pr_rational_float): New class for rational approximation of
+	floats, specifically with the << operator defined.
+	(std::ostream& operator << (std::ostream&, const
+	pr_rational_float&)): Operator to print rational approximations of
+	double values.
+	(std::string rational_approx (double, int)): Function to convert a
+	double value to a string of maximum length giving the rational
+	approximation.
+	(pr_any_float): Include the output of rational approximations.
+	(Fformat): Add the "rat" format as an option.
+	(Frats): New function.
+
 2007-07-23  Aquil H. Abdullah  <aquil.abdullah@gmail.com>
 
 	* mex.cc (mxCreateStructArray): Declare second arg as const.
 	* mexproto.h (mxCreateStructArray): Ditto.
 
 2007-07-20  David Bateman  <dbateman@free.fr>
 
         * zfstream.cc (BUFSIZE): Increase default buffer size to 256kB
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -85,16 +85,22 @@ int Vstruct_levels_to_print = 2;
 static bool free_format = false;
 
 // TRUE means print plus sign for nonzero, blank for zero.
 static bool plus_format = false;
 
 // First char for > 0, second for < 0, third for == 0.
 static std::string plus_format_chars = "+  ";
 
+// TRUE means always print in a rational approximation
+static bool rat_format = false;
+
+// Used to force the length of the rational approximation string for Frats
+static int rat_string_len = -1;
+
 // TRUE means always print like dollars and cents.
 static bool bank_format = false;
 
 // TRUE means print data in hexadecimal format.
 static int hex_format = 0;
 
 // TRUE means print data in binary-bit-pattern format.
 static int bit_format = 0;
@@ -107,16 +113,17 @@ static bool print_e = false;
 
 // TRUE means use a g format.
 static bool print_g = false;
 
 // TRUE means print E instead of e for exponent field.
 static bool print_big_e = false;
 
 class pr_formatted_float;
+class pr_rational_float;
 
 static int
 current_output_max_field_width (void)
 {
   return Voutput_max_field_width;
 }
 
 static int
@@ -165,16 +172,19 @@ public:
   float_format& width (int w) { fw = w; return *this; }
 
   float_format& trailing_zeros (bool tz = true)
     { sp = tz ? std::ios::showpoint : 0; return *this; }
 
   friend std::ostream& operator << (std::ostream& os,
 				    const pr_formatted_float& pff);
 
+  friend std::ostream& operator << (std::ostream& os,
+				    const pr_rational_float& pff);
+
 private:
 
   // Field width.  Zero means as wide as necessary.
   int fw;
 
   // Precision.
   int prec;
 
@@ -216,16 +226,141 @@ operator << (std::ostream& os, const pr_
 
   os << pff.val;
 
   os.flags (oflags);
 
   return os;
 }
 
+static inline std::string
+rational_approx (double val, int len)
+{
+  std::string s;
+
+  if (len <= 0)
+    len = 10;
+
+  if (xisinf (val))
+    s = "1/0";
+  else if (xisnan (val))
+    s = "0/0";
+  else if (val < INT_MIN || val > INT_MAX || D_NINT (val) == val)
+    {
+      std::ostringstream buf;
+      buf.flags (std::ios::fixed);
+      buf << std::setprecision (0) << xround(val);
+      s = buf.str ();
+    }
+  else
+    {
+      double lastn = 1.;
+      double lastd = 0.;
+      double n = xround (val);
+      double d = 1.;
+      double frac = val - n;
+      int m = 0;
+
+      std::ostringstream buf2;
+      buf2.flags (std::ios::fixed);
+      buf2 << std::setprecision (0) << static_cast<int>(n); 
+      s = buf2.str();
+
+      while (1)
+	{
+	  double flip = 1. / frac;
+	  double step = xround (flip);
+	  double nextn = n;
+	  double nextd = d;
+	  frac = flip - step;
+	  n = n * step + lastn;
+	  d = d * step + lastd;
+	  lastn = nextn;
+	  lastd = nextd;
+
+	  std::ostringstream buf;
+	  buf.flags (std::ios::fixed);
+	  buf << std::setprecision (0) << static_cast<int>(n) 
+	      << "/" << static_cast<int>(d);
+	  m++;
+
+	  if (n < 0 && d < 0)
+	    {
+	      // Double negative, string can be two characters longer..
+	      if (buf.str().length() > static_cast<unsigned int>(len + 2) && 
+		  m > 1) 
+		break;
+	    }
+	  else if (buf.str().length() > static_cast<unsigned int>(len) && 
+		   m > 1) 
+	    break;
+
+	  s = buf.str();
+
+	  // Have we converged to 1/intmax ?
+	  if (m > 100 || fabs (frac) < 1 / static_cast<double>(INT_MAX))
+	    {
+	      lastn = n;
+	      lastd = d;
+	      break;
+	    }
+	}
+
+      if (lastd < 0.)
+	{
+	  // Move sign to the top
+	  lastd = - lastd;
+	  lastn = - lastn;
+	  std::ostringstream buf;
+	  buf.flags (std::ios::fixed);
+	  buf << std::setprecision (0) << static_cast<int>(lastn) 
+	       << "/" << static_cast<int>(lastd);
+	  s = buf.str();
+	}
+    }
+
+  return s;
+}
+
+class
+pr_rational_float
+{
+public:
+
+  const float_format& f;
+
+  double val;
+
+  pr_rational_float (const float_format& f_arg, double val_arg)
+    : f (f_arg), val (val_arg) { }
+};
+
+std::ostream&
+operator << (std::ostream& os, const pr_rational_float& prf)
+{
+  int fw = (rat_string_len > 0 ? rat_string_len : prf.f.fw);
+  std::string s = rational_approx (prf.val, fw);
+
+  if (fw >= 0)
+    os << std::setw (fw);
+
+  std::ios::fmtflags oflags = 
+    os.flags (static_cast<std::ios::fmtflags> 
+              (prf.f.fmt | prf.f.up | prf.f.sp));
+
+  if (fw > 0 && s.length() > static_cast<unsigned int>(fw))
+    os << "*";
+  else
+    os << s;
+
+  os.flags (oflags);
+
+  return os;
+}
+
 // Current format for real numbers and the real part of complex
 // numbers.
 static float_format *curr_real_fmt = 0;
 
 // Current format for the imaginary part of complex numbers.
 static float_format *curr_imag_fmt = 0;
 
 static double
@@ -294,17 +429,22 @@ set_real_format (bool sign, int digits, 
 		 int &fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
-  if (bank_format)
+  if (rat_format)
+    {
+      fw = 0;
+      rd = 0;
+    }
+  else if (bank_format)
     {
       fw = digits < 0 ? 4 : digits + 3;
       if (inf_or_nan && fw < 4)
 	fw = 4;
       rd = 2;
     }
   else if (hex_format)
     {
@@ -338,17 +478,17 @@ set_real_format (bool sign, int digits, 
 	  digits = -digits + 1;
 	}
 
       fw = 1 + ld + 1 + rd;
       if (inf_or_nan && fw < 4)
 	fw = 4;
     }
 
-  if (! (bank_format || hex_format || bit_format)
+  if (! (rat_format || bank_format || hex_format || bit_format)
       && (fw > Voutput_max_field_width || print_e || print_g))
     {
       if (print_g)
 	fmt = float_format ();
       else
 	{
 	  int exp_field = 4;
 	  if (digits > 100)
@@ -407,17 +547,22 @@ set_real_matrix_format (bool sign, int x
 			bool inf_or_nan, int int_or_inf_or_nan, int& fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
-  if (bank_format)
+  if (rat_format)
+    {
+      fw = 9;
+      rd = 0;
+    }
+  else if (bank_format)
     {
       int digits = x_max > x_min ? x_max : x_min;
       fw = digits <= 0 ? 4 : digits + 3;
       if (inf_or_nan && fw < 4)
 	fw = 4;
       rd = 2;
     }
   else if (hex_format)
@@ -478,17 +623,17 @@ set_real_matrix_format (bool sign, int x
       ld = ld_max > ld_min ? ld_max : ld_min;
       rd = rd_max > rd_min ? rd_max : rd_min;
 
       fw = 1 + ld + 1 + rd;
       if (inf_or_nan && fw < 4)
 	fw = 4;
     }
 
-  if (! (bank_format || hex_format || bit_format)
+  if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
 	  || print_g
 	  || (! Vfixed_point_format && fw > Voutput_max_field_width)))
     {
       if (print_g)
 	fmt = float_format ();
       else
 	{
@@ -559,17 +704,23 @@ set_complex_format (bool sign, int x_max
 {
   static float_format r_fmt;
   static float_format i_fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
-  if (bank_format)
+  if (rat_format)
+    {
+      i_fw = 0;
+      r_fw = 0;
+      rd = 0;
+    }
+  else if (bank_format)
     {
       int digits = r_x;
       i_fw = 0;
       r_fw = digits <= 0 ? 4 : digits + 3;
       if (inf_or_nan && r_fw < 4)
 	r_fw = 4;
       rd = 2;
     }
@@ -634,17 +785,17 @@ set_complex_format (bool sign, int x_max
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
 	{
 	  i_fw = 3;
 	  r_fw = 4;
 	}
     }
 
-  if (! (bank_format || hex_format || bit_format)
+  if (! (rat_format || bank_format || hex_format || bit_format)
       && (r_fw > Voutput_max_field_width || print_e || print_g))
     {
       if (print_g)
 	{
 	  r_fmt = float_format ();
 	  i_fmt = float_format ();
 	}
       else
@@ -744,17 +895,23 @@ set_complex_matrix_format (bool sign, in
 {
   static float_format r_fmt;
   static float_format i_fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
-  if (bank_format)
+  if (rat_format)
+    {
+      i_fw = 9;
+      r_fw = 9;
+      rd = 0;
+    }
+  else if (bank_format)
     {
       int digits = r_x_max > r_x_min ? r_x_max : r_x_min;
       i_fw = 0;
       r_fw = digits <= 0 ? 4 : digits + 3;
       if (inf_or_nan && r_fw < 4)
 	r_fw = 4;
       rd = 2;
     }
@@ -830,17 +987,17 @@ set_complex_matrix_format (bool sign, in
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
 	{
 	  i_fw = 3;
 	  r_fw = 4;
 	}
     }
 
-  if (! (bank_format || hex_format || bit_format)
+  if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
 	  || print_g
 	  || (! Vfixed_point_format && r_fw > Voutput_max_field_width)))
     {
       if (print_g)
 	{
 	  r_fmt = float_format ();
 	  i_fmt = float_format ();
@@ -944,17 +1101,22 @@ static void
 set_range_format (bool sign, int x_max, int x_min, int all_ints, int& fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
-  if (bank_format)
+  if (rat_format)
+    {
+      fw = 9;
+      rd = 0;
+    }
+  else if (bank_format)
     {
       int digits = x_max > x_min ? x_max : x_min;
       fw = sign + digits < 0 ? 4 : digits + 3;
       rd = 2;
     }
   else if (hex_format)
     {
       fw = 2 * sizeof (double);
@@ -1007,17 +1169,17 @@ set_range_format (bool sign, int x_max, 
 	}
 
       ld = ld_max > ld_min ? ld_max : ld_min;
       rd = rd_max > rd_min ? rd_max : rd_min;
 
       fw = sign + 1 + ld + 1 + rd;
     }
 
-  if (! (bank_format || hex_format || bit_format)
+  if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
 	  || print_g
 	  || (! Vfixed_point_format && fw > Voutput_max_field_width)))
     {
       if (print_g)
 	fmt = float_format ();
       else
 	{
@@ -1206,36 +1368,38 @@ pr_any_float (const float_format *fmt, s
 		}
 	      else
 		{
 		  for (int i = sizeof (double) - 1; i >= 0; i--)
 		    PRINT_CHAR_BITS (os, tmp.i[i]);
 		}
 	    }
 	}
+      else if (octave_is_NA (d))
+	{
+	  if (fw > 0)
+	    os << std::setw (fw) << "NA";
+	  else
+	    os << "NA";
+	}
+      else if (rat_format)
+	os << pr_rational_float (*fmt, d);
       else if (xisinf (d))
 	{
 	  const char *s;
 	  if (d < 0.0)
 	    s = "-Inf";
 	  else
 	    s = "Inf";
 
 	  if (fw > 0)
 	    os << std::setw (fw) << s;
 	  else
 	    os << s;
 	}
-      else if (octave_is_NA (d))
-	{
-	  if (fw > 0)
-	    os << std::setw (fw) << "NA";
-	  else
-	    os << "NA";
-	}
       else if (xisnan (d))
 	{
 	  if (fw > 0)
 	    os << std::setw (fw) << "NaN";
 	  else
 	    os << "NaN";
 	}
       else
@@ -1690,17 +1854,18 @@ octave_print_internal (std::ostream& os,
 	}
     }
   else
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (cm, r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
-      column_width += (bank_format || hex_format|| bit_format) ? 2 : 7;
+      column_width += (rat_format || bank_format || hex_format 
+		       || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
 	max_width -= 4;
       else
 	max_width -= extra_indent;
 
@@ -2358,17 +2523,17 @@ octave_print_internal (std::ostream& os,
 
 	      if (! isneg)
 	      isneg = (abs (nda(i).value ()) != nda(i).value ());
 	    }
 
 	  fw = digits + isneg;
 	}
 
-      int column_width = fw + (bank_format ? 5 : 2);
+      int column_width = fw + (rat_format ?  0 : (bank_format ? 5 : 2));
       octave_idx_type total_width = nc * column_width;
       int max_width = command_editor::terminal_cols () - extra_indent;
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
 	{
 	  inc = max_width / column_width;
 	  if (inc == 0)
 	    inc++;
@@ -2565,16 +2730,57 @@ template OCTINTERP_API void
 octave_print_internal (std::ostream&, const octave_uint64&, bool);
 
 extern void
 octave_print_internal (std::ostream&, const Cell&, bool, int, bool)
 {
   panic_impossible ();
 }
 
+DEFUN (rats, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} rats (@var{x}, @var{len})\n\
+Convert @var{x} into a rational approximation represented as a string.\n\
+You can convert the string back into a matrix as follows:\n\
+\n\
+@example\n\
+   eval(['[',rats(hilb(4)),'];'])\n\
+@end example\n\
+\n\
+The optional second argument defines the maximum length of the string\n\
+representing the elements of @var{x}. By default @var{len} is 9.\n\
+@seealso{format, rat}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  int nargin = args.length ();
+
+  rat_string_len = 9;
+  if (nargin == 2)
+    rat_string_len = args(1).nint_value ();
+
+  if (!error_state)
+    {
+      if (nargin < 3 && nargout < 2)
+	{
+	  bool save_rat_format = rat_format;
+	  rat_format = true;
+	  std::ostringstream buf;
+	  args(0).print (buf);
+	  retval = buf.str ();
+	  rat_format = save_rat_format;
+	}
+      else
+	print_usage ();
+    }
+
+  rat_string_len = -1;
+  return retval;
+}
+
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
 Display the value of @var{x}.  For example,\n\
 \n\
 @example\n\
 disp (\"The value of pi is:\"), disp (pi)\n\
 \n\
@@ -2654,16 +2860,17 @@ Note that the output from @code{fdisp} a
   return retval;
 }
 
 static void
 init_format_state (void)
 {
   free_format = false;
   plus_format = false;
+  rat_format = false;
   bank_format = false;
   hex_format = 0;
   bit_format = 0;
   compact_format = false;
   print_e = false;
   print_big_e = false;
   print_g = false;
 }
@@ -2799,16 +3006,21 @@ set_format_style (int argc, const string
 		}
 	    }
 	  else
 	    plus_format_chars = "+  ";
 
 	  init_format_state ();
 	  plus_format = true;
 	}
+      else if (arg == "rat")
+	{
+	  init_format_state ();
+	  rat_format = true;
+	}
       else if (arg == "bank")
 	{
 	  init_format_state ();
 	  bank_format = true;
 	}
       else if (arg == "free")
 	{
 	  init_format_state ();
@@ -2976,16 +3188,19 @@ works for numeric types.\n\
 @item bit\n\
 The same as @code{native-bit}, but always print the most significant\n\
 bits first.\n\
 @item compact\n\
 Remove extra blank space around column number labels.\n\
 @item loose\n\
 Insert blank lines above and below column number labels (this is the\n\
 default).\n\
+@item rat\n\
+Print a rational approximation. That is the values are approximated\n\
+by one small integer divided by another.\n\
 @end table\n\
 \n\
 By default, Octave will try to print numbers with at least 5 significant\n\
 figures within a field that is a maximum of 10 characters wide.\n\
 \n\
 If Octave is unable to format a matrix so that columns line up on the\n\
 decimal point and all the numbers fit within the maximum field width,\n\
 it switches to an @samp{e} format.\n\
