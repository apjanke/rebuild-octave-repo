# HG changeset patch
# User jwe
# Date 845145490 0
#      Sat Oct 12 18:38:10 1996 +0000
# Node ID 4fc9fd1424a93454a4b28fca44c03306f81cfe58
# Parent  170053c0f75efbe671684687f96257026cf72e4f
[project @ 1996-10-12 18:31:34 by jwe]

diff --git a/Makeconf.in b/Makeconf.in
--- a/Makeconf.in
+++ b/Makeconf.in
@@ -52,34 +52,32 @@ FFLAGS = @FFLAGS@
 FPICFLAG = @FPICFLAG@
 FUGLY = @FUGLY@
 ALL_FFLAGS = $(FUGLY) $(FFLAGS)
 
 # cc and associated flags.
 
 DLFCN_INCFLAGS = @DLFCN_INCFLAGS@
 
-UCB_INCFLAGS = @UCB_INCFLAGS@
-
 # Clean up INCFLAGS a bit if we are not compiling in a separate
 # directory.
 ifeq ($(srcdir),.)
   TMP_IF_1 = -I. -I../src
 else
   TMP_IF_1 = -I. -I$(srcdir) -I../src
 endif
 ifeq ($(TOPDIR),$(top_srcdir))
   TMP_IF_2 = -I$(TOPDIR) -I$(TOPDIR)/liboctave -I$(TOPDIR)/src \
 	-I$(TOPDIR)/glob
 else
   TMP_IF_2 = -I$(TOPDIR) -I$(TOPDIR)/liboctave -I$(TOPDIR)/src \
 	-I$(TOPDIR)/glob -I$(top_srcdir) -I$(top_srcdir)/liboctave \
 	-I$(top_srcdir)/src -I$(top_srcdir)/glob
 endif
-INCFLAGS = $(TMP_IF_1) $(TMP_IF_2) $(DLFCN_INCFLAGS) $(UCB_INCFLAGS)
+INCFLAGS = $(TMP_IF_1) $(TMP_IF_2) $(DLFCN_INCFLAGS)
 
 LIBFLAGS = -L$(TOPDIR)
 
 DEFS = @DEFS@
 
 UGLY_DEFS = @UGLY_DEFS@
 
 CC = @CC@
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -15,17 +15,17 @@ dnl Copyright (C) 1996 John W. Eaton
 ### ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-AC_REVISION($Revision: 1.215 $)
+AC_REVISION($Revision: 1.216 $)
 AC_PREREQ(2.9)
 AC_INIT(src/octave.cc)
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1)
 
 AC_CANONICAL_HOST
 if test -z "$host"; then
@@ -882,33 +882,17 @@ case "$RETSIGTYPE" in
   ;;
   *)
     VOID_SIGHANDLER="-DVOID_SIGHANDLER=1"
     AC_MSG_RESULT([defining VOID_SIGHANDLER to be 1])
   ;;
 esac
 AC_SUBST(VOID_SIGHANDLER)
 
-### Try to make it possible to find getrusage on Solaris systems.
-
-XCFLAGS="$CFLAGS"
-case "$canonical_host_type" in
-  *-*-solaris2*)
-    UCBLIB=/usr/ucblib/libucb.a
-    UCB_INCFLAGS=-I/usr/ucbinclude
-    if test -f $UCBLIB; then
-      LIBS="-lc $UCBLIB $LIBS"
-      AC_MSG_RESULT([adding $UCBLIB to LIBS])
-      AC_MSG_RESULT([defining UCB_INCFLAGS to be $UCB_INCFLAGS])
-    fi
-  ;;
-esac
-AC_SUBST(UCB_INCFLAGS)
 AC_CHECK_FUNCS(getrusage times)
-CFLAGS="$XCFLAGS"
 
 ### Checks for other programs used for building, testing, installing,
 ### and running Octave.
 ###
 ### For now, don't define LEXLIB to be -lfl -- we don't use anything in
 ### it, and it might not be installed.
 ###
 ### Also make sure that we generate an interactive scanner if we are
diff --git a/doc/Makefile.in b/doc/Makefile.in
--- a/doc/Makefile.in
+++ b/doc/Makefile.in
@@ -51,18 +51,18 @@ tags::
 	ctags $(SOURCES)
 
 TAGS:: $(SOURCES)
 	etags $(SOURCES)
 
 distclean::
 	rm -f Makefile
 
-maintainer-clean:: distclean
-	rm -f tags TAGS
+maintainer-clean::
+	rm -f tags TAGS Makefile
 
 local-dist:
 	ln $(DISTFILES) ../`cat ../.fname`/doc
 	for dir in $(DISTSUBDIRS); do mkdir ../`cat ../.fname`/doc/$$dir; cd $$dir; $(MAKE) $@; cd ..; done
 .PHONY: local-dist
 
 dist:
 	ln $(DISTFILES) ../`cat ../.fname`/doc
diff --git a/libcruft/Makerules.in b/libcruft/Makerules.in
--- a/libcruft/Makerules.in
+++ b/libcruft/Makerules.in
@@ -63,18 +63,18 @@ mostlyclean::
 	rm -f *.o pic/*.o
 .PHONY: mostlyclean
 
 distclean:: clean
 	rm -f Makefile stamp-picdir
 	-rmdir pic
 .PHONY: distclean
 	
-maintainer-clean:: distclean
-	rm -f tags TAGS stamp-picdir
+maintainer-clean::
+	rm -f tags TAGS stamp-picdir Makefile
 	-rmdir pic
 .PHONY: maintainer-clean
 
 local-dist:
 	ln $(DISTFILES) ../../`cat ../../.fname`/libcruft/$(THISDIR)
 .PHONY: local-dist
 
 dist:
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -52,26 +52,26 @@ extern "C"
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
-int
+bool
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
 
-int
+bool
 ComplexColumnVector::operator != (const ComplexColumnVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexColumnVector&
@@ -225,40 +225,44 @@ ComplexColumnVector::extract (int r1, in
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
+      gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), len);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
+      gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -266,40 +270,43 @@ ComplexColumnVector::operator -= (const 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ComplexColumnVector& a)
 {
   int len = length ();
 
-  if (len != a.length ())
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
+      gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), len);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ComplexColumnVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
+      gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -435,19 +442,20 @@ operator * (const ComplexMatrix& m, cons
 ComplexColumnVector
 operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
 {
   ComplexColumnVector retval;
 
   int nr = m.rows ();
   int nc = m.cols ();
 
-  if (nc != a.length ())
-    (*current_liboctave_error_handler)
-      ("nonconformant matrix multiplication attempted");
+  int a_len = a.length ();
+
+  if (nc != a_len)
+    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nc == 0 || nr == 0)
 	retval.resize (nr, 0.0);
       else
 	{
 	  int ld = nr;
 
@@ -467,139 +475,155 @@ operator * (const ComplexMatrix& m, cons
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector
 operator + (const ComplexColumnVector& v, const ColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
+      gripe_nonconformant ("operator +", len, a_len);
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 operator - (const ComplexColumnVector& v, const ColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
+      gripe_nonconformant ("operator -", len, a_len);
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 operator + (const ColumnVector& v, const ComplexColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
+      gripe_nonconformant ("operator +", len, a_len);
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 operator - (const ColumnVector& v, const ComplexColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
+      gripe_nonconformant ("operator -", len, a_len);
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 product (const ComplexColumnVector& v, const ColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
+      gripe_nonconformant ("product", len, a_len);
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 quotient (const ComplexColumnVector& v, const ColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
+      gripe_nonconformant ("quotient", len, a_len);
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 product (const ColumnVector& v, const ComplexColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
+      gripe_nonconformant ("product", len, a_len);
       return ColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
 quotient (const ColumnVector& v, const ComplexColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
+      gripe_nonconformant ("quotient", len, a_len);
       return ColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (v.data (), a.data (), len), len);
 }
@@ -615,21 +639,22 @@ operator * (const Matrix& m, const Compl
 
 // diagonal matrix by column vector -> column vector operations
 
 ComplexColumnVector
 operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
+
   int a_len = a.length ();
+
   if (nc != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
+      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
@@ -642,21 +667,22 @@ operator * (const DiagMatrix& m, const C
   return result;
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
+
   int a_len = a.length ();
+
   if (nc != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix muliplication attempted");
+      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
@@ -669,21 +695,22 @@ operator * (const ComplexDiagMatrix& m, 
   return result;
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
+
   int a_len = a.length ();
+
   if (nc != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix muliplication attempted");
+      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -46,18 +46,18 @@ public:
   ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
 
   ComplexColumnVector& operator = (const ComplexColumnVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
 
-  int operator == (const ComplexColumnVector& a) const;
-  int operator != (const ComplexColumnVector& a) const;
+  bool operator == (const ComplexColumnVector& a) const;
+  bool operator != (const ComplexColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   ComplexColumnVector& insert (const ColumnVector& a, int r);
   ComplexColumnVector& insert (const ComplexColumnVector& a, int r);
 
   ComplexColumnVector& fill (double val);
   ComplexColumnVector& fill (const Complex& val);
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -40,26 +40,26 @@ Software Foundation, 59 Temple Place - S
 
 ComplexDiagMatrix::ComplexDiagMatrix (const DiagMatrix& a)
   : MDiagArray2<Complex> (a.rows (), a.cols ())
 {
   for (int i = 0; i < length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-int
+bool
 ComplexDiagMatrix::operator == (const ComplexDiagMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
   return equal (data (), a.data (), length ());
 }
 
-int
+bool
 ComplexDiagMatrix::operator != (const ComplexDiagMatrix& a) const
 {
   return !(*this == a);
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val)
 {
@@ -394,20 +394,23 @@ ComplexDiagMatrix::inverse (int& info) c
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const DiagMatrix& a)
 {
   int nr = rows ();
   int nc = cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
+      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -415,20 +418,23 @@ ComplexDiagMatrix::operator += (const Di
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator -= (const DiagMatrix& a)
 {
   int nr = rows ();
   int nc = cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
+      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -436,20 +442,23 @@ ComplexDiagMatrix::operator -= (const Di
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const ComplexDiagMatrix& a)
 {
   int nr = rows ();
   int nc = cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
+      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -457,20 +466,23 @@ ComplexDiagMatrix::operator += (const Co
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator -= (const ComplexDiagMatrix& a)
 {
   int nr = rows ();
   int nc = cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
+      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -526,22 +538,23 @@ operator * (const Complex& s, const Diag
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b)
 {
   int nr_a = a.rows ();
   int nc_a = a.cols ();
+
   int nr_b = b.rows ();
   int nc_b = b.cols ();
+
   if (nc_a != nr_b)
     {
-      (*current_liboctave_error_handler)
-        ("nonconformant matrix multiplication attempted");
+      gripe_nonconformant ("operator *", nr_a, nc_a, nr_b, nc_b);
       return ComplexDiagMatrix ();
     }
 
   if (nr_a == 0 || nc_a == 0 || nc_b == 0)
     return ComplexDiagMatrix (nr_a, nc_a, 0.0);
 
   ComplexDiagMatrix c (nr_a, nc_b);
 
@@ -565,59 +578,66 @@ operator * (const ComplexDiagMatrix& a, 
   return c;
 }
 
 ComplexDiagMatrix
 operator + (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
+      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
       return ComplexDiagMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexDiagMatrix
 operator - (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
+      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
       return ComplexDiagMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (subtract (m.data (), a.data (), m.length ()),
 			    nr, nc);
 }
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const DiagMatrix& b)
 {
   int nr_a = a.rows ();
   int nc_a = a.cols ();
+
   int nr_b = b.rows ();
   int nc_b = b.cols ();
+
   if (nc_a != nr_b)
     {
-      (*current_liboctave_error_handler)
-        ("nonconformant matrix multiplication attempted");
+      gripe_nonconformant ("operator *", nr_a, nc_a, nr_b, nc_b);
       return ComplexDiagMatrix ();
     }
 
   if (nr_a == 0 || nc_a == 0 || nc_b == 0)
     return ComplexDiagMatrix (nr_a, nc_a, 0.0);
 
   ComplexDiagMatrix c (nr_a, nc_b);
 
@@ -641,59 +661,66 @@ operator * (const ComplexDiagMatrix& a, 
   return c;
 }
 
 ComplexDiagMatrix
 operator + (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
+      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
       return ComplexDiagMatrix ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (add (m.data (), a.data (), m.length ()),  nr, nc);
 }
 
 ComplexDiagMatrix
 operator - (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
+      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
       return ComplexDiagMatrix ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (subtract (m.data (), a.data (), m.length ()),
 			    nr, nc);
 }
 
 ComplexDiagMatrix
 operator * (const DiagMatrix& a, const ComplexDiagMatrix& b)
 {
   int nr_a = a.rows ();
   int nc_a = a.cols ();
+
   int nr_b = b.rows ();
   int nc_b = b.cols ();
+
   if (nc_a != nr_b)
     {
-      (*current_liboctave_error_handler)
-        ("nonconformant matrix multiplication attempted");
+      gripe_nonconformant ("operator *", nr_a, nc_a, nr_b, nc_b);
       return ComplexDiagMatrix ();
     }
 
   if (nr_a == 0 || nc_a == 0 || nc_b == 0)
     return ComplexDiagMatrix (nr_a, nc_a, 0.0);
 
   ComplexDiagMatrix c (nr_a, nc_b);
 
@@ -717,39 +744,45 @@ operator * (const DiagMatrix& a, const C
   return c;
 }
 
 ComplexDiagMatrix
 product (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
+      gripe_nonconformant ("product", nr, nc, a_nr, a_nc);
       return ComplexDiagMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
 			    nr, nc);
 }
 
 ComplexDiagMatrix
 product (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nr != a_nr || nc != a_nc)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
+      gripe_nonconformant ("product", nr, nc, a_nr, a_nc);
       return ComplexDiagMatrix ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
 			    nr, nc);
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -57,18 +57,18 @@ public:
   ComplexDiagMatrix (const ComplexDiagMatrix& a) : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
     {
       MDiagArray2<Complex>::operator = (a);
       return *this;
     }
 
-  int operator == (const ComplexDiagMatrix& a) const;
-  int operator != (const ComplexDiagMatrix& a) const;
+  bool operator == (const ComplexDiagMatrix& a) const;
+  bool operator != (const ComplexDiagMatrix& a) const;
 
   ComplexDiagMatrix& fill (double val);
   ComplexDiagMatrix& fill (const Complex& val);
   ComplexDiagMatrix& fill (double val, int beg, int end);
   ComplexDiagMatrix& fill (const Complex& val, int beg, int end);
   ComplexDiagMatrix& fill (const ColumnVector& a);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a);
   ComplexDiagMatrix& fill (const RowVector& a);
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -52,26 +52,26 @@ extern "C"
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
-int
+bool
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
 
-int
+bool
 ComplexRowVector::operator != (const ComplexRowVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexRowVector&
@@ -225,80 +225,88 @@ ComplexRowVector::extract (int c1, int c
 }
 
 // row vector by row vector -> row vector operations
 
 ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
+      gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
+      gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator += (const ComplexRowVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
+      gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator -= (const ComplexRowVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
+      gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -426,19 +434,21 @@ operator / (const Complex& s, const RowV
 
 ComplexRowVector
 operator * (const ComplexRowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector retval;
 
   int len = v.length ();
 
-  if (a.rows () != len)
-    (*current_liboctave_error_handler)
-      ("nonconformant vector multiplication attempted");
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (a_nr != len)
+    gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       int a_nr = a.rows ();
       int a_nc = a.cols ();
 
       if (len == 0)
 	retval.resize (a_nc, 0.0);
       else
@@ -470,139 +480,155 @@ operator * (const RowVector& v, const Co
 }
 
 // row vector by row vector -> row vector operations
 
 ComplexRowVector
 operator + (const ComplexRowVector& v, const RowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
+      gripe_nonconformant ("operator +", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 operator - (const ComplexRowVector& v, const RowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
+      gripe_nonconformant ("operator -", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 operator + (const RowVector& v, const ComplexRowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
+      gripe_nonconformant ("operator +", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 operator - (const RowVector& v, const ComplexRowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
+      gripe_nonconformant ("operator -", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 product (const ComplexRowVector& v, const RowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
+      gripe_nonconformant ("product", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 quotient (const ComplexRowVector& v, const RowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
+      gripe_nonconformant ("quotient", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (divide (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 product (const RowVector& v, const ComplexRowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
+      gripe_nonconformant ("product", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
 quotient (const RowVector& v, const ComplexRowVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
+      gripe_nonconformant ("quotient", len, a_len);
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (divide (v.data (), a.data (), len), len);
 }
@@ -707,20 +733,22 @@ operator * (const ComplexRowVector& v, c
   ComplexColumnVector tmp (a);
   return v * tmp;
 }
 
 Complex
 operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
 {
   int len = v.length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector multiplication attempted");
+      gripe_nonconformant ("operator *", len, a_len);
       return 0.0;
     }
 
   Complex retval (0.0, 0.0);
 
   for (int i = 0; i < len; i++)
     retval += v.elem (i) * a.elem (i);
 
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -45,18 +45,18 @@ public:
   ComplexRowVector (const ComplexRowVector& a) : MArray<Complex> (a) { }
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
 
-  int operator == (const ComplexRowVector& a) const;
-  int operator != (const ComplexRowVector& a) const;
+  bool operator == (const ComplexRowVector& a) const;
+  bool operator != (const ComplexRowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   ComplexRowVector& insert (const RowVector& a, int c);
   ComplexRowVector& insert (const ComplexRowVector& a, int c);
 
   ComplexRowVector& fill (double val);
   ComplexRowVector& fill (const Complex& val);
diff --git a/liboctave/MArray-misc.cc b/liboctave/MArray-misc.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/MArray-misc.cc
@@ -0,0 +1,52 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "MArray.h"
+#include "MArray2.h"
+#include "lo-error.h"
+
+void
+gripe_nonconformant (const char *op, int op1_len, int op2_len)
+{
+  (*current_liboctave_error_handler)
+    ("%s: nonconformant arguments (op1 len: %d, op2 len: %d)",
+     op, op1_len, op2_len);
+}
+
+void
+gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
+		     int op2_nr, int op2_nc)
+{
+  (*current_liboctave_error_handler)
+    ("%s: nonconformant arguments (op1 is %dx%d, op2 is %dx%d)",
+     op, op1_nr, op1_nc, op2_nr, op2_nc);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -49,20 +49,20 @@ TEMPLATE_SRC := Array.cc Array2.cc Array
 
 TI_SRC := Array-C.cc Array-ch.cc Array-i.cc Array-d.cc Array-s.cc \
 	Array-str.cc \
 	MArray-C.cc MArray-ch.cc MArray-i.cc MArray-d.cc MArray-s.cc
 
 MATRIX_SRC := Array-flags.cc CColVector.cc CDiagMatrix.cc CMatrix.cc \
 	CRowVector.cc CmplxAEPBAL.cc CmplxCHOL.cc CmplxDET.cc \
 	CmplxHESS.cc CmplxLU.cc CmplxQR.cc CmplxQRP.cc CmplxSCHUR.cc \
-	CmplxSVD.cc EIG.cc chMatrix.cc dColVector.cc dDiagMatrix.cc \
-	dMatrix.cc dRowVector.cc dbleAEPBAL.cc dbleCHOL.cc \
-	dbleDET.cc dbleGEPBAL.cc dbleHESS.cc dbleLU.cc dbleQR.cc \
-	dbleQRP.cc dbleSCHUR.cc dbleSVD.cc
+	CmplxSVD.cc EIG.cc MArray-misc.cc chMatrix.cc dColVector.cc \
+	dDiagMatrix.cc dMatrix.cc dRowVector.cc dbleAEPBAL.cc \
+	dbleCHOL.cc dbleDET.cc dbleGEPBAL.cc dbleHESS.cc dbleLU.cc \
+	dbleQR.cc dbleQRP.cc dbleSCHUR.cc dbleSVD.cc
 
 SOURCES := Bounds.cc CollocWt.cc DAE.cc DASSL.cc FEGrid.cc FSQP.cc \
 	LinConst.cc LPsolve.cc LSODE.cc NLEqn.cc NPSOL.cc QPSOL.cc \
 	Quad.cc Range.cc acosh.c asinh.c atanh.c cmd-hist.cc \
 	data-conv.cc dir-ops.cc erf.c erfc.c f77-fcn.c file-ops.cc \
 	filemode.c gamma.c getopt.c getopt1.c idx-vector.cc lgamma.c \
 	lo-ieee.cc lo-mappers.cc lo-utils.cc mach-info.cc mkdir.c \
 	oct-glob.cc oct-term.cc pathsearch.cc prog-args.cc rename.c \
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -45,26 +45,26 @@ extern "C"
 			      const double&, const double*,
 			      const int&, const double*, const int&,
 			      const double&, double*, const int&,
 			      long);
 }
 
 // Column Vector class.
 
-int
+bool
 ColumnVector::operator == (const ColumnVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
 
-int
+bool
 ColumnVector::operator != (const ColumnVector& a) const
 {
   return !(*this == a);
 }
 
 ColumnVector&
 ColumnVector::insert (const ColumnVector& a, int r)
 {
@@ -164,40 +164,44 @@ ColumnVector::extract (int r1, int r2) c
 }
 
 // column vector by column vector -> column vector operations
 
 ColumnVector&
 ColumnVector::operator += (const ColumnVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
+      gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), len);
   return *this;
 }
 
 ColumnVector&
 ColumnVector::operator -= (const ColumnVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
+      gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -210,19 +214,20 @@ ColumnVector::operator -= (const ColumnV
 ColumnVector
 operator * (const Matrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
   int nr = m.rows ();
   int nc = m.cols ();
 
-  if (nc != a.length ())
-    (*current_liboctave_error_handler)
-      ("nonconformant matrix multiplication attempted");
+  int a_len = a.length ();
+
+  if (nc != a_len)
+    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
 	retval.resize (nr, 0.0);
       else
 	{
 	  int ld = nr;
 
@@ -249,18 +254,17 @@ operator * (const DiagMatrix& m, const C
   ColumnVector retval;
 
   int nr = m.rows ();
   int nc = m.cols ();
 
   int a_len = a.length ();
 
   if (nc != a_len)
-    (*current_liboctave_error_handler)
-      ("nonconformant matrix multiplication attempted");
+    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
 	retval.resize (nr, 0.0);
       else
 	{
 	  retval.resize (nr);
 
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -45,18 +45,18 @@ public:
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
   ColumnVector& operator = (const ColumnVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
-  int operator == (const ColumnVector& a) const;
-  int operator != (const ColumnVector& a) const;
+  bool operator == (const ColumnVector& a) const;
+  bool operator != (const ColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   ColumnVector& insert (const ColumnVector& a, int r);
 
   ColumnVector& fill (double val);
   ColumnVector& fill (double val, int r1, int r2);
 
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -48,26 +48,26 @@ extern "C"
 			      long);
 
   double F77_FCN (ddot, DDOT) (const int&, const double*, const int&,
 			       const double*, const int&);
 }
 
 // Row Vector class.
 
-int
+bool
 RowVector::operator == (const RowVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
 
-int
+bool
 RowVector::operator != (const RowVector& a) const
 {
   return !(*this == a);
 }
 
 RowVector&
 RowVector::insert (const RowVector& a, int c)
 {
@@ -165,40 +165,44 @@ RowVector::extract (int c1, int c2) cons
 }
 
 // row vector by row vector -> row vector operations
 
 RowVector&
 RowVector::operator += (const RowVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
+      gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), len);
   return *this;
 }
 
 RowVector&
 RowVector::operator -= (const RowVector& a)
 {
   int len = length ();
-  if (len != a.length ())
+
+  int a_len = a.length ();
+
+  if (len != a_len)
     {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
+      gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -210,19 +214,21 @@ RowVector::operator -= (const RowVector&
 
 RowVector
 operator * (const RowVector& v, const Matrix& a)
 {
   RowVector retval;
 
   int len = v.length ();
 
-  if (a.rows () != len)
-    (*current_liboctave_error_handler)
-      ("nonconformant vector multiplication attempted");
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (a_nr != len)
+    gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       int a_nr = a.rows ();
       int a_nc = a.cols ();
 
       if (len == 0)
 	retval.resize (a_nc, 0.0);
       else
@@ -361,19 +367,20 @@ linspace (double x1, double x2, int n)
 
 double
 operator * (const RowVector& v, const ColumnVector& a)
 {
   double retval = 0.0;
 
   int len = v.length ();
 
-  if (len != a.length ())
-    (*current_liboctave_error_handler)
-      ("nonconformant vector multiplication attempted");
+  int a_len = a.length ();
+
+  if (len != a_len)
+    gripe_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     retval = F77_FCN (ddot, DDOT) (len, v.data (), 1, a.data (), 1);
 
   return retval;
 }
 
 Complex
 operator * (const RowVector& v, const ComplexColumnVector& a)
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -44,18 +44,18 @@ public:
   RowVector (const RowVector& a) : MArray<double> (a) { }
 
   RowVector& operator = (const RowVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
-  int operator == (const RowVector& a) const;
-  int operator != (const RowVector& a) const;
+  bool operator == (const RowVector& a) const;
+  bool operator != (const RowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   RowVector& insert (const RowVector& a, int c);
 
   RowVector& fill (double val);
   RowVector& fill (double val, int c1, int c2);
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -144,16 +144,37 @@ IDX_VEC_REP::idx_vector_rep (const Matri
       for (int j = 0; j < orig_nc; j++)
 	for (int i = 0; i < orig_nr; i++)
 	  data[k++] = tree_to_mat_idx (m.elem (i, j));
     }
 
   init_state ();
 }
 
+IDX_VEC_REP::idx_vector_rep (double d)
+{
+  data = 0;
+  initialized = 0;
+  frozen = 0;
+  colon_equiv_checked = 0;
+  colon_equiv = 0;
+  colon = 0;
+
+  len = 1;
+
+  orig_nr = 1;
+  orig_nc = 1;
+
+  data = new int [len];
+
+  data[0] = tree_to_mat_idx (d);
+
+  init_state ();
+}
+
 IDX_VEC_REP::idx_vector_rep (const Range& r)
 {
   data = 0;
   initialized = 0;
   frozen = 0;
   colon_equiv_checked = 0;
   colon_equiv = 0;
   colon = 0;
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -59,16 +59,18 @@ private:
       }
 
     idx_vector_rep (const ColumnVector& v);
 
     idx_vector_rep (const Matrix& m);
 
     idx_vector_rep (const Range& r);
 
+    idx_vector_rep (double d);
+
     idx_vector_rep (char c);
 
     idx_vector_rep (const idx_vector_rep& a);
 
     idx_vector_rep::~idx_vector_rep (void) { delete [] data; }
 
     idx_vector_rep& operator = (const idx_vector_rep& a);
 
@@ -150,16 +152,22 @@ public:
     }
 
   idx_vector (const Range& r)
     {
       rep = new idx_vector_rep (r);
       rep->count = 1;
     }
 
+  idx_vector (double d)
+    {
+      rep = new idx_vector_rep (d);
+      rep->count = 1;
+    }
+
   idx_vector (char c)
     {
       rep = new idx_vector_rep (c);
       rep->count = 1;
     }
 
   idx_vector (const idx_vector& a)
     {
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -22,23 +22,24 @@ Software Foundation, 59 Temple Place - S
 */
 
 #include "oct-cmplx.h"
 
 // But first, some helper functions...
 
 // XXX FIXME XXX -- these need to be done with templates...
 
-static inline int
+static inline bool
 equal (const char *x, const char *y, int len)
 {
   for (int i = 0; i < len; i++)
     if (x[i] != y[i])
-      return 0;
-  return 1;
+      return false;
+
+  return true;
 }
 
 static inline double *
 add (const double *d, int len, double s)
 {
   double *result = 0;
   if (len > 0)
     {
