# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1342557259 25200
#      Tue Jul 17 13:34:19 2012 -0700
# Node ID c2dbdeaa25df8767ae2561e5fe1d4ec510f2ed06
# Parent  26c4ca9782b06b23fa11ec0bdcfc9f435475e089
maint: use rows() and columns() to clarify m-files.

* gradient.m, interp1q.m, rat.m, tsearchn.m, image.m, imwrite.m, area.m,
contourc.m, hist.m, isocolors.m, isonormals.m, meshz.m, print.m, __bar__.m,
__go_draw_axes__.m, __interp_cube__.m, __marching_cube__.m, __patch__.m,
__print_parse_opts__.m, __quiver__.m, rose.m, shrinkfaces.m, stairs.m,
surfnorm.m, tetramesh.m, text.m, deconv.m, spline.m, intersect.m, setdiff.m,
setxor.m, union.m, periodogram.m, pcg.m, perms.m: Replace size (x,1) with
rows (x) and size(x,2) with columns(x).

diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -82,17 +82,17 @@ function varargout = gradient (m, vararg
   endif
 
 endfunction
 
 function varargout = matrix_gradient (m, varargin)
   transposed = false;
   if (isvector (m))
     ## make a row vector.
-    transposed = (size (m, 2) == 1);
+    transposed = (columns (m) == 1);
     m = m(:).';
   endif
 
   nd = ndims (m);
   sz = size (m);
   if (length (sz) > 1)
     tmp = sz(1); sz(1) = sz(2); sz(2) = tmp;
   endif
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -32,17 +32,17 @@
 ## execution time of this @code{interp1} if the size of the input arguments
 ## is relatively small.  Therefore, the benefit of using @code{interp1q}
 ## is relatively small.
 ## @seealso{interp1}
 ## @end deftypefn
 
 function yi = interp1q (x, y, xi)
   x = x(:);
-  nx = size (x, 1);
+  nx = rows (x);
   szy = size (y);
   y = y(:,:);
   [ny, nc] = size (y);
   szx = size (xi);
   xi = xi (:);
   dy = diff (y);
   dx = diff (x);
   idx = lookup (x, xi, "lr");
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -111,17 +111,17 @@ function [n,d] = rat (x,tol)
     n(isinf (x)) = sign (x(isinf (x)));
     d(isinf (x)) = 0;
 
     ## Reshape the output.
     n = reshape (n, size (x));
     d = reshape (d, size (x));
   else
     n = "";
-    nsteps = size (steps, 2);
+    nsteps = columns (steps);
     for i = 1: nsz
       s = [int2str(y(i))," "];
       j = 1;
 
       while (true)
         step = steps(i, j++);
         if (isnan (step))
           break;
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -26,19 +26,19 @@
 ## @seealso{delaunay, delaunayn}
 ## @end deftypefn
 
 function [idx, p] = tsearchn (x, t, xi)
   if (nargin != 3)
     print_usage ();
   endif
 
-  nt = size (t, 1);
+  nt = rows (t);
   [m, n] = size (x);
-  mi = size (xi, 1);
+  mi = rows (xi);
   idx = NaN (mi, 1);
   p = NaN (mi, n + 1);
 
   ni = [1:mi].';
   for i = 1 : nt
     ## Only calculate the Barycentric coordinates for points that have not
     ## already been found in a triangle.
     b = cart2bary (x (t (i, :), :), xi(ni,:));
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -130,22 +130,22 @@ function h = __img__ (x, y, img, varargi
   tmp = __go_image__ (ca, "cdata", img, "xdata", xdata, "ydata", ydata,
                     "cdatamapping", "direct", varargin {:});
 
   px = __image_pixel_size__ (tmp);
 
   if (xdata(2) < xdata(1))
     xdata = xdata(2:-1:1);
   elseif (xdata(2) == xdata(1))
-    xdata = xdata(1) + [0, size(img,2)-1];
+    xdata = xdata(1) + [0, columns(img)-1];
   endif
   if (ydata(2) < ydata(1))
     ydata = ydata(2:-1:1);
   elseif (ydata(2) == ydata(1))
-    ydata = ydata(1) + [0, size(img,1)-1];
+    ydata = ydata(1) + [0, rows(img)-1];
   endif
   xlim = xdata + [-px(1), px(1)];
   ylim = ydata + [-px(2), px(2)];
 
   ## FIXME -- how can we do this and also get the {x,y}limmode
   ## properties to remain "auto"?  I suppose this adjustment should
   ## happen automatically in axes::update_axis_limits instead of
   ## explicitly setting the values here.  But then what information is
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -157,17 +157,17 @@ function imwrite (img, varargin)
       endif
       if (nd != 2 && nd != 4)
         error ("imwrite: invalid size for indexed image");
       endif
     else
       error ("imwrite: %s: invalid class for indexed image data", img_class);
     endif
     if (isa (map, "double"))
-      if (ndims (map) != 2 || size (map, 2) != 3)
+      if (ndims (map) != 2 || columns (map) != 3)
         error ("imwrite: invalid size for colormap");
       endif
     else
       error ("imwrite: %s invalid class for indexed image colormap",
              class (map));
     endif
 
     ## FIXME -- we should really be writing indexed images here but
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -75,17 +75,17 @@ function h = area (varargin)
     if (nargin >= idx)
       args = {varargin{idx:end}};
     endif
     newplot ();
     if (isvector (y))
       y = y(:);
     endif
     if (isempty (x))
-      x = repmat ([1:size(y, 1)]', 1, columns (y));
+      x = repmat ([1:rows(y)]', 1, columns (y));
     elseif (isvector (x))
       x = repmat (x(:),  1, columns (y));
     endif
 
     oldax = gca ();
     unwind_protect
       axes (ax);
       tmp = __area__ (ax, x, y, bv, args{:});
@@ -102,17 +102,17 @@ function h = area (varargin)
 
 endfunction
 
 function retval = __area__ (ax, x, y, bv, varargin)
 
   y0 = bv * ones (1, rows (y));
   y0 = zeros (1, rows (y));
   retval = [];
-  for i = 1: size (y, 2);
+  for i = 1: columns (y);
     hg = hggroup ();
     retval = [retval; hg];
     args = __add_datasource__ ("area", hg, {"x", "y"}, varargin{:});
 
     x1 = x(:, 1).';
     y1 = y (:, i).';
     addproperty ("xdata", hg, "data", x1);
     addproperty ("ydata", hg, "data", y1);
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -96,40 +96,40 @@ function [cout, lev] = contourc (varargi
   else
     vv = unique (sort (vn));
   endif
 
   if (isvector (x) && isvector (y))
     c = __contourc__ (x(:)', y(:)', z, vv);
   else
     ## Indexes x,y for the purpose of __contourc__.
-    ii = 1:size (z,2);
-    jj = 1:size (z,1);
+    ii = 1:columns (z);
+    jj = 1:rows (z);
 
     ## Now call __contourc__ for the real work...
     c = __contourc__ (ii, jj, z, vv);
 
     ## Map the contour lines from index space (i,j) back
     ## to the original grid (x,y)
     i = 1;
 
-    while (i < size (c,2))
+    while (i < columns (c))
       clen = c(2, i);
       ind = i + [1 : clen];
 
       ci = c(1, ind);
       cj = c(2,ind);
 
       ## due to rounding errors some elements of ci and cj
       ## can fall out of the range of ii and jj and interp2 would
       ## return NA for those values.
       ## The permitted range is enforced here:
 
-      ci = max (ci, 1); ci = min (ci, size (z, 2));
-      cj = max (cj, 1); cj = min (cj, size (z, 1));
+      ci = max (ci, 1); ci = min (ci, columns (z));
+      cj = max (cj, 1); cj = min (cj, rows (z));
 
       c(1, ind) = interp2 (ii, jj, x, ci, cj);
       c(2, ind) = interp2 (ii, jj, y, ci, cj);
 
       i = i + clen + 1;
     endwhile
   endif
 
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -155,17 +155,17 @@ function [nn, xx] = hist (y, varargin)
   if (nargout > 0)
     if (arg_is_vector)
       nn = freq';
       xx = x';
     else
       nn = freq;
       xx = x;
     endif
-  elseif (size (freq, 2) != 1)
+  elseif (columns (freq) != 1)
     bar (x, freq, 0.8, varargin{iarg:end});
   else
     bar (x, freq, 1.0, varargin{iarg:end});
   endif
 
 endfunction
 
 
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -129,27 +129,27 @@ function varargout = isocolors (varargin
       z = varargin{3};
       R = varargin{4};
       G = varargin{5};
       B = varargin{6};
       vp = varargin{7};
     otherwise
       print_usage ();
   endswitch
-  if (ismatrix (vp) && size (vp,2) == 3)
+  if (ismatrix (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
   elseif ( ishandle (vp) )
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isocolors: last argument is not a vertex list or patch handle");
   endif
   if (calc_rgb)
-    new_col = zeros (size (v, 1), 3);
+    new_col = zeros (rows (v), 3);
     new_col(:,1) = __interp_cube__ (x, y, z, R, v, "values" );
     new_col(:,2) = __interp_cube__ (x, y, z, G, v, "values" );
     new_col(:,3) = __interp_cube__ (x, y, z, B, v, "values" );
   else
     new_col = __interp_cube__ (x, y, z, c, v, "values" );
   endif
   switch (nargout)
     case 0
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -117,17 +117,17 @@ function varargout = isonormals (varargi
       x = varargin{1};
       y = varargin{2};
       z = varargin{3};
       c = varargin{4};
       vp = varargin{5};
     otherwise
       print_usage ();
   endswitch
-  if (ismatrix (vp) && size (vp,2) == 3)
+  if (ismatrix (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
   elseif (ishandle (vp))
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isonormals: Last argument is not a vertex list or a patch handle");
   endif
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -64,19 +64,19 @@ function retval = meshz (varargin)
          x(:, 1), x, x(:, end);
          x(end, 1), x(end, :), x(end, end)];
     y = [y(1, 1), y(1, :), y(1, end);
          y(:, 1), y, y(:, end);
          y(end, 1), y(end, :), y(end, end)];
   endif
 
   zref = min (z(isfinite (z)));
-  z = [zref .* ones(1, size(z, 2) + 2);
-       zref .* ones(size(z, 1), 1), z, zref .* ones(size(z, 1), 1);
-       zref.* ones(1, size(z, 2) + 2)];
+  z = [zref .* ones(1, columns(z) + 2);
+       zref .* ones(rows(z), 1), z, zref .* ones(rows(z), 1);
+       zref.* ones(1, columns(z) + 2)];
 
   oldh = gca ();
   unwind_protect
     axes (h);
     tmp = mesh (x, y, z, varargin{ioff:end});
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -359,17 +359,17 @@ function print (varargin)
             ## Need to verify objects exist since callbacks may delete objects
             ## as the colors for others are modified.
             rgb = get (h(n), color_props{c});
             props(end+1).h = h(n);
             props(end).name = color_props{c};
             props(end).value = {get(h(n), color_props{c})};
             if (isnumeric (rgb))
               ## convert RGB color to RGB gray scale
-              xfer = repmat ([0.30, 0.59, 0.11], size (rgb, 1), 1);
+              xfer = repmat ([0.30, 0.59, 0.11], rows (rgb), 1);
               ggg = repmat (sum (xfer .* rgb, 2), 1, 3);
               set (h(n), color_props{c}, ggg);
             endif
           endif
         endfor
       endfor
     endif
 
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -40,35 +40,35 @@ function varargout = __bar__ (vertical, 
     x = varargin{1};
     if (isvector (x))
       x = x(:);
     endif
     y = varargin{2};
     if (isvector (y))
       y = y(:);
     endif
-    if (size (x, 1) != size (y, 1))
+    if (rows (x) != rows (y))
       y = varargin{1};
       if (isvector (y))
         y = y(:);
       endif
-      x = [1:size(y,1)]';
+      x = [1:rows(y)]';
       idx = 2;
     else
       if (! isvector (x))
         error ("%s: x must be a vector", func);
       endif
       idx = 3;
     endif
   else
     y = varargin{1};
     if (isvector (y))
       y = y(:);
     endif
-    x = [1:size(y,1)]';
+    x = [1:rows(y)]';
     idx = 2;
   endif
 
   newargs = {};
   have_line_spec = false;
   while (idx <= nargin - 2)
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
@@ -100,27 +100,27 @@ function varargout = __bar__ (vertical, 
         idx += 2;
       else
         newargs = [newargs,varargin(idx:idx+1)];
         idx += 2;
       endif
     endif
   endwhile
 
-  xlen = size (x, 1);
-  ylen = size (y, 1);
+  xlen = rows (x);
+  ylen = rows (y);
 
   if (xlen != ylen)
     error ("%s: length of x and y must be equal", func);
   endif
   if (any (x(2:end) < x(1:end-1)))
     error ("%s: x vector values must be in ascending order", func);
   endif
 
-  ycols = size (y, 2);
+  ycols = columns (y);
   if (numel (x) > 1)
     cutoff = min (diff (double (x))) / 2;
   else
     cutoff = 1;
   endif
   if (group)
     delta_p = delta_m = repmat (cutoff * width / ycols, size (x));
   else
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -490,23 +490,23 @@ function __go_draw_axes__ (h, plot_strea
           parametric(data_idx) = false;
           have_cdata(data_idx) = false;
           have_3d_patch(data_idx) = false;
 
           if (img_xdata(2) < img_xdata(1))
             img_xdata = img_xdata(2:-1:1);
             img_data = img_data(:,end:-1:1,:);
           elseif (img_xdata(1) == img_xdata(2))
-            img_xdata = img_xdata(1) + [0, size(img_data,2)-1];
+            img_xdata = img_xdata(1) + [0, columns(img_data)-1];
           endif
           if (img_ydata(2) < img_ydata(1))
             img_ydata = img_ydata(2:-1:1);
             img_data = img_data(end:-1:1,:,:);
           elseif (img_ydata(1) == img_ydata(2))
-            img_ydata = img_ydata(1) + [0, size(img_data,1)-1];
+            img_ydata = img_ydata(1) + [0, rows(img_data)-1];
           endif
 
           [y_dim, x_dim] = size (img_data(:,:,1));
           if (x_dim > 1)
             dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
           else
             x_dim = 2;
             img_data = [img_data, img_data];
@@ -675,44 +675,44 @@ function __go_draw_axes__ (h, plot_strea
                  tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
                  titlespec{local_idx} = cstrcat ("title \"", tmp, "\"");
                endif
                if (isfield (obj, "facecolor"))
                  if ((strncmp (obj.facecolor, "flat", 4)
                      || strncmp (obj.facecolor, "interp", 6))
                      && isfield (obj, "cdata"))
                    if (ndims (obj.cdata) == 2
-                       && (size (obj.cdata, 2) == nc
-                           && (size (obj.cdata, 1) == 1
-                               || size (obj.cdata, 1) == 3)))
+                       && (columns (obj.cdata) == nc
+                           && (rows (obj.cdata) == 1
+                               || rows (obj.cdata) == 3)))
                      ccol = cdat (:, i);
                    elseif (ndims (obj.cdata) == 2
-                       && (size (obj.cdata, 1) == nc
-                           && (size (obj.cdata, 2) == 1
-                               || size (obj.cdata, 2) == 3)))
+                       && (rows (obj.cdata) == nc
+                           && (columns (obj.cdata) == 1
+                               || columns (obj.cdata) == 3)))
                      ccol = cdat (i, :);
                    elseif (ndims (obj.cdata) == 3)
                      ccol = permute (cdat (:, i, :), [1, 3, 2]);
                    else
                      ccol = cdat;
                    endif
                    if (strncmp (obj.facecolor, "flat", 4))
                      if (isequal (size (ccol), [1, 3]))
                        ## RGB Triplet
                        color = ccol;
                      elseif (nd == 3 && numel (xcol) == 3)
                        ccdat = ccol;
                      else
                        if (cdatadirect)
                          r = round (ccol);
                        else
-                         r = 1 + round ((size (cmap, 1) - 1)
+                         r = 1 + round ((rows (cmap) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
-                       r = max (1, min (r, size (cmap, 1)));
+                       r = max (1, min (r, rows (cmap)));
                        color = cmap(r, :);
                      endif
                    elseif (strncmp (obj.facecolor, "interp", 6))
                      if (nd == 3 && numel (xcol) == 3)
                        ccdat = ccol;
                        if (! isvector (ccdat))
                          tmp = rows (cmap) + rows (addedcmap) + ...
                               [1 : rows(ccdat)];
@@ -723,20 +723,20 @@ function __go_draw_axes__ (h, plot_strea
                        endif
                      else
                        if (sum (diff (ccol)))
                          warning ("\"interp\" not supported, using 1st entry of cdata");
                        endif
                        if (cdatadirect)
                          r = round (ccol);
                        else
-                         r = 1 + round ((size (cmap, 1) - 1)
+                         r = 1 + round ((rows (cmap) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
-                       r = max (1, min (r, size (cmap, 1)));
+                       r = max (1, min (r, rows (cmap)));
                        color = cmap(r(1),:);
                      endif
                    endif
                  elseif (isnumeric (obj.facecolor))
                    color = obj.facecolor;
                  else
                    color = [0, 1, 0];
                  endif
@@ -807,24 +807,24 @@ function __go_draw_axes__ (h, plot_strea
                else
                  ec = obj.edgecolor;
                endif
 
                if ((strncmp (ec, "flat", 4)
                     || strncmp (ec, "interp", 6))
                    && isfield (obj, "cdata"))
                  if (ndims (obj.cdata) == 2
-                     && (size (obj.cdata, 2) == nc
-                         && (size (obj.cdata, 1) == 1
-                             || size (obj.cdata, 1) == 3)))
+                     && (columns (obj.cdata) == nc
+                         && (rows (obj.cdata) == 1
+                             || rows (obj.cdata) == 3)))
                    ccol = cdat (:, i);
                  elseif (ndims (obj.cdata) == 2
-                         && (size (obj.cdata, 1) == nc
-                             && (size (obj.cdata, 2) == 1
-                                 || size (obj.cdata, 2) == 3)))
+                         && (rows (obj.cdata) == nc
+                             && (columns (obj.cdata) == 1
+                                 || columns (obj.cdata) == 3)))
                    ccol = cdat (i, :);
                  elseif (ndims (obj.cdata) == 3)
                    ccol = permute (cdat (:, i, :), [1, 3, 2]);
                  else
                    ccol = cdat;
                  endif
                  if (strncmp (ec, "flat", 4))
                    if (numel (ccol) == 3)
@@ -1310,17 +1310,17 @@ function __go_draw_axes__ (h, plot_strea
             units = "";
           endif
 
           if (isnumeric (color))
             colorspec = get_text_colorspec (color, mono);
           endif
 
           if (ischar (obj.string))
-            num_lines = size (obj.string, 1);
+            num_lines = rows (obj.string);
           else
             num_lines = numel (obj.string);
           endif
           switch valign
             ## Text offset in characters. This relies on gnuplot for font metrics.
             case "top"
               dy = -0.5;
             case "cap"
@@ -1725,19 +1725,19 @@ function __go_draw_axes__ (h, plot_strea
 
   else
     print_usage ();
   endif
 
 endfunction
 
 function x = flip (x)
-  if (size (x, 1) == 1)
+  if (rows (x) == 1)
     x = fliplr (x);
-  elseif (size (x, 2) == 1 || ischar (x))
+  elseif (columns (x) == 1 || ischar (x))
     x = flipud (x);
   else
     x = flipud (fliplr (x));
   endif
 endfunction
 
 function fontspec = create_fontspec (f, s, gp_term)
   if (strcmp (f, "*") || strcmp (gp_term, "tikz"))
@@ -2201,17 +2201,17 @@ function do_tics_1 (ticmode, tics, mtics
 endfunction
 
 function ticklabel = ticklabel_to_cell (ticklabel)
   if (isnumeric (ticklabel))
     ## Use upto 5 significant digits
     ticklabel = num2str (ticklabel(:), 5);
   endif
   if (ischar (ticklabel))
-    if (size (ticklabel, 1) == 1 && any (ticklabel == "|"))
+    if (rows (ticklabel) == 1 && any (ticklabel == "|"))
       ticklabel = strsplit (ticklabel, "|");
     else
       ticklabel = cellstr (ticklabel);
     endif
   elseif (isempty (ticklabel))
     ticklabel = {""};
   else
     ticklabel = ticklabel;
@@ -2271,17 +2271,17 @@ function [str, f, s] = __maybe_munge_tex
     s = 10;
     fnt = f;
     it = false;
     bld = false;
   endif
 
   ## The text object maybe multiline, and may be of any class
   str = getfield (obj, fld);
-  if (ischar (str) && size (str, 1) > 1)
+  if (ischar (str) && rows (str) > 1)
     str = cellstr (str);
   elseif (isnumeric (str))
     str = cellstr (num2str (str(:)));
   endif
   if (iscellstr (str))
     for n = 1:numel (str)
       if (isnumeric (str{n}))
         str{n} = num2str (str{n});
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -34,17 +34,17 @@ function [Vxyz, idx, frac] = __interp_cu
     y = y(:);
     z = z(:);
   else
     error ("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
     error ("__interp_cube__: VAL has wrong dimensions");
   endif
-  if (size (v, 2) != 3)
+  if (columns (v) != 3)
     error ( "v has to be N*3 matrix");
   endif
   if (!ischar (req))
    error ("__interp_cube__: Invalid request parameter use 'values', 'normals' or 'normals8'");
   endif
   if (isempty (v))
     Vxyz = idx = frac = [];
     return
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -164,31 +164,31 @@ function [T, p, col] = __marching_cube__
     id_ = ccedge(id__, 2);
     [ix iy iz] = ind2sub (size (cc), id_);
     id_c = sub2ind (size (c), ix, iy, iz);
     id1 = id_c + offset(edges(jj, 1));
     id2 = id_c + offset(edges(jj, 2));
     if (calc_cols)
       pp(id__, 1:5, jj) = [vertex_interp(iso, xx(id1), yy(id1), zz(id1), ...
         xx(id2), yy(id2), zz(id2), c(id1), c(id2), colors(id1), colors(id2)), ...
-        (1:size (id_, 1))' + ix_offset ];
+        (1:rows (id_))' + ix_offset ];
     else
       pp(id__, 1:4, jj) = [vertex_interp(iso, xx(id1), yy(id1), zz(id1), ...
         xx(id2), yy(id2), zz(id2), c(id1), c(id2)), ...
-        (1:size (id_, 1))' + ix_offset ];
+        (1:rows (id_))' + ix_offset ];
     endif
-    ix_offset += size (id_, 1);
+    ix_offset += rows (id_);
   endfor
 
   ## phase III: calculate the triangulation from the point list
   T = [];
   tri = tri_table(cc(id)+1, :);
   for jj=1:3:15
     id_ = find (tri(:, jj)>0);
-    p = [id_, lindex*ones(size (id_, 1), 1),tri(id_, jj:jj+2)];
+    p = [id_, lindex*ones(rows (id_), 1),tri(id_, jj:jj+2)];
     if (!isempty (p))
       p1 = sub2ind (size (pp), p(:,1), p(:,2), p(:,3));
       p2 = sub2ind (size (pp), p(:,1), p(:,2), p(:,4));
       p3 = sub2ind (size (pp), p(:,1), p(:,2), p(:,5));
       T = [T; pp(p1), pp(p2), pp(p3)];
     endif
   endfor
 
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -92,31 +92,31 @@ function [h, failed] = __patch__ (p, var
 
       if (isvector (x))
         x = x(:);
         y = y(:);
         z = z(:);
         if (isnumeric (c))
           if (isvector (c) && numel (c) == numel (x))
             c = c(:);
-          elseif (size (c, 1) != numel (x) && size (c, 2) == numel (x))
+          elseif (rows (c) != numel (x) && columns (c) == numel (x))
             c = c.';
           endif
         endif
       endif
       args{1} = "xdata";
       args{2} = x;
       args{3} = "ydata";
       args{4} = y;
       args{5} = "zdata";
       args{6} = z;
 
       if (isnumeric (c))
 
-        if (ndims (c) == 3 && size (c, 2) == 1)
+        if (ndims (c) == 3 && columns (c) == 1)
           c = permute (c, [1, 3, 2]);
         endif
 
         if (isvector (c) && numel (c) == columns (x))
           if (isnan (c))
             args{7} = "facecolor";
             args{8} = [1, 1, 1];
             args{9} = "cdata";
@@ -131,24 +131,24 @@ function [h, failed] = __patch__ (p, var
           endif
         elseif (isvector (c) && numel (c) == 3)
           args{7} = "facecolor";
           args{8} = c;
           args{9} = "cdata";
           args{10} = [];
         elseif (ndims (c) == 3 && size (c, 3) == 3)
           ## CDATA is specified as RGB data
-          if ((size (c, 1) == 1 && size (c, 2) == 1) ...
-              || (size (c, 1) == 1 && size (c, 2) == columns (x)))
+          if ((rows (c) == 1 && columns (c) == 1) ...
+              || (rows (c) == 1 && columns (c) == columns (x)))
             ## Single patch color or per-face color
             args{7} = "facecolor";
             args{8} = "flat";
             args{9} = "cdata";
             args{10} = c;
-          elseif (size (c, 1) == rows (x) && size (c, 2) == columns (x))
+          elseif (rows (c) == rows (x) && columns (c) == columns (x))
             ## Per-vertex color
             args{7} = "facecolor";
             args{8} = "interp";
             args{9} = "cdata";
             agrs{10} = c;
           else
             error ("patch: color value not valid");
           endif
@@ -247,17 +247,17 @@ function args = setdata (args)
     if (!isempty (fvc))
       fc = "flat";
     else
       fc = [0, 1, 0];
     endif
     args = {"facecolor", fc, args{:}};
   endif
 
-  nc = size (faces, 1);
+  nc = rows (faces);
   idx = faces .';
   t1 = isnan (idx);
   for i = find (any (t1))
     first_idx_in_column = find (t1(:,i), 1);
     idx(first_idx_in_column:end,i) = idx(first_idx_in_column-1,i);
   endfor
   x = reshape (vert(:,1)(idx), size (idx));
   y = reshape (vert(:,2)(idx), size (idx));
@@ -271,17 +271,17 @@ function args = setdata (args)
     c = reshape (fvc, [1, size(fvc)]);
   else
     if (columns (fvc) == 3)
       c = cat (3, reshape (fvc(idx, 1), size (idx)),
                reshape (fvc(idx, 2), size (idx)),
                reshape (fvc(idx, 3), size (idx)));
     elseif (isempty (fvc))
       c = [];
-    else ## if (size (fvc, 2) == 1)
+    else ## if (columnns (fvc) == 1)
       c = permute (fvc(faces), [2, 1]);
     endif
   endif
   args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};
 endfunction
 
 function args = setvertexdata (args)
   args = delfields (args, {"vertices", "faces", "facevertexcdata"});
@@ -331,17 +331,17 @@ function args = setvertexdata (args)
     vert = [x(:), y(:), z(:)];
   else
     vert = [x(:), y(:)];
   endif
   faces = reshape (1:numel (x), nr, nc);
   faces = faces';
 
   if (ndims (c) == 3)
-    fvc = reshape (c, size (c, 1) * size (c, 2), size (c, 3));
+    fvc = reshape (c, rows (c) * columns (c), size (c, 3));
   else
     fvc = c(:);
   endif
 
   args = {"faces", faces, "vertices", vert, "facevertexcdata", fvc, args{:}};
 endfunction
 
 function update_data (h, d)
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -564,17 +564,17 @@ function [papersize, paperposition] = gs
   else
     paperposition = convert2points (paperposition, paperunits);
   endif
 
   ## FIXME - This will be obsoleted by listeners for paper properties.
   ##         Papersize is tall when portrait,and wide when landscape.
   if ((papersize(1) > papersize(2) && strcmpi (paperorientation, "portrait"))
       || (papersize(1) < papersize(2) && strcmpi (paperorientation, "landscape")))
-    papersize = papersize ([2,1]);
+    papersize = papersize([2,1]);
     paperposition = paperposition([2,1,4,3]);
   endif
 
   if ((! strcmp (papertype, "<custom>")) && (strcmp (paperorientation, "portrait")))
     ## For portrait use the ghostscript name
     papersize = papertype;
     papersize(papersize=="-") = "";
     papersize = strrep (papersize, "us", "");
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -38,19 +38,19 @@ function hg = __quiver__ (varargin)
   endfor
 
   ioff = 3;
   if (nargin < (6 + is3d) || firstnonnumeric < (6 + is3d))
     u = varargin{ioff++};
     v = varargin{ioff++};
     if (is3d)
       w = varargin{ioff++};
-      [x, y, z] = meshgrid (1:size (u,2), 1:size (u,1), 1:max (size (w)));
+      [x, y, z] = meshgrid (1:columns (u), 1:rows (u), 1:max (size (w)));
     else
-      [x, y] = meshgrid (1:size (u,2), 1:size (u,1));
+      [x, y] = meshgrid (1:columns (u), 1:rows (u));
     endif
     if (nargin >= ioff && isnumeric (varargin{ioff})
         && isscalar (varargin{ioff}))
       autoscale = varargin{ioff++};
     endif
   else
     x = varargin{ioff++};
     y = varargin{ioff++};
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -75,17 +75,17 @@ function [thout, rout] = rose (varargin)
   [nn, xx] = hist (th, x);
   xx = xx(:).';
   if (isvector (nn))
     nn = nn (:);
   endif
   x1 = xx(1:end-1) + diff (xx, 1) / 2;
   x1 = [x1 ; x1; x1; x1](:);
   th = [0; 0; x1; 2*pi ; 2*pi];
-  r = zeros (4 * size (nn, 1), size (nn, 2));
+  r = zeros (4 * rows (nn), columns (nn));
   r(2:4:end, :) = nn;
   r(3:4:end, :) = nn;
 
   if (nargout < 2)
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
diff --git a/scripts/plot/shrinkfaces.m b/scripts/plot/shrinkfaces.m
--- a/scripts/plot/shrinkfaces.m
+++ b/scripts/plot/shrinkfaces.m
@@ -99,36 +99,36 @@ function [nf, nv] = shrinkfaces (varargi
   else
     print_usage ();
   endif
   
   if (! isscalar (sf) || sf <= 0)
     error ("shrinkfaces: scale factor must be a positive scalar")
   endif
 
-  n = size (vertices, 2);
+  n = columns (vertices);
   if (n < 2 || n > 3)
     error ("shrinkfaces: only 2D and 3D patches are supported")
   endif
 
-  m = size (faces, 2);
+  m = columns (faces);
   if (m < 3)
     error ("shrinkfaces: faces must consist of at least 3 vertices")
   endif
 
   v = vertices(faces'(:), :);
-  if (isempty (colors) || size (colors, 1) == size (faces, 1))
+  if (isempty (colors) || rows (colors) == rows (faces))
     c = colors;
-  elseif (size (colors, 1) == size (vertices, 1))
+  elseif (rows (colors) == rows (vertices))
     c = colors(faces'(:), :);
   else
     ## Discard inconsistent color data.
     c = [];
   endif
-  sv = size (v, 1);
+  sv = rows (v);
   ## we have to deal with a probably very large number of vertices, so
   ## use sparse we use as midpoint (1/m, ..., 1/m) in generalized
   ## barycentric coordinates.
   midpoints = full (kron ( speye (sv / m), ones (m, m) / m) * sparse (v));
   v = sqrt (sf) * (v - midpoints) + midpoints;
   f = reshape (1:sv, m, sv / m)';
   
   switch (nargout)
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -151,17 +151,17 @@ function [h, xs, ys] = __stairs__ (doplo
       endif
     endif
   endfor
 
   if (doplot)
     h = [];
     unwind_protect
       hold_state = get (gca (), "nextplot");
-      for i = 1 : size(y, 2)
+      for i = 1 : columns (y)
         hg = hggroup ();
         h = [h; hg];
         args = __add_datasource__ ("stairs", hg, {"x", "y"}, varargin{:});
 
         addproperty ("xdata", hg, "data", x(:,i).');
         addproperty ("ydata", hg, "data", y(:,i).');
 
         addlistener (hg, "xdata", @update_data);
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {[@var{nx}, @var{ny}, @var{nz}] =} surfnorm (@dots{})
 ## @deftypefnx {Function File} {} surfnorm (@var{h}, @dots{})
 ## Find the vectors normal to a meshgridded surface.  The meshed gridded
 ## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and
 ## @var{y} are not defined, then it is assumed that they are given by
 ##
 ## @example
 ## @group
-## [@var{x}, @var{y}] = meshgrid (1:size (@var{z}, 1),
-##                    1:size (@var{z}, 2));
+## [@var{x}, @var{y}] = meshgrid (1:rows (@var{z}),
+##                    1:columns (@var{z}));
 ## @end group
 ## @end example
 ##
 ## If no return arguments are requested, a surface plot with the normal
 ## vectors to the surface is plotted.  Otherwise the components of the normal
 ## vectors at the mesh gridded points are returned in @var{nx}, @var{ny},
 ## and @var{nz}.
 ##
diff --git a/scripts/plot/tetramesh.m b/scripts/plot/tetramesh.m
--- a/scripts/plot/tetramesh.m
+++ b/scripts/plot/tetramesh.m
@@ -65,17 +65,17 @@ function h = tetramesh (varargin)
   if (! ismatrix (X) || columns (X) != 3)
     error ("tetramesh: X must be a n-by-3 matrix");
   endif
 
   size_T = rows (T);
   colmap = colormap ();
   
   if (length (reg) < 3)
-    size_colmap = size (colmap, 1);
+    size_colmap = rows (colmap);
     C = mod ((1:size_T)' - 1, size_colmap) + 1;
     if (size_T < size_colmap && size_T > 1) 
       ## expand to the available range of colors
       C = floor ((C - 1) * (size_colmap - 1) / (size_T - 1)) + 1;
     endif
   else
     C = reg{3};
     if (! isvector (C) || size_T != length (C))
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -52,17 +52,17 @@ function h = text (varargin)
 
     label = varargin{offset};
     varargin(1:offset) = [];
 
     nx = numel (x);
     ny = numel (y);
     nz = numel (z);
     if (ischar (label) || isnumeric (label))
-      nt = size (label, 1);
+      nt = rows (label);
       if (nx > 1 && nt == 1)
         ## Mutiple text objects with same string
         label = repmat ({label}, [nx, 1]);
         nt = nx;
       elseif (nx > 1 && nt == nx)
         ## Mutiple text objects with different strings
         label = cellstr (label);
       elseif (ischar (label))
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -63,17 +63,17 @@ function [b, r] = deconv (y, a)
     b = 0;
   endif
 
   lc = la + length (b) - 1;
   if (ly == lc)
     r = y - conv (a, b);
   else
     ## Respect the orientation of Y"
-    if (size (y, 1) <= size (y, 2))
+    if (rows (y) <= columns (y))
       r = [(zeros (1, lc - ly)), y] - conv (a, b);
     else
       r = [(zeros (lc - ly, 1)); y] - conv (a, b);
     endif
     if (ly < la)
       ## Trim the remainder is equal to the length of Y.
       r = r(end-(length(y)-1):end);
     endif
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -95,17 +95,17 @@ function ret = spline (x, y, xi)
   endif
 
   for k = (1:columns (a))(any (isnan (a)))
     ok = ! isnan (a(:,k));
     a(!ok,k) = spline (x(ok), a(ok,k), x(!ok));
   endfor
 
   complete = false;
-  if (size (a, 1) == n + 2)
+  if (rows (a) == n + 2)
     complete = true;
     dfs = a(1,:);
     dfe = a(end,:);
     a = a(2:end-1,:);
   endif
 
   if (! issorted (x))
     [x, idx] = sort (x);
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -70,17 +70,17 @@ function [c, ia, ib] = intersect (a, b, 
       len_a = length (a);
     endif
 
     if (nargout > 1)
       ia = ja(ic(ii));                  ## a(ia) == c
       ib = jb(ic(ii+1) - len_a);        ## b(ib) == c
     endif
 
-    if (nargin == 2 && (size (b, 1) == 1 || size (a, 1) == 1))
+    if (nargin == 2 && (rows (b) == 1 || rows (a) == 1))
       c = c.';
     endif
   endif
 
 endfunction
 
 
 %!# Test the routine for index vectors ia and ib
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -77,17 +77,17 @@ function [c, i] = setdiff (a, b, varargi
       else
         dups = find (dummy(1:end-1) == dummy(2:end));
       endif
       c(idx(dups)) = [];
       if (nargout > 1)
         i(idx(dups)) = [];
       endif
       ## Reshape if necessary.
-      if (size (c, 1) != 1 && size (b, 1) == 1)
+      if (rows (c) != 1 && rows (b) == 1)
         c = c.';
       endif
     endif
   endif
 
 endfunction
 
 
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -74,17 +74,17 @@ function [c, ia, ib] = setxor (a, b, var
         idx = find (strcmp (c(1:n-1), c(2:n)));
       else
         idx = find (c(1:n-1) == c(2:n));
       endif
       if (! isempty (idx))
         c([idx, idx+1]) = [];
         i([idx, idx+1]) = [];
       endif
-      if (size (a, 1) == 1 || size (b, 1) == 1)
+      if (rows (a) == 1 || rows (b) == 1)
         c = c.';
       endif
     endif
   endif
   if (nargout > 1)
     ia = ia(i(i <= na));
     ib = ib(i(i > na) - na);
   endif
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -60,17 +60,17 @@ function [y, ia, ib] = union (a, b, vara
     print_usage ();
   endif
 
   [a, b] = validargs ("union", a, b, varargin{:});
 
   if (nargin == 2)
     y = [a(:); b(:)];
     na = numel (a); nb = numel (b);
-    if (size (a, 1) == 1 || size (b, 1) == 1)
+    if (rows (a) == 1 || rows (b) == 1)
       y = y.';
     endif
   else
     y = [a; b];
     na = rows (a); nb = rows (b);
   endif
 
   if (nargout == 1)
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -103,17 +103,17 @@ function [pxx, f] = periodogram (x, vara
   if (ischar (fs))
     range = fs;
     fs = [];
   endif;
 
   if (!  isempty (window))
     if (all (size (x) == size (window)))
       x .*= window;
-    elseif (size (x, 1) == size (window, 1) && size (window, 2) == 1)
+    elseif (rows (x) == rows (window) && columns (window) == 1)
       x .*= window (:,ones (1,c));
     endif;
   endif
 
   if (numel (nfft)>1)
     error ("nfft must be scalar");
   endif
   if (isempty (nfft))
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -236,17 +236,17 @@ function [x, flag, relres, iter, resvec,
 
   if (nargin < 6 || isempty (m2))
      exist_m2 = 0;
   else
      exist_m2 = 1;
   endif
 
   if (nargin < 4 || isempty (maxit))
-    maxit = min (size (b, 1), 20);
+    maxit = min (rows (b), 20);
   endif
 
   maxit += 2;
 
   if (nargin < 3 || isempty (tol))
     tol = 1e-6;
   endif
 
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -47,17 +47,17 @@ function A = perms (v)
 
   if (n == 0)
     A = [];
   else
     A = v(1);
     for j = 2:n
       B = A;
       A = zeros (prod (2:j), n, class (v));
-      k = size (B, 1);
+      k = rows (B);
       idx = 1:k;
       for i = j:-1:1
         A(idx,1:i-1) = B(:,1:i-1);
         A(idx,i) = v(j);
         A(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
     endfor
