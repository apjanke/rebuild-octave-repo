# HG changeset patch
# User Marco Caliari <marco.caliari@univr.it>
# Date 1530081415 -7200
#      Wed Jun 27 08:36:55 2018 +0200
# Node ID 3b6691ff0f594104e12338b335f905caeb614d07
# Parent  038fb01854a0cc7e81da3bac41cf148a51346444
Fix eigs for generalized problems with user defined function (bug #54167).

* eigs-base.cc (EigsRealSymmetricFunc, EigsRealNonSymmetricFunc,
 EigsComplexNonSymmetricFunc): Add B as input argument and manage mode = 1 and
mode = 3.

* eigs-base.h: Declare EigsRealSymmetricFunc, EigsRealNonSymmetricFunc, and
EigsComplexNonSymmetricFunc template functions.

* __eigs__.cc: Call EigsRealSymmetricFunc, EigsRealNonSymmetricFunc, and
EigsComplexNonSymmetricFunc  with the new input argument B.

* scripts/sparse/eigs.m: Add BIST tests.

diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -177,16 +177,17 @@ Undocumented internal function.
   bool have_b = false;
   bool have_a_fun = false;
   bool a_is_complex = false;
   bool b_is_complex = false;
   bool symmetric = false;
   bool sym_tested = false;
   bool cholB = false;
   bool a_is_sparse = false;
+  bool b_is_sparse = false;
   ColumnVector permB;
   int arg_offset = 0;
   double tol = std::numeric_limits<double>::epsilon ();
   int maxit = 300;
   int disp = 0;
   octave_idx_type p = -1;
   ColumnVector resid;
   ComplexColumnVector cresid;
@@ -260,23 +261,37 @@ Undocumented internal function.
   // Note hold off reading B until later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
   if (nargin > 1 + arg_offset
       && ! (args(1 + arg_offset).is_real_scalar ()))
     {
       if (args(1+arg_offset).iscomplex ())
         {
           b_arg = 1+arg_offset;
+          if (args(b_arg).issparse ())
+            {
+              bscm = (args(b_arg).sparse_complex_matrix_value ());
+              b_is_sparse = true;
+            }
+          else
+            bcm = (args(b_arg).complex_matrix_value ());
           have_b = true;
           b_is_complex = true;
           arg_offset++;
         }
       else
         {
           b_arg = 1+arg_offset;
+          if (args(b_arg).issparse ())
+            {
+              bsmm = (args(b_arg).sparse_matrix_value ());
+              b_is_sparse = true;
+            }
+          else
+            bmm = (args(b_arg).matrix_value ());
           have_b = true;
           arg_offset++;
         }
     }
 
   if (nargin > (1+arg_offset))
     k = args(1+arg_offset).nint_value ();
 
@@ -369,24 +384,24 @@ Undocumented internal function.
       else
         symmetric = amm.issymmetric ();
     }
 
   if (have_b)
     {
       if (a_is_complex || b_is_complex)
         {
-          if (a_is_sparse)
+          if (b_is_sparse)
             bscm = args(b_arg).sparse_complex_matrix_value ();
           else
             bcm = args(b_arg).complex_matrix_value ();
         }
       else
         {
-          if (a_is_sparse)
+          if (b_is_sparse)
             bsmm = args(b_arg).sparse_matrix_value ();
           else
             bmm = args(b_arg).matrix_value ();
         }
     }
 
   // Mode 1 for SM mode seems unstable for some reason.
   // Use Mode 3 instead, with sigma = 0.
@@ -395,20 +410,28 @@ Undocumented internal function.
 
   octave_idx_type nconv;
   if (a_is_complex || b_is_complex)
     {
       ComplexMatrix eig_vec;
       ComplexColumnVector eig_val;
 
       if (have_a_fun)
-        nconv = EigsComplexNonSymmetricFunc
-                (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
-                 eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
-                 disp, maxit);
+        {
+          if (b_is_sparse)
+            nconv = EigsComplexNonSymmetricFunc
+              (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+               eig_val, bscm, permB, cresid, octave_stdout, tol,
+               (nargout > 1), cholB, disp, maxit);
+          else
+            nconv = EigsComplexNonSymmetricFunc
+              (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+               eig_val, bcm, permB, cresid, octave_stdout, tol,
+               (nargout > 1), cholB, disp, maxit);
+        }
       else if (have_sigma)
         {
           if (a_is_sparse)
             nconv = EigsComplexNonSymmetricMatrixShift
                     (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
                      cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
                      maxit);
           else
@@ -438,20 +461,28 @@ Undocumented internal function.
     }
   else if (sigmai != 0.)
     {
       // Promote real problem to a complex one.
       ComplexMatrix eig_vec;
       ComplexColumnVector eig_val;
 
       if (have_a_fun)
-        nconv = EigsComplexNonSymmetricFunc
-                (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec,
-                 eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
-                 disp, maxit);
+        {
+          if (b_is_sparse)
+            nconv = EigsComplexNonSymmetricFunc
+              (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+               eig_val, bscm, permB, cresid, octave_stdout, tol,
+               (nargout > 1), cholB, disp, maxit);
+          else
+            nconv = EigsComplexNonSymmetricFunc
+              (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+               eig_val, bcm, permB, cresid, octave_stdout, tol,
+               (nargout > 1), cholB, disp, maxit);
+        }
       else
         {
           if (a_is_sparse)
             nconv = EigsComplexNonSymmetricMatrixShift
                     (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
                      eig_val, SparseComplexMatrix (bsmm), permB, cresid,
                      octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
           else
@@ -469,20 +500,28 @@ Undocumented internal function.
   else
     {
       if (symmetric)
         {
           Matrix eig_vec;
           ColumnVector eig_val;
 
           if (have_a_fun)
-            nconv = EigsRealSymmetricFunc
-                    (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
-                     eig_val, resid, octave_stdout, tol, (nargout > 1),
-                     cholB, disp, maxit);
+            {
+              if (b_is_sparse)
+                nconv = EigsRealSymmetricFunc
+                       (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                        eig_val, bsmm, permB, resid, octave_stdout, tol,
+                        (nargout > 1), cholB, disp, maxit);
+              else
+                nconv = EigsRealSymmetricFunc
+                       (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                        eig_val, bmm, permB, resid, octave_stdout, tol,
+                        (nargout > 1), cholB, disp, maxit);
+            }
           else if (have_sigma)
             {
               if (a_is_sparse)
                 nconv = EigsRealSymmetricMatrixShift
                         (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
                          permB, resid, octave_stdout, tol, (nargout > 1),
                          cholB, disp, maxit);
               else
@@ -511,20 +550,28 @@ Undocumented internal function.
             retval = ovl (eig_vec, DiagMatrix (eig_val), double (info));
         }
       else
         {
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
           if (have_a_fun)
-            nconv = EigsRealNonSymmetricFunc
-                    (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
-                     eig_val, resid, octave_stdout, tol, (nargout > 1),
-                     cholB, disp, maxit);
+            {
+              if (b_is_sparse)
+                nconv = EigsRealNonSymmetricFunc
+                        (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                         eig_val, bsmm, permB, resid, octave_stdout, tol,
+                         (nargout > 1), cholB, disp, maxit);
+              else
+                nconv = EigsRealNonSymmetricFunc
+                        (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                         eig_val, bmm, permB, resid, octave_stdout, tol,
+                         (nargout > 1), cholB, disp, maxit);
+            }
           else if (have_sigma)
             {
               if (a_is_sparse)
                 nconv = EigsRealNonSymmetricMatrixShift
                         (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
                          permB, resid, octave_stdout, tol, (nargout > 1),
                          cholB, disp, maxit);
               else
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -1197,33 +1197,39 @@ EigsRealSymmetricMatrixShift (const M& m
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
+template <typename M>
 octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
                        const std::string& _typ, double sigma,
                        octave_idx_type k_arg, octave_idx_type p_arg,
                        octave_idx_type& info, Matrix& eig_vec,
-                       ColumnVector& eig_val, ColumnVector& resid,
+                       ColumnVector& eig_val, const M& _b,
+                       ColumnVector& permB, ColumnVector& resid,
                        std::ostream& os, double tol, bool rvec,
-                       bool /* cholB */, int disp, int maxit)
+                       bool cholB, int disp, int maxit)
 {
   F77_INT n = octave::to_f77_int (n_arg);
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
+  M b(_b);
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
+  bool have_b = ! b.isempty ();
+  bool note3 = false;
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
+  M bt;
 
   if (resid.isempty ())
     {
       std::string rand_dist = octave::rand::distribution ();
       octave::rand::distribution ("uniform");
       resid = ColumnVector (octave::rand::vector (n));
       octave::rand::distribution (rand_dist);
     }
@@ -1249,40 +1255,91 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p > n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than or equal to n");
 
+  if (have_b && cholB && ! permB.isempty ())
+    {
+      // Check the we really have a permutation vector
+      if (permB.numel () != n)
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (F77_INT i = 0; i < n; i++)
+        {
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+        }
+    }
+
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
         (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
         (*current_liboctave_error_handler)
           ("eigs: invalid sigma value for real symmetric problem");
 
+      if (typ != "SM" && have_b)
+        note3 = true;
+
       if (typ == "SM")
         {
           typ = "LM";
           sigma = 0.;
           mode = 3;
+          if (have_b)
+            bmat = 'G';
         }
     }
   else if (! std::abs (sigma))
-    typ = "SM";
+    {
+      typ = "SM";
+      if (have_b)
+        bmat = 'G';
+    }
   else
     {
       typ = "LM";
       mode = 3;
+      if (have_b)
+        bmat = 'G';
+    }
+
+  if (mode == 1 && have_b)
+    {
+      // See Note 3 dsaupd
+      note3 = true;
+      if (cholB)
+        {
+          bt = b;
+          b = b.transpose ();
+          if (permB.isempty ())
+            {
+              permB = ColumnVector (n);
+              for (F77_INT i = 0; i < n; i++)
+                permB(i) = i;
+            }
+        }
+      else
+        {
+          if (! make_cholb (b, bt, permB))
+            (*current_liboctave_error_handler)
+              ("eigs: The matrix B is not positive definite");
+        }
     }
 
   Array<F77_INT> ip (dim_vector (11, 1));
   F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
@@ -1347,30 +1404,95 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
-          double *ip2 = workd + iptr(0) - 1;
-          ColumnVector x(n);
-
-          for (F77_INT i = 0; i < n; i++)
-            x(i) = *ip2++;
-
-          ColumnVector y = fun (x, err);
-
-          if (err)
-            return false;
-
-          ip2 = workd + iptr(1) - 1;
-          for (F77_INT i = 0; i < n; i++)
-            *ip2++ = y(i);
+          if (have_b)
+            {
+              if (mode == 1) // regular mode with factorized B
+                {
+                  Matrix mtmp (n,1);
+                  for (F77_INT i = 0; i < n; i++)
+                    mtmp(i,0) = workd[i + iptr(0) - 1];
+
+                  mtmp = utsolve (bt, permB, mtmp);
+                  ColumnVector y = fun (mtmp, err);
+
+                  if (err)
+                    return false;
+
+                  mtmp = ltsolve (b, permB, y);
+
+                  for (F77_INT i = 0; i < n; i++)
+                    workd[i+iptr(1)-1] = mtmp(i,0);
+                }
+              else // shift-invert mode
+                {
+                  if (ido == -1)
+                    {
+                      OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+                      vector_product (b, workd+iptr(0)-1, dtmp);
+
+                      ColumnVector x(n);
+
+                      for (F77_INT i = 0; i < n; i++)
+                        x(i) = dtmp[i];
+
+                      ColumnVector y = fun (x, err);
+
+                      if (err)
+                        return false;
+
+                      double *ip2 = workd + iptr(1) - 1;
+                      for (F77_INT i = 0; i < n; i++)
+                        ip2[i] = y(i);
+                    }
+                  else if (ido == 2)
+                    vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
+                  else
+                    {
+                      double *ip2 = workd+iptr(2)-1;
+                      ColumnVector x(n);
+
+                      for (F77_INT i = 0; i < n; i++)
+                        x(i) = *ip2++;
+
+                      ColumnVector y = fun (x, err);
+
+                      if (err)
+                        return false;
+
+                      ip2 = workd + iptr(1) - 1;
+                      for (F77_INT i = 0; i < n; i++)
+                        *ip2++ = y(i);
+                     }
+                }
+            }
+          else
+            {
+              double *ip2 = workd + iptr(0) - 1;
+              ColumnVector x(n);
+
+              for (F77_INT i = 0; i < n; i++)
+                x(i) = *ip2++;
+
+              ColumnVector y = fun (x, err);
+
+              if (err)
+                return false;
+
+              ip2 = workd + iptr(1) - 1;
+              for (F77_INT i = 0; i < n; i++)
+                *ip2++ = y(i);
+            }
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
           break;
@@ -1403,17 +1525,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (info2 == 0)
     {
       for (F77_INT i = ip(4); i < k; i++)
         d[i] = octave::numeric_limits<double>::NaN ();
       F77_INT k2 = ip(4) / 2;
-      if (typ != "SM" && typ != "BE")
+      if (mode == 3 || (mode == 1 && typ != "SM" && typ != "BE"))
         {
           for (F77_INT i = 0; i < k2; i++)
             {
               double dtmp = d[i];
               d[i] = d[ip(4) - i - 1];
               d[ip(4) - i - 1] = dtmp;
             }
         }
@@ -1421,17 +1543,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       if (rvec)
         {
           for (F77_INT i = ip(4); i < k; i++)
             {
               F77_INT off1 = i * n;
               for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = octave::numeric_limits<double>::NaN ();
             }
-          if (typ != "SM" && typ != "BE")
+          if (mode == 3 || (mode == 1 && typ != "SM" && typ != "BE"))
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (F77_INT i = 0; i < k2; i++)
                 {
                   F77_INT off1 = i * n;
                   F77_INT off2 = (ip(4) - i - 1) * n;
 
@@ -1443,17 +1565,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
                   for (F77_INT j = 0; j < n; j++)
                     z[off1 + j] = z[off2 + j];
 
                   for (F77_INT j = 0; j < n; j++)
                     z[off2 + j] = dtmp[j];
                 }
             }
-        }
+          if (note3)
+            eig_vec = utsolve (bt, permB, eig_vec);
+         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 template <typename M>
@@ -2174,34 +2298,40 @@ EigsRealNonSymmetricMatrixShift (const M
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
+template <typename M>
 octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
                           const std::string& _typ, double sigmar,
                           octave_idx_type k_arg, octave_idx_type p_arg,
                           octave_idx_type& info, ComplexMatrix& eig_vec,
-                          ComplexColumnVector& eig_val, ColumnVector& resid,
+                          ComplexColumnVector& eig_val, const M& _b,
+                          ColumnVector& permB, ColumnVector& resid,
                           std::ostream& os, double tol, bool rvec,
-                          bool /* cholB */, int disp, int maxit)
+                          bool cholB, int disp, int maxit)
 {
   F77_INT n = octave::to_f77_int (n_arg);
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
+  M b(_b);
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
-  char bmat = 'I';
   double sigmai = 0.;
   F77_INT mode = 1;
+  bool have_b = ! b.isempty ();
+  bool note3 = false;
+  char bmat = 'I';
   int err = 0;
+  M bt;
 
   if (resid.isempty ())
     {
       std::string rand_dist = octave::rand::distribution ();
       octave::rand::distribution ("uniform");
       resid = ColumnVector (octave::rand::vector (n));
       octave::rand::distribution (rand_dist);
     }
@@ -2227,40 +2357,91 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p > n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than or equal to n");
 
+  if (have_b && cholB && ! permB.isempty ())
+    {
+      // Check the we really have a permutation vector
+      if (permB.numel () != n)
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (F77_INT i = 0; i < n; i++)
+        {
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+        }
+    }
+
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
         (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
         (*current_liboctave_error_handler)
           ("eigs: invalid sigma value for unsymmetric problem");
 
+      if (typ != "SM" && have_b)
+        note3 = true;
+
       if (typ == "SM")
         {
           typ = "LM";
           sigmar = 0.;
           mode = 3;
+          if (have_b)
+            bmat = 'G';
         }
+   }
+  else if (! std::abs (sigmar))
+    {
+      typ = "SM";
+      if (have_b)
+        bmat = 'G';
     }
-  else if (! std::abs (sigmar))
-    typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
+      if (have_b)
+        bmat = 'G';
+    }
+
+  if (mode == 1 && have_b)
+    {
+      // See Note 3 dsaupd
+      note3 = true;
+      if (cholB)
+        {
+          bt = b;
+          b = b.transpose ();
+          if (permB.isempty ())
+            {
+              permB = ColumnVector (n);
+              for (F77_INT i = 0; i < n; i++)
+                permB(i) = i;
+            }
+        }
+      else
+        {
+          if (! make_cholb (b, bt, permB))
+            (*current_liboctave_error_handler)
+              ("eigs: The matrix B is not positive definite");
+        }
     }
 
   Array<F77_INT> ip (dim_vector (11, 1));
   F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
@@ -2329,30 +2510,95 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
-          double *ip2 = workd + iptr(0) - 1;
-          ColumnVector x(n);
-
-          for (F77_INT i = 0; i < n; i++)
-            x(i) = *ip2++;
-
-          ColumnVector y = fun (x, err);
-
-          if (err)
-            return false;
-
-          ip2 = workd + iptr(1) - 1;
-          for (F77_INT i = 0; i < n; i++)
-            *ip2++ = y(i);
+          if (have_b)
+            {
+              if (mode == 1) // regular mode with factorized B
+                {
+                  Matrix mtmp (n,1);
+                  for (F77_INT i = 0; i < n; i++)
+                    mtmp(i,0) = workd[i + iptr(0) - 1];
+
+                  mtmp = utsolve (bt, permB, mtmp);
+                  ColumnVector y = fun (mtmp, err);
+
+                  if (err)
+                    return false;
+
+                  mtmp = ltsolve (b, permB, y);
+
+                  for (F77_INT i = 0; i < n; i++)
+                    workd[i+iptr(1)-1] = mtmp(i,0);
+                }
+              else // shift-invert mode
+                {
+                  if (ido == -1)
+                    {
+                      OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+                      vector_product (b, workd+iptr(0)-1, dtmp);
+
+                      ColumnVector x(n);
+
+                      for (F77_INT i = 0; i < n; i++)
+                        x(i) = dtmp[i];
+
+                      ColumnVector y = fun (x, err);
+
+                      if (err)
+                        return false;
+
+                      double *ip2 = workd + iptr(1) - 1;
+                      for (F77_INT i = 0; i < n; i++)
+                        ip2[i] = y(i);
+                    }
+                  else if (ido == 2)
+                    vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
+                  else
+                    {
+                      double *ip2 = workd+iptr(2)-1;
+                      ColumnVector x(n);
+
+                      for (F77_INT i = 0; i < n; i++)
+                        x(i) = *ip2++;
+
+                      ColumnVector y = fun (x, err);
+
+                      if (err)
+                        return false;
+
+                      ip2 = workd + iptr(1) - 1;
+                      for (F77_INT i = 0; i < n; i++)
+                        *ip2++ = y(i);
+                     }
+                }
+            }
+          else
+            {
+              double *ip2 = workd + iptr(0) - 1;
+              ColumnVector x(n);
+
+              for (F77_INT i = 0; i < n; i++)
+                x(i) = *ip2++;
+
+              ColumnVector y = fun (x, err);
+
+              if (err)
+                return false;
+
+              ip2 = workd + iptr(1) - 1;
+              for (F77_INT i = 0; i < n; i++)
+                *ip2++ = y(i);
+            }
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dnaupd", info);
 
           break;
@@ -2480,16 +2726,18 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
             }
           else
             {
               for (F77_INT ii = ip(4); ii < k; ii++)
                 for (F77_INT jj = 0; jj < n; jj++)
                   eig_vec(jj,ii) =
                     Complex (octave::numeric_limits<double>::NaN (), 0.);
             }
+          if (note3)
+              eig_vec = utsolve (bt, permB, eig_vec);
         }
       if (k0 < k)
         {
           eig_val.resize (k0);
           eig_vec.resize (n, k0);
         }
     }
   else
@@ -3114,34 +3362,39 @@ EigsComplexNonSymmetricMatrixShift (cons
     }
   else
     (*current_liboctave_error_handler)
       ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
+template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n_arg,
                              const std::string& _typ, Complex sigma,
                              octave_idx_type k_arg, octave_idx_type p_arg,
                              octave_idx_type& info, ComplexMatrix& eig_vec,
-                             ComplexColumnVector& eig_val,
-                             ComplexColumnVector& cresid, std::ostream& os,
-                             double tol, bool rvec, bool /* cholB */,
-                             int disp, int maxit)
+                             ComplexColumnVector& eig_val, const M& _b,
+                             ColumnVector& permB, ComplexColumnVector& cresid,
+                             std::ostream& os, double tol, bool rvec,
+                             bool cholB, int disp, int maxit)
 {
   F77_INT n = octave::to_f77_int (n_arg);
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
+  M b(_b);
   std::string typ (_typ);
   bool have_sigma = (std::abs (sigma) ? true : false);
+  F77_INT mode = 1;
+  bool have_b = ! b.isempty ();
+  bool note3 = false;
   char bmat = 'I';
-  F77_INT mode = 1;
   int err = 0;
+  M bt;
 
   if (cresid.isempty ())
     {
       std::string rand_dist = octave::rand::distribution ();
       octave::rand::distribution ("uniform");
       Array<double> rr (octave::rand::vector (n));
       Array<double> ri (octave::rand::vector (n));
       cresid = ComplexColumnVector (n);
@@ -3171,40 +3424,91 @@ EigsComplexNonSymmetricFunc (EigsComplex
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p > n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than or equal to n");
 
+  if (have_b && cholB && ! permB.isempty ())
+    {
+      // Check the we really have a permutation vector
+      if (permB.numel () != n)
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (F77_INT i = 0; i < n; i++)
+        {
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+        }
+    }
+
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
         (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
         (*current_liboctave_error_handler)
           ("eigs: invalid sigma value for complex problem");
 
+      if (typ != "SM" && have_b)
+        note3 = true;
+
       if (typ == "SM")
         {
           typ = "LM";
           sigma = 0.;
           mode = 3;
+          if (have_b)
+            bmat ='G';
         }
     }
   else if (! std::abs (sigma))
-    typ = "SM";
+    {
+      typ = "SM";
+      if (have_b)
+        bmat = 'G';
+    }
   else
     {
       typ = "LM";
       mode = 3;
+      if (have_b)
+        bmat = 'G';
+    }
+
+  if (mode == 1 && have_b)
+    {
+      // See Note 3 dsaupd
+      note3 = true;
+      if (cholB)
+        {
+          bt = b;
+          b = b.hermitian ();
+          if (permB.isempty ())
+            {
+              permB = ColumnVector (n);
+              for (F77_INT i = 0; i < n; i++)
+                permB(i) = i;
+            }
+        }
+      else
+        {
+          if (! make_cholb (b, bt, permB))
+            (*current_liboctave_error_handler)
+              ("eigs: The matrix B is not positive definite");
+        }
     }
 
   Array<F77_INT> ip (dim_vector (11, 1));
   F77_INT *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
@@ -3271,30 +3575,95 @@ EigsComplexNonSymmetricFunc (EigsComplex
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
-          Complex *ip2 = workd + iptr(0) - 1;
-          ComplexColumnVector x(n);
-
-          for (F77_INT i = 0; i < n; i++)
-            x(i) = *ip2++;
-
-          ComplexColumnVector y = fun (x, err);
-
-          if (err)
-            return false;
-
-          ip2 = workd + iptr(1) - 1;
-          for (F77_INT i = 0; i < n; i++)
-            *ip2++ = y(i);
+          if (have_b)
+            {
+              if (mode == 1) // regular mode with factorized B
+                {
+                  ComplexMatrix mtmp (n,1);
+                  for (F77_INT i = 0; i < n; i++)
+                    mtmp(i,0) = workd[i + iptr(0) - 1];
+
+                  mtmp = utsolve (bt, permB, mtmp);
+                  ComplexColumnVector y = fun (mtmp, err);
+
+                  if (err)
+                    return false;
+
+                  mtmp = ltsolve (b, permB, y);
+
+                  for (F77_INT i = 0; i < n; i++)
+                    workd[i+iptr(1)-1] = mtmp(i,0);
+                }
+              else // shift-invert mode
+                {
+                  if (ido == -1)
+                    {
+                      OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
+
+                      vector_product (b, workd+iptr(0)-1, ctmp);
+
+                      ComplexColumnVector x(n);
+
+                      for (F77_INT i = 0; i < n; i++)
+                        x(i) = ctmp[i];
+
+                      ComplexColumnVector y = fun (x, err);
+
+                      if (err)
+                        return false;
+
+                      Complex *ip2 = workd+iptr(1)-1;
+                      for (F77_INT i = 0; i < n; i++)
+                        ip2[i] = y(i);
+                    }
+                  else if (ido == 2)
+                    vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
+                  else
+                    {
+                      Complex *ip2 = workd+iptr(2)-1;
+                      ComplexColumnVector x(n);
+
+                      for (F77_INT i = 0; i < n; i++)
+                        x(i) = *ip2++;
+
+                      ComplexColumnVector y = fun (x, err);
+
+                      if (err)
+                        return false;
+
+                      ip2 = workd + iptr(1) - 1;
+                      for (F77_INT i = 0; i < n; i++)
+                        *ip2++ = y(i);
+                    }
+                }
+            }
+          else
+            {
+              Complex *ip2 = workd + iptr(0) - 1;
+              ComplexColumnVector x(n);
+
+              for (F77_INT i = 0; i < n; i++)
+                x(i) = *ip2++;
+
+              ComplexColumnVector y = fun (x, err);
+
+              if (err)
+                return false;
+
+              ip2 = workd + iptr(1) - 1;
+              for (F77_INT i = 0; i < n; i++)
+                *ip2++ = y(i);
+            }
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in znaupd", info);
 
           break;
@@ -3372,16 +3741,18 @@ EigsComplexNonSymmetricFunc (EigsComplex
                 ctmp[j] = z[off1 + j];
 
               for (F77_INT j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
               for (F77_INT j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
+          if (note3)
+            eig_vec = utsolve (bt, permB, eig_vec);
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
@@ -3404,32 +3775,50 @@ EigsRealSymmetricMatrixShift<Matrix>
   (const Matrix& m, double sigma, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, Matrix& eig_vec,
    ColumnVector& eig_val, const Matrix& _b, ColumnVector& permB,
    ColumnVector& resid, std::ostream& os, double tol, bool rvec,
    bool cholB, int disp, int maxit);
 
 template
 octave_idx_type
+EigsRealSymmetricFunc<Matrix>
+(EigsFunc fun, octave_idx_type n, const std::string& _typ, double sigma,
+   octave_idx_type k, octave_idx_type p, octave_idx_type& info,
+   Matrix& eig_vec, ColumnVector& eig_val, const Matrix& _b,
+   ColumnVector& permB, ColumnVector& resid, std::ostream& os, double tol,
+   bool rvec, bool cholB, int disp, int maxit);
+
+template
+octave_idx_type
 EigsRealNonSymmetricMatrix<Matrix>
   (const Matrix& m, const std::string typ, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const Matrix& _b, ColumnVector& permB,
    ColumnVector& resid, std::ostream& os, double tol, bool rvec,
    bool cholB, int disp, int maxit);
 
 template
 octave_idx_type
 EigsRealNonSymmetricMatrixShift<Matrix>
   (const Matrix& m, double sigmar, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const Matrix& _b, ColumnVector& permB,
    ColumnVector& resid, std::ostream& os, double tol, bool rvec,
    bool cholB, int disp, int maxit);
 
+template
+octave_idx_type
+EigsRealNonSymmetricFunc<Matrix>
+(EigsFunc fun, octave_idx_type n, const std::string& _typ, double sigmar,
+   octave_idx_type k, octave_idx_type p, octave_idx_type& info,
+   ComplexMatrix& eig_vec, ComplexColumnVector& eig_val, const Matrix& _b,
+   ColumnVector& permB, ColumnVector& resid, std::ostream& os, double tol,
+   bool rvec, bool cholB, int disp, int maxit);
+
 // SparseMatrix
 
 template
 octave_idx_type
 EigsRealSymmetricMatrix<SparseMatrix>
   (const SparseMatrix& m, const std::string typ, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, Matrix& eig_vec,
    ColumnVector& eig_val, const SparseMatrix& _b, ColumnVector& permB,
@@ -3442,32 +3831,50 @@ EigsRealSymmetricMatrixShift<SparseMatri
   (const SparseMatrix& m, double sigma, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, Matrix& eig_vec,
    ColumnVector& eig_val, const SparseMatrix& _b, ColumnVector& permB,
    ColumnVector& resid, std::ostream& os, double tol, bool rvec,
    bool cholB, int disp, int maxit);
 
 template
 octave_idx_type
+EigsRealSymmetricFunc<SparseMatrix>
+(EigsFunc fun, octave_idx_type n, const std::string& _typ, double sigma,
+   octave_idx_type k, octave_idx_type p, octave_idx_type& info,
+   Matrix& eig_vec, ColumnVector& eig_val, const SparseMatrix& _b,
+   ColumnVector& permB, ColumnVector& resid, std::ostream& os, double tol,
+   bool rvec, bool cholB, int disp, int maxit);
+
+template
+octave_idx_type
 EigsRealNonSymmetricMatrix<SparseMatrix>
   (const SparseMatrix& m, const std::string typ, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const SparseMatrix& _b, ColumnVector& permB,
    ColumnVector& resid, std::ostream& os, double tol, bool rvec,
    bool cholB, int disp, int maxit);
 
 template
 octave_idx_type
 EigsRealNonSymmetricMatrixShift<SparseMatrix>
   (const SparseMatrix& m, double sigmar, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const SparseMatrix& _b, ColumnVector& permB,
    ColumnVector& resid, std::ostream& os, double tol, bool rvec,
    bool cholB, int disp, int maxit);
 
+template
+octave_idx_type
+EigsRealNonSymmetricFunc<SparseMatrix>
+(EigsFunc fun, octave_idx_type n, const std::string& _typ, double sigmar,
+   octave_idx_type k, octave_idx_type p, octave_idx_type& info,
+   ComplexMatrix& eig_vec, ComplexColumnVector& eig_val,
+   const SparseMatrix& _b, ColumnVector& permB, ColumnVector& resid,
+   std::ostream& os, double tol, bool rvec, bool cholB, int disp, int maxit);
+
 // ComplexMatrix
 
 template
 octave_idx_type
 EigsComplexNonSymmetricMatrix<ComplexMatrix>
   (const ComplexMatrix& m, const std::string typ, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const ComplexMatrix& _b, ColumnVector& permB,
@@ -3478,16 +3885,25 @@ template
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift<ComplexMatrix>
   (const ComplexMatrix& m, Complex sigma, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const ComplexMatrix& _b, ColumnVector& permB,
    ComplexColumnVector& cresid, std::ostream& os, double tol,
    bool rvec, bool cholB, int disp, int maxit);
 
+template
+octave_idx_type
+EigsComplexNonSymmetricFunc<ComplexMatrix>
+(EigsComplexFunc fun, octave_idx_type n, const std::string& _typ, Complex sigma,
+   octave_idx_type k, octave_idx_type p, octave_idx_type& info,
+   ComplexMatrix& eig_vec, ComplexColumnVector& eig_val,
+   const ComplexMatrix& _b, ColumnVector& permB, ComplexColumnVector& cresid,
+   std::ostream& os, double tol, bool rvec, bool cholB, int disp, int maxit);
+
 // SparseComplexMatrix
 
 template
 octave_idx_type
 EigsComplexNonSymmetricMatrix<SparseComplexMatrix>
   (const SparseComplexMatrix& m, const std::string typ, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const SparseComplexMatrix& _b,
@@ -3498,9 +3914,18 @@ template
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift<SparseComplexMatrix>
   (const SparseComplexMatrix& m, Complex sigma, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const SparseComplexMatrix& _b,
    ColumnVector& permB, ComplexColumnVector& cresid, std::ostream& os,
    double tol, bool rvec, bool cholB, int disp, int maxit);
 
+template
+octave_idx_type
+EigsComplexNonSymmetricFunc<SparseComplexMatrix>
+(EigsComplexFunc fun, octave_idx_type n, const std::string& _typ, Complex sigma,
+   octave_idx_type k, octave_idx_type p, octave_idx_type& info,
+   ComplexMatrix& eig_vec, ComplexColumnVector& eig_val,
+   const SparseComplexMatrix& _b, ColumnVector& permB,
+   ComplexColumnVector& cresid, std::ostream& os, double tol, bool rvec,
+   bool cholB, int disp, int maxit);
 #endif
diff --git a/liboctave/numeric/eigs-base.h b/liboctave/numeric/eigs-base.h
--- a/liboctave/numeric/eigs-base.h
+++ b/liboctave/numeric/eigs-base.h
@@ -55,24 +55,26 @@ octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
                               octave_idx_type k, octave_idx_type p,
                               octave_idx_type& info, Matrix& eig_vec,
                               ColumnVector& eig_val, const M& _b,
                               ColumnVector& permB, ColumnVector& resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit);
 
+template <typename M>
 extern OCTAVE_API octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
                        const std::string& _typ, double sigma,
                        octave_idx_type k, octave_idx_type p,
                        octave_idx_type& info, Matrix& eig_vec,
-                       ColumnVector& eig_val, ColumnVector& resid,
+                       ColumnVector& eig_val, const M& _b,
+                       ColumnVector& permB, ColumnVector& resid,
                        std::ostream& os, double tol, bool rvec,
-                       bool /* cholB */, int disp, int maxit);
+                       bool cholB, int disp, int maxit);
 
 template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
                             octave_idx_type k, octave_idx_type p,
                             octave_idx_type& info, ComplexMatrix& eig_vec,
                             ComplexColumnVector& eig_val, const M& _b,
                             ColumnVector& permB, ColumnVector& resid,
@@ -85,24 +87,26 @@ EigsRealNonSymmetricMatrixShift (const M
                                  octave_idx_type k, octave_idx_type p,
                                  octave_idx_type& info,
                                  ComplexMatrix& eig_vec,
                                  ComplexColumnVector& eig_val, const M& _b,
                                  ColumnVector& permB, ColumnVector& resid,
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit);
 
+template <typename M>
 extern OCTAVE_API octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
                           const std::string& _typ, double sigmar,
                           octave_idx_type k, octave_idx_type p,
                           octave_idx_type& info, ComplexMatrix& eig_vec,
-                          ComplexColumnVector& eig_val, ColumnVector& resid,
+                          ComplexColumnVector& eig_val, const M& _b,
+                          ColumnVector& permB, ColumnVector& resid,
                           std::ostream& os, double tol, bool rvec,
-                          bool /* cholB */, int disp, int maxit);
+                          bool cholB, int disp, int maxit);
 
 template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrix (const M& m, const std::string typ,
                                octave_idx_type k, octave_idx_type p,
                                octave_idx_type& info, ComplexMatrix& eig_vec,
                                ComplexColumnVector& eig_val, const M& _b,
                                ColumnVector& permB,
@@ -117,19 +121,20 @@ EigsComplexNonSymmetricMatrixShift (cons
                                     octave_idx_type& info,
                                     ComplexMatrix& eig_vec,
                                     ComplexColumnVector& eig_val, const M& _b,
                                     ColumnVector& permB,
                                     ComplexColumnVector& cresid,
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit);
 
+template <typename M>
 extern OCTAVE_API octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
                              const std::string& _typ, Complex sigma,
                              octave_idx_type k, octave_idx_type p,
                              octave_idx_type& info, ComplexMatrix& eig_vec,
-                             ComplexColumnVector& eig_val,
-                             ComplexColumnVector& cresid, std::ostream& os,
-                             double tol, bool rvec, bool /* cholB */,
-                             int disp, int maxit);
+                             ComplexColumnVector& eig_val, const M& _b,
+                             ColumnVector& permB, ComplexColumnVector& cresid,
+                             std::ostream& os, double tol, bool rvec,
+                             bool cholB, int disp, int maxit);
 
 #endif
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -1475,16 +1475,82 @@ endfunction
 %! i_A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 %! j_A = [1, 2, 3, 4, 5, 6, 7,  8, 9, 10];
 %! v_A = [1, 2i, 3, 4i, 5, 6i, 7, 8, 9, 10i];
 %! A = sparse(i_A, j_A, v_A);
 %! i_B = [1,2, 3, 4, 5, 6, 7, 8, 9, 10];
 %! j_B = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 %! v_B = [3, 10i, 1, 8i, 7, 6i, 5, 4i, 9, 7i];
 %! B = sparse(i_B, j_B, v_B); # not SPD
-%! [Evectors Evalues] = eigs(A, B, 5, 'SM'); # call_eig is true
+%! [Evectors, Evalues] = eigs(A, B, 5, "SM"); # call_eig is true
 %! ResidualVectors = A * Evectors - B * Evectors * Evalues;
 %! RelativeErrors = norm (ResidualVectors, "columns") ./ ...
 %! norm (A * Evectors, "columns");
-%! assert (RelativeErrors, zeros (1, 5))
+%! assert (RelativeErrors, zeros (1, 5));
 %!testif HAVE_ARPACK
 %! A = rand (8);
 %! eigs (A, 6, "lr"); # this failed on 4.2.x
+%!testif HAVE_ARPACK
+%! A = rand (10);
+%! B = rand (10);
+%! B = B * B';
+%! opts.v0 = (1:10)';
+%! [Evector, Evalues] = eigs (A, B, 4, "LM", opts);
+%! Afun = @(x) A * x;
+%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "LM", opts);
+%! assert (Evector, Evector_f);
+%! assert (Evalues, Evalues_f);
+%!testif HAVE_ARPACK
+%! A = rand (10);
+%! B = rand (10);
+%! B = B * B';
+%! opts.v0 = (1:10)';
+%! [Evector, Evalues] = eigs (A, B, 4, "SM", opts);
+%! Afun = @(x) A \ x;
+%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "SM", opts);
+%! assert (Evector, Evector_f);
+%! assert (Evalues, Evalues_f);
+%!testif HAVE_ARPACK
+%! A = rand (10);
+%! A = A * A';
+%! B = rand (10);
+%! B = B * B';
+%! opts.v0 = (1:10)';
+%! [Evector, Evalues] = eigs (A, B, 4, "LM", opts);
+%! Afun = @(x) A * x;
+%! opts.issym = true;
+%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "LM", opts);
+%! assert (Evector, Evector_f);
+%! assert (Evalues, Evalues_f);
+%!testif HAVE_ARPACK
+%! A = rand (10);
+%! A = A * A';
+%! B = rand (10);
+%! B = B * B';
+%! opts.v0 = (1:10)';
+%! [Evector, Evalues] = eigs (A, B, 4, "SM", opts);
+%! Afun = @(x) A \ x;
+%! opts.issym = true;
+%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "SM", opts);
+%! assert (Evector, Evector_f, 100*eps);
+%! assert (Evalues, Evalues_f, 100*eps);
+%!testif HAVE_ARPACK
+%! A = rand (10) + 1i * rand (10);
+%! B = rand (10) + 1i * rand (10);
+%! B = B * B';
+%! opts.v0 = (1:10)';
+%! [Evector, Evalues] = eigs (A, B, 4, "LM", opts);
+%! Afun = @(x) A * x;
+%! opts.isreal = false;
+%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "LM", opts);
+%! assert (Evector, Evector_f);
+%! assert (Evalues, Evalues_f);
+%!testif HAVE_ARPACK
+%! A = rand (10) + 1i * rand (10);
+%! B = rand (10) + 1i * rand (10);
+%! B = B * B';
+%! opts.v0 = (1:10)';
+%! [Evector, Evalues] = eigs (A, B, 4, "SM", opts);
+%! Afun = @(x) A \ x;
+%! opts.isreal = false;
+%! [Evector_f, Evalues_f] = eigs (Afun, 10, B, 4, "SM", opts);
+%! assert (Evector, Evector_f);
+%! assert (Evalues, Evalues_f);
