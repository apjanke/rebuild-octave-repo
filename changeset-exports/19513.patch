# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1420182280 18000
#      Fri Jan 02 02:04:40 2015 -0500
# Node ID 4cb4210bd392ca25b5a3a0d9386ce3379f3bbfa6
# Parent  a5eb03a7e2a5264ef1090983c0dedb0f357eddfb
use C++ style casts in audio code

* audiodevinfo.cc, audioread.cc: Use C++ style casts.

diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -518,17 +518,17 @@ is_big_endian (void)
   return bint.c[0] == 1;
 }
 
 static int
 octave_play_callback (const void *, void *output, unsigned long frames,
                       const PaStreamCallbackTimeInfo *,
                       PaStreamCallbackFlags, void *data)
 {
-  audioplayer *player = (audioplayer *)data;
+  audioplayer *player = static_cast<audioplayer *> (data);
   int big_endian = is_big_endian ();
   octave_value_list args, retval;
   args(0) = frames;
   retval = feval (player->octave_callback_function, args, 1);
   RowVector sound_l, sound_r;
   Matrix sound = retval(0).matrix_value ();
   int return_status = retval(1).int_value ();
   sound_l.resize (frames);
@@ -551,52 +551,53 @@ octave_play_callback (const void *, void
     }
   else
     return paAbort;
 
   for (int i = 0; i < frames; i++)
     {
       if (player->get_nbits () == 8)
         {
-          int8_t *buffer = (int8_t *)output;
+          int8_t *buffer = static_cast<int8_t *> (output);
           buffer[2 * i] = sound_l.elem (i) * (pow (2.0, 7) - 1);
           buffer[2 * i + 1] = sound_r.elem (i) * (pow (2.0, 7) - 1);
         }
       else if (player->get_nbits () == 16)
         {
-          int16_t *buffer = (int16_t *)output;
+          int16_t *buffer = static_cast<int16_t *> (output);
           buffer[2 * i] = sound_l.elem (i) * (pow (2.0, 15) - 1);
           buffer[2 * i + 1] = sound_r.elem (i) * (pow (2.0, 15) - 1);
         }
       else if (player->get_nbits () == 24)
         {
-          uint8_t *buffer = (uint8_t *)output;
+          uint8_t *buffer = static_cast<uint8_t *> (output);
           int32_t sample_l = sound_l.elem (i) * (pow (2.0, 23) - 1);
           int32_t sample_r = sound_r.elem (i) * (pow (2.0, 23) - 1);
           sample_l &= 0x00ffffff;
           sample_r &= 0x00ffffff;
-          uint8_t *_sample_l = (uint8_t *)&sample_l;
-          uint8_t *_sample_r = (uint8_t *)&sample_r;
+          // FIXME: Would a mask work better?
+          uint8_t *_sample_l = reinterpret_cast<uint8_t *> (&sample_l);
+          uint8_t *_sample_r = reinterpret_cast<uint8_t *> (&sample_r);
           buffer[i * 6 + 0] = _sample_l[0 + big_endian];
           buffer[i * 6 + 1] = _sample_l[1 + big_endian];
           buffer[i * 6 + 2] = _sample_l[2 + big_endian];
           buffer[i * 6 + 3] = _sample_r[0 + big_endian];
           buffer[i * 6 + 4] = _sample_r[1 + big_endian];
           buffer[i * 6 + 5] = _sample_r[2 + big_endian];
         }
     }
   return return_status;
 }
 
 static int
 portaudio_play_callback (const void *, void *output, unsigned long frames,
                          const PaStreamCallbackTimeInfo*,
                          PaStreamCallbackFlags, void *data)
 {
-  audioplayer *player = (audioplayer *)data;
+  audioplayer *player = static_cast<audioplayer *> (data);
   int big_endian = is_big_endian ();
   int channels = player->get_channels ();
   RowVector *sound_l = player->get_left ();
   RowVector *sound_r;
 
   if (channels > 1)
     sound_r = player->get_right ();
   else
@@ -607,58 +608,59 @@ portaudio_play_callback (const void *, v
       unsigned int sample_number = player->get_sample_number ();
       if (sample_number > player->get_end_sample ())
         return paAbort;
 
       if (player->get_type () == DOUBLE)
         {
           if (player->get_nbits () == 8)
             {
-              int8_t *buffer = (int8_t *)output;
+              int8_t *buffer = static_cast<int8_t *> (output);
               buffer[k] = sound_l->elem (sample_number) * (pow (2.0, 7) - 1);
               buffer[k + 1] = sound_r->elem (sample_number) * (pow (2.0, 7) - 1);
             }
           else if (player->get_nbits () == 16)
             {
-              int16_t *buffer = (int16_t *)output;
+              int16_t *buffer = static_cast<int16_t *> (output);
               buffer[k] = sound_l->elem (sample_number) * (pow (2.0, 15) - 1);
               buffer[k + 1] = sound_r->elem (sample_number) * (pow (2.0, 15) - 1);
             }
           else if (player->get_nbits () == 24)
             {
-              uint8_t *buffer = (uint8_t *)output;
+              uint8_t *buffer = static_cast<uint8_t *> (output);
               int32_t sample_l = sound_l->elem (sample_number) * (pow (2.0, 23) - 1);
               int32_t sample_r = sound_r->elem (sample_number) * (pow (2.0, 23) - 1);
               sample_l &= 0x00ffffff;
               sample_r &= 0x00ffffff;
-              uint8_t *_sample_l = (uint8_t *)&sample_l;
-              uint8_t *_sample_r = (uint8_t *)&sample_r;
+              // FIXME: Would a mask work better?
+              uint8_t *_sample_l = reinterpret_cast<uint8_t *> (&sample_l);
+              uint8_t *_sample_r = reinterpret_cast<uint8_t *> (&sample_r);
               buffer[j * 6 + 0] = _sample_l[0 + big_endian];
               buffer[j * 6 + 1] = _sample_l[1 + big_endian];
               buffer[j * 6 + 2] = _sample_l[2 + big_endian];
               buffer[j * 6 + 3] = _sample_r[0 + big_endian];
               buffer[j * 6 + 4] = _sample_r[1 + big_endian];
               buffer[j * 6 + 5] = _sample_r[2 + big_endian];
             }
         }
       else if (player->get_type () == INT8)
         {
-          int8_t *buffer = (int8_t *)output;
+          int8_t *buffer = static_cast<int8_t *> (output);
           buffer[k] = sound_l->elem (sample_number);
           buffer[k + 1] = sound_r->elem (sample_number);
         }
       else if (player->get_type () == UINT8)
         {
-          uint8_t *buffer = (uint8_t *)output;
+          uint8_t *buffer = static_cast<uint8_t *> (output);
           buffer[k] = sound_l->elem (sample_number);
           buffer[k + 1] = sound_r->elem (sample_number);
         }
       else if (player->get_type () == INT16)
         {
-          int16_t *buffer = (int16_t *)output;
+          int16_t *buffer = static_cast<int16_t *> (output);
           buffer[k] = sound_l->elem (sample_number);
           buffer[k + 1] = sound_r->elem (sample_number);
         }
       player->set_sample_number (sample_number + 1);
     }
   return paContinue;
 }
 
@@ -948,19 +950,20 @@ audioplayer::playblocking (void)
     }
 
   unsigned int start, end;
   start = this->get_sample_number ();
   end = this->get_end_sample ();
   for (int i = start; i < end; i += BUFFER_SIZE)
     {
       if (this->octave_callback_function != 0)
-        octave_play_callback (0, (void *)buffer, BUFFER_SIZE, 0, 0, (void *)this);
+        octave_play_callback (0, buffer, BUFFER_SIZE, 0, 0, this);
       else
-        portaudio_play_callback (0, (void *)buffer, BUFFER_SIZE, 0, 0, (void *)this);
+        portaudio_play_callback (0, buffer, BUFFER_SIZE, 0, 0, this);
+
       err = Pa_WriteStream (stream, buffer, BUFFER_SIZE);
     }
 
   err = Pa_StopStream (stream);
   if (err != paNoError)
     {
       error ("audioplayer: Error stoping audio playback stream");
       return;
@@ -981,19 +984,23 @@ audioplayer::playblocking (void)
 void
 audioplayer::play (void)
 {
   if (this->get_stream ())
     this->stop ();
 
   PaError err;
   if (this->octave_callback_function != 0)
-    err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, octave_play_callback, (void *)this);
+    err = Pa_OpenStream (&stream, NULL, &(this->output_parameters),
+                         this->get_fs (), BUFFER_SIZE, paClipOff,
+                         octave_play_callback, this);
   else
-    err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, portaudio_play_callback, (void *)this);
+    err = Pa_OpenStream (&stream, NULL, &(this->output_parameters),
+                         this->get_fs (), BUFFER_SIZE, paClipOff,
+                         portaudio_play_callback, this);
 
   if (err != paNoError)
     {
       error ("audioplayer: Error opening audio playback stream");
       return;
     }
 
   err = Pa_StartStream (stream);
@@ -1160,55 +1167,56 @@ private:
 DEFINE_OCTAVE_ALLOCATOR (audiorecorder);
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (audiorecorder, "audiorecorder", "audiorecorder");
 
 static int
 octave_record_callback (const void *input, void *, unsigned long frames,
                         const PaStreamCallbackTimeInfo *,
                         PaStreamCallbackFlags, void *data)
 {
-  audiorecorder *recorder = (audiorecorder *)data;
+  audiorecorder *recorder = static_cast<audiorecorder *> (data);
   int channels = recorder->get_channels ();
   float sample_l, sample_r;
   Matrix sound;
   sound.resize (frames, 2);
   if (recorder->get_nbits () == 8)
     {
-      int8_t *input8 = (int8_t *)input;
+      const int8_t *input8 = static_cast<const int8_t *> (input);
       for (int i = 0; i < frames; i++)
         {
           sample_l = input8[i * channels] / (pow (2.0, 7) - 1.0);
           sample_r = input8[i * channels + (channels - 1)] / (pow (2.0, 7) - 1.0);
           sound(i, 0) = sample_l;
           sound(i, 1) = sample_r;
         }
       }
   else if (recorder->get_nbits () == 16)
     {
-      int16_t *input16 = (int16_t *)input;
+      const int16_t *input16 = static_cast<const int16_t *> (input);
       for (int i = 0; i < frames; i++)
         {
           sample_l = input16[i * channels] / (pow (2.0, 15) - 1.0);
           sample_r = input16[i * channels + (channels - 1)] / (pow (2.0, 15) - 1.0);
           sound(i, 0) = sample_l;
           sound(i, 1) = sample_r;
         }
     }
   else if (recorder->get_nbits () == 24)
     {
-      uint8_t *input24 = (uint8_t *)input;
+      // FIXME: Is there a better way?
+      const uint8_t *input24 = static_cast<const uint8_t *> (input);
       int32_t sample_l32, sample_r32;
-      uint8_t *_sample_l = (uint8_t *)&sample_l;
-      uint8_t *_sample_r = (uint8_t *)&sample_r;
+      uint8_t *_sample_l = reinterpret_cast<uint8_t *> (&sample_l);
+      uint8_t *_sample_r = reinterpret_cast<uint8_t *> (&sample_r);
       for (int i = 0; i < frames; i++)
         {
           for (int j = 0; j < 3; j++)
             {
               _sample_l[j] = input24[i * channels * 3 + j];
-              _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
+               _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
             }
           if (sample_l32 & 0x00800000)
             sample_l32 |= 0xff000000;
           if (sample_r32 & 0x00800000)
             sample_r32 |= 0xff000000;
           sound(i, 0) = sample_l32 / pow (2.0, 23);
           sound(i, 1) = sample_r32 / pow (2.0, 23);
         }
@@ -1220,45 +1228,46 @@ octave_record_callback (const void *inpu
   return retval(0).int_value ();
 }
 
 static int
 portaudio_record_callback (const void *input, void *, unsigned long frames,
                            const PaStreamCallbackTimeInfo *,
                            PaStreamCallbackFlags, void *data)
 {
-  audiorecorder *recorder = (audiorecorder *)data;
+  audiorecorder *recorder = static_cast<audiorecorder *> (data);
   int channels = recorder->get_channels ();
   float sample_l, sample_r;
   if (recorder->get_nbits () == 8)
     {
-      int8_t *input8 = (int8_t *)input;
+      const int8_t *input8 = static_cast<const int8_t *> (input);
       for (int i = 0; i < frames; i++)
         {
           sample_l = input8[i * channels] / (pow (2.0, 7) - 1.0);
           sample_r = input8[i * channels + (channels - 1)] / (pow (2.0, 7) - 1.0);
           recorder->append (sample_l, sample_r);
         }
     }
   else if (recorder->get_nbits () == 16)
     {
-      int16_t *input16 = (int16_t *)input;
+      const int16_t *input16 = static_cast<const int16_t *> (input);
       for (int i = 0; i < frames; i++)
         {
           sample_l = input16[i * channels] / (pow (2.0, 15) - 1.0);
           sample_r = input16[i * channels + (channels - 1)] / (pow (2.0, 15) - 1.0);
           recorder->append (sample_l, sample_r);
         }
     }
   else if (recorder->get_nbits () == 24)
     {
-      uint8_t *input24 = (uint8_t *)input;
+      // FIXME: Is there a better way?
+      const uint8_t *input24 = static_cast<const uint8_t *> (input);
       int32_t sample_l32, sample_r32;
-      uint8_t *_sample_l = (uint8_t *)&sample_l;
-      uint8_t *_sample_r = (uint8_t *)&sample_r;
+      uint8_t *_sample_l = reinterpret_cast<uint8_t *> (&sample_l);
+      uint8_t *_sample_r = reinterpret_cast<uint8_t *> (&sample_r);
       for (int i = 0; i < frames; i++)
         {
           for (int j = 0; j < 3; j++)
             {
               _sample_l[j] = input24[i * channels * 3 + j];
               _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
             }
           if (sample_l32 & 0x00800000)
@@ -1496,21 +1505,25 @@ audiorecorder::record (void)
   if (this->get_stream ())
     this->stop ();
 
   this->left.clear ();
   this->right.clear ();
   PaError err;
   if (this->octave_callback_function != 0)
     {
-      err = Pa_OpenStream (&stream, &(this->input_parameters), NULL, this->get_fs (), BUFFER_SIZE, paClipOff, octave_record_callback, (void *)this);
+      err = Pa_OpenStream (&stream, &(this->input_parameters), NULL,
+                           this->get_fs (), BUFFER_SIZE, paClipOff,
+                           octave_record_callback, this);
     }
   else
     {
-      err = Pa_OpenStream (&stream, &(this->input_parameters), NULL, this->get_fs (), BUFFER_SIZE, paClipOff, portaudio_record_callback, (void *)this);
+      err = Pa_OpenStream (&stream, &(this->input_parameters), NULL,
+                           this->get_fs (), BUFFER_SIZE, paClipOff,
+                           portaudio_record_callback, this);
     }
   if (err != paNoError)
     {
       error ("audiorecorder: Error opening audio recording stream");
       return;
     }
   err = Pa_StartStream (stream);
   if (err != paNoError)
@@ -1525,17 +1538,18 @@ audiorecorder::recordblocking (float sec
 {
   if (this->get_stream ())
     this->stop ();
 
   this->left.clear ();
   this->right.clear ();
 
   PaError err;
-  err = Pa_OpenStream (&stream, &(this->input_parameters), NULL, this->get_fs (), BUFFER_SIZE, paClipOff, NULL, (void *)this);
+  err = Pa_OpenStream (&stream, &(this->input_parameters), NULL,
+                       this->get_fs (), BUFFER_SIZE, paClipOff, NULL, this);
   if (err != paNoError)
     {
       error ("audiorecorder: Error opening audio recording stream");
       return;
     }
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
@@ -1543,21 +1557,21 @@ audiorecorder::recordblocking (float sec
       error ("audiorecorder: Error starting audio recording stream");
       return;
     }
 
   unsigned int frames = seconds * this->get_fs ();
   uint8_t buffer[BUFFER_SIZE * 2 * 3];
   for (int i = 0; i < frames / BUFFER_SIZE; i++)
     {
-      Pa_ReadStream (this->get_stream (), (void *)buffer, BUFFER_SIZE);
+      Pa_ReadStream (this->get_stream (), buffer, BUFFER_SIZE);
       if (this->octave_callback_function != 0)
-        octave_record_callback ((void *)buffer, NULL, BUFFER_SIZE, 0, 0, (void *)this);
+        octave_record_callback (buffer, NULL, BUFFER_SIZE, 0, 0, this);
       else
-        portaudio_record_callback ((void *)buffer, NULL, BUFFER_SIZE, 0, 0, (void *)this);
+        portaudio_record_callback (buffer, NULL, BUFFER_SIZE, 0, 0, this);
     }
 }
 
 void
 audiorecorder::pause (void)
 {
   if (this->get_stream () == 0)
     return;
@@ -1668,26 +1682,35 @@ Undocumented internal function.\n\
   return octave_value (retval);
 #else
   octave_value retval;
   error ("portaudio not found on your system and thus audio functionality is not present");
   return retval;
 #endif
 }
 
+static audiorecorder *
+get_recorder (const octave_value& ov)
+{
+  const octave_base_value& rep = ov.get_rep ();
+
+  octave_base_value *ncrep = const_cast<octave_base_value *> (&rep);
+
+  return dynamic_cast<audiorecorder *> (ncrep);
+}
+
 DEFUN_DLD (__recorder_getaudiodata__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{data}} __recorder_getaudiodata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  const octave_base_value& rep = args(0).get_rep ();
-  audiorecorder *recorder = &((audiorecorder &)rep);
+  audiorecorder *recorder = get_recorder (args(0));
   retval = octave_value (recorder->getaudiodata ());
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_channels__, args, ,
@@ -1696,18 +1719,17 @@ DEFUN_DLD (__recorder_get_channels__, ar
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_channels ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1717,18 +1739,17 @@ DEFUN_DLD (__recorder_get_fs__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_fs ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1738,18 +1759,17 @@ DEFUN_DLD (__recorder_get_id__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_id ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1759,18 +1779,17 @@ DEFUN_DLD (__recorder_get_nbits__, args,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_nbits ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1780,18 +1799,17 @@ DEFUN_DLD (__recorder_get_sample_number_
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_sample_number ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1801,18 +1819,17 @@ DEFUN_DLD (__recorder_get_tag__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_tag ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1822,18 +1839,17 @@ DEFUN_DLD (__recorder_get_total_samples_
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = octave_value (recorder->get_total_samples ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1843,18 +1859,17 @@ DEFUN_DLD (__recorder_get_userdata__, ar
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       retval = recorder->get_userdata ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1864,18 +1879,17 @@ DEFUN_DLD (__recorder_isrecording__, arg
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       if (recorder->isrecording ())
         return octave_value (1);
       else
         return octave_value (0);
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
@@ -1888,54 +1902,51 @@ DEFUN_DLD (__recorder_pause__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       recorder->pause ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_recordblocking__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_recordblocking__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  const octave_base_value& rep = args(0).get_rep ();
-  audiorecorder *recorder = &((audiorecorder &)rep);
+  audiorecorder *recorder = get_recorder (args(0));
   recorder->recordblocking (args(1).float_value ());
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_record__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} __recorder_record__ (@var{recorder})\n\
 @deftypefnx {Loadable Function} {} __recorder_record__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  const octave_base_value& rep = args(0).get_rep ();
-  audiorecorder *recorder = &((audiorecorder &)rep);
+  audiorecorder *recorder = get_recorder (args(0));
   if (args.length () == 1)
     {
       recorder->record ();
     }
   else if (args.length () == 2)
     {
       recorder->set_end_sample (args(1).int_value () * recorder->get_fs ());
       recorder->record ();
@@ -1956,18 +1967,17 @@ DEFUN_DLD (__recorder_resume__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       recorder->resume ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1977,18 +1987,17 @@ DEFUN_DLD (__recorder_set_fs__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       recorder->set_fs (args(1).int_value ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -1998,18 +2007,17 @@ DEFUN_DLD (__recorder_set_tag__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       recorder->set_tag (args(1).char_matrix_value ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2019,36 +2027,34 @@ DEFUN_DLD (__recorder_set_userdata__, ar
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audiorecorder *recorder = &((audiorecorder &)rep);
+      audiorecorder *recorder = get_recorder (args(0));
       recorder->set_userdata (args(1));
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_stop__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_stop__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  const octave_base_value& rep = args(0).get_rep ();
-  audiorecorder *recorder = &((audiorecorder &)rep);
+  audiorecorder *recorder = get_recorder (args(0));
   recorder->stop ();
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_audioplayer__, args, ,
@@ -2085,29 +2091,38 @@ Undocumented internal function.\n\
   return octave_value (retval);
 #else
   octave_value retval;
   error ("portaudio not found on your system and thus audio functionality is not present");
   return retval;
 #endif
 }
 
+static audioplayer *
+get_player (const octave_value& ov)
+{
+  const octave_base_value& rep = ov.get_rep ();
+
+  octave_base_value *ncrep = const_cast<octave_base_value *> (&rep);
+
+  return dynamic_cast<audioplayer *> (ncrep);
+}
+
 DEFUN_DLD (__player_get_channels__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __player_get_channels__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_channels ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2117,18 +2132,17 @@ DEFUN_DLD (__player_get_fs__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_fs ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2138,18 +2152,17 @@ DEFUN_DLD (__player_get_id__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_id ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2159,18 +2172,17 @@ DEFUN_DLD (__player_get_nbits__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_nbits ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2180,18 +2192,17 @@ DEFUN_DLD (__player_get_sample_number__,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_sample_number ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2201,18 +2212,17 @@ DEFUN_DLD (__player_get_tag__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_tag ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2222,18 +2232,17 @@ DEFUN_DLD (__player_get_total_samples__,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = octave_value (player->get_total_samples ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2243,18 +2252,17 @@ DEFUN_DLD (__player_get_userdata__, args
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       retval = player->get_userdata ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2264,18 +2272,17 @@ DEFUN_DLD (__player_isplaying__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       if (player->isplaying ())
         return octave_value (1);
       else
         return octave_value (0);
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
@@ -2288,18 +2295,17 @@ DEFUN_DLD (__player_pause__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->pause ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2311,24 +2317,22 @@ DEFUN_DLD (__player_playblocking__, args
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->playblocking ();
     }
   else
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       if (args(1).is_matrix_type ())
         {
           unsigned int start, end;
           RowVector range = args(1).row_vector_value ();
           start = range.elem (0) - 1;
           end = range.elem (1) - 1;
           if (start < 0 or start > player->get_total_samples () or
               start > end or end < 0 or end > player->get_total_samples ())
@@ -2360,24 +2364,22 @@ DEFUN_DLD (__player_play__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->play ();
     }
   else
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       if (args(1).is_matrix_type ())
         {
           unsigned int start, end;
           RowVector range = args(1).row_vector_value ();
           start = range.elem (0) - 1;
           end = range.elem (1) - 1;
           if (start < 0 or start > player->get_total_samples () or
               start > end or end < 0 or end > player->get_total_samples ())
@@ -2407,18 +2409,17 @@ DEFUN_DLD (__player_resume__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->resume ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2428,18 +2429,17 @@ DEFUN_DLD (__player_set_fs__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->set_fs (args(1).int_value ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2449,18 +2449,17 @@ DEFUN_DLD (__player_set_tag__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->set_tag (args(1).char_matrix_value ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2470,18 +2469,17 @@ DEFUN_DLD (__player_set_userdata__, args
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args(0));
       player->set_userdata (args(1));
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
@@ -2491,17 +2489,16 @@ DEFUN_DLD (__player_stop__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      const octave_base_value& rep = args(0).get_rep ();
-      audioplayer *player = &((audioplayer &)rep);
+      audioplayer *player = get_player (args (0));
       player->stop ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -22,16 +22,18 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 #include <map>
 
+#include "oct-locbuf.h"
+
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-struct.h"
 
 #ifdef HAVE_SNDFILE
@@ -76,33 +78,33 @@ Read a file and return a specified range
   octave_value ret_audio;
   SNDFILE *file;
   SF_INFO info;
   info.format = 0;
   int start, end;
   file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
   start = 0;
   end = info.frames;
-  float *data = (float *)malloc (sizeof (float) * info.frames * info.channels);
+  OCTAVE_LOCAL_BUFFER (float, data, info.frames * info.channels);
   sf_read_float (file, data, info.frames * info.channels);
   if (args.length () == 2 && !args(1).is_string () || args.length () == 3)
     {
       RowVector range = args(1).row_vector_value ();
       start = range(0);
       end = range(1);
     }
   audio.resize (end - start, info.channels);
   for (int i = start; i < end; i++)
     {
       for (int channel = 0; channel < info.channels; channel++)
         {
           audio(i - start, channel) = data[i * info.channels + channel];
         }
     }
-  free (data);
+
   if (args.length () == 2 && args(1).is_string () || args.length () == 3)
     {
       std::string type;
       if (args.length () == 3)
         type = args(2).string_value ();
       else
         type = args(1).string_value ();
 
@@ -201,17 +203,18 @@ Comment.\n\
   std::map<std::string, int> extension_to_format;
   fill_extension_table (extension_to_format);
   std::string filename = args(0).string_value ();
   std::string extension = filename.substr (filename.find_last_of (".") + 1);
   std::transform (extension.begin (), extension.end (), extension.begin (), ::tolower);
   Matrix audio = args(1).matrix_value ();
   SNDFILE *file;
   SF_INFO info;
-  float *data = (float *)malloc (audio.rows () * audio.cols () * sizeof (float));
+  OCTAVE_LOCAL_BUFFER (float, data, audio.rows () * audio.cols ());
+
   for (int i = 0; i < audio.cols (); i++)
     {
       for (int j = 0; j < audio.rows (); j++)
         {
           data[j * audio.cols () + i] = audio(j, i);
         }
     }
 
@@ -294,17 +297,19 @@ Return information about an audio file s
   SF_INFO info;
   info.format = 0;
   file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
   retval.assign ("Filename", args(0).string_value ());
   retval.assign ("CompressionMethod", "");
   retval.assign ("NumChannels", info.channels);
   retval.assign ("SampleRate", info.samplerate);
   retval.assign ("TotalSamples", info.frames);
-  retval.assign ("Duration", (float)info.frames / (float)info.samplerate);
+  double dframes = info.frames;
+  double drate = info.samplerate;
+  retval.assign ("Duration", dframes / drate);
 
   int bits;
   if (info.format & SF_FORMAT_PCM_S8)
     bits = 8;
   else if (info.format & SF_FORMAT_PCM_U8)
     bits = 8;
   else if (info.format & SF_FORMAT_PCM_16)
     bits = 16;
