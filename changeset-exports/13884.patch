# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1321585136 18000
#      Thu Nov 17 21:58:56 2011 -0500
# Branch gui
# Node ID 22e16fd68b8a4b161d45132b770b91373ee7e7e7
# Parent  b09321ab846475b66731aaeac0ab2782f06afc0c
# Parent  ecf0c6bca0c97d2221b6d4653a39af907830d671
Merge default onto gui

diff --git a/.hgsub b/.hgsub
new file mode 100644
--- /dev/null
+++ b/.hgsub
@@ -0,0 +1,1 @@
+gnulib = [git]git://git.sv.gnu.org/gnulib
diff --git a/.hgsubstate b/.hgsubstate
new file mode 100644
--- /dev/null
+++ b/.hgsubstate
@@ -0,0 +1,1 @@
+84c3f9cf54eaa688c5a1a26925886535079a91de gnulib
diff --git a/build-aux/bootstrap b/build-aux/bootstrap
--- a/build-aux/bootstrap
+++ b/build-aux/bootstrap
@@ -164,18 +164,20 @@ copy=false
 # Or set it to 'auto' to make this script select which to use based
 # on which version control system (if any) is used in the source directory.
 vc_ignore=auto
 
 # Set this to true in bootstrap.conf to enable --bootstrap-sync by
 # default.
 bootstrap_sync=false
 
-# Use git to update gnulib sources
-use_git=true
+# Don't use git to update gnulib sources. We keep gnulib under a
+# Mercurial subrepository instead
+use_git=false
+GNULIB_SRCDIR=gnulib/
 
 # find_tool ENVVAR NAMES...
 # -------------------------
 # Search for a required program.  Use the value of ENVVAR, if set,
 # otherwise find the first of the NAMES that can be run (i.e.,
 # supports --version).  If found, set ENVVAR to the program name,
 # die otherwise.
 find_tool ()
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -65,18 +65,16 @@
 ## 2003-12-14 Rafael Laboissiere <rafael@laboissiere.net>
 ## Added optional fourth argument to pass options to the underlying
 ## qhull command
 
 function [vx, vy] = voronoi (varargin)
 
   if (nargin < 1)
     print_usage ();
-  elseif (nargout > 2)
-    error ("voronoi: No more than two output arguments supported");
   endif
 
   narg = 1;
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
     handl = varargin{1};
     if (! strcmp (get (handl, "type"), "axes"))
       error ("voronoi: expecting first argument to be an axes object");
     endif
@@ -126,17 +124,19 @@ function [vx, vy] = voronoi (varargin)
   ydelta = ymax - ymin;
   scale = 2;
 
   xbox = [xmin - scale * xdelta; xmin - scale * xdelta; ...
           xmax + scale * xdelta; xmax + scale * xdelta];
   ybox = [xmin - scale * xdelta; xmax + scale * xdelta; ...
           xmax + scale * xdelta; xmin - scale * xdelta];
 
-  [p, c, infi] = __voronoi__ ([[x(:) ; xbox(:)], [y(:); ybox(:)]], opts{:});
+  [p, c, infi] = __voronoi__ ("voronoi",
+                              [[x(:) ; xbox(:)], [y(:); ybox(:)]],
+                              opts{:});
 
   idx = find (! infi);
   ll = length (idx);
   c = c(idx).';
   k = sum (cellfun ("length", c));
   edges = cell2mat (cellfun (@(x) [x ; [x(end), x(1:end-1)]], c,
                              "uniformoutput", false));
 
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -43,24 +43,24 @@ function [C, F] = voronoin (pts, options
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   [np, dim] = size (pts);
 
   if (np <= dim)
     error ("voronoin: number of points must be greater than their dimension");
-  elseif (nargin == 2 && ! (ischar (options) || iscellstr (options)))
-    error ("voronoin: OPTIONS argument must be a string or cell array of strings");
   endif
 
+  caller = "voronoin";
+
   if (nargin == 1)
-    [C, F] = __voronoi__ (pts);
+    [C, F] = __voronoi__ (caller, pts);
   else
-    [C, F] = __voronoi__ (pts, options);
+    [C, F] = __voronoi__ (caller, pts, options);
   endif
 
 endfunction
 
 
 %% FIXME: Need functional tests
 
 %% FIXME: Need input validation tests
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -49,33 +49,31 @@
 ##
 ## @seealso{invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hilb (n)
 
-
   if (nargin != 1)
     print_usage ();
+  elseif (! isscalar (n))
+    error ("hilb: N must be a scalar integer");
   endif
 
-  nmax = length (n);
-  if (nmax == 1)
-    retval = zeros (n);
-    tmp = 1:n;
-    for i = 1:n
-      retval (i, :) = 1.0 ./ (tmp + (i - 1));
-    endfor
-  else
-    error ("hilb: expecting scalar argument, found something else");
-  endif
+  retval = zeros (n);
+  tmp = 1:n;
+  for i = 1:n
+    retval(i, :) = 1.0 ./ tmp;
+    tmp++;
+  endfor
 
 endfunction
 
-%!assert((hilb (2) == [1, 1/2; 1/2, 1/3]
-%! && hilb (3) == [1, 1/2, 1/3; 1/2, 1/3, 1/4; 1/3, 1/4, 1/5]));
+
+%!assert (hilb (2), [1, 1/2; 1/2, 1/3])
+%!assert (hilb (3), [1, 1/2, 1/3; 1/2, 1/3, 1/4; 1/3, 1/4, 1/5])
 
-%!error hilb ();
+%!error hilb ()
+%!error hilb (1, 2)
+%!error <N must be a scalar integer> hilb (ones(2))
 
-%!error hilb (1, 2);
-
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -55,42 +55,41 @@
 function retval = vander (c, n)
 
   if (nargin == 1)
     n = length (c);
   elseif (nargin != 2)
     print_usage ();
   endif
 
-  if (isvector (c))
-    retval = zeros (length (c), n, class (c));
-    ## avoiding many ^s appears to be faster for n >= 100.
-    d = 1;
-    c = c(:);
-    for i = n:-1:1
-      retval(:,i) = d;
-      d = c .* d;
-    endfor
-  else
-    error ("vander: argument must be a vector");
+  if (! isvector (c))
+    error ("vander: polynomial C must be a vector");
   endif
 
+  ## avoiding many ^s appears to be faster for n >= 100.
+  retval = zeros (length (c), n, class (c));
+  d = 1;
+  c = c(:);
+  for i = n:-1:1
+    retval(:,i) = d;
+    d .*= c;
+  endfor
+
 endfunction
 
+
 %!test
 %! c = [0,1,2,3];
 %! expect = [0,0,0,1; 1,1,1,1; 8,4,2,1; 27,9,3,1];
-%! result = vander(c);
-%! assert(expect, result);
+%! assert(vander (c), expect);
 
-%!assert((vander (1) == 1 && vander ([1, 2, 3]) == vander ([1; 2; 3])
-%! && vander ([1, 2, 3]) == [1, 1, 1; 4, 2, 1; 9, 3, 1]
-%! && vander ([1, 2, 3]*i) == [-1, i, 1; -4, 2i, 1; -9, 3i, 1]));
+%!assert (vander (1), 1)
+%!assert (vander ([1, 2, 3]), vander ([1; 2; 3]))
+%!assert (vander ([1, 2, 3]), [1, 1, 1; 4, 2, 1; 9, 3, 1])
+%!assert (vander ([1, 2, 3]*i), [-1, i, 1; -4, 2i, 1; -9, 3i, 1])
 
 %!assert(vander (2, 3), [4, 2, 1])
 %!assert(vander ([2, 3], 3), [4, 2, 1; 9, 3, 1])
 
-%!error vander ([1, 2; 3, 4]);
+%!error vander ();
+%!error vander (1, 2, 3);
+%!error <polynomial C must be a vector> vander ([1, 2; 3, 4]);
 
-%!error vander ();
-
-%!error vander (1, 2, 3);
-
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -52,234 +52,264 @@ extern "C" {
 
 #ifdef NEED_QHULL_VERSION
 char qh_version[] = "__voronoi__.oct 2007-07-24";
 #endif
 #endif
 
 DEFUN_DLD (__voronoi__, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{pts})\n\
-@deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{pts}, @var{options})\n\
+@deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
+@deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
-  if (nargin < 1 || nargin > 2)
+  if (nargin < 2 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
 
-  std::string options = "";
+  std::string caller = args(0).string_value ();
+
+  Matrix points = args(1).matrix_value ();
+  const octave_idx_type dim = points.columns ();
+  const octave_idx_type num_points = points.rows ();
+
+  points = points.transpose ();
 
-  if (nargin == 2)
+  std::string options;
+
+  if (dim <= 4)
+    options = " Qbb";
+  else
+    options = " Qbb Qx";
+
+  if (nargin == 3)
     {
-      if (args(1).is_string ())
-        options = args(1).string_value ();
-      else if (args(1).is_empty ())
-        ;  // Use default options
-      else if (args(1).is_cellstr ())
+      octave_value opt_arg = args(2);
+
+      if (opt_arg.is_string ())
+        options = " " + opt_arg.string_value ();
+      else if (opt_arg.is_empty ())
+        ; // Use default options.
+      else if (opt_arg.is_cellstr ())
         {
           options = "";
-          Array<std::string> tmp = args(1).cellstr_value ();
+
+          Array<std::string> tmp = opt_arg.cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
-            options += tmp(i) + " ";
+            options += " " + tmp(i);
         }
       else
         {
-          error ("__voronoi__: OPTIONS argument must be a string, cell array of strings, or empty");
+          error ("%s: OPTIONS must be a string, cell array of strings, or empty",
+                 caller.c_str ());
           return retval;
         }
     }
 
-  Matrix p (args(0).matrix_value ());
-  const octave_idx_type dim = p.columns ();
-  const octave_idx_type np = p.rows ();
-
-  p = p.transpose ();
-  double *pt_array = p.fortran_vec ();
-
   boolT ismalloc = false;
 
   // Replace the 0 pointer with stdout for debugging information
   FILE *outfile = 0;
   FILE *errfile = stderr;
 
-  // Qhull flags argument is not const char*
-  OCTAVE_LOCAL_BUFFER (char, flags, 12 + options.length ());
+  // qh_new_qhull command and points arguments are not const...
+
+  std::string cmd = "qhull v" + options;
 
-  sprintf (flags, "qhull v Fv %s", options.c_str ());
+  OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
-  int exitcode = qh_new_qhull (dim, np, pt_array, 
-                               ismalloc, flags, outfile, errfile);
+  strcpy (cmd_str, cmd.c_str ());
+
+  int exitcode = qh_new_qhull (dim, num_points, points.fortran_vec (),
+                               ismalloc, cmd_str, outfile, errfile);
   if (! exitcode) 
     {
-      facetT *facet;
-      vertexT *vertex;
+      // Calling findgood_all provides the number of Voronoi vertices
+      // (sets qh num_good).
 
-      octave_idx_type i = 0, n = 1, k = 0, m = 0, j = 0, r = 0;
+      qh_findgood_all (qh facet_list);
 
-      // Count number of vertices for size of NI.  FIXME -- does Qhull
-      // have a way to query this value directly?
-      octave_idx_type nv = 0;
-      FORALLvertices
-        {
-          nv++;
-        }
+      octave_idx_type num_voronoi_regions
+        = qh num_vertices - qh_setsize (qh del_vertices);
 
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, ni, nv);
+      octave_idx_type num_voronoi_vertices = qh num_good;
 
-      for (i = 0; i < nv; i++)
-        ni[i] = 0;
+      // Find the voronoi centers for all facets.
 
       qh_setvoronoi_all ();
 
-      bool infinity_seen = false;
-      facetT *neighbor, **neighborp;
-      coordT *voronoi_vertex;
+      facetT *facet;
+      vertexT *vertex;
+      octave_idx_type k;
+
+      // Find the number of Voronoi vertices for each Voronoi cell and
+      // store them in NI so we can use them later to set the dimensions
+      // of the RowVector objects used to collect them.
 
       FORALLfacets
         {
           facet->seen = false;
         }
+      
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, ni, num_voronoi_regions);
+      for (octave_idx_type i = 0; i < num_voronoi_regions; i++)
+        ni[i] = 0;
+
+      k = 0;
 
       FORALLvertices
         {
           if (qh hull_dim == 3)
             qh_order_vertexneighbors (vertex);
           
-          infinity_seen = false;
+          bool infinity_seen = false;
+
+          facetT *neighbor, **neighborp;
 
           FOREACHneighbor_ (vertex)
             {
-              if (! neighbor->upperdelaunay)
+              if (neighbor->upperdelaunay)
                 {
-                  if (! neighbor->seen)
+                  if (! infinity_seen)
                     {
-                      n++;
-                      neighbor->seen = true;
+                      infinity_seen = true;
+                      ni[k]++;
                     }
-                  ni[k]++;
                 }
-              else if (! infinity_seen)
+              else
                 {
-                  infinity_seen = true;
+                  neighbor->seen = true;
                   ni[k]++;
                 }
             }
 
           k++;
         }
 
-      Matrix v (n, dim);
-      for (octave_idx_type d = 0; d < dim; d++)
-        v(0,d) = octave_Inf;
+      // If Qhull finds fewer regions than points, we will pad the end
+      // of the at_inf and C arrays so that they always contain at least
+      // as many elements as the given points array.
+
+      // FIXME -- is it possible (or does it make sense) for
+      // num_voronoi_regions to ever be larger than num_points?
+
+      octave_idx_type nr = (num_points > num_voronoi_regions
+                            ? num_points : num_voronoi_regions);
+
+      boolMatrix at_inf (nr, 1, false);
 
-      boolMatrix AtInf (nv, 1, false);
-      std::list<RowVector> F;
-      k = 0;
-      i = 0;
+      // The list of Voronoi vertices.  The first element is always
+      // Inf.
+      Matrix F (num_voronoi_vertices+1, dim);
+
+      for (octave_idx_type d = 0; d < dim; d++)
+        F(0,d) = octave_Inf;
+
+      // The cell array of vectors of indices into F that represent the
+      // vertices of the Voronoi regions (cells).
+
+      Cell C (nr, 1);
+
+      // Now loop through the list of vertices again and store the
+      // coordinates of the Voronoi vertices and the lists of indices
+      // for the cells.
 
       FORALLfacets
         {
           facet->seen = false;
         }
 
+      octave_idx_type i = 0;
+      k = 0;
+
       FORALLvertices
         {
           if (qh hull_dim == 3)
             qh_order_vertexneighbors (vertex);
 
-          infinity_seen = false;
+          bool infinity_seen = false;
+
+          octave_idx_type idx = qh_pointid (vertex->point);
 
-          octave_idx_type n_vertices = ni[k++];
+          octave_idx_type num_vertices = ni[k++];
 
-          // Qhull seems to sometimes produce "facets" with a single
-          // vertex.  Is that a bug?  How can a facet have just one
+          // Qhull seems to sometimes produces regions with a single
+          // vertex.  Is that a bug?  How can a region have just one
           // vertex?  Let's skip it.
 
-          if (n_vertices == 1)
+          if (num_vertices == 1)
             continue;
 
-          RowVector facet_list (n_vertices);
-          m = 0;
+          RowVector facet_list (num_vertices);
+
+          octave_idx_type m = 0;
+
+          facetT *neighbor, **neighborp;
 
           FOREACHneighbor_(vertex)
             {
               if (neighbor->upperdelaunay)
                 {
                   if (! infinity_seen)
                     {
                       infinity_seen = true;
                       facet_list(m++) = 1;
-                      AtInf(j) = true;
+                      at_inf(idx) = true;
                     }
                 }
               else
                 {
                   if (! neighbor->seen)
                     {
-                      voronoi_vertex = neighbor->center;
                       i++;
                       for (octave_idx_type d = 0; d < dim; d++)
-                        {
-                          v(i,d) = *(voronoi_vertex++);
-                        }
+                        F(i,d) = neighbor->center[d];
+
                       neighbor->seen = true;
                       neighbor->visitid = i;
                     }
+
                   facet_list(m++) = neighbor->visitid + 1;
                 }
             }
-          F.push_back (facet_list);
-          j++;
+
+          C(idx) = facet_list;
         }
 
-      // For compatibility with Matlab, pad the cell array of vertex
-      // lists with empty matrices if there are fewer facets than
-      // points.
-      octave_idx_type f_len = F.size ();
-      Cell C(np > f_len ? np : f_len, 1);
-
-      i = 0;
-      for (std::list<RowVector>::const_iterator it = F.begin ();
-           it != F.end (); it++)
-        C.elem (i++) = *it;
-
-      F.clear ();
-
-      AtInf.resize (f_len, 1);
-      retval(2) = AtInf;
+      retval(2) = at_inf;
       retval(1) = C;
-      retval(0) = v;
+      retval(0) = F;
     }
   else
-    error ("__voronoi__: qhull failed");
+    error ("%s: qhull failed", caller.c_str ());
 
-  // free memory from Qhull
+  // Free memory from Qhull
   qh_freeqhull (! qh_ALL);
 
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
 
   if (curlong || totlong)
-    warning ("__voronoi__: did not free %d bytes of long memory (%d pieces)",
-             totlong, curlong);
+    warning ("%s: qhull did not free %d bytes of long memory (%d pieces)",
+             caller.c_str (), totlong, curlong);
 
 #else
-  error ("__voronoi__: not available in this version of Octave");
+  error ("%s: not available in this version of Octave", caller.c_str ());
 #endif
 
   return retval;
 }
 
 /*
 
 ## No test needed for internal helper function.
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -89,127 +89,138 @@ convex hull is calculated.\n\n\
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
-  Matrix p (args(0).matrix_value ());
-  const octave_idx_type dim = p.columns ();
-  const octave_idx_type n = p.rows ();
+  Matrix points (args(0).matrix_value ());
+  const octave_idx_type dim = points.columns ();
+  const octave_idx_type num_points = points.rows ();
+
+  points = points.transpose ();
 
-  // Default options
   std::string options;
+
   if (dim <= 4)
-    options = "Qt";
+    options = " Qt";
   else
-    options = "Qt Qx";
+    options = " Qt Qx";
 
   if (nargin == 2)
     {
       if (args(1).is_string ())
-        options = args(1).string_value ();
+        options = " " + args(1).string_value ();
       else if (args(1).is_empty ())
-        ; // Use default options
+        ; // Use default options.
       else if (args(1).is_cellstr ())
         {
           options = "";
+
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
-            options += tmp(i) + " ";
+            options += " " + tmp(i);
         }
       else
         {
           error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
           return retval;
         }
      }
 
-
-  p = p.transpose ();
-  double *pt_array = p.fortran_vec ();
   boolT ismalloc = false;
 
-  // FIXME: we can't just pass options.c_str () to qh_new_qhull
-  // because the argument is not declared const.  Ugh.  Unless qh_new_qhull
-  // really needs to modify this argument, someone should fix QHULL.
-  OCTAVE_LOCAL_BUFFER (char, flags, 7 + options.length ());
-
-  sprintf (flags, "qhull %s", options.c_str ());
-
-  // Replace the 0 pointer with stdout for debugging information
+  // Replace the 0 pointer with stdout for debugging information.
   FILE *outfile = 0;
   FILE *errfile = stderr;
       
-  int exitcode = qh_new_qhull (dim, n, pt_array, 
-                               ismalloc, flags, outfile, errfile);
+  // qh_new_qhull command and points arguments are not const...
+
+  std::string cmd = "qhull" + options;
+
+  OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
+
+  strcpy (cmd_str, cmd.c_str ());
+
+  int exitcode = qh_new_qhull (dim, num_points, points.fortran_vec (),
+                               ismalloc, cmd_str, outfile, errfile);
   if (! exitcode)
     {
-      vertexT *vertex, **vertexp;
-      facetT *facet;
-      setT *vertices;
       bool nonsimp_seen = false;
+
       octave_idx_type nf = qh num_facets;
 
       Matrix idx (nf, dim + 1);
 
-      octave_idx_type i = 0, j;
+      facetT *facet;
+
+      octave_idx_type i = 0;
+
       FORALLfacets
         {
-          j = 0;
+          octave_idx_type j = 0;
 
           if (! nonsimp_seen && ! facet->simplicial)
             {
               nonsimp_seen = true;
 
-              if (options.find ("QJ") != std::string::npos)
+              if (cmd.find ("QJ") != std::string::npos)
                 {
-                  // should never happen with QJ
-                  error ("convhulln: qhull failed.  Option 'QJ' returned non-simplicial facet");
-                  break;
+                  // Should never happen with QJ.
+                  error ("convhulln: qhull failed: option 'QJ' returned non-simplicial facet");
+                  return retval;
                 }
             }
+
           if (dim == 3)
             {
-              vertices = qh_facet3vertex (facet);
+              setT *vertices = qh_facet3vertex (facet);
+
+              vertexT *vertex, **vertexp;
+
               FOREACHvertex_ (vertices)
                 idx(i, j++) = 1 + qh_pointid(vertex->point);
 
               qh_settempfree (&vertices);
             }
           else
             {
               if (facet->toporient ^ qh_ORIENTclock)
                 {
+                  vertexT *vertex, **vertexp;
+
                   FOREACHvertex_ (facet->vertices)
                     idx(i, j++) = 1 + qh_pointid(vertex->point);
                 }
               else
                 {
+                  vertexT *vertex, **vertexp;
+
                   FOREACHvertexreverse12_ (facet->vertices)
                     idx(i, j++) = 1 + qh_pointid(vertex->point);
                 }
             }
           if (j < dim)
-            warning ("facet %d only has %d vertices", i, j);
+            warning ("convhulln: facet %d only has %d vertices", i, j);
 
           i++;
         }
 
-      // Remove extra dimension if all facets were simplicial
+      // Remove extra dimension if all facets were simplicial.
+
       if (! nonsimp_seen)
         idx.resize (nf, dim, 0.0);
 
       if (nargout == 2)
-        // calculate volume of convex hull
-        // taken from qhull src/geom2.c
         {
+          // Calculate volume of convex hull, taken from qhull src/geom2.c.
+
           realT area;
           realT dist;
 
           FORALLfacets
             {
               if (! facet->normal)
                 continue;
 
@@ -235,17 +246,17 @@ convex hull is calculated.\n\n\
           retval(1) = octave_value (qh totvol);
         }
 
       retval(0) = idx;
     }
   else
     error ("convhulln: qhull failed");
 
-  // free memory from Qhull
+  // Free memory from Qhull
   qh_freeqhull (! qh_ALL);
 
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
 
   if (curlong || totlong)
     warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
              totlong, curlong);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -559,17 +559,17 @@ convert_position (const Matrix& pos, con
 static Matrix
 convert_text_position (const Matrix& pos, const text::properties& props,
                        const caseless_str& from_units,
                        const caseless_str& to_units)
 {
   graphics_object go = gh_manager::get_object (props.get___myhandle__ ());
   graphics_object ax = go.get_ancestor ("axes");
 
-  Matrix retval (1, pos.numel (), 0);
+  Matrix retval;
 
   if (ax.valid_object ())
     {
       const axes::properties& ax_props =
           dynamic_cast<const axes::properties&> (ax.get_properties ());
       graphics_xform ax_xform = ax_props.get_transform ();
       bool is_rectangle = (pos.numel () == 4);
       Matrix ax_bbox = ax_props.get_boundingbox (true),
@@ -578,25 +578,29 @@ convert_text_position (const Matrix& pos
       if (from_units.compare ("data"))
         {
           if (is_rectangle)
             {
               ColumnVector v1 = ax_xform.transform (pos(0), pos(1), 0),
                            v2 = ax_xform.transform (pos(0) + pos(2),
                                                     pos(1) + pos(3), 0);
 
+              retval.resize (1, 4);
+
               retval(0) = v1(0) - ax_bbox(0) + 1;
               retval(1) = ax_bbox(1) + ax_bbox(3) - v1(1) + 1;
               retval(2) = v2(0) - v1(0);
               retval(3) = v1(1) - v2(1);
             }
           else
             {
               ColumnVector v = ax_xform.transform (pos(0), pos(1), pos(2));
 
+              retval.resize (1, 3);
+
               retval(0) = v(0) - ax_bbox(0) + 1;
               retval(1) = ax_bbox(1) + ax_bbox(3) - v(1) + 1;
               retval(2) = 0;
             }
         }
       else
         retval = convert_position (pos, from_units, "pixels", ax_size);
 
@@ -606,26 +610,30 @@ convert_text_position (const Matrix& pos
             {
               if (is_rectangle)
                 {
                   ColumnVector v1 = ax_xform.untransform (retval(0) + ax_bbox(0) - 1,
                                                           ax_bbox(1) + ax_bbox(3)  - retval(1) + 1),
                                v2 = ax_xform.untransform (retval(0) + retval(2) + ax_bbox(0) - 1,
                                                           ax_bbox(1) + ax_bbox(3)  - (retval(1) + retval(3)) + 1);
 
+                  retval.resize (1, 4);
+
                   retval(0) = v1(0);
                   retval(1) = v1(1);
                   retval(2) = v2(0) - v1(0);
                   retval(3) = v2(1) - v1(1);
                 }
               else
                 {
                   ColumnVector v = ax_xform.untransform (retval(0) + ax_bbox(0) - 1,
                                                          ax_bbox(1) + ax_bbox(3)  - retval(1) + 1);
 
+                  retval.resize (1, 3);
+
                   retval(0) = v(0);
                   retval(1) = v(1);
                   retval(2) = v(2);
                 }
             }
           else
             retval = convert_position (retval, "pixels", to_units, ax_size);
         }
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1219,17 +1219,19 @@ read_mat5_binary_element (std::istream& 
                 // inline is not an object in Octave but rather an
                 // overload of a function handle. Special case.
                 tc =
                   new octave_fcn_inline (m.contents("expr")(0).string_value(),
                                          m.contents("args")(0).string_value());
               }
             else
               {
-                octave_class* cls = new octave_class (m, classname);
+                octave_class* cls
+                  = new octave_class (m, classname,
+                                      std::list<std::string> ());
 
                 if (cls->reconstruct_exemplar ())
                   {
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -510,17 +510,17 @@ octave_class::subsref (const std::string
                     // We handled two index elements, so tell
                     // next_subsref to skip both of them.
 
                     skip++;
                   }
               }
             else
               retval(0) = octave_value (map.index (idx.front ()),
-                                        class_name ());
+                                        c_name, parent_list);
           }
           break;
 
         case '.':
           {
             if (map.numel() > 0)
               {
                 Cell t = dotref (idx.front ());
@@ -586,18 +586,18 @@ octave_class::subsref (const std::string
           // if it has more than one element, to be able to pass through
           // rvalue1 calls.
           if (retval.length () > 1)
             retval = octave_value (retval, true);
         }
       else
         {
           if (type.length () == 1 && type[0] == '(')
-            retval(0) = octave_value (map.index (idx.front ()), class_name (),
-                                      parent_class_name_list ());
+            retval(0) = octave_value (map.index (idx.front ()), c_name,
+                                      parent_list);
           else
             gripe_invalid_index1 ();
         }
     }
 
   return retval;
 }
 
@@ -988,17 +988,17 @@ octave_class::index_vector (void) const
 {
   idx_vector retval;
 
   octave_value meth = symbol_table::find_method ("subsindex", class_name ());
 
   if (meth.is_defined ())
     {
       octave_value_list args;
-      args(0) = octave_value (new octave_class (map, c_name));
+      args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
         {
           if (tmp(0).is_object())
             error ("subsindex function must return a valid index vector");
           else
@@ -1118,17 +1118,17 @@ octave_class::all_strings (bool pad) con
 {
   string_vector retval;
 
   octave_value meth = symbol_table::find_method ("char", class_name ());
 
   if (meth.is_defined ())
     {
       octave_value_list args;
-      args(0) = octave_value (new octave_class (map, c_name));
+      args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
         {
           if (tmp(0).is_string ())
             retval = tmp(0).all_strings (pad);
           else
@@ -1949,17 +1949,19 @@ derived.\n\
             {
               if (fcn->is_class_constructor (id) || fcn->is_class_method (id))
                 {
                   octave_map m = args(0).map_value ();
 
                   if (! error_state)
                     {
                       if (nargin == 2)
-                        retval = octave_value (new octave_class (m, id));
+                        retval
+                          = octave_value (new octave_class
+                                          (m, id, std::list<std::string> ()));
                       else
                         {
                           octave_value_list parents = args.slice (2, nargin-2);
 
                           retval
                             = octave_value (new octave_class (m, id, parents));
                         }
 
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -50,38 +50,37 @@ octave_class : public octave_base_value
 public:
 
   octave_class (void)
     : octave_base_value (), map (), c_name (),
       parent_list (), obsolete_copies (0)
     { }
 
   octave_class (const octave_map& m, const std::string& id,
-                const std::list<std::string>& plist
-                  = std::list<std::string> ())
+                const std::list<std::string>& plist)
     : octave_base_value (), map (m), c_name (id),
       parent_list (plist), obsolete_copies (0)
     { }
 
+  octave_class (const octave_map& m, const std::string& id,
+                const octave_value_list& parents);
+
   octave_class (const octave_class& s)
     : octave_base_value (s), map (s.map), c_name (s.c_name),
       parent_list (s.parent_list), obsolete_copies (0)  { }
 
-  octave_class (const octave_map& m, const std::string& id,
-                const octave_value_list& parents);
-
   ~octave_class (void) { }
 
   octave_base_value *clone (void) const { return new octave_class (*this); }
 
   octave_base_value *unique_clone (void);
 
   octave_base_value *empty_clone (void) const
   {
-    return new octave_class (octave_map (map.keys ()), class_name ());
+    return new octave_class (octave_map (map.keys ()), c_name, parent_list);
   }
 
   Cell dotref (const octave_value_list& idx);
 
   Matrix size (void);
 
   octave_idx_type numel (const octave_value_list&);
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -275,18 +275,17 @@ public:
   octave_value (const Array<std::string>& cellstr);
   octave_value (const idx_vector& idx, bool lazy = true);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const octave_map& m);
   octave_value (const octave_scalar_map& m);
   octave_value (const Octave_map& m);
   octave_value (const Octave_map& m, const std::string& id,
-                const std::list<std::string>& plist
-                  = std::list<std::string> ());
+                const std::list<std::string>& plist);
   octave_value (const octave_value_list& m, bool = false);
   octave_value (octave_value::magic_colon);
 
   octave_value (octave_base_value *new_rep, bool borrow = false);
   octave_value (octave_base_value *new_rep, int xcount) GCC_ATTR_DEPRECATED;
 
   // Copy constructor.
 
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -58,17 +58,17 @@ octave_value
 xpow (const SparseMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               SparseMatrix tmp = SparseMatrix (nr, nr, nr);
@@ -131,17 +131,17 @@ octave_value
 xpow (const SparseComplexMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               SparseMatrix tmp = SparseMatrix (nr, nr, nr);
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -99,17 +99,17 @@ octave_value
 xpow (double a, const Matrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
@@ -150,17 +150,17 @@ octave_value
 xpow (double a, const ComplexMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
@@ -189,17 +189,17 @@ octave_value
 xpow (const Matrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = DiagMatrix (nr, nr, 1.0);
@@ -275,17 +275,17 @@ octave_value
 xpow (const DiagMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           DiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
             r.dgelem (i) = std::pow (a.dgelem (i), b);
           retval = r;
@@ -319,17 +319,17 @@ octave_value
 xpow (const Matrix& a, const Complex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       EIG a_eig (a);
 
       if (! error_state)
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
           ComplexMatrix Q (a_eig.eigenvectors ());
@@ -367,17 +367,17 @@ octave_value
 xpow (const Complex& a, const Matrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
@@ -415,17 +415,17 @@ octave_value
 xpow (const Complex& a, const ComplexMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
@@ -454,17 +454,17 @@ octave_value
 xpow (const ComplexMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = DiagMatrix (nr, nr, 1.0);
@@ -540,17 +540,17 @@ octave_value
 xpow (const ComplexMatrix& a, const Complex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       EIG a_eig (a);
 
       if (! error_state)
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
           ComplexMatrix Q (a_eig.eigenvectors ());
@@ -574,17 +574,17 @@ octave_value
 xpow (const ComplexDiagMatrix& a, const Complex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       ComplexDiagMatrix r (nr, nc);
       for (octave_idx_type i = 0; i < nc; i++)
         r(i, i) = std::pow (a(i, i), b);
       retval = r;
     }
 
@@ -1548,17 +1548,17 @@ octave_value
 xpow (float a, const FloatMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
@@ -1600,17 +1600,17 @@ octave_value
 xpow (float a, const FloatComplexMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
@@ -1639,17 +1639,17 @@ octave_value
 xpow (const FloatMatrix& a, float b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = FloatDiagMatrix (nr, nr, 1.0);
@@ -1725,17 +1725,17 @@ octave_value
 xpow (const FloatDiagMatrix& a, float b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           FloatDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
             r.dgelem (i) = std::pow (a.dgelem (i), b);
           retval = r;
@@ -1757,17 +1757,17 @@ octave_value
 xpow (const FloatMatrix& a, const FloatComplex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       FloatEIG a_eig (a);
 
       if (! error_state)
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
           FloatComplexMatrix Q (a_eig.eigenvectors ());
@@ -1805,17 +1805,17 @@ octave_value
 xpow (const FloatComplex& a, const FloatMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
@@ -1853,17 +1853,17 @@ octave_value
 xpow (const FloatComplex& a, const FloatComplexMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for x^A, A must be square");
+    error ("for x^A, A must be a square matrix");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
@@ -1892,17 +1892,17 @@ octave_value
 xpow (const FloatComplexMatrix& a, float b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       if (static_cast<int> (b) == b)
         {
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = FloatDiagMatrix (nr, nr, 1.0);
@@ -1978,17 +1978,17 @@ octave_value
 xpow (const FloatComplexMatrix& a, const FloatComplex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       FloatEIG a_eig (a);
 
       if (! error_state)
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
           FloatComplexMatrix Q (a_eig.eigenvectors ());
@@ -2012,17 +2012,17 @@ octave_value
 xpow (const FloatComplexDiagMatrix& a, const FloatComplex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be square");
+    error ("for A^b, A must be a square matrix");
   else
     {
       FloatComplexDiagMatrix r (nr, nc);
       for (octave_idx_type i = 0; i < nc; i++)
         r(i, i) = std::pow (a(i, i), b);
       retval = r;
     }
 
