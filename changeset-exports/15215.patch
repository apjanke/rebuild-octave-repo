# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1345671414 14400
#      Wed Aug 22 17:36:54 2012 -0400
# Node ID 9020dddc925a3a28cf98f98918735d2b9226f4e6
# Parent  ae6b7ee0a73394b212d5da9b7bdb1bd90026ba7f
use std::numeric_limits for integer max and min values

* strfind.cc, gl-render.cc, jit-typeinfo.cc, oct-stream.cc,
sparse-xpow.cc, xpow.cc, debug.cc, file-io.cc, ls-oct-ascii.cc,
oct-hist.cc, pr-output.cc, utils.cc, variables.h, ov-base-int.cc,
ov-base.cc, ov-bool-sparse.cc, ov-cx-sparse.cc, ov-float.cc,
ov-flt-re-mat.cc, ov-int16.cc, ov-int32.cc, ov-int64.cc, ov-int8.cc,
ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc, ov-struct.cc,
ov-uint16.cc, ov-uint32.cc, ov-uint64.cc, ov-uint8.cc, Array.cc,
Sparse.cc, chNDArray.cc, dNDArray.cc, data-conv.cc, data-conv.h,
fNDArray.cc, kpse.cc, oct-inttypes.h, oct-time.cc:
Use std::numeric_limits for max and min integer values.  Include
<limits>, not <climits>.

diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -20,52 +20,52 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <string>
-#include <climits>
 #include <algorithm>
 #include <deque>
+#include <limits>
+#include <string>
 
 #include "Cell.h"
 #include "ov.h"
 #include "defun.h"
 #include "unwind-prot.h"
 #include "gripes.h"
 #include "utils.h"
 
 // This allows safe indexing with char. In C++, char may be (and often is) signed!
 #define ORD(ch) static_cast<unsigned char>(ch)
-#define TABSIZE (UCHAR_MAX + 1)
+#define TABSIZE (std::numeric_limits<unsigned char>::max () + 1)
 
 // This is the quick search algorithm, as described at
 // http://www-igm.univ-mlv.fr/~lecroq/string/node19.html
 static void
 qs_preprocess (const Array<char>& needle,
-               octave_idx_type table[TABSIZE])
+               octave_idx_type *table)
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
 
    for (octave_idx_type i = 0; i < TABSIZE; i++)
       table[i] = m + 1;
    for (octave_idx_type i = 0; i < m; i++)
       table[ORD(x[i])] = m - i;
 }
 
 
 static Array<octave_idx_type>
 qs_search (const Array<char>& needle,
            const Array<char>& haystack,
-           const octave_idx_type table[TABSIZE],
+           const octave_idx_type *table,
            bool overlaps = true)
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
   const char *y = haystack.data ();
   octave_idx_type n = haystack.numel ();
 
   // We'll use deque because it typically has the most favorable properties for
@@ -256,17 +256,17 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
 %!error strfind ("foo", "bar", 1)
 %!error <PATTERN must be a string> strfind ("foo", 100)
 %!error <first argument must be a string> strfind (100, "foo")
 */
 
 static Array<char>
 qs_replace (const Array<char>& str, const Array<char>& pat,
             const Array<char>& rep,
-            const octave_idx_type table[TABSIZE],
+            const octave_idx_type *table,
             bool overlaps = true)
 {
   Array<char> ret = str;
 
   octave_idx_type siz = str.numel (), psiz = pat.numel (), rsiz = rep.numel ();
 
   if (psiz != 0)
     {
diff --git a/libinterp/interp-core/gl-render.cc b/libinterp/interp-core/gl-render.cc
--- a/libinterp/interp-core/gl-render.cc
+++ b/libinterp/interp-core/gl-render.cc
@@ -130,17 +130,17 @@ public:
     { return rep->valid; }
 };
 
 static int
 next_power_of_2 (int n)
 {
   int m = 1;
 
-  while (m < n && m < INT_MAX)
+  while (m < n && m < std::numeric_limits<int>::max ())
     m <<= 1;
 
   return m;
 }
 
 opengl_texture
 opengl_texture::create (const octave_value& data)
 {
@@ -1420,17 +1420,17 @@ opengl_renderer::draw_axes (const axes::
 void
 opengl_renderer::draw_line (const line::properties& props)
 {
   Matrix x = xform.xscale (props.get_xdata ().matrix_value ());
   Matrix y = xform.yscale (props.get_ydata ().matrix_value ());
   Matrix z = xform.zscale (props.get_zdata ().matrix_value ());
 
   bool has_z = (z.numel () > 0);
-  int n = static_cast<int> (::xmin (::xmin (x.numel (), y.numel ()), (has_z ? z.numel () : INT_MAX)));
+  int n = static_cast<int> (::xmin (::xmin (x.numel (), y.numel ()), (has_z ? z.numel () : std::numeric_limits<int>::max ())));
   octave_uint8 clip_mask = (props.is_clipping () ? 0x7F : 0x40), clip_ok (0x40);
 
   std::vector<octave_uint8> clip (n);
 
   if (has_z)
     for (int i = 0; i < n; i++)
       clip[i] = (clip_code (x(i), y(i), z(i)) & clip_mask);
   else
diff --git a/libinterp/interp-core/jit-typeinfo.cc b/libinterp/interp-core/jit-typeinfo.cc
--- a/libinterp/interp-core/jit-typeinfo.cc
+++ b/libinterp/interp-core/jit-typeinfo.cc
@@ -376,18 +376,18 @@ octave_jit_complex_div (Complex lhs, Com
   return lhs / rhs;
 }
 
 // FIXME: CP form src/xpow.cc
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
-          && ((x >= 0 && x < INT_MAX)
-              || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < std::numeric_limits<int>::max ())
+              || (x <= 0 && x > std::numermic_limits<int>::min ())));
 }
 
 extern "C" Complex
 octave_jit_pow_scalar_scalar (double lhs, double rhs)
 {
   // FIXME: almost CP from src/xpow.cc
   if (lhs < 0.0 && ! xisint (rhs))
     return std::pow (Complex (lhs), rhs);
diff --git a/libinterp/interp-core/oct-stream.cc b/libinterp/interp-core/oct-stream.cc
--- a/libinterp/interp-core/oct-stream.cc
+++ b/libinterp/interp-core/oct-stream.cc
@@ -1440,17 +1440,17 @@ do_scanf_conv (std::istream&, const scan
 #define BEGIN_CHAR_CLASS_CONVERSION() \
   int width = elt->width; \
  \
   std::string tmp; \
  \
   do \
     { \
       if (! width) \
-        width = INT_MAX; \
+        width = std::numeric_limits<int>::max (); \
  \
       std::ostringstream buf; \
  \
       std::string char_class = elt->char_class; \
  \
       int c = EOF; \
  \
       if (elt->type == '[') \
@@ -1463,17 +1463,17 @@ do_scanf_conv (std::istream&, const scan
       else \
         { \
           int chars_read = 0; \
           while (is && chars_read++ < width && (c = is.get ()) != EOF \
                  && char_class.find (c) == std::string::npos) \
             buf << static_cast<char> (c); \
         } \
  \
-      if (width == INT_MAX && c != EOF) \
+      if (width == std::numeric_limits<int>::max () && c != EOF) \
         is.putback (c); \
  \
       tmp = buf.str (); \
  \
       if (tmp.empty ()) \
         is.setstate (std::ios::failbit); \
       else if (c == EOF) \
         is.clear (); \
diff --git a/libinterp/interp-core/sparse-xpow.cc b/libinterp/interp-core/sparse-xpow.cc
--- a/libinterp/interp-core/sparse-xpow.cc
+++ b/libinterp/interp-core/sparse-xpow.cc
@@ -21,17 +21,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
-#include <climits>
+
+#include <limits>
 
 #include "Array-util.h"
 #include "oct-cmplx.h"
 #include "quit.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
@@ -41,18 +42,18 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "sparse-xpow.h"
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
-          && ((x >= 0 && x < INT_MAX)
-              || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < std::numeric_limits<int>::max ())
+              || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 
 // Safer pow functions. Only two make sense for sparse matrices, the
 // others should all promote to full matrices.
 
 octave_value
 xpow (const SparseMatrix& a, double b)
diff --git a/libinterp/interp-core/xpow.cc b/libinterp/interp-core/xpow.cc
--- a/libinterp/interp-core/xpow.cc
+++ b/libinterp/interp-core/xpow.cc
@@ -21,17 +21,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
-#include <climits>
+
+#include <limits>
 
 #include "Array-util.h"
 #include "CColVector.h"
 #include "CDiagMatrix.h"
 #include "fCDiagMatrix.h"
 #include "CMatrix.h"
 #include "EIG.h"
 #include "fEIG.h"
@@ -54,18 +55,18 @@ along with Octave; see the file COPYING.
 #ifdef _OPENMP
 #include <omp.h>
 #endif
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
-          && ((x >= 0 && x < INT_MAX)
-              || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < std::numeric_limits<int>::max ())
+              || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 // Safer pow functions.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
 //   scalar   |     | 1 | 5 |  7 | 11 |
 //                  +---+---+----+----+
@@ -1503,18 +1504,18 @@ elem_xpow (const ComplexNDArray& a, cons
 
   return result;
 }
 
 static inline int
 xisint (float x)
 {
   return (D_NINT (x) == x
-          && ((x >= 0 && x < INT_MAX)
-              || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < std::numeric_limits<int>::max ())
+              || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 // Safer pow functions.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
 //   scalar   |     | 1 | 5 |  7 | 11 |
 //                  +---+---+----+----+
diff --git a/libinterp/interpfcn/debug.cc b/libinterp/interpfcn/debug.cc
--- a/libinterp/interpfcn/debug.cc
+++ b/libinterp/interpfcn/debug.cc
@@ -820,17 +820,18 @@ with line numbers.\n\
   if (! error_state)
     {
       switch (nargin)
         {
         case 0: // dbtype
           dbg_fcn = get_user_code ();
 
           if (dbg_fcn)
-            do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
+            do_dbtype (octave_stdout, dbg_fcn->name (), 0,
+                       std::numeric_limits<int>::max ());
           else
             error ("dbtype: must be inside a user function to give no arguments to dbtype\n");
           break;
 
         case 1: // (dbtype func) || (dbtype start:end)
           {
             std::string arg = argv[1];
 
@@ -843,17 +844,17 @@ with line numbers.\n\
                 if (dbg_fcn)
                   {
                     std::string start_str = arg.substr (0, ind);
                     std::string end_str = arg.substr (ind + 1);
 
                     int start, end;
                     start = atoi (start_str.c_str ());
                     if (end_str == "end")
-                      end = INT_MAX;
+                      end = std::numeric_limits<int>::max ();
                     else
                       end = atoi (end_str.c_str ());
 
                     if (std::min (start, end) <= 0)
                       error ("dbtype: start and end lines must be >= 1\n");
 
                     if (start <= end)
                       do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
@@ -861,17 +862,18 @@ with line numbers.\n\
                       error ("dbtype: start line must be less than end line\n");
                   }
               }
             else  // (dbtype func)
               {
                 dbg_fcn = get_user_code (arg);
 
                 if (dbg_fcn)
-                  do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
+                  do_dbtype (octave_stdout, dbg_fcn->name (), 0,
+                             std::numeric_limits<int>::max ());
                 else
                   error ("dbtype: function <%s> not found\n", arg.c_str ());
               }
           }
           break;
 
         case 2: // (dbtype func start:end) , (dbtype func start)
           dbg_fcn = get_user_code (argv[1]);
@@ -884,17 +886,17 @@ with line numbers.\n\
 
               if (ind != std::string::npos)
                 {
                   std::string start_str = arg.substr (0, ind);
                   std::string end_str = arg.substr (ind + 1);
 
                   start = atoi (start_str.c_str ());
                   if (end_str == "end")
-                    end = INT_MAX;
+                    end = std::numeric_limits<int>::max ();
                   else
                     end = atoi (end_str.c_str ());
                 }
               else
                 {
                   start = atoi (arg.c_str ());
                   end = start;
                 }
diff --git a/libinterp/interpfcn/file-io.cc b/libinterp/interpfcn/file-io.cc
--- a/libinterp/interpfcn/file-io.cc
+++ b/libinterp/interpfcn/file-io.cc
@@ -34,20 +34,20 @@ along with Octave; see the file COPYING.
 // Extensively revised by John W. Eaton <jwe@octave.org>,
 // April 1996.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cerrno>
-#include <climits>
 #include <cstdio>
 
 #include <iostream>
+#include <limits>
 #include <locale>
 #include <stack>
 #include <stdexcept>
 #include <vector>
 
 #include <fcntl.h>
 #include <sys/types.h>
 #include <unistd.h>
diff --git a/libinterp/interpfcn/ls-oct-ascii.cc b/libinterp/interpfcn/ls-oct-ascii.cc
--- a/libinterp/interpfcn/ls-oct-ascii.cc
+++ b/libinterp/interpfcn/ls-oct-ascii.cc
@@ -423,10 +423,11 @@ DEFUN (save_precision, args, nargout,
 Query or set the internal variable that specifies the number of\n\
 digits to keep when saving data in text format.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
-  return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1, INT_MAX);
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1,
+                                            std::numeric_limits<int>::max ());
 }
diff --git a/libinterp/interpfcn/oct-hist.cc b/libinterp/interpfcn/oct-hist.cc
--- a/libinterp/interpfcn/oct-hist.cc
+++ b/libinterp/interpfcn/oct-hist.cc
@@ -693,17 +693,18 @@ but may be overridden by the environment
 @seealso{history_file, history_timestamp_format_string, saving_history}\n\
 @end deftypefn")
 {
   int old_history_size = command_history::size ();
 
   int tmp = old_history_size;
 
   octave_value retval = set_internal_variable (tmp, args, nargout,
-                                               "history_size", -1, INT_MAX);
+                                               "history_size", -1,
+                                               std::numeric_limits<int>::max ());
 
   if (tmp != old_history_size)
     command_history::set_size (tmp);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
diff --git a/libinterp/interpfcn/pr-output.cc b/libinterp/interpfcn/pr-output.cc
--- a/libinterp/interpfcn/pr-output.cc
+++ b/libinterp/interpfcn/pr-output.cc
@@ -351,17 +351,19 @@ rational_approx (double val, int len)
 
   if (len <= 0)
     len = 10;
 
   if (xisinf (val))
     s = "1/0";
   else if (xisnan (val))
     s = "0/0";
-  else if (val < INT_MIN || val > INT_MAX || D_NINT (val) == val)
+  else if (val < std::numeric_limits<int>::min ()
+           || val > std::numeric_limits<int>::max ()
+           || D_NINT (val) == val)
     {
       std::ostringstream buf;
       buf.flags (std::ios::fixed);
       buf << std::setprecision (0) << xround (val);
       s = buf.str ();
     }
   else
     {
@@ -380,17 +382,17 @@ rational_approx (double val, int len)
       while (1)
         {
           double flip = 1. / frac;
           double step = xround (flip);
           double nextn = n;
           double nextd = d;
 
           // Have we converged to 1/intmax ?
-          if (m > 100 || fabs (frac) < 1 / static_cast<double>(INT_MAX))
+          if (m > 100 || fabs (frac) < 1 / static_cast<double> (std::numeric_limits<int>::max ()))
             {
               lastn = n;
               lastd = d;
               break;
             }
 
           frac = flip - step;
           n = n * step + lastn;
@@ -4063,27 +4065,29 @@ Query or set the internal variable that 
 of a numeric output field.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_precision}\n\
 @end deftypefn")
 {
-  return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_max_field_width, 0, INT_MAX);
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_max_field_width, 0,
+                                            std::numeric_limits<int>::max ());
 }
 
 DEFUN (output_precision, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} output_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the minimum number of\n\
 significant figures to display for numeric output.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_max_field_width}\n\
 @end deftypefn")
 {
-  return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1, INT_MAX);
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1,
+                                            std::numeric_limits<int>::max ());
 }
diff --git a/libinterp/interpfcn/utils.cc b/libinterp/interpfcn/utils.cc
--- a/libinterp/interpfcn/utils.cc
+++ b/libinterp/interpfcn/utils.cc
@@ -21,21 +21,21 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cerrno>
-#include <climits>
 #include <cstring>
 
 #include <fstream>
 #include <iostream>
+#include <limits>
 #include <string>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "vasnprintf.h"
 
 #include "quit.h"
@@ -1261,17 +1261,19 @@ octave_sleep (double seconds)
   if (seconds > 0)
     {
       double t;
 
       unsigned int usec
         = static_cast<unsigned int> (modf (seconds, &t) * 1000000);
 
       unsigned int sec
-        = (t > UINT_MAX) ? UINT_MAX : static_cast<unsigned int> (t);
+        = ((t > std::numeric_limits<unsigned int>::max ())
+           ? std::numeric_limits<unsigned int>::max ()
+           : static_cast<unsigned int> (t));
 
       // Versions of these functions that accept unsigned int args are
       // defined in cutils.c.
       octave_sleep (sec);
       octave_usleep (usec);
 
       octave_quit ();
     }
diff --git a/libinterp/interpfcn/variables.h b/libinterp/interpfcn/variables.h
--- a/libinterp/interpfcn/variables.h
+++ b/libinterp/interpfcn/variables.h
@@ -27,21 +27,23 @@ class octave_function;
 class octave_user_function;
 
 class tree_identifier;
 class octave_value;
 class octave_value_list;
 class octave_builtin;
 class string_vector;
 
-#include <climits>
 #include <cfloat>
 
+#include <limits>
 #include <string>
 
+#include "lo-ieee.h"
+
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern OCTINTERP_API void clear_mex_functions (void);
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const octave_value&, const std::string& = std::string (),
@@ -92,17 +94,18 @@ set_internal_variable (bool& var, const 
 
 extern OCTINTERP_API octave_value
 set_internal_variable (char& var, const octave_value_list& args,
                        int nargout, const char *nm);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (int& var, const octave_value_list& args,
                        int nargout, const char *nm,
-                       int minval = INT_MIN, int maxval = INT_MAX);
+                       int minval = std::numeric_limits<int>::min (),
+                       int maxval = std::numeric_limits<int>::max ());
 
 extern OCTINTERP_API octave_value
 set_internal_variable (double& var, const octave_value_list& args,
                        int nargout, const char *nm,
                        double minval = -octave_Inf,
                        double maxval = octave_Inf);
 
 extern OCTINTERP_API octave_value
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
@@ -60,29 +59,35 @@ along with Octave; see the file COPYING.
 // octave_base_int_helper_traits) to avoid a few warnings from GCC
 // about comparisons always false due to limited range of data types.
 // Ugh.  The cure may be worse than the disease.
 
 template <class T, bool is_signed = true, bool can_be_too_big = true>
 struct octave_base_int_helper
 {
   static bool
-  char_value_out_of_range (T val) { return val < 0 || val > UCHAR_MAX; }
+  char_value_out_of_range (T val)
+  {
+    return val < 0 || val > std::numeric_limits<unsigned char>::max ();
+  }
 };
 
 template <class T>
 struct octave_base_int_helper<T, false, false>
 {
   static bool char_value_out_of_range (T) { return false; }
 };
 
 template <class T>
 struct octave_base_int_helper<T, false, true>
 {
-  static bool char_value_out_of_range (T val) { return val > UCHAR_MAX; }
+  static bool char_value_out_of_range (T val)
+  {
+    return val > std::numeric_limits<unsigned char>::max ();
+  }
 };
 
 template <class T>
 struct octave_base_int_helper<T, true, false>
 {
   static bool char_value_out_of_range (T val) { return val < 0; }
 };
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -20,19 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-map.h"
@@ -445,50 +444,50 @@ octave_base_value::print_with_name (std:
 
 void
 octave_base_value::print_info (std::ostream& os,
                                const std::string& /* prefix */) const
 {
   os << "no info for type: " << type_name () << "\n";
 }
 
-#define INT_CONV_METHOD(T, F, MIN_LIMIT, MAX_LIMIT) \
+#define INT_CONV_METHOD(T, F) \
   T \
   octave_base_value::F ## _value (bool require_int, bool frc_str_conv) const \
   { \
     T retval = 0; \
  \
     double d = double_value (frc_str_conv); \
  \
     if (! error_state) \
       { \
         if (require_int && D_NINT (d) != d) \
           error_with_cfn ("conversion of %g to " #T " value failed", d); \
-        else if (d < MIN_LIMIT) \
-          retval = MIN_LIMIT; \
-        else if (d > MAX_LIMIT) \
-          retval = MAX_LIMIT; \
+        else if (d < std::numeric_limits<T>::min ()) \
+          retval = std::numeric_limits<T>::min (); \
+        else if (d > std::numeric_limits<T>::max ()) \
+          retval = std::numeric_limits<T>::max (); \
         else \
           retval = static_cast<T> (::fix (d));  \
       } \
     else \
       gripe_wrong_type_arg ("octave_base_value::" #F "_value ()", \
                             type_name ()); \
  \
     return retval; \
   }
 
-INT_CONV_METHOD (short int, short, SHRT_MIN, SHRT_MAX)
-INT_CONV_METHOD (unsigned short int, ushort, 0, USHRT_MAX)
+INT_CONV_METHOD (short int, short)
+INT_CONV_METHOD (unsigned short int, ushort)
 
-INT_CONV_METHOD (int, int, INT_MIN, INT_MAX)
-INT_CONV_METHOD (unsigned int, uint, 0, UINT_MAX)
+INT_CONV_METHOD (int, int)
+INT_CONV_METHOD (unsigned int, uint)
 
-INT_CONV_METHOD (long int, long, LONG_MIN, LONG_MAX)
-INT_CONV_METHOD (unsigned long int, ulong, 0, ULONG_MAX)
+INT_CONV_METHOD (long int, long)
+INT_CONV_METHOD (unsigned long int, ulong)
 
 int
 octave_base_value::nint_value (bool frc_str_conv) const
 {
   int retval = 0;
 
   double d = double_value (frc_str_conv);
 
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -20,19 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "dim-vector.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-bool.h"
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -20,19 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -110,17 +110,17 @@ octave_float_scalar::convert_to_str_inte
   octave_value retval;
 
   if (xisnan (scalar))
     gripe_nan_to_character_conversion ();
   else
     {
       int ival = NINT (scalar);
 
-      if (ival < 0 || ival > UCHAR_MAX)
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME -- is there something better we could do?
 
           ival = 0;
 
           ::warning ("range error for conversion to character value");
         }
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -20,19 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "data-conv.h"
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
@@ -64,20 +63,16 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "ops.h"
 
 #include "byte-swap.h"
 #include "ls-oct-ascii.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
-#if ! defined (UCHAR_MAX)
-#define UCHAR_MAX 255
-#endif
-
 template class octave_base_matrix<FloatNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_matrix, "float matrix", "single");
 
 octave_base_value *
 octave_float_matrix::try_narrowing_conversion (void)
@@ -303,17 +298,17 @@ octave_float_matrix::convert_to_str_inte
         {
           gripe_nan_to_character_conversion ();
           return retval;
         }
       else
         {
           int ival = NINT (d);
 
-          if (ival < 0 || ival > UCHAR_MAX)
+          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
               // FIXME -- is there something
               // better we could do?
 
               ival = 0;
 
               if (! warned)
                 {
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -20,19 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "data-conv.h"
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
@@ -64,20 +63,16 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-ascii.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
-#if ! defined (UCHAR_MAX)
-#define UCHAR_MAX 255
-#endif
-
 template class octave_base_matrix<NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_matrix, "matrix", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
@@ -405,17 +400,17 @@ octave_matrix::convert_to_str_internal (
         {
           gripe_nan_to_character_conversion ();
           return retval;
         }
       else
         {
           int ival = NINT (d);
 
-          if (ival < 0 || ival > UCHAR_MAX)
+          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
               // FIXME -- is there something
               // better we could do?
 
               ival = 0;
 
               if (! warned)
                 {
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -20,19 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
@@ -228,17 +227,17 @@ octave_sparse_matrix::convert_to_str_int
                 {
                   gripe_nan_to_character_conversion ();
                   return retval;
                 }
               else
                 {
                   int ival = NINT (d);
 
-                  if (ival < 0 || ival > UCHAR_MAX)
+                  if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
                     {
                       // FIXME -- is there something
                       // better we could do?
 
                       ival = 0;
 
                       if (! warned)
                         {
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -125,17 +125,17 @@ octave_scalar::convert_to_str_internal (
   octave_value retval;
 
   if (xisnan (scalar))
     gripe_nan_to_character_conversion ();
   else
     {
       int ival = NINT (scalar);
 
-      if (ival < 0 || ival > UCHAR_MAX)
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME -- is there something better we could do?
 
           ival = 0;
 
           ::warning ("range error for conversion to character value");
         }
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -2207,18 +2207,18 @@ DEFUN (struct_levels_to_print, args, nar
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
-  return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print,
-                                            -1, INT_MAX);
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print, -1,
+                                            std::numeric_limits<int>::max ());
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_struct_array_contents ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -19,19 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
-
 #include <iostream>
+#include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -23,17 +23,16 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
-#include <climits>
 
 #include <iostream>
 #include <sstream>
 #include <vector>
 #include <algorithm>
 #include <new>
 
 #include "Array.h"
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -23,20 +23,20 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
-#include <climits>
 
 #include <algorithm>
 #include <iostream>
+#include <limits>
 #include <sstream>
 #include <vector>
 
 #include "Array.h"
 #include "MArray.h"
 #include "Array-util.h"
 #include "Range.h"
 #include "idx-vector.h"
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -74,17 +74,17 @@ charNDArray::concat (const NDArray& rb, 
           (*current_liboctave_error_handler)
             ("invalid conversion from NaN to character");
           return *this;
         }
       else
         {
           octave_idx_type ival = NINTbig (d);
 
-          if (ival < 0 || ival > UCHAR_MAX)
+          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             // FIXME -- is there something
             // better we could do? Should we warn the user?
             ival = 0;
 
           tmp.elem (i) = static_cast<char>(ival);
         }
     }
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -771,17 +771,17 @@ NDArray::concat (const charNDArray& rb, 
           (*current_liboctave_error_handler)
             ("invalid conversion from NaN to character");
           return retval;
         }
       else
         {
           octave_idx_type ival = NINTbig (d);
 
-          if (ival < 0 || ival > UCHAR_MAX)
+          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             // FIXME -- is there something
             // better we could do? Should we warn the user?
             ival = 0;
 
           retval.elem (i) = static_cast<char>(ival);
         }
     }
 
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
+#include <climits>
 #include <cstdlib>
 
 #include <iostream>
 #include <vector>
 
 #include "byte-swap.h"
 #include "data-conv.h"
 #include "lo-error.h"
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -18,17 +18,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_data_conv_h)
 #define octave_data_conv_h 1
 
-#include <climits>
+#include <limits>
 
 #include "mach-info.h"
 
 class
 OCTAVE_API
 oct_data_conv
 {
 public:
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -731,17 +731,17 @@ FloatNDArray::concat (const charNDArray&
           (*current_liboctave_error_handler)
             ("invalid conversion from NaN to character");
           return retval;
         }
       else
         {
           octave_idx_type ival = NINTbig (d);
 
-          if (ival < 0 || ival > UCHAR_MAX)
+          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             // FIXME -- is there something
             // better we could do? Should we warn the user?
             ival = 0;
 
           retval.elem (i) = static_cast<char>(ival);
         }
     }
 
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -124,17 +124,16 @@ extern "C" {
 #include "str-vec.h"
 
 /* Header files that essentially all of our sources need, and
    that all implementations have.  We include these first, to help with
    NULL being defined multiple times.  */
 #include <cstdio>
 #include <cstdarg>
 #include <cstdlib>
-#include <climits>
 #include <cerrno>
 #include <cassert>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "sysdir.h"
 #include "statdefs.h"
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -19,17 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_inttypes_h)
 #define octave_inttypes_h 1
 
-#include <climits>
 #include <cstdlib>
 
 #include <limits>
 #include <iosfwd>
 
 #include "lo-traits.h"
 #include "lo-math.h"
 #include "lo-mappers.h"
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -19,17 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
+#include <limits>
+
 #include <ctime>
 
 #include <sys/time.h>
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "strftime.h"
 
@@ -116,17 +117,18 @@ octave_time::stamp (void)
   DEFINE_SET_FIELD_FCN (int, f, lo, hi)
 
 DEFINE_SET_INT_FIELD_FCN (usec, 0, 1000000)
 DEFINE_SET_INT_FIELD_FCN (sec, 0, 61)
 DEFINE_SET_INT_FIELD_FCN (min, 0, 59)
 DEFINE_SET_INT_FIELD_FCN (hour, 0, 23)
 DEFINE_SET_INT_FIELD_FCN (mday, 1, 31)
 DEFINE_SET_INT_FIELD_FCN (mon, 0, 11)
-DEFINE_SET_INT_FIELD_FCN (year, INT_MIN, INT_MAX)
+DEFINE_SET_INT_FIELD_FCN (year, std::numeric_limits<int>::min (),
+                          std::numeric_limitd<int>::max ())
 DEFINE_SET_INT_FIELD_FCN (wday, 0, 6)
 DEFINE_SET_INT_FIELD_FCN (yday, 0, 365)
 DEFINE_SET_INT_FIELD_FCN (isdst, 0, 1)
 DEFINE_SET_FIELD_FCN (long, gmtoff, -86400, 0)
 
 octave_base_tm&
 octave_base_tm::zone (const std::string& s)
 {
@@ -251,17 +253,17 @@ octave_strptime::init (const std::string
 {
   struct tm t;
 
   t.tm_sec = 0;
   t.tm_min = 0;
   t.tm_hour = 0;
   t.tm_mday = 0;
   t.tm_mon = -1;
-  t.tm_year = INT_MIN;
+  t.tm_year = std::numeric_limits<int>::min ();
   t.tm_wday = 0;
   t.tm_yday = 0;
   t.tm_isdst = 0;
 
 #if defined (HAVE_STRUCT_TM_GMTOFF)
   t.tm_gmtoff = 0;
 #endif
 
@@ -271,26 +273,27 @@ octave_strptime::init (const std::string
 #endif
 
   const char *p = str.c_str ();
 
   char *q = gnulib::strptime (p, fmt.c_str (), &t);
 
   // Fill in wday and yday, but only if mday is valid and the mon and year
   // are filled in, avoiding issues with mktime and invalid dates.
-  if (t.tm_mday != 0 && t.tm_mon >= 0 && t.tm_year != INT_MIN)
+  if (t.tm_mday != 0 && t.tm_mon >= 0
+      && t.tm_year != std::numeric_limits<int>::min ())
     {
       t.tm_isdst = -1;
       gnulib::mktime (&t);
     }
 
   if (t.tm_mon < 0)
     t.tm_mon = 0;
 
-  if (t.tm_year == INT_MIN)
+  if (t.tm_year == std::numeric_limits<int>::min ())
     t.tm_year = 0;
 
   if (q)
     nchars = q - p + 1;
   else
     nchars = 0;
 
   octave_base_tm::init (&t);
