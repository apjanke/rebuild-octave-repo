# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1452807612 18000
#      Thu Jan 14 16:40:12 2016 -0500
# Node ID f7cc48f601d239ca1c5dfaca832f917e4517bf10
# Parent  a9ed4104ecfdc787d66ccac338f2acb76463433c
additional reworking of error handling in the parser (bug #46877)

* oct-parse.in.yy (ABORT_PARSE): Delete.  Replace all uses with
YYABORT.  Ensure that all uses of octave_base_parser::bison_error are
followed by YYABORT.
(octave_base_parser::make_for_command): Always delete unused parse
tree elements if an error is detected.
octave_base_parser::make_index_expression): Likewise.
(octave_base_parser::parse_error_msg): New data member.
(octave_base_parser::bison_error): Store error message for later use
instead of calling parse_error.
(octave_parser::run, octave_push_parser::run): Check return status of
Bison-generated parser and call parse_error here with stored message.
Handle exceptions generated while parsing.

diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -103,27 +103,16 @@ bool reading_startup_message_printed = f
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 static void yyerror (octave_base_parser& parser, const char *s);
 
-#define ABORT_PARSE \
-  do \
-    { \
-      yyerrok; \
-      if (interactive && ! lexer.input_from_eval_string ()) \
-        YYACCEPT; \
-      else \
-        YYABORT; \
-    } \
-  while (0)
-
 #define lexer parser.lexer
 #define scanner lexer.scanner
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 // Disable this warning for code that is generated by Bison, including
 // grammar rules.  Push the current state so we can restore the warning
 // state prior to functions we define at the bottom of the file.
 #pragma GCC diagnostic push
@@ -417,17 +406,17 @@ input           : simple_list '\n'
                     $$ = 0;
                     lexer.end_of_input = true;
                     parser.stmt_list = $1;
                     YYACCEPT;
                   }
                 | parse_error
                   {
                     $$ = 0;
-                    ABORT_PARSE;
+                    YYABORT;
                   }
                 ;
 
 simple_list     : opt_sep_no_nl
                   {
                     YYUSE ($1);
 
                     $$ = 0;
@@ -475,17 +464,17 @@ statement       : expression
 // WHILE, etc.
 
 word_list_cmd   : identifier word_list
                   {
                     $$ = parser.make_index_expression ($1, $2, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $2.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 word_list       : string
                   { $$ = new tree_argument_list ($1); }
                 | word_list string
                   {
@@ -684,44 +673,44 @@ oper_expr       : primary_expr
                 | oper_expr MINUS_MINUS
                   { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
                   {
                     $$ = parser.make_index_expression ($1, 0, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | oper_expr '(' arg_list ')'
                   {
                     $$ = parser.make_index_expression ($1, $3, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | oper_expr '{' '}'
                   {
                     $$ = parser.make_index_expression ($1, 0, '{');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | oper_expr '{' arg_list '}'
                   {
                     $$ = parser.make_index_expression ($1, $3, '{');
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | oper_expr HERMITIAN
                   { $$ = parser.make_postfix_op (HERMITIAN, $1, $2); }
                 | oper_expr TRANSPOSE
                   { $$ = parser.make_postfix_op (TRANSPOSE, $1, $2); }
                 | oper_expr indirect_ref_op STRUCT_ELT
                   { $$ = parser.make_indirect_ref ($1, $3->text ()); }
@@ -770,44 +759,44 @@ power_expr      : primary_expr
                 | power_expr MINUS_MINUS
                   { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | power_expr '(' ')'
                   {
                     $$ = parser.make_index_expression ($1, 0, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | power_expr '(' arg_list ')'
                   {
                     $$ = parser.make_index_expression ($1, $3, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | power_expr '{' '}'
                   {
                     $$ = parser.make_index_expression ($1, 0, '{');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | power_expr '{' arg_list '}'
                   {
                     $$ = parser.make_index_expression ($1, $3, '{');
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | power_expr indirect_ref_op STRUCT_ELT
                   { $$ = parser.make_indirect_ref ($1, $3->text ()); }
                 | power_expr indirect_ref_op '(' expression ')'
                   { $$ = parser.make_indirect_ref ($1, $4); }
                 | PLUS_PLUS power_expr %prec POW
                   { $$ = parser.make_prefix_op (PLUS_PLUS, $2, $1); }
@@ -830,17 +819,17 @@ colon_expr1     : oper_expr
                 | colon_expr1 ':' oper_expr
                   {
                     YYUSE ($2);
 
                     if (! ($$ = $1->append ($3)))
                       {
                         delete $1;
                         delete $3;
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 simple_expr     : colon_expr
                   { $$ = $1; }
                 | simple_expr LSHIFT simple_expr
                   { $$ = parser.make_binary_op (LSHIFT, $1, $2, $3); }
@@ -872,17 +861,17 @@ assign_lhs      : simple_expr
                   {
                     $$ = parser.validate_matrix_for_assignment ($1);
 
                     if ($$)
                       { lexer.looking_at_matrix_or_assign_lhs = false; }
                     else
                       {
                         // validate_matrix_for_assignment deleted $1.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 assign_expr     : assign_lhs '=' expression
                   { $$ = parser.make_assign_op ('=', $1, $2, $3); }
                 | assign_lhs ADD_EQ expression
                   { $$ = parser.make_assign_op (ADD_EQ, $1, $2, $3); }
@@ -918,24 +907,29 @@ expression      : simple_expr
                   {
                     if ($1 && ($1->is_matrix () || $1->is_cell ()))
                       {
                         if (parser.validate_array_list ($1))
                           $$ = $1;
                         else
                           {
                             delete $1;
-                            ABORT_PARSE;
+                            YYABORT;
                           }
                       }
                     else
                       $$ = $1;
                   }
                 | assign_expr
-                  { $$ = $1; }
+                  {
+                    if (! $1)
+                      YYABORT;
+
+                    $$ = $1;
+                  }
                 | anon_fcn_handle
                   { $$ = $1; }
                 ;
 
 // ================================================
 // Commands, declarations, and function definitions
 // ================================================
 
@@ -1011,17 +1005,17 @@ select_command  : if_command
 // If statement
 // ============
 
 if_command      : IF stash_comment if_cmd_list END
                   {
                     if (! ($$ = parser.finish_if_command ($1, $3, $4, $2)))
                       {
                         // finish_if_command deleted $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
@@ -1071,17 +1065,17 @@ else_clause     : ELSE stash_comment opt
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.finish_switch_command ($1, $3, $5, $6, $2)))
                       {
                         // finish_switch_command deleted $3 adn $5.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 case_list       : // empty
                   { $$ = new tree_switch_case_list (); }
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
@@ -1129,17 +1123,17 @@ loop_command    : WHILE stash_comment ex
                   {
                     YYUSE ($5);
 
                     $3->mark_braindead_shortcircuit ();
 
                     if (! ($$ = parser.make_while_command ($1, $3, $6, $7, $2)))
                       {
                         // make_while_command deleted $3 and $6.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
                     YYUSE ($1);
                     YYUSE ($3);
 
                     $$ = parser.make_do_until_command ($5, $4, $6, $2);
@@ -1148,53 +1142,53 @@ loop_command    : WHILE stash_comment ex
                   {
                     YYUSE ($4);
                     YYUSE ($7);
 
                     if (! ($$ = parser.make_for_command (FOR, $1, $3, $5, 0,
                                                          $8, $9, $2)))
                       {
                         // make_for_command deleted $3, $5, and $8.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
                     YYUSE ($5);
                     YYUSE ($8);
 
                     if (! ($$ = parser.make_for_command (FOR, $1, $4, $6, 0,
                                                          $9, $10, $2)))
                       {
                         // make_for_command deleted $4, $6, and $9.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | PARFOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     YYUSE ($4);
                     YYUSE ($7);
 
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $3, $5,
                                                          0, $8, $9, $2)))
                       {
                         // make_for_command deleted $3, $5, and $8.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
                     YYUSE ($5);
                     YYUSE ($10);
 
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $4, $6,
                                                          $8, $11, $12, $2)))
                       {
                         // make_for_command deleted $4, $6, $8, and $11.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 // =======
 // Jumping
 // =======
 
@@ -1215,40 +1209,40 @@ except_command  : UNWIND stash_comment o
                   {
                     YYUSE ($3);
                     YYUSE ($5);
                     YYUSE ($7);
 
                     if (! ($$ = parser.make_unwind_command ($1, $4, $8, $9, $2, $6)))
                       {
                         // make_unwind_command deleted $4 and $8.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | TRY stash_comment opt_sep opt_list CATCH stash_comment
                   opt_sep opt_list END
                   {
                     YYUSE ($3);
                     YYUSE ($5);
                     YYUSE ($7);
 
                     if (! ($$ = parser.make_try_command ($1, $4, $7, $8, $9, $2, $6)))
                       {
                         // make_try_command deleted $4 and $8.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
                     YYUSE ($3);
 
                     if (! ($$ = parser.make_try_command ($1, $4, 0, 0, $5, $2, 0)))
                       {
                         // make_try_command deleted $4.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
@@ -1269,17 +1263,20 @@ push_fcn_symtab : // empty
                     if (! lexer.reading_script_file
                         && parser.curr_fcn_depth == 1
                         && ! parser.parsing_subfunctions)
                       parser.primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
 
                     if (lexer.reading_script_file
                         && parser.curr_fcn_depth > 1)
-                      parser.bison_error ("nested functions not implemented in this context");
+                      {
+                        parser.bison_error ("nested functions not implemented in this context");
+                        YYABORT;
+                      }
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
@@ -1308,36 +1305,36 @@ param_list      : param_list_beg param_l
                   {
                     if ($2)
                       lexer.mark_as_variables ($2->variable_names ());
 
                     $$ = $2;
                   }
                 | param_list_beg error
                   {
+                    $$ = 0;
                     parser.bison_error ("invalid parameter list");
-                    $$ = 0;
-                    ABORT_PARSE;
+                    YYABORT;
                   }
                 ;
 
 param_list1     : // empty
                   { $$ = 0; }
                 | param_list2
                   {
                     $1->mark_as_formal_parameters ();
                     if ($1->validate (tree_parameter_list::in))
                       {
                         lexer.mark_as_variables ($1->variable_names ());
                         $$ = $1;
                       }
                     else
                       {
                         delete $1;
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 param_list2     : param_list_elt
                   { $$ = new tree_parameter_list ($1); }
                 | param_list2 ',' param_list_elt
                   {
@@ -1372,32 +1369,32 @@ return_list     : '[' ']'
                     // a single identifier, we still need to validate it
                     // to check for varargin or varargout.
 
                     if (tmp->validate (tree_parameter_list::out))
                       $$ = tmp;
                     else
                       {
                         delete tmp;
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | '[' return_list1 ']'
                   {
                     lexer.looking_at_return_list = false;
 
                     // Check for duplicate parameter names, varargin,
                     // or varargout.
 
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
                       {
                         delete $2;
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 return_list1    : identifier
                   { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
                 | return_list1 ',' identifier
                   {
@@ -1543,18 +1540,17 @@ function_end    : END
                     parser.endfunction_found = true;
 
                     if (parser.end_token_ok ($1, token::function_end))
                       $$ = parser.make_end ("endfunction", false,
                                             $1->line (), $1->column ());
                     else
                       {
                         parser.end_token_error ($1, token::function_end);
-
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
 //                  if (lexer.reading_script_file)
 //                    {
 //                      parser.bison_error ("function body open at end of script");
@@ -1610,29 +1606,29 @@ classdef        : classdef_beg stash_com
                     YYUSE ($6);
                     YYUSE ($8);
 
                     lexer.parsing_classdef = false;
 
                     if (! ($$ = parser.make_classdef ($1, $3, $4, $5, $7, $9, $2)))
                       {
                         // make_classdef deleted $3, $4, $5, and $7.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep END
                   {
                     YYUSE ($6);
 
                     lexer.parsing_classdef = false;
 
                     if (! ($$ = parser.make_classdef ($1, $3, $4, $5, 0, $7, $2)))
                       {
                         // make_classdef deleted $3, $4, and $5.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 opt_attr_list   : // empty
                   { $$ = 0; }
                 | '(' attr_list ')'
                   { $$ = $2; }
@@ -1739,28 +1735,28 @@ properties_block
                   {
                     YYUSE ($4);
                     YYUSE ($6);
 
                     if (! ($$ = parser.make_classdef_properties_block
                            ($1, $3, $5, $7, $2)))
                       {
                         // make_classdef_properties_block delete $3 and $5.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | PROPERTIES stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_properties_block
                            ($1, $3, 0, $5, $2)))
                       {
                         // make_classdef_properties_block delete $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 property_list
                 : class_property
                   { $$ = new tree_classdef_property_list ($1); }
                 | property_list opt_sep class_property
@@ -1787,42 +1783,42 @@ methods_block   : METHODS stash_comment 
                   {
                     YYUSE ($4);
                     YYUSE ($6);
 
                     if (! ($$ = parser.make_classdef_methods_block
                            ($1, $3, $5, $7, $2)))
                       {
                         // make_classdef_methods_block deleted $3 and $5.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | METHODS stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_methods_block
                            ($1, $3, 0, $5, $2)))
                       {
                         // make_classdef_methods_block deleted $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
                 ;
 
 method_decl1    : identifier
                   {
                     if (! ($$ = parser.start_classdef_external_method ($1, 0)))
-                      ABORT_PARSE;
+                      YYABORT;
                   }
                 | identifier param_list
                   {
                     if (! ($$ = parser.start_classdef_external_method ($1, $2)))
-                      ABORT_PARSE;
+                      YYABORT;
                   }
                 ;
 
 method_decl     : stash_comment method_decl1
                   { $$ = parser.finish_classdef_external_method ($2, 0, $1); }
                 | stash_comment return_list '='
                   {
                     YYUSE ($3);
@@ -1870,28 +1866,28 @@ events_block    : EVENTS stash_comment o
                   {
                     YYUSE ($4);
                     YYUSE ($6);
 
                     if (! ($$ = parser.make_classdef_events_block
                            ($1, $3, $5, $7, $2)))
                       {
                         // make_classdef_events_block deleted $3 and $5.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | EVENTS stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_events_block
                            ($1, $3, 0, $5, $2)))
                       {
                         // make_classdef_events_block deleted $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 events_list     : class_event
                   { $$ = new tree_classdef_events_list ($1); }
                 | events_list opt_sep class_event
                   {
@@ -1910,28 +1906,28 @@ enum_block      : ENUMERATION stash_comm
                   {
                     YYUSE ($4);
                     YYUSE ($6);
 
                     if (! ($$ = parser.make_classdef_enum_block
                            ($1, $3, $5, $7, $2)))
                       {
                         // make_classdef_enum_block deleted $3 and $5.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 | ENUMERATION stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_enum_block
                            ($1, $3, 0, $5, $2)))
                       {
                         // make_classdef_enum_block deleted $3.
-                        ABORT_PARSE;
+                        YYABORT;
                       }
                   }
                 ;
 
 enum_list       : class_enum
                   { $$ = new tree_classdef_enum_list ($1); }
                 | enum_list opt_sep class_enum
                   {
@@ -2775,17 +2771,24 @@ octave_base_parser::make_for_command (in
           retval = new tree_simple_for_command (parfor, tmp, expr, maxproc,
                                                 body, lc, tc, l, c);
 
           delete lhs;
         }
       else
         {
           if (parfor)
-            bison_error ("invalid syntax for parfor statement");
+            {
+              delete lhs;
+              delete expr;
+              delete maxproc;
+              delete body;
+
+              bison_error ("invalid syntax for parfor statement");
+            }
           else
             retval = new tree_complex_for_command (lhs, expr, body,
                                                    lc, tc, l, c);
         }
     }
   else
     {
       delete lhs;
@@ -3045,17 +3048,22 @@ octave_base_parser::make_assign_op (int 
 
       retval = new tree_simple_assignment (tmp, rhs, false, l, c, t);
 
       delete lhs;
     }
   else if (t == octave_value::op_asn_eq)
     return new tree_multi_assignment (lhs, rhs, false, l, c);
   else
-    bison_error ("computed multiple assignment not allowed");
+    {
+      delete lhs;
+      delete rhs;
+
+      bison_error ("computed multiple assignment not allowed");
+    }
 
   return retval;
 }
 
 // Define a script.
 
 void
 octave_base_parser::make_script (tree_statement_list *cmds,
@@ -3597,40 +3605,40 @@ tree_index_expression *
 octave_base_parser::make_index_expression (tree_expression *expr,
                                            tree_argument_list *args,
                                            char type)
 {
   tree_index_expression *retval = 0;
 
   if (args && args->has_magic_tilde ())
     {
-      bison_error ("invalid use of empty argument (~) in index expression");
-
       delete expr;
       delete args;
 
-      return retval;
-    }
-
-  int l = expr->line ();
-  int c = expr->column ();
-
-  if (! expr->is_postfix_indexed ())
-    expr->set_postfix_index (type);
-
-  if (expr->is_index_expression ())
-    {
-      tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
-
-      tmp->append (args, type);
-
-      retval = tmp;
+      bison_error ("invalid use of empty argument (~) in index expression");
     }
   else
-    retval = new tree_index_expression (expr, args, l, c, type);
+    {
+      int l = expr->line ();
+      int c = expr->column ();
+
+      if (! expr->is_postfix_indexed ())
+        expr->set_postfix_index (type);
+
+      if (expr->is_index_expression ())
+        {
+          tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
+
+          tmp->append (args, type);
+
+          retval = tmp;
+        }
+      else
+        retval = new tree_index_expression (expr, args, l, c, type);
+    }
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
 tree_index_expression *
 octave_base_parser::make_indirect_ref (tree_expression *expr,
@@ -3737,42 +3745,44 @@ octave_base_parser::validate_array_list 
 
   for (tree_array_list::iterator i = al->begin (); i != al->end (); i++)
     {
       tree_argument_list *row = *i;
 
       if (row && row->has_magic_tilde ())
         {
           retval = false;
+
           if (e->is_matrix ())
             bison_error ("invalid use of tilde (~) in matrix expression");
           else
             bison_error ("invalid use of tilde (~) in cell expression");
+
           break;
         }
     }
 
   return retval;
 }
 
 tree_argument_list *
 octave_base_parser::validate_matrix_for_assignment (tree_expression *e)
 {
   tree_argument_list *retval = 0;
 
   if (e->is_constant ())
     {
       octave_value ov = e->rvalue1 ();
 
+      delete e;
+
       if (ov.is_empty ())
         bison_error ("invalid empty left hand side of assignment");
       else
         bison_error ("invalid constant left hand side of assignment");
-
-      delete e;
     }
   else
     {
       bool is_simple_assign = true;
 
       tree_argument_list *tmp = 0;
 
       if (e->is_matrix ())
@@ -3792,18 +3802,19 @@ octave_base_parser::validate_matrix_for_
 
       if (tmp && tmp->is_valid_lvalue_list ())
         {
           lexer.mark_as_variables (tmp->variable_names ());
           retval = tmp;
         }
       else
         {
+          delete tmp;
+
           bison_error ("invalid left hand side of assignment");
-          delete tmp;
         }
 
       if (retval && is_simple_assign)
         retval->mark_as_simple_assign_lhs ();
     }
 
   return retval;
 }
@@ -3992,25 +4003,53 @@ octave_base_parser::bison_error (const s
       for (int i = 0; i < err_col + 3; i++)
         output_buf << " ";
 
       output_buf << "^";
     }
 
   output_buf << "\n";
 
-  std::string msg = output_buf.str ();
-
-  parse_error ("%s", msg.c_str ());
+  parse_error_msg = output_buf.str ();
 }
 
 int
 octave_parser::run (void)
 {
-  return octave_parse (*this);
+  int status = -1;
+
+  yypstate *pstate = static_cast<yypstate *> (parser_state);
+
+  try
+    {
+      status = octave_pull_parse (pstate, *this);
+    }
+  catch (octave_execution_exception& e)
+    {
+      std::string file = lexer.fcn_file_full_name;
+
+      if (file.empty ())
+        error (e, "parse error");
+      else
+        error (e, "parse error in %s", file.c_str ());
+    }
+  catch (...)
+    {
+      std::string file = lexer.fcn_file_full_name;
+
+      if (file.empty ())
+        error ("unexpected exception while parsing input");
+      else
+        error ("unexpected exception while parsing %s", file.c_str ());
+    }
+
+  if (status != 0)
+    parse_error ("%s", parse_error_msg.c_str ());
+
+  return status;
 }
 
 // Parse input from INPUT.  Pass TRUE for EOF if the end of INPUT should
 // finish the parse.
 
 int
 octave_push_parser::run (const std::string& input, bool eof)
 {
@@ -4030,20 +4069,44 @@ octave_push_parser::run (const std::stri
             {
               status = -1;
               break;
             }
         }
 
       yypstate *pstate = static_cast<yypstate *> (parser_state);
 
-      status = octave_push_parse (pstate, token, &lval, *this);
+      try
+        {
+          status = octave_push_parse (pstate, token, &lval, *this);
+        }
+      catch (octave_execution_exception& e)
+        {
+          std::string file = lexer.fcn_file_full_name;
+
+          if (file.empty ())
+            error (e, "parse error");
+          else
+            error (e, "parse error in %s", file.c_str ());
+        }
+      catch (...)
+        {
+          std::string file = lexer.fcn_file_full_name;
+
+          if (file.empty ())
+            error ("unexpected exception while parsing input");
+          else
+            error ("unexpected exception while parsing %s", file.c_str ());
+        }
     }
   while (status == YYPUSH_MORE);
 
+  if (status != 0)
+    parse_error ("%s", parse_error_msg.c_str ());
+
   return status;
 }
 
 static void
 safe_fclose (FILE *f)
 {
   if (f)
     fclose (static_cast<FILE *> (f));
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -386,16 +386,20 @@ public:
   // Append a statement to an existing statement list.
   tree_statement_list *
   append_statement_list (tree_statement_list *list, char sep,
                          tree_statement *stmt, bool warn_missing_semi);
 
   // Generic error messages.
   void bison_error (const std::string& s, int l = -1, int c = -1);
 
+  // Contains error message if Bison-generated parser returns non-zero
+  // status.
+  std::string parse_error_msg;
+
   // Have we found an explicit end to a function?
   bool endfunction_found;
 
   // TRUE means we are in the process of autoloading a function.
   bool autoloading;
 
   // TRUE means the current function file was found in a relative path
   // element.
