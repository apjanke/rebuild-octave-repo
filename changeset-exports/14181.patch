# HG changeset patch
# User Jordi Gutiérrez Hermoso <jordigh@octave.org>
# Date 1326140361 18000
#      Mon Jan 09 15:19:21 2012 -0500
# Branch stable
# Node ID 6b28e8a8c7772e21b9381164ff769d227fb552e1
# Parent  4942b3011541564531872886ca841e89ba0df6fc
# Parent  a7a020cd6106bab66cf52eaaebb06e988b2469bc
Merge in Carn̈́ë's changes

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-bb052d4a7416accaad0747e84bd2a0accbfcf923 gnulib
+3559997a03e82d650aaa708447362fe20a6eaf15 gnulib
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -50,8 +50,9 @@ 6c69a7c39039bccd5a2fe481fcc7f896c82b160b
 3cbc0d77db48aec32bcb202d09a036d2cb9cc3b9 ss-3-3-53
 bd2643f0ce57d070963bedd48857405f6924aa85 ss-3-3-54
 695141f1c05cf1b240592bdd18e7a1503bb2a539 ss-3-3-55
 901d466ee55ac902a875ec0ade6f1eccef0841dc release-3-4-1
 3666e8e6f96e6899b8306d6ea9614aadf0500d67 release-3-4-2
 b0e70a71647b671ebcfa7a79af1ae6d3c0f52065 release-3-4-3
 3781981be535e80d44c85373b8fdaa60ca5cd097 ss-3-5-90
 ff5588774680d4f54567311fc109c8e351950f1c ss-3-5-91
+a737b3fb9c4d89d3694da6b4e623aeee64b212e1 ss-3-5-92
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,13 +1,17 @@
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
  ** The PCRE library is now required to build Octave.
 
+ ** The ARPACK library is no longer distributed with Octave.
+    If you need the eigs() or svds() functions you must provide an external
+    ARPACK through a package manager or by compiling it yourself.
+
  ** Many of Octave's binary operators (.*, .^, +, -, ...) now perform
     automatic broadcasting for array operations that allows you to use
     operator notation instead of calling bsxfun or expanding arrays (and
     unnecessarily wasting memory) with repmat or similar idioms.  For
     example, to scale the columns of a matrix by the elements of a row
     vector, you may now write
 
       rv .* M
@@ -37,23 +41,23 @@ Summary of important user-visible change
       rem
       xor
 
     additionally, since the A op= B assginment operators are equivalent
     to A = A op B, the following operators are also affected:
 
       +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
 
-    See the new "Broadcasting Operations" chapter in the manual for more
-    details.
+    See the "Broadcasting" section in the new "Vectorization and Faster
+    Code Execution" chapter of the manual for more details.
 
  ** Octave now features a profiler, thanks to the work of Daniel Kraft
     under the Google Summer of Code mentorship program.  The manual has
     been updated to reflect this addition.  The new user-visible
-    functions are profexplore, profile, and profshow.
+    functions are profile, profshow, and profexplore.
 
  ** Overhaul of statistical distribution functions
 
     Functions now return "single" outputs for inputs of class "single".
 
     75% reduction in memory usage through use of logical indexing.
 
     Random sample functions now use the same syntax as rand() and accept
@@ -162,20 +166,22 @@ Summary of important user-visible change
     functions nor the waitfor function.
 
  ** New keyword parfor (parallel for loop) is now recognized as a valid
     keyword.  Implementation, however, is still mapped to an ordinary
     for loop.
 
  ** Other new functions added in 3.6.0:
 
-      is_dq_string    nthargout    usejava     
-      is_sq_string    python       waitbar
-      narginchk       recycle      zscore            
-    
+      bicg                       nthargout                   usejava
+      is_dq_string               narginchk                   waitbar
+      is_sq_string               python                      zscore
+      is_function_handle         register_graphics_toolkit 
+      loaded_graphics_toolkits   recycle                   
+
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.2 and have been
     removed from Octave 3.6.
                                            
       create_set          spcholinv    splu   
       dmult               spcumprod    spmax
       iscommand           spcumsum     spmin
diff --git a/README b/README
--- a/README
+++ b/README
@@ -1,11 +1,11 @@
 GNU Octave -- a high-level language for numerical computations.
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 Overview
 --------
 
 GNU Octave is a high-level language, primarily intended for numerical
 computations.  It provides a convenient command line interface for
 solving linear and nonlinear problems numerically.
 
diff --git a/build-aux/bootstrap b/build-aux/bootstrap
--- a/build-aux/bootstrap
+++ b/build-aux/bootstrap
@@ -1,15 +1,15 @@
 #! /bin/sh
 # Print a version string.
 scriptversion=2011-08-11.17; # UTC
 
 # Bootstrap this package from checked-out sources.
 
-# Copyright (C) 2003-2011 Free Software Foundation, Inc.
+# Copyright (C) 2003-2012 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap.conf
@@ -1,11 +1,11 @@
 # Bootstrap configuration.
 
-# Copyright (C) 2006-2007, 2009-2011 Free Software Foundation, Inc.
+# Copyright (C) 2006-2007, 2009-2012 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -31,30 +31,33 @@ gnulib_modules="
   fflush
   fseek
   ftell
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
+  isatty
   link
   lstat
   mkdir
   mkfifo
   mkostemp
   mkstemp
   mktime
   nanosleep
   nproc
   opendir
   pathmax
   progname
+  readdir
   readlink
   rename
+  rewinddir
   rmdir
   round
   roundf
   sigaction
   signal
   sigprocmask
   sleep
   sleep
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -238,16 +238,20 @@ OPENGL_LIBS = @OPENGL_LIBS@
 
 QRUPDATE_CPPFLAGS = @QRUPDATE_CPPFLAGS@
 QRUPDATE_LDFLAGS = @QRUPDATE_LDFLAGS@
 QRUPDATE_LIBS = @QRUPDATE_LIBS@
 
 READLINE_LIBS = @READLINE_LIBS@
 TERM_LIBS = @TERM_LIBS@
 
+ARPACK_CPPFLAGS = @ARPACK_CPPFLAGS@
+ARPACK_LDFLAGS = @ARPACK_LDFLAGS@
+ARPACK_LIBS = @ARPACK_LIBS@
+
 DL_LIBS = @DL_LIBS@
 LIBS = @LIBS@
 
 ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS)
 
 SPARSE_XCPPFLAGS = \
   $(CHOLMOD_CPPFLAGS) $(UMFPACK_CPPFLAGS) \
   $(AMD_CPPFLAGS) $(CAMD_CPPFLAGS) $(COLAMD_CPPFLAGS) \
@@ -447,16 +451,19 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_ALL_CXXFLAGS%|\"${ALL_CXXFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_ALL_FFLAGS%|\"${ALL_FFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_ALL_LDFLAGS%|\"${ALL_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_AMD_CPPFLAGS%|\"${AMD_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_AMD_LDFLAGS%|\"${AMD_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_AMD_LIBS%|\"${AMD_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_AR%|\"${AR}\"|" \
   -e "s|%OCTAVE_CONF_ARFLAGS%|\"${ARFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ARPACK_CPPFLAGS%|\"${ARPACK_CPPFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ARPACK_LDFLAGS%|\"${ARPACK_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ARPACK_LIBS%|\"${ARPACK_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_BLAS_LIBS%|\"${BLAS_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_CAMD_CPPFLAGS%|\"${CAMD_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_CAMD_LDFLAGS%|\"${CAMD_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_CAMD_LIBS%|\"${CAMD_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_CANONICAL_HOST_TYPE%|\"${canonical_host_type}\"|" \
   -e "s|%OCTAVE_CONF_CARBON_LIBS%|\"${CARBON_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_CC%|\"${CC}\"|" \
   -e "s|%OCTAVE_CONF_CC_VERSION%|\"${CC_VERSION}\"|" \
diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -1,11 +1,11 @@
 #! /usr/bin/perl -w
 #
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1,13 +1,13 @@
 dnl configure.in
 dnl
 dnl Process this file with autoconf to produce a configure script.
 dnl
-dnl Copyright (C) 1993-2011 John W. Eaton
+dnl Copyright (C) 1993-2012 John W. Eaton
 ### 
 ### This file is part of Octave.
 ### 
 ### Octave is free software; you can redistribute it and/or modify it
 ### under the terms of the GNU General Public License as published by the
 ### Free Software Foundation; either version 3 of the License, or (at
 ### your option) any later version.
 ### 
@@ -22,24 +22,24 @@ dnl Copyright (C) 1993-2011 John W. Eato
 
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
-AC_INIT([GNU Octave], [3.5.91+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.5.92+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="46"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2011-12-23"
-OCTAVE_COPYRIGHT="Copyright (C) 2011 John W. Eaton and others."
+OCTAVE_RELEASE_DATE="2012-01-06"
+OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 AC_REVISION($Revision: 1.603 $)
 AC_PREREQ([2.62])
@@ -1168,16 +1168,29 @@ fi
 
 if test -n "$UMFPACK_LIBS"; then
   save_LIBS="$LIBS";
   LIBS="$UMFPACK_LIBS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
   OCTAVE_UMFPACK_SEPERATE_SPLIT
   LIBS="$save_LIBS"
 fi
 
+save_LIBS="$LIBS"
+LIBS="$LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
+OCTAVE_CHECK_LIBRARY(arpack, ARPACK,
+  [ARPACK not found.  The eigs function will be disabled.],
+  [],
+  [dseupd],
+  [Fortran 77], [don't use the ARPACK library, disable eigs function],
+  [warn_arpack=
+   OCTAVE_CHECK_ARPACK_OK([
+     AC_DEFINE(HAVE_ARPACK, 1, [Define if ARPACK is available.])], [
+     warn_arpack="ARPACK library found, but seems not to work properly -- disabling eigs function"])])
+LIBS="$save_LIBS"
+
 ### Enable dynamic linking.  --enable-shared implies this, so
 ### --enable-dl is only need if you are only building static libraries
 ### and want to try dynamic linking too (works on some systems, for
 ### example, OS X and Windows).
 
 AC_ARG_ENABLE([dl],
   [AS_HELP_STRING([--enable-dl],
     [allow loading of dynamically linked modules (not all systems)])], [
@@ -1608,17 +1621,17 @@ else
   AC_MSG_WARN([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
 
 ### Checks for functions and variables.
 
 AC_CHECK_FUNCS(basename canonicalize_file_name \
   chmod dup2 endgrent endpwent execvp expm1 expm1f fork \
   getegid geteuid getgid getgrent getgrgid getgrnam getpgrp getpid \
-  getppid getpwent getpwuid getuid getwd _kbhit kill \
+  getppid getpwent getpwuid getuid getwd _kbhit \
   lgamma lgammaf lgamma_r lgammaf_r localtime_r log1p log1pf \
   mkstemp pipe putenv \
   realpath resolvepath rindex roundl select setgrent setlocale \
   setpwent setvbuf siglongjmp \
   strsignal tempnam tgammaf umask \
   uname utime waitpid \
   _chmod x_utime _utime32)
 
@@ -2145,16 +2158,19 @@ Octave is now configured for $canonical_
   Fortran compiler:            $F77 $FFLAGS
   Fortran libraries:           $FLIBS
   Lex libraries:               $LEXLIB
   LIBS:                        $LIBS
 
   AMD CPPFLAGS:                $AMD_CPPFLAGS
   AMD LDFLAGS:                 $AMD_LDFLAGS
   AMD libraries:               $AMD_LIBS
+  ARPACK CPPFLAGS:             $ARPACK_CPPFLAGS
+  ARPACK LDFLAGS:              $ARPACK_LDFLAGS
+  ARPACK libraries:            $ARPACK_LIBS
   BLAS libraries:              $BLAS_LIBS
   CAMD CPPFLAGS:               $CAMD_CPPFLAGS
   CAMD LDFLAGS:                $CAMD_LDFLAGS
   CAMD libraries:              $CAMD_LIBS
   CARBON libraries:            $CARBON_LIBS
   CCOLAMD CPPFLAGS:            $CCOLAMD_CPPFLAGS
   CCOLAMD LDFLAGS:             $CCOLAMD_LDFLAGS
   CCOLAMD libraries:           $CCOLAMD_LIBS
@@ -2390,17 +2406,17 @@ if $USE_64_BIT_IDX_T; then
   AC_MSG_WARN([Are you sure that is what you want to do?])
   AC_MSG_WARN([])
   AC_MSG_WARN([Your Fortran compiler must have an option to generate])
   AC_MSG_WARN([code with 8 byte signed INTEGER values.  This option])
   AC_MSG_WARN([should be specified in the F77_INTEGER_8_FLAG variable])
   AC_MSG_WARN([Make.  This should work automatically for gfortran.  If])
   AC_MSG_WARN([you use another compiler, you will need to set this])
   AC_MSG_WARN([variable on the configure command line.  You must also])
-  AC_MSG_WARN([compile the BLAS, LAPACK, QRUPDATE, and SuiteSparse])
+  AC_MSG_WARN([compile the ARPACK, BLAS, LAPACK, QRUPDATE, and SuiteSparse])
   AC_MSG_WARN([libraries to use 8 byte signed integers for array indexing.])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
 
 if $USE_OPENMP; then
   AC_MSG_WARN([])
   AC_MSG_WARN([You used the EXPERIMENTAL --enable-openmp option.])
diff --git a/doc/Makefile.am b/doc/Makefile.am
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/interpreter directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/faq/Makefile.am b/doc/faq/Makefile.am
--- a/doc/faq/Makefile.am
+++ b/doc/faq/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/faq directory
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
--- a/doc/faq/OctaveFAQ.texi
+++ b/doc/faq/OctaveFAQ.texi
@@ -1,9 +1,9 @@
-% Copyright (C) 1997-2011 John W. Eaton
+% Copyright (C) 1997-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
 %
diff --git a/doc/icons/Makefile.am b/doc/icons/Makefile.am
--- a/doc/icons/Makefile.am
+++ b/doc/icons/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/icons directory
 #
-# Copyright (C) 2011 John W. Eaton
+# Copyright (C) 2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/interpreter directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -143,17 +143,18 @@ MUNGED_TEXI_SRC = \
   signal.texi \
   sparse.texi \
   stats.texi \
   stmt.texi \
   strings.texi \
   system.texi \
   testfun.texi \
   tips.texi \
-  var.texi
+  var.texi \
+  vectorize.texi
 
 TXI_SRC = $(MUNGED_TEXI_SRC:.texi=.txi)
 
 info_TEXINFOS = octave.texi
 
 octave_TEXINFOS = \
   contributors.texi \
   $(MUNGED_TEXI_SRC)
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -184,20 +184,16 @@ cos (pi/2)
 @DOCSTRING(prod)
 
 @DOCSTRING(cumsum)
 
 @DOCSTRING(cumprod)
 
 @DOCSTRING(sumsq)
 
-@DOCSTRING(accumarray)
-
-@DOCSTRING(accumdim)
-
 @node Utility Functions
 @section Utility Functions
 
 @DOCSTRING(ceil)
 
 @DOCSTRING(fix)
 
 @DOCSTRING(floor)
diff --git a/doc/interpreter/audio.txi b/doc/interpreter/audio.txi
--- a/doc/interpreter/audio.txi
+++ b/doc/interpreter/audio.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 Kurt Hornik
+@c Copyright (C) 1996-2012 Kurt Hornik
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/bugs.txi b/doc/interpreter/bugs.txi
--- a/doc/interpreter/bugs.txi
+++ b/doc/interpreter/bugs.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -502,19 +502,17 @@ Other functions that can manipulate the 
 @DOCSTRING(substruct)
 
 @node Processing Data in Structures
 @subsection Processing Data in Structures
 
 The simplest way to process data in a structure is within a @code{for}
 loop (@pxref{Looping Over Structure Elements}).  A similar effect can be
 achieved with the @code{structfun} function, where a user defined
-function is applied to each field of the structure.
-
-@DOCSTRING(structfun)
+function is applied to each field of the structure.  @xref{doc-structfun}.
 
 Alternatively, to process the data in a structure, the structure might
 be converted to another type of container before being treated.
 
 @DOCSTRING(struct2cell)
 
 @node Cell Arrays
 @section Cell Arrays
@@ -882,19 +880,17 @@ cell array of strings.
 @node Processing Data in Cell Arrays
 @subsection Processing Data in Cell Arrays
 
 Data that is stored in a cell array can be processed in several ways
 depending on the actual data.  The simplest way to process that data
 is to iterate through it using one or more @code{for} loops.  The same
 idea can be implemented more easily through the use of the @code{cellfun}
 function that calls a user-specified function on all elements of a cell
-array.
-
-@DOCSTRING(cellfun)
+array.  @xref{doc-cellfun}.
 
 An alternative is to convert the data to a different container, such as
 a matrix or a data structure.  Depending on the data this is possible
 using the @code{cell2mat} and @code{cell2struct} functions.
 
 @DOCSTRING(cell2mat)
 
 @DOCSTRING(cell2struct)
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -1,9 +1,10 @@
-@c Copyright (C) 2008-2011 Jaroslav Hajek
+@c Copyright (C) 2012 John W. Eaton
+@c Copyright (C) 2008-2012 Jaroslav Hajek
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c
@@ -20,32 +21,114 @@
 @appendix Contributing Guidelines
 @cindex coding standards
 @cindex Octave development
 
 This chapter is dedicated to those who wish to contribute code to Octave.
 
 @menu
 * How to Contribute::
+* Building the Development Sources::
+* Basics of Generating a Changeset::
 * General Guidelines::
 * Octave Sources (m-files)::
 * C++ Sources::
 * Other Sources::
 @end menu
 
 @node How to Contribute
 @section How to Contribute
 The mailing list for Octave development discussion and sending
 contributions is @email{maintainers@@octave.org}.  This concerns the
 development of Octave core, i.e., code that goes to Octave directly.
 You may consider developing and publishing a package instead; a great
 place for this is the allied Octave-Forge project
 (@url{http://octave.sf.net}).  Note that the Octave project is
 inherently more conservative and follows narrower rules.
 
+@node Building the Development Sources
+@section Building the Development Sources
+
+In addition to all the tools (both optional and required) that are
+listed in @ref{Build Dependencies} you will need:
+
+@table @asis
+@item Mercurial
+Distributed version control system (@url{http://mercurial.selenic.com}).
+Octave's sources are stored in a Mercurial archive.
+
+@item Git
+Distributed version control system (@url{http://git-scm.com}).  The
+gnulib sources that Octave depends on are stored in a Git archive.
+@end table
+
+Once you have the required tools installed, you can build Octave by
+doing
+
+@itemize @bullet
+@item
+Check out a copy of the Octave sources:
+@example
+hg clone http://hg.savannah.gnu.org/hgweb/octave
+@end example
+
+@item
+Change to the top-level directory of the newly checked out sources:
+@example
+cd octave
+@end example
+
+@item
+Generate the necessary configuration files:
+@example
+./autogen.sh
+@end example
+
+@item
+Create a build directory and change to it:
+@example
+mkdir build
+cd build
+@end example
+By using a separate build directory, you will keep the source directory
+clean and it will be easy to completely remove all files generated by
+the build.  You can also have parallel build trees for different
+purposes that all share the same sources.  For example, one build tree
+may be configured to disable compiler optimization in order to allow for
+easier debugging while another may be configured to test building with
+other specialized compiler flags.
+
+@item
+Run Octave's configure script from the build directory:
+@example
+../configure
+@end example
+
+@item
+Run make in the build directory:
+@example
+make
+@end example
+@end itemize
+
+Once the build is finished, you will see a message like the following:
+
+@example
+@group
+Octave successfully built.  Now choose from the following:
+
+   ./run-octave    - to run in place to test before installing
+   make check      - to run the tests
+   make install    - to install (PREFIX=...)
+@end group
+@end example
+
+@node Basics of Generating a Changeset
+@section Basics of Generating a Changeset
+
 The preferable form of contribution is creating a Mercurial changeset
 and sending it via e-mail to the octave-maintainers mailing list.
 Mercurial is the source code management system currently used to develop
 Octave.  Other forms of contributions (e.g., simple diff patches) are
 also acceptable, but they slow down the review process.  If you want to
 make more contributions, you should really get familiar with Mercurial.
 A good place to start is
 @url{http://www.selenic.com/mercurial/wiki/index.cgi/Tutorial}.  There
@@ -110,17 +193,17 @@ hg export -o ../nasty2.diff tip
 
 All Octave's sources are distributed under the General Public License
 (GPL).  Currently, Octave uses GPL version 3.  For details about this
 license, see @url{http://www.gnu.org/licenses/gpl.html}.  Therefore,
 whenever you create a new source file, it should have the following
 comment header (use appropriate year, name and comment marks):
 
 @example
-## Copyright (C) 1996-2011 John W. Eaton <jwe@@octave.org>
+## Copyright (C) 1996-2012 John W. Eaton <jwe@@octave.org>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or
 ## modify it under the terms of the GNU General Public
 ## License as published by the Free Software Foundation;
 ## either version 3 of the License, or (at your option) any
 ## later version.
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -1,54 +1,63 @@
 Ben Abbott
 Andy Adler
 Giles Anderson
 Joel Andersson
 Muthiah Annamalai
+Marco Atzeri
 Shai Ayal
 Roger Banks
 Ben Barrowes
 Alexander Barth
 David Bateman
 Heinz Bauschke
 Roman Belov
 Karl Berry
 David Billinghurst
 Don Bindner
 Jakub Bogusz
 Moritz Borgmann
+Paul Boven
 Richard Bovey
+John Bradshaw
 Marcus Brinkmann
 Remy Bruno
+Ansgar Burchard
 Marco Caliari
 Daniel Calvelo
 John C. Campbell
+Juan Pablo Carbajal
 Jean-Francois Cardoso
 Joao Cardoso
 Larrie Carr
 David Castelow
 Vincent Cautaerts
 Clinton Chee
 Albert Chin-A-Young
 Carsten Clark
 J. D. Cole
 Martin Costabel
 Michael Creel
 Jeff Cunningham
 Martin Dalecki
 Jorge Barros de Abreu
 Carlo de Falco
+Jacob Dawid
 Thomas D. Dean
 Philippe Defert
 Bill Denney
+Fabian Deutsch
 Christos Dimitrakakis
 David M. Doolin
+Carnë Draug
 Pascal A. Dupuis
 John W. Eaton
 Dirk Eddelbuettel
+Pieter Eendebak
 Paul Eggert
 Stephen Eglen
 Peter Ekberg
 Rolf Fabian
 Gunnar Farnebäck
 Stephen Fegan
 Ramon Garcia Fernandez
 Torsten Finke
@@ -66,16 +75,17 @@ Glenn Golden
 Tomislav Goles
 Keith Goodman
 Brian Gough
 Steffen Groot
 Etienne Grossmann
 David Grundberg
 Peter Gustafson
 Kai Habel
+Patrick Häcker
 William P. Y. Hadisoeseno
 Jaroslav Hajek
 Benjamin Hall
 Kim Hansen
 Søren Hauberg
 Dave Hawthorne
 Daniel Heiserer
 Martin Helm
@@ -93,55 +103,61 @@ Christopher Hulbert
 Cyril Humbert
 Teemu Ikonen
 Alan W. Irwin
 Geoff Jacobsen
 Mats Jansson
 Cai Jianming
 Steven G. Johnson
 Heikki Junes
+Matthias Jüschke
 Atsushi Kajita
 Jarkko Kaleva
 Mohamed Kamoun
 Lute Kamstra
 Fotios Kasolis
 Thomas Kasper
 Joel Keay
 Mumit Khan
 Paul Kienzle
 Aaron A. King
 Arno J. Klaassen
+Alexander Klein
 Geoffrey Knauth
 Heine Kolltveit
 Ken Kouno
 Kacper Kowalik
 Daniel Kraft
+Aravindh Krishnamoorthy
 Oyvind Kristiansen
 Piotr Krzyzanowski
 Volker Kuhlmann
 Tetsuro Kurita
 Miroslaw Kwasniak
 Rafael Laboissiere
 Kai Labusch
 Claude Lacoursiere
 Walter Landry
 Bill Lash
 Dirk Laurie
 Maurice LeBrun
 Friedrich Leisch
+Jyh-miin Lin
 Timo Lindfors
 Benjamin Lindner
 Ross Lippert
 David Livings
+Sebastien Loisel
 Erik de Castro Lopo
 Massimo Lorenzin
 Emil Lucretiu
 Hoxide Ma
 James Macnicol
 Jens-Uwe Mager
+Rob Mahurin
 Ricardo Marranita
 Orestes Mas
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
@@ -170,89 +186,103 @@ Luis F. Ortiz
 Scott Pakin
 Gabriele Pannocchia
 Sylvain Pelissier
 Per Persson
 Primozz Peterlin
 Jim Peterson
 Danilo Piazzalunga
 Nicholas Piper
+Elias Pipping
 Robert Platt
 Hans Ekkehard Plesser
 Tom Poage
 Orion Poplawski
 Ondrej Popp
 Jef Poskanzer
-Francesco Potorti
+Francesco Potortì
 Konstantinos Poulios
+Jarno Rajahalme
 James B. Rawlings
 Eric S. Raymond
 Balint Reczey
+Joshua Redstone
+Lukas Reichlin
 Michael Reifenberger
+Anthony Richardson
 Jason Riedy
+E. Joshua Rigler
 Petter Risholm
 Matthew W. Roberts
 Andrew Ross
 Mark van Rossum
+Joe Rothweiler
 Kevin Ruland
 Kristian Rumberg
 Ryan Rusaw
 Olli Saarela
 Toni Saarela
 Juhani Saastamoinen
 Radek Salac
 Ben Sapp
 Aleksej Saushev
-Alois Schloegl
+Alois Schlögl
 Michel D. Schmid
 Julian Schnidder
 Nicol N. Schraudolph
 Sebastian Schubert
 Ludwig Schwardt
 Thomas L. Scofield
 Daniel J. Sebald
 Dmitri A. Sergatskov
 Vanya Sergeev
 Baylis Shanks
 Andriy Shinkarchuck
+Robert T. Short
 Joseph P. Skudlarek
 John Smith
 Julius Smith
 Shan G. Smith
+Peter L. Sondergaard
 Joerg Specht
 Quentin H. Spencer
 Christoph Spiel
 Richard Stallman
 Russell Standish
+Brett Stewart
 Doug Stewart
 Jonathan Stickel
 Judd Storrs
 Thomas Stuart
 Ivan Sutoris
 John Swensen
 Daisuke Takago
 Ariel Tankus
+Matthew Tenny
 Georg Thimm
 Duncan Temple Lang
 Kris Thielemans
 Olaf Till
 Christophe Tournery
 Thomas Treichl
+Karsten Trulsen
 Frederick Umminger
 Utkarsh Upadhyay
 Stefan van der Walt
-David Wells
 Peter Van Wieren
 James R. Van Zandt
 Gregory Vanuxem
 Ivana Varekova
 Thomas Walter
+Andreas Weber
 Olaf Weber
 Thomas Weber
 Rik Wehbring
 Bob Weigel
 Andreas Weingessel
+Martin Weiser
 Michael Weitzel
+David Wells
 Fook Fah Yap
 Sean Young
 Michael Zeising
 Federico Zenith
 Alex Zvoleff
diff --git a/doc/interpreter/cp-idx.txi b/doc/interpreter/cp-idx.txi
--- a/doc/interpreter/cp-idx.txi
+++ b/doc/interpreter/cp-idx.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/data.txi b/doc/interpreter/data.txi
--- a/doc/interpreter/data.txi
+++ b/doc/interpreter/data.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2009-2011 Jaroslav Hajek
+@c Copyright (C) 2009-2012 Jaroslav Hajek
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -33,16 +33,17 @@ AutoCAD
 Autoconf
 autocorrelations
 autocovariances
 autoload
 Autoload
 autoloaded
 autoloading
 Autoloading
+Automake
 autoregression
 autoregressions
 autoscaled
 AutoScaling
 AWK
 awt
 backend
 Backends
@@ -77,17 +78,19 @@ boolMatrix
 boxerrorbars
 boxoff
 boxon
 boxxyerrorbars
 bracketx
 brackety
 breakpoint
 Brenan
+broadcastable
 Brockwell
+BSX
 builtin
 builtins
 ButtonDownFcn
 BV
 bz
 BZ
 bzip
 CallbackObject
@@ -157,16 +160,20 @@ courseware
 cov
 CPLEX
 CreateFcn
 CRLF
 csymamd
 ctranspose
 CTRL
 CTS
+cummax
+cummin
+cumprod
+cumsum
 cURL
 Cuthill
 cxsparse
 Cygwin
 DAE
 DAEs
 daspk
 dasrt
@@ -221,16 +228,17 @@ dx
 dy
 EastOutside
 EIDORS
 eigenpairs
 eigenvector
 eigenvectors
 eigs
 Ekerdt
+elementwise
 Elfers
 elseif
 emacs
 emptyvalue
 endfunction
 endian
 Endian
 endif
@@ -294,16 +302,17 @@ fontname
 forall
 foregroundcolor
 formfeed
 Fortran
 fpdf
 fprintf
 FreeBSD
 freespacing
+FreeType
 freetype
 frnd
 frob
 Frobenius
 Fs
 FSF
 FunValCheck
 gamcdf
@@ -328,25 +337,27 @@ gesvd
 gfortan
 Ghostscript
 gif
 GIF
 glibc
 globbing
 glpk
 GLS
+gnulib
 gnuplot
 Gnuplot
 gnuplot's
 Golub
 Gonnet
 goto
 Goto
 gotos
 GPL
+GPLK
 gplot
 grabdemo
 GradObj
 GraphicsMagick
 Graymap
 grayscale
 Graz
 griddata
@@ -392,16 +403,17 @@ Huhdanpaa
 hygecdf
 hygeinv
 hygepdf
 hygernd
 Hyndman
 Hypergeometric
 hypergeometric
 IEEE
+ifelse
 iff
 ifft
 ifftn
 ignorecase
 IIP
 ij
 Im
 imag
@@ -473,16 +485,17 @@ leq
 Levinson
 LF
 lfloor
 li
 libcruft
 libcurl
 liblapack
 liboctave
+Libtool
 licensors
 lineanchors
 linefeeds
 linesearch
 linespec
 linespoints
 linkprop
 literalspacing
@@ -539,16 +552,17 @@ meshgrid
 meshgridded
 metafile
 Metafile
 metafiles
 Metafont
 mex
 Michelsen
 Microsystems
+MinGW
 minima
 Minimizers
 Minitab
 minval
 MIP
 miscompiled
 Misra
 mkoctfile
@@ -560,16 +574,17 @@ mmmm
 mmmyy
 mmmyyyy
 modelled
 Moler
 Montanet
 mpoles
 mpower
 mrdivide
+MSYS
 mtimes
 Multi
 multi
 multibyte
 multiline
 multipledelimsasone
 MultiSelect
 mxArray
@@ -596,31 +611,33 @@ Ng
 ni
 Nishimura
 NLP
 nnls
 nnz
 nocompute
 nolabel
 noncommercially
+nonconformant
 nonsmooth
 nonzeros
 noperm
 normcdf
 normest
 norminv
 normpdf
 normrnd
 NorthOutside
 noscal
 noshare
 notin
 nthargout
 NTSC
 nul
+Numpy
 Nx
 nzmax
 oct
 octaverc
 ODEPACK
 OLS
 onCleanup
 online
@@ -731,16 +748,18 @@ readline
 recursing
 reentrant
 regex
 regressor
 reimported
 Reindent
 relicensing
 ren
+renderer
+repelems
 repmat
 resampled
 resampling
 Resize
 resize
 resized
 resnorm
 resparsify
@@ -766,26 +785,28 @@ Sandia
 SAS
 sB
 Schafer
 schar
 Schur
 SCO
 screenful
 se
+sed
 seealso
 semidefinite
 Sep
 Shampine
 shiftdim
 si
 signum
 SIGNUM
 sim
 SIMAX
+SIMD
 simplechol
 simplecholperm
 simplematrix
 simplices
 sinetone
 sm
 smirnov
 Smirnov
@@ -859,16 +880,17 @@ Subscripted
 subscripted
 subscripting
 subseteq
 subsindex
 subsref
 substring
 substrings
 SuiteSparse
+sumsq
 SunOS
 superiorto
 supradiagonal
 supset
 supseteq
 SV
 SVD
 svd
@@ -892,16 +914,17 @@ textscan
 th
 ths
 tif
 Tikhonov
 TikZ
 tinv
 Tisseur
 Tisseur's
+tmp
 Toeplitz
 tokenExtents
 TolF
 TolFun
 TolX
 toolkits
 Toolkits
 tp
@@ -1029,18 +1052,20 @@ xu
 xwd
 xy
 xyerrorbar
 xyerrorbars
 xyz
 ydata
 yerrorbar
 yerrorbars
+ylim
 yy
 YY
 yyyy
 YYYY
 yyyymmdd
 yyyymmddTHHMMSS
 Zechner
 zer
 Ziggurat
 zlib
+zlim
diff --git a/doc/interpreter/doccheck/mk_undocumented_list b/doc/interpreter/doccheck/mk_undocumented_list
--- a/doc/interpreter/doccheck/mk_undocumented_list
+++ b/doc/interpreter/doccheck/mk_undocumented_list
@@ -4,17 +4,17 @@
 # Get a list from Octave of all visible functions
 @octave_output = <<`_END_OCT_SCRIPT_`;
 ../../run-octave --norc --silent --no-history --eval '\
  funclist  = vertcat (__list_functions__ , __builtins__) \
  disp("#!-separator-!#") \
  where = cellfun (\@which, funclist, \"UniformOutput\", 0)'
 _END_OCT_SCRIPT_
 
-die "Unable to invoke 'run-octave'.  Exiting\n" unless (@octave_output);
+unless (@octave_output) { die "Unable to invoke 'run-octave'.  Exiting\n" ;}
 
 ################################################################################
 # Winnow list of functions that require a DOCSTRING
 
 $idx = 0;
 while (($_ = $octave_output[$idx++]) !~ /^#!-separator-!#$/)
 {
    push(@all_functions, $1) if (/] = (\w+)$/);
@@ -81,19 +81,19 @@ bug_report
 chdir
 comma
 debug
 dbnext
 exit
 F_DUPFD
 F_GETFD
 F_GETFL
+fact
 finite
 fmod
-fntests
 F_SETFD
 F_SETFL
 gammaln
 home
 i
 ifelse
 inf
 inverse
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 John W. Eaton and David Bateman
+@c Copyright (C) 2007-2012 John W. Eaton and David Bateman
 @c Copyright (C) 2007 Paul Thomas and Christoph Spiel
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 Kurt Hornik
+@c Copyright (C) 1996-2012 Kurt Hornik
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -507,46 +507,49 @@ the recursion depth and prevents Octave 
 @cindex unary minus
 @cindex exponentiation
 @cindex transpose
 @cindex Hermitian operator
 @cindex transpose, complex-conjugate
 @cindex complex-conjugate transpose
 
 The following arithmetic operators are available, and work on scalars
-and matrices.
+and matrices.  The element-by-element operators and functions broadcast
+(@pxref{Broadcasting}).
 
 @table @asis
 @item @var{x} + @var{y}
 @opindex +
 Addition.  If both operands are matrices, the number of rows and columns
-must both agree.  If one operand is a scalar, its value is added to
-all the elements of the other operand.
+must both agree, or they must be broadcastable to the same shape.
 
 @item @var{x} .+ @var{y}
 @opindex .+
-Element by element addition.  This operator is equivalent to @code{+}.
+Element-by-element addition.  This operator is equivalent to @code{+}.
 
 @item @var{x} - @var{y}
 @opindex -
 Subtraction.  If both operands are matrices, the number of rows and
-columns of both must agree.
+columns of both must agree, or they must be broadcastable to the same
+shape.
 
 @item @var{x} .- @var{y}
-Element by element subtraction.  This operator is equivalent to @code{-}.
+Element-by-element subtraction.  This operator is equivalent to @code{-}.
 
 @item @var{x} * @var{y}
 @opindex *
-Matrix multiplication.  The number of columns of @var{x} must agree
-with the number of rows of @var{y}.
+Matrix multiplication.  The number of columns of @var{x} must agree with
+the number of rows of @var{y}, or they must be broadcastable to the same
+shape.
 
 @item @var{x} .* @var{y}
 @opindex .*
-Element by element multiplication.  If both operands are matrices, the
-number of rows and columns must both agree.
+Element-by-element multiplication.  If both operands are matrices, the
+number of rows and columns must both agree, or they must be
+broadcastable to the same shape.
 
 @item @var{x} / @var{y}
 @opindex /
 Right division.  This is conceptually equivalent to the expression
 
 @example
 (inverse (y') * x')'
 @end example
@@ -554,17 +557,17 @@ Right division.  This is conceptually eq
 @noindent
 but it is computed without forming the inverse of @var{y'}.
 
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} ./ @var{y}
 @opindex ./
-Element by element right division.
+Element-by-element right division.
 
 @item @var{x} \ @var{y}
 @opindex \
 Left division.  This is conceptually equivalent to the expression
 
 @example
 inverse (x) * y
 @end example
@@ -572,17 +575,17 @@ inverse (x) * y
 @noindent
 but it is computed without forming the inverse of @var{x}.
 
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} .\ @var{y}
 @opindex .\
-Element by element left division.  Each element of @var{y} is divided
+Element-by-element left division.  Each element of @var{y} is divided
 by each corresponding element of @var{x}.
 
 @item @var{x} ^ @var{y}
 @itemx @var{x} ** @var{y}
 @opindex **
 @opindex ^
 Power operator.  If @var{x} and @var{y} are both scalars, this operator
 returns @var{x} raised to the power @var{y}.  If @var{x} is a scalar and
@@ -593,18 +596,23 @@ expansion if @var{y} is not an integer. 
 @var{x} and @var{y} are matrices.
 
 The implementation of this operator needs to be improved.
 
 @item @var{x} .^ @var{y}
 @itemx @var{x} .** @var{y}
 @opindex .**
 @opindex .^
-Element by element power operator.  If both operands are matrices, the
-number of rows and columns must both agree.
+Element-by-element power operator.  If both operands are matrices, the
+number of rows and columns must both agree, or they must be
+broadcastable to the same shape.  If several complex results are
+possible, the one with smallest non-negative argument (angle) is taken.
+This rule may return a complex root even when a real root is also possible.
+Use @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a
+real result is preferred.
 
 @item -@var{x}
 @opindex -
 Negation.
 
 @item +@var{x}
 @opindex +
 Unary plus.  This operator has no effect on the operand.
@@ -619,17 +627,17 @@ equivalent to the expression
 conj (x.')
 @end example
 
 @item @var{x}.'
 @opindex .'
 Transpose.
 @end table
 
-Note that because Octave's element by element operators begin with a
+Note that because Octave's element-by-element operators begin with a
 @samp{.}, there is a possible ambiguity for statements like
 
 @example
 1./m
 @end example
 
 @noindent
 because the period could be interpreted either as part of the constant
@@ -710,29 +718,30 @@ useful in this case.
 @cindex equality, tests for
 
 @dfn{Comparison operators} compare numeric values for relationships
 such as equality.  They are written using
 @emph{relational operators}.
 
 All of Octave's comparison operators return a value of 1 if the
 comparison is true, or 0 if it is false.  For matrix values, they all
-work on an element-by-element basis.  For example:
+work on an element-by-element basis.  Broadcasting rules apply.
+@xref{Broadcasting}.  For example:
 
 @example
 @group
 [1, 2; 3, 4] == [1, 3; 2, 4]
      @result{}  1  0
          0  1
 @end group
 @end example
 
-If one operand is a scalar and the other is a matrix, the scalar is
-compared to each element of the matrix in turn, and the result is the
-same size as the matrix.
+According to broadcasting rules, if one operand is a scalar and the
+other is a matrix, the scalar is compared to each element of the matrix
+in turn, and the result is the same size as the matrix.
 
 @table @code
 @item @var{x} < @var{y}
 @opindex <
 True if @var{x} is less than @var{y}.
 
 @item @var{x} <= @var{y}
 @opindex <=
@@ -857,28 +866,28 @@ of @var{boolean1} or @var{boolean2} is t
 @item ! @var{boolean}
 @itemx ~ @var{boolean}
 @opindex ~
 @opindex !
 Each element of the result is true if the corresponding element of
 @var{boolean} is false.
 @end table
 
-For matrix operands, these operators work on an element-by-element
-basis.  For example, the expression
+These operators work on an element-by-element basis.  For example, the
+expression
 
 @example
 [1, 0; 0, 1] & [1, 0; 2, 3]
 @end example
 
 @noindent
 returns a two by two identity matrix.
 
-For the binary operators, the dimensions of the operands must conform if
-both are matrices.  If one of the operands is a scalar and the other a
+For the binary operators, broadcasting rules apply.  @xref{Broadcasting}.
+In particular, if one of the operands is a scalar and the other a
 matrix, the operator is applied to the scalar and each element of the
 matrix.
 
 For the binary element-by-element boolean operators, both subexpressions
 @var{boolean1} and @var{boolean2} are evaluated before computing the
 result.  This can make a difference when the expressions have side
 effects.  For example, in the expression
 
diff --git a/doc/interpreter/fn-idx.txi b/doc/interpreter/fn-idx.txi
--- a/doc/interpreter/fn-idx.txi
+++ b/doc/interpreter/fn-idx.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -1140,16 +1140,18 @@ list.  If there are no arguments, you mu
 f = @@sin;
 feval (f, pi/4)
     @result{} 0.70711
 f (pi/4)
     @result{} 0.70711
 @end group
 @end example
 
+@DOCSTRING(is_function_handle)
+
 @DOCSTRING(functions)
 
 @DOCSTRING(func2str)
 
 @DOCSTRING(str2func)
 
 @node Anonymous Functions
 @subsection Anonymous Functions
@@ -1220,18 +1222,16 @@ After this it is possible to evaluate @m
 writing @code{f(x)}.
 
 @DOCSTRING(inline)
 
 @DOCSTRING(argnames)
 
 @DOCSTRING(formula)
 
-@DOCSTRING(vectorize)
-
 @DOCSTRING(symvar)
 
 @node Commands
 @section Commands
 
 Commands are a special class of functions that only accept string
 input arguments.  A command can be called as an ordinary function, but
 it can also be called without the parentheses.  For example,
@@ -1345,16 +1345,19 @@ Functions to manage the directory path O
 Package manager for installing external packages of functions in Octave.
 
 @item plot
 Functions for displaying and printing two- and three-dimensional graphs.
 
 @item polynomial
 Functions for manipulating polynomials.
 
+@item prefs
+Functions implementing user-defined preferences.
+
 @item set
 Functions for creating and manipulating sets of unique values.
 
 @item signal
 Functions for signal processing applications.
 
 @item sparse
 Functions for handling sparse matrices.
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 John W. Eaton and David Bateman
+@c Copyright (C) 2007-2012 John W. Eaton and David Bateman
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/grammar.txi b/doc/interpreter/grammar.txi
--- a/doc/interpreter/grammar.txi
+++ b/doc/interpreter/grammar.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2011 Rik Wehbring
+@c Copyright (C) 2012 Rik Wehbring
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -39,17 +39,198 @@ derived file.
 
 @node Installation
 @chapter Installing Octave
 @end ifset
 
 @cindex installing Octave
 
 The procedure for installing Octave from source on a Unix-like system is
-described below.  Building on other platforms will follow similar steps.
+described below.  Building on other platforms will follow similar
+steps.  Note that this description applies to Octave releases.  Building
+the development sources from the Mercurial archive requires additional
+steps as described in @ref{Building the Development Sources}.
+
+@menu
+* Build Dependencies::
+* Running Configure and Make::
+* Compiling Octave with 64-bit Indexing::
+* Installation Problems::
+@end menu
+
+@node Build Dependencies
+@section Build Dependencies
+
+Octave is a fairly large program with many build dependencies.  You may
+be able to find pre-packaged versions of the dependencies distributed as
+part of your system, or you may have to build some or all of them
+yourself.
+
+The following tools are required:
+
+@table @asis
+@item C++, C, and Fortran compilers
+The Octave sources are primarily written in C++, but some portions are
+also written in C and Fortran.  The Octave sources are intended to be
+portable.  Recent versions of the GNU compiler collection (GCC) should
+work (@url{http://gcc.gnu.org}).  If you use GCC, you should avoid
+mixing versions.  For example, be sure that you are not using the
+obsolete @code{g77} Fortran compiler with modern versions of @code{gcc}
+and @code{g++}.
+
+@item GNU Make
+Tool for building software (@url{http://www.gnu.org/software/make}).
+Octave's build system requires GNU Make.  Other versions of Make will
+not work.  Fortunately, GNU Make is highly portable and easy to install.
+
+@item AWK, sed, and other Unix utilities
+Basic Unix system utilities are required for building Octave.  All will
+be available with any modern Unix system and also on Windows with either
+Cygwin or MinGW and MSYS.
+@end table
+
+Additionally, the following tools may be needed:
+
+@table @asis
+@item Bison
+Parser generator (@url{http://www.gnu.org/software/bison}).
+You will need Bison if you modify the @code{oct-parse.yy} source file or
+if you delete the files that are generated from it.
+
+@item Flex
+Lexer analyzer (@url{http://www.gnu.org/software/flex}).  You will need
+Flex if you modify the @code{lex.ll} source file or if you delete the
+files that are generated from it.
+
+@item Autoconf
+Package for software configuration
+(@url{http://www.gnu.org/software/autoconf}).  Autoconf is required if
+you modify Octave's @code{configure.ac} file or other files that it
+requires.
+
+@item Automake
+Package for Makefile generation
+(@url{http://www.gnu.org/software/automake}).  Automake is required if
+you modify Octave's @code{Makefile.am} files or other files that they
+depend on.
+
+@item Libtool
+Package for building software libraries
+(@url{http://www.gnu.org/software/libtool}).  Libtool is required by
+Automake.
+@end table
+
+The following external packages are required:
+
+@table @asis
+@item BLAS
+Basic Linear Algebra Subroutine library
+(@url{http://www.netlib.org/blas}).  Accelerated BLAS libraries such as
+ATLAS (@url{http://math-atlas.sourceforge.net}) are recommeded for
+better performance.
+@item LAPACK
+Linear Algebra Package (@url{http://www.netlib.org/lapack}).
+@item PCRE
+The Perl Compatible Regular Expression library (http://www.pcre.org).
+@end table
+
+The following external package is optional but strongly recommended:
+
+@table @asis
+@item GNU Readline
+Command-line editing library (@url{www.gnu.org/s/readline}).
+@end table
+
+If you wish to build Octave without GNU readline installed, you must use
+the @code{--disable-readline} option when running the configure script.
+
+The following external software packages are optional but recommended:
+
+@table @asis
+@item ARPACK
+Library for the solution of large-scale eigenvalue problems
+(@url{http://forge.scilab.org/index.php/p/arpack-ng}).  ARPACK is
+required to provide the functions @code{eigs} and @code{svds}.
+
+@item cURL
+Library for transferring data with URL syntax
+(@url{http://curl.haxx.se}).  cURL is required to provide the
+@code{urlread} and @code{urlwrite} functions and the @code{ftp} class.
+
+@item FFTW3
+Library for computing discrete Fourier transforms
+(@url{http://www.fftw.org}).  FFTW3 is used to provide better
+performance for functions that compute discrete Fourier transforms
+(@code{fft}, @code{ifft}, @code{fft2}, etc.)
+
+@item FLTK
+Portable GUI toolkit (@url{http://www.fltk.org}).  FLTK is currently
+used to provide windows for Octave's OpenGL-based graphics functions.
+
+@item fontconfig
+Library for configuring and customizing font access
+(@url{http://www.freedesktop.org/wiki/Software/fontconfig}).  Fontconfig
+is used to manage fonts for Octave's OpenGL-based graphics functions.
+
+@item FreeType
+Portable font engine (@url{http://www.freetype.org}).  FreeType is used
+to perform font rendering for Octave's OpenGL-based graphics functions.
+
+@item GLPK
+GNU Linear Programming Kit (@url{http://www.gnu.org/software/glpk}).
+GPLK is required for the function @code{glpk}.
+
+@item gnuplot
+Interactive graphics program (@url{http://www.gnuplot.info}).  gnuplot
+is currently the default graphics renderer for Octave.
+
+@item GraphicsMagick++
+Image processing library (@url{http://www.graphicsmagick.org}).
+GraphicsMagick++ is used to provide the @code{imread} and @code{imwrite}
+functions.
+
+@item HDF5
+Library for manipulating portable data files
+(@url{http://www.hdfgroup.org/HDF5}).  HDF5 is required for Octave's
+@code{load} and @code{save} commands to read and write HDF data files.
+
+@item OpenGL
+API for portable 2D and 3D graphics (@url{http://www.opengl.org}).  An
+OpenGL implementation is required to provide Octave's OpenGL-based
+graphics functions.  Octave's OpenGL-based graphics functions usually
+outperform the gnuplot-based graphics functions because plot data can be
+rendered directly instead of sending data and commands to gnuplot for
+interpretation and rendering.
+
+@item Qhull
+Computational geometry library (@url{http://www.qhull.org}).  Qhull is
+required to provide the functions @code{convhull}, @code{convhulln}, 
+@code{delaunay}, @code{delaunay3}, @code{delaunayn}, @code{voronoi}, and
+@code{voronoin}.
+
+@item QRUPDATE
+QR factorization updating library
+(@url{http://sourceforge.net/projects/qrupdate}).  QRUPDATE is used to
+provide improved performance for the functions @code{qrdelete},
+@code{qrinsert}, @code{qrshift}, and @code{qrupdate}.
+
+@item SuiteSparse
+Sparse matrix factorization library
+(@url{http://www.cise.ufl.edu/research/sparse/SuiteSparse}).
+SuiteSparse is required to provide sparse matrix factorizations and
+solution of linear equations for sparse systems.
+
+@item zlib
+Data compression library (@url{http://zlib.net}).  The zlib library is
+required for Octave's @code{load} and @code{save} commands to handle
+compressed data, including @sc{Matlab} v5 MAT files.
+@end table
+
+@node Running Configure and Make
+@section Running Configure and Make
 
 @itemize @bullet
 @item
 Run the shell script @file{configure}.  This will determine the features
 your system has (or doesn't have) and create a file named
 @file{Makefile} from each of the files named @file{Makefile.in}.
 
 Here is a summary of the configure options that are most frequently used
@@ -309,23 +490,18 @@ Executables to be run by Octave rather t
 @item @var{prefix}/lib/octave/@var{version}/oct/@var{arch}
 Object files that will be dynamically loaded.
 
 @item @var{prefix}/share/octave/@var{version}/imagelib
 Image files that are distributed with Octave.
 @end table
 @end itemize
 
-@menu
-* Compiling Octave with 64-bit Indexing::       
-* Installation Problems::       
-@end menu
-
 @node Compiling Octave with 64-bit Indexing  
-@appendixsec Compiling Octave with 64-bit Indexing
+@section Compiling Octave with 64-bit Indexing
 
 Note: the following only applies to systems that have 64-bit pointers.
 Configuring Octave with @option{--enable-64} cannot magically make a
 32-bit system have a 64-bit address space.
 
 On 64-bit systems, Octave is limited to (approximately) the following
 array sizes when using the default 32-bit indexing mode:
 
@@ -580,17 +756,17 @@ please submit a bug report.
 @item fontconfig
 
 @item fltk
 @end itemize
 
 @end itemize
 
 @node Installation Problems
-@appendixsec Installation Problems
+@section Installation Problems
 
 This section contains a list of problems (and some apparent problems
 that don't really mean anything is wrong) that may show up during
 installation of Octave.
 
 @itemize @bullet
 @item
 On some SCO systems, @code{info} fails to compile if
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 John W. Eaton
+@c Copyright (C) 2007-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/interpimages.m b/doc/interpreter/interpimages.m
--- a/doc/interpreter/interpimages.m
+++ b/doc/interpreter/interpimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -24,17 +24,16 @@ elements of a matrix meet some condition
 elements of a matrix.  For example, Octave can easily tell you if all
 the elements of a matrix are finite, or are less than some specified
 value.  Octave can also rotate the elements, extract the upper- or
 lower-triangular parts, or sort the columns of a matrix.
 
 @menu
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
-* Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 @end menu
 
 @node Finding Elements and Checking Conditions
 @section Finding Elements and Checking Conditions
 
 The functions @code{any} and @code{all} are useful for determining
@@ -135,23 +134,16 @@ its elements may have, consult @ref{Stat
 @DOCSTRING(prepad)
 
 @DOCSTRING(postpad)
 
 @DOCSTRING(diag)
 
 @DOCSTRING(blkdiag)
 
-@node Applying a Function to an Array
-@section Applying a Function to an Array
-
-@DOCSTRING(arrayfun)
-
-@DOCSTRING(bsxfun)
-
 @node Special Utility Matrices
 @section Special Utility Matrices
 
 @DOCSTRING(eye)
 
 @DOCSTRING(ones)
 
 @DOCSTRING(zeros)
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 John W. Eaton
+## Copyright (C) 2009-2012 John W. Eaton
 ##
 ## This program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -1,9 +1,9 @@
-.\" Copyright (C) 2000-2011 Dirk Eddelbuettel
+.\" Copyright (C) 2000-2012 Dirk Eddelbuettel
 .\"
 .\" This file is part of Octave.
 .\"
 .\" Octave is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
 .\" Free Software Foundation; either version 3 of the License, or (at
 .\" your option) any later version.
 .\"
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
--- a/doc/interpreter/munge-texi.cc
+++ b/doc/interpreter/munge-texi.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/doc/interpreter/nonlin.txi b/doc/interpreter/nonlin.txi
--- a/doc/interpreter/nonlin.txi
+++ b/doc/interpreter/nonlin.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/obsolete.txi b/doc/interpreter/obsolete.txi
--- a/doc/interpreter/obsolete.txi
+++ b/doc/interpreter/obsolete.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2010-2011 John W. Eaton
+@c Copyright (C) 2010-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/octave-config.1 b/doc/interpreter/octave-config.1
--- a/doc/interpreter/octave-config.1
+++ b/doc/interpreter/octave-config.1
@@ -1,9 +1,9 @@
-.\" Copyright (C) 2003-2011 Dirk Eddelbuettel
+.\" Copyright (C) 2003-2012 Dirk Eddelbuettel
 .\"
 .\" This file is part of Octave.
 .\"
 .\" Octave is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
 .\" Free Software Foundation; either version 3 of the License, or (at
 .\" your option) any later version.
 .\"
diff --git a/doc/interpreter/octave.1 b/doc/interpreter/octave.1
--- a/doc/interpreter/octave.1
+++ b/doc/interpreter/octave.1
@@ -1,9 +1,9 @@
-.\" Copyright (C) 1996-2011 John W. Eaton
+.\" Copyright (C) 1996-2012 John W. Eaton
 .\"
 .\" This file is part of Octave.
 .\"
 .\" Octave is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
 .\" Free Software Foundation; either version 3 of the License, or (at
 .\" your option) any later version.
 .\"
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -1,9 +1,9 @@
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
 % 
@@ -192,18 +192,19 @@ It corresponds to GNU Octave version @va
 * Statements::                  Looping and program flow control.
 * Functions and Scripts::       
 * Errors and Warnings::              
 * Debugging::
 * Input and Output::            
 * Plotting::                    
 * Matrix Manipulation::         
 * Arithmetic::                  
-* Linear Algebra::              
-* Nonlinear Equations::         
+* Linear Algebra::
+* Vectorization and Faster Code Execution::
+* Nonlinear Equations::
 * Diagonal and Permutation Matrices::
 * Sparse Matrices::
 * Numerical Integration::                  
 * Differential Equations::      
 * Optimization::                
 * Statistics::                  
 * Sets::                        
 * Polynomial Manipulations::    
@@ -595,17 +596,16 @@ Object Groups
 Graphics Toolkits
 
 * Customizing Toolkit Behavior::
 
 Matrix Manipulation
 
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
-* Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 
 Arithmetic
 
 * Exponents and Logarithms::
 * Complex Arithmetic::          
 * Trigonometry::                
@@ -619,16 +619,25 @@ Arithmetic
 Linear Algebra
 
 * Techniques Used for Linear Algebra::
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 * Specialized Solvers::
 
+Vectorization and Faster Code Execution
+
+* Basic Vectorization::
+* Broadcasting::
+* Function Application::
+* Accumulation::
+* Miscellaneous Techniques::
+* Examples::
+
 Nonlinear Equations
 
 * Solvers::
 * Minimizers::
 
 Diagonal and Permutation Matrices
 
 * Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
@@ -839,24 +848,25 @@ Mex-Files
 Test and Demo Functions
 
 * Test Functions::
 * Demonstration Functions::
 
 Tips and Standards
 
 * Style Tips::                  Writing clean and robust programs.
-* Coding Tips::                 Making code run faster.
 * Comment Tips::                Conventions for writing comments.
 * Function Headers::            Standard headers for functions.
 * Documentation Tips::          Writing readable documentation strings.
 
 Contributing Guidelines
 
 * How to Contribute::
+* Building the Development Sources::
+* Basics of Generating a Changeset::
 * General Guidelines::
 * Octave Sources (m-files)::
 * C++ Sources::
 * Other Sources::
 
 Trouble
 
 * Actual Bugs::                 Bugs we will fix later.
@@ -867,16 +877,19 @@ Reporting Bugs
 
 * Bug Criteria::                
 * Bug Tracker::                 Where to submit your bug report.
 * Bug Reporting::               How to report a bug effectively.
 * Sending Patches::             How to send a patch for Octave.
 
 Installation
 
+* Build Dependencies::
+* Running Configure and Make::
+* Compiling Octave with 64-bit Indexing::       
 * Installation Problems::       
 
 Emacs Octave Support
 
 * Installing EOS::              
 * Using Octave Mode::           
 * Running Octave from Within Emacs::  
 * Using the Emacs Info Reader for Octave::  
@@ -905,16 +918,17 @@ Grammar and Parser
 @include func.texi
 @include errors.texi
 @include debug.texi
 @include io.texi
 @include plot.texi
 @include matrix.texi
 @include arith.texi
 @include linalg.texi
+@include vectorize.texi
 @include nonlin.texi
 @include diagperm.texi
 @include sparse.texi
 @include quad.texi
 @include diffeq.texi
 @include optim.texi
 @include stats.texi
 @include set.texi
diff --git a/doc/interpreter/octave_logo.svg b/doc/interpreter/octave_logo.svg
deleted file mode 100644
--- a/doc/interpreter/octave_logo.svg
+++ /dev/null
@@ -1,259 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:osb="http://www.openswatchbook.org/uri/2009/osb"
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="744.09448819"
-   height="1052.3622047"
-   id="svg2"
-   version="1.1"
-   inkscape:version="0.48.0 r9654"
-   sodipodi:docname="test.svg">
-  <defs
-     id="defs4">
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient5943">
-      <stop
-         style="stop-color:#005e80;stop-opacity:1;"
-         offset="0"
-         id="stop5945" />
-      <stop
-         style="stop-color:#005e80;stop-opacity:0;"
-         offset="1"
-         id="stop5947" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient5748"
-       osb:paint="solid">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop5750" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient4308">
-      <stop
-         id="stop4310"
-         offset="0"
-         style="stop-color:#008cbe;stop-opacity:1;" />
-      <stop
-         id="stop4312"
-         offset="1"
-         style="stop-color:#000000;stop-opacity:1;" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient3976">
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="0"
-         id="stop3978" />
-      <stop
-         style="stop-color:#ff8c00;stop-opacity:1;"
-         offset="1"
-         id="stop3980" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient3840">
-      <stop
-         style="stop-color:#000000;stop-opacity:0.58035713;"
-         offset="0"
-         id="stop3842" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop3844" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient3755">
-      <stop
-         style="stop-color:#008cbe;stop-opacity:1;"
-         offset="0"
-         id="stop3757" />
-      <stop
-         style="stop-color:#b2ffff;stop-opacity:1;"
-         offset="1"
-         id="stop3759" />
-    </linearGradient>
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3755"
-       id="radialGradient5882"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(3.1825621,-3.1825621,10.616125,10.616125,-4957.7085,-4957.9174)"
-       cx="182.9837"
-       cy="395.04871"
-       fx="182.9837"
-       fy="395.04871"
-       r="148.95309" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3755"
-       id="radialGradient5884"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(3.1825621,-3.1825621,10.616125,10.616125,-4957.7085,-4957.9174)"
-       cx="182.9837"
-       cy="395.04871"
-       fx="182.9837"
-       fy="395.04871"
-       r="148.95309" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient5943"
-       id="linearGradient5949"
-       x1="553.82886"
-       y1="268.30722"
-       x2="553.82886"
-       y2="754.65405"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.57247179,0,0,0.57247179,158.30205,-21.246556)" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3755"
-       id="radialGradient3028"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.22914334,-0.22914334,0.7643572,0.7643572,-264.43967,-118.04761)"
-       cx="182.9837"
-       cy="395.04871"
-       fx="182.9837"
-       fy="395.04871"
-       r="148.95309" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3755"
-       id="radialGradient3031"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(3.1825621,-3.1825621,10.616125,10.616125,-4957.7085,-4957.9174)"
-       cx="182.9837"
-       cy="395.04871"
-       fx="182.9837"
-       fy="395.04871"
-       r="148.95309" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3755"
-       id="radialGradient3033"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.22914334,-0.24901479,0.7643572,0.83064268,-274.64232,-161.59239)"
-       cx="182.9837"
-       cy="395.04871"
-       fx="182.9837"
-       fy="395.04871"
-       r="148.95309" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3755"
-       id="radialGradient3918"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.22914334,-0.24901479,0.7643572,0.83064268,-139.56064,-80.672649)"
-       cx="182.9837"
-       cy="395.04871"
-       fx="182.9837"
-       fy="395.04871"
-       r="148.95309" />
-  </defs>
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="0.7194903"
-     inkscape:cx="400.83771"
-     inkscape:cy="794.65978"
-     inkscape:document-units="px"
-     inkscape:current-layer="g3033"
-     showgrid="false"
-     showguides="true"
-     inkscape:guide-bbox="true"
-     inkscape:window-width="1366"
-     inkscape:window-height="706"
-     inkscape:window-x="-8"
-     inkscape:window-y="-8"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata7">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1">
-    <g
-       id="g3033"
-       transform="matrix(2.6880349,0,0,2.6880349,-128.19445,-235.26709)">
-      <g
-         id="g3025"
-         transform="matrix(3.1442941,0,0,3.1442941,-137.08563,-202.09652)">
-        <path
-           inkscape:connector-curvature="0"
-           id="path5874"
-           d="m 66.432103,97.488679 c -5.19584,5.646431 -3.93661,16.169031 2.81107,23.501871 6.74768,7.33285 16.42898,8.69955 21.62483,3.05312 5.19585,-5.64643 3.9402,-16.16946 -2.80749,-23.5023 -6.74768,-7.332861 -16.43256,-8.699131 -21.62841,-3.052691 z m 4.71149,2.34553 c 4.08256,-4.43659 11.589,-3.47152 16.76741,2.155961 5.17842,5.6275 6.06647,13.78491 1.98391,18.2215 -4.08256,4.43658 -11.59097,3.47369 -16.76939,-2.15381 -5.17842,-5.6275 -6.06449,-13.78704 -1.98193,-18.223651 z"
-           style="fill:url(#radialGradient3033);fill-opacity:1;stroke:none"
-           inkscape:export-filename="C:\Users\fotios\Desktop\text5905.png"
-           inkscape:export-xdpi="47.908585"
-           inkscape:export-ydpi="47.908585" />
-        <rect
-           ry="0.76958966"
-           y="99.493881"
-           x="85.381561"
-           height="4.349854"
-           width="4.349854"
-           id="rect5876"
-           style="fill:#ff7f2a;fill-opacity:1;fill-rule:nonzero;stroke:#d45500;stroke-width:0.74403799;stroke-miterlimit:4;stroke-dasharray:none"
-           inkscape:export-filename="C:\Users\fotios\Desktop\text5905.png"
-           inkscape:export-xdpi="47.908585"
-           inkscape:export-ydpi="47.908585" />
-        <rect
-           style="fill:#ff7f2a;fill-opacity:1;fill-rule:nonzero;stroke:#d45500;stroke-width:0.74403799;stroke-miterlimit:4;stroke-dasharray:none"
-           id="rect5878"
-           width="10.245436"
-           height="10.245436"
-           x="60.92659"
-           y="105.2245"
-           ry="1.8126545"
-           inkscape:export-filename="C:\Users\fotios\Desktop\text5905.png"
-           inkscape:export-xdpi="47.908585"
-           inkscape:export-ydpi="47.908585" />
-        <rect
-           ry="1.0951102"
-           y="118.63705"
-           x="87.404739"
-           height="6.1897531"
-           width="6.1897531"
-           id="rect5880"
-           style="fill:#ff7f2a;fill-opacity:1;fill-rule:nonzero;stroke:#d45500;stroke-width:0.74403799;stroke-miterlimit:4;stroke-dasharray:none"
-           inkscape:export-filename="C:\Users\fotios\Desktop\text5905.png"
-           inkscape:export-xdpi="47.908585"
-           inkscape:export-ydpi="47.908585" />
-      </g>
-    </g>
-    <flowRoot
-       xml:space="preserve"
-       id="flowRoot3016"
-       style="fill:black;stroke:none;stroke-opacity:1;stroke-width:1px;stroke-linejoin:miter;stroke-linecap:butt;fill-opacity:1;font-family:ZapfEllipt BT;font-style:normal;font-weight:normal;font-size:40px;line-height:125%;letter-spacing:0px;word-spacing:0px;-inkscape-font-specification:ZapfEllipt BT;font-stretch:normal;font-variant:normal"><flowRegion
-         id="flowRegion3018"><rect
-           id="rect3020"
-           width="835.43738"
-           height="362.30096"
-           x="-17.876692"
-           y="14.322274" /></flowRegion><flowPara
-         id="flowPara3022" /></flowRoot>  </g>
-</svg>
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2008-2011 David Bateman
+@c Copyright (C) 2008-2012 David Bateman
 @c Copyright (C) 2009 VZLU Prague
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
diff --git a/doc/interpreter/op-idx.txi b/doc/interpreter/op-idx.txi
--- a/doc/interpreter/op-idx.txi
+++ b/doc/interpreter/op-idx.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/optim.txi b/doc/interpreter/optim.txi
--- a/doc/interpreter/optim.txi
+++ b/doc/interpreter/optim.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 S�ren Hauberg
+@c Copyright (C) 2007-2012 S�ren Hauberg
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c
@@ -3278,16 +3278,20 @@ Data source variables.
 @subsection Graphics Toolkits
 @cindex graphics toolkits
 @cindex toolkits, graphics
 
 @DOCSTRING(graphics_toolkit)
 
 @DOCSTRING(available_graphics_toolkits)
 
+@DOCSTRING(loaded_graphics_toolkits)
+
+@DOCSTRING(register_graphics_toolkit)
+
 @menu
 * Customizing Toolkit Behavior::    
 @end menu
 
 @node Customizing Toolkit Behavior
 @subsubsection Customizing Toolkit Behavior
 @cindex toolkit customization
 
diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton and David Bateman
+## Copyright (C) 2007-2012 John W. Eaton and David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/preface.txi b/doc/interpreter/preface.txi
--- a/doc/interpreter/preface.txi
+++ b/doc/interpreter/preface.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/signal.txi b/doc/interpreter/signal.txi
--- a/doc/interpreter/signal.txi
+++ b/doc/interpreter/signal.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2004-2011 David Bateman
+@c Copyright (C) 2004-2012 David Bateman
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -218,18 +218,16 @@ s = diag (sparse(randn(1,n)), -1);
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 @DOCSTRING(spdiags)
 
 @DOCSTRING(speye)
 
-@DOCSTRING(spfun)
-
 @DOCSTRING(spones)
 
 @DOCSTRING(sprand)
 
 @DOCSTRING(sprandn)
 
 @DOCSTRING(sprandsym)
 
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2005-2011 David Bateman
+@c Copyright (C) 2005-2012 David Bateman
 @c Copyright (C) 2002-2005 Paul Kienzle
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -23,17 +23,16 @@
 @cindex coding standards
 
 This chapter describes no additional features of Octave.  Instead it
 gives advice on making effective use of the features described in the
 previous chapters.
 
 @menu
 * Style Tips::                  Writing clean and robust programs.
-* Coding Tips::                 Making code run faster.
 * Comment Tips::                Conventions for writing comments.
 * Function Headers::            Standard headers for functions.
 * Documentation Tips::          Writing readable documentation strings.
 @end menu
 
 @node Style Tips
 @section Writing Clean Octave Programs
 
@@ -70,213 +69,16 @@ return.
 
 @item
 Please put a copyright notice on the file if you give copies to anyone.
 Use the same lines that appear at the top of the function files
 distributed with Octave.  If you have not signed papers to assign the
 copyright to anyone else, then place your name in the copyright notice.
 @end itemize
 
-@node Coding Tips
-@section Tips for Making Code Run Faster.
-@cindex execution speed
-@cindex speedups
-
-Here are some ways of improving the execution speed of Octave programs.
-
-@itemize @bullet
-@item
-Vectorize loops.  For instance, rather than
-
-@example
-@group
-for i = 1:n-1
-  a(i) = b(i+1) - b(i);
-endfor
-@end group
-@end example
-
-@noindent
-write
-
-@example
-a = b(2:n) - b(1:n-1);
-@end example
-
-This is especially important for loops with "cheap" bodies.  Often it suffices
-to vectorize just the innermost loop to get acceptable performance.  A general
-rule of thumb is that the "order" of the vectorized body should be greater or
-equal to the "order" of the enclosing loop.
-
-@item
-Use built-in and library functions if possible.  Built-in and compiled functions
-are very fast.  Even with a m-file library function, chances are good that it is
-already optimized, or will be optimized more in a future release.
-
-For instance, even better than
-
-@example
-a = b(2:n) - b(1:n-1);
-@end example
-
-@noindent
-is
-
-@example
-a = diff (b);
-@end example
-
-
-@item
-Avoid computing costly intermediate results multiple times.  Octave currently
-does not eliminate common subexpressions.
-Also, certain internal computation results are cached for variables.
-For instance, if a matrix variable is used multiple times as an index,
-checking the indices (and internal conversion to integers) is only done once.
-
-@item
-Be aware of lazy copies (copy-on-write).  When a copy of an object
-is created, the data is not immediately copied, but rather shared.  The actual
-copying is postponed until the copied data needs to be modified.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a; # no copying done here
-b(1) = 1; # copying done here
-@end group
-@end example
-
-Lazy copying applies to whole Octave objects such as matrices, cells, struct,
-and also individual cell or struct elements (not array elements).
-
-Additionally, index expressions also use lazy copying when Octave can determine
-that the indexed portion is contiguous in memory.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a(:,10:100); # no copying done here
-b = a(10:100,:); # copying done here
-@end group
-@end example
-
-This applies to arrays (matrices), cell arrays, and structs indexed using ().
-Index expressions generating cs-lists can also benefit of shallow copying
-in some cases.  In particular, when @var{a} is a struct array, expressions like
-@code{@{a.x@}, @{a(:,2).x@}} will use lazy copying, so that data can be shared
-between a struct array and a cell array.
-
-Most indexing expressions do not live longer than their `parent' objects.
-In rare cases, however, a lazily copied slice outlasts its parent, in which
-case it becomes orphaned, still occupying unnecessarily more memory than needed.
-To provide a remedy working in most real cases,
-Octave checks for orphaned lazy slices at certain situations, when a value
-is stored into a "permanent" location, such as a named variable or cell or
-struct element, and possibly economizes them.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a(:,10:100);  # lazy slice
-a = []; # the original a array is still allocated
-c@{1@} = b; # b is reallocated at this point
-@end group
-@end example
-
-@item
-Avoid deep recursion.  Function calls to m-file functions carry a relatively
-significant overhead, so rewriting a recursion as a loop often helps.  Also,
-note that the maximum level of recursion is limited.
-
-@item
-Avoid resizing matrices unnecessarily.  When building a single result
-matrix from a series of calculations, set the size of the result matrix
-first, then insert values into it.  Write
-
-@example
-@group
-result = zeros (big_n, big_m)
-for i = over:and_over
-  r1 = @dots{}
-  r2 = @dots{}
-  result (r1, r2) = new_value ();
-endfor
-@end group
-@end example
-
-@noindent
-instead of
-
-@example
-@group
-result = [];
-for i = ever:and_ever
-  result = [ result, new_value() ];
-endfor
-@end group
-@end example
-
-Sometimes the number of items can't be computed in advance, and stack-like
-operations are needed.  When elements are being repeatedly inserted at/removed
-from the end of an array, Octave detects it as stack usage and attempts to use a
-smarter memory management strategy pre-allocating the array in bigger chunks. 
-Likewise works for cell and struct arrays.
-
-@example
-@group
-a = [];
-while (condition)
-  @dots{}
-  a(end+1) = value; # "push" operation
-  @dots{}
-  a(end) = []; # "pop" operation
-  @dots{}
-endwhile
-@end group
-@end example
-
-@item
-Use @code{cellfun} intelligently.  The @code{cellfun} function is a useful tool
-for avoiding loops.  @xref{Processing Data in Cell Arrays}.
-@code{cellfun} is often used with anonymous function handles; however, calling
-an anonymous function involves an overhead quite comparable to the overhead
-of an m-file function.  Passing a handle to a built-in function is faster,
-because the interpreter is not involved in the internal loop.  For example:
-
-@example
-@group
-a = @{@dots{}@}
-v = cellfun (@@(x) det(x), a); # compute determinants
-v = cellfun (@@det, a); # faster
-@end group
-@end example
-
-@item
-Octave includes a number of other functions that can replace common types of
-loops, including @code{bsxfun}, @code{arrayfun}, @code{structfun},
-@code{accumarray}.  These functions can take an arbitrary function as a handle.
-Be sure to get familiar with them if you want to become an Octave expert.
-
-@item
-Avoid calling @code{eval} or @code{feval} excessively, because
-they require Octave to parse input or look up the name of a function in
-the symbol table.
-
-If you are using @code{eval} as an exception handling mechanism and not
-because you need to execute some arbitrary text, use the @code{try}
-statement instead.  @xref{The @code{try} Statement}.
-
-@item
-If you are calling lots of functions but none of them will need to
-change during your run, set the variable
-@code{ignore_function_time_stamp} to @code{"all"} so that Octave doesn't
-waste a lot of time checking to see if you have updated your function
-files.
-@end itemize
 
 @node Comment Tips
 @section Tips on Writing Comments
 
 Here are the conventions to follow when writing comments.
 
 @table @samp
 @item #
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/vectorize.txi
@@ -0,0 +1,678 @@
+@c Copyright (C) 2012 Jordi Gutiérrez Hermoso
+@c
+@c This file is part of Octave.
+@c
+@c Octave is free software; you can redistribute it and/or modify it
+@c under the terms of the GNU General Public License as published by the
+@c Free Software Foundation; either version 3 of the License, or (at
+@c your option) any later version.
+@c
+@c Octave is distributed in the hope that it will be useful, but WITHOUT
+@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+@c FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+@c for more details.
+@c
+@c You should have received a copy of the GNU General Public License
+@c along with Octave; see the file COPYING. If not, see
+@c <http://www.gnu.org/licenses/>.
+
+@node Vectorization and Faster Code Execution
+@chapter Vectorization and Faster Code Execution
+@cindex vectorization
+@cindex vectorize
+
+Vectorization is a programming technique that uses vector operations
+instead of element-by-element loop-based operations.  Besides frequently
+producing more succinct Octave code, vectorization also allows for better
+optimization in the subsequent implementation.  The optimizations may occur
+either in Octave's own Fortran, C, or C++ internal implementation, or even at a
+lower level depending on the compiler and external numerical libraries used to
+build Octave.  The ultimate goal is to make use of your hardware's vector
+instructions if possible or to perform other optimizations in software.
+
+Vectorization is not a concept unique to Octave, but it is particularly
+important because Octave is a matrix-oriented language.  Vectorized
+Octave code will see a dramatic speed up (10X--100X) in most cases.
+
+This chapter discusses vectorization and other techniques for writing faster
+code.
+
+@menu
+* Basic Vectorization::        Basic techniques for code optimization
+* Broadcasting::               Broadcasting operations
+* Function Application::       Applying functions to arrays, cells, and structs
+* Accumulation::               Accumulation functions
+* Miscellaneous Techniques::   Other techniques for speeding up code
+* Examples::
+@end menu
+
+@node Basic Vectorization
+@section Basic Vectorization
+
+To a very good first approximation, the goal in vectorization is to
+write code that avoids loops and uses whole-array operations.  As a
+trivial example, consider
+
+@example
+@group
+for i = 1:n
+  for j = 1:m
+    c(i,j) = a(i,j) + b(i,j);
+  endfor
+endfor
+@end group
+@end example
+
+@noindent
+compared to the much simpler
+
+@example
+c = a + b;
+@end example
+
+@noindent
+This isn't merely easier to write; it is also internally much easier to
+optimize.  Octave delegates this operation to an underlying
+implementation which, among other optimizations, may use special vector
+hardware instructions or could conceivably even perform the additions in
+parallel.  In general, if the code is vectorized, the underlying
+implementation has more freedom about the assumptions it can make
+in order to achieve faster execution.
+
+This is especially important for loops with "cheap" bodies.  Often it
+suffices to vectorize just the innermost loop to get acceptable
+performance.  A general rule of thumb is that the "order" of the
+vectorized body should be greater or equal to the "order" of the
+enclosing loop.
+
+As a less trivial example, instead of
+
+@example
+@group
+for i = 1:n-1
+  a(i) = b(i+1) - b(i);
+endfor
+@end group
+@end example
+
+@noindent
+write
+
+@example
+a = b(2:n) - b(1:n-1);
+@end example
+
+This shows an important general concept about using arrays for indexing
+instead of looping over an index variable.  @xref{Index Expressions}.
+Also use boolean indexing generously.  If a condition needs to be tested,
+this condition can also be written as a boolean index.  For instance,
+instead of
+
+@example
+@group
+for i = 1:n
+  if a(i) > 5
+    a(i) -= 20
+  endif
+endfor
+@end group
+@end example
+
+@noindent
+write
+
+@example
+a(a>5) -= 20;
+@end example
+
+@noindent
+which exploits the fact that @code{a > 5} produces a boolean index.
+
+Use elementwise vector operators whenever possible to avoid looping
+(operators like @code{.*} and @code{.^}).  @xref{Arithmetic Ops}.  For
+simple inline functions, the @code{vectorize} function can do this
+automatically.
+
+@DOCSTRING(vectorize)
+
+Also exploit broadcasting in these elementwise operators both to avoid
+looping and unnecessary intermediate memory allocations.
+@xref{Broadcasting}.
+
+Use built-in and library functions if possible.  Built-in and compiled
+functions are very fast.  Even with an m-file library function, chances
+are good that it is already optimized, or will be optimized more in a
+future release.
+
+For instance, even better than
+
+@example
+a = b(2:n) - b(1:n-1);
+@end example
+
+@noindent
+is
+
+@example
+a = diff (b);
+@end example
+
+Most Octave functions are written with vector and array arguments in
+mind.  If you find yourself writing a loop with a very simple operation,
+chances are that such a function already exists.  The following functions
+occur frequently in vectorized code:
+
+@itemize @bullet
+@item
+Index manipulation
+
+@itemize
+@item
+find
+
+@item
+sub2ind
+
+@item
+ind2sub
+
+@item
+sort
+
+@item
+unique
+
+@item
+lookup
+
+@item
+ifelse / merge
+@end itemize
+
+@item
+Repetition
+@itemize
+@item
+repmat
+
+@item
+repelems
+@end itemize
+
+@item
+Vectorized arithmetic
+@itemize
+@item
+sum
+
+@item
+prod
+
+@item
+cumsum
+
+@item
+cumprod
+
+@item
+sumsq
+
+@item
+diff
+
+@item
+dot
+
+@item
+cummax
+
+@item
+cummin
+@end itemize
+
+@item
+Shape of higher dimensional arrays
+@itemize
+@item
+reshape
+
+@item
+resize
+
+@item
+permute
+
+@item
+squeeze
+
+@item
+deal
+@end itemize
+
+@end itemize
+
+@node Broadcasting
+@section Broadcasting
+@cindex broadcast
+@cindex broadcasting
+@cindex BSX
+@cindex recycling
+@cindex SIMD
+
+Broadcasting refers to how Octave binary operators and functions behave
+when their matrix or array operands or arguments differ in size.  Since
+version 3.6.0, Octave now automatically broadcasts vectors, matrices,
+and arrays when using elementwise binary operators and functions.
+Broadly speaking, smaller arrays are ``broadcast'' across the larger
+one, until they have a compatible shape.  The rule is that corresponding
+array dimensions must either
+
+@enumerate
+@item
+be equal, or
+
+@item
+one of them must be 1.
+@end enumerate
+
+@noindent
+In case all dimensions are equal, no broadcasting occurs and ordinary
+element-by-element arithmetic takes place.  For arrays of higher
+dimensions, if the number of dimensions isn't the same, then missing
+trailing dimensions are treated as 1.  When one of the dimensions is 1,
+the array with that singleton dimension gets copied along that dimension
+until it matches the dimension of the other array.  For example, consider
+
+@example
+@group
+x = [1 2 3;
+     4 5 6;
+     7 8 9];
+
+y = [10 20 30];
+
+x + y
+@end group
+@end example
+
+@noindent
+Without broadcasting, @code{x + y} would be an error because the dimensions
+do not agree.  However, with broadcasting it is as if the following
+operation were performed:
+
+@example
+@group
+x = [1 2 3
+     4 5 6
+     7 8 9];
+
+y = [10 20 30
+     10 20 30
+     10 20 30];
+
+x + y
+@result{}    11   22   33
+      14   25   36
+      17   28   39
+@end group
+@end example
+
+@noindent
+That is, the smaller array of size @code{[1 3]} gets copied along the
+singleton dimension (the number of rows) until it is @code{[3 3]}.  No
+actual copying takes place, however.  The internal implementation reuses
+elements along the necessary dimension in order to achieve the desired
+effect without copying in memory.
+
+Both arrays can be broadcast across each other, for example, all
+pairwise differences of the elements of a vector with itself:
+
+@example
+@group
+y - y'
+@result{}    0   10   20
+    -10    0   10
+    -20  -10    0
+@end group
+@end example
+
+@noindent
+Here the vectors of size @code{[1 3]} and @code{[3 1]} both get
+broadcast into matrices of size @code{[3 3]} before ordinary matrix
+subtraction takes place.
+
+A special case of broadcasting that may be familiar is when all
+dimensions of the array being broadcast are 1, i.e. the array is a
+scalar. Thus for example, operations like @code{x - 42} and @code{max
+(x, 2)} are basic examples of broadcasting.
+
+For a higher-dimensional example, suppose @code{img} is an RGB image of
+size @code{[m n 3]} and we wish to multiply each color by a different
+scalar.  The following code accomplishes this with broadcasting,
+
+@example
+img .*= permute ([0.8, 0.9, 1.2], [1, 3, 2]);
+@end example
+
+@noindent
+Note the usage of permute to match the dimensions of the
+@code{[0.8, 0.9, 1.2]} vector with @code{img}.
+
+For functions that are not written with broadcasting semantics,
+@code{bsxfun} can be useful for coercing them to broadcast.
+
+@DOCSTRING(bsxfun)
+
+Broadcasting is only applied if either of the two broadcasting
+conditions hold.  As usual, however, broadcasting does not apply when two
+dimensions differ and neither is 1:
+
+@example
+@group
+x = [1 2 3
+     4 5 6];
+y = [10 20
+     30 40];
+x + y
+@end group
+@end example
+
+@noindent
+This will produce an error about nonconformant arguments.
+
+Besides common arithmetic operations, several functions of two arguments
+also broadcast.  The full list of functions and operators that broadcast
+is
+
+@example
+      plus      +  .+
+      minus     -  .-
+      times     .*
+      rdivide   ./
+      ldivide   .\
+      power     .^  .**
+      lt        <
+      le        <=
+      eq        ==
+      gt        >
+      ge        >=
+      ne        !=  ~=
+      and       &
+      or        |
+      atan2
+      hypot
+      max
+      min
+      mod
+      rem
+      xor
+
+      +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
+@end example
+
+Beware of resorting to broadcasting if a simpler operation will suffice.
+For matrices @var{a} and @var{b}, consider the following:
+
+@example
+@var{c} = sum (permute (@var{a}, [1, 3, 2]) .* permute (@var{b}, [3, 2, 1]), 3);
+@end example
+
+@noindent
+This operation broadcasts the two matrices with permuted dimensions
+across each other during elementwise multiplication in order to obtain a
+larger 3-D array, and this array is then summed along the third dimension.
+A moment of thought will prove that this operation is simply the much
+faster ordinary matrix multiplication, @code{@var{c} = @var{a}*@var{b};}.
+
+A note on terminology: ``broadcasting'' is the term popularized by the
+Numpy numerical environment in the Python programming language.  In other
+programming languages and environments, broadcasting may also be known
+as @emph{binary singleton expansion} (BSX, in @sc{matlab}, and the
+origin of the name of the @code{bsxfun} function), @emph{recycling} (R
+programming language), @emph{single-instruction multiple data} (SIMD),
+or @emph{replication}.
+
+@subsection Broadcasting and Legacy Code
+
+The new broadcasting semantics almost never affect code that worked
+in previous versions of Octave.  Consequently, all code inherited from
+@sc{matlab} that worked in previous versions of Octave should still work
+without change in Octave.  The only exception is code such as
+
+@example
+@group
+try
+  c = a.*b;
+catch
+  c = a.*a;
+end_try_catch
+@end group
+@end example
+
+@noindent
+that may have relied on matrices of different size producing an error.
+Due to how broadcasting changes semantics with older versions of Octave,
+by default Octave warns if a broadcasting operation is performed.  To
+disable this warning, refer to its ID (@pxref{doc-warning_ids}):
+
+@example
+warning ("off", "Octave:broadcast");
+@end example
+
+@noindent
+If you want to recover the old behavior and produce an error, turn this
+warning into an error:
+
+@example
+warning ("error", "Octave:broadcast");
+@end example
+
+@noindent
+For broadcasting on scalars that worked in previous versions of Octave,
+this warning will not be emitted.
+
+@node Function Application
+@section Function Application
+@cindex map
+@cindex apply
+@cindex function application
+
+As a general rule, functions should already be written with matrix
+arguments in mind and should consider whole matrix operations in a
+vectorized manner.  Sometimes, writing functions in this way appears
+difficult or impossible for various reasons.  For those situations,
+Octave provides facilities for applying a function to each element of an
+array, cell, or struct.
+
+@DOCSTRING(arrayfun)
+
+@DOCSTRING(spfun)
+
+@DOCSTRING(cellfun)
+
+@DOCSTRING(structfun)
+
+@node Accumulation
+@section Accumulation
+
+Whenever it's possible to categorize according to indices the elements
+of an array when performing a computation, accumulation functions can be
+useful.
+
+@DOCSTRING(accumarray)
+
+@DOCSTRING(accumdim)
+
+@node Miscellaneous Techniques
+@section Miscellaneous Techniques
+@cindex execution speed
+@cindex speedups
+@cindex optimization
+
+Here are some other ways of improving the execution speed of Octave
+programs.
+
+@itemize @bullet
+
+@item Avoid computing costly intermediate results multiple times.
+Octave currently does not eliminate common subexpressions.  Also, certain
+internal computation results are cached for variables.  For instance, if
+a matrix variable is used multiple times as an index, checking the
+indices (and internal conversion to integers) is only done once.
+
+@item Be aware of lazy copies (copy-on-write).  
+@cindex copy-on-write
+@cindex COW
+@cindex memory management
+When a copy of an object is created, the data is not immediately copied, but
+rather shared.  The actual copying is postponed until the copied data needs to
+be modified.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a; # no copying done here
+b(1) = 1; # copying done here
+@end group
+@end example
+
+Lazy copying applies to whole Octave objects such as matrices, cells,
+struct, and also individual cell or struct elements (not array
+elements).
+
+Additionally, index expressions also use lazy copying when Octave can
+determine that the indexed portion is contiguous in memory.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a(:,10:100);  # no copying done here
+b = a(10:100,:);  # copying done here
+@end group
+@end example
+
+This applies to arrays (matrices), cell arrays, and structs indexed
+using @samp{()}.  Index expressions generating comma-separated lists can also
+benefit from shallow copying in some cases.  In particular, when @var{a} is a
+struct array, expressions like @code{@{a.x@}, @{a(:,2).x@}} will use lazy
+copying, so that data can be shared between a struct array and a cell array.
+
+Most indexing expressions do not live longer than their parent
+objects.  In rare cases, however, a lazily copied slice outlasts its
+parent, in which case it becomes orphaned, still occupying unnecessarily
+more memory than needed.  To provide a remedy working in most real cases,
+Octave checks for orphaned lazy slices at certain situations, when a
+value is stored into a "permanent" location, such as a named variable or
+cell or struct element, and possibly economizes them.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a(:,10:100);  # lazy slice
+a = []; # the original a array is still allocated
+c@{1@} = b; # b is reallocated at this point
+@end group
+@end example
+
+@item Avoid deep recursion.
+Function calls to m-file functions carry a relatively significant overhead, so
+rewriting a recursion as a loop often helps.  Also, note that the maximum level
+of recursion is limited.
+
+@item Avoid resizing matrices unnecessarily.
+When building a single result matrix from a series of calculations, set the
+size of the result matrix first, then insert values into it.  Write
+
+@example
+@group
+result = zeros (big_n, big_m)
+for i = over:and_over
+  ridx = @dots{}
+  cidx = @dots{}
+  result(ridx, cidx) = new_value ();
+endfor
+@end group
+@end example
+
+@noindent
+instead of
+
+@example
+@group
+result = [];
+for i = ever:and_ever
+  result = [ result, new_value() ];
+endfor
+@end group
+@end example
+
+Sometimes the number of items can not be computed in advance, and
+stack-like operations are needed.  When elements are being repeatedly
+inserted or removed from the end of an array, Octave detects it as stack
+usage and attempts to use a smarter memory management strategy by
+pre-allocating the array in bigger chunks.  This strategy is also applied
+to cell and struct arrays.
+
+@example
+@group
+a = [];
+while (condition)
+  @dots{}
+  a(end+1) = value; # "push" operation
+  @dots{}
+  a(end) = []; # "pop" operation
+  @dots{}
+endwhile
+@end group
+@end example
+
+@item Avoid calling @code{eval} or @code{feval} excessively.
+Parsing input or looking up the name of a function in the symbol table are
+relatively expensive operations.
+
+If you are using @code{eval} merely as an exception handling mechanism, and not
+because you need to execute some arbitrary text, use the @code{try}
+statement instead.  @xref{The @code{try} Statement}.
+
+@item Use @code{ignore_function_time_stamp} when appropriate.
+If you are calling lots of functions, and none of them will need to change
+during your run, set the variable @code{ignore_function_time_stamp} to
+@code{"all"}.  This will stop Octave from checking the time stamp of a function
+file to see if it has been updated while the program is being run.
+@end itemize
+
+@node Examples
+@section Examples
+
+The following are examples of vectorization questions asked by actual
+users of Octave and their solutions.
+
+@c FIXME: We need a lot more examples here.
+
+@itemize @bullet
+@item
+For a vector @code{A}, the following loop
+
+@example
+@group
+n = length (A);
+B = zeros (n, 2);
+for i = 1:length(A)
+  ## this will be two columns, the first is the difference and
+  ## the second the mean of the two elements used for the diff.
+  B(i,:) = [A(i+1)-A(i), (A(i+1) + A(i))/2)];
+endfor
+@end group
+@end example
+
+@noindent
+can be turned into the following one-liner:
+
+@example
+B = [diff(A)(:), 0.5*(A(1:end-1)+A(2:end))(:)]
+@end example
+
+Note the usage of colon indexing to flatten an intermediate result into
+a column vector.  This is a common vectorization trick.
+
+@end itemize
diff --git a/doc/liboctave/array.texi b/doc/liboctave/array.texi
--- a/doc/liboctave/array.texi
+++ b/doc/liboctave/array.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/bugs.texi b/doc/liboctave/bugs.texi
--- a/doc/liboctave/bugs.texi
+++ b/doc/liboctave/bugs.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/cp-idx.texi b/doc/liboctave/cp-idx.texi
--- a/doc/liboctave/cp-idx.texi
+++ b/doc/liboctave/cp-idx.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/dae.texi b/doc/liboctave/dae.texi
--- a/doc/liboctave/dae.texi
+++ b/doc/liboctave/dae.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/diffeq.texi b/doc/liboctave/diffeq.texi
--- a/doc/liboctave/diffeq.texi
+++ b/doc/liboctave/diffeq.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/error.texi b/doc/liboctave/error.texi
--- a/doc/liboctave/error.texi
+++ b/doc/liboctave/error.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/factor.texi b/doc/liboctave/factor.texi
--- a/doc/liboctave/factor.texi
+++ b/doc/liboctave/factor.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/fn-idx.texi b/doc/liboctave/fn-idx.texi
--- a/doc/liboctave/fn-idx.texi
+++ b/doc/liboctave/fn-idx.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/gpl.texi b/doc/liboctave/gpl.texi
--- a/doc/liboctave/gpl.texi
+++ b/doc/liboctave/gpl.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/install.texi b/doc/liboctave/install.texi
--- a/doc/liboctave/install.texi
+++ b/doc/liboctave/install.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/intro.texi b/doc/liboctave/intro.texi
--- a/doc/liboctave/intro.texi
+++ b/doc/liboctave/intro.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/liboctave.texi b/doc/liboctave/liboctave.texi
--- a/doc/liboctave/liboctave.texi
+++ b/doc/liboctave/liboctave.texi
@@ -1,9 +1,9 @@
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
 % 
diff --git a/doc/liboctave/matvec.texi b/doc/liboctave/matvec.texi
--- a/doc/liboctave/matvec.texi
+++ b/doc/liboctave/matvec.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/nleqn.texi b/doc/liboctave/nleqn.texi
--- a/doc/liboctave/nleqn.texi
+++ b/doc/liboctave/nleqn.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/nlfunc.texi b/doc/liboctave/nlfunc.texi
--- a/doc/liboctave/nlfunc.texi
+++ b/doc/liboctave/nlfunc.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1997-2011 John W. Eaton
+@c Copyright (C) 1997-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/ode.texi b/doc/liboctave/ode.texi
--- a/doc/liboctave/ode.texi
+++ b/doc/liboctave/ode.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/optim.texi b/doc/liboctave/optim.texi
--- a/doc/liboctave/optim.texi
+++ b/doc/liboctave/optim.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/preface.texi b/doc/liboctave/preface.texi
--- a/doc/liboctave/preface.texi
+++ b/doc/liboctave/preface.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/quad.texi b/doc/liboctave/quad.texi
--- a/doc/liboctave/quad.texi
+++ b/doc/liboctave/quad.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/range.texi b/doc/liboctave/range.texi
--- a/doc/liboctave/range.texi
+++ b/doc/liboctave/range.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/refcard/Makefile.am b/doc/refcard/Makefile.am
--- a/doc/refcard/Makefile.am
+++ b/doc/refcard/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/refcard directory
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/refcard/refcard-a4.tex b/doc/refcard/refcard-a4.tex
--- a/doc/refcard/refcard-a4.tex
+++ b/doc/refcard/refcard-a4.tex
@@ -1,13 +1,13 @@
 % refcard-a4.tex
 %
 % Make a reference card that will fit on A4 paper.
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/doc/refcard/refcard-legal.tex b/doc/refcard/refcard-legal.tex
--- a/doc/refcard/refcard-legal.tex
+++ b/doc/refcard/refcard-legal.tex
@@ -1,13 +1,13 @@
 % refcard-legal.tex
 %
 % Make a reference card that will fit on US legal paper.
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/doc/refcard/refcard-letter.tex b/doc/refcard/refcard-letter.tex
--- a/doc/refcard/refcard-letter.tex
+++ b/doc/refcard/refcard-letter.tex
@@ -1,14 +1,14 @@
 % refcard-letter.tex
 %
 % Make a reference card that will fit on US letter paper
 % (8-1/2 by 11 inches).
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -1,13 +1,13 @@
 % refcard.tex
 %
 % This file is TeX source for a reference card describing Octave.
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -184,17 +184,17 @@ John W. Eaton
 jwe@octave.org
 
 
 Last updated: Tue Nov 22 20:51:34 PST 2011
 
 
 ################################################################################
 
-Copyright (C) 2009,2011 John W. Eaton
+Copyright (C) 2009,2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at
 your option) any later version.
 
diff --git a/etc/README.Cygwin b/etc/README.Cygwin
--- a/etc/README.Cygwin
+++ b/etc/README.Cygwin
@@ -2,50 +2,88 @@ Starting with version 3.0.1, Octave is o
 net distribution of Cygwin, available from http://www.cygwin.com.  
 
 It is possible to build Octave from source on Windows systems with Cygwin,
 but with the old gcc-3.4.4-3 compiler there are some performance
 problems related to the way C++ exception handling is implemented.
 This is a known problem with a long history and it is STRONGLY 
 encouraged to use gcc-4.3.2-1 or later.
 
-Current binary versions are built with gcc-4.3.4-3 while 
-binary version 3.0.2-2 was built with gcc-4.3.2-1.
+Current binary versions are built with gcc-4.5.3-3.  
+
 
-The latest development Octave development sources (octave-3.3.54+)
+------- SUGGESTED CONFIGURATION  ---------------------------
+
+The latest development Octave development sources (octave-3.5.91+)
 are built with:
 
 configure --enable-shared \
           --enable-float-truncate \
           CC=gcc-4 F77=gfortran-4 CXX=g++-4 CPP=cpp-4 
           lt_cv_deplibs_check_method=pass_all \
-          LDFLAGS=-no-undefined 
+          LDFLAGS=-Wl,-no-undefined 
 
 "--enable-float-truncate" is needed for the following bug:
 http://thread.gmane.org/gmane.comp.gnu.octave.bugs/12361/focus=12404
 Without it, one of the quadgk test will fail as
 "a=a" could be false due to truncation problems with 
 complex numbers. 
 
 "lt_cv_deplibs_check_method=pass_all"  is needed to bypass
 incorrect libtool detection of system capabilities and
 to allow shared libs building.
 
+"LDFLAGS=-Wl,-no-undefined" is better than previous 
+"LDFLAGS=-no-undefined" as gcc-4 is now complaining about
+unknown command and the "undefined" is for the linker.
+
+The additional patch used for 3.4.3-3 package can also be 
+needed for 3.6.x (see below).
+
+------- SUGGESTION FOR FORK ISSUE --------------------------
+
+The build process can fails in building images for documentation 
+due to fork issue of the octave dll just built. In such case 
+I suggest to rebase the built dll's with:
+
+$ find build_tree -name "*.dll"  > rebase_list
+
+and after closing all cygwin process, from a dash shell
+
+$ rebaseall -s 'dll|so|oct' -T /full_path/rebase_list
+
+After rebasing the "make" should be able to complete the
+creation of the images and the documentation. 
+
+------------------------------------------------------ 
+
+Octave-3.4.3-3 package was built using:
+
+configure --libexecdir=/usr/lib \
+          --enable-shared \
+          --enable-float-truncate \
+          F77=gfortran-4 \
+          lt_cv_deplibs_check_method=pass_all \
+          LDFLAGS=-no-undefined    
+
+plus and additional patch to solve a specific cygwin 
+fltk print issue, see:
+https://savannah.gnu.org/bugs/?31641
 
 Octave-3.2.4 was built using:
 
 configure --enable-shared \
           --without-fltk \
           --without-framework-opengl \
           CC=gcc-4 F77=gfortran-4 CXX=g++-4 CPP=cpp-4
           CFLAGS="-Dtimezone=_timezone"
 
-
+------------------------------------------------------
 Current Cygwin package maintainer for Octave:
 
   Marco Atzeri
   http://matzeri.altervista.org
 
 Marco Atzeri
-marco_atzeri@yahoo.it
+marco.atzeri@gmail.com
 Italy
 
-Last updated: Mon Jan  3 18:53:41 WEST 2011
+Last updated: Tue Jan  3 14:40:58 WEST 2012
diff --git a/examples/Makefile.am b/examples/Makefile.am
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's examples directory
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/libcruft/Makefile.am b/libcruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/libcruft/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's libcruft directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
@@ -64,17 +64,16 @@ libranlib_la_SOURCES =
 
 libranlib_la_DEPENDENCIES = ranlib.def
 
 octinclude_HEADERS =
 
 EXTRA_DIST =
 
 include amos/module.mk
-include arpack/module.mk
 include blas-xtra/module.mk
 include daspk/module.mk
 include dasrt/module.mk
 include dassl/module.mk
 include fftpack/module.mk
 include lapack-xtra/module.mk
 include misc/module.mk
 include odepack/module.mk
diff --git a/libcruft/arpack/LICENSE b/libcruft/arpack/LICENSE
deleted file mode 100644
--- a/libcruft/arpack/LICENSE
+++ /dev/null
@@ -1,35 +0,0 @@
-BSD Software License
-
-Pertains to ARPACK and P_ARPACK
-
-Copyright (c) 1996-2008 Rice University.  
-Developed by D.C. Sorensen, R.B. Lehoucq, C. Yang, and K. Maschhoff.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-- Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer. 
-  
-- Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer listed
-  in this license in the documentation and/or other materials
-  provided with the distribution.
-  
-- Neither the name of the copyright holders nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-  
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
diff --git a/libcruft/arpack/README b/libcruft/arpack/README
deleted file mode 100644
--- a/libcruft/arpack/README
+++ /dev/null
@@ -1,120 +0,0 @@
-1. You have successfully unbundled ARPACK and are now in the ARPACK 
-   directory that was created for you.
-
-2. Recent bug fixes are included in patch.tar.gz and ppatch.tar.gz 
-   If you have not retrieved these files, please do so and place them in 
-   the directory right above the current directory.  (They should
-   be in the same directory where arpack96.tar and parpack96.tar reside).
-   Use uncompress or gunzip to unzip the tar files, and use 'tar -xvf '
-   to unbundle these patches.  The source codes in these patches will 
-   overwrite those contained in arpack96.tar and parpack96.tar.
-
-3. Upon executing the 'ls | more ' command you should see
-
-      BLAS
-      DOCUMENTS
-      EXAMPLES
-      LAPACK
-      README
-      SRC
-      UTIL
-      Makefile
-      ARmake.inc
-      ARMAKES
-      PARPACK
-
-   The following entries are directories:
-
-      ARMAKES, BLAS, DOCUMENTS, EXAMPLES, LAPACK, SRC, UTIL, PARPACK
-
-   The directory SRC contains the top level routines including 
-   the highest level reverse communication interface routines
-
-      ssaupd, dsaupd - symmetric single and double precision
-      snaupd, dnaupd - non-symmetric single and double precision
-      cnaupd, znaupd - complex non-symmetric single and double precision
-
-   The headers of these routines contain full documentation of calling
-   sequence and usage.  Additional information is in the DOCUMENTS directory.
-
-   The directory PARPACK contains the Parallel ARPACK routines.
-     
-
-3. Example driver programs that illustrate all the computational modes,
-   data types and precisions may be found in the EXAMPLES directory.
-   Upon executing the 'ls EXAMPLES | more ' command you should see
-
-      BAND
-      COMPLEX
-      NONSYM
-      README
-      SIMPLE
-      SVD
-      SYM
-
-   Example programs for banded, complex, nonsymmetric, symmetric,
-   and singular value decomposition may be found in the directories
-   BAND, COMPLEX, NONSYM, SYM, SVD respectively.  Look at the README
-   file for further information.  To get started, get into the SIMPLE
-   directory to see example programs that illustrate the use of ARPACK in
-   the simplest modes of operation for the most commonly posed 
-   standard eigenvalue problems.  
-
-
-   Example programs for Parallel ARPACK may be found in the directory
-   PARPACK/EXAMPLES. Look at the README file for further information.
-
-   The following instructions explain how to make the ARPACK library.
-
-4. Before you can compile anything, you must first edit and correct the file
-   ARmake.inc. Sample ARmake.inc's can be found in the ARMAKES directory.
-   If you plan on using Parallel ARPACK you will need to use those sample
-   files which contain either BLACS or MPI in their name. For example,
-   ARmake.MPI-$(PLAT) or ARmake.BLACS-$(PLAT).
-   Edit "ARmake.inc" and change the definition "home" to the root of the
-   source tree (Top level of ARPACK directory)
-
-   The makefile is set up to build a self-contained library which includes
-   the needed BLAS 1/2/3 and LAPACK routines.  If you already have the
-   BLAS and LAPACK libraries installed on your system you might want to
-   change the definition of DIRS as indicated in the ARmake.inc file. 
-
-   *** NOTE ***  The LAPACK library on your system MUST be the public release.
-   The current release is version 2.0. If you are not certain if the public 
-   release has been installed, we strongly recommend that you compile and link 
-   to the subset of LAPACK included here. 
-
-
-5. You will also need to change the file "second.f" in the UTIL directory
-   to whatever is appropriate for timing on your system.  The "second" routine
-   provided works on most workstations.  If you are running on a Cray,
-   copy the file "second.f.CRAYT3D" to "second.f"  to use the rtf system 
-   function. 
-
-
-6. Do "make lib" in the current directory to build the standard library 
-   "libarpack_$(PLAT).a" (serial code)
- 
-   To build the the parallel library, "parpack_$(COMMLIB)-$(PLAT).a",
-   type "make plib". When using the parallel routines you must link to 
-   both the serial library and the parallel library.
-
-
-7. Within DOCUMENTS directory there are three files 
-
-   ex-sym.doc 
-   ex-nonsym.doc and
-   ex-complex.doc
-
-   for templates on how to invoke the computational modes of ARPACK.
-   Also look in the README file for explanations concerning the 
-   other documents.
-
-
-   Danny Sorensen   at  sorensen@caam.rice.edu
-   Richard Lehoucq  at  rblehou@sandia.gov
-   Chao Yang        at  cyang@lbl.gov
-   Kristi Maschhoff at  kristyn@tera.com
-
- Good luck and enjoy.
-
diff --git a/libcruft/arpack/docs/README b/libcruft/arpack/docs/README
deleted file mode 100644
--- a/libcruft/arpack/docs/README
+++ /dev/null
@@ -1,18 +0,0 @@
-
-  There are five documents within the DOCUMENT subdirectory.
-  In summary,
-
-  ex-nonsym.doc, ex-sym.doc  and ex-complex.doc
-  -------------  ----------      --------------
-  Example Templates of how to invoke the different computational
-  modes offered by [D,S]NAUPD, [D,S]SAUPD and [C,Z]NAUPD.
-
-  stat.doc
-  --------
-  File that gets timing statistics for the different parts
-  of the Arnoldi update iteration codes within ARPACK. 
-
-  debug.doc
-  ---------
-  File that explains the different printing options of the
-  Arnoldi update iteration codes within ARPACK. 
diff --git a/libcruft/arpack/docs/debug.doc b/libcruft/arpack/docs/debug.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/debug.doc
+++ /dev/null
@@ -1,339 +0,0 @@
- ARPACK provides a means to trace the progress of the computation
- as it proceeds.  Various levels of output may be specified
- from no output, level = 0, to voluminous, level = 3.
- The following statements may be used within the calling program to 
- initiate and request this output.
-
-      include 'debug.h'
-      ndigit = -3
-      logfil = 6
-      msgets = 0
-      msaitr = 0
-      msapps = 0
-      msaupd = 1
-      msaup2 = 0
-      mseigt = 0
-      mseupd = 0
-
- The parameter "logfil" specifies the logical unit number of the output 
- file.  The parameter "ndigit" specifies the number of decimal digits 
- and the width of the output lines. A positive value of "ndigit"
- specifies that 132 columns are used during output and a negative 
- value specifies eighty columns are to be used. The values of the remaining 
- parameters indicate the output levels from the indicated routines.  
-
- For the above example, "msaitr" indicates the level of output requested 
- for the subroutine ssaitr or dsaitr.  The above configuration will
- give a breakdown of the number of matrix vector products required,
- the total number of iterations, the number of re-orthogonalization
- steps and an estimate of the time spent in each routine and phase of the 
- computation.  The following output is produced:   
-
----------------------------------------------------------------------
-     ==========================================
-     = Symmetric implicit Arnoldi update code =
-     = Version Number: 2.1                    =
-     = Version Date:   11/15/95               =
-     ==========================================
-     = Summary of timing statistics           =
-     ==========================================
-
-
-     Total number update iterations             =     8
-     Total number of OP*x operations            =   125
-     Total number of B*x operations             =     0
-     Total number of reorthogonalization steps  =   125
-     Total number of iterative refinement steps =     0
-     Total number of restart steps              =     0
-     Total time in user OP*x operation          =     0.020002
-     Total time in user B*x operation           =     0.000000
-     Total time in Arnoldi update routine       =     0.210021
-     Total time in ssaup2 routine               =     0.190019
-     Total time in basic Arnoldi iteration loop =     0.110011
-     Total time in reorthogonalization phase    =     0.070007
-     Total time in (re)start vector generation  =     0.000000
-     Total time in trid eigenvalue subproblem   =     0.040004
-     Total time in getting the shifts           =     0.000000
-     Total time in applying the shifts          =     0.040004
-     Total time in convergence testing          =     0.000000
-
----------------------------------------------------------------------
-
- The user is encouraged to experiment with the other settings 
- once some familiarity has been gained with the routines. 
-
- The include statement sets up the storage declarations that are
- solely associated with this trace debugging feature. "debug.h"
- has the following structure:
-
----------------------------------------------------------------------
-c
-c\SCCS Information: @(#) 
-c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-c     %---------------------------------%
-c     | See debug.doc for documentation |
-c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
----------------------------------------------------------------------
-
-
- The parameters "msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd"
- are for the symmetric codes, while 
- "mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd" are for the 
- nonsymmetric codes and, finally, 
- "mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd" are for the complex
- arithmetic codes. A comprehensive break down of each parameter is given
- below.
-
- ==========================================================
- === Common to symmetric, nonsymmetric and complex code ===
- ==========================================================
-
-
- logfil:     unit number where the logfile (debug) is written
-
- ndigit:     number of digits used in the debug output
- ndigit < 0: printing is done with  72 columns.
- ndigit > 0: printing is done with 132 columns.
-
- mgetv0 > 0: print residual vector generated.
-
-             ======================================
-             === Specific to the symmetric code ===
-             ======================================
-
- msaupd > 0: *Print the number of iterations taken, 
-              number of "converged" eigenvalues,
-              final Ritz values and corresponding Ritz estimates.
-             *Print various timing statistics.
-
- msaup2 > 0: *Print major iteration number, 
-             number of "converged" Ritz values on exit,
-             B-norm of the residual vector of length NCV factorization,
-             B-norm of the residual vector of length NEV factorization,
-             residual norm before exit,
-             Ritz values and corresponding Ritz estimates before exit.
- msaup2 > 1: print number of unreduced submatrices,
-             Ritz values and corresponding Ritz estimates of the current 
-             T matrix, actual values for NEV and NP,
-             wanted Ritz values and corresponding Ritz estimates,
-             shifts selected.
- msaup2 > 2: print "unwanted" Ritz values and corresponding Ritz
-             estimates, order NCV matrix T (diagonal and off-diagonal),
-             unwanted Ritz values and error bounds.
-
- msaitr > 0: print iteration number, residual norm, restart info
-             print if an off diagonal element of T became negative.
- msaitr > 1: print the final matrix T.
- msaitr > 2: print Arnoldi vector no. generate at iteration j,
-             b-norm of residual vector at each iteration,
-             print rnorm and rnorm1 for iterative refinement,
-             print wnorm and rnorm used for Re-orthogonalization,
-             V^T * B * (resid/B-norm(resid)),
-             print the results of whether the current residual vector is 
-             orthogonal to the current Lanczos basis.
- msaitr > 3: print the matrix T at each iteration.
-             print the residual vector and arnoldi vectors.
-
- mseigt > 0: print the current matrix T.
-
- msgets > 0: print NEV and NP,
-             eigenvalues of and corresponding Ritz estimates of the 
-             current T matrix.
-
- msapps > 0: print information about deflation at row/column no.
- msapps > 1: print initial matrix T
-             print sigmak, betak and matrix T after all shifts
- msapps > 2: print the matrix T after the application of each shift.
- msapps > 3: updated residual for next iteration.
-
- mseupd > 1: print eigenvalues of the final T matrix,
-             the last row of the eigenvector matrix for T,
-             if reordered, reordered last row of the eigenvector matrix,
-             reordered NCV Ritz values of the final T matrix,
-             if type = 'REGULAR', untransformed "converged" Ritz values 
-             and corresponding Ritz estimates,
-             NCV Ritz values of the final T matrix,
-             last row of the eigenvector matrix for T,
-             if reordered, reordered last row of the eigenvector matrix,
-             reordered NCV Ritz values of the final T.
-
- mseupd > 2: print the matrix T.
-
-              =========================================
-              === Specific to the nonsymmetric code ===
-              =========================================
-
- mnaupd > 0: *Print the number of iterations taken, 
-              number of "converged" eigenvalues,
-              real and imaginary parts of the converged Ritz values
-              and their corresponding Ritz estimates,
-             *Print various timing statistics.
-
- mnaup2 > 0: *Print major iteration number.
-             *Print the number of "converged" Ritz values on exit,
-              and the real and imaginary parts of the "converged" Ritz
-              values and corresponding Ritz estimates.
- mnaup2 > 1: *Print the length of the Arnoldi Factorization,
-              and the B-norm of its residual vector.
-             *Print NEV and NP, real and imaginary parts of the "wanted"
-              Ritz values and associated Ritz estimates at each
-              iteration.
-             *Print the B-norm of the residual of the compressed
-              factorization and the compressed upper Hessenberg matrix H.
- mnaup2 > 2: *Print the real and imaginary parts of all the Ritz values
-              and associated Ritz estimates, NEV, NP, NUMCNV, NCONV.
-             *Print the real and imaginary parts of the shifts. If the
-              exact shift strategy is used, print the associated Ritz
-              estimates of the shifts.
-             *Print the real and imaginary parts of the Ritz values
-              and the corresponding Ritz estimates obtained from _neigh.
-
- mnaitr > 0: *Print if a restart is needed.
- mnaitr > 1: *Print the number of Arnoldi vector being generated and
-              the B-norm of the current residual.
- mnaitr > 2: *Print j-th column of the Hessenberg matrix H.
-             *Print reorthogonalization and iterative refinement information,
-             *Print the final upper Hessenberg matrix of order K+NEV.
- mnaitr > 3: *Print V^T*B*resid/(B-norm(resid)).
- mnaitr > 4: *Print current upper Hessenberg matrix.
- mnaitr > 5: *Print updated arnoldi vectors and the residual vector.
-
- mneigh > 1: *Print the last row of the Schur matrix for H, and
-             the last row of the eigenvector matrix for H.
- mneigh > 2: *Print the entering upper Hessenberg matrix.
-             *Print the real and imaginary part of eigenvalues
-              of the current Hessenberg matrix, and associated 
-              Ritz estimates. 
-
- mngets > 0: *Print the real and imaginary parts of the Ritz values
-              of the Hessenberg matrix and their the corresponding 
-              error bounds, KEV, NP.
-
- mnapps > 0: *Print information about where deflation occured.
- mnapps > 1: *Print sigmak, betak, order of the final Hessenberg matrix,
-              and the final compressed upper Hessenberg matrix.
- mnapps > 2: *Print implicit application of shift number, real and imaginary 
-              part of the shift.
-             *Print the indices of the submatrix that the shift is applied.
- mnapps > 3: *Print the matrix H before and after the application of 
-              each shift, updated residual for next iteration.
- mnapps > 4: *Print the accumulated orthogonal Hessenberg matrix Q,
-              updated matrix of Arnoldi vectors.
- 
- mneupd > 0: *Print the number of converged Ritz values, B-norm of the 
-              residual, all NCV Ritz values and error bounds.
- mneupd > 1: *Print the final upper Hessenberg matrix computed by _naupd.
-             *If Ritz vectors are requested, print real and imaginary parts 
-              of the eigenvalues and the last row of the Schur vectors as 
-              computed by _neupd. 
- mneupd > 2: *If Ritz vectors are requested, print the threshold eigenvalue 
-              used for re-ordering.
-             *If Ritz vectors are requested, print the number of eigenvalues
-              to reorder and the number of converged Ritz values.
-             *If Ritz vectors are requested, print the upper quasi-matrix
-              computed by _neupd.
-             *If Ritz vectors are requested, print the real and imaginary
-              part of the Ritz values.
-             *If Ritz vectors are requested, print the last row of the 
-              eigenvector matrix.
-             *Print the NCV Ritz estimates in the original system.
- mneupd > 3: *Print the integer array of pointers.
-             *If Ritz vectors are requested, print the eigenvector matrix.
-             *If Ritz vectors are requested, print the reordered upper 
-              quasi-triangular matrix.
- mneupd > 4: *If Ritz vectors are requested, print the Q matrix of the QR 
-              factorization of the matrix representing the wanted invariant 
-              subspace. 
-             *If Ritz vectors are requested, print the Schur vectors.
-             *If Ritz vectors are requested, print the reordered Schur vectors.
-
-              
-             ====================================
-             === Specific to the complex code ===
-             ====================================
-
- mcaupd > 0: *Print the number of iterations taken, 
-              number of "converged" eigenvalues, the converged Ritz values
-              and their corresponding Ritz estimates,
-             *Print various timing statistics.
-
- mcaup2 > 0: *Print major iteration number.
-             *Print the number of "converged" Ritz values on exit, and the 
-              "converged" Ritz values and corresponding Ritz estimates.
- mcaup2 > 1: *Print the length of the Arnoldi Factorization,
-              and the B-norm of its residual vector.
-             *Print NEV and NP, the "wanted" Ritz values and associated Ritz 
-              estimates at each iteration.
-             *Print the B-norm of the residual of the compressed
-              factorization and the compressed upper Hessenberg matrix H.
- mcaup2 > 2: *Print the all the Ritz values and associated Ritz estimates, 
-              NEV, NP, NUMCNV, NCONV.
-             *Print the shifts. If the exact shift strategy is used, print the 
-              associated Ritz estimates of the shifts.
-             *Print the Ritz values and the corresponding Ritz estimates obtained 
-              from _neigh.
-
- mcaitr > 0: *Print if a restart is needed.
- mcaitr > 1: *Print the number of Arnoldi vector being generated and
-              the B-norm of the current residual.
- mcaitr > 2: *Print j-th column of the Hessenberg matrix H.
-             *Print reorthogonalization and iterative refinement information,
-             *Print the final upper Hessenberg matrix of order K+NEV.
- mcaitr > 3: *Print V^T*B*resid/(B-norm(resid)).
- mcaitr > 4: *Print current upper Hessenberg matrix.
- mcaitr > 5: *Print updated Arnoldi vectors and the residual vector.
-
- mceigh > 1: *Print the last row of the Schur matrix for H, and
-             the last row of the eigenvector matrix for H.
- mceigh > 2: *Print the entering upper Hessenberg matrix.
-             *Print the eigenvalues of the current Hessenberg matrix, and 
-              associated Ritz estimates. 
-
- mcgets > 0: *Print the real and imaginary parts of the Ritz values
-              of the Hessenberg matrix and their the corresponding 
-              error bounds, KEV, NP.
-
- mcapps > 0: *Print information about where deflation occured.
- mcapps > 1: *Print sigmak, betak, order of the final Hessenberg matrix,
-              and the final compressed upper Hessenberg matrix.
- mcapps > 2: *Print implicit application of shift number, the shift.
-             *Print the indices of the submatrix that the shift is applied.
- mcapps > 3: *Print the matrix H before and after the application of 
-              each shift, updated residual for next iteration.
- mcapps > 4: *Print the accumulated unitary Hessenberg matrix Q, and the
-              updated matrix of Arnoldi vectors.
- 
- mceupd > 0: *Print the number of converged Ritz values, B-norm of the 
-              residual, all NCV Ritz values and error bounds.
- mceupd > 1: *Print the final upper Hessenberg matrix computed by _naupd.
-             *If Ritz vectors are requested, print the eigenvalues and the 
-              last row of the Schur vectors as computed by _neupd. 
- mceupd > 2: *If Ritz vectors are requested, print the threshold eigenvalue 
-              used for re-ordering.
-             *If Ritz vectors are requested, print the number of eigenvalues
-              to reorder and the number of converged Ritz values.
-             *If Ritz vectors are requested, print the upper quasi-matrix
-              computed by _neupd.
-             *If Ritz vectors are requested, print the Ritz values.
-             *If Ritz vectors are requested, print the last row of the 
-              eigenvector matrix.
-             *Print the NCV Ritz estimates in the original system.
- mceupd > 3: *Print the integer array of pointers.
-             *If Ritz vectors are requested, print the eigenvector matrix.
- mceupd > 4: *If Ritz vectors are requested, print the Q matrix of the QR 
-              factorization of the matrix representing the wanted invariant 
-              subspace. 
-             *If Ritz vectors are requested, print the Schur vectors.
-
-
-
diff --git a/libcruft/arpack/docs/ex-complex.doc b/libcruft/arpack/docs/ex-complex.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/ex-complex.doc
+++ /dev/null
@@ -1,152 +0,0 @@
-c-----------------------------------------------------------------------
-c        
-c\Example-1
-c     ... Suppose want to solve A*x = lambda*x in regular mode
-c     ... so OP = A  and  B = I.
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 1
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end 
-c
-c\Example-2
-c     ... Suppose want to solve A*x = lambda*x in shift-invert mode
-c     ... so OP = inv[A - sigma*I] and B = I
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*I]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iaparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call solve (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end 
-c
-c\Example-3
-c     ... Suppose want to solve A*x = lambda*M*x in regular mode
-c     ... so OP = inv[M]*A  and  B = M.
-c     ... Assume "call matvecM(n,x,y)"  computes y = M*x
-c     ... Assume "call matvecA(n,x,y)"  computes y = A*x
-c     ... Assume "call solveM(n,rhs,x)" solves   M*x = rhs
-c     ... Assume user will supplied shifts
-c     ...
-c     ido = 0
-c     iparam(7) = 2
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call solveM  (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c
-c     ... delete this last conditional if want to use exact shifts
-c     else if (ido .eq. 3) then
-c        ... compute shifts and put in workl starting from the position
-c        ... pointed by ipntr(14).
-c        np = iparam(8)
-c        call scopy (np, shifts, 1, workl(ipntr(14), 1)
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end
-c
-c\Example-4
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... so OP = inv[A - sigma*M]*M and B = M
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if 
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end 
-c\EndDoc
diff --git a/libcruft/arpack/docs/ex-nonsym.doc b/libcruft/arpack/docs/ex-nonsym.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/ex-nonsym.doc
+++ /dev/null
@@ -1,256 +0,0 @@
-c-----------------------------------------------------------------------
-c        
-c\Example-1
-c     ... Suppose want to solve A*x = lambda*x in regular mode
-c     ... so OP = A  and  B = I.
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 1
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end 
-c
-c\Example-2
-c     ... Suppose want to solve A*x = lambda*x in shift-invert mode
-c     ... so OP = inv[A - sigma*I] and B = I, sigma has zero 
-c     ... imaginary part
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*I]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iaparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call solve (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end 
-c
-c\Example-3
-c     ... Suppose want to solve A*x = lambda*M*x in regular mode
-c     ... so OP = inv[M]*A  and  B = M.
-c     ... Assume "call matvecM(n,x,y)"  computes y = M*x
-c     ... Assume "call matvecA(n,x,y)"  computes y = A*x
-c     ... Assume "call solveM(n,rhs,x)" solves   M*x = rhs
-c     ... Assume user will supplied shifts
-c     ...
-c     ido = 0
-c     iparam(7) = 2
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call solveM  (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c
-c     ... delete this last conditional if want to use exact shifts
-c     else if (ido .eq. 3) then
-c        ... compute shifts and put in workl starting from the position
-c        ... pointed by ipntr(14).
-c        np = iparam(8)
-c        call scopy (np, shifts, 1, workl(ipntr(14), 1)
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end
-c
-c\Example-4
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... so OP = inv[A - sigma*M]*M and B = M, sigma has zero 
-c     ... imaginary part
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if 
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end 
-c
-c\Example-5
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... So OP = Real_Part{inv[A-SIGMA*M]*M and B=M, sigma has 
-c     ... nonzero imaginary part
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... in complex  arithmetic
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve(n, temp_array, complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = real(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = real(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess.
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     ... Use Rayleigh quotient to transform d(:,1) and d(:,2)
-c         to the approximation to the original problem.
-c     stop
-c     end 
-c
-c\Example-6
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... So OP = Imaginary_Part{inv[A-SIGMA*M]*M and B=M, sigma must
-c     ... have nonzero imaginary part
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... in complex  arithmetic
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve(n, temp_array, complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = aimag(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = aimag(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     ... Use Rayleigh quotient to transform d(:,1) and d(:,2)
-c         to the Ritz approximation to the original problem.
-c     stop
-c     end
-c        
-c\EndDoc
-
diff --git a/libcruft/arpack/docs/ex-sym.doc b/libcruft/arpack/docs/ex-sym.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/ex-sym.doc
+++ /dev/null
@@ -1,234 +0,0 @@
-c-----------------------------------------------------------------------
-c        
-c\Example-1
-c     ... Suppose want to solve A*x = lambda*x in regular mode
-c     ... so OP = A  and  B = I.
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 1
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if 
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... Call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c
-c     stop
-c     end
-c
-c\Example-2
-c     ... Suppose want to solve A*x = lambda*x in shift-invert mode
-c     ... so OP = inv[A - sigma*I]  and  B = I.
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*I]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call solve (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... Call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c
-c\Example-3
-c     ... Suppose want to solve A*x = lambda*M*x in regular mode
-c     ... so OP = inv[M]*A  and  B = M.
-c     ... Assume "call matvecM(n,x,y)"  computes y = M*x
-c     ... Assume "call matvecA(n,x,y)"  computes y = A*x
-c     ... Assume "call solveM(n,rhs,x)" solves   M*x = rhs
-c     ... Assume user will supplied shifts
-c     ...
-c     ido = 0
-c     iparam(7) = 2
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call _scopy (n, temp_array, 1, workd(ipntr(1)), 1)
-c        call solveM  (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c
-c     ... delete this last conditional if want to use exact shifts
-c     else if (ido .eq. 3) then
-c        ... compute shifts and put in the first np locations of work
-c        np = iparam(8)
-c        call _copy (np, shifts, 1, workl(ipntr(11), 1)
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess 
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c     stop
-c     end
-c
-c\Example-4
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... so OP = (inv[A - sigma*M])*M  and  B = M.
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10  
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c
-c     stop
-c     end 
-c        
-c\Example-5
-c     ... Suppose want to solve K*x = lambda*KG*x in Buckling mode
-c     ... so OP = (inv[K - sigma*KG])*K  and  B = K.
-c     ... Assume "call matvecM(n,x,y)" computes y = KG*x
-c     ... Assume "call matvecA(n,x,y)" computes y = K*x
-c     ... Assume "call solve(n,rhs,x)" solves [K - sigma*KG]*x = rhs
-c     ... Assume exact shifts are used
-c
-c     ido = 0
-c     iparam(7) = 4
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess 
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     stop
-c     end
-c
-c\Example-6
-c     ... Suppose want to solve A*x = lambda*M*x in Cayley mode
-c     ... so OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 5
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call _axpy (n, sigma, workd(inptr(2)), 1, temp_array, 1)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        call _axpy (n, sigma, workd(inptr(3)), 1, workd(ipntr(2)), 1)
-c        call _copy (n, workd(inptr(2)), 1, workd(ipntr(3)), 1)
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c     stop
-c     end 
-c\EndDoc
-c
diff --git a/libcruft/arpack/docs/stat.doc b/libcruft/arpack/docs/stat.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/stat.doc
+++ /dev/null
@@ -1,80 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c  Include this file to get timing statistics for the different parts
-c  of the Arnoldi update iteration.  An easy way to initialize all the
-c  timing information to zero at the beginning is by:
-c
-c     call sstats  <-- symmetric code
-c     call sstatn  <-- nonsymmetric code
-c     call cstatn  <-- complex code
-c
-c-----------------------------------------------------------------------
-c
-c  nopx   = total number of user OP*x operation
-c  nbx    = total number of user B*x operation (same as copy when B = I)
-c  nrorth = total number of reorthogonalization steps taken
-c  nitref = total number of it. refinement steps in reorthogonalization
-c  nrstrt = total number of restart steps
-c
-c-----------------------------------------------------------------------
-c
-c========================================================
-c===  Common to both symmetric and nonsymmetric code  ===
-c========================================================
-c
-c  tgetv0 = total time spent in generating starting vector and 
-c           restarted vector for the Arnoldi sequence.
-c  titref = total time spent in iterative refinement phase in SSAITR.
-c  trvec  = total time spent in computing the Ritz vectors before exit.
-c
-c====================================
-c===  Specific to symmetric code  ===
-c====================================
-c
-c  tsaupd = total time spent in SSAUPD.
-c  tsaup2 = total time spent in SSAUP2.
-c  tsaitr = total time spent in the basic Arnoldi iteration loop,
-c           including iterative refinement in SSAITR.
-c  tseigt = total time spent in computing the tridiagonal eigenvalue
-c           subproblem at each iteration.
-c  tsgets = total time spent in getting the shifts at each iteration.
-c  tsapps = total time spent in applying the shifts at each iteration.
-c  tsconv = total time spent in convergence test at each iteration.
-c
-c=======================================
-c===  Specific to nonsymmetric code  ===
-c=======================================
-c
-c  tnaupd = total time spent in SNAUPD.
-c  tnaup2 = total time spent in SNAUP2.
-c  tnaitr = total time spent in the basic Arnoldi iteration loop,
-c           including iterative refinement in SNAITR.
-c  tneigh = total time spent in computing the Hessenberg eigenvalue
-c           subproblem at each iteration.
-c  tngets = total time spent in getting the shifts at each iteration.
-c  tnapps = total time spent in applying the shifts at each iteration.
-c  tnconv = total time spent in convergence test at each iteration.
-c
-c==================================
-c===  Specific to complex code  ===
-c==================================
-c
-c  tcaupd = total time spent in CNAUPD.
-c  tcaup2 = total time spent in CNAUP2.
-c  tcaitr = total time spent in the basic Arnoldi iteration loop,
-c           including iterative refinement in CNAITR.
-c  tceigh = total time spent in computing the Hessenberg eigenvalue
-c           subproblem at each iteration.
-c  tcgets = total time spent in getting the shifts at each iteration.
-c  tcapps = total time spent in applying the shifts at each iteration.
-c  tcconv = total time spent in convergence test at each iteration.
-c
-c==================
-c=== User time  ===
-c==================
-c
-c  tmvopx = total time spent in computing Y = OP * X
-c  tmvbx  = total time spent in computing Y = B * X
-c
-c=======================================================================
-c
diff --git a/libcruft/arpack/module.mk b/libcruft/arpack/module.mk
deleted file mode 100644
--- a/libcruft/arpack/module.mk
+++ /dev/null
@@ -1,97 +0,0 @@
-EXTRA_DIST += \
-  arpack/LICENSE \
-  arpack/README \
-  arpack/docs/README \
-  arpack/docs/debug.doc \
-  arpack/docs/ex-complex.doc \
-  arpack/docs/ex-nonsym.doc \
-  arpack/docs/ex-sym.doc \
-  arpack/docs/stat.doc \
-  arpack/module.mk \
-  arpack/src/debug.h \
-  arpack/src/stat.h \
-  arpack/src/version.h
-
-libcruft_la_SOURCES += \
-  arpack/src/cgetv0.f \
-  arpack/src/cnaitr.f \
-  arpack/src/cnapps.f \
-  arpack/src/cnaup2.f \
-  arpack/src/cnaupd.f \
-  arpack/src/cneigh.f \
-  arpack/src/cneupd.f \
-  arpack/src/cngets.f \
-  arpack/src/csortc.f \
-  arpack/src/cstatn.f \
-  arpack/src/dgetv0.f \
-  arpack/src/dlaqrb.f \
-  arpack/src/dnaitr.f \
-  arpack/src/dnapps.f \
-  arpack/src/dnaup2.f \
-  arpack/src/dnaupd.f \
-  arpack/src/dnconv.f \
-  arpack/src/dneigh.f \
-  arpack/src/dneupd.f \
-  arpack/src/dngets.f \
-  arpack/src/dsaitr.f \
-  arpack/src/dsapps.f \
-  arpack/src/dsaup2.f \
-  arpack/src/dsaupd.f \
-  arpack/src/dsconv.f \
-  arpack/src/dseigt.f \
-  arpack/src/dsesrt.f \
-  arpack/src/dseupd.f \
-  arpack/src/dsgets.f \
-  arpack/src/dsortc.f \
-  arpack/src/dsortr.f \
-  arpack/src/dstatn.f \
-  arpack/src/dstats.f \
-  arpack/src/dstqrb.f \
-  arpack/src/sgetv0.f \
-  arpack/src/slaqrb.f \
-  arpack/src/snaitr.f \
-  arpack/src/snapps.f \
-  arpack/src/snaup2.f \
-  arpack/src/snaupd.f \
-  arpack/src/snconv.f \
-  arpack/src/sneigh.f \
-  arpack/src/sneupd.f \
-  arpack/src/sngets.f \
-  arpack/src/ssaitr.f \
-  arpack/src/ssapps.f \
-  arpack/src/ssaup2.f \
-  arpack/src/ssaupd.f \
-  arpack/src/ssconv.f \
-  arpack/src/sseigt.f \
-  arpack/src/ssesrt.f \
-  arpack/src/sseupd.f \
-  arpack/src/ssgets.f \
-  arpack/src/ssortc.f \
-  arpack/src/ssortr.f \
-  arpack/src/sstatn.f \
-  arpack/src/sstats.f \
-  arpack/src/sstqrb.f \
-  arpack/src/zgetv0.f \
-  arpack/src/znaitr.f \
-  arpack/src/znapps.f \
-  arpack/src/znaup2.f \
-  arpack/src/znaupd.f \
-  arpack/src/zneigh.f \
-  arpack/src/zneupd.f \
-  arpack/src/zngets.f \
-  arpack/src/zsortc.f \
-  arpack/src/zstatn.f \
-  arpack/util/cmout.f \
-  arpack/util/cvout.f \
-  arpack/util/dmout.f \
-  arpack/util/dvout.f \
-  arpack/util/icnteq.f \
-  arpack/util/icopy.f \
-  arpack/util/iset.f \
-  arpack/util/iswap.f \
-  arpack/util/ivout.f \
-  arpack/util/second.f \
-  arpack/util/smout.f \
-  arpack/util/svout.f \
-  arpack/util/zmout.f \
-  arpack/util/zvout.f
diff --git a/libcruft/arpack/src/cgetv0.f b/libcruft/arpack/src/cgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/cgetv0.f
+++ /dev/null
@@ -1,414 +0,0 @@
-c\BeginDoc
-c
-c\Name: cgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call cgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to cgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that cgetv0 is called.  
-c          It should be set to 1 on the initial call to cgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Complex N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Real scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Complex work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     cvout   ARPACK utility routine that prints vectors.
-c     clarnv  LAPACK routine for generating a random vector. 
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.3   DATE OF SID: 08/27/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &            rzero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Real
-     &           rnorm0
-      Complex
-     &           cnorm
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy, cgemv, clarnv, cvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           scnrm2, slapy2
-      Complex
-     &           cdotc
-      external   cdotc, scnrm2, slapy2
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call clarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call ccopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %----------------------------------------%
-c     | Back from computing B*(initial-vector) |
-c     %----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      call arscnd (t3)
-      tmvopx = tmvopx + (t3 - t2)
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call ccopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call ccopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          cnorm  = cdotc (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(slapy2(real(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-           rnorm0 = scnrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call cgemv ('C', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call cgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call ccopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call ccopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         cnorm = cdotc (n, resid, 1, workd, 1)
-         rnorm = sqrt(slapy2(real(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-         rnorm = scnrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call svout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 1) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = rzero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 2) then
-         call cvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cnaitr.f b/libcruft/arpack/src/cnaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnaitr.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in cnaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call cnaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See cnaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Complex N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Complex (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     cgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     clanhs  LAPACK routine that computes various norms of a matrix.
-c     clascl  LAPACK routine for careful scaling of a matrix.
-c     slabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     caxpy   Level 1 BLAS that computes a vector triad.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors. 
-c     cscal   Level 1 BLAS that scales a vector.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number. 
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.3   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in cnaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rone, rzero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0), 
-     &           rone = 1.0E+0, rzero = 0.0E+0)
-c
-c     %--------------%
-c     | Local Arrays |
-c     %--------------%
-c
-      Real
-     &           rtemp(2)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Real            
-     &           ovfl, smlnum, tst1, ulp, unfl, betaj,
-     &           temp1, rnorm1, wnorm
-      Complex
-     &           cnorm
-c
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   caxpy, ccopy, cscal, csscal, cgemv, cgetv0, 
-     &           slabad, cvout, cmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Complex
-     &           cdotc 
-      Real            
-     &           slamch,  scnrm2, clanhs, slapy2
-      external   cdotc, scnrm2, clanhs, slamch, slapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, real, max, sqrt 
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine clahqr     |
-c        %-----------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = real(one / unfl)
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mcaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         cgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determine whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. rzero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = rzero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call cgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tcaitr = tcaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call ccopy (n, resid, 1, v(1,j), 1)
-         if ( rnorm .ge. unfl) then
-             temp1 = rone / rnorm
-             call csscal (n, temp1, v(1,j), 1)
-             call csscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine clascl               |
-c            %-----------------------------------------%
-c
-             call clascl ('General', i, i, rnorm, rone,
-     &                    n, 1, v(1,j), n, infol)
-             call clascl ('General', i, i, rnorm, rone,  
-     &                    n, 1, workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call ccopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call ccopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             cnorm = cdotc (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             wnorm = scnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call cgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call cgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = cmplx(betaj, rzero)
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            cnorm = cdotc (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-            rnorm = scnrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if ( rnorm .gt. 0.717*wnorm ) go to 100
-c
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            rtemp(1) = wnorm
-            rtemp(2) = rnorm
-            call svout (logfil, 2, rtemp, ndigit, 
-     &      '_naitr: re-orthogonalization; wnorm and rnorm are')
-            call cvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call cgemv ('C', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call cgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call caxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             cnorm  = cdotc (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             rnorm1 = scnrm2(n, resid, 1)
-         end if
-c 
-         if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                rtemp(1) = rnorm
-                rtemp(2) = rnorm1
-                call svout (logfil, 2, rtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if ( rnorm1 .gt. 0.717*rnorm ) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue 
-            rnorm = rzero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tcaitr = tcaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine clahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = slapy2(real(h(i,i)),aimag(h(i,i)))
-     &              + slapy2(real(h(i+1,i+1)), aimag(h(i+1,i+1)))
-               if( tst1.eq.real(zero) )
-     &              tst1 = clanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( slapy2(real(h(i+1,i)),aimag(h(i+1,i))) .le. 
-     &                    max( ulp*tst1, smlnum ) ) 
-     &             h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call cmout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cnaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cnapps.f b/libcruft/arpack/src/cnapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnapps.f
+++ /dev/null
@@ -1,507 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call cnapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW. 
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Complex array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Complex N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenberg matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Complex KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Complex work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     clacpy  LAPACK matrix copy routine.
-c     clanhs  LAPACK routine that computes various norms of a matrix.
-c     clartg  LAPACK Givens rotation construction routine.
-c     claset  LAPACK matrix initialization routine.
-c     slabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     caxpy   Level 1 BLAS that computes a vector triad.
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     cscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.3   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine clahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     Upon output, the subdiagonals of H are enforced to be non-negative
-c     real numbers.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           h(ldh,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rzero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, istart, j, jj, kplusp, msglvl
-      logical    first
-      Complex
-     &           cdum, f, g, h11, h21, r, s, sigma, t
-      Real             
-     &           c,  ovfl, smlnum, ulp, unfl, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   caxpy, ccopy, cgemv, cscal, clacpy, clartg, 
-     &           cvout, claset, slabad, cmout, arscnd, ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real                 
-     &           clanhs, slamch, slapy2
-      external   clanhs, slamch, slapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, aimag, conjg, cmplx, max, min, real
-c
-c     %---------------------%
-c     | Statement Functions |
-c     %---------------------%
-c
-      Real     
-     &           cabs1
-      cabs1( cdum ) = abs( real( cdum ) ) + abs( aimag( cdum ) )
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine clahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = real(one / unfl)
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcapps
-c 
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call claset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      do 110 jj = 1, np
-         sigma = shift(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call cvout (logfil, 1, sigma, ndigit, 
-     &               '_napps: Value of the shift ')
-         end if
-c
-         istart = 1
-   20    continue
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine clahqr    |
-c           %----------------------------------------%
-c
-            tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
-            if( tst1.eq.rzero )
-     &         tst1 = clanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if ( abs(real(h(i+1,i))) 
-     &           .le. max(ulp*tst1, smlnum) )  then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call cvout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        | or if the current block starts after the point |
-c        | of compression since we'll discard this stuff  |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend .or. istart .gt. kev) go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         f = h11 - sigma
-         g = h21
-c 
-         do 80 i = istart, iend-1
-c
-c           %------------------------------------------------------%
-c           | Construct the plane rotation G to zero out the bulge |
-c           %------------------------------------------------------%
-c
-            call clartg (f, g, c, s, r)
-            if (i .gt. istart) then
-               h(i,i-1) = r
-               h(i+1,i-1) = zero
-            end if
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the left of H;  H <- G'*H |
-c           %---------------------------------------------%
-c
-            do 50 j = i, kplusp
-               t        =  c*h(i,j) + s*h(i+1,j)
-               h(i+1,j) = -conjg(s)*h(i,j) + c*h(i+1,j)
-               h(i,j)   = t   
-   50       continue
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the right of H;  H <- H*G |
-c           %---------------------------------------------%
-c
-            do 60 j = 1, min(i+2,iend)
-               t        =  c*h(j,i) + conjg(s)*h(j,i+1)
-               h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-               h(j,i)   = t   
-   60       continue
-c
-c           %-----------------------------------------------------%
-c           | Accumulate the rotation in the matrix Q;  Q <- Q*G' |
-c           %-----------------------------------------------------%
-c
-            do 70 j = 1, min(i+jj, kplusp)
-               t        =   c*q(j,i) + conjg(s)*q(j,i+1)
-               q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-               q(j,i)   = t   
-   70       continue
-c
-c           %---------------------------%
-c           | Prepare for next rotation |
-c           %---------------------------%
-c
-            if (i .lt. iend-1) then
-               f = h(i+1,i)
-               g = h(i+2,i)
-            end if
-   80    continue
-c
-c        %-------------------------------%
-c        | Finished applying the shift.  |
-c        %-------------------------------%
-c 
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %---------------------------------------------------%
-c     | Perform a similarity transformation that makes    |
-c     | sure that the compressed H will have non-negative |
-c     | real subdiagonal elements.                        |
-c     %---------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( real( h(j+1,j) ) .lt. rzero .or.
-     &        aimag( h(j+1,j) ) .ne. rzero ) then
-            t = h(j+1,j) / slapy2(real(h(j+1,j)),aimag(h(j+1,j)))
-            call cscal( kplusp-j+1, conjg(t), h(j+1,j), ldh )
-            call cscal( min(j+2, kplusp), t, h(1,j+1), 1 )
-            call cscal( min(j+np+1,kplusp), t, q(1,j+1), 1 )
-            h(j+1,j) = cmplx( real( h(j+1,j) ), rzero )
-         end if
-  120 continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine clahqr.       |
-c        | Note: Since the subdiagonals of the        |
-c        | compressed H are nonnegative real numbers, |
-c        | we take advantage of this.                 |
-c        %--------------------------------------------%
-c
-         tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
-         if( tst1 .eq. rzero )
-     &       tst1 = clanhs( '1', kev, h, ldh, workl )
-         if( real( h( i+1,i ) ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call cgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call cgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call ccopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call clacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call ccopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call cscal (n, q(kplusp,kev), resid, 1)
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call caxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call cvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call cvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call cmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tcapps = tcapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of cnapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cnaup2.f b/libcruft/arpack/src/cnaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnaup2.f
+++ /dev/null
@@ -1,801 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaup2
-c
-c\Description: 
-c  Intermediate level interface called by cnaupd.
-c
-c\Usage:
-c  call cnaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, 
-c       Q, LDQ, WORKL, IPNTR, WORKD, RWORK, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in cnaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in cnaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Complex  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV 
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Complex  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  RITZ    Complex  array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV)  contains the computed Ritz values of OP.
-c
-c  BOUNDS  Complex  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to 
-c          the computed Ritz values.
-c          
-c  Q       Complex  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex  work array of length at least 
-c          (NEV+NP)**2 + 3*(NEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in CNAUPD.
-c
-c  RWORK   Real    work array of length  NEV+NP ( WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.  
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex 
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     cgetv0  ARPACK initial vector generation routine. 
-c     cnaitr  ARPACK Arnoldi factorization routine.
-c     cnapps  ARPACK application of implicit shifts routine.
-c     cneigh  ARPACK compute Ritz values and error bounds routine. 
-c     cngets  ARPACK reorder Ritz values and error bounds routine.
-c     csortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors. 
-c     cswap   Level 1 BLAS that swaps two vectors.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice Universitya
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.6   DATE OF SID: 06/01/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd, 
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds, 
-     &     q, ldq, workl, ipntr, workd, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Real   
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Complex 
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), 
-     &           resid(n), ritz(nev+np),  v(ldv,nev+np), 
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-       Real   
-     &           rwork(nev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex 
-     &           one, zero
-      Real 
-     &           rzero
-      parameter (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) ,
-     &           rzero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    cnorm , getv0, initv , update, ushift
-      integer    ierr  , iter , kplusp, msglvl, nconv, 
-     &           nevbef, nev0 , np0   , nptemp, i    ,
-     &           j    
-      Complex 
-     &           cmpnorm
-      Real 
-     &           rnorm , eps23, rtemp
-      character  wprime*2
-c
-      save       cnorm,  getv0, initv , update, ushift, 
-     &           rnorm,  iter , kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0   , eps23
-c
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(3)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy, cgetv0, cnaitr, cneigh, cngets, cnapps,
-     &           csortc, cswap, cmout, cvout, ivout, arscnd
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Complex 
-     &           cdotc
-      Real   
-     &           scnrm2, slamch, slapy2
-      external   cdotc, scnrm2, slamch, slapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, real , min, max
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c 
-         call arscnd (t0)
-c 
-         msglvl = mcaup2
-c 
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvalues.     |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c 
-c        %---------------------------------%
-c        | Get machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c 
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call cgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. rzero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. | 
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c 
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c 
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call cnaitr (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv, 
-     &             h, ldh, ipntr, workd, info)
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c 
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit, 
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine cnapps.                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit, 
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit, 
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call cnaitr(ido, bmat, n, nev, np,    mode,  resid, rnorm,
-     &               v  , ldv , h, ldh, ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c 
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call cneigh (rnorm, kplusp, h, ldh, ritz, bounds,
-     &                q, ldq, workl, rwork,  ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZ,    |
-c        | and BOUNDS respectively.                          | 
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-c
-c        %--------------------------------------------------%
-c        | Make a copy of Ritz values and the corresponding |
-c        | Ritz estimates obtained from cneigh.             |
-c        %--------------------------------------------------%
-c
-         call ccopy(kplusp,ritz,1,workl(kplusp**2+1),1)
-         call ccopy(kplusp,bounds,1,workl(kplusp**2+kplusp+1),1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | bounds are in the last NEV loc. of RITZ           |
-c        | BOUNDS respectively.                              |
-c        %---------------------------------------------------%
-c
-         call cngets (ishift, which, nev, np, ritz, bounds)
-c 
-c        %------------------------------------------------------------%
-c        | Convergence test: currently we use the following criteria. |
-c        | The relative accuracy of a Ritz value is considered        |
-c        | acceptable if:                                             |
-c        |                                                            |
-c        | error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)). |
-c        |                                                            |
-c        %------------------------------------------------------------%
-c
-         nconv  = 0
-c
-         do 25 i = 1, nev
-            rtemp = max( eps23, slapy2( real (ritz(np+i)),
-     &                                  aimag(ritz(np+i)) ) ) 
-            if ( slapy2(real (bounds(np+i)),aimag(bounds(np+i))) 
-     &                 .le. tol*rtemp ) then
-               nconv = nconv + 1
-            end if
-   25    continue
-c 
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit, 
-     &                  '_naup2: NEV, NP, NCONV are')
-            call cvout (logfil, kplusp, ritz, ndigit,
-     &           '_naup2: The eigenvalues of H')
-            call cvout (logfil, kplusp, bounds, ndigit, 
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c     
-         if ( (nconv .ge. nev0) .or. 
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call cvout(logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Eigenvalues computed by _neigh:')
-               call cvout(logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Ritz estimates computed by _neigh:')
-            end if
-c     
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to cneupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = cmplx(rnorm,rzero)
-c
-c           %----------------------------------------------%
-c           | Sort Ritz values so that converged Ritz      |
-c           | values appear within the first NEV locations |
-c           | of ritz and bounds, and the most desired one |
-c           | appears at the front.                        |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call csortc(wprime, .true., kplusp, ritz, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23, magnitude of the Ritz value).  |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0 
-                rtemp = max( eps23, slapy2( real (ritz(j)),
-     &                                       aimag(ritz(j)) ) )
-                bounds(j) = bounds(j)/rtemp
- 35         continue
-c
-c           %---------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz |
-c           | estimates.  This will push all the converged ones |
-c           | towards the front of ritz, bounds (in the case    |
-c           | when NCONV < NEV.)                                |
-c           %---------------------------------------------------%
-c
-            wprime = 'LM'
-            call csortc(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                rtemp = max( eps23, slapy2( real (ritz(j)),
-     &                                       aimag(ritz(j)) ) )
-                bounds(j) = bounds(j)*rtemp
- 40         continue
-c
-c           %-----------------------------------------------%
-c           | Sort the converged Ritz values again so that  |
-c           | the "threshold" value appears at the front of |
-c           | ritz and bound.                               |
-c           %-----------------------------------------------%
-c
-            call csortc(which, .true., nconv, ritz, bounds)
-c
-            if (msglvl .gt. 1) then
-               call cvout (logfil, kplusp, ritz, ndigit,
-     &            '_naup2: Sorted eigenvalues')
-               call cvout (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. | 
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev0) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. | 
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0)  info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. nev0) .and. (ishift .eq. 1) ) then
-c     
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c     
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c     
-            if (nevbef .lt. nev) 
-     &         call cngets (ishift, which, nev, np, ritz, bounds)
-c
-         end if              
-c     
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit, 
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit, 
-     &              '_naup2: NEV and NP are')
-               call cvout (logfil, nev, ritz(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values ')
-               call cvout (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: pop back out to get the shifts |
-c           | and return them in the first 2*NP locations of WORKL. |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-   50    continue
-         ushift = .false.
-c
-         if ( ishift .ne. 1 ) then
-c 
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZ, to free up WORKL           |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call ccopy (np, workl, 1, ritz, 1)
-         end if
-c
-         if (msglvl .gt. 2) then 
-            call ivout (logfil, 1, np, ndigit, 
-     &                  '_naup2: The number of shifts to apply ')
-            call cvout (logfil, np, ritz, ndigit,
-     &                  '_naup2: values of the shifts')
-            if ( ishift .eq. 1 ) 
-     &          call cvout (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call cnapps (n, nev, np, ritz, v, ldv, 
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to cnaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd, 1)
-         end if
-c 
-  100    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         if (bmat .eq. 'G') then         
-            cmpnorm = cdotc (n, resid, 1, workd, 1)
-            rnorm = sqrt(slapy2(real (cmpnorm),aimag(cmpnorm)))
-         else if (bmat .eq. 'I') then
-            rnorm = scnrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call cmout (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c 
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c     
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tcaup2 = t1 - t0
-c     
- 9000 continue
-c
-c     %---------------%
-c     | End of cnaup2 |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/cnaupd.f b/libcruft/arpack/src/cnaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnaupd.f
+++ /dev/null
@@ -1,664 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaupd
-c
-c\Description: 
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This is intended to be used to find a few eigenpairs of a 
-c  complex linear operator OP with respect to a semi-inner product defined 
-c  by a hermitian positive semi-definite real matrix B. B may be the identity 
-c  matrix.  NOTE: if both OP and B are real, then ssaupd or snaupd should
-c  be used.
-c
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  cnaupd is usually called iteratively to solve one of the 
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M hermitian positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M hermitian semi-definite
-c           ===> OP =  inv[A - sigma*M]*M   and  B = M. 
-c           ===> shift-and-invert mode 
-c           If OP*x = amu*x, then lambda = sigma + 1/amu.
-c  
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call cnaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first 
-c          call to cnaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          cnaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = M * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute and return the shifts in the first 
-c                    NP locations of WORKL.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          After the initialization phase, when the routine is used in 
-c          the "shift-and-invert" mode, the vector M * X is already 
-c          available and does not need to be recomputed in forming OP*X.
-c             
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Real   scalar.  (INPUT)
-c          Stopping criteria: the relative accuracy of the Ritz value 
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = slamch('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine slamch).
-c
-c  RESID   Complex  array of length N.  (INPUT/OUTPUT)
-c          On INPUT: 
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 1 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated 
-c          at each iteration.  After the startup phase in which NEV 
-c          Arnoldi vectors are generated, the algorithm generates 
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update 
-c          iteration. Most of the cost in generating each Arnoldi vector is 
-c          in the matrix-vector operation OP*x. (See remark 4 below.)
-c
-c  V       Complex  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors. 
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to filter out
-c          the components of the unwanted eigenvector.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are to be provided by the user via
-c                      reverse communication.  The NCV eigenvalues of 
-c                      the Hessenberg matrix H are returned in the part
-c                      of WORKL array corresponding to RITZ.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to 
-c                      restarting the iteration from the beginning 
-c                      after updating the starting vector with a linear
-c                      combination of Ritz vectors associated with the 
-c                      "wanted" eigenvalues.
-c          ISHIFT = 2: other choice of internal shift to be defined.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced 
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed. 
-c          On OUTPUT: actual number of Arnoldi update iterations taken. 
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.  
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3; See under \Description of cnaupd for the 
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), _naupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP < NCV-NEV.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in 
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg
-c                    matrix H in WORKL.
-c          IPNTR(6): pointer to the  ritz value array  RITZ
-c          IPNTR(7): pointer to the (projected) ritz vector array Q
-c          IPNTR(8): pointer to the error BOUNDS array in WORKL.
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by cneupd. See Remark 2 below.
-c
-c          IPNTR(9): pointer to the NCV RITZ values of the 
-c                    original system.
-c          IPNTR(10): Not Used
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     cneupd if RVEC = .TRUE. See Remark 2 below.
-c
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD 
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note below.  
-c
-c  WORKL   Complex  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 5*NCV.
-c
-c  RWORK   Real   work array of length NCV (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)  
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the 
-c                Implicitly restarted Arnoldi iteration. One possibility 
-c                is to increase the size of NCV relative to NEV. 
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration 
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   User input error highly likely.  Please
-c                   check actual array dimensions and layout.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when using
-c     Mode = 3.  When operating in Mode = 3 setting WHICH = 'LM' will
-c     compute the NEV eigenvalues of the original problem that are
-c     closest to the shift SIGMA . After convergence, approximate eigenvalues 
-c     of the original problem may be obtained with the ARPACK subroutine cneupd.
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz 
-c     values is needed, the user must call cneupd immediately following 
-c     completion of cnaupd. This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 1.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will 
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically. 
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) complex shifts in locations
-c     WORKL(IPNTR(14)), WORKL(IPNTR(14)+1), ... , WORKL(IPNTR(14)+NP).
-c     Eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are ordered
-c     according to the order defined by WHICH.  The associated Ritz estimates
-c     are located in WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... ,
-c     WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note: 
-c
-c  Fortran-D syntax:
-c  ================
-c  Complex  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Complex  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c  
-c  CM2/CM5 syntax:
-c  ==============
-c  
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex 
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "_Complex_ Shift and Invert Strategies for
-c     _Real_ Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     cnaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     cstatn  ARPACK routine that initializes the timing variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     cvout   ARPACK utility routine that prints vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-     &     ipntr, workd, workl, lworkl, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real  
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Complex 
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-      Real   
-     &           rwork(ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex 
-     &           one, zero
-      parameter (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw, 
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   cnaup2, cvout, ivout, arscnd, cstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real  
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call cstatn
-         call arscnd (t0)
-         msglvl = mcaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 5*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 3) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         end if
-c 
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c 
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. 0.0E+0  )			tol = slamch('EpsMach')
-         if (ishift .ne. 0  .and.  
-     &       ishift .ne. 1  .and.
-     &       ishift .ne. 2) 			ishift = 1
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev 
-c 
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 5*ncv
-            workl(j) = zero
-  10     continue
-c 
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values             |
-c        | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds        |
-c        | workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace       |
-c        | The final workspace is needed by subroutine cneigh called   |
-c        | by cnaup2. Subroutine cneigh calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + ldh*ncv
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = iq
-         ipntr(8) = bounds
-         ipntr(14) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call cnaup2 
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz), 
-     &     workl(bounds), workl(iq), ldq, workl(iw), 
-     &     ipntr, workd, rwork, info )
-c 
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP.              |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c 
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within cnaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call cvout (logfil, np, workl(ritz), ndigit, 
-     &               '_naupd: The final Ritz values')
-         call cvout (logfil, np, workl(bounds), ndigit, 
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tcaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tcaupd, tcaup2, tcaitr, titref,
-     &                  tgetv0, tceigh, tcgets, tcapps, tcconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Complex implicit Arnoldi update code      =',/
-     &      5x, '= Version Number: ', ' 2.3' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of cnaupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cneigh.f b/libcruft/arpack/src/cneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/cneigh.f
+++ /dev/null
@@ -1,257 +0,0 @@
-c\BeginDoc
-c
-c\Name: cneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call cneigh
-c     ( RNORM, N, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, RWORK, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Complex N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex array of length N.  (OUTPUT)
-c          On output, RITZ(1:N) contains the eigenvalues of H.
-c
-c  BOUNDS  Complex array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues held in RITZ.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZ.
-c
-c  Q       Complex N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  RWORK   Real  work array of length N (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end. 
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from clahqr or ctrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     svout   ARPACK utility routine that prints vectors.
-c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine to compute the Schur form of an
-c             upper Hessenberg matrix.
-c     claset  LAPACK matrix initialization routine.
-c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form
-c     ccopy   Level 1 BLAS that copies one vector to another. 
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cneigh (rnorm, n, h, ldh, ritz, bounds, 
-     &                   q, ldq, workl, rwork, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Real     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritz(n),
-     &           workl(n*(n+3)) 
-      Real 
-     &           rwork(n)
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex     
-     &           one, zero
-      Real
-     &           rone
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rone = 1.0E+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    j,  msglvl
-      Complex     
-     &           vl(1)
-      Real
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   clacpy, clahqr, ctrevc, ccopy, 
-     &           csscal, cmout, cvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           scnrm2
-      external   scnrm2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mceigh
-c 
-      if (msglvl .gt. 2) then
-          call cmout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the   |
-c     |    corresponding Schur vectors and the full Schur form T |
-c     |    of the current upper Hessenberg matrix H.             |
-c     |    clahqr returns the full Schur form of H               | 
-c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
-c     %----------------------------------------------------------%
-c
-      call clacpy ('All', n, n, h, ldh, workl, n)
-      call claset ('All', n, n, zero, one, q, ldq)
-      call clahqr (.true., .true., n, 1, n, workl, ldh, ritz,
-     &             1, n, q, ldq, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      call ccopy (n, q(n-1,1), ldq, bounds, 1)
-      if (msglvl .gt. 1) then
-         call cvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and |
-c     |    apply the Schur vectors to get the corresponding      |
-c     |    eigenvectors.                                         |
-c     %----------------------------------------------------------%
-c
-      call ctrevc ('Right', 'Back', select, n, workl, n, vl, n, q, 
-     &             ldq, n, n, workl(n*n+1), rwork, ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | Euclidean norms are all one. LAPACK subroutine |
-c     | ctrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      do 10 j=1, n
-            temp = scnrm2( n, q(1,j), 1 )
-            call csscal ( n, rone / temp, q(1,j), 1 )
-   10 continue
-c
-      if (msglvl .gt. 1) then
-         call ccopy(n, q(n,1), ldq, workl, 1)
-         call cvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      call ccopy(n, q(n,1), n, bounds, 1)
-      call csscal(n, rnorm, bounds, 1)
-c
-      if (msglvl .gt. 2) then
-         call cvout (logfil, n, ritz, ndigit,
-     &              '_neigh: The eigenvalues of H')
-         call cvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd(t1)
-      tceigh = tceigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cneupd.f b/libcruft/arpack/src/cneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/cneupd.f
+++ /dev/null
@@ -1,876 +0,0 @@
-c\BeginDoc
-c 
-c\Name: cneupd 
-c 
-c\Description: 
-c  This subroutine returns the converged approximations to eigenvalues 
-c  of A*z = lambda*B*z and (optionally): 
-c 
-c      (1) The corresponding approximate eigenvectors; 
-c 
-c      (2) An orthonormal basis for the associated approximate 
-c          invariant subspace; 
-c 
-c      (3) Both.  
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal 
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied). 
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to CNAUPD.  CNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such 
-c  in the comments that follow.   The computed orthonormal basis for the 
-c  invariant subspace corresponding to these Ritz values is referred to as a 
-c  Schur basis. 
-c 
-c  The definition of OP as well as other terms and the relation of computed
-c  Ritz values and vectors of OP with respect to the given problem
-c  A*z = lambda*B*z may be found in the header of CNAUPD.  For a brief 
-c  description, see definitions of IPARAM(7), MODE and WHICH in the
-c  documentation of CNAUPD.
-c
-c\Usage:
-c  call cneupd 
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, 
-c       WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the  Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT need not be initialized 
-c          but it is used as internal workspace.
-c
-c  D       Complex  array of dimension NEV+1.  (OUTPUT)
-c          On exit, D contains the  Ritz  approximations 
-c          to the eigenvalues lambda for A*z = lambda*B*z.
-c
-c  Z       Complex  N by NEV array    (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represents approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          If RVEC = .FALSE. or HOWMNY = 'P', then Z is NOT REFERENCED.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required, 
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi 
-c          basis array V computed by CNAUPD.  In this case the Arnoldi basis 
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ) is required.  
-c          In any case,  LDZ .ge. 1 is required.
-c
-c  SIGMA   Complex   (INPUT)
-c          If IPARAM(7) = 3 then SIGMA represents the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  WORKEV  Complex  work array of dimension 2*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to CNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments 
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, 
-c           WORKD, WORKL, LWORKL, RWORK, INFO 
-c
-c         must be passed directly to CNEUPD following the last call 
-c         to CNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to CNAUPD and the call to CNEUPD.
-c
-c  Three of these parameters (V, WORKL and INFO) are also output parameters:
-c
-c  V       Complex  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by CNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+2*ncv) contains information obtained in
-c          cnaupd.  They are not changed by cneupd.
-c          WORKL(ncv*ncv+2*ncv+1:3*ncv*ncv+4*ncv) holds the
-c          untransformed Ritz values, the untransformed error estimates of 
-c          the Ritz values, the upper triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by cneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): Not used
-c          IPNTR(11): pointer to the NCV corresponding error estimates.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     cneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine csheqr
-c                could not be reordered by LAPACK routine ctrsen.
-c                Re-enter subroutine cneupd with IPARAM(5)=NCV and
-c                increase the size of the array D to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation.
-c                This should never happened.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine ctrevc.
-c          = -10: IPARAM(7) must be 1,2,3
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: CNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: CNEUPD got a different count of the number of converged
-c                 Ritz values than CNAUPD got.  This indicates the user
-c                 probably made an error in passing data from CNAUPD to
-c                 CNEUPD or that the data was modified before entering
-c                 CNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B. Nour-Omid, B. N. Parlett, T. Ericsson and P. S. Jensen,
-c     "How to Implement the Spectral Transformation", Math Comp.,
-c     Vol. 48, No. 178, April, 1987 pp. 664-673. 
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     cgeqr2  LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine that computes the Schur form of a
-c             upper Hessenberg matrix.
-c     claset  LAPACK matrix initialization routine.
-c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form.
-c     ctrsen  LAPACK routine that re-orders the Schur form.
-c     cunm2r  LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     slamch  LAPACK routine that determines machine constants.
-c     ctrmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     cgeru   Level 2 BLAS rank one update to a matrix.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cscal   Level 1 BLAS that scales a vector.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a complex vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented. 
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .true. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c       transpose( V(:,1:IPARAM(5)) ) * V(:,1:IPARAM(5)) = I
-c     are approximately satisfied.
-c     Here T is the leading submatrix of order IPARAM(5) of the 
-c     upper triangular matrix stored workl(ipntr(12)). 
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas 
-c     Dept. of Computational & 
-c     Applied Mathematics 
-c     Rice University 
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine cneupd(rvec , howmny, select, d     ,
-     &                   z    , ldz   , sigma , workev,
-     &                   bmat , n     , which , nev   ,
-     &                   tol  , resid , ncv   , v     ,
-     &                   ldv  , iparam, ipntr , workd ,
-     &                   workl, lworkl, rwork , info  )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Complex      
-     &           sigma
-      Real  
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Real 
-     &           rwork(ncv)
-      Complex 
-     &           d(nev)     , resid(n)     , v(ldv,ncv),
-     &           z(ldz, nev), 
-     &           workd(3*n) , workl(lworkl), workev(2*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex 
-     &           one, zero
-      parameter  (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds, iheig , nconv ,
-     &           invsub, iuptri, iwev  , j    , ldh   , ldq   ,
-     &           mode  , msglvl, ritz  , wr   , k     , irz   ,
-     &           ibd   , outncv, iq    , np   , numcnv, jj    ,
-     &           ishift, nconv2
-      Complex 
-     &           rnorm, temp, vl(1)
-      Real 
-     &           conds, sep, rtemp, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy , cgeru, cgeqr2, clacpy, cmout,
-     &           cunm2r, ctrmm, cvout, ivout,
-     &           clahqr
-c  
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           scnrm2, slamch, slapy2
-      external   scnrm2, slamch, slapy2
-c
-      Complex 
-     &           cdotc
-      external   cdotc
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mceupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %-------------------------------%
-c     | Quick return                  |
-c     | Check for incompatible input  |
-c     %-------------------------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 4*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, WORKEV, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values            |
-c     | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds     |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by CNEUPD.                 |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed |
-c     |                                      Ritz values.         |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                                      error bounds of      |
-c     |                                      the Ritz values      |
-c     | workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper |
-c     |                                      triangular matrix    |
-c     |                                      for H.               |
-c     | workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the    |
-c     |                                      associated matrix    |
-c     |                                      representation of    |
-c     |                                      the invariant        |
-c     |                                      subspace for H.      |
-c     | GRAND total of NCV * ( 3 * NCV + 4 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      iq     = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheig  = bounds + ldh
-      ihbds  = iheig  + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheig
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wr = 1
-      iwev = wr + ncv
-c
-c     %-----------------------------------------%
-c     | irz points to the Ritz values computed  |
-c     |     by _neigh before exiting _naup2.    |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irz = ipntr(14) + ncv*ncv
-      ibd = irz + ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call cvout(logfil, ncv, workl(irz), ndigit,
-     &   '_neupd: Ritz values passed in from _NAUPD.')
-         call cvout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(ibd)       |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call cngets(ishift, which     , nev          ,
-     &                np    , workl(irz), workl(bounds))
-c
-         if (msglvl .gt. 2) then
-            call cvout (logfil, ncv, workl(irz), ndigit,
-     &      '_neupd: Ritz values after calling _NGETS.')
-            call cvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            rtemp = max(eps23,
-     &                 slapy2 ( real (workl(irz+ncv-j)),
-     &                          aimag(workl(irz+ncv-j)) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          slapy2( real (workl(ibd+jj-1)),
-     &          aimag(workl(ibd+jj-1)) )
-     &          .le. tol*rtemp) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-------------------------------------------------------%
-c        | Call LAPACK routine clahqr to compute the Schur form |
-c        | of the upper Hessenberg matrix returned by CNAUPD.   |
-c        | Make a copy of the upper Hessenberg matrix.           |
-c        | Initialize the Schur vector matrix Q to the identity. |
-c        %-------------------------------------------------------%
-c
-         call ccopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call claset('All', ncv, ncv          , 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call clahqr(.true., .true.       , ncv          , 
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheig) , 1            ,
-     &                ncv   , workl(invsub), ldq          ,
-     &                ierr)
-         call ccopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call cvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H')
-            call cvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call cmout (logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------%
-c           | Reorder the computed upper triangular matrix. |
-c           %-----------------------------------------------%
-c
-            call ctrsen('None'       , 'V'          , select      ,
-     &                   ncv          , workl(iuptri), ldh         ,
-     &                   workl(invsub), ldq          , workl(iheig),
-     &                   nconv2       , conds        , sep         , 
-     &                   workev       , ncv          , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call cvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call cmout(logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &              '_neupd: Triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------------%
-c        | Copy the last row of the Schur basis matrix |
-c        | to workl(ihbds).  This vector will be used  |
-c        | to compute the Ritz estimates of converged  |
-c        | Ritz values.                                |
-c        %---------------------------------------------%
-c
-         call ccopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c 
-c        %--------------------------------------------%
-c        | Place the computed eigenvalues of H into D |
-c        | if a spectral transformation was not used. |
-c        %--------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call ccopy(nconv, workl(iheig), 1, d, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call cgeqr2(ncv , nconv , workl(invsub),
-     &                ldq , workev, workev(ncv+1),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q using cunm2r.                    |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | * Postmultiply Z by R.                                 |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(iheig). The first NCONV       | 
-c        | columns of V are now approximate Schur vectors         |
-c        | associated with the upper triangular matrix of order   |
-c        | NCONV in workl(iuptri).                                |
-c        %--------------------------------------------------------%
-c
-         call cunm2r('Right', 'Notranspose', n            ,
-     &                ncv    , nconv        , workl(invsub),
-     &                ldq    , workev       , v            ,
-     &                ldv    , workd(n+1)   , ierr)
-         call clacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | triangular form of workl(iuptri,ldq).             |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones.          |
-c           %---------------------------------------------------%
-c
-            if ( real ( workl(invsub+(j-1)*ldq+j-1) ) .lt. 
-     &                  real (zero) ) then
-               call cscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call cscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call ctrevc('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , rwork        , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | ctrevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1.                                   |
-c           %------------------------------------------------%
-c
-            do 40 j=1, nconv
-                  rtemp = scnrm2(ncv, workl(invsub+(j-1)*ldq), 1)
-                  rtemp = real (one) / rtemp
-                  call csscal ( ncv, rtemp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-c                 %------------------------------------------%
-c                 | Ritz estimates can be obtained by taking |
-c                 | the inner product of the last row of the |
-c                 | Schur basis of H with eigenvectors of T. |
-c                 | Note that the eigenvector matrix of T is |
-c                 | upper triangular, thus the length of the |
-c                 | inner product can be set to j.           |
-c                 %------------------------------------------%
-c 
-                  workev(j) = cdotc(j, workl(ihbds), 1,
-     &                        workl(invsub+(j-1)*ldq), 1)
- 40         continue
-c
-            if (msglvl .gt. 2) then
-               call ccopy(nconv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &            '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call cmout(logfil       , ncv, ncv   ,
-     &                        workl(invsub), ldq, ndigit,
-     &               '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c 
-            call ccopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %----------------------------------------------%
-c           | The eigenvector matrix Q of T is triangular. |
-c           | Form Z*Q.                                    |
-c           %----------------------------------------------%
-c
-            call ctrmm('Right'   , 'Upper'      , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-         end if 
-c
-      else
-c
-c        %--------------------------------------------------%
-c        | An approximate invariant subspace is not needed. |
-c        | Place the Ritz values computed CNAUPD into D.    |
-c        %--------------------------------------------------%
-c
-         call ccopy(nconv, workl(ritz), 1, d, 1)
-         call ccopy(nconv, workl(ritz), 1, workl(iheig), 1)
-         call ccopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call cscal(ncv, rnorm, workl(ihbds), 1)
-c      
-      else
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (rvec) 
-     &      call cscal(ncv, rnorm, workl(ihbds), 1)
-c    
-         do 50 k=1, ncv
-            temp = workl(iheig+k-1)
-            workl(ihbds+k-1) = workl(ihbds+k-1) / temp / temp
-  50     continue
-c  
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | *  Transform the Ritz values back to the original system. |
-c     |    For TYPE = 'SHIFTI' the transformation is              |
-c     |             lambda = 1/theta + sigma                      |
-c     | NOTES:                                                    |
-c     | *The Ritz vectors are not affected by the transformation. |
-c     %-----------------------------------------------------------%
-c    
-      if (type .eq. 'SHIFTI') then
-         do 60 k=1, nconv
-            d(k) = one / workl(iheig+k-1) + sigma
-  60     continue
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call cvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Untransformed Ritz values.')
-         call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Ritz estimates of the untransformed Ritz values.')
-      else if ( msglvl .gt. 1) then
-         call cvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Converged Ritz values.')
-         call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3. See reference 3.                  |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta.                           |
-c        %------------------------------------------------%
-c
-         do 100 j=1, nconv
-            if (workl(iheig+j-1) .ne. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheig+j-1)
-            endif
- 100     continue
-
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call cgeru (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of cneupd|
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cngets.f b/libcruft/arpack/src/cngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/cngets.f
+++ /dev/null
@@ -1,178 +0,0 @@
-c\BeginDoc
-c
-c\Name: cngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call cngets
-c      ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest REAL part.
-c          'SR' -> want the KEV eigenvalues of smallest REAL part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV     Integer.  (INPUT)
-c          The number of desired eigenvalues.
-c
-c  NP      Integer.  (INPUT)
-c          The number of shifts to compute.
-c
-c  RITZ    Complex array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Complex array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\Routines called:
-c     csortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cvout   ARPACK utility routine that prints vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. This routine does not keep complex conjugate pairs of
-c        eigenvalues together.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cngets ( ishift, which, kev, np, ritz, bounds)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           bounds(kev+np), ritz(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   cvout,  csortc, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mcgets
-c 
-      call csortc (which, .true., kev+np, ritz, bounds)
-c     
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine cnapps.                     |
-c        | Be careful and use 'SM' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call csortc ( 'SM', .true., np, bounds, ritz )
-c
-      end if
-c     
-      call arscnd (t1)
-      tcgets = tcgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call cvout (logfil, kev+np, ritz, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix ')
-         call cvout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of cngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/csortc.f b/libcruft/arpack/src/csortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/csortc.f
+++ /dev/null
@@ -1,322 +0,0 @@
-c\BeginDoc
-c
-c\Name: csortc
-c
-c\Description:
-c  Sorts the Complex array in X into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  Real  array Y. 
-c
-c\Usage:
-c  call csortc
-c     ( WHICH, APPLY, N, X, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort X into increasing order of magnitude.
-c          'SM' -> sort X into decreasing order of magnitude.
-c          'LR' -> sort X with real(X) in increasing algebraic order 
-c          'SR' -> sort X with real(X) in decreasing algebraic order
-c          'LI' -> sort X with imag(X) in increasing algebraic order
-c          'SI' -> sort X with imag(X) in decreasing algebraic order
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X       Complex array of length N.  (INPUT/OUTPUT)
-c          This is the array to be sorted.
-c
-c  Y       Complex array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c     Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine csortc (which, apply, n, x, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex     
-     &           x(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Complex     
-     &           temp
-      Real 
-     &           temp1, temp2
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2
-c
-c     %--------------------%
-c     | Intrinsic Functions |
-c     %--------------------%
-       Intrinsic
-     &           real, aimag
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into increasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = slapy2(real(x(j)),aimag(x(j)))
-            temp2 = slapy2(real(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.gt.temp2) then
-                temp = x(j)
-                x(j) = x(j+igap)
-                x(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into decreasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = slapy2(real(x(j)),aimag(x(j)))
-            temp2 = slapy2(real(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.lt.temp2) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (real(x(j)).gt.real(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (real(x(j)).lt.real(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %--------------------------------------------%
-c        | Sort XIMAG into increasing algebraic order |
-c        %--------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (aimag(x(j)).gt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %---------------------------------------------%
-c        | Sort XIMAG into decreasing algebraic order  |
-c        %---------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (aimag(x(j)).lt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of csortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cstatn.f b/libcruft/arpack/src/cstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/cstatn.f
+++ /dev/null
@@ -1,51 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for complex nonsymmetric Arnoldi code.      |
-c     %---------------------------------------------%
-
-      subroutine cstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tcaupd = 0.0E+0
-      tcaup2 = 0.0E+0
-      tcaitr = 0.0E+0
-      tceigh = 0.0E+0
-      tcgets = 0.0E+0
-      tcapps = 0.0E+0
-      tcconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
- 
-      return
-c
-c     %---------------%
-c     | End of cstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/debug.h b/libcruft/arpack/src/debug.h
deleted file mode 100644
--- a/libcruft/arpack/src/debug.h
+++ /dev/null
@@ -1,16 +0,0 @@
-c
-c\SCCS Information: @(#) 
-c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-c     %---------------------------------%
-c     | See debug.doc for documentation |
-c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
diff --git a/libcruft/arpack/src/dgetv0.f b/libcruft/arpack/src/dgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/dgetv0.f
+++ /dev/null
@@ -1,419 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call dgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that dgetv0 is called.  
-c          It should be set to 1 on the initial call to dgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Double precision N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Double precision scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Double precision work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine for vector output.
-c     dlarnv  LAPACK routine for generating a random vector.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: getv0.F   SID: 2.7   DATE OF SID: 04/07/99   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Double precision
-     &           rnorm0
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dlarnv, dvout, dcopy, dgemv, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2
-      external   ddot, dnrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call dlarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call dcopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %-----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %-----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-      end if
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call dcopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call dcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          rnorm0 = ddot (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(abs(rnorm0))
-      else if (bmat .eq. 'I') then
-           rnorm0 = dnrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call dgemv ('T', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call dgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call dcopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call dcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         rnorm = ddot (n, resid, 1, workd, 1)
-         rnorm = sqrt(abs(rnorm))
-      else if (bmat .eq. 'I') then
-         rnorm = dnrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call dvout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 5) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = zero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 3) then
-         call dvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dlaqrb.f b/libcruft/arpack/src/dlaqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/dlaqrb.f
+++ /dev/null
@@ -1,521 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dlaqrb
-c
-c\Description:
-c  Compute the eigenvalues and the Schur decomposition of an upper 
-c  Hessenberg submatrix in rows and columns ILO to IHI.  Only the
-c  last component of the Schur vectors are computed.
-c
-c  This is mostly a modification of the LAPACK routine dlahqr.
-c  
-c\Usage:
-c  call dlaqrb
-c     ( WANTT, N, ILO, IHI, H, LDH, WR, WI,  Z, INFO )
-c
-c\Arguments
-c  WANTT   Logical variable.  (INPUT)
-c          = .TRUE. : the full Schur form T is required;
-c          = .FALSE.: only eigenvalues are required.
-c
-c  N       Integer.  (INPUT)
-c          The order of the matrix H.  N >= 0.
-c
-c  ILO     Integer.  (INPUT)
-c  IHI     Integer.  (INPUT)
-c          It is assumed that H is already upper quasi-triangular in
-c          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
-c          ILO = 1). SLAQRB works primarily with the Hessenberg
-c          submatrix in rows and columns ILO to IHI, but applies
-c          transformations to all of H if WANTT is .TRUE..
-c          1 <= ILO <= max(1,IHI); IHI <= N.
-c
-c  H       Double precision array, dimension (LDH,N).  (INPUT/OUTPUT)
-c          On entry, the upper Hessenberg matrix H.
-c          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
-c          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
-c          standard form. If WANTT is .FALSE., the contents of H are
-c          unspecified on exit.
-c
-c  LDH     Integer.  (INPUT)
-c          The leading dimension of the array H. LDH >= max(1,N).
-c
-c  WR      Double precision array, dimension (N).  (OUTPUT)
-c  WI      Double precision array, dimension (N).  (OUTPUT)
-c          The real and imaginary parts, respectively, of the computed
-c          eigenvalues ILO to IHI are stored in the corresponding
-c          elements of WR and WI. If two eigenvalues are computed as a
-c          complex conjugate pair, they are stored in consecutive
-c          elements of WR and WI, say the i-th and (i+1)th, with
-c          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
-c          eigenvalues are stored in the same order as on the diagonal
-c          of the Schur form returned in H, with WR(i) = H(i,i), and, if
-c          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
-c          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
-c
-c  Z       Double precision array, dimension (N).  (OUTPUT)
-c          On exit Z contains the last components of the Schur vectors.
-c
-c  INFO    Integer.  (OUPUT)
-c          = 0: successful exit
-c          > 0: SLAQRB failed to compute all the eigenvalues ILO to IHI
-c               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
-c               elements i+1:ihi of WR and WI contain those eigenvalues
-c               which have been successfully computed.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dlanv2  LAPACK routine that computes the Schur factorization of
-c             2 by 2 nonsymmetric matrix in standard form.
-c     dlarfg  LAPACK Householder reflection construction routine.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     drot    Level 1 BLAS that applies a rotation to a 2 by 2 matrix.
-
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c               Modified from the LAPACK routine dlahqr so that only the
-c               last component of the Schur vectors are computed.
-c
-c\SCCS Information: @(#) 
-c FILE: laqrb.F   SID: 2.2   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dlaqrb ( wantt, n, ilo, ihi, h, ldh, wr, wi,
-     &                    z, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      logical    wantt
-      integer    ihi, ilo, info, ldh, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h( ldh, * ), wi( * ), wr( * ), z( * )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           zero, one, dat1, dat2
-      parameter (zero = 0.0D+0, one = 1.0D+0, dat1 = 7.5D-1, 
-     &           dat2 = -4.375D-1)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, i1, i2, itn, its, j, k, l, m, nh, nr
-      Double precision
-     &           cs, h00, h10, h11, h12, h21, h22, h33, h33s,
-     &           h43h34, h44, h44s, ovfl, s, smlnum, sn, sum,
-     &           t1, t2, t3, tst1, ulp, unfl, v1, v2, v3
-      Double precision
-     &           v( 3 ), work( 1 )
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch, dlanhs
-      external   dlamch, dlanhs
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dlabad, dlanv2, dlarfg, drot
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      info = 0
-c
-c     %--------------------------%
-c     | Quick return if possible |
-c     %--------------------------%
-c
-      if( n.eq.0 )
-     &   return
-      if( ilo.eq.ihi ) then
-         wr( ilo ) = h( ilo, ilo )
-         wi( ilo ) = zero
-         return
-      end if
-c 
-c     %---------------------------------------------%
-c     | Initialize the vector of last components of |
-c     | the Schur vectors for accumulation.         |
-c     %---------------------------------------------%
-c
-      do 5 j = 1, n-1
-         z(j) = zero
-  5   continue 
-      z(n) = one
-c 
-      nh = ihi - ilo + 1
-c
-c     %-------------------------------------------------------------%
-c     | Set machine-dependent constants for the stopping criterion. |
-c     | If norm(H) <= sqrt(OVFL), overflow should not occur.        |
-c     %-------------------------------------------------------------%
-c
-      unfl = dlamch( 'safe minimum' )
-      ovfl = one / unfl
-      call dlabad( unfl, ovfl )
-      ulp = dlamch( 'precision' )
-      smlnum = unfl*( nh / ulp )
-c
-c     %---------------------------------------------------------------%
-c     | I1 and I2 are the indices of the first row and last column    |
-c     | of H to which transformations must be applied. If eigenvalues |
-c     | only are computed, I1 and I2 are set inside the main loop.    |
-c     | Zero out H(J+2,J) = ZERO for J=1:N if WANTT = .TRUE.          |
-c     | else H(J+2,J) for J=ILO:IHI-ILO-1 if WANTT = .FALSE.          |
-c     %---------------------------------------------------------------%
-c
-      if( wantt ) then
-         i1 = 1
-         i2 = n
-         do 8 i=1,i2-2
-            h(i1+i+1,i) = zero
- 8       continue
-      else
-         do 9 i=1, ihi-ilo-1
-            h(ilo+i+1,ilo+i-1) = zero
- 9       continue
-      end if
-c 
-c     %---------------------------------------------------%
-c     | ITN is the total number of QR iterations allowed. |
-c     %---------------------------------------------------%
-c
-      itn = 30*nh
-c 
-c     ------------------------------------------------------------------
-c     The main loop begins here. I is the loop index and decreases from
-c     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
-c     with the active submatrix in rows and columns L to I.
-c     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
-c     H(L,L-1) is negligible so that the matrix splits.
-c     ------------------------------------------------------------------
-c 
-      i = ihi
-   10 continue
-      l = ilo
-      if( i.lt.ilo )
-     &   go to 150
- 
-c     %--------------------------------------------------------------%
-c     | Perform QR iterations on rows and columns ILO to I until a   |
-c     | submatrix of order 1 or 2 splits off at the bottom because a |
-c     | subdiagonal element has become negligible.                   |
-c     %--------------------------------------------------------------%
- 
-      do 130 its = 0, itn
-c
-c        %----------------------------------------------%
-c        | Look for a single small subdiagonal element. |
-c        %----------------------------------------------%
-c
-         do 20 k = i, l + 1, -1
-            tst1 = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
-            if( tst1.eq.zero )
-     &         tst1 = dlanhs( '1', i-l+1, h( l, l ), ldh, work )
-            if( abs( h( k, k-1 ) ).le.max( ulp*tst1, smlnum ) )
-     &         go to 30
-   20    continue
-   30    continue
-         l = k
-         if( l.gt.ilo ) then
-c
-c           %------------------------%
-c           | H(L,L-1) is negligible |
-c           %------------------------%
-c
-            h( l, l-1 ) = zero
-         end if
-c
-c        %-------------------------------------------------------------%
-c        | Exit from loop if a submatrix of order 1 or 2 has split off |
-c        %-------------------------------------------------------------%
-c
-         if( l.ge.i-1 )
-     &      go to 140
-c
-c        %---------------------------------------------------------%
-c        | Now the active submatrix is in rows and columns L to I. |
-c        | If eigenvalues only are being computed, only the active |
-c        | submatrix need be transformed.                          |
-c        %---------------------------------------------------------%
-c
-         if( .not.wantt ) then
-            i1 = l
-            i2 = i
-         end if
-c 
-         if( its.eq.10 .or. its.eq.20 ) then
-c
-c           %-------------------%
-c           | Exceptional shift |
-c           %-------------------%
-c
-            s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
-            h44 = dat1*s
-            h33 = h44
-            h43h34 = dat2*s*s
-c
-         else
-c
-c           %-----------------------------------------%
-c           | Prepare to use Wilkinson's double shift |
-c           %-----------------------------------------%
-c
-            h44 = h( i, i )
-            h33 = h( i-1, i-1 )
-            h43h34 = h( i, i-1 )*h( i-1, i )
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Look for two consecutive small subdiagonal elements |
-c        %-----------------------------------------------------%
-c
-         do 40 m = i - 2, l, -1
-c
-c           %---------------------------------------------------------%
-c           | Determine the effect of starting the double-shift QR    |
-c           | iteration at row M, and see if this would make H(M,M-1) |
-c           | negligible.                                             |
-c           %---------------------------------------------------------%
-c
-            h11 = h( m, m )
-            h22 = h( m+1, m+1 )
-            h21 = h( m+1, m )
-            h12 = h( m, m+1 )
-            h44s = h44 - h11
-            h33s = h33 - h11
-            v1 = ( h33s*h44s-h43h34 ) / h21 + h12
-            v2 = h22 - h11 - h33s - h44s
-            v3 = h( m+2, m+1 )
-            s = abs( v1 ) + abs( v2 ) + abs( v3 )
-            v1 = v1 / s
-            v2 = v2 / s
-            v3 = v3 / s
-            v( 1 ) = v1
-            v( 2 ) = v2
-            v( 3 ) = v3
-            if( m.eq.l )
-     &         go to 50
-            h00 = h( m-1, m-1 )
-            h10 = h( m, m-1 )
-            tst1 = abs( v1 )*( abs( h00 )+abs( h11 )+abs( h22 ) )
-            if( abs( h10 )*( abs( v2 )+abs( v3 ) ).le.ulp*tst1 )
-     &         go to 50
-   40    continue
-   50    continue
-c
-c        %----------------------%
-c        | Double-shift QR step |
-c        %----------------------%
-c
-         do 120 k = m, i - 1
-c 
-c           ------------------------------------------------------------
-c           The first iteration of this loop determines a reflection G
-c           from the vector V and applies it from left and right to H,
-c           thus creating a nonzero bulge below the subdiagonal.
-c
-c           Each subsequent iteration determines a reflection G to
-c           restore the Hessenberg form in the (K-1)th column, and thus
-c           chases the bulge one step toward the bottom of the active
-c           submatrix. NR is the order of G.
-c           ------------------------------------------------------------
-c 
-            nr = min( 3, i-k+1 )
-            if( k.gt.m )
-     &         call dcopy( nr, h( k, k-1 ), 1, v, 1 )
-            call dlarfg( nr, v( 1 ), v( 2 ), 1, t1 )
-            if( k.gt.m ) then
-               h( k, k-1 ) = v( 1 )
-               h( k+1, k-1 ) = zero
-               if( k.lt.i-1 )
-     &            h( k+2, k-1 ) = zero
-            else if( m.gt.l ) then
-               h( k, k-1 ) = -h( k, k-1 )
-            end if
-            v2 = v( 2 )
-            t2 = t1*v2
-            if( nr.eq.3 ) then
-               v3 = v( 3 )
-               t3 = t1*v3
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 60 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-                  h( k+2, j ) = h( k+2, j ) - sum*t3
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 70 j = i1, min( k+3, i )
-                  sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-                  h( j, k+2 ) = h( j, k+2 ) - sum*t3
-   70          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 ) + v3*z( k+2 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-               z( k+2 ) = z( k+2 ) - sum*t3
- 
-            else if( nr.eq.2 ) then
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 90 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-   90          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 100 j = i1, i
-                  sum = h( j, k ) + v2*h( j, k+1 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-  100          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-            end if
-  120    continue
- 
-  130 continue
-c
-c     %-------------------------------------------------------%
-c     | Failure to converge in remaining number of iterations |
-c     %-------------------------------------------------------%
-c
-      info = i
-      return
- 
-  140 continue
- 
-      if( l.eq.i ) then
-c
-c        %------------------------------------------------------%
-c        | H(I,I-1) is negligible: one eigenvalue has converged |
-c        %------------------------------------------------------%
-c
-         wr( i ) = h( i, i )
-         wi( i ) = zero
-
-      else if( l.eq.i-1 ) then
-c
-c        %--------------------------------------------------------%
-c        | H(I-1,I-2) is negligible;                              |
-c        | a pair of eigenvalues have converged.                  |
-c        |                                                        |
-c        | Transform the 2-by-2 submatrix to standard Schur form, |
-c        | and compute and store the eigenvalues.                 |
-c        %--------------------------------------------------------%
-c
-         call dlanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),
-     &                h( i, i ), wr( i-1 ), wi( i-1 ), wr( i ), wi( i ),
-     &                cs, sn )
- 
-         if( wantt ) then
-c
-c           %-----------------------------------------------------%
-c           | Apply the transformation to the rest of H and to Z, |
-c           | as required.                                        |
-c           %-----------------------------------------------------%
-c
-            if( i2.gt.i )
-     &         call drot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,
-     &                    cs, sn )
-            call drot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
-            sum      = cs*z( i-1 ) + sn*z( i )
-            z( i )   = cs*z( i )   - sn*z( i-1 )
-            z( i-1 ) = sum
-         end if
-      end if
-c
-c     %---------------------------------------------------------%
-c     | Decrement number of remaining iterations, and return to |
-c     | start of the main loop with new value of I.             |
-c     %---------------------------------------------------------%
-c
-      itn = itn - its
-      i = l - 1
-      go to 10
- 
-  150 continue
-      return
-c
-c     %---------------%
-c     | End of dlaqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnaitr.f b/libcruft/arpack/src/dnaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnaitr.f
+++ /dev/null
@@ -1,840 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in dnaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call dnaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recompute in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See dnaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Double precision N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Double precision (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     dgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c 
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in dnaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Double precision
-     &           betaj, ovfl, temp1, rnorm1, smlnum, tst1, ulp, unfl, 
-     &           wnorm
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Double precision
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dgemv, dgetv0, dlabad, 
-     &           dvout, dmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlanhs, dlamch
-      external   ddot, dnrm2, dlanhs, dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine dlahqr     |
-c        %-----------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = one / unfl
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mnaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         dgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determing whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = zero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call dgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tnaitr = tnaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call dcopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. unfl) then
-             temp1 = one / rnorm
-             call dscal (n, temp1, v(1,j), 1)
-             call dscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call dcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call dcopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             wnorm = ddot (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = betaj
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = ddot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call dvout (logfil, 2, xtemp, ndigit, 
-     &           '_naitr: re-orthonalization; wnorm and rnorm are')
-            call dvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call daxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = ddot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = dnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call dvout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tnaitr = tnaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine dlahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-               if( tst1.eq.zero )
-     &              tst1 = dlanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) 
-     &              h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call dmout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dnaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnapps.f b/libcruft/arpack/src/dnapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnapps.f
+++ /dev/null
@@ -1,647 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge chage sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call dnapps
-c     ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.  KEV is only 
-c          updated on ouput when fewer than NP shifts are applied in
-c          order to keep the conjugate pair together.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFTR, Double precision array of length NP.  (INPUT)
-c  SHIFTI  Real and imaginary part of the shifts to be applied.
-c          Upon, entry to dnapps, the shifts must be sorted so that the 
-c          conjugate pairs are in consecutive locations.
-c
-c  V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenber matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Double precision work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlamch  LAPACK routine that determines machine constants. 
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlarf   LAPACK routine that applies Householder reflection to
-c             a matrix.
-c     dlarfg  LAPACK Householder reflection construction routine.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlaset  LAPACK matrix initialization routine.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: napps.F   SID: 2.4   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine dlahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     The subdiagonals of H are enforced to be non-negative.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnapps
-     &   ( n, kev, np, shiftr, shifti, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h(ldh,kev+np), resid(n), shifti(np), shiftr(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, ir, istart, j, jj, kplusp, msglvl, nr
-      logical    cconj, first
-      Double precision
-     &           c, f, g, h11, h12, h21, h22, h32, ovfl, r, s, sigmai, 
-     &           sigmar, smlnum, ulp, unfl, u(3), t, tau, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dlacpy, dlarfg, dlarf,
-     &           dlaset, dlabad, arscnd, dlartg
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch, dlanhs, dlapy2
-      external   dlamch, dlanhs, dlapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, max, min
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine dlahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = one / unfl
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mnapps
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call dlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      cconj = .false.
-      do 110 jj = 1, np
-         sigmar = shiftr(jj)
-         sigmai = shifti(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call dvout (logfil, 1, sigmar, ndigit, 
-     &               '_napps: The real part of the shift ')
-            call dvout (logfil, 1, sigmai, ndigit, 
-     &               '_napps: The imaginary part of the shift ')
-         end if
-c
-c        %-------------------------------------------------%
-c        | The following set of conditionals is necessary  |
-c        | in order that complex conjugate pairs of shifts |
-c        | are applied together or not at all.             |
-c        %-------------------------------------------------%
-c
-         if ( cconj ) then
-c
-c           %-----------------------------------------%
-c           | cconj = .true. means the previous shift |
-c           | had non-zero imaginary part.            |
-c           %-----------------------------------------%
-c
-            cconj = .false.
-            go to 110
-         else if ( jj .lt. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %------------------------------------%
-c           | Start of a complex conjugate pair. |
-c           %------------------------------------%
-c
-            cconj = .true.
-         else if ( jj .eq. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %----------------------------------------------%
-c           | The last shift has a nonzero imaginary part. |
-c           | Don't apply it; thus the order of the        |
-c           | compressed H is order KEV+1 since only np-1  |
-c           | were applied.                                |
-c           %----------------------------------------------%
-c
-            kev = kev + 1
-            go to 110
-         end if
-         istart = 1
-   20    continue
-c
-c        %--------------------------------------------------%
-c        | if sigmai = 0 then                               |
-c        |    Apply the jj-th shift ...                     |
-c        | else                                             |
-c        |    Apply the jj-th and (jj+1)-th together ...    |
-c        |    (Note that jj < np at this point in the code) |
-c        | end                                              |
-c        | to the current block of H. The next do loop      |
-c        | determines the current block ;                   |
-c        %--------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine dlahqr    |
-c           %----------------------------------------%
-c
-            tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-            if( tst1.eq.zero )
-     &         tst1 = dlanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call dvout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend ) go to 100
-c
-c        %------------------------------------------------------%
-c        | If istart + 1 = iend then no reason to apply a       |
-c        | complex conjugate pair of shifts on a 2 by 2 matrix. |
-c        %------------------------------------------------------%
-c
-         if ( istart + 1 .eq. iend .and. abs( sigmai ) .gt. zero ) 
-     &      go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         if ( abs( sigmai ) .le. zero ) then
-c
-c           %---------------------------------------------%
-c           | Real-valued shift ==> apply single shift QR |
-c           %---------------------------------------------%
-c
-            f = h11 - sigmar
-            g = h21
-c 
-            do 80 i = istart, iend-1
-c
-c              %-----------------------------------------------------%
-c              | Contruct the plane rotation G to zero out the bulge |
-c              %-----------------------------------------------------%
-c
-               call dlartg (f, g, c, s, r)
-               if (i .gt. istart) then
-c
-c                 %-------------------------------------------%
-c                 | The following ensures that h(1:iend-1,1), |
-c                 | the first iend-2 off diagonal of elements |
-c                 | H, remain non negative.                   |
-c                 %-------------------------------------------%
-c
-                  if (r .lt. zero) then
-                     r = -r
-                     c = -c
-                     s = -s
-                  end if
-                  h(i,i-1) = r
-                  h(i+1,i-1) = zero
-               end if
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the left of H;  H <- G'*H |
-c              %---------------------------------------------%
-c
-               do 50 j = i, kplusp
-                  t        =  c*h(i,j) + s*h(i+1,j)
-                  h(i+1,j) = -s*h(i,j) + c*h(i+1,j)
-                  h(i,j)   = t   
-   50          continue
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the right of H;  H <- H*G |
-c              %---------------------------------------------%
-c
-               do 60 j = 1, min(i+2,iend)
-                  t        =  c*h(j,i) + s*h(j,i+1)
-                  h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-                  h(j,i)   = t   
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c              %----------------------------------------------------%
-c
-               do 70 j = 1, min( i+jj, kplusp ) 
-                  t        =   c*q(j,i) + s*q(j,i+1)
-                  q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                  q(j,i)   = t   
-   70          continue
-c
-c              %---------------------------%
-c              | Prepare for next rotation |
-c              %---------------------------%
-c
-               if (i .lt. iend-1) then
-                  f = h(i+1,i)
-                  g = h(i+2,i)
-               end if
-   80       continue
-c
-c           %-----------------------------------%
-c           | Finished applying the real shift. |
-c           %-----------------------------------%
-c 
-         else
-c
-c           %----------------------------------------------------%
-c           | Complex conjugate shifts ==> apply double shift QR |
-c           %----------------------------------------------------%
-c
-            h12 = h(istart,istart+1)
-            h22 = h(istart+1,istart+1)
-            h32 = h(istart+2,istart+1)
-c
-c           %---------------------------------------------------------%
-c           | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |
-c           %---------------------------------------------------------%
-c
-            s    = 2.0*sigmar
-            t = dlapy2 ( sigmar, sigmai ) 
-            u(1) = ( h11 * (h11 - s) + t * t ) / h21 + h12
-            u(2) = h11 + h22 - s 
-            u(3) = h32
-c
-            do 90 i = istart, iend-1
-c
-               nr = min ( 3, iend-i+1 )
-c
-c              %-----------------------------------------------------%
-c              | Construct Householder reflector G to zero out u(1). |
-c              | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |
-c              %-----------------------------------------------------%
-c
-               call dlarfg ( nr, u(1), u(2), 1, tau )
-c
-               if (i .gt. istart) then
-                  h(i,i-1)   = u(1)
-                  h(i+1,i-1) = zero
-                  if (i .lt. iend-1) h(i+2,i-1) = zero
-               end if
-               u(1) = one
-c
-c              %--------------------------------------%
-c              | Apply the reflector to the left of H |
-c              %--------------------------------------%
-c
-               call dlarf ('Left', nr, kplusp-i+1, u, 1, tau,
-     &                     h(i,i), ldh, workl)
-c
-c              %---------------------------------------%
-c              | Apply the reflector to the right of H |
-c              %---------------------------------------%
-c
-               ir = min ( i+3, iend )
-               call dlarf ('Right', ir, nr, u, 1, tau,
-     &                     h(1,i), ldh, workl)
-c
-c              %-----------------------------------------------------%
-c              | Accumulate the reflector in the matrix Q;  Q <- Q*G |
-c              %-----------------------------------------------------%
-c
-               call dlarf ('Right', kplusp, nr, u, 1, tau, 
-     &                     q(1,i), ldq, workl)
-c
-c              %----------------------------%
-c              | Prepare for next reflector |
-c              %----------------------------%
-c
-               if (i .lt. iend-1) then
-                  u(1) = h(i+1,i)
-                  u(2) = h(i+2,i)
-                  if (i .lt. iend-2) u(3) = h(i+3,i)
-               end if
-c
-   90       continue
-c
-c           %--------------------------------------------%
-c           | Finished applying a complex pair of shifts |
-c           | to the current block                       |
-c           %--------------------------------------------%
-c 
-         end if
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %--------------------------------------------------%
-c     | Perform a similarity transformation that makes   |
-c     | sure that H will have non negative sub diagonals |
-c     %--------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( h(j+1,j) .lt. zero ) then
-              call dscal( kplusp-j+1, -one, h(j+1,j), ldh )
-              call dscal( min(j+2, kplusp), -one, h(1,j+1), 1 )
-              call dscal( min(j+np+1,kplusp), -one, q(1,j+1), 1 )
-         end if
- 120  continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine dlahqr        |
-c        %--------------------------------------------%
-c
-         tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-         if( tst1.eq.zero )
-     &       tst1 = dlanhs( '1', kev, h, ldh, workl )
-         if( h( i+1,i ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &    call dgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call dgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call dcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call dlacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &   call dcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kplusp}'*Q)*e_{kev} |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call dscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,kev) .gt. zero)
-     &   call daxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call dvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call dmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c 
- 9000 continue
-      call arscnd (t1)
-      tnapps = tnapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of dnapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnaup2.f b/libcruft/arpack/src/dnaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnaup2.f
+++ /dev/null
@@ -1,835 +0,0 @@
-c\BeginDoc
-c
-c\Name: dnaup2
-c
-c\Description:
-c  Intermediate level interface called by dnaupd .
-c
-c\Usage:
-c  call dnaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dnaupd .
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in dnaupd .
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV for two reasons. The first, is
-c          to keep complex conjugate pairs of "wanted" Ritz values
-c          together. The second, is that a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Double precision  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Double precision  arrays of length NEV+NP.  (OUTPUT)
-c  RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.
-c          imaginary) part of the computed Ritz values of OP.
-c
-c  BOUNDS  Double precision  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Double precision  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c          On exit, the last 3*(NEV+NP) locations of WORKL contain
-c          the Ritz values (real,imaginary) and associated Ritz
-c          estimates of the current Hessenberg matrix.  They are
-c          listed in the same order as returned from dneigh .
-c
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in DNAUPD.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     dgetv0   ARPACK initial vector generation routine.
-c     dnaitr   ARPACK Arnoldi factorization routine.
-c     dnapps   ARPACK application of implicit shifts routine.
-c     dnconv   ARPACK convergence of Ritz values routine.
-c     dneigh   ARPACK compute Ritz values and error bounds routine.
-c     dngets   ARPACK reorder Ritz values and error bounds routine.
-c     dsortc   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout    ARPACK utility routine that prints matrices
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     ddot     Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dswap    Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.8   DATE OF SID: 10/17/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritzr, ritzi, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Double precision
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), resid(n),
-     &           ritzi(nev+np), ritzr(nev+np), v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm , getv0, initv, update, ushift
-      integer    ierr  , iter , j    , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0  , nptemp, numcnv
-      Double precision
-     &           rnorm , temp , eps23
-      save       cnorm , getv0, initv, update, ushift,
-     &           rnorm , iter , eps23, kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0  , numcnv
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(4)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dgetv0 , dnaitr , dnconv , dneigh ,
-     &           dngets , dnapps , dvout  , ivout , arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot , dnrm2 , dlapy2 , dlamch
-      external   ddot , dnrm2 , dlapy2 , dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min, max, abs, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mnaup2
-c
-c        %-------------------------------------%
-c        | Get the machine dependent constant. |
-c        %-------------------------------------%
-c
-         eps23 = dlamch ('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call dgetv0  (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call dnaitr  (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine dnapps .                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call dnaitr  (ido  , bmat, n  , nev, np , mode , resid,
-     &                rnorm, v   , ldv, h  , ldh, ipntr, workd,
-     &                info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call dneigh  (rnorm, kplusp, h, ldh, ritzr, ritzi, bounds,
-     &                q, ldq, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from dneigh .                       |
-c        %----------------------------------------------------%
-c
-         call dcopy (kplusp, ritzr, 1, workl(kplusp**2+1), 1)
-         call dcopy (kplusp, ritzi, 1, workl(kplusp**2+kplusp+1), 1)
-         call dcopy (kplusp, bounds, 1, workl(kplusp**2+2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZR,   |
-c        | RITZI and BOUNDS respectively. The variables NEV  |
-c        | and NP may be updated if the NEV-th wanted Ritz   |
-c        | value has a non zero imaginary part. In this case |
-c        | NEV is increased by one and NP decreased by one.  |
-c        | NOTE: The last two arguments of dngets  are no     |
-c        | longer used as of version 2.1.                    |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         numcnv = nev
-         call dngets  (ishift, which, nev, np, ritzr, ritzi,
-     &                bounds, workl, workl(np+1))
-         if (nev .eq. nev0+1) numcnv = nev0+1
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call dcopy  (nev, bounds(np+1), 1, workl(2*np+1), 1)
-         call dnconv  (nev, ritzr(np+1), ritzi(np+1), workl(2*np+1),
-     &        tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = numcnv
-            kp(4) = nconv
-            call ivout (logfil, 4, kp, ndigit,
-     &                  '_naup2: NEV, NP, NUMCNV, NCONV are')
-            call dvout  (logfil, kplusp, ritzr, ndigit,
-     &           '_naup2: Real part of the eigenvalues of H')
-            call dvout  (logfil, kplusp, ritzi, ndigit,
-     &           '_naup2: Imaginary part of the eigenvalues of H')
-            call dvout  (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. numcnv) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call dvout (logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Real part of the eig computed by _neigh:')
-               call dvout (logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Imag part of the eig computed by _neigh:')
-               call dvout (logfil, kplusp, workl(kplusp**2+kplusp*2+1),
-     &                     ndigit,
-     &             '_naup2: Ritz eistmates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to _neupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = rnorm
-c
-c           %----------------------------------------------%
-c           | To be consistent with dngets , we first do a  |
-c           | pre-processing sort in order to keep complex |
-c           | conjugate pairs together.  This is similar   |
-c           | to the pre-processing sort used in dngets     |
-c           | except that the sort is done in the opposite |
-c           | order.                                       |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SR'
-            if (which .eq. 'SM') wprime = 'LR'
-            if (which .eq. 'LR') wprime = 'SM'
-            if (which .eq. 'SR') wprime = 'LM'
-            if (which .eq. 'LI') wprime = 'SM'
-            if (which .eq. 'SI') wprime = 'LM'
-c
-            call dsortc  (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %----------------------------------------------%
-c           | Now sort Ritz values so that converged Ritz  |
-c           | values appear within the first NEV locations |
-c           | of ritzr, ritzi and bounds, and the most     |
-c           | desired one appears at the front.            |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call dsortc (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, numcnv
-                temp = max(eps23,dlapy2 (ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LR'
-            call dsortc (wprime, .true., numcnv, bounds, ritzr, ritzi)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, numcnv
-                temp = max(eps23, dlapy2 (ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %------------------------------------------------%
-c           | Sort the converged Ritz values again so that   |
-c           | the "threshold" value appears at the front of  |
-c           | ritzr, ritzi and bound.                        |
-c           %------------------------------------------------%
-c
-            call dsortc (which, .true., nconv, ritzr, ritzi, bounds)
-c
-            if (msglvl .gt. 1) then
-               call dvout  (logfil, kplusp, ritzr, ndigit,
-     &            '_naup2: Sorted real part of the eigenvalues')
-               call dvout  (logfil, kplusp, ritzi, ndigit,
-     &            '_naup2: Sorted imaginary part of the eigenvalues')
-               call dvout  (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. numcnv) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. numcnv) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. numcnv) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call dngets  (ishift, which, nev, np, ritzr, ritzi,
-     &              bounds, workl, workl(np+1))
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call dvout  (logfil, nev, ritzr(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- real part')
-               call dvout  (logfil, nev, ritzi(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- imag part')
-               call dvout  (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: reverse comminucation to       |
-c           | compute the shifts. They are returned in the first    |
-c           | 2*NP locations of WORKL.                              |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:2*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-         if ( ishift .eq. 0 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZR, RITZI to free up WORKL    |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call dcopy  (np, workl,       1, ritzr, 1)
-             call dcopy  (np, workl(np+1), 1, ritzi, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call dvout  (logfil, np, ritzr, ndigit,
-     &                  '_naup2: Real part of the shifts')
-            call dvout  (logfil, np, ritzi, ndigit,
-     &                  '_naup2: Imaginary part of the shifts')
-            if ( ishift .eq. 1 )
-     &          call dvout  (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call dnapps  (n, nev, np, ritzr, ritzi, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to dnaitr .  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy  (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy  (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = ddot  (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2 (n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call dmout  (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = numcnv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tnaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of dnaup2  |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/dnaupd.f b/libcruft/arpack/src/dnaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnaupd.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c\BeginDoc
-c
-c\Name: dnaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This subroutine computes approximations to a few eigenpairs
-c  of a linear operator "OP" with respect to a semi-inner product defined by
-c  a symmetric positive semi-definite real matrix B. B may be the identity
-c  matrix. NOTE: If the linear operator "OP" is real and symmetric
-c  with respect to the real positive semi-definite symmetric matrix B,
-c  i.e. B*OP = (OP`)*B, then subroutine dsaupd  should be used instead.
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  dnaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].
-c           Note: If sigma is real, i.e. imaginary part of sigma is zero;
-c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M
-c                 amu == 1/(lambda-sigma).
-c
-c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].
-c
-c  Both mode 3 and 4 give the same enhancement to eigenvalues close to
-c  the (complex) shift sigma.  However, as lambda goes to infinity,
-c  the operator OP in mode 4 dampens the eigenvalues more strongly than
-c  does OP defined in mode 3.
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call dnaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dnaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          dnaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3 and 4, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) real and imaginary parts
-c                    of the shifts where INPTR(14) is the pointer
-c                    into WORKL for placing the shifts. See Remark
-c                    5 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Double precision  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = DLAMCH ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine DLAMCH ).
-c
-c  RESID   Double precision  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 2 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x.
-c          NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz
-c          values are kept together. (See remark 4 below)
-c
-c  V       Double precision  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The real and imaginary
-c                      parts of the NCV eigenvalues of the Hessenberg
-c                      matrix H are returned in the part of the WORKL
-c                      array corresponding to RITZR and RITZI. See remark
-c                      5 below.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of approximate Schur
-c                      vectors associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4; See under \Description of dnaupd  for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), dnaupd  returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          5 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix
-c                    H in WORKL.
-c          IPNTR(6): pointer to the real part of the ritz value array
-c                    RITZR in WORKL.
-c          IPNTR(7): pointer to the imaginary part of the ritz value array
-c                    RITZI in WORKL.
-c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZR and RITZI in WORKL.
-c
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by dneupd . See Remark 2 below.
-c
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     dneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace
-c          associated with the converged Ritz values is desired, see remark
-c          2 below, subroutine dneupd  uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 6*NCV.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when
-c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the
-c     original problem may be obtained with the ARPACK subroutine dneupd .
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call dneupd  immediately following
-c     completion of dnaupd . This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV + 2.
-c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) real and imaginary parts of the shifts in locations
-c         real part                  imaginary part
-c         -----------------------    --------------
-c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)
-c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)
-c                        .                          .
-c                        .                          .
-c                        .                          .
-c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).
-c
-c     Only complex conjugate pairs of shifts may be applied and the pairs
-c     must be placed in consecutive locations. The real part of the
-c     eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part
-c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered
-c     according to the order defined by WHICH. The complex conjugate
-c     pairs are kept together and the associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Double precision  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Double precision   resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     dnaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version '1.1'
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Double precision
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritzi, ritzr, j
-      save       bounds, ih, iq, ishift, iupd, iw, ldh, ldq,
-     &           levec, mode, msglvl, mxiter, nb, nev0, next,
-     &           np, ritzi, ritzr
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dnaup2 , dvout , ivout, arscnd, dstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call dstatn
-         call arscnd (t0)
-         msglvl = mnaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 4) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. zero)			tol = dlamch ('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 6*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |
-c        |                                   parts of ritz values      |
-c        | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |
-c        | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |
-c        | The final workspace is needed by subroutine dneigh  called   |
-c        | by dnaup2 . Subroutine dneigh  calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritzr  = ih     + ldh*ncv
-         ritzi  = ritzr  + ncv
-         bounds = ritzi  + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritzr
-         ipntr(7) = ritzi
-         ipntr(8) = bounds
-         ipntr(14) = iw
-c
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call dnaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritzr),
-     &     workl(ritzi), workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within dnaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call dvout  (logfil, np, workl(ritzr), ndigit,
-     &               '_naupd: Real part of the final Ritz values')
-         call dvout  (logfil, np, workl(ritzi), ndigit,
-     &               '_naupd: Imaginary part of the final Ritz values')
-         call dvout  (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tnaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tnaupd, tnaup2, tnaitr, titref,
-     &                  tgetv0, tneigh, tngets, tnapps, tnconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Nonsymmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number: ', ' 2.4' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dnaupd  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnconv.f b/libcruft/arpack/src/dnconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnconv.f
+++ /dev/null
@@ -1,146 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnconv
-c
-c\Description: 
-c  Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call dnconv
-c     ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZR,  Double precision arrays of length N.  (INPUT)
-c  RITZI   Real and imaginary parts of the Ritz values to be checked
-c          for convergence.
-
-c  BOUNDS  Double precision array of length N.  (INPUT)
-c          Ritz estimates for the Ritz values in RITZR and RITZI.
-c
-c  TOL     Double precision scalar.  (INPUT)
-c          Desired backward error for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnconv (n, ritzr, ritzi, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-
-      Double precision
-     &           ritzr(n), ritzi(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Double precision
-     &           temp, eps23
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2, dlamch
-      external   dlapy2, dlamch
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------------------------------------%
-c     | Convergence test: unlike in the symmetric code, I am not    |
-c     | using things like refined error bounds and gap condition    |
-c     | because I don't know the exact equivalent concept.          |
-c     |                                                             |
-c     | Instead the i-th Ritz value is considered "converged" when: |
-c     |                                                             |
-c     |     bounds(i) .le. ( TOL * | ritz | )                       |
-c     |                                                             |
-c     | for some appropriate choice of norm.                        |
-c     %-------------------------------------------------------------%
-c
-      call arscnd (t0)
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-      nconv  = 0
-      do 20 i = 1, n
-         temp = max( eps23, dlapy2( ritzr(i), ritzi(i) ) )
-         if (bounds(i) .le. tol*temp)   nconv = nconv + 1
-   20 continue
-c 
-      call arscnd (t1)
-      tnconv = tnconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of dnconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dneigh.f b/libcruft/arpack/src/dneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/dneigh.f
+++ /dev/null
@@ -1,314 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call dneigh
-c     ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Double precision N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Double precision arrays of length N.  (OUTPUT)
-c  RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real 
-c          (respectively imaginary) parts of the eigenvalues of H.
-c
-c  BOUNDS  Double precision array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues RITZR and RITZI.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZR and RITZI.
-c
-c  Q       Double precision N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from dlaqrb or dtrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dlaqrb  ARPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix and last row of the Schur vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dtrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c     dscal   Level 1 BLAS that scales a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dneigh (rnorm, n, h, ldh, ritzr, ritzi, bounds, 
-     &                   q, ldq, workl, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Double precision     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritzi(n), ritzr(n),
-     &           workl(n*(n+3))
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision     
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    i, iconj, msglvl
-      Double precision     
-     &           temp, vl(1)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dlacpy, dlaqrb, dtrevc, dvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2, dnrm2
-      external   dlapy2, dnrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mneigh
-c 
-      if (msglvl .gt. 2) then
-          call dmout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %-----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the    |
-c     |    corresponding Schur vectors and the full Schur form T  |
-c     |    of the current upper Hessenberg matrix H.              |
-c     | dlaqrb returns the full Schur form of H in WORKL(1:N**2)  |
-c     | and the last components of the Schur vectors in BOUNDS.   |
-c     %-----------------------------------------------------------%
-c
-      call dlacpy ('All', n, n, h, ldh, workl, n)
-      call dlaqrb (.true., n, 1, n, workl, n, ritzr, ritzi, bounds,
-     &             ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and  |
-c     |    apply the last components of the Schur vectors to get  |
-c     |    the last components of the corresponding eigenvectors. |
-c     | Remember that if the i-th and (i+1)-st eigenvalues are    |
-c     | complex conjugate pairs, then the real & imaginary part   |
-c     | of the eigenvector components are split across adjacent   |
-c     | columns of Q.                                             |
-c     %-----------------------------------------------------------%
-c
-      call dtrevc ('R', 'A', select, n, workl, n, vl, n, q, ldq,
-     &             n, n, workl(n*n+1), ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | euclidean norms are all one. LAPACK subroutine |
-c     | dtrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      iconj = 0
-      do 10 i=1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            temp = dnrm2( n, q(1,i), 1 )
-            call dscal ( n, one / temp, q(1,i), 1 )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we further normalize by the      |
-c           | square root of two.                       |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               temp = dlapy2( dnrm2( n, q(1,i), 1 ), 
-     &                        dnrm2( n, q(1,i+1), 1 ) )
-               call dscal ( n, one / temp, q(1,i), 1 )
-               call dscal ( n, one / temp, q(1,i+1), 1 )
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if         
-   10 continue
-c
-      call dgemv ('T', n, n, one, q, ldq, bounds, 1, zero, workl, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      iconj = 0
-      do 20 i = 1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            bounds(i) = rnorm * abs( workl(i) )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we need to take the magnitude    |
-c           | of the last components of the two vectors |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               bounds(i) = rnorm * dlapy2( workl(i), workl(i+1) )
-               bounds(i+1) = bounds(i)
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   20 continue
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, n, ritzr, ndigit,
-     &              '_neigh: Real part of the eigenvalues of H')
-         call dvout (logfil, n, ritzi, ndigit,
-     &              '_neigh: Imaginary part of the eigenvalues of H')
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd (t1)
-      tneigh = tneigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dneupd.f b/libcruft/arpack/src/dneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dneupd.f
+++ /dev/null
@@ -1,1068 +0,0 @@
-c\BeginDoc
-c
-c\Name: dneupd 
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to DNAUPD .  DNAUPD  must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.  The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  See documentation in the header of the subroutine DNAUPD  for 
-c  definition of OP as well as other terms and the relation of computed
-c  Ritz values and Ritz vectors of OP with respect to the given problem
-c  A*z = lambda*B*z.  For a brief description, see definitions of 
-c  IPARAM(7), MODE and WHICH in the documentation of DNAUPD .
-c
-c\Usage:
-c  call dneupd  
-c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, 
-c       LWORKL, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether a basis for the invariant subspace corresponding 
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.
-c                                See Remarks below. 
-c 
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors; 
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.
-c
-c  DR      Double precision  array of dimension NEV+1.  (OUTPUT)
-c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains 
-c          the real part of the Ritz  approximations to the eigenvalues of 
-c          A*z = lambda*B*z. 
-c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:
-c          DR contains the real part of the Ritz values of OP computed by 
-c          DNAUPD . A further computation must be performed by the user
-c          to transform the Ritz values computed for OP by DNAUPD  to those
-c          of the original system A*z = lambda*B*z. See remark 3 below.
-c
-c  DI      Double precision  array of dimension NEV+1.  (OUTPUT)
-c          On exit, DI contains the imaginary part of the Ritz value 
-c          approximations to the eigenvalues of A*z = lambda*B*z associated
-c          with DR.
-c
-c          NOTE: When Ritz values are complex, they will come in complex 
-c                conjugate pairs.  If eigenvectors are requested, the 
-c                corresponding Ritz vectors will also come in conjugate 
-c                pairs and the real and imaginary parts of these are 
-c                represented in two consecutive columns of the array Z 
-c                (see below).
-c
-c  Z       Double precision  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represent approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem 
-c          A*z = lambda*B*z. 
-c 
-c          The complex Ritz vector associated with the Ritz value 
-c          with positive imaginary part is stored in two consecutive 
-c          columns.  The first column holds the real part of the Ritz 
-c          vector and the second column holds the imaginary part.  The 
-c          Ritz vector associated with the Ritz value with negative 
-c          imaginary part is simply the complex conjugate of the Ritz vector 
-c          associated with the positive imaginary part.
-c
-c          If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by DNAUPD .  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.
-c
-c  SIGMAR  Double precision   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the real part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  SIGMAI  Double precision   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.
-c
-c  WORKEV  Double precision  work array of dimension 3*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to DNAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to DNEUPD  following the last call
-c         to DNAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to DNAUPD  and the call to DNEUPD .
-c
-c  Three of these parameters (V, WORKL, INFO) are also output parameters:
-c
-c  V       Double precision  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by DNAUPD  .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.  See Remark 2 below.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in
-c          dnaupd .  They are not changed by dneupd .
-c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the
-c          real and imaginary part of the untransformed Ritz values,
-c          the upper quasi-triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by dneupd .
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     dneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine dlahqr 
-c                could not be reordered by LAPACK routine dtrsen .
-c                Re-enter subroutine dneupd  with IPARAM(5)=NCV and 
-c                increase the size of the arrays DR and DI to have 
-c                dimension at least dimension NCV and allocate at least NCV 
-c                columns for Z. NOTE: Not necessary if Z and V share 
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine dlahqr .
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine dtrevc .
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: DNAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: DNEUPD got a different count of the number of converged
-c                 Ritz values than DNAUPD got.  This indicates the user
-c                 probably made an error in passing data from DNAUPD to
-c                 DNEUPD or that the data was modified before entering
-c                 DNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     dmout    ARPACK utility routine that prints matrices
-c     dvout    ARPACK utility routine that prints vectors.
-c     dgeqr2   LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     dlacpy   LAPACK matrix copy routine.
-c     dlahqr   LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlaset   LAPACK matrix initialization routine.
-c     dorm2r   LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     dtrevc   LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form.
-c     dtrsen   LAPACK routine that re-orders the Schur form.
-c     dtrmm    Level 3 BLAS matrix times an upper triangular matrix.
-c     dger     Level 2 BLAS rank one update to a matrix.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     ddot     Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dscal    Level 1 BLAS that scales a vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c     Let trans(X) denote the transpose of X.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .TRUE. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately 
-c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the 
-c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,
-c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; 
-c     each 2-by-2 diagonal block has its diagonal elements equal and its
-c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
-c     diagonal block is a complex conjugate pair of Ritz values. The real
-c     Ritz values are stored on the diagonal of T.
-c
-c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must
-c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz
-c     values computed by DNAUPD  for OP to those of A*z = lambda*B*z. 
-c     Set RVEC = .true. and HOWMNY = 'A', and
-c     compute 
-c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.
-c     If DI(I) is not equal to zero and DI(I+1) = - D(I), 
-c     then the desired real and imaginary parts of the Ritz value are
-c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),
-c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I), 
-c     respectively.
-c     Another possibility is to set RVEC = .true. and HOWMNY = 'P' and
-c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper
-c     quasi-triangular matrix of order IPARAM(5) is computed. See remark
-c     2 above.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics          
-c     Rice University           
-c     Houston, Texas            
-c 
-c\SCCS Information: @(#) 
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine dneupd (rvec , howmny, select, dr    , di,    
-     &                   z    , ldz   , sigmar, sigmai, workev,
-     &                   bmat , n     , which , nev   , tol,
-     &                   resid, ncv   , v     , ldv   , iparam,
-     &                   ipntr, workd , workl , lworkl, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Double precision      
-     &           sigmar, sigmai, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Double precision 
-     &           dr(nev+1)    , di(nev+1), resid(n)  , 
-     &           v(ldv,ncv)   , z(ldz,*) , workd(3*n), 
-     &           workl(lworkl), workev(3*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision 
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds   , 
-     &           iheigr, iheigi, iconj , nconv   , 
-     &           invsub, iuptri, iwev  , iwork(1),
-     &           j     , k     , ldh   , ldq     ,
-     &           mode  , msglvl, outncv, ritzr   ,
-     &           ritzi , wri   , wrr   , irr     ,
-     &           iri   , ibd   , ishift, numcnv  ,
-     &           np    , jj    , nconv2
-      logical    reord
-      Double precision 
-     &           conds  , rnorm, sep  , temp,
-     &           vl(1,1), temp1, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dger   , dgeqr2 , dlacpy , 
-     &           dlahqr , dlaset , dmout  , dorm2r , 
-     &           dtrevc , dtrmm  , dtrsen , dscal  , 
-     &           dvout  , ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dlapy2 , dnrm2 , dlamch , ddot 
-      external   dlapy2 , dnrm2 , dlamch , ddot 
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, min, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mneupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 .and. sigmai .eq. zero) then
-         type = 'SHIFTI'
-      else if (mode .eq. 3 ) then
-         type = 'REALPT'
-      else if (mode .eq. 4 ) then
-         type = 'IMAGPT'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |
-c     |                                   parts of ritz values |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by DNEUPD .                  |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                             real part of the Ritz values. |
-c     | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |
-c     |                        imaginary part of the Ritz values. |
-c     | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |
-c     |                           error bounds of the Ritz values |
-c     | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |
-c     |                             quasi-triangular matrix for H |
-c     | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |
-c     |       associated matrix representation of the invariant   |
-c     |       subspace for H.                                     |
-c     | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritzr  = ipntr(6)
-      ritzi  = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheigr = bounds + ldh
-      iheigi = iheigr + ldh
-      ihbds  = iheigi + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheigr
-      ipntr(10) = iheigi
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wrr = 1
-      wri = ncv + 1
-      iwev = wri + ncv
-c
-c     %-----------------------------------------%
-c     | irr points to the REAL part of the Ritz |
-c     |     values computed by _neigh before    |
-c     |     exiting _naup2.                     |
-c     | iri points to the IMAGINARY part of the |
-c     |     Ritz values computed by _neigh      |
-c     |     before exiting _naup2.              |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irr = ipntr(14)+ncv*ncv
-      iri = irr+ncv
-      ibd = iri+ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, ncv, workl(irr), ndigit,
-     &   '_neupd: Real part of Ritz values passed in from _NAUPD.')
-         call dvout (logfil, ncv, workl(iri), ndigit,
-     &   '_neupd: Imag part of Ritz values passed in from _NAUPD.')
-         call dvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c     
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call dngets (ishift       , which     , nev       , 
-     &                np           , workl(irr), workl(iri),
-     &                workl(bounds), workl     , workl(np+1))
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, ncv, workl(irr), ndigit,
-     &      '_neupd: Real part of Ritz values after calling _NGETS.')
-            call dvout (logfil, ncv, workl(iri), ndigit,
-     &      '_neupd: Imag part of Ritz values after calling _NGETS.')
-            call dvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23,
-     &                 dlapy2 ( workl(irr+ncv-j), workl(iri+ncv-j) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine dlahqr  to compute the real Schur form |
-c        | of the upper Hessenberg matrix returned by DNAUPD .        |
-c        | Make a copy of the upper Hessenberg matrix.               |
-c        | Initialize the Schur vector matrix Q to the identity.     |
-c        %-----------------------------------------------------------%
-c     
-         call dcopy (ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call dlaset ('All', ncv, ncv, 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call dlahqr (.true., .true.       , ncv, 
-     &                1     , ncv          , workl(iuptri), 
-     &                ldh   , workl(iheigr), workl(iheigi),
-     &                1     , ncv          , workl(invsub), 
-     &                ldq   , ierr)
-         call dcopy (ncv         , workl(invsub+ncv-1), ldq, 
-     &               workl(ihbds), 1)
-c     
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c     
-         if (msglvl .gt. 1) then
-            call dvout (logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H')
-            call dvout (logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imaginary part of the Eigenvalues of H')
-            call dvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call dmout (logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper quasi-triangular matrix ')
-            end if
-         end if 
-c
-         if (reord) then
-c     
-c           %-----------------------------------------------------%
-c           | Reorder the computed upper quasi-triangular matrix. | 
-c           %-----------------------------------------------------%
-c     
-            call dtrsen ('None'       , 'V'          , 
-     &                   select       , ncv          ,
-     &                   workl(iuptri), ldh          , 
-     &                   workl(invsub), ldq          , 
-     &                   workl(iheigr), workl(iheigi), 
-     &                   nconv2       , conds        ,
-     &                   sep          , workl(ihbds) , 
-     &                   ncv          , iwork        ,
-     &                   1            , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-
-            if (msglvl .gt. 2) then
-                call dvout (logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H--reordered')
-                call dvout (logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imag part of the eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call dmout (logfil       , ncv, ncv   , 
-     &                         workl(iuptri), ldq, ndigit,
-     &             '_neupd: Quasi-triangular matrix after re-ordering')
-                end if
-            end if
-c     
-         end if
-c
-c        %---------------------------------------%
-c        | Copy the last row of the Schur vector |
-c        | into workl(ihbds).  This will be used |
-c        | to compute the Ritz estimates of      |
-c        | converged Ritz values.                |
-c        %---------------------------------------%
-c
-         call dcopy (ncv, workl(invsub+ncv-1), ldq, workl(ihbds), 1)
-c
-c        %----------------------------------------------------%
-c        | Place the computed eigenvalues of H into DR and DI |
-c        | if a spectral transformation was not used.         |
-c        %----------------------------------------------------%
-c
-         if (type .eq. 'REGULR') then 
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-         end if
-c     
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c     
-         call dgeqr2 (ncv, nconv , workl(invsub), 
-     &               ldq, workev, workev(ncv+1),
-     &               ierr)
-c
-c        %---------------------------------------------------------%
-c        | * Postmultiply V by Q using dorm2r .                     |   
-c        | * Copy the first NCONV columns of VQ into Z.            |
-c        | * Postmultiply Z by R.                                  |
-c        | The N by NCONV matrix Z is now a matrix representation  |
-c        | of the approximate invariant subspace associated with   |
-c        | the Ritz values in workl(iheigr) and workl(iheigi)      |
-c        | The first NCONV columns of V are now approximate Schur  |
-c        | vectors associated with the real upper quasi-triangular |
-c        | matrix of order NCONV in workl(iuptri)                  |
-c        %---------------------------------------------------------%
-c     
-         call dorm2r ('Right', 'Notranspose', n            , 
-     &                ncv   , nconv        , workl(invsub),
-     &                ldq   , workev       , v            , 
-     &                ldv   , workd(n+1)   , ierr)
-         call dlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c     
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | quasi-triangular form of workl(iuptri,ldq)        |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones           |
-c           %---------------------------------------------------%
-c     
-            if (workl(invsub+(j-1)*ldq+j-1) .lt. zero) then
-               call dscal (nconv, -one, workl(iuptri+j-1), ldq)
-               call dscal (nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c     
- 20      continue
-c     
-         if (howmny .eq. 'A') then
-c     
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T | 
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c     
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call dtrevc ('Right', 'Select'     , select       , 
-     &                   ncv    , workl(iuptri), ldq          , 
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c     
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | dtrevc  returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1;                                   |
-c           %------------------------------------------------%
-c     
-            iconj = 0
-            do 40 j=1, nconv
-c
-               if ( workl(iheigi+j-1) .eq. zero ) then
-c     
-c                 %----------------------%
-c                 | real eigenvalue case |
-c                 %----------------------%
-c     
-                  temp = dnrm2 ( ncv, workl(invsub+(j-1)*ldq), 1 )
-                  call dscal ( ncv, one / temp, 
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-               else
-c     
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 | columns, we further normalize by the      |
-c                 | square root of two.                       |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     temp = dlapy2 (dnrm2 (ncv, 
-     &                                   workl(invsub+(j-1)*ldq), 
-     &                                   1),
-     &                             dnrm2 (ncv, 
-     &                                   workl(invsub+j*ldq),
-     &                                   1))  
-                     call dscal (ncv, one/temp, 
-     &                           workl(invsub+(j-1)*ldq), 1 )
-                     call dscal (ncv, one/temp, 
-     &                           workl(invsub+j*ldq), 1 )
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-c
-               end if
-c
- 40         continue
-c
-            call dgemv ('T', ncv, nconv, one, workl(invsub),
-     &                 ldq, workl(ihbds), 1, zero,  workev, 1)
-c
-            iconj = 0
-            do 45 j=1, nconv
-               if (workl(iheigi+j-1) .ne. zero) then
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     workev(j) = dlapy2 (workev(j), workev(j+1))
-                     workev(j+1) = workev(j)
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-               end if
- 45         continue
-c
-            if (msglvl .gt. 2) then
-               call dcopy (ncv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call dvout (logfil, ncv, workl(ihbds), ndigit,
-     &              '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call dmout (logfil, ncv, ncv, workl(invsub), ldq, 
-     &                 ndigit, '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call dcopy (nconv, workev, 1, workl(ihbds), 1)
-c
-c           %---------------------------------------------------------%
-c           | Compute the QR factorization of the eigenvector matrix  |
-c           | associated with leading portion of T in the first NCONV |
-c           | columns of workl(invsub,ldq).                           |
-c           %---------------------------------------------------------%
-c     
-            call dgeqr2 (ncv, nconv , workl(invsub), 
-     &                   ldq, workev, workev(ncv+1),
-     &                   ierr)
-c     
-c           %----------------------------------------------%
-c           | * Postmultiply Z by Q.                       |   
-c           | * Postmultiply Z by R.                       |
-c           | The N by NCONV matrix Z is now contains the  | 
-c           | Ritz vectors associated with the Ritz values |
-c           | in workl(iheigr) and workl(iheigi).          |
-c           %----------------------------------------------%
-c     
-            call dorm2r ('Right', 'Notranspose', n            ,
-     &                   ncv  , nconv        , workl(invsub),
-     &                   ldq  , workev       , z            ,
-     &                   ldz  , workd(n+1)   , ierr)
-c     
-            call dtrmm ('Right'   , 'Upper'       , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-c     
-         end if
-c     
-      else 
-c
-c        %------------------------------------------------------%
-c        | An approximate invariant subspace is not needed.     |
-c        | Place the Ritz values computed DNAUPD  into DR and DI |
-c        %------------------------------------------------------%
-c
-         call dcopy (nconv, workl(ritzr), 1, dr, 1)
-         call dcopy (nconv, workl(ritzi), 1, di, 1)
-         call dcopy (nconv, workl(ritzr), 1, workl(iheigr), 1)
-         call dcopy (nconv, workl(ritzi), 1, workl(iheigi), 1)
-         call dcopy (nconv, workl(bounds), 1, workl(ihbds), 1)
-      end if
-c 
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call dscal (ncv, rnorm, workl(ihbds), 1)     
-c     
-      else 
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then
-c
-            if (rvec) 
-     &         call dscal (ncv, rnorm, workl(ihbds), 1)
-c
-            do 50 k=1, ncv
-               temp = dlapy2 ( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(ihbds+k-1) = abs( workl(ihbds+k-1) ) 
-     &                          / temp / temp
- 50         continue
-c
-         else if (type .eq. 'REALPT') then
-c
-            do 60 k=1, ncv
- 60         continue
-c
-         else if (type .eq. 'IMAGPT') then
-c
-            do 70 k=1, ncv
- 70         continue
-c
-         end if
-c     
-c        %-----------------------------------------------------------%
-c        | *  Transform the Ritz values back to the original system. |
-c        |    For TYPE = 'SHIFTI' the transformation is              |
-c        |             lambda = 1/theta + sigma                      |
-c        |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |
-c        |    Rayleigh quotients or a projection. See remark 3 above.| 
-c        | NOTES:                                                    |
-c        | *The Ritz vectors are not affected by the transformation. |
-c        %-----------------------------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               temp = dlapy2 ( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(iheigr+k-1) = workl(iheigr+k-1)/temp/temp 
-     &                           + sigmar   
-               workl(iheigi+k-1) = -workl(iheigi+k-1)/temp/temp
-     &                           + sigmai   
- 80         continue
-c
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-c
-         else if (type .eq. 'REALPT' .or. type .eq. 'IMAGPT') then
-c
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-c
-         end if
-c
-      end if
-c
-      if (type .eq. 'SHIFTI' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, dr, ndigit,
-     &   '_neupd: Untransformed real part of the Ritz valuess.')
-         call dvout  (logfil, nconv, di, ndigit,
-     &   '_neupd: Untransformed imag part of the Ritz valuess.')
-         call dvout (logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Ritz estimates of untransformed Ritz values.')
-      else if (type .eq. 'REGULR' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, dr, ndigit,
-     &   '_neupd: Real parts of converged Ritz values.')
-         call dvout  (logfil, nconv, di, ndigit,
-     &   '_neupd: Imag parts of converged Ritz values.')
-         call dvout (logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Associated Ritz estimates.')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 2.                                   |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta. Remember that when theta  |
-c        | has nonzero imaginary part, the corresponding  |
-c        | Ritz vector is stored across two columns of Z. |
-c        %------------------------------------------------%
-c
-         iconj = 0
-         do 110 j=1, nconv
-            if (workl(iheigi+j-1) .eq. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheigr+j-1)
-            else if (iconj .eq. 0) then
-               temp = dlapy2 ( workl(iheigr+j-1), workl(iheigi+j-1) )
-               workev(j) = ( workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                       workl(iheigr+j-1) +
-     &                       workl(invsub+j*ldq+ncv-1) * 
-     &                       workl(iheigi+j-1) ) / temp / temp
-               workev(j+1) = ( workl(invsub+j*ldq+ncv-1) * 
-     &                         workl(iheigr+j-1) -
-     &                         workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                         workl(iheigi+j-1) ) / temp / temp
-               iconj = 1
-            else
-               iconj = 0
-            end if
- 110     continue
-c
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call dger (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of DNEUPD  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dngets.f b/libcruft/arpack/src/dngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/dngets.f
+++ /dev/null
@@ -1,231 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call dngets
-c     ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest real part.
-c          'SR' -> want the KEV eigenvalues of smallest real part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV      Integer.  (INPUT/OUTPUT)
-c           INPUT: KEV+NP is the size of the matrix H.
-c           OUTPUT: Possibly increases KEV by one to keep complex conjugate
-c           pairs together.
-c
-c  NP       Integer.  (INPUT/OUTPUT)
-c           Number of implicit shifts to be computed.
-c           OUTPUT: Possibly decreases NP by one to keep complex conjugate
-c           pairs together.
-c
-c  RITZR,  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c  RITZI   On INPUT, RITZR and RITZI contain the real and imaginary 
-c          parts of the eigenvalues of H.
-c          On OUTPUT, RITZR and RITZI are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dsortc  ARPACK sorting routine.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dngets ( ishift, which, kev, np, ritzr, ritzi, bounds,
-     &                    shiftr, shifti )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(kev+np), ritzr(kev+np), ritzi(kev+np), 
-     &           shiftr(1), shifti(1)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0, zero = 0.0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dsortc, arscnd
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mngets
-c 
-c     %----------------------------------------------------%
-c     | LM, SM, LR, SR, LI, SI case.                       |
-c     | Sort the eigenvalues of H into the desired order   |
-c     | and apply the resulting order to BOUNDS.           |
-c     | The eigenvalues are sorted so that the wanted part |
-c     | are always in the last KEV locations.              |
-c     | We first do a pre-processing sort in order to keep |
-c     | complex conjugate pairs together                   |
-c     %----------------------------------------------------%
-c
-      if (which .eq. 'LM') then
-         call dsortc ('LR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SM') then
-         call dsortc ('SR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LR') then
-         call dsortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SR') then
-         call dsortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LI') then
-         call dsortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SI') then
-         call dsortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      end if
-c      
-      call dsortc (which, .true., kev+np, ritzr, ritzi, bounds)
-c     
-c     %-------------------------------------------------------%
-c     | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |
-c     | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |
-c     | Accordingly decrease NP by one. In other words keep   |
-c     | complex conjugate pairs together.                     |
-c     %-------------------------------------------------------%
-c     
-      if (       ( ritzr(np+1) - ritzr(np) ) .eq. zero
-     &     .and. ( ritzi(np+1) + ritzi(np) ) .eq. zero ) then
-         np = np - 1
-         kev = kev + 1
-      end if
-c
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when they shifts |
-c        | are applied in subroutine dnapps.                     |
-c        | Be careful and use 'SR' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call dsortc ( 'SR', .true., np, bounds, ritzr, ritzi )
-      end if
-c     
-      call arscnd (t1)
-      tngets = tngets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call dvout (logfil, kev+np, ritzr, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- real part')
-         call dvout (logfil, kev+np, ritzi, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- imag part')
-         call dvout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of dngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/dsaitr.f b/libcruft/arpack/src/dsaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsaitr.f
+++ /dev/null
@@ -1,853 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step symmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in dsaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call dsaitr
-c     ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and does not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of matrix B that defines the
-c          semi-inner product for the operator OP.  See dsaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current order of H and the number of columns of V.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  MODE    Integer.  (INPUT)
-c          Signifies which form for "OP". If MODE=2 then
-c          a reduction in the number of B matrix vector multiplies
-c          is possible since the B-norm of OP*x is equivalent to
-c          the inv(B)-norm of A*x.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          On INPUT the B-norm of r_{k}.
-c          On OUTPUT the B-norm of the updated residual r_{k+p}.
-c
-c  V       Double precision N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Double precision (K+NP) by 2 array.  (INPUT/OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          with the subdiagonal in the first column starting at H(2,1)
-c          and the main diagonal in the second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On INPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K step Arnoldi factorization. Used to save some 
-c          computation at the first step. 
-c          On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K+NP step Arnoldi factorization.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of an invariant subspace of OP is found that is
-c               less than K + NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     dmout   ARPACK utility routine that prints matrices.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     xx/xx/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in dsaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        alphaj <- j-th component of w_{j}
-c        rnorm = || r_{j} ||
-c        betaj+1 = rnorm
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaitr
-     &   (ido, bmat, n, k, np, mode, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, mode, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           h(ldh,2), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl, 
-     &           infol, jj
-      Double precision
-     &           rnorm1, wnorm, safmin, temp1
-      save       orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           rnorm1, safmin, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Double precision
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dgemv, dgetv0, dvout, dmout,
-     &           dlascl, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlamch
-      external   ddot, dnrm2, dlamch
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         first = .false.
-c
-c        %--------------------------------%
-c        | safmin = safe minimum is such  |
-c        | that 1/sfmin does not overflow |
-c        %--------------------------------%
-c
-         safmin = dlamch('safmin')
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-c 
-c        %--------------------------------%
-c        | Pointer to the current step of |
-c        | the factorization to build     |
-c        %--------------------------------%
-c
-         j      = k + 1
-c 
-c        %------------------------------------------%
-c        | Pointers used for reverse communication  |
-c        | when using WORKD.                        |
-c        %------------------------------------------%
-c
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true.                                  |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         dgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %------------------------------%
-c     | Else this is the first step. |
-c     %------------------------------%
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_saitr: generating Arnoldi vector no.')
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &                  '_saitr: B-norm of the current residual =')
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Check for exact zero. Equivalent to determing whether a |
-c        | j-step Arnoldi factorization is present.                |
-c        %---------------------------------------------------------%
-c
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_saitr: ****** restart at step ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call dgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tsaitr = tsaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call dcopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. safmin) then
-             temp1 = one / rnorm
-             call dscal (n, temp1, v(1,j), 1)
-             call dscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c 
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call dcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000
-   50    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |
-c        %-----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-c 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call dcopy (n, workd(irj), 1, resid, 1)
-c 
-c        %-------------------------------------------%
-c        | STEP 4:  Finish extending the symmetric   |
-c        |          Arnoldi to length j. If MODE = 2 |
-c        |          then B*OP = B*inv(B)*A = A and   |
-c        |          we don't need to compute B*OP.   |
-c        | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |
-c        | assumed to have A*v_{j}.                  |
-c        %-------------------------------------------%
-c
-         if (mode .eq. 2) go to 65
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-              call dcopy(n, resid, 1 , workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |
-c        %-----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-   65    continue
-         if (mode .eq. 2) then
-c
-c           %----------------------------------%
-c           | Note that the B-norm of OP*v_{j} |
-c           | is the inv(B)-norm of A*v_{j}.   |
-c           %----------------------------------%
-c
-            wnorm = ddot (n, resid, 1, workd(ivj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'G') then         
-            wnorm = ddot (n, resid, 1, workd(ipj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         if (mode .ne. 2 ) then
-            call dgemv('T', n, j, one, v, ldv, workd(ipj), 1, zero, 
-     &                  workd(irj), 1)
-         else if (mode .eq. 2) then
-            call dgemv('T', n, j, one, v, ldv, workd(ivj), 1, zero, 
-     &                  workd(irj), 1)
-         end if
-c
-c        %--------------------------------------%
-c        | Orthgonalize r_{j} against V_{j}.    |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call dgemv('N', n, j, -one, v, ldv, workd(irj), 1, one, 
-     &               resid, 1)
-c
-c        %--------------------------------------%
-c        | Extend H to have j rows and columns. |
-c        %--------------------------------------%
-c
-         h(j,2) = workd(irj + j - 1)
-         if (j .eq. 1  .or.  rstart) then
-            h(j,1) = zero
-         else
-            h(j,1) = rnorm
-         end if
-         call arscnd (t4)
-c 
-         orth1 = .true.
-         iter  = 0
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = ddot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call dvout (logfil, 2, xtemp, ndigit, 
-     &           '_saitr: re-orthonalization ; wnorm and rnorm are')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %----------------------------------------------%
-c        | Compute the correction to the residual:      |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J) + |
-c        | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |
-c        | H(j,j) is updated.                           |
-c        %----------------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-c
-         if (j .eq. 1  .or.  rstart) h(j,1) = zero
-         h(j,2) = h(j,2) + workd(irj + j - 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = ddot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = dnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_saitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call dvout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c 
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %--------------------------------%
-c           | No need for further refinement |
-c           %--------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %----------------------------------------------------------%
-c        | Make sure the last off-diagonal element is non negative  |
-c        | If not perform a similarity transformation on H(1:j,1:j) |
-c        | and scale v(:,j) by -1.                                  |
-c        %----------------------------------------------------------%
-c
-         if (h(j,1) .lt. zero) then
-            h(j,1) = -h(j,1)
-            if ( j .lt. k+np) then 
-               call dscal(n, -one, v(1,j+1), 1)
-            else
-               call dscal(n, -one, resid, 1)
-            end if
-         end if
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tsaitr = tsaitr + (t1 - t0)
-            ido = 99
-c
-            if (msglvl .gt. 1) then
-               call dvout (logfil, k+np, h(1,2), ndigit, 
-     &         '_saitr: main diagonal of matrix H of step K+NP.')
-               if (k+np .gt. 1) then
-               call dvout (logfil, k+np-1, h(2,1), ndigit, 
-     &         '_saitr: sub diagonal of matrix H of step K+NP.')
-               end if
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsapps.f b/libcruft/arpack/src/dsapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsapps.f
+++ /dev/null
@@ -1,516 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP shifts implicitly resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix of order KEV+NP. Q is the product of 
-c  rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi 
-c  factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call dsapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. dimension of matrix A.
-c
-c  KEV     Integer.  (INPUT)
-c          INPUT: KEV+NP is the size of the input matrix H.
-c          OUTPUT: KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Double precision array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          INPUT: V contains the current KEV+NP Arnoldi vectors.
-c          OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors
-c          are in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (KEV+NP) by 2 array.  (INPUT/OUTPUT)
-c          INPUT: H contains the symmetric tridiagonal matrix of the
-c          Arnoldi factorization with the subdiagonal in the 1st column
-c          starting at H(2,1) and the main diagonal in the 2nd column.
-c          OUTPUT: H contains the updated tridiagonal matrix in the 
-c          KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length (N).  (INPUT/OUTPUT)
-c          INPUT: RESID contains the the residual vector r_{k+p}.
-c          OUTPUT: RESID is the updated residual vector rnew_{k}.
-c
-c  Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations during the bulge
-c          chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKD   Double precision work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers. 
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlaset  LAPACK matrix initialization routine.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: sapps.F   SID: 2.6   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the subblocks of
-c     the tridiagonal matrix H and not just to the submatrix that it 
-c     comes from. This routine assumes that the subdiagonal elements 
-c     of H that are stored in h(1:kev+np,1) are nonegative upon input
-c     and enforce this condition upon output. This version incorporates
-c     deflation. See code for documentation.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h(ldh,2), q(ldq,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, iend, istart, itop, j, jj, kplusp, msglvl
-      logical    first
-      Double precision
-     &           a1, a2, a3, a4, big, c, epsmch, f, g, r, s
-      save       epsmch, first
-c
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dlacpy, dlartg, dlaset, dvout, 
-     &           ivout, arscnd, dgemv
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         epsmch = dlamch('Epsilon-Machine')
-         first = .false.
-      end if
-      itop = 1
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msapps
-c 
-      kplusp = kev + np 
-c 
-c     %----------------------------------------------%
-c     | Initialize Q to the identity matrix of order |
-c     | kplusp used to accumulate the rotations.     |
-c     %----------------------------------------------%
-c
-      call dlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c 
-c     %----------------------------------------------------------%
-c     | Apply the np shifts implicitly. Apply each shift to the  |
-c     | whole matrix and not just to the submatrix from which it |
-c     | comes.                                                   |
-c     %----------------------------------------------------------%
-c
-      do 90 jj = 1, np
-c 
-         istart = itop
-c
-c        %----------------------------------------------------------%
-c        | Check for splitting and deflation. Currently we consider |
-c        | an off-diagonal element h(i+1,1) negligible if           |
-c        |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |
-c        | for i=1:KEV+NP-1.                                        |
-c        | If above condition tests true then we set h(i+1,1) = 0.  |
-c        | Note that h(1:KEV+NP,1) are assumed to be non negative.  |
-c        %----------------------------------------------------------%
-c
-   20    continue
-c
-c        %------------------------------------------------%
-c        | The following loop exits early if we encounter |
-c        | a negligible off diagonal element.             |
-c        %------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-            big   = abs(h(i,2)) + abs(h(i+1,2))
-            if (h(i+1,1) .le. epsmch*big) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_sapps: occured before shift number.')
-                  call dvout (logfil, 1, h(i+1,1), ndigit, 
-     &                 '_sapps: the corresponding off diagonal element')
-               end if
-               h(i+1,1) = zero
-               iend = i
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (istart .lt. iend) then
-c 
-c           %--------------------------------------------------------%
-c           | Construct the plane rotation G'(istart,istart+1,theta) |
-c           | that attempts to drive h(istart+1,1) to zero.          |
-c           %--------------------------------------------------------%
-c
-             f = h(istart,2) - shift(jj)
-             g = h(istart+1,1)
-             call dlartg (f, g, c, s, r)
-c 
-c            %-------------------------------------------------------%
-c            | Apply rotation to the left and right of H;            |
-c            | H <- G' * H * G,  where G = G(istart,istart+1,theta). |
-c            | This will create a "bulge".                           |
-c            %-------------------------------------------------------%
-c
-             a1 = c*h(istart,2)   + s*h(istart+1,1)
-             a2 = c*h(istart+1,1) + s*h(istart+1,2)
-             a4 = c*h(istart+1,2) - s*h(istart+1,1)
-             a3 = c*h(istart+1,1) - s*h(istart,2) 
-             h(istart,2)   = c*a1 + s*a2
-             h(istart+1,2) = c*a4 - s*a3
-             h(istart+1,1) = c*a3 + s*a4
-c 
-c            %----------------------------------------------------%
-c            | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c            %----------------------------------------------------%
-c
-             do 60 j = 1, min(istart+jj,kplusp)
-                a1            =   c*q(j,istart) + s*q(j,istart+1)
-                q(j,istart+1) = - s*q(j,istart) + c*q(j,istart+1)
-                q(j,istart)   = a1
-   60        continue
-c
-c
-c            %----------------------------------------------%
-c            | The following loop chases the bulge created. |
-c            | Note that the previous rotation may also be  |
-c            | done within the following loop. But it is    |
-c            | kept separate to make the distinction among  |
-c            | the bulge chasing sweeps and the first plane |
-c            | rotation designed to drive h(istart+1,1) to  |
-c            | zero.                                        |
-c            %----------------------------------------------%
-c
-             do 70 i = istart+1, iend-1
-c 
-c               %----------------------------------------------%
-c               | Construct the plane rotation G'(i,i+1,theta) |
-c               | that zeros the i-th bulge that was created   |
-c               | by G(i-1,i,theta). g represents the bulge.   |
-c               %----------------------------------------------%
-c
-                f = h(i,1)
-                g = s*h(i+1,1)
-c
-c               %----------------------------------%
-c               | Final update with G(i-1,i,theta) |
-c               %----------------------------------%
-c
-                h(i+1,1) = c*h(i+1,1)
-                call dlartg (f, g, c, s, r)
-c
-c               %-------------------------------------------%
-c               | The following ensures that h(1:iend-1,1), |
-c               | the first iend-2 off diagonal of elements |
-c               | H, remain non negative.                   |
-c               %-------------------------------------------%
-c
-                if (r .lt. zero) then
-                   r = -r
-                   c = -c
-                   s = -s
-                end if
-c 
-c               %--------------------------------------------%
-c               | Apply rotation to the left and right of H; |
-c               | H <- G * H * G',  where G = G(i,i+1,theta) |
-c               %--------------------------------------------%
-c
-                h(i,1) = r
-c 
-                a1 = c*h(i,2)   + s*h(i+1,1)
-                a2 = c*h(i+1,1) + s*h(i+1,2)
-                a3 = c*h(i+1,1) - s*h(i,2)
-                a4 = c*h(i+1,2) - s*h(i+1,1)
-c 
-                h(i,2)   = c*a1 + s*a2
-                h(i+1,2) = c*a4 - s*a3
-                h(i+1,1) = c*a3 + s*a4
-c 
-c               %----------------------------------------------------%
-c               | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c               %----------------------------------------------------%
-c
-                do 50 j = 1, min( i+jj, kplusp )
-                   a1       =   c*q(j,i) + s*q(j,i+1)
-                   q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                   q(j,i)   = a1
-   50           continue
-c
-   70        continue
-c
-         end if
-c
-c        %--------------------------%
-c        | Update the block pointer |
-c        %--------------------------%
-c
-         istart = iend + 1
-c
-c        %------------------------------------------%
-c        | Make sure that h(iend,1) is non-negative |
-c        | If not then set h(iend,1) <-- -h(iend,1) |
-c        | and negate the last column of Q.         |
-c        | We have effectively carried out a        |
-c        | similarity on transformation H           |
-c        %------------------------------------------%
-c
-         if (h(iend,1) .lt. zero) then
-             h(iend,1) = -h(iend,1)
-             call dscal(kplusp, -one, q(1,iend), 1)
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any |
-c        %--------------------------------------------------------%
-c
-         if (iend .lt. kplusp) go to 20
-c
-c        %-----------------------------------------------------%
-c        | Check if we can increase the the start of the block |
-c        %-----------------------------------------------------%
-c
-         do 80 i = itop, kplusp-1
-            if (h(i+1,1) .gt. zero) go to 90
-            itop  = itop + 1
-   80    continue
-c
-c        %-----------------------------------%
-c        | Finished applying the jj-th shift |
-c        %-----------------------------------%
-c
-   90 continue
-c
-c     %------------------------------------------%
-c     | All shifts have been applied. Check for  |
-c     | more possible deflation that might occur |
-c     | after the last shift is applied.         |                               
-c     %------------------------------------------%
-c
-      do 100 i = itop, kplusp-1
-         big   = abs(h(i,2)) + abs(h(i+1,2))
-         if (h(i+1,1) .le. epsmch*big) then
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, i, ndigit, 
-     &              '_sapps: deflation at row/column no.')
-               call dvout (logfil, 1, h(i+1,1), ndigit, 
-     &              '_sapps: the corresponding off diagonal element')
-            end if
-            h(i+1,1) = zero
-         end if
- 100  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is not necessary if h(kev+1,1) = 0.         |
-c     %-------------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &   call dgemv ('N', n, kplusp, one, v, ldv,
-     &                q(1,kev+1), 1, zero, workd(n+1), 1)
-c 
-c     %-------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order    |
-c     | taking advantage that Q is an upper triangular matrix |    
-c     | with lower bandwidth np.                              |
-c     | Place results in v(:,kplusp-kev:kplusp) temporarily.  |
-c     %-------------------------------------------------------%
-c
-      do 130 i = 1, kev
-         call dgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call dcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  130 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call dlacpy ('All', n, kev, v(1,np+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the |
-c     | appropriate place if h(kev+1,1) .ne. zero. |
-c     %--------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &     call dcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call dscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,1) .gt. zero) 
-     &   call daxpy (n, h(kev+1,1), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, 1, q(kplusp,kev), ndigit, 
-     &      '_sapps: sigmak of the updated residual vector')
-         call dvout (logfil, 1, h(kev+1,1), ndigit, 
-     &      '_sapps: betak of the updated residual vector')
-         call dvout (logfil, kev, h(1,2), ndigit, 
-     &      '_sapps: updated main diagonal of H for next iteration')
-         if (kev .gt. 1) then
-         call dvout (logfil, kev-1, h(2,1), ndigit, 
-     &      '_sapps: updated sub diagonal of H for next iteration')
-         end if
-      end if
-c
-      call arscnd (t1)
-      tsapps = tsapps + (t1 - t0)
-c 
- 9000 continue 
-      return
-c
-c     %---------------%
-c     | End of dsapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsaup2.f b/libcruft/arpack/src/dsaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsaup2.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaup2
-c
-c\Description: 
-c  Intermediate level interface called by dsaupd.
-c
-c\Usage:
-c  call dsaup2 
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dsaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in dsaupd.
-c  
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during 
-c          each Arnoldi/Lanczos iteration.  
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration 
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector 
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Tridiagonal matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number 
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Double precision N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Double precision (NEV+NP) by 2 array.  (OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          The subdiagonal is stored in the first column of H starting 
-c          at H(2,1).  The main diagonal is stored in the arscnd column
-c          of H starting at H(1,2). If dsaup2 converges store the 
-c          B-norm of the final residual vector in H(1,1).
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  RITZ    Double precision array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV) contains the computed Ritz values of OP.
-c
-c  BOUNDS  Double precision array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.
-c
-c  Q       Double precision (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the 
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c          
-c  WORKL   Double precision array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in the computation of the 
-c          tridiagonal eigenvalue problem, the calculation and
-c          application of the shifts and convergence checking.
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations
-c          of WORKL are used in reverse communication to hold the user 
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for 
-c          vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in one of  
-c                    the spectral transformation modes.  X is the current
-c                    operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Lanczos iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in dsaupd.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: All possible eigenvalues of OP has been found.  
-c                   NP returns the size of the invariant subspace
-c                   spanning the operator OP. 
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from trid. eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Lanczos factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Routines called:
-c     dgetv0  ARPACK initial vector generation routine. 
-c     dsaitr  ARPACK Lanczos factorization routine.
-c     dsapps  ARPACK application of implicit shifts routine.
-c     dsconv  ARPACK convergence of Ritz values routine.
-c     dseigt  ARPACK compute Ritz values and error bounds routine.
-c     dsgets  ARPACK reorder Ritz values and error bounds routine.
-c     dsortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c     xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)
-c
-c\SCCS Information: @(#) 
-c FILE: saup2.F   SID: 2.7   DATE OF SID: 5/19/98   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd, 
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds, 
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
-     &           n, mode, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           bounds(nev+np), h(ldh,2), q(ldq,nev+np), resid(n), 
-     &           ritz(nev+np), v(ldv,nev+np), workd(3*n), 
-     &           workl(3*(nev+np))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm, getv0, initv, update, ushift
-      integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0, 
-     &           np0, nptemp, nevd2, nevm2, kp(3) 
-      Double precision
-     &           rnorm, temp, eps23
-      save       cnorm, getv0, initv, update, ushift,
-     &           iter, kplusp, msglvl, nconv, nev0, np0,
-     &           rnorm, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dgetv0, dsaitr, dscal, dsconv, dseigt, dsgets, 
-     &           dsapps, dsortr, dvout, ivout, arscnd, dswap
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlamch
-      external   ddot, dnrm2, dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaup2
-c
-c        %---------------------------------%
-c        | Set machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = dlamch('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0/3.0D+0)
-c
-c        %-------------------------------------%
-c        | nev0 and np0 are integer variables  |
-c        | hold the initial values of NEV & NP |
-c        %-------------------------------------%
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev0 + np0
-         nconv  = 0
-         iter   = 0
-c 
-c        %--------------------------------------------%
-c        | Set flags for computing the first NEV steps |
-c        | of the Lanczos factorization.              |
-c        %--------------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c        %--------------------------------------------%
-c        | User provides the initial residual vector. |
-c        %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c 
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call dgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. | 
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1200
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c 
-c     %------------------------------------------------------------%
-c     | Back from reverse communication: continue with update step |
-c     %------------------------------------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c 
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Lanczos factorization |
-c     %----------------------------------------------------------%
-c
-      call dsaitr (ido, bmat, n, 0, nev0, mode, resid, rnorm, v, ldv, 
-     &             h, ldh, ipntr, workd, info)
-c 
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-c
-c        %-----------------------------------------------------%
-c        | dsaitr was unable to build an Lanczos factorization |
-c        | of length NEV0. INFO is returned with the size of   |
-c        | the factorization built. Exit main loop.            |
-c        %-----------------------------------------------------%
-c
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Lanczos     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c 
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit, 
-     &           '_saup2: **** Start of major iteration number ****')
-         end if
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit, 
-     &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, np, ndigit, 
-     &           '_saup2: Extend the Lanczos factorization by')
-         end if
-c 
-c        %------------------------------------------------------------%
-c        | Compute NP additional steps of the Lanczos factorization. |
-c        %------------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call dsaitr (ido, bmat, n, nev, np, mode, resid, rnorm, v, 
-     &                ldv, h, ldh, ipntr, workd, info)
-c 
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-c
-c           %-----------------------------------------------------%
-c           | dsaitr was unable to build an Lanczos factorization |
-c           | of length NEV0+NP0. INFO is returned with the size  |  
-c           | of the factorization built. Exit main loop.         |
-c           %-----------------------------------------------------%
-c
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &           '_saup2: Current B-norm of residual for factorization')
-         end if
-c 
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current symmetric tridiagonal matrix.           |
-c        %--------------------------------------------------------%
-c
-         call dseigt (rnorm, kplusp, h, ldh, ritz, bounds, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from _seigt.                       |
-c        %----------------------------------------------------%
-c
-         call dcopy(kplusp, ritz, 1, workl(kplusp+1), 1)
-         call dcopy(kplusp, bounds, 1, workl(2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The selection is based on the requested number of |
-c        | eigenvalues instead of the current NEV and NP to  |
-c        | prevent possible misconvergence.                  |
-c        | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |
-c        | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         call dsgets (ishift, which, nev, np, ritz, bounds, workl)
-c 
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call dcopy (nev, bounds(np+1), 1, workl(np+1), 1)
-         call dsconv (nev, ritz(np+1), workl(np+1), tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_saup2: NEV, NP, NCONV are')
-            call dvout (logfil, kplusp, ritz, ndigit,
-     &           '_saup2: The eigenvalues of H')
-            call dvout (logfil, kplusp, bounds, ndigit,
-     &          '_saup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c 
-         if ( (nconv .ge. nev0) .or. 
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c     
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP since we don't want to |
-c           | swap overlapping locations.                    |
-c           %------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %-----------------------------------------------------%
-c              | Both ends of the spectrum are requested.            |
-c              | Sort the eigenvalues into algebraically decreasing  |
-c              | order first then swap low end of the spectrum next  |
-c              | to high end in appropriate locations.               |
-c              | NOTE: when np < floor(nev/2) be careful not to swap |
-c              | overlapping locations.                              |
-c              %-----------------------------------------------------%
-c
-               wprime = 'SA'
-               call dsortr (wprime, .true., kplusp, ritz, bounds)
-               nevd2 = nev0 / 2
-               nevm2 = nev0 - nevd2 
-               if ( nev .gt. 1 ) then
-                  call dswap ( min(nevd2,np), ritz(nevm2+1), 1,
-     &                 ritz( max(kplusp-nevd2+1,kplusp-np+1) ), 1)
-                  call dswap ( min(nevd2,np), bounds(nevm2+1), 1,
-     &                 bounds( max(kplusp-nevd2+1,kplusp-np+1)), 1)
-               end if
-c
-            else
-c
-c              %--------------------------------------------------%
-c              | LM, SM, LA, SA case.                             |
-c              | Sort the eigenvalues of H into the an order that |
-c              | is opposite to WHICH, and apply the resulting    |
-c              | order to BOUNDS.  The eigenvalues are sorted so  |
-c              | that the wanted part are always within the first |
-c              | NEV locations.                                   |
-c              %--------------------------------------------------%
-c
-               if (which .eq. 'LM') wprime = 'SM'
-               if (which .eq. 'SM') wprime = 'LM'
-               if (which .eq. 'LA') wprime = 'SA'
-               if (which .eq. 'SA') wprime = 'LA'
-c
-               call dsortr (wprime, .true., kplusp, ritz, bounds)
-c
-            end if
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-               temp = max( eps23, abs(ritz(j)) )
-               bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LA'
-            call dsortr(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                temp = max( eps23, abs(ritz(j)) )
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %--------------------------------------------------%
-c           | Sort the "converged" Ritz values again so that   |
-c           | the "threshold" values and their associated Ritz |
-c           | estimates appear at the appropriate position in  |
-c           | ritz and bound.                                  |
-c           %--------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %------------------------------------------------%
-c              | Sort the "converged" Ritz values in increasing |
-c              | order.  The "threshold" values are in the      |
-c              | middle.                                        |
-c              %------------------------------------------------%
-c
-               wprime = 'LA'
-               call dsortr(wprime, .true., nconv, ritz, bounds)
-c
-            else
-c
-c              %----------------------------------------------%
-c              | In LM, SM, LA, SA case, sort the "converged" |
-c              | Ritz values according to WHICH so that the   |
-c              | "threshold" value appears at the front of    |
-c              | ritz.                                        |
-c              %----------------------------------------------%
-
-               call dsortr(which, .true., nconv, ritz, bounds)
-c
-            end if
-c
-c           %------------------------------------------%
-c           |  Use h( 1,1 ) as storage to communicate  |
-c           |  rnorm to _seupd if needed               |
-c           %------------------------------------------%
-c
-            h(1,1) = rnorm
-c
-            if (msglvl .gt. 1) then
-               call dvout (logfil, kplusp, ritz, ndigit,
-     &            '_saup2: Sorted Ritz values.')
-               call dvout (logfil, kplusp, bounds, ndigit,
-     &            '_saup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. | 
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. | 
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if (nconv .lt. nev .and. ishift .eq. 1) then
-c
-c           %---------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.    |
-c           | To prevent possible stagnation, adjust the number |
-c           | of Ritz values and the shifts.                    |
-c           %---------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min (nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 2) then
-               nev = 2
-            end if
-            np  = kplusp - nev
-c     
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c     
-            if (nevbef .lt. nev) 
-     &         call dsgets (ishift, which, nev, np, ritz, bounds,
-     &              workl)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_saup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_saup2: NEV and NP are')
-               call dvout (logfil, nev, ritz(np+1), ndigit,
-     &              '_saup2: "wanted" Ritz values.')
-               call dvout (logfil, nev, bounds(np+1), ndigit,
-     &              '_saup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-
-c 
-         if (ishift .eq. 0) then
-c
-c           %-----------------------------------------------------%
-c           | User specified shifts: reverse communication to     |
-c           | compute the shifts. They are returned in the first  |
-c           | NP locations of WORKL.                              |
-c           %-----------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c 
-c 
-c        %---------------------------------------------------------%
-c        | Move the NP shifts to the first NP locations of RITZ to |
-c        | free up WORKL.  This is for the non-exact shift case;   |
-c        | in the exact shift case, dsgets already handles this.   |
-c        %---------------------------------------------------------%
-c
-         if (ishift .eq. 0) call dcopy (np, workl, 1, ritz, 1)
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_saup2: The number of shifts to apply ')
-            call dvout (logfil, np, workl, ndigit,
-     &                  '_saup2: shifts selected')
-            if (ishift .eq. 1) then
-               call dvout (logfil, np, bounds, ndigit,
-     &                  '_saup2: corresponding Ritz estimates')
-             end if
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Apply the NP0 implicit shifts by QR bulge chasing.      |
-c        | Each shift is applied to the entire tridiagonal matrix. |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        | After dsapps is done, we have a Lanczos                 |
-c        | factorization of length NEV.                            |
-c        %---------------------------------------------------------%
-c
-         call dsapps (n, nev, np, ritz, v, ldv, h, ldh, resid, q, ldq,
-     &        workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to dsaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd, 1)
-         end if
-c 
-  100    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         if (bmat .eq. 'G') then         
-            rnorm = ddot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-  130    continue
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &      '_saup2: B-norm of residual for NEV factorization')
-            call dvout (logfil, nev, h(1,2), ndigit,
-     &           '_saup2: main diagonal of compressed H matrix')
-            call dvout (logfil, nev-1, h(2,1), ndigit,
-     &           '_saup2: subdiagonal of compressed H matrix')
-         end if
-c 
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c 
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c 
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tsaup2 = t1 - t0
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsaup2 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsaupd.f b/libcruft/arpack/src/dsaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsaupd.f
+++ /dev/null
@@ -1,690 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaupd
-c
-c\Description:
-c
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  Iteration.  For symmetric problems this reduces to a variant of the Lanczos
-c  method.  This method has been designed to compute approximations to a
-c  few eigenpairs of a linear operator OP that is real and symmetric
-c  with respect to a real positive semi-definite symmetric matrix B,
-c  i.e.
-c
-c       B*OP = (OP`)*B.
-c
-c  Another way to express this condition is
-c
-c       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
-c
-c  In the standard eigenproblem B is the identity matrix.
-c  ( A` denotes transpose of A)
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  dsaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x, A symmetric
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
-c           ===> OP = (inv[K - sigma*M])*M  and  B = M.
-c           ===> Shift-and-Invert mode
-c
-c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,
-c           KG symmetric indefinite
-c           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
-c           ===> Buckling mode
-c
-c  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
-c           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c           ===> Cayley transformed mode
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call dsaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dsaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          dsaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          (If Mode = 2 see remark 5 below)
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3,4 and 5, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) shifts where
-c                    IPNTR(11) is the pointer into WORKL for
-c                    placing the shifts. See remark 6 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Specify which of the Ritz values of OP to compute.
-c
-c          'LA' - compute the NEV largest (algebraic) eigenvalues.
-c          'SA' - compute the NEV smallest (algebraic) eigenvalues.
-c          'LM' - compute the NEV largest (in magnitude) eigenvalues.
-c          'SM' - compute the NEV smallest (in magnitude) eigenvalues.
-c          'BE' - compute NEV eigenvalues, half from each end of the
-c                 spectrum.  When NEV is odd, compute one more from the
-c                 high end than from the low end.
-c           (see remark 1 below)
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N.
-c
-c  TOL     Double precision  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
-c          If TOL .LE. 0. is passed a default is set:
-c          DEFAULT = DLAMCH ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine DLAMCH ).
-c
-c  RESID   Double precision  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V (less than or equal to N).
-c          This will indicate how many Lanczos vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Lanczos vectors are generated, the algorithm generates
-c          NCV-NEV Lanczos vectors at each subsequent update iteration.
-c          Most of the cost in generating each Lanczos vector is in the
-c          matrix-vector product OP*x. (See remark 4 below).
-c
-c  V       Double precision  N by NCV array.  (OUTPUT)
-c          The NCV columns of V contain the Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the current tridiagonal matrix T are returned in
-c                      the part of WORKL array corresponding to RITZ.
-c                      See remark 6 below.
-c          ISHIFT = 1: exact shifts with respect to the reduced
-c                      tridiagonal matrix T.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of Ritz vectors
-c                      associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = LEVEC
-c          No longer referenced. See remark 2 below.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4,5; See under \Description of dsaupd  for the
-c          five modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), dsaupd  returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          6 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 11.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
-c          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
-c          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZ in WORKL.
-c          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.
-c
-c          Note: IPNTR(8:10) is only referenced by dseupd . See Remark 2.
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     dseupd  if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
-c          subroutine dseupd  uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least NCV**2 + 8*NCV .
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iterations allowed
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array WORKL is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Informatinal error from LAPACK routine dsteqr .
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -13: NEV and WHICH = 'BE' are incompatable.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization. The user is advised to check that
-c                   enough workspace and array storage has been allocated.
-c
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in ascending
-c     algebraic order.  The computed Ritz values are approximate
-c     eigenvalues of OP.  The selection of WHICH should be made
-c     with this in mind when Mode = 3,4,5.  After convergence,
-c     approximate eigenvalues of the original problem may be obtained
-c     with the ARPACK subroutine dseupd .
-c
-c  2. If the Ritz vectors corresponding to the converged Ritz values
-c     are needed, the user must call dseupd  immediately following completion
-c     of dsaupd . This is new starting with version 2.1 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.   The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c
-c  5. If IPARAM(7) = 2 then in the Reverse commuication interface the user
-c     must do the following. When IDO = 1, Y = OP * X is to be computed.
-c     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
-c     must overwrite X with A*X. Y is then the solution to the linear set
-c     of equations B*Y = A*X.
-c
-c  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) shifts in locations:
-c     1   WORKL(IPNTR(11))
-c     2   WORKL(IPNTR(11)+1)
-c                        .
-c                        .
-c                        .
-c     NP  WORKL(IPNTR(11)+NP-1).
-c
-c     The eigenvalues of the current tridiagonal matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
-c     order defined by WHICH. The associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
-c  DECOMPOSE  D1(N), D2(N,NCV)
-c  ALIGN      RESID(I) with D1(I)
-c  ALIGN      V(I,J)   with D2(I,J)
-c  ALIGN      WORKD(I) with D1(I)     range (1:N)
-c  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
-c  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
-c  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c  Cray MPP syntax:
-c  ===============
-c  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
-c  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
-c     Transformations in a k-Step Arnoldi Method". In Preparation.
-c
-c\Routines called:
-c     dsaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     dstats   ARPACK routine that initialize timing and other statistics
-c             variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(11)
-      Double precision
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dsaup2 ,  dvout , ivout, arscnd, dstats
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call dstats
-         call arscnd (t0)
-         msglvl = msaupd
-c
-         ierr   = 0
-         ishift = iparam(1)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         if (n .le. 0) then
-            ierr = -1
-         else if (nev .le. 0) then
-            ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-            ierr = -3
-         end if
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-c
-         if (mxiter .le. 0)                     ierr = -4
-         if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LA' .and.
-     &       which .ne. 'SA' .and.
-     &       which .ne. 'BE')                   ierr = -5
-         if (bmat .ne. 'I' .and. bmat .ne. 'G') ierr = -6
-c
-         if (lworkl .lt. ncv**2 + 8*ncv)        ierr = -7
-         if (mode .lt. 1 .or. mode .gt. 5) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         else if (nev .eq. 1 .and. which .eq. 'BE') then
-                                                ierr = -13
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)                         nb = 1
-         if (tol .le. zero)                     tol = dlamch ('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, ncv**2 + 8*ncv
-            workl(j) = zero
- 10      continue
-c
-c        %-------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c        | etc... and the remaining workspace.                   |
-c        | Also update pointer to be used on output.             |
-c        | Memory is laid out as follows:                        |
-c        | workl(1:2*ncv) := generated tridiagonal matrix        |
-c        | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c        | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |
-c        | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |
-c        | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |
-c        %-------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + 2*ldh
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ncv**2
-         next   = iw     + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = bounds
-         ipntr(11) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Lanczos Iteration. |
-c     %-------------------------------------------------------%
-c
-      call dsaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw), ipntr, workd,
-     &     info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within dsaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_saupd: number of "converged" Ritz values')
-         call dvout  (logfil, np, workl(Ritz), ndigit,
-     &               '_saupd: final Ritz values')
-         call dvout  (logfil, np, workl(Bounds), ndigit,
-     &               '_saupd: corresponding error bounds')
-      end if
-c
-      call arscnd (t1)
-      tsaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tsaupd, tsaup2, tsaitr, titref,
-     &                  tgetv0, tseigt, tsgets, tsapps, tsconv
- 1000    format (//,
-     &      5x, '==========================================',/
-     &      5x, '= Symmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number:', ' 2.4' , 19x, ' =',/
-     &      5x, '= Version Date:  ', ' 07/31/96' , 14x, ' =',/
-     &      5x, '==========================================',/
-     &      5x, '= Summary of timing statistics           =',/
-     &      5x, '==========================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in saup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in trid eigenvalue subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dsaupd  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsconv.f b/libcruft/arpack/src/dsconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsconv.f
+++ /dev/null
@@ -1,138 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsconv
-c
-c\Description: 
-c  Convergence testing for the symmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call dsconv
-c     ( N, RITZ, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZ    Double precision array of length N.  (INPUT)
-c          The Ritz values to be checked for convergence.
-c
-c  BOUNDS  Double precision array of length N.  (INPUT)
-c          Ritz estimates associated with the Ritz values in RITZ.
-c
-c  TOL     Double precision scalar.  (INPUT)
-c          Desired relative accuracy for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch  LAPACK routine that determines machine constants. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.4, this routine no longer uses the
-c        Parlett strategy using the gap conditions. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsconv (n, ritz, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           ritz(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Double precision
-     &           temp, eps23
-c
-c     %-------------------%
-c     | External routines |
-c     %-------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      call arscnd (t0)
-c
-      eps23 = dlamch('Epsilon-Machine') 
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-      nconv  = 0
-      do 10 i = 1, n
-c
-c        %-----------------------------------------------------%
-c        | The i-th Ritz value is considered "converged"       |
-c        | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |
-c        %-----------------------------------------------------%
-c
-         temp = max( eps23, abs(ritz(i)) )
-         if ( bounds(i) .le. tol*temp ) then
-            nconv = nconv + 1
-         end if
-c
-   10 continue
-c 
-      call arscnd (t1)
-      tsconv = tsconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of dsconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dseigt.f b/libcruft/arpack/src/dseigt.f
deleted file mode 100644
--- a/libcruft/arpack/src/dseigt.f
+++ /dev/null
@@ -1,181 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dseigt
-c
-c\Description: 
-c  Compute the eigenvalues of the current symmetric tridiagonal matrix
-c  and the corresponding error bounds given the current residual norm.
-c
-c\Usage:
-c  call dseigt
-c     ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          RNORM contains the residual norm corresponding to the current
-c          symmetric tridiagonal matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the symmetric tridiagonal matrix H.
-c
-c  H       Double precision N by 2 array.  (INPUT)
-c          H contains the symmetric tridiagonal matrix with the 
-c          subdiagonal in the first column starting at H(2,1) and the 
-c          main diagonal in second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  EIG     Double precision array of length N.  (OUTPUT)
-c          On output, EIG contains the N eigenvalues of H possibly 
-c          unsorted.  The BOUNDS arrays are returned in the
-c          same sorted order as EIG.
-c
-c  BOUNDS  Double precision array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the error estimates corresponding
-c          to the eigenvalues EIG.  This is equal to RNORM times the
-c          last components of the eigenvectors corresponding to the
-c          eigenvalues in EIG.
-c
-c  WORKL   Double precision work array of length 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from dstqrb.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dstqrb  ARPACK routine that computes the eigenvalues and the
-c             last components of the eigenvectors of a symmetric
-c             and tridiagonal matrix.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dseigt 
-     &   ( rnorm, n, h, ldh, eig, bounds, workl, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, ldh, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           eig(n), bounds(n), h(ldh,2), workl(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           zero
-      parameter (zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, k, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dstqrb, dvout, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------% 
-c
-      call arscnd (t0)
-      msglvl = mseigt
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, n, h(1,2), ndigit,
-     &              '_seigt: main diagonal of matrix H')
-         if (n .gt. 1) then
-         call dvout (logfil, n-1, h(2,1), ndigit,
-     &              '_seigt: sub diagonal of matrix H')
-         end if
-      end if
-c
-      call dcopy  (n, h(1,2), 1, eig, 1)
-      call dcopy  (n-1, h(2,1), 1, workl, 1)
-      call dstqrb (n, eig, workl, bounds, workl(n+1), ierr)
-      if (ierr .ne. 0) go to 9000
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_seigt: last row of the eigenvector matrix for H')
-      end if
-c
-c     %-----------------------------------------------%
-c     | Finally determine the error bounds associated |
-c     | with the n Ritz values of H.                  |
-c     %-----------------------------------------------%
-c
-      do 30 k = 1, n
-         bounds(k) = rnorm*abs(bounds(k))
-   30 continue
-c 
-      call arscnd (t1)
-      tseigt = tseigt + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dseigt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsesrt.f b/libcruft/arpack/src/dsesrt.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsesrt.f
+++ /dev/null
@@ -1,217 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsesrt
-c
-c\Description:
-c  Sort the array X in the order specified by WHICH and optionally 
-c  apply the permutation to the columns of the matrix A.
-c
-c\Usage:
-c  call dsesrt
-c     ( WHICH, APPLY, N, X, NA, A, LDA)
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X is sorted into increasing order of magnitude.
-c          'SM' -> X is sorted into decreasing order of magnitude.
-c          'LA' -> X is sorted into increasing order of algebraic.
-c          'SA' -> X is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to A.
-c          APPLY = .FALSE. -> do not apply the sorted order to A.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the array X.
-c
-c  X      Double precision array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  NA      Integer.  (INPUT)
-c          Number of rows of the matrix A.
-c
-c  A      Double precision array of length NA by N.  (INPUT/OUTPUT)
-c         
-c  LDA     Integer.  (INPUT)
-c          Leading dimension of A.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines
-c     dswap  Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO and 
-c               the ARPACK code dsortr
-c
-c\SCCS Information: @(#) 
-c FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsesrt (which, apply, n, x, na, a, lda)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    lda, n, na
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           x(0:n-1), a(lda, 0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dswap
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x(j).lt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x(j)).lt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x(j).gt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x(j)).gt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsesrt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dseupd.f b/libcruft/arpack/src/dseupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dseupd.f
+++ /dev/null
@@ -1,857 +0,0 @@
-c\BeginDoc
-c
-c\Name: dseupd 
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) the corresponding approximate eigenvectors,
-c
-c      (2) an orthonormal (Lanczos) basis for the associated approximate
-c          invariant subspace,
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  (Lanczos) basis is always computed.  There is an additional storage cost 
-c  of n*nev if both are requested (in this case a separate array Z must be 
-c  supplied).
-c
-c  These quantities are obtained from the Lanczos factorization computed
-c  by DSAUPD  for the linear operator OP prescribed by the MODE selection
-c  (see IPARAM(7) in DSAUPD  documentation.)  DSAUPD  must be called before
-c  this routine is called. These approximate eigenvalues and vectors are 
-c  commonly called Ritz values and Ritz vectors respectively.  They are 
-c  referred to as such in the comments that follow.   The computed orthonormal 
-c  basis for the invariant subspace corresponding to these Ritz values is 
-c  referred to as a Lanczos basis.
-c
-c  See documentation in the header of the subroutine DSAUPD  for a definition 
-c  of OP as well as other terms and the relation of computed Ritz values 
-c  and vectors of OP with respect to the given problem  A*z = lambda*B*z.  
-c
-c  The approximate eigenvalues of the original problem are returned in
-c  ascending algebraic order.  The user may elect to call this routine
-c  once for each desired Ritz vector and store it peripherally if desired.
-c  There is also the option of computing a selected set of these vectors
-c  with a single call.
-c
-c\Usage:
-c  call dseupd  
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,
-c       RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether Ritz vectors corresponding to the Ritz value 
-c          approximations to the eigenproblem A*z = lambda*B*z are computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors.
-c
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies how many Ritz vectors are wanted and the form of Z
-c          the matrix of Ritz vectors. See remark 1 below.
-c          = 'A': compute NEV Ritz vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' , SELECT is used as a workspace for
-c          reordering the Ritz values.
-c
-c  D       Double precision  array of dimension NEV.  (OUTPUT)
-c          On exit, D contains the Ritz value approximations to the
-c          eigenvalues of A*z = lambda*B*z. The values are returned
-c          in ascending order. If IPARAM(7) = 3,4,5 then D represents
-c          the Ritz values of OP computed by dsaupd  transformed to
-c          those of the original eigensystem A*z = lambda*B*z. If 
-c          IPARAM(7) = 1,2 then the Ritz values of OP are the same 
-c          as the those of A*z = lambda*B*z.
-c
-c  Z       Double precision  N by NEV array if HOWMNY = 'A'.  (OUTPUT)
-c          On exit, Z contains the B-orthonormal Ritz vectors of the
-c          eigensystem A*z = lambda*B*z corresponding to the Ritz
-c          value approximations.
-c          If  RVEC = .FALSE. then Z is not referenced.
-c          NOTE: The array Z may be set equal to first NEV columns of the 
-c          Arnoldi/Lanczos basis array V computed by DSAUPD .
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.
-c
-c  SIGMA   Double precision   (INPUT)
-c          If IPARAM(7) = 3,4,5 represents the shift. Not referenced if
-c          IPARAM(7) = 1 or 2.
-c
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to DSAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to DSEUPD  following the last call
-c         to DSAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to DSAUPD  and the call to DSEUPD .
-c
-c  Two of these parameters (WORKL, INFO) are also output parameters:
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:4*ncv) contains information obtained in
-c          dsaupd .  They are not changed by dseupd .
-c          WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the
-c          untransformed Ritz values, the computed error estimates,
-c          and the associated eigenvector matrix of H.
-c
-c          Note: IPNTR(8:10) contains the pointer into WORKL for addresses
-c          of the above information computed by dseupd .
-c          -------------------------------------------------------------
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     dseupd  if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Information error from LAPACK routine dsteqr .
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: NEV and WHICH = 'BE' are incompatible.
-c          = -14: DSAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.
-c          = -16: HOWMNY = 'S' not yet implemented
-c          = -17: DSEUPD  got a different count of the number of converged
-c                 Ritz values than DSAUPD  got.  This indicates the user
-c                 probably made an error in passing data from DSAUPD  to
-c                 DSEUPD  or that the data was modified before entering 
-c                 DSEUPD .
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in increasing 
-c     (algebraic) order.
-c
-c  2. Currently only HOWMNY = 'A' is implemented. It is included at this
-c     stage for the user who wants to incorporate it. 
-c
-c\Routines called:
-c     dsesrt   ARPACK routine that sorts an array X, and applies the
-c             corresponding permutation to a matrix A.
-c     dsortr   dsortr   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dgeqr2   LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     dlacpy   LAPACK matrix copy routine.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dorm2r   LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     dsteqr   LAPACK routine that computes eigenvalues and eigenvectors
-c             of a tridiagonal matrix.
-c     dger     Level 2 BLAS rank one update to a matrix.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dscal    Level 1 BLAS that scales a vector.
-c     dswap    Level 1 BLAS that swaps the contents of two vectors.
-
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational & 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: seupd.F   SID: 2.11   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine dseupd (rvec  , howmny, select, d    ,
-     &                   z     , ldz   , sigma , bmat ,
-     &                   n     , which , nev   , tol  ,
-     &                   resid , ncv   , v     , ldv  ,
-     &                   iparam, ipntr , workd , workl,
-     &                   lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Double precision      
-     &           sigma, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(7), ipntr(11)
-      logical    select(ncv)
-      Double precision 
-     &           d(nev)     , resid(n)  , v(ldv,ncv),
-     &           z(ldz, nev), workd(2*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision 
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds , ierr   , ih    , ihb   , ihd   ,
-     &           iq     , iw     , j     , k     , ldh   ,
-     &           ldq    , mode   , msglvl, nconv , next  ,
-     &           ritz   , irz    , ibd   , np    , ishift,
-     &           leftptr, rghtptr, numcnv, jj
-      Double precision 
-     &           bnorm2 , rnorm, temp, temp1, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dger   , dgeqr2 , dlacpy , dorm2r , dscal , 
-     &           dsesrt , dsteqr , dswap  , dvout  , ivout , dsortr 
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dnrm2 , dlamch 
-      external   dnrm2 , dlamch 
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mseupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      if (nconv .eq. 0) go to 9000
-      ierr = 0
-c
-      if (nconv .le. 0)                        ierr = -14 
-      if (n .le. 0)                            ierr = -1
-      if (nev .le. 0)                          ierr = -2
-      if (ncv .le. nev .or.  ncv .gt. n)       ierr = -3
-      if (which .ne. 'LM' .and.
-     &    which .ne. 'SM' .and.
-     &    which .ne. 'LA' .and.
-     &    which .ne. 'SA' .and.
-     &    which .ne. 'BE')                     ierr = -5
-      if (bmat .ne. 'I' .and. bmat .ne. 'G')   ierr = -6
-      if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) 
-     &                                         ierr = -15
-      if (rvec .and. howmny .eq. 'S')           ierr = -16
-c
-      if (rvec .and. lworkl .lt. ncv**2+8*ncv) ierr = -7
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else if (mode .eq. 4 ) then
-         type = 'BUCKLE'
-      else if (mode .eq. 5 ) then
-         type = 'CAYLEY'
-      else 
-                                               ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')     ierr = -11
-      if (nev .eq. 1 .and. which .eq. 'BE')    ierr = -12
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c     
-c     %-------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c     | etc... and the remaining workspace.                   |
-c     | Also update pointer to be used on output.             |
-c     | Memory is laid out as follows:                        |
-c     | workl(1:2*ncv) := generated tridiagonal matrix H      |
-c     |       The subdiagonal is stored in workl(2:ncv).      |
-c     |       The dead spot is workl(1) but upon exiting      |
-c     |       dsaupd  stores the B-norm of the last residual   |
-c     |       vector in workl(1). We use this !!!             |
-c     | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c     |       The wanted values are in the first NCONV spots. |
-c     | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |
-c     |       The wanted values are in the first NCONV spots. |
-c     | NOTE: workl(1:4*ncv) is set by dsaupd  and is not      |
-c     |       modified by dseupd .                             |
-c     %-------------------------------------------------------%
-c
-c     %-------------------------------------------------------%
-c     | The following is used and set by dseupd .              |
-c     | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the diagonal of H. Upon EXIT contains the NCV   |
-c     |       Ritz values of the original system. The first   |
-c     |       NCONV spots have the wanted values. If MODE =   |
-c     |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |
-c     | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the subdiagonal of H. Upon EXIT contains the    |
-c     |       NCV corresponding Ritz estimates of the         |
-c     |       original system. The first NCONV spots have the |
-c     |       wanted values. If MODE = 1,2 then will equal    |
-c     |       workl(3*ncv+1:4*ncv).                           |
-c     | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |
-c     |       the eigenvector matrix for H as returned by     |
-c     |       dsteqr . Not referenced if RVEC = .False.        |
-c     |       Ordering follows that of workl(4*ncv+1:5*ncv)   |
-c     | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |
-c     |       Workspace. Needed by dsteqr  and by dseupd .      |
-c     | GRAND total of NCV*(NCV+8) locations.                 |
-c     %-------------------------------------------------------%
-c
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      bounds = ipntr(7)
-      ldh    = ncv
-      ldq    = ncv
-      ihd    = bounds + ldh
-      ihb    = ihd    + ldh
-      iq     = ihb    + ldh
-      iw     = iq     + ldh*ncv
-      next   = iw     + 2*ncv
-      ipntr(4)  = next
-      ipntr(8)  = ihd
-      ipntr(9)  = ihb
-      ipntr(10) = iq
-c
-c     %----------------------------------------%
-c     | irz points to the Ritz values computed |
-c     |     by _seigt before exiting _saup2.   |
-c     | ibd points to the Ritz estimates       |
-c     |     computed by _seigt before exiting  |
-c     |     _saup2.                            |
-c     %----------------------------------------%
-c
-      irz = ipntr(11)+ncv
-      ibd = irz+ncv
-c
-c
-c     %---------------------------------%
-c     | Set machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine') 
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %---------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N).    |
-c     | BNORM2 is the 2 norm of B*RESID(1:N). |
-c     | Upon exit of dsaupd  WORKD(1:N) has    |
-c     | B*RESID(1:N).                         |
-c     %---------------------------------------%
-c
-      rnorm = workl(ih)
-      if (bmat .eq. 'I') then
-         bnorm2 = rnorm
-      else if (bmat .eq. 'G') then
-         bnorm2 = dnrm2 (n, workd, 1)
-      end if
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, ncv, workl(irz), ndigit,
-     &   '_seupd: Ritz values passed in from _SAUPD.')
-         call dvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_seupd: Ritz estimates passed in from _SAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call dsgets (ishift, which       , nev          ,
-     &                np    , workl(irz)  , workl(bounds),
-     &                workl)
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, ncv, workl(irz), ndigit,
-     &      '_seupd: Ritz values after calling _SGETS.')
-            call dvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_seupd: Ritz value indices after calling _SGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23, abs(workl(irz+ncv-j)) )
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by _saupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the _saupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_seupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -17
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine _steqr to compute the eigenvalues and |
-c        | eigenvectors of the final symmetric tridiagonal matrix H. |
-c        | Initialize the eigenvector matrix Q to the identity.      |
-c        %-----------------------------------------------------------%
-c
-         call dcopy (ncv-1, workl(ih+1), 1, workl(ihb), 1)
-         call dcopy (ncv, workl(ih+ldh), 1, workl(ihd), 1)
-c
-         call dsteqr ('Identity', ncv, workl(ihd), workl(ihb),
-     &                workl(iq) , ldq, workl(iw), ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call dcopy (ncv, workl(iq+ncv-1), ldq, workl(iw), 1)
-            call dvout (logfil, ncv, workl(ihd), ndigit,
-     &          '_seupd: NCV Ritz values of the final H matrix')
-            call dvout (logfil, ncv, workl(iw), ndigit,
-     &           '_seupd: last row of the eigenvector matrix for H')
-         end if
-c
-         if (reord) then
-c
-c           %---------------------------------------------%
-c           | Reordered the eigenvalues and eigenvectors  |
-c           | computed by _steqr so that the "converged"  |
-c           | eigenvalues appear in the first NCONV       |
-c           | positions of workl(ihd), and the associated |
-c           | eigenvectors appear in the first NCONV      |
-c           | columns.                                    |
-c           %---------------------------------------------%
-c
-            leftptr = 1
-            rghtptr = ncv
-c
-            if (ncv .eq. 1) go to 30
-c
- 20         if (select(leftptr)) then
-c
-c              %-------------------------------------------%
-c              | Search, from the left, for the first Ritz |
-c              | value that has not converged.             |
-c              %-------------------------------------------%
-c
-               leftptr = leftptr + 1
-c
-            else if ( .not. select(rghtptr)) then
-c
-c              %----------------------------------------------%
-c              | Search, from the right, the first Ritz value |
-c              | that has converged.                          |
-c              %----------------------------------------------%
-c
-               rghtptr = rghtptr - 1
-c
-            else
-c
-c              %----------------------------------------------%
-c              | Swap the Ritz value on the left that has not |
-c              | converged with the Ritz value on the right   |
-c              | that has converged.  Swap the associated     |
-c              | eigenvector of the tridiagonal matrix H as   |
-c              | well.                                        |
-c              %----------------------------------------------%
-c
-               temp = workl(ihd+leftptr-1)
-               workl(ihd+leftptr-1) = workl(ihd+rghtptr-1)
-               workl(ihd+rghtptr-1) = temp
-               call dcopy (ncv, workl(iq+ncv*(leftptr-1)), 1,
-     &                    workl(iw), 1)
-               call dcopy (ncv, workl(iq+ncv*(rghtptr-1)), 1,
-     &                    workl(iq+ncv*(leftptr-1)), 1)
-               call dcopy (ncv, workl(iw), 1,
-     &                    workl(iq+ncv*(rghtptr-1)), 1)
-               leftptr = leftptr + 1
-               rghtptr = rghtptr - 1
-c
-            end if
-c
-            if (leftptr .lt. rghtptr) go to 20
-c
-         end if
-c
- 30      if (msglvl .gt. 2) then
-             call dvout  (logfil, ncv, workl(ihd), ndigit,
-     &       '_seupd: The eigenvalues of H--reordered')
-         end if
-c
-c        %----------------------------------------%
-c        | Load the converged Ritz values into D. |
-c        %----------------------------------------%
-c
-         call dcopy (nconv, workl(ihd), 1, d, 1)
-c
-      else
-c
-c        %-----------------------------------------------------%
-c        | Ritz vectors not required. Load Ritz values into D. |
-c        %-----------------------------------------------------%
-c
-         call dcopy (nconv, workl(ritz), 1, d, 1)
-         call dcopy (ncv, workl(ritz), 1, workl(ihd), 1)
-c
-      end if
-c
-c     %------------------------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors and corresponding |
-c     | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |
-c     | (and corresponding data) are returned in ascending order.        |
-c     %------------------------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-c        %---------------------------------------------------------%
-c        | Ascending sort of wanted Ritz values, vectors and error |
-c        | bounds. Not necessary if only Ritz values are desired.  |
-c        %---------------------------------------------------------%
-c
-         if (rvec) then
-            call dsesrt ('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call dcopy (ncv, workl(bounds), 1, workl(ihb), 1)
-         end if
-c
-      else 
-c 
-c        %-------------------------------------------------------------%
-c        | *  Make a copy of all the Ritz values.                      |
-c        | *  Transform the Ritz values back to the original system.   |
-c        |    For TYPE = 'SHIFTI' the transformation is                |
-c        |             lambda = 1/theta + sigma                        |
-c        |    For TYPE = 'BUCKLE' the transformation is                |
-c        |             lambda = sigma * theta / ( theta - 1 )          |
-c        |    For TYPE = 'CAYLEY' the transformation is                |
-c        |             lambda = sigma * (theta + 1) / (theta - 1 )     |
-c        |    where the theta are the Ritz values returned by dsaupd .  |
-c        | NOTES:                                                      |
-c        | *The Ritz vectors are not affected by the transformation.   |
-c        |  They are only reordered.                                   |
-c        %-------------------------------------------------------------%
-c
-         call dcopy  (ncv, workl(ihd), 1, workl(iw), 1)
-         if (type .eq. 'SHIFTI') then 
-            do 40 k=1, ncv
-               workl(ihd+k-1) = one / workl(ihd+k-1) + sigma
-  40        continue
-         else if (type .eq. 'BUCKLE') then
-            do 50 k=1, ncv
-               workl(ihd+k-1) = sigma * workl(ihd+k-1) / 
-     &                          (workl(ihd+k-1) - one)
-  50        continue
-         else if (type .eq. 'CAYLEY') then
-            do 60 k=1, ncv
-               workl(ihd+k-1) = sigma * (workl(ihd+k-1) + one) /
-     &                          (workl(ihd+k-1) - one)
-  60        continue
-         end if
-c 
-c        %-------------------------------------------------------------%
-c        | *  Store the wanted NCONV lambda values into D.             |
-c        | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |
-c        |    into ascending order and apply sort to the NCONV theta   |
-c        |    values in the transformed system. We will need this to   |
-c        |    compute Ritz estimates in the original system.           |
-c        | *  Finally sort the lambda`s into ascending order and apply |
-c        |    to Ritz vectors if wanted. Else just sort lambda`s into  |
-c        |    ascending order.                                         |
-c        | NOTES:                                                      |
-c        | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |
-c        |  match the ordering of the lambda. We`ll use them again for |
-c        |  Ritz vector purification.                                  |
-c        %-------------------------------------------------------------%
-c
-         call dcopy (nconv, workl(ihd), 1, d, 1)
-         call dsortr ('LA', .true., nconv, workl(ihd), workl(iw))
-         if (rvec) then
-            call dsesrt ('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call dcopy (ncv, workl(bounds), 1, workl(ihb), 1)
-            call dscal (ncv, bnorm2/rnorm, workl(ihb), 1)
-            call dsortr ('LA', .true., nconv, d, workl(ihb))
-         end if
-c
-      end if 
-c 
-c     %------------------------------------------------%
-c     | Compute the Ritz vectors. Transform the wanted |
-c     | eigenvectors of the symmetric tridiagonal H by |
-c     | the Lanczos basis matrix V.                    |
-c     %------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A') then
-c    
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(iq,ldq).                                |
-c        %----------------------------------------------------------%
-c     
-         call dgeqr2 (ncv, nconv        , workl(iq) ,
-     &                ldq, workl(iw+ncv), workl(ihb),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q.                                 |   
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(ihd).                         |
-c        %--------------------------------------------------------%
-c     
-         call dorm2r ('Right', 'Notranspose', n        ,
-     &                ncv    , nconv        , workl(iq),
-     &                ldq    , workl(iw+ncv), v        ,
-     &                ldv    , workd(n+1)   , ierr)
-         call dlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-c        %-----------------------------------------------------%
-c        | In order to compute the Ritz estimates for the Ritz |
-c        | values in both systems, need the last row of the    |
-c        | eigenvector matrix. Remember, it`s in factored form |
-c        %-----------------------------------------------------%
-c
-         do 65 j = 1, ncv-1
-            workl(ihb+j-1) = zero 
-  65     continue
-         workl(ihb+ncv-1) = one
-         call dorm2r ('Left', 'Transpose'  , ncv       ,
-     &                1     , nconv        , workl(iq) ,
-     &                ldq   , workl(iw+ncv), workl(ihb),
-     &                ncv   , temp         , ierr)
-c
-      else if (rvec .and. howmny .eq. 'S') then
-c
-c     Not yet implemented. See remark 2 above.
-c
-      end if
-c
-      if (type .eq. 'REGULR' .and. rvec) then
-c
-            do 70 j=1, ncv
-               workl(ihb+j-1) = rnorm * abs( workl(ihb+j-1) )
- 70         continue
-c
-      else if (type .ne. 'REGULR' .and. rvec) then
-c
-c        %-------------------------------------------------%
-c        | *  Determine Ritz estimates of the theta.       |
-c        |    If RVEC = .true. then compute Ritz estimates |
-c        |               of the theta.                     |
-c        |    If RVEC = .false. then copy Ritz estimates   |
-c        |              as computed by dsaupd .             |
-c        | *  Determine Ritz estimates of the lambda.      |
-c        %-------------------------------------------------%
-c
-         call dscal  (ncv, bnorm2, workl(ihb), 1)
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1) ) 
-     &                        / workl(iw+k-1)**2
- 80         continue
-c
-         else if (type .eq. 'BUCKLE') then
-c
-            do 90 k=1, ncv
-               workl(ihb+k-1) = sigma * abs( workl(ihb+k-1) )
-     &                        / (workl(iw+k-1)-one )**2
- 90         continue
-c
-         else if (type .eq. 'CAYLEY') then
-c
-            do 100 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1)
-     &                        / workl(iw+k-1)*(workl(iw+k-1)-one) )
- 100        continue
-c
-         end if
-c
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, d, ndigit,
-     &          '_seupd: Untransformed converged Ritz values')
-         call dvout (logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Ritz estimates of the untransformed Ritz values')
-      else if (msglvl .gt. 1) then
-         call dvout (logfil, nconv, d, ndigit,
-     &          '_seupd: Converged Ritz values')
-         call dvout (logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Associated Ritz estimates')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Ritz vector purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3,4,5. See reference 7               |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. (type .eq. 'SHIFTI' .or. type .eq. 'CAYLEY')) then
-c
-         do 110 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / workl(iw+k)
- 110     continue
-c
-      else if (rvec .and. type .eq. 'BUCKLE') then
-c
-         do 120 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / (workl(iw+k)-one)
- 120     continue
-c
-      end if 
-c
-      if (type .ne. 'REGULR')
-     &   call dger  (n, nconv, one, resid, 1, workl(iw), 1, z, ldz)
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dseupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsgets.f b/libcruft/arpack/src/dsgets.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsgets.f
+++ /dev/null
@@ -1,219 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsgets
-c
-c\Description: 
-c  Given the eigenvalues of the symmetric tridiagonal matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors 
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: This is called even in the case of user specified shifts in 
-c  order to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call dsgets
-c     ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> KEV eigenvalues of largest magnitude are retained.
-c          'SM' -> KEV eigenvalues of smallest magnitude are retained.
-c          'LA' -> KEV eigenvalues of largest value are retained.
-c          'SA' -> KEV eigenvalues of smallest value are retained.
-c          'BE' -> KEV eigenvalues, half from each end of the spectrum.
-c                  If KEV is odd, compute one more from the high end.
-c
-c  KEV      Integer.  (INPUT)
-c          KEV+NP is the size of the matrix H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be computed.
-c
-c  RITZ    Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted eigenvalues 
-c          are in the first NP locations and the wanted part is in 
-c          the last KEV locations.  When exact shifts are selected, the
-c          unwanted part corresponds to the shifts to be applied.
-c
-c  BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTS  Double precision array of length NP.  (INPUT/OUTPUT)
-c          On INPUT:  contains the user specified shifts if ISHIFT = 0.
-c          On OUTPUT: contains the shifts sorted into decreasing order 
-c          of magnitude with respect to the Ritz estimates contained in
-c          BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dsortr  ARPACK utility sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dswap   Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsgets ( ishift, which, kev, np, ritz, bounds, shifts )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(kev+np), ritz(kev+np), shifts(np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    kevd2, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dswap, dcopy, dsortr, arscnd
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    max, min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msgets
-c 
-      if (which .eq. 'BE') then
-c
-c        %-----------------------------------------------------%
-c        | Both ends of the spectrum are requested.            |
-c        | Sort the eigenvalues into algebraically increasing  |
-c        | order first then swap high end of the spectrum next |
-c        | to low end in appropriate locations.                |
-c        | NOTE: when np < floor(kev/2) be careful not to swap |
-c        | overlapping locations.                              |
-c        %-----------------------------------------------------%
-c
-         call dsortr ('LA', .true., kev+np, ritz, bounds)
-         kevd2 = kev / 2 
-         if ( kev .gt. 1 ) then
-            call dswap ( min(kevd2,np), ritz, 1, 
-     &                   ritz( max(kevd2,np)+1 ), 1)
-            call dswap ( min(kevd2,np), bounds, 1, 
-     &                   bounds( max(kevd2,np)+1 ), 1)
-         end if
-c
-      else
-c
-c        %----------------------------------------------------%
-c        | LM, SM, LA, SA case.                               |
-c        | Sort the eigenvalues of H into the desired order   |
-c        | and apply the resulting order to BOUNDS.           |
-c        | The eigenvalues are sorted so that the wanted part |
-c        | are always in the last KEV locations.               |
-c        %----------------------------------------------------%
-c
-         call dsortr (which, .true., kev+np, ritz, bounds)
-      end if
-c
-      if (ishift .eq. 1 .and. np .gt. 0) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first.       |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine dsapps.                     |
-c        %-------------------------------------------------------%
-c     
-         call dsortr ('SM', .true., np, bounds, ritz)
-         call dcopy (np, ritz, 1, shifts, 1)
-      end if
-c 
-      call arscnd (t1)
-      tsgets = tsgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_sgets: NP is')
-         call dvout (logfil, kev+np, ritz, ndigit,
-     &        '_sgets: Eigenvalues of current H matrix')
-         call dvout (logfil, kev+np, bounds, ndigit, 
-     &        '_sgets: Associated Ritz estimates')
-      end if
-c 
-      return
-c
-c     %---------------%
-c     | End of dsgets |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsortc.f b/libcruft/arpack/src/dsortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsortc.f
+++ /dev/null
@@ -1,344 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsortc
-c
-c\Description:
-c  Sorts the complex array in XREAL and XIMAG into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  real array Y. It is assumed that if an element of XIMAG is
-c  nonzero, then its negative is also an element. In other words,
-c  both members of a complex conjugate pair are to be sorted and the
-c  pairs are kept adjacent to each other.
-c
-c\Usage:
-c  call dsortc
-c     ( WHICH, APPLY, N, XREAL, XIMAG, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort XREAL,XIMAG into increasing order of magnitude.
-c          'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.
-c          'LR' -> sort XREAL into increasing order of algebraic.
-c          'SR' -> sort XREAL into decreasing order of algebraic.
-c          'LI' -> sort XIMAG into increasing order of magnitude.
-c          'SI' -> sort XIMAG into decreasing order of magnitude.
-c          NOTE: If an element of XIMAG is non-zero, then its negative
-c                is also an element.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  XREAL,  Double precision array of length N.  (INPUT/OUTPUT)
-c  XIMAG   Real and imaginary part of the array to be sorted.
-c
-c  Y       Double precision array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsortc (which, apply, n, xreal, ximag, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision     
-     &           xreal(0:n-1), ximag(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision     
-     &           temp, temp1, temp2
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision     
-     &           dlapy2
-      external   dlapy2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = dlapy2(xreal(j),ximag(j))
-            temp2 = dlapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.gt.temp2) then
-                temp = xreal(j)
-                xreal(j) = xreal(j+igap)
-                xreal(j+igap) = temp
-c
-                temp = ximag(j)
-                ximag(j) = ximag(j+igap)
-                ximag(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = dlapy2(xreal(j),ximag(j))
-            temp2 = dlapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.lt.temp2) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (xreal(j).gt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (xreal(j).lt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (abs(ximag(j)).gt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (abs(ximag(j)).lt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsortr.f b/libcruft/arpack/src/dsortr.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsortr.f
+++ /dev/null
@@ -1,218 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsortr
-c
-c\Description:
-c  Sort the array X1 in the order specified by WHICH and optionally 
-c  applies the permutation to the array X2.
-c
-c\Usage:
-c  call dsortr
-c     ( WHICH, APPLY, N, X1, X2 )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X1 is sorted into increasing order of magnitude.
-c          'SM' -> X1 is sorted into decreasing order of magnitude.
-c          'LA' -> X1 is sorted into increasing order of algebraic.
-c          'SA' -> X1 is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to X2.
-c          APPLY = .FALSE. -> do not apply the sorted order to X2.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X1      Double precision array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  X2      Double precision array of length N.  (INPUT/OUTPUT)
-c          Only referenced if APPLY = .TRUE.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsortr (which, apply, n, x1, x2)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           x1(0:n-1), x2(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X1 is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x1(j).lt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X1 is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x1(j)).lt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X1 is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x1(j).gt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X1 is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x1(j)).gt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsortr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dstatn.f b/libcruft/arpack/src/dstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/dstatn.f
+++ /dev/null
@@ -1,61 +0,0 @@
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for nonsymmetric Arnoldi code.              |
-c     %---------------------------------------------%
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\SCCS Information: @(#) 
-c FILE: statn.F   SID: 2.4   DATE OF SID: 4/20/96   RELEASE: 2
-c
-      subroutine dstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-c 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-c 
-      tnaupd = 0.0D+0
-      tnaup2 = 0.0D+0
-      tnaitr = 0.0D+0
-      tneigh = 0.0D+0
-      tngets = 0.0D+0
-      tnapps = 0.0D+0
-      tnconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
-c 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-c
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
-c 
-      return
-c
-c
-c     %---------------%
-c     | End of dstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dstats.f b/libcruft/arpack/src/dstats.f
deleted file mode 100644
--- a/libcruft/arpack/src/dstats.f
+++ /dev/null
@@ -1,47 +0,0 @@
-c
-c\SCCS Information: @(#) 
-c FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for symmetric Arnoldi code.                 |
-c     %---------------------------------------------%
- 
-      subroutine dstats
-
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tsaupd = 0.0D+0
-      tsaup2 = 0.0D+0
-      tsaitr = 0.0D+0
-      tseigt = 0.0D+0
-      tsgets = 0.0D+0
-      tsapps = 0.0D+0
-      tsconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
- 
-      return
-c
-c     End of dstats
-c
-      end
diff --git a/libcruft/arpack/src/dstqrb.f b/libcruft/arpack/src/dstqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/dstqrb.f
+++ /dev/null
@@ -1,594 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dstqrb
-c
-c\Description:
-c  Computes all eigenvalues and the last component of the eigenvectors
-c  of a symmetric tridiagonal matrix using the implicit QL or QR method.
-c
-c  This is mostly a modification of the LAPACK routine dsteqr.
-c  See Remarks.
-c
-c\Usage:
-c  call dstqrb
-c     ( N, D, E, Z, WORK, INFO )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          The number of rows and columns in the matrix.  N >= 0.
-c
-c  D       Double precision array, dimension (N).  (INPUT/OUTPUT)
-c          On entry, D contains the diagonal elements of the
-c          tridiagonal matrix.
-c          On exit, D contains the eigenvalues, in ascending order.
-c          If an error exit is made, the eigenvalues are correct
-c          for indices 1,2,...,INFO-1, but they are unordered and
-c          may not be the smallest eigenvalues of the matrix.
-c
-c  E       Double precision array, dimension (N-1).  (INPUT/OUTPUT)
-c          On entry, E contains the subdiagonal elements of the
-c          tridiagonal matrix in positions 1 through N-1.
-c          On exit, E has been destroyed.
-c
-c  Z       Double precision array, dimension (N).  (OUTPUT)
-c          On exit, Z contains the last row of the orthonormal 
-c          eigenvector matrix of the symmetric tridiagonal matrix.  
-c          If an error exit is made, Z contains the last row of the
-c          eigenvector matrix associated with the stored eigenvalues.
-c
-c  WORK    Double precision array, dimension (max(1,2*N-2)).  (WORKSPACE)
-c          Workspace used in accumulating the transformation for 
-c          computing the last components of the eigenvectors.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0:  normal return.
-c          < 0:  if INFO = -i, the i-th argument had an illegal value.
-c          > 0:  if INFO = +i, the i-th eigenvalue has not converged
-c                              after a total of  30*N  iterations.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dswap   Level 1 BLAS that swaps the contents of two vectors.
-c     lsame   LAPACK character comparison routine.
-c     dlae2   LAPACK routine that computes the eigenvalues of a 2-by-2 
-c             symmetric matrix.
-c     dlaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric 
-c             matrix.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlanst  LAPACK routine that computes the norm of a matrix.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dlaset  LAPACK matrix initialization routine.
-c     dlasr   LAPACK routine that applies an orthogonal transformation to 
-c             a matrix.
-c     dlasrt  LAPACK sorting routine.
-c     dsteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a symmetric tridiagonal matrix.
-c     xerbla  LAPACK error handler routine.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.5, this routine is a modified version
-c        of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,
-c        only commeted out and new lines inserted.
-c        All lines commented out have "c$$$" at the beginning.
-c        Note that the LAPACK version 1.0 subroutine SSTEQR contained
-c        bugs. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dstqrb ( n, d, e, z, work, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    info, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           d( n ), e( n-1 ), z( n ), work( 2*n-2 )
-c
-c     .. parameters ..
-      Double precision               
-     &                   zero, one, two, three
-      parameter          ( zero = 0.0D+0, one = 1.0D+0, 
-     &                     two = 2.0D+0, three = 3.0D+0 )
-      integer            maxit
-      parameter          ( maxit = 30 )
-c     ..
-c     .. local scalars ..
-      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
-     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
-     &                   nm1, nmaxit
-      Double precision               
-     &                   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
-     &                   s, safmax, safmin, ssfmax, ssfmin, tst
-c     ..
-c     .. external functions ..
-      logical            lsame
-      Double precision
-     &                   dlamch, dlanst, dlapy2
-      external           lsame, dlamch, dlanst, dlapy2
-c     ..
-c     .. external subroutines ..
-      external           dlae2, dlaev2, dlartg, dlascl, dlaset, dlasr,
-     &                   dlasrt, dswap, xerbla
-c     ..
-c     .. intrinsic functions ..
-      intrinsic          abs, max, sign, sqrt
-c     ..
-c     .. executable statements ..
-c
-c     test the input parameters.
-c
-      info = 0
-c
-c$$$      IF( LSAME( COMPZ, 'N' ) ) THEN
-c$$$         ICOMPZ = 0
-c$$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
-c$$$         ICOMPZ = 1
-c$$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
-c$$$         ICOMPZ = 2
-c$$$      ELSE
-c$$$         ICOMPZ = -1
-c$$$      END IF
-c$$$      IF( ICOMPZ.LT.0 ) THEN
-c$$$         INFO = -1
-c$$$      ELSE IF( N.LT.0 ) THEN
-c$$$         INFO = -2
-c$$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
-c$$$     $         N ) ) ) THEN
-c$$$         INFO = -6
-c$$$      END IF
-c$$$      IF( INFO.NE.0 ) THEN
-c$$$         CALL XERBLA( 'SSTEQR', -INFO )
-c$$$         RETURN
-c$$$      END IF
-c
-c    *** New starting with version 2.5 ***
-c
-      icompz = 2
-c    *************************************
-c
-c     quick return if possible
-c
-      if( n.eq.0 )
-     $   return
-c
-      if( n.eq.1 ) then
-         if( icompz.eq.2 )  z( 1 ) = one
-         return
-      end if
-c
-c     determine the unit roundoff and over/underflow thresholds.
-c
-      eps = dlamch( 'e' )
-      eps2 = eps**2
-      safmin = dlamch( 's' )
-      safmax = one / safmin
-      ssfmax = sqrt( safmax ) / three
-      ssfmin = sqrt( safmin ) / eps2
-c
-c     compute the eigenvalues and eigenvectors of the tridiagonal
-c     matrix.
-c
-c$$      if( icompz.eq.2 )
-c$$$     $   call dlaset( 'full', n, n, zero, one, z, ldz )
-c
-c     *** New starting with version 2.5 ***
-c
-      if ( icompz .eq. 2 ) then
-         do 5 j = 1, n-1
-            z(j) = zero
-  5      continue
-         z( n ) = one
-      end if
-c     *************************************
-c
-      nmaxit = n*maxit
-      jtot = 0
-c
-c     determine where the matrix splits and choose ql or qr iteration
-c     for each block, according to whether top or bottom diagonal
-c     element is smaller.
-c
-      l1 = 1
-      nm1 = n - 1
-c
-   10 continue
-      if( l1.gt.n )
-     $   go to 160
-      if( l1.gt.1 )
-     $   e( l1-1 ) = zero
-      if( l1.le.nm1 ) then
-         do 20 m = l1, nm1
-            tst = abs( e( m ) )
-            if( tst.eq.zero )
-     $         go to 30
-            if( tst.le.( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+
-     $          1 ) ) ) )*eps ) then
-               e( m ) = zero
-               go to 30
-            end if
-   20    continue
-      end if
-      m = n
-c
-   30 continue
-      l = l1
-      lsv = l
-      lend = m
-      lendsv = lend
-      l1 = m + 1
-      if( lend.eq.l )
-     $   go to 10
-c
-c     scale submatrix in rows and columns l to lend
-c
-      anorm = dlanst( 'i', lend-l+1, d( l ), e( l ) )
-      iscale = 0
-      if( anorm.eq.zero )
-     $   go to 10
-      if( anorm.gt.ssfmax ) then
-         iscale = 1
-         call dlascl( 'g', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,
-     $                info )
-         call dlascl( 'g', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,
-     $                info )
-      else if( anorm.lt.ssfmin ) then
-         iscale = 2
-         call dlascl( 'g', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,
-     $                info )
-         call dlascl( 'g', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,
-     $                info )
-      end if
-c
-c     choose between ql and qr iteration
-c
-      if( abs( d( lend ) ).lt.abs( d( l ) ) ) then
-         lend = lsv
-         l = lendsv
-      end if
-c
-      if( lend.gt.l ) then
-c
-c        ql iteration
-c
-c        look for small subdiagonal element.
-c
-   40    continue
-         if( l.ne.lend ) then
-            lendm1 = lend - 1
-            do 50 m = l, lendm1
-               tst = abs( e( m ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+
-     $             safmin )go to 60
-   50       continue
-         end if
-c
-         m = lend
-c
-   60    continue
-         if( m.lt.lend )
-     $      e( m ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 80
-c
-c        if remaining matrix is 2-by-2, use dlae2 or dlaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l+1 ) then
-            if( icompz.gt.0 ) then
-               call dlaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
-               work( l ) = c
-               work( n-1+l ) = s
-c$$$               call dlasr( 'r', 'v', 'b', n, 2, work( l ),
-c$$$     $                     work( n-1+l ), z( 1, l ), ldz )
-c
-c              *** New starting with version 2.5 ***
-c
-               tst      = z(l+1)
-               z(l+1) = c*tst - s*z(l)
-               z(l)   = s*tst + c*z(l)
-c              *************************************
-            else
-               call dlae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
-            end if
-            d( l ) = rt1
-            d( l+1 ) = rt2
-            e( l ) = zero
-            l = l + 2
-            if( l.le.lend )
-     $         go to 40
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l+1 )-p ) / ( two*e( l ) )
-         r = dlapy2( g, one )
-         g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         mm1 = m - 1
-         do 70 i = mm1, l, -1
-            f = s*e( i )
-            b = c*e( i )
-            call dlartg( g, f, c, s, r )
-            if( i.ne.m-1 )
-     $         e( i+1 ) = r
-            g = d( i+1 ) - p
-            r = ( d( i )-g )*s + two*c*b
-            p = s*r
-            d( i+1 ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = -s
-            end if
-c
-   70    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = m - l + 1
-c$$$            call dlasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),
-c$$$     $                  z( 1, l ), ldz )
-c
-c             *** New starting with version 2.5 ***
-c
-              call dlasr( 'r', 'v', 'b', 1, mm, work( l ), 
-     &                    work( n-1+l ), z( l ), 1 )
-c             *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( l ) = g
-         go to 40
-c
-c        eigenvalue found.
-c
-   80    continue
-         d( l ) = p
-c
-         l = l + 1
-         if( l.le.lend )
-     $      go to 40
-         go to 140
-c
-      else
-c
-c        qr iteration
-c
-c        look for small superdiagonal element.
-c
-   90    continue
-         if( l.ne.lend ) then
-            lendp1 = lend + 1
-            do 100 m = l, lendp1, -1
-               tst = abs( e( m-1 ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+
-     $             safmin )go to 110
-  100       continue
-         end if
-c
-         m = lend
-c
-  110    continue
-         if( m.gt.lend )
-     $      e( m-1 ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 130
-c
-c        if remaining matrix is 2-by-2, use dlae2 or dlaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l-1 ) then
-            if( icompz.gt.0 ) then
-               call dlaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
-c$$$               work( m ) = c
-c$$$               work( n-1+m ) = s
-c$$$               call dlasr( 'r', 'v', 'f', n, 2, work( m ),
-c$$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )
-c
-c               *** New starting with version 2.5 ***
-c
-                tst      = z(l)
-                z(l)   = c*tst - s*z(l-1)
-                z(l-1) = s*tst + c*z(l-1)
-c               ************************************* 
-            else
-               call dlae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
-            end if
-            d( l-1 ) = rt1
-            d( l ) = rt2
-            e( l-1 ) = zero
-            l = l - 2
-            if( l.ge.lend )
-     $         go to 90
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
-         r = dlapy2( g, one )
-         g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         lm1 = l - 1
-         do 120 i = m, lm1
-            f = s*e( i )
-            b = c*e( i )
-            call dlartg( g, f, c, s, r )
-            if( i.ne.m )
-     $         e( i-1 ) = r
-            g = d( i ) - p
-            r = ( d( i+1 )-g )*s + two*c*b
-            p = s*r
-            d( i ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = s
-            end if
-c
-  120    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = l - m + 1
-c$$$            call dlasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),
-c$$$     $                  z( 1, m ), ldz )
-c
-c           *** New starting with version 2.5 ***
-c
-            call dlasr( 'r', 'v', 'f', 1, mm, work( m ), work( n-1+m ),
-     &                  z( m ), 1 )
-c           *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( lm1 ) = g
-         go to 90
-c
-c        eigenvalue found.
-c
-  130    continue
-         d( l ) = p
-c
-         l = l - 1
-         if( l.ge.lend )
-     $      go to 90
-         go to 140
-c
-      end if
-c
-c     undo scaling if necessary
-c
-  140 continue
-      if( iscale.eq.1 ) then
-         call dlascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call dlascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      else if( iscale.eq.2 ) then
-         call dlascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call dlascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      end if
-c
-c     check for no convergence to an eigenvalue after a total
-c     of n*maxit iterations.
-c
-      if( jtot.lt.nmaxit )
-     $   go to 10
-      do 150 i = 1, n - 1
-         if( e( i ).ne.zero )
-     $      info = info + 1
-  150 continue
-      go to 190
-c
-c     order eigenvalues and eigenvectors.
-c
-  160 continue
-      if( icompz.eq.0 ) then
-c
-c        use quick sort
-c
-         call dlasrt( 'i', n, d, info )
-c
-      else
-c
-c        use selection sort to minimize swaps of eigenvectors
-c
-         do 180 ii = 2, n
-            i = ii - 1
-            k = i
-            p = d( i )
-            do 170 j = ii, n
-               if( d( j ).lt.p ) then
-                  k = j
-                  p = d( j )
-               end if
-  170       continue
-            if( k.ne.i ) then
-               d( k ) = d( i )
-               d( i ) = p
-c$$$               call dswap( n, z( 1, i ), 1, z( 1, k ), 1 )
-c           *** New starting with version 2.5 ***
-c
-               p    = z(k)
-               z(k) = z(i)
-               z(i) = p
-c           *************************************
-            end if
-  180    continue
-      end if
-c
-  190 continue
-      return
-c
-c     %---------------%
-c     | End of dstqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sgetv0.f b/libcruft/arpack/src/sgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/sgetv0.f
+++ /dev/null
@@ -1,419 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call sgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to sgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that sgetv0 is called.  
-c          It should be set to 1 on the initial call to sgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Real N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Real scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Real work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine for vector output.
-c     slarnv  LAPACK routine for generating a random vector.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: getv0.F   SID: 2.7   DATE OF SID: 04/07/99   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Real
-     &           rnorm0
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   slarnv, svout, scopy, sgemv, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2
-      external   sdot, snrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call slarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call scopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %-----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %-----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-      end if
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call scopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call scopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          rnorm0 = sdot (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(abs(rnorm0))
-      else if (bmat .eq. 'I') then
-           rnorm0 = snrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call sgemv ('T', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call sgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call scopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call scopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         rnorm = sdot (n, resid, 1, workd, 1)
-         rnorm = sqrt(abs(rnorm))
-      else if (bmat .eq. 'I') then
-         rnorm = snrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call svout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 5) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = zero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 3) then
-         call svout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/slaqrb.f b/libcruft/arpack/src/slaqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/slaqrb.f
+++ /dev/null
@@ -1,521 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: slaqrb
-c
-c\Description:
-c  Compute the eigenvalues and the Schur decomposition of an upper 
-c  Hessenberg submatrix in rows and columns ILO to IHI.  Only the
-c  last component of the Schur vectors are computed.
-c
-c  This is mostly a modification of the LAPACK routine slahqr.
-c  
-c\Usage:
-c  call slaqrb
-c     ( WANTT, N, ILO, IHI, H, LDH, WR, WI,  Z, INFO )
-c
-c\Arguments
-c  WANTT   Logical variable.  (INPUT)
-c          = .TRUE. : the full Schur form T is required;
-c          = .FALSE.: only eigenvalues are required.
-c
-c  N       Integer.  (INPUT)
-c          The order of the matrix H.  N >= 0.
-c
-c  ILO     Integer.  (INPUT)
-c  IHI     Integer.  (INPUT)
-c          It is assumed that H is already upper quasi-triangular in
-c          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
-c          ILO = 1). SLAQRB works primarily with the Hessenberg
-c          submatrix in rows and columns ILO to IHI, but applies
-c          transformations to all of H if WANTT is .TRUE..
-c          1 <= ILO <= max(1,IHI); IHI <= N.
-c
-c  H       Real array, dimension (LDH,N).  (INPUT/OUTPUT)
-c          On entry, the upper Hessenberg matrix H.
-c          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
-c          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
-c          standard form. If WANTT is .FALSE., the contents of H are
-c          unspecified on exit.
-c
-c  LDH     Integer.  (INPUT)
-c          The leading dimension of the array H. LDH >= max(1,N).
-c
-c  WR      Real array, dimension (N).  (OUTPUT)
-c  WI      Real array, dimension (N).  (OUTPUT)
-c          The real and imaginary parts, respectively, of the computed
-c          eigenvalues ILO to IHI are stored in the corresponding
-c          elements of WR and WI. If two eigenvalues are computed as a
-c          complex conjugate pair, they are stored in consecutive
-c          elements of WR and WI, say the i-th and (i+1)th, with
-c          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
-c          eigenvalues are stored in the same order as on the diagonal
-c          of the Schur form returned in H, with WR(i) = H(i,i), and, if
-c          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
-c          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
-c
-c  Z       Real array, dimension (N).  (OUTPUT)
-c          On exit Z contains the last components of the Schur vectors.
-c
-c  INFO    Integer.  (OUPUT)
-c          = 0: successful exit
-c          > 0: SLAQRB failed to compute all the eigenvalues ILO to IHI
-c               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
-c               elements i+1:ihi of WR and WI contain those eigenvalues
-c               which have been successfully computed.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     slabad  LAPACK routine that computes machine constants.
-c     slamch  LAPACK routine that determines machine constants.
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     slanv2  LAPACK routine that computes the Schur factorization of
-c             2 by 2 nonsymmetric matrix in standard form.
-c     slarfg  LAPACK Householder reflection construction routine.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     srot    Level 1 BLAS that applies a rotation to a 2 by 2 matrix.
-
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c               Modified from the LAPACK routine slahqr so that only the
-c               last component of the Schur vectors are computed.
-c
-c\SCCS Information: @(#) 
-c FILE: laqrb.F   SID: 2.2   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine slaqrb ( wantt, n, ilo, ihi, h, ldh, wr, wi,
-     &                    z, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      logical    wantt
-      integer    ihi, ilo, info, ldh, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h( ldh, * ), wi( * ), wr( * ), z( * )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           zero, one, dat1, dat2
-      parameter (zero = 0.0E+0, one = 1.0E+0, dat1 = 7.5E-1, 
-     &           dat2 = -4.375E-1)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, i1, i2, itn, its, j, k, l, m, nh, nr
-      Real
-     &           cs, h00, h10, h11, h12, h21, h22, h33, h33s,
-     &           h43h34, h44, h44s, ovfl, s, smlnum, sn, sum,
-     &           t1, t2, t3, tst1, ulp, unfl, v1, v2, v3
-      Real
-     &           v( 3 ), work( 1 )
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch, slanhs
-      external   slamch, slanhs
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, slabad, slanv2, slarfg, srot
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      info = 0
-c
-c     %--------------------------%
-c     | Quick return if possible |
-c     %--------------------------%
-c
-      if( n.eq.0 )
-     &   return
-      if( ilo.eq.ihi ) then
-         wr( ilo ) = h( ilo, ilo )
-         wi( ilo ) = zero
-         return
-      end if
-c 
-c     %---------------------------------------------%
-c     | Initialize the vector of last components of |
-c     | the Schur vectors for accumulation.         |
-c     %---------------------------------------------%
-c
-      do 5 j = 1, n-1
-         z(j) = zero
-  5   continue 
-      z(n) = one
-c 
-      nh = ihi - ilo + 1
-c
-c     %-------------------------------------------------------------%
-c     | Set machine-dependent constants for the stopping criterion. |
-c     | If norm(H) <= sqrt(OVFL), overflow should not occur.        |
-c     %-------------------------------------------------------------%
-c
-      unfl = slamch( 'safe minimum' )
-      ovfl = one / unfl
-      call slabad( unfl, ovfl )
-      ulp = slamch( 'precision' )
-      smlnum = unfl*( nh / ulp )
-c
-c     %---------------------------------------------------------------%
-c     | I1 and I2 are the indices of the first row and last column    |
-c     | of H to which transformations must be applied. If eigenvalues |
-c     | only are computed, I1 and I2 are set inside the main loop.    |
-c     | Zero out H(J+2,J) = ZERO for J=1:N if WANTT = .TRUE.          |
-c     | else H(J+2,J) for J=ILO:IHI-ILO-1 if WANTT = .FALSE.          |
-c     %---------------------------------------------------------------%
-c
-      if( wantt ) then
-         i1 = 1
-         i2 = n
-         do 8 i=1,i2-2
-            h(i1+i+1,i) = zero
- 8       continue
-      else
-         do 9 i=1, ihi-ilo-1
-            h(ilo+i+1,ilo+i-1) = zero
- 9       continue
-      end if
-c 
-c     %---------------------------------------------------%
-c     | ITN is the total number of QR iterations allowed. |
-c     %---------------------------------------------------%
-c
-      itn = 30*nh
-c 
-c     ------------------------------------------------------------------
-c     The main loop begins here. I is the loop index and decreases from
-c     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
-c     with the active submatrix in rows and columns L to I.
-c     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
-c     H(L,L-1) is negligible so that the matrix splits.
-c     ------------------------------------------------------------------
-c 
-      i = ihi
-   10 continue
-      l = ilo
-      if( i.lt.ilo )
-     &   go to 150
- 
-c     %--------------------------------------------------------------%
-c     | Perform QR iterations on rows and columns ILO to I until a   |
-c     | submatrix of order 1 or 2 splits off at the bottom because a |
-c     | subdiagonal element has become negligible.                   |
-c     %--------------------------------------------------------------%
- 
-      do 130 its = 0, itn
-c
-c        %----------------------------------------------%
-c        | Look for a single small subdiagonal element. |
-c        %----------------------------------------------%
-c
-         do 20 k = i, l + 1, -1
-            tst1 = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
-            if( tst1.eq.zero )
-     &         tst1 = slanhs( '1', i-l+1, h( l, l ), ldh, work )
-            if( abs( h( k, k-1 ) ).le.max( ulp*tst1, smlnum ) )
-     &         go to 30
-   20    continue
-   30    continue
-         l = k
-         if( l.gt.ilo ) then
-c
-c           %------------------------%
-c           | H(L,L-1) is negligible |
-c           %------------------------%
-c
-            h( l, l-1 ) = zero
-         end if
-c
-c        %-------------------------------------------------------------%
-c        | Exit from loop if a submatrix of order 1 or 2 has split off |
-c        %-------------------------------------------------------------%
-c
-         if( l.ge.i-1 )
-     &      go to 140
-c
-c        %---------------------------------------------------------%
-c        | Now the active submatrix is in rows and columns L to I. |
-c        | If eigenvalues only are being computed, only the active |
-c        | submatrix need be transformed.                          |
-c        %---------------------------------------------------------%
-c
-         if( .not.wantt ) then
-            i1 = l
-            i2 = i
-         end if
-c 
-         if( its.eq.10 .or. its.eq.20 ) then
-c
-c           %-------------------%
-c           | Exceptional shift |
-c           %-------------------%
-c
-            s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
-            h44 = dat1*s
-            h33 = h44
-            h43h34 = dat2*s*s
-c
-         else
-c
-c           %-----------------------------------------%
-c           | Prepare to use Wilkinson's double shift |
-c           %-----------------------------------------%
-c
-            h44 = h( i, i )
-            h33 = h( i-1, i-1 )
-            h43h34 = h( i, i-1 )*h( i-1, i )
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Look for two consecutive small subdiagonal elements |
-c        %-----------------------------------------------------%
-c
-         do 40 m = i - 2, l, -1
-c
-c           %---------------------------------------------------------%
-c           | Determine the effect of starting the double-shift QR    |
-c           | iteration at row M, and see if this would make H(M,M-1) |
-c           | negligible.                                             |
-c           %---------------------------------------------------------%
-c
-            h11 = h( m, m )
-            h22 = h( m+1, m+1 )
-            h21 = h( m+1, m )
-            h12 = h( m, m+1 )
-            h44s = h44 - h11
-            h33s = h33 - h11
-            v1 = ( h33s*h44s-h43h34 ) / h21 + h12
-            v2 = h22 - h11 - h33s - h44s
-            v3 = h( m+2, m+1 )
-            s = abs( v1 ) + abs( v2 ) + abs( v3 )
-            v1 = v1 / s
-            v2 = v2 / s
-            v3 = v3 / s
-            v( 1 ) = v1
-            v( 2 ) = v2
-            v( 3 ) = v3
-            if( m.eq.l )
-     &         go to 50
-            h00 = h( m-1, m-1 )
-            h10 = h( m, m-1 )
-            tst1 = abs( v1 )*( abs( h00 )+abs( h11 )+abs( h22 ) )
-            if( abs( h10 )*( abs( v2 )+abs( v3 ) ).le.ulp*tst1 )
-     &         go to 50
-   40    continue
-   50    continue
-c
-c        %----------------------%
-c        | Double-shift QR step |
-c        %----------------------%
-c
-         do 120 k = m, i - 1
-c 
-c           ------------------------------------------------------------
-c           The first iteration of this loop determines a reflection G
-c           from the vector V and applies it from left and right to H,
-c           thus creating a nonzero bulge below the subdiagonal.
-c
-c           Each subsequent iteration determines a reflection G to
-c           restore the Hessenberg form in the (K-1)th column, and thus
-c           chases the bulge one step toward the bottom of the active
-c           submatrix. NR is the order of G.
-c           ------------------------------------------------------------
-c 
-            nr = min( 3, i-k+1 )
-            if( k.gt.m )
-     &         call scopy( nr, h( k, k-1 ), 1, v, 1 )
-            call slarfg( nr, v( 1 ), v( 2 ), 1, t1 )
-            if( k.gt.m ) then
-               h( k, k-1 ) = v( 1 )
-               h( k+1, k-1 ) = zero
-               if( k.lt.i-1 )
-     &            h( k+2, k-1 ) = zero
-            else if( m.gt.l ) then
-               h( k, k-1 ) = -h( k, k-1 )
-            end if
-            v2 = v( 2 )
-            t2 = t1*v2
-            if( nr.eq.3 ) then
-               v3 = v( 3 )
-               t3 = t1*v3
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 60 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-                  h( k+2, j ) = h( k+2, j ) - sum*t3
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 70 j = i1, min( k+3, i )
-                  sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-                  h( j, k+2 ) = h( j, k+2 ) - sum*t3
-   70          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 ) + v3*z( k+2 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-               z( k+2 ) = z( k+2 ) - sum*t3
- 
-            else if( nr.eq.2 ) then
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 90 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-   90          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 100 j = i1, i
-                  sum = h( j, k ) + v2*h( j, k+1 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-  100          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-            end if
-  120    continue
- 
-  130 continue
-c
-c     %-------------------------------------------------------%
-c     | Failure to converge in remaining number of iterations |
-c     %-------------------------------------------------------%
-c
-      info = i
-      return
- 
-  140 continue
- 
-      if( l.eq.i ) then
-c
-c        %------------------------------------------------------%
-c        | H(I,I-1) is negligible: one eigenvalue has converged |
-c        %------------------------------------------------------%
-c
-         wr( i ) = h( i, i )
-         wi( i ) = zero
-
-      else if( l.eq.i-1 ) then
-c
-c        %--------------------------------------------------------%
-c        | H(I-1,I-2) is negligible;                              |
-c        | a pair of eigenvalues have converged.                  |
-c        |                                                        |
-c        | Transform the 2-by-2 submatrix to standard Schur form, |
-c        | and compute and store the eigenvalues.                 |
-c        %--------------------------------------------------------%
-c
-         call slanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),
-     &                h( i, i ), wr( i-1 ), wi( i-1 ), wr( i ), wi( i ),
-     &                cs, sn )
- 
-         if( wantt ) then
-c
-c           %-----------------------------------------------------%
-c           | Apply the transformation to the rest of H and to Z, |
-c           | as required.                                        |
-c           %-----------------------------------------------------%
-c
-            if( i2.gt.i )
-     &         call srot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,
-     &                    cs, sn )
-            call srot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
-            sum      = cs*z( i-1 ) + sn*z( i )
-            z( i )   = cs*z( i )   - sn*z( i-1 )
-            z( i-1 ) = sum
-         end if
-      end if
-c
-c     %---------------------------------------------------------%
-c     | Decrement number of remaining iterations, and return to |
-c     | start of the main loop with new value of I.             |
-c     %---------------------------------------------------------%
-c
-      itn = itn - its
-      i = l - 1
-      go to 10
- 
-  150 continue
-      return
-c
-c     %---------------%
-c     | End of slaqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snaitr.f b/libcruft/arpack/src/snaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/snaitr.f
+++ /dev/null
@@ -1,840 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in snaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call snaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recompute in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See snaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Real N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Real (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     sgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slabad  LAPACK routine that computes machine constants.
-c     slamch  LAPACK routine that determines machine constants.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     sscal   Level 1 BLAS that scales a vector.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c 
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in snaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Real
-     &           betaj, ovfl, temp1, rnorm1, smlnum, tst1, ulp, unfl, 
-     &           wnorm
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Real
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, sgemv, sgetv0, slabad, 
-     &           svout, smout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slanhs, slamch
-      external   sdot, snrm2, slanhs, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine slahqr     |
-c        %-----------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = one / unfl
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mnaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         sgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determing whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = zero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call sgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tnaitr = tnaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call scopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. unfl) then
-             temp1 = one / rnorm
-             call sscal (n, temp1, v(1,j), 1)
-             call sscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call scopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call scopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             wnorm = sdot (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = betaj
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = sdot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call svout (logfil, 2, xtemp, ndigit, 
-     &           '_naitr: re-orthonalization; wnorm and rnorm are')
-            call svout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call saxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = sdot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = snrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call svout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tnaitr = tnaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine slahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-               if( tst1.eq.zero )
-     &              tst1 = slanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) 
-     &              h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call smout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of snaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snapps.f b/libcruft/arpack/src/snapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/snapps.f
+++ /dev/null
@@ -1,647 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge chage sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call snapps
-c     ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.  KEV is only 
-c          updated on ouput when fewer than NP shifts are applied in
-c          order to keep the conjugate pair together.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFTR, Real array of length NP.  (INPUT)
-c  SHIFTI  Real and imaginary part of the shifts to be applied.
-c          Upon, entry to snapps, the shifts must be sorted so that the 
-c          conjugate pairs are in consecutive locations.
-c
-c  V       Real N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenber matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Real KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Real work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices.
-c     svout   ARPACK utility routine that prints vectors.
-c     slabad  LAPACK routine that computes machine constants.
-c     slacpy  LAPACK matrix copy routine.
-c     slamch  LAPACK routine that determines machine constants. 
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slarf   LAPACK routine that applies Householder reflection to
-c             a matrix.
-c     slarfg  LAPACK Householder reflection construction routine.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slaset  LAPACK matrix initialization routine.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: napps.F   SID: 2.4   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine slahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     The subdiagonals of H are enforced to be non-negative.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snapps
-     &   ( n, kev, np, shiftr, shifti, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h(ldh,kev+np), resid(n), shifti(np), shiftr(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, ir, istart, j, jj, kplusp, msglvl, nr
-      logical    cconj, first
-      Real
-     &           c, f, g, h11, h12, h21, h22, h32, ovfl, r, s, sigmai, 
-     &           sigmar, smlnum, ulp, unfl, u(3), t, tau, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, slacpy, slarfg, slarf,
-     &           slaset, slabad, arscnd, slartg
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch, slanhs, slapy2
-      external   slamch, slanhs, slapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, max, min
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine slahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = one / unfl
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mnapps
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call slaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      cconj = .false.
-      do 110 jj = 1, np
-         sigmar = shiftr(jj)
-         sigmai = shifti(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call svout (logfil, 1, sigmar, ndigit, 
-     &               '_napps: The real part of the shift ')
-            call svout (logfil, 1, sigmai, ndigit, 
-     &               '_napps: The imaginary part of the shift ')
-         end if
-c
-c        %-------------------------------------------------%
-c        | The following set of conditionals is necessary  |
-c        | in order that complex conjugate pairs of shifts |
-c        | are applied together or not at all.             |
-c        %-------------------------------------------------%
-c
-         if ( cconj ) then
-c
-c           %-----------------------------------------%
-c           | cconj = .true. means the previous shift |
-c           | had non-zero imaginary part.            |
-c           %-----------------------------------------%
-c
-            cconj = .false.
-            go to 110
-         else if ( jj .lt. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %------------------------------------%
-c           | Start of a complex conjugate pair. |
-c           %------------------------------------%
-c
-            cconj = .true.
-         else if ( jj .eq. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %----------------------------------------------%
-c           | The last shift has a nonzero imaginary part. |
-c           | Don't apply it; thus the order of the        |
-c           | compressed H is order KEV+1 since only np-1  |
-c           | were applied.                                |
-c           %----------------------------------------------%
-c
-            kev = kev + 1
-            go to 110
-         end if
-         istart = 1
-   20    continue
-c
-c        %--------------------------------------------------%
-c        | if sigmai = 0 then                               |
-c        |    Apply the jj-th shift ...                     |
-c        | else                                             |
-c        |    Apply the jj-th and (jj+1)-th together ...    |
-c        |    (Note that jj < np at this point in the code) |
-c        | end                                              |
-c        | to the current block of H. The next do loop      |
-c        | determines the current block ;                   |
-c        %--------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine slahqr    |
-c           %----------------------------------------%
-c
-            tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-            if( tst1.eq.zero )
-     &         tst1 = slanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call svout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend ) go to 100
-c
-c        %------------------------------------------------------%
-c        | If istart + 1 = iend then no reason to apply a       |
-c        | complex conjugate pair of shifts on a 2 by 2 matrix. |
-c        %------------------------------------------------------%
-c
-         if ( istart + 1 .eq. iend .and. abs( sigmai ) .gt. zero ) 
-     &      go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         if ( abs( sigmai ) .le. zero ) then
-c
-c           %---------------------------------------------%
-c           | Real-valued shift ==> apply single shift QR |
-c           %---------------------------------------------%
-c
-            f = h11 - sigmar
-            g = h21
-c 
-            do 80 i = istart, iend-1
-c
-c              %-----------------------------------------------------%
-c              | Contruct the plane rotation G to zero out the bulge |
-c              %-----------------------------------------------------%
-c
-               call slartg (f, g, c, s, r)
-               if (i .gt. istart) then
-c
-c                 %-------------------------------------------%
-c                 | The following ensures that h(1:iend-1,1), |
-c                 | the first iend-2 off diagonal of elements |
-c                 | H, remain non negative.                   |
-c                 %-------------------------------------------%
-c
-                  if (r .lt. zero) then
-                     r = -r
-                     c = -c
-                     s = -s
-                  end if
-                  h(i,i-1) = r
-                  h(i+1,i-1) = zero
-               end if
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the left of H;  H <- G'*H |
-c              %---------------------------------------------%
-c
-               do 50 j = i, kplusp
-                  t        =  c*h(i,j) + s*h(i+1,j)
-                  h(i+1,j) = -s*h(i,j) + c*h(i+1,j)
-                  h(i,j)   = t   
-   50          continue
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the right of H;  H <- H*G |
-c              %---------------------------------------------%
-c
-               do 60 j = 1, min(i+2,iend)
-                  t        =  c*h(j,i) + s*h(j,i+1)
-                  h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-                  h(j,i)   = t   
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c              %----------------------------------------------------%
-c
-               do 70 j = 1, min( i+jj, kplusp ) 
-                  t        =   c*q(j,i) + s*q(j,i+1)
-                  q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                  q(j,i)   = t   
-   70          continue
-c
-c              %---------------------------%
-c              | Prepare for next rotation |
-c              %---------------------------%
-c
-               if (i .lt. iend-1) then
-                  f = h(i+1,i)
-                  g = h(i+2,i)
-               end if
-   80       continue
-c
-c           %-----------------------------------%
-c           | Finished applying the real shift. |
-c           %-----------------------------------%
-c 
-         else
-c
-c           %----------------------------------------------------%
-c           | Complex conjugate shifts ==> apply double shift QR |
-c           %----------------------------------------------------%
-c
-            h12 = h(istart,istart+1)
-            h22 = h(istart+1,istart+1)
-            h32 = h(istart+2,istart+1)
-c
-c           %---------------------------------------------------------%
-c           | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |
-c           %---------------------------------------------------------%
-c
-            s    = 2.0*sigmar
-            t = slapy2 ( sigmar, sigmai ) 
-            u(1) = ( h11 * (h11 - s) + t * t ) / h21 + h12
-            u(2) = h11 + h22 - s 
-            u(3) = h32
-c
-            do 90 i = istart, iend-1
-c
-               nr = min ( 3, iend-i+1 )
-c
-c              %-----------------------------------------------------%
-c              | Construct Householder reflector G to zero out u(1). |
-c              | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |
-c              %-----------------------------------------------------%
-c
-               call slarfg ( nr, u(1), u(2), 1, tau )
-c
-               if (i .gt. istart) then
-                  h(i,i-1)   = u(1)
-                  h(i+1,i-1) = zero
-                  if (i .lt. iend-1) h(i+2,i-1) = zero
-               end if
-               u(1) = one
-c
-c              %--------------------------------------%
-c              | Apply the reflector to the left of H |
-c              %--------------------------------------%
-c
-               call slarf ('Left', nr, kplusp-i+1, u, 1, tau,
-     &                     h(i,i), ldh, workl)
-c
-c              %---------------------------------------%
-c              | Apply the reflector to the right of H |
-c              %---------------------------------------%
-c
-               ir = min ( i+3, iend )
-               call slarf ('Right', ir, nr, u, 1, tau,
-     &                     h(1,i), ldh, workl)
-c
-c              %-----------------------------------------------------%
-c              | Accumulate the reflector in the matrix Q;  Q <- Q*G |
-c              %-----------------------------------------------------%
-c
-               call slarf ('Right', kplusp, nr, u, 1, tau, 
-     &                     q(1,i), ldq, workl)
-c
-c              %----------------------------%
-c              | Prepare for next reflector |
-c              %----------------------------%
-c
-               if (i .lt. iend-1) then
-                  u(1) = h(i+1,i)
-                  u(2) = h(i+2,i)
-                  if (i .lt. iend-2) u(3) = h(i+3,i)
-               end if
-c
-   90       continue
-c
-c           %--------------------------------------------%
-c           | Finished applying a complex pair of shifts |
-c           | to the current block                       |
-c           %--------------------------------------------%
-c 
-         end if
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %--------------------------------------------------%
-c     | Perform a similarity transformation that makes   |
-c     | sure that H will have non negative sub diagonals |
-c     %--------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( h(j+1,j) .lt. zero ) then
-              call sscal( kplusp-j+1, -one, h(j+1,j), ldh )
-              call sscal( min(j+2, kplusp), -one, h(1,j+1), 1 )
-              call sscal( min(j+np+1,kplusp), -one, q(1,j+1), 1 )
-         end if
- 120  continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine slahqr        |
-c        %--------------------------------------------%
-c
-         tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-         if( tst1.eq.zero )
-     &       tst1 = slanhs( '1', kev, h, ldh, workl )
-         if( h( i+1,i ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &    call sgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call sgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call scopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call slacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &   call scopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kplusp}'*Q)*e_{kev} |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call sscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,kev) .gt. zero)
-     &   call saxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call svout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call smout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c 
- 9000 continue
-      call arscnd (t1)
-      tnapps = tnapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of snapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snaup2.f b/libcruft/arpack/src/snaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/snaup2.f
+++ /dev/null
@@ -1,835 +0,0 @@
-c\BeginDoc
-c
-c\Name: snaup2
-c
-c\Description:
-c  Intermediate level interface called by snaupd.
-c
-c\Usage:
-c  call snaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in snaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in snaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV for two reasons. The first, is
-c          to keep complex conjugate pairs of "wanted" Ritz values
-c          together. The second, is that a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Real  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Real  arrays of length NEV+NP.  (OUTPUT)
-c  RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.
-c          imaginary) part of the computed Ritz values of OP.
-c
-c  BOUNDS  Real  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Real  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c          On exit, the last 3*(NEV+NP) locations of WORKL contain
-c          the Ritz values (real,imaginary) and associated Ritz
-c          estimates of the current Hessenberg matrix.  They are
-c          listed in the same order as returned from sneigh.
-c
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in DNAUPD.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     sgetv0  ARPACK initial vector generation routine.
-c     snaitr  ARPACK Arnoldi factorization routine.
-c     snapps  ARPACK application of implicit shifts routine.
-c     snconv  ARPACK convergence of Ritz values routine.
-c     sneigh  ARPACK compute Ritz values and error bounds routine.
-c     sngets  ARPACK reorder Ritz values and error bounds routine.
-c     ssortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.8   DATE OF SID: 10/17/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritzr, ritzi, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Real
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), resid(n),
-     &           ritzi(nev+np), ritzr(nev+np), v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm , getv0, initv, update, ushift
-      integer    ierr  , iter , j    , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0  , nptemp, numcnv
-      Real
-     &           rnorm , temp , eps23
-      save       cnorm , getv0, initv, update, ushift,
-     &           rnorm , iter , eps23, kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0  , numcnv
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(4)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sgetv0, snaitr, snconv, sneigh,
-     &           sngets, snapps, svout , ivout , arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slapy2, slamch
-      external   sdot, snrm2, slapy2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min, max, abs, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mnaup2
-c
-c        %-------------------------------------%
-c        | Get the machine dependent constant. |
-c        %-------------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call sgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call snaitr (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine snapps.                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call snaitr (ido  , bmat, n  , nev, np , mode , resid,
-     &                rnorm, v   , ldv, h  , ldh, ipntr, workd,
-     &                info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call sneigh (rnorm, kplusp, h, ldh, ritzr, ritzi, bounds,
-     &                q, ldq, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from sneigh.                       |
-c        %----------------------------------------------------%
-c
-         call scopy(kplusp, ritzr, 1, workl(kplusp**2+1), 1)
-         call scopy(kplusp, ritzi, 1, workl(kplusp**2+kplusp+1), 1)
-         call scopy(kplusp, bounds, 1, workl(kplusp**2+2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZR,   |
-c        | RITZI and BOUNDS respectively. The variables NEV  |
-c        | and NP may be updated if the NEV-th wanted Ritz   |
-c        | value has a non zero imaginary part. In this case |
-c        | NEV is increased by one and NP decreased by one.  |
-c        | NOTE: The last two arguments of sngets are no     |
-c        | longer used as of version 2.1.                    |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         numcnv = nev
-         call sngets (ishift, which, nev, np, ritzr, ritzi,
-     &                bounds, workl, workl(np+1))
-         if (nev .eq. nev0+1) numcnv = nev0+1
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call scopy (nev, bounds(np+1), 1, workl(2*np+1), 1)
-         call snconv (nev, ritzr(np+1), ritzi(np+1), workl(2*np+1),
-     &        tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = numcnv
-            kp(4) = nconv
-            call ivout (logfil, 4, kp, ndigit,
-     &                  '_naup2: NEV, NP, NUMCNV, NCONV are')
-            call svout (logfil, kplusp, ritzr, ndigit,
-     &           '_naup2: Real part of the eigenvalues of H')
-            call svout (logfil, kplusp, ritzi, ndigit,
-     &           '_naup2: Imaginary part of the eigenvalues of H')
-            call svout (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. numcnv) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call svout(logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Real part of the eig computed by _neigh:')
-               call svout(logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Imag part of the eig computed by _neigh:')
-               call svout(logfil, kplusp, workl(kplusp**2+kplusp*2+1),
-     &                     ndigit,
-     &             '_naup2: Ritz eistmates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to _neupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = rnorm
-c
-c           %----------------------------------------------%
-c           | To be consistent with sngets, we first do a  |
-c           | pre-processing sort in order to keep complex |
-c           | conjugate pairs together.  This is similar   |
-c           | to the pre-processing sort used in sngets    |
-c           | except that the sort is done in the opposite |
-c           | order.                                       |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SR'
-            if (which .eq. 'SM') wprime = 'LR'
-            if (which .eq. 'LR') wprime = 'SM'
-            if (which .eq. 'SR') wprime = 'LM'
-            if (which .eq. 'LI') wprime = 'SM'
-            if (which .eq. 'SI') wprime = 'LM'
-c
-            call ssortc (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %----------------------------------------------%
-c           | Now sort Ritz values so that converged Ritz  |
-c           | values appear within the first NEV locations |
-c           | of ritzr, ritzi and bounds, and the most     |
-c           | desired one appears at the front.            |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call ssortc(wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, numcnv
-                temp = max(eps23,slapy2(ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LR'
-            call ssortc(wprime, .true., numcnv, bounds, ritzr, ritzi)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, numcnv
-                temp = max(eps23, slapy2(ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %------------------------------------------------%
-c           | Sort the converged Ritz values again so that   |
-c           | the "threshold" value appears at the front of  |
-c           | ritzr, ritzi and bound.                        |
-c           %------------------------------------------------%
-c
-            call ssortc(which, .true., nconv, ritzr, ritzi, bounds)
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, kplusp, ritzr, ndigit,
-     &            '_naup2: Sorted real part of the eigenvalues')
-               call svout (logfil, kplusp, ritzi, ndigit,
-     &            '_naup2: Sorted imaginary part of the eigenvalues')
-               call svout (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. numcnv) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. numcnv) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. numcnv) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call sngets (ishift, which, nev, np, ritzr, ritzi,
-     &              bounds, workl, workl(np+1))
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call svout (logfil, nev, ritzr(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- real part')
-               call svout (logfil, nev, ritzi(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- imag part')
-               call svout (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: reverse comminucation to       |
-c           | compute the shifts. They are returned in the first    |
-c           | 2*NP locations of WORKL.                              |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:2*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-         if ( ishift .eq. 0 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZR, RITZI to free up WORKL    |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call scopy (np, workl,       1, ritzr, 1)
-             call scopy (np, workl(np+1), 1, ritzi, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call svout (logfil, np, ritzr, ndigit,
-     &                  '_naup2: Real part of the shifts')
-            call svout (logfil, np, ritzi, ndigit,
-     &                  '_naup2: Imaginary part of the shifts')
-            if ( ishift .eq. 1 )
-     &          call svout (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call snapps (n, nev, np, ritzr, ritzi, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to snaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = sdot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call smout (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = numcnv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tnaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of snaup2 |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/snaupd.f b/libcruft/arpack/src/snaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/snaupd.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c\BeginDoc
-c
-c\Name: snaupd
-c
-c\Description: 
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This subroutine computes approximations to a few eigenpairs 
-c  of a linear operator "OP" with respect to a semi-inner product defined by 
-c  a symmetric positive semi-definite real matrix B. B may be the identity 
-c  matrix. NOTE: If the linear operator "OP" is real and symmetric 
-c  with respect to the real positive semi-definite symmetric matrix B, 
-c  i.e. B*OP = (OP`)*B, then subroutine ssaupd should be used instead.
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  snaupd is usually called iteratively to solve one of the 
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M. 
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then 
-c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].
-c           Note: If sigma is real, i.e. imaginary part of sigma is zero;
-c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M 
-c                 amu == 1/(lambda-sigma). 
-c  
-c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M. 
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then 
-c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].
-c
-c  Both mode 3 and 4 give the same enhancement to eigenvalues close to
-c  the (complex) shift sigma.  However, as lambda goes to infinity,
-c  the operator OP in mode 4 dampens the eigenvalues more strongly than
-c  does OP defined in mode 3.
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call snaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first 
-c          call to snaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          snaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3 and 4, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) real and imaginary parts 
-c                    of the shifts where INPTR(14) is the pointer
-c                    into WORKL for placing the shifts. See Remark
-c                    5 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c             
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Real  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value 
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = SLAMCH('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine SLAMCH).
-c
-c  RESID   Real  array of length N.  (INPUT/OUTPUT)
-c          On INPUT: 
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 2 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated 
-c          at each iteration.  After the startup phase in which NEV 
-c          Arnoldi vectors are generated, the algorithm generates 
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update 
-c          iteration. Most of the cost in generating each Arnoldi vector is 
-c          in the matrix-vector operation OP*x. 
-c          NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz 
-c          values are kept together. (See remark 4 below)
-c
-c  V       Real  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors. 
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The real and imaginary
-c                      parts of the NCV eigenvalues of the Hessenberg
-c                      matrix H are returned in the part of the WORKL 
-c                      array corresponding to RITZR and RITZI. See remark 
-c                      5 below.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to 
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of approximate Schur
-c                      vectors associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed. 
-c          On OUTPUT: actual number of Arnoldi update iterations taken. 
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.  
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4; See under \Description of snaupd for the 
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), snaupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          5 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.        
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in 
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix
-c                    H in WORKL.
-c          IPNTR(6): pointer to the real part of the ritz value array 
-c                    RITZR in WORKL.
-c          IPNTR(7): pointer to the imaginary part of the ritz value array
-c                    RITZI in WORKL.
-c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZR and RITZI in WORKL.
-c
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by sneupd. See Remark 2 below.
-c
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the 
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of 
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     sneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD 
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace
-c          associated with the converged Ritz values is desired, see remark
-c          2 below, subroutine sneupd uses this output.
-c          See Data Distribution Note below.  
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 6*NCV.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)  
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the 
-c                Implicitly restarted Arnoldi iteration. One possibility 
-c                is to increase the size of NCV relative to NEV. 
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration 
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when
-c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the
-c     original problem may be obtained with the ARPACK subroutine sneupd.
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz 
-c     values is needed, the user must call sneupd immediately following 
-c     completion of snaupd. This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV + 2.
-c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will 
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically. 
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the 
-c     NP = IPARAM(8) real and imaginary parts of the shifts in locations 
-c         real part                  imaginary part
-c         -----------------------    --------------
-c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)
-c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)
-c                        .                          .
-c                        .                          .
-c                        .                          .
-c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).
-c
-c     Only complex conjugate pairs of shifts may be applied and the pairs 
-c     must be placed in consecutive locations. The real part of the 
-c     eigenvalues of the current upper Hessenberg matrix are located in 
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part 
-c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered
-c     according to the order defined by WHICH. The complex conjugate
-c     pairs are kept together and the associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note: 
-c
-c  Fortran-D syntax:
-c  ================
-c  Real  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Real   resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c  
-c  CM2/CM5 syntax:
-c  ==============
-c  
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     snaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/16/93: Version '1.1'
-c
-c\SCCS Information: @(#) 
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real 
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Real 
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw, 
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritzi, ritzr, j
-      save       bounds, ih, iq, ishift, iupd, iw, ldh, ldq,
-     &           levec, mode, msglvl, mxiter, nb, nev0, next,
-     &           np, ritzi, ritzr
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   snaup2, svout, ivout, arscnd, sstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call sstatn
-         call arscnd (t0)
-         msglvl = mnaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 4) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         end if
-c 
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c 
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. zero)			tol = slamch('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev 
-c 
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 6*ncv
-            workl(j) = zero
-  10     continue
-c 
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |
-c        |                                   parts of ritz values      |
-c        | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |
-c        | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |
-c        | The final workspace is needed by subroutine sneigh called   |
-c        | by snaup2. Subroutine sneigh calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritzr  = ih     + ldh*ncv
-         ritzi  = ritzr  + ncv
-         bounds = ritzi  + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritzr
-         ipntr(7) = ritzi
-         ipntr(8) = bounds
-         ipntr(14) = iw 
-c
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call snaup2 
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritzr), 
-     &     workl(ritzi), workl(bounds), workl(iq), ldq, workl(iw), 
-     &     ipntr, workd, info )
-c 
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c 
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within snaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call svout (logfil, np, workl(ritzr), ndigit, 
-     &               '_naupd: Real part of the final Ritz values')
-         call svout (logfil, np, workl(ritzi), ndigit, 
-     &               '_naupd: Imaginary part of the final Ritz values')
-         call svout (logfil, np, workl(bounds), ndigit, 
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tnaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tnaupd, tnaup2, tnaitr, titref,
-     &                  tgetv0, tneigh, tngets, tnapps, tnconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Nonsymmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number: ', ' 2.4' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of snaupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snconv.f b/libcruft/arpack/src/snconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/snconv.f
+++ /dev/null
@@ -1,146 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snconv
-c
-c\Description: 
-c  Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call snconv
-c     ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZR,  Real arrays of length N.  (INPUT)
-c  RITZI   Real and imaginary parts of the Ritz values to be checked
-c          for convergence.
-
-c  BOUNDS  Real array of length N.  (INPUT)
-c          Ritz estimates for the Ritz values in RITZR and RITZI.
-c
-c  TOL     Real scalar.  (INPUT)
-c          Desired backward error for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snconv (n, ritzr, ritzi, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-
-      Real
-     &           ritzr(n), ritzi(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Real
-     &           temp, eps23
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, slamch
-      external   slapy2, slamch
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------------------------------------%
-c     | Convergence test: unlike in the symmetric code, I am not    |
-c     | using things like refined error bounds and gap condition    |
-c     | because I don't know the exact equivalent concept.          |
-c     |                                                             |
-c     | Instead the i-th Ritz value is considered "converged" when: |
-c     |                                                             |
-c     |     bounds(i) .le. ( TOL * | ritz | )                       |
-c     |                                                             |
-c     | for some appropriate choice of norm.                        |
-c     %-------------------------------------------------------------%
-c
-      call arscnd (t0)
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-      nconv  = 0
-      do 20 i = 1, n
-         temp = max( eps23, slapy2( ritzr(i), ritzi(i) ) )
-         if (bounds(i) .le. tol*temp)   nconv = nconv + 1
-   20 continue
-c 
-      call arscnd (t1)
-      tnconv = tnconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of snconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sneigh.f b/libcruft/arpack/src/sneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/sneigh.f
+++ /dev/null
@@ -1,314 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call sneigh
-c     ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Real N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Real arrays of length N.  (OUTPUT)
-c  RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real 
-c          (respectively imaginary) parts of the eigenvalues of H.
-c
-c  BOUNDS  Real array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues RITZR and RITZI.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZR and RITZI.
-c
-c  Q       Real N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from slaqrb or strevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     slaqrb  ARPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix and last row of the Schur vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slacpy  LAPACK matrix copy routine.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     strevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sneigh (rnorm, n, h, ldh, ritzr, ritzi, bounds, 
-     &                   q, ldq, workl, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Real     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritzi(n), ritzr(n),
-     &           workl(n*(n+3))
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real     
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    i, iconj, msglvl
-      Real     
-     &           temp, vl(1)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, slacpy, slaqrb, strevc, svout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, snrm2
-      external   slapy2, snrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mneigh
-c 
-      if (msglvl .gt. 2) then
-          call smout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %-----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the    |
-c     |    corresponding Schur vectors and the full Schur form T  |
-c     |    of the current upper Hessenberg matrix H.              |
-c     | slaqrb returns the full Schur form of H in WORKL(1:N**2)  |
-c     | and the last components of the Schur vectors in BOUNDS.   |
-c     %-----------------------------------------------------------%
-c
-      call slacpy ('All', n, n, h, ldh, workl, n)
-      call slaqrb (.true., n, 1, n, workl, n, ritzr, ritzi, bounds,
-     &             ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and  |
-c     |    apply the last components of the Schur vectors to get  |
-c     |    the last components of the corresponding eigenvectors. |
-c     | Remember that if the i-th and (i+1)-st eigenvalues are    |
-c     | complex conjugate pairs, then the real & imaginary part   |
-c     | of the eigenvector components are split across adjacent   |
-c     | columns of Q.                                             |
-c     %-----------------------------------------------------------%
-c
-      call strevc ('R', 'A', select, n, workl, n, vl, n, q, ldq,
-     &             n, n, workl(n*n+1), ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | euclidean norms are all one. LAPACK subroutine |
-c     | strevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      iconj = 0
-      do 10 i=1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            temp = snrm2( n, q(1,i), 1 )
-            call sscal ( n, one / temp, q(1,i), 1 )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we further normalize by the      |
-c           | square root of two.                       |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               temp = slapy2( snrm2( n, q(1,i), 1 ), 
-     &                        snrm2( n, q(1,i+1), 1 ) )
-               call sscal ( n, one / temp, q(1,i), 1 )
-               call sscal ( n, one / temp, q(1,i+1), 1 )
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if         
-   10 continue
-c
-      call sgemv ('T', n, n, one, q, ldq, bounds, 1, zero, workl, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      iconj = 0
-      do 20 i = 1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            bounds(i) = rnorm * abs( workl(i) )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we need to take the magnitude    |
-c           | of the last components of the two vectors |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               bounds(i) = rnorm * slapy2( workl(i), workl(i+1) )
-               bounds(i+1) = bounds(i)
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   20 continue
-c
-      if (msglvl .gt. 2) then
-         call svout (logfil, n, ritzr, ndigit,
-     &              '_neigh: Real part of the eigenvalues of H')
-         call svout (logfil, n, ritzi, ndigit,
-     &              '_neigh: Imaginary part of the eigenvalues of H')
-         call svout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd (t1)
-      tneigh = tneigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sneupd.f b/libcruft/arpack/src/sneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/sneupd.f
+++ /dev/null
@@ -1,1067 +0,0 @@
-c\BeginDoc
-c
-c\Name: sneupd
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to SNAUPD.  SNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.  The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  See documentation in the header of the subroutine SNAUPD for 
-c  definition of OP as well as other terms and the relation of computed
-c  Ritz values and Ritz vectors of OP with respect to the given problem
-c  A*z = lambda*B*z.  For a brief description, see definitions of 
-c  IPARAM(7), MODE and WHICH in the documentation of SNAUPD.
-c
-c\Usage:
-c  call sneupd 
-c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, 
-c       LWORKL, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether a basis for the invariant subspace corresponding 
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.
-c                                See Remarks below. 
-c 
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors; 
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.
-c
-c  DR      Real  array of dimension NEV+1.  (OUTPUT)
-c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains 
-c          the real part of the Ritz  approximations to the eigenvalues of 
-c          A*z = lambda*B*z. 
-c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:
-c          DR contains the real part of the Ritz values of OP computed by 
-c          SNAUPD. A further computation must be performed by the user
-c          to transform the Ritz values computed for OP by SNAUPD to those
-c          of the original system A*z = lambda*B*z. See remark 3 below.
-c
-c  DI      Real  array of dimension NEV+1.  (OUTPUT)
-c          On exit, DI contains the imaginary part of the Ritz value 
-c          approximations to the eigenvalues of A*z = lambda*B*z associated
-c          with DR.
-c
-c          NOTE: When Ritz values are complex, they will come in complex 
-c                conjugate pairs.  If eigenvectors are requested, the 
-c                corresponding Ritz vectors will also come in conjugate 
-c                pairs and the real and imaginary parts of these are 
-c                represented in two consecutive columns of the array Z 
-c                (see below).
-c
-c  Z       Real  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represent approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem 
-c          A*z = lambda*B*z. 
-c 
-c          The complex Ritz vector associated with the Ritz value 
-c          with positive imaginary part is stored in two consecutive 
-c          columns.  The first column holds the real part of the Ritz 
-c          vector and the second column holds the imaginary part.  The 
-c          Ritz vector associated with the Ritz value with negative 
-c          imaginary part is simply the complex conjugate of the Ritz vector 
-c          associated with the positive imaginary part.
-c
-c          If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by SNAUPD.  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.
-c
-c  SIGMAR  Real   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the real part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  SIGMAI  Real   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.
-c
-c  WORKEV  Real  work array of dimension 3*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to SNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to SNEUPD following the last call
-c         to SNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to SNAUPD and the call to SNEUPD.
-c
-c  Three of these parameters (V, WORKL, INFO) are also output parameters:
-c
-c  V       Real  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by SNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.  See Remark 2 below.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in
-c          snaupd.  They are not changed by sneupd.
-c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the
-c          real and imaginary part of the untransformed Ritz values,
-c          the upper quasi-triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by sneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     sneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine slahqr
-c                could not be reordered by LAPACK routine strsen.
-c                Re-enter subroutine sneupd with IPARAM(5)=NCV and 
-c                increase the size of the arrays DR and DI to have 
-c                dimension at least dimension NCV and allocate at least NCV 
-c                columns for Z. NOTE: Not necessary if Z and V share 
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine slahqr.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine strevc.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: SNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: DNEUPD got a different count of the number of converged
-c                 Ritz values than DNAUPD got.  This indicates the user
-c                 probably made an error in passing data from DNAUPD to
-c                 DNEUPD or that the data was modified before entering
-c                 DNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     sgeqr2  LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     slacpy  LAPACK matrix copy routine.
-c     slahqr  LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slaset  LAPACK matrix initialization routine.
-c     sorm2r  LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     strevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form.
-c     strsen  LAPACK routine that re-orders the Schur form.
-c     strmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     sger    Level 2 BLAS rank one update to a matrix.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c     Let trans(X) denote the transpose of X.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .TRUE. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately 
-c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the 
-c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,
-c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; 
-c     each 2-by-2 diagonal block has its diagonal elements equal and its
-c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
-c     diagonal block is a complex conjugate pair of Ritz values. The real
-c     Ritz values are stored on the diagonal of T.
-c
-c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must
-c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz
-c     values computed by SNAUPD for OP to those of A*z = lambda*B*z. 
-c     Set RVEC = .true. and HOWMNY = 'A', and
-c     compute 
-c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.
-c     If DI(I) is not equal to zero and DI(I+1) = - D(I), 
-c     then the desired real and imaginary parts of the Ritz value are
-c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),
-c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I), 
-c     respectively.
-c     Another possibility is to set RVEC = .true. and HOWMNY = 'P' and
-c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper
-c     quasi-triangular matrix of order IPARAM(5) is computed. See remark
-c     2 above.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics          
-c     Rice University           
-c     Houston, Texas            
-c 
-c\SCCS Information: @(#) 
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine sneupd(rvec , howmny, select, dr    , di,    
-     &                   z    , ldz   , sigmar, sigmai, workev,
-     &                   bmat , n     , which , nev   , tol,
-     &                   resid, ncv   , v     , ldv   , iparam,
-     &                   ipntr, workd , workl , lworkl, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Real      
-     &           sigmar, sigmai, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Real 
-     &           dr(nev+1)    , di(nev+1), resid(n)  , 
-     &           v(ldv,ncv)   , z(ldz,*) , workd(3*n), 
-     &           workl(lworkl), workev(3*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds   , 
-     &           iheigr, iheigi, iconj , nconv   , 
-     &           invsub, iuptri, iwev  , iwork(1),
-     &           j     , k     , ldh   , ldq     ,
-     &           mode  , msglvl, outncv, ritzr   ,
-     &           ritzi , wri   , wrr   , irr     ,
-     &           iri   , ibd   , ishift, numcnv  ,
-     &           np    , jj    , nconv2
-      logical    reord
-      Real 
-     &           conds  , rnorm, sep  , temp,
-     &           vl(1,1), temp1, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sger  , sgeqr2, slacpy, 
-     &           slahqr, slaset, smout , sorm2r, 
-     &           strevc, strmm , strsen, sscal , 
-     &           svout , ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           slapy2, snrm2, slamch, sdot
-      external   slapy2, snrm2, slamch, sdot
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, min, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mneupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 .and. sigmai .eq. zero) then
-         type = 'SHIFTI'
-      else if (mode .eq. 3 ) then
-         type = 'REALPT'
-      else if (mode .eq. 4 ) then
-         type = 'IMAGPT'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |
-c     |                                   parts of ritz values |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by SNEUPD.                  |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                             real part of the Ritz values. |
-c     | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |
-c     |                        imaginary part of the Ritz values. |
-c     | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |
-c     |                           error bounds of the Ritz values |
-c     | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |
-c     |                             quasi-triangular matrix for H |
-c     | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |
-c     |       associated matrix representation of the invariant   |
-c     |       subspace for H.                                     |
-c     | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritzr  = ipntr(6)
-      ritzi  = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheigr = bounds + ldh
-      iheigi = iheigr + ldh
-      ihbds  = iheigi + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheigr
-      ipntr(10) = iheigi
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wrr = 1
-      wri = ncv + 1
-      iwev = wri + ncv
-c
-c     %-----------------------------------------%
-c     | irr points to the REAL part of the Ritz |
-c     |     values computed by _neigh before    |
-c     |     exiting _naup2.                     |
-c     | iri points to the IMAGINARY part of the |
-c     |     Ritz values computed by _neigh      |
-c     |     before exiting _naup2.              |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irr = ipntr(14)+ncv*ncv
-      iri = irr+ncv
-      ibd = iri+ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call svout(logfil, ncv, workl(irr), ndigit,
-     &   '_neupd: Real part of Ritz values passed in from _NAUPD.')
-         call svout(logfil, ncv, workl(iri), ndigit,
-     &   '_neupd: Imag part of Ritz values passed in from _NAUPD.')
-         call svout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c     
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call sngets(ishift       , which     , nev       , 
-     &                np           , workl(irr), workl(iri),
-     &                workl(bounds), workl     , workl(np+1))
-c
-         if (msglvl .gt. 2) then
-            call svout(logfil, ncv, workl(irr), ndigit,
-     &      '_neupd: Real part of Ritz values after calling _NGETS.')
-            call svout(logfil, ncv, workl(iri), ndigit,
-     &      '_neupd: Imag part of Ritz values after calling _NGETS.')
-            call svout(logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23,
-     &                 slapy2( workl(irr+ncv-j), workl(iri+ncv-j) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine slahqr to compute the real Schur form |
-c        | of the upper Hessenberg matrix returned by SNAUPD.        |
-c        | Make a copy of the upper Hessenberg matrix.               |
-c        | Initialize the Schur vector matrix Q to the identity.     |
-c        %-----------------------------------------------------------%
-c     
-         call scopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call slaset('All', ncv, ncv, 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call slahqr(.true., .true.       , ncv, 
-     &                1     , ncv          , workl(iuptri), 
-     &                ldh   , workl(iheigr), workl(iheigi),
-     &                1     , ncv          , workl(invsub), 
-     &                ldq   , ierr)
-         call scopy(ncv         , workl(invsub+ncv-1), ldq, 
-     &               workl(ihbds), 1)
-c     
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c     
-         if (msglvl .gt. 1) then
-            call svout(logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H')
-            call svout(logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imaginary part of the Eigenvalues of H')
-            call svout(logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call smout(logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper quasi-triangular matrix ')
-            end if
-         end if 
-c
-         if (reord) then
-c     
-c           %-----------------------------------------------------%
-c           | Reorder the computed upper quasi-triangular matrix. | 
-c           %-----------------------------------------------------%
-c     
-            call strsen('None'       , 'V'          , 
-     &                   select       , ncv          ,
-     &                   workl(iuptri), ldh          , 
-     &                   workl(invsub), ldq          , 
-     &                   workl(iheigr), workl(iheigi), 
-     &                   nconv2       , conds        ,
-     &                   sep          , workl(ihbds) , 
-     &                   ncv          , iwork        ,
-     &                   1            , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call svout(logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H--reordered')
-                call svout(logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imag part of the eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call smout(logfil       , ncv, ncv   , 
-     &                         workl(iuptri), ldq, ndigit,
-     &             '_neupd: Quasi-triangular matrix after re-ordering')
-                end if
-            end if
-c     
-         end if
-c
-c        %---------------------------------------%
-c        | Copy the last row of the Schur vector |
-c        | into workl(ihbds).  This will be used |
-c        | to compute the Ritz estimates of      |
-c        | converged Ritz values.                |
-c        %---------------------------------------%
-c
-         call scopy(ncv, workl(invsub+ncv-1), ldq, workl(ihbds), 1)
-c
-c        %----------------------------------------------------%
-c        | Place the computed eigenvalues of H into DR and DI |
-c        | if a spectral transformation was not used.         |
-c        %----------------------------------------------------%
-c
-         if (type .eq. 'REGULR') then 
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-         end if
-c     
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c     
-         call sgeqr2(ncv, nconv , workl(invsub), 
-     &               ldq, workev, workev(ncv+1),
-     &               ierr)
-c
-c        %---------------------------------------------------------%
-c        | * Postmultiply V by Q using sorm2r.                     |   
-c        | * Copy the first NCONV columns of VQ into Z.            |
-c        | * Postmultiply Z by R.                                  |
-c        | The N by NCONV matrix Z is now a matrix representation  |
-c        | of the approximate invariant subspace associated with   |
-c        | the Ritz values in workl(iheigr) and workl(iheigi)      |
-c        | The first NCONV columns of V are now approximate Schur  |
-c        | vectors associated with the real upper quasi-triangular |
-c        | matrix of order NCONV in workl(iuptri)                  |
-c        %---------------------------------------------------------%
-c     
-         call sorm2r('Right', 'Notranspose', n            , 
-     &                ncv   , nconv        , workl(invsub),
-     &                ldq   , workev       , v            , 
-     &                ldv   , workd(n+1)   , ierr)
-         call slacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c     
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | quasi-triangular form of workl(iuptri,ldq)        |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones           |
-c           %---------------------------------------------------%
-c     
-            if (workl(invsub+(j-1)*ldq+j-1) .lt. zero) then
-               call sscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call sscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c     
- 20      continue
-c     
-         if (howmny .eq. 'A') then
-c     
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T | 
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c     
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call strevc('Right', 'Select'     , select       , 
-     &                   ncv    , workl(iuptri), ldq          , 
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c     
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | strevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1;                                   |
-c           %------------------------------------------------%
-c     
-            iconj = 0
-            do 40 j=1, nconv
-c
-               if ( workl(iheigi+j-1) .eq. zero ) then
-c     
-c                 %----------------------%
-c                 | real eigenvalue case |
-c                 %----------------------%
-c     
-                  temp = snrm2( ncv, workl(invsub+(j-1)*ldq), 1 )
-                  call sscal( ncv, one / temp, 
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-               else
-c     
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 | columns, we further normalize by the      |
-c                 | square root of two.                       |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     temp = slapy2(snrm2(ncv, 
-     &                                   workl(invsub+(j-1)*ldq), 
-     &                                   1),
-     &                             snrm2(ncv, 
-     &                                   workl(invsub+j*ldq),
-     &                                   1))  
-                     call sscal(ncv, one/temp, 
-     &                           workl(invsub+(j-1)*ldq), 1 )
-                     call sscal(ncv, one/temp, 
-     &                           workl(invsub+j*ldq), 1 )
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-c
-               end if
-c
- 40         continue
-c
-            call sgemv('T', ncv, nconv, one, workl(invsub),
-     &                 ldq, workl(ihbds), 1, zero,  workev, 1)
-c
-            iconj = 0
-            do 45 j=1, nconv
-               if (workl(iheigi+j-1) .ne. zero) then
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     workev(j) = slapy2(workev(j), workev(j+1))
-                     workev(j+1) = workev(j)
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-               end if
- 45         continue
-c
-            if (msglvl .gt. 2) then
-               call scopy(ncv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call svout(logfil, ncv, workl(ihbds), ndigit,
-     &              '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call smout(logfil, ncv, ncv, workl(invsub), ldq, 
-     &                 ndigit, '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call scopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %---------------------------------------------------------%
-c           | Compute the QR factorization of the eigenvector matrix  |
-c           | associated with leading portion of T in the first NCONV |
-c           | columns of workl(invsub,ldq).                           |
-c           %---------------------------------------------------------%
-c     
-            call sgeqr2(ncv, nconv , workl(invsub), 
-     &                   ldq, workev, workev(ncv+1),
-     &                   ierr)
-c     
-c           %----------------------------------------------%
-c           | * Postmultiply Z by Q.                       |   
-c           | * Postmultiply Z by R.                       |
-c           | The N by NCONV matrix Z is now contains the  | 
-c           | Ritz vectors associated with the Ritz values |
-c           | in workl(iheigr) and workl(iheigi).          |
-c           %----------------------------------------------%
-c     
-            call sorm2r('Right', 'Notranspose', n            ,
-     &                   ncv  , nconv        , workl(invsub),
-     &                   ldq  , workev       , z            ,
-     &                   ldz  , workd(n+1)   , ierr)
-c     
-            call strmm('Right'   , 'Upper'       , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-c     
-         end if
-c     
-      else 
-c
-c        %------------------------------------------------------%
-c        | An approximate invariant subspace is not needed.     |
-c        | Place the Ritz values computed SNAUPD into DR and DI |
-c        %------------------------------------------------------%
-c
-         call scopy(nconv, workl(ritzr), 1, dr, 1)
-         call scopy(nconv, workl(ritzi), 1, di, 1)
-         call scopy(nconv, workl(ritzr), 1, workl(iheigr), 1)
-         call scopy(nconv, workl(ritzi), 1, workl(iheigi), 1)
-         call scopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-      end if
-c 
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call sscal(ncv, rnorm, workl(ihbds), 1)     
-c     
-      else 
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then
-c
-            if (rvec) 
-     &         call sscal(ncv, rnorm, workl(ihbds), 1)
-c
-            do 50 k=1, ncv
-               temp = slapy2( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(ihbds+k-1) = abs( workl(ihbds+k-1) ) 
-     &                          / temp / temp
- 50         continue
-c
-         else if (type .eq. 'REALPT') then
-c
-            do 60 k=1, ncv
- 60         continue
-c
-         else if (type .eq. 'IMAGPT') then
-c
-            do 70 k=1, ncv
- 70         continue
-c
-         end if
-c     
-c        %-----------------------------------------------------------%
-c        | *  Transform the Ritz values back to the original system. |
-c        |    For TYPE = 'SHIFTI' the transformation is              |
-c        |             lambda = 1/theta + sigma                      |
-c        |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |
-c        |    Rayleigh quotients or a projection. See remark 3 above.| 
-c        | NOTES:                                                    |
-c        | *The Ritz vectors are not affected by the transformation. |
-c        %-----------------------------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               temp = slapy2( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(iheigr+k-1) = workl(iheigr+k-1)/temp/temp 
-     &                           + sigmar   
-               workl(iheigi+k-1) = -workl(iheigi+k-1)/temp/temp
-     &                           + sigmai   
- 80         continue
-c
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-c
-         else if (type .eq. 'REALPT' .or. type .eq. 'IMAGPT') then
-c
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-c
-         end if
-c
-      end if
-c
-      if (type .eq. 'SHIFTI' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, dr, ndigit,
-     &   '_neupd: Untransformed real part of the Ritz valuess.')
-         call svout (logfil, nconv, di, ndigit,
-     &   '_neupd: Untransformed imag part of the Ritz valuess.')
-         call svout(logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Ritz estimates of untransformed Ritz values.')
-      else if (type .eq. 'REGULR' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, dr, ndigit,
-     &   '_neupd: Real parts of converged Ritz values.')
-         call svout (logfil, nconv, di, ndigit,
-     &   '_neupd: Imag parts of converged Ritz values.')
-         call svout(logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Associated Ritz estimates.')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 2.                                   |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta. Remember that when theta  |
-c        | has nonzero imaginary part, the corresponding  |
-c        | Ritz vector is stored across two columns of Z. |
-c        %------------------------------------------------%
-c
-         iconj = 0
-         do 110 j=1, nconv
-            if (workl(iheigi+j-1) .eq. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheigr+j-1)
-            else if (iconj .eq. 0) then
-               temp = slapy2( workl(iheigr+j-1), workl(iheigi+j-1) )
-               workev(j) = ( workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                       workl(iheigr+j-1) +
-     &                       workl(invsub+j*ldq+ncv-1) * 
-     &                       workl(iheigi+j-1) ) / temp / temp
-               workev(j+1) = ( workl(invsub+j*ldq+ncv-1) * 
-     &                         workl(iheigr+j-1) -
-     &                         workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                         workl(iheigi+j-1) ) / temp / temp
-               iconj = 1
-            else
-               iconj = 0
-            end if
- 110     continue
-c
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call sger(n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of SNEUPD |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sngets.f b/libcruft/arpack/src/sngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/sngets.f
+++ /dev/null
@@ -1,231 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call sngets
-c     ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest real part.
-c          'SR' -> want the KEV eigenvalues of smallest real part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV      Integer.  (INPUT/OUTPUT)
-c           INPUT: KEV+NP is the size of the matrix H.
-c           OUTPUT: Possibly increases KEV by one to keep complex conjugate
-c           pairs together.
-c
-c  NP       Integer.  (INPUT/OUTPUT)
-c           Number of implicit shifts to be computed.
-c           OUTPUT: Possibly decreases NP by one to keep complex conjugate
-c           pairs together.
-c
-c  RITZR,  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c  RITZI   On INPUT, RITZR and RITZI contain the real and imaginary 
-c          parts of the eigenvalues of H.
-c          On OUTPUT, RITZR and RITZI are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     ssortc  ARPACK sorting routine.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sngets ( ishift, which, kev, np, ritzr, ritzi, bounds,
-     &                    shiftr, shifti )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(kev+np), ritzr(kev+np), ritzi(kev+np), 
-     &           shiftr(1), shifti(1)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0, zero = 0.0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, ssortc, arscnd
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mngets
-c 
-c     %----------------------------------------------------%
-c     | LM, SM, LR, SR, LI, SI case.                       |
-c     | Sort the eigenvalues of H into the desired order   |
-c     | and apply the resulting order to BOUNDS.           |
-c     | The eigenvalues are sorted so that the wanted part |
-c     | are always in the last KEV locations.              |
-c     | We first do a pre-processing sort in order to keep |
-c     | complex conjugate pairs together                   |
-c     %----------------------------------------------------%
-c
-      if (which .eq. 'LM') then
-         call ssortc ('LR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SM') then
-         call ssortc ('SR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LR') then
-         call ssortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SR') then
-         call ssortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LI') then
-         call ssortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SI') then
-         call ssortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      end if
-c      
-      call ssortc (which, .true., kev+np, ritzr, ritzi, bounds)
-c     
-c     %-------------------------------------------------------%
-c     | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |
-c     | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |
-c     | Accordingly decrease NP by one. In other words keep   |
-c     | complex conjugate pairs together.                     |
-c     %-------------------------------------------------------%
-c     
-      if (       ( ritzr(np+1) - ritzr(np) ) .eq. zero
-     &     .and. ( ritzi(np+1) + ritzi(np) ) .eq. zero ) then
-         np = np - 1
-         kev = kev + 1
-      end if
-c
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when they shifts |
-c        | are applied in subroutine snapps.                     |
-c        | Be careful and use 'SR' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call ssortc ( 'SR', .true., np, bounds, ritzr, ritzi )
-      end if
-c     
-      call arscnd (t1)
-      tngets = tngets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call svout (logfil, kev+np, ritzr, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- real part')
-         call svout (logfil, kev+np, ritzi, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- imag part')
-         call svout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of sngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/ssaitr.f b/libcruft/arpack/src/ssaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssaitr.f
+++ /dev/null
@@ -1,853 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step symmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in ssaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call ssaitr
-c     ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and does not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of matrix B that defines the
-c          semi-inner product for the operator OP.  See ssaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current order of H and the number of columns of V.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  MODE    Integer.  (INPUT)
-c          Signifies which form for "OP". If MODE=2 then
-c          a reduction in the number of B matrix vector multiplies
-c          is possible since the B-norm of OP*x is equivalent to
-c          the inv(B)-norm of A*x.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          On INPUT the B-norm of r_{k}.
-c          On OUTPUT the B-norm of the updated residual r_{k+p}.
-c
-c  V       Real N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Real (K+NP) by 2 array.  (INPUT/OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          with the subdiagonal in the first column starting at H(2,1)
-c          and the main diagonal in the second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On INPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K step Arnoldi factorization. Used to save some 
-c          computation at the first step. 
-c          On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K+NP step Arnoldi factorization.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of an invariant subspace of OP is found that is
-c               less than K + NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     sgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     smout   ARPACK utility routine that prints matrices.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     sscal   Level 1 BLAS that scales a vector.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     xx/xx/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in ssaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        alphaj <- j-th component of w_{j}
-c        rnorm = || r_{j} ||
-c        betaj+1 = rnorm
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaitr
-     &   (ido, bmat, n, k, np, mode, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, mode, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           h(ldh,2), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl, 
-     &           infol, jj
-      Real
-     &           rnorm1, wnorm, safmin, temp1
-      save       orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           rnorm1, safmin, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Real
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, sgemv, sgetv0, svout, smout,
-     &           slascl, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slamch
-      external   sdot, snrm2, slamch
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         first = .false.
-c
-c        %--------------------------------%
-c        | safmin = safe minimum is such  |
-c        | that 1/sfmin does not overflow |
-c        %--------------------------------%
-c
-         safmin = slamch('safmin')
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-c 
-c        %--------------------------------%
-c        | Pointer to the current step of |
-c        | the factorization to build     |
-c        %--------------------------------%
-c
-         j      = k + 1
-c 
-c        %------------------------------------------%
-c        | Pointers used for reverse communication  |
-c        | when using WORKD.                        |
-c        %------------------------------------------%
-c
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true.                                  |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         sgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %------------------------------%
-c     | Else this is the first step. |
-c     %------------------------------%
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_saitr: generating Arnoldi vector no.')
-            call svout (logfil, 1, rnorm, ndigit, 
-     &                  '_saitr: B-norm of the current residual =')
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Check for exact zero. Equivalent to determing whether a |
-c        | j-step Arnoldi factorization is present.                |
-c        %---------------------------------------------------------%
-c
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_saitr: ****** restart at step ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call sgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tsaitr = tsaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call scopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. safmin) then
-             temp1 = one / rnorm
-             call sscal (n, temp1, v(1,j), 1)
-             call sscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c 
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call scopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000
-   50    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |
-c        %-----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-c 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call scopy (n, workd(irj), 1, resid, 1)
-c 
-c        %-------------------------------------------%
-c        | STEP 4:  Finish extending the symmetric   |
-c        |          Arnoldi to length j. If MODE = 2 |
-c        |          then B*OP = B*inv(B)*A = A and   |
-c        |          we don't need to compute B*OP.   |
-c        | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |
-c        | assumed to have A*v_{j}.                  |
-c        %-------------------------------------------%
-c
-         if (mode .eq. 2) go to 65
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-              call scopy(n, resid, 1 , workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |
-c        %-----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-   65    continue
-         if (mode .eq. 2) then
-c
-c           %----------------------------------%
-c           | Note that the B-norm of OP*v_{j} |
-c           | is the inv(B)-norm of A*v_{j}.   |
-c           %----------------------------------%
-c
-            wnorm = sdot (n, resid, 1, workd(ivj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'G') then         
-            wnorm = sdot (n, resid, 1, workd(ipj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         if (mode .ne. 2 ) then
-            call sgemv('T', n, j, one, v, ldv, workd(ipj), 1, zero, 
-     &                  workd(irj), 1)
-         else if (mode .eq. 2) then
-            call sgemv('T', n, j, one, v, ldv, workd(ivj), 1, zero, 
-     &                  workd(irj), 1)
-         end if
-c
-c        %--------------------------------------%
-c        | Orthgonalize r_{j} against V_{j}.    |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call sgemv('N', n, j, -one, v, ldv, workd(irj), 1, one, 
-     &               resid, 1)
-c
-c        %--------------------------------------%
-c        | Extend H to have j rows and columns. |
-c        %--------------------------------------%
-c
-         h(j,2) = workd(irj + j - 1)
-         if (j .eq. 1  .or.  rstart) then
-            h(j,1) = zero
-         else
-            h(j,1) = rnorm
-         end if
-         call arscnd (t4)
-c 
-         orth1 = .true.
-         iter  = 0
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = sdot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call svout (logfil, 2, xtemp, ndigit, 
-     &           '_saitr: re-orthonalization ; wnorm and rnorm are')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %----------------------------------------------%
-c        | Compute the correction to the residual:      |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J) + |
-c        | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |
-c        | H(j,j) is updated.                           |
-c        %----------------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-c
-         if (j .eq. 1  .or.  rstart) h(j,1) = zero
-         h(j,2) = h(j,2) + workd(irj + j - 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = sdot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = snrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_saitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call svout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c 
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %--------------------------------%
-c           | No need for further refinement |
-c           %--------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %----------------------------------------------------------%
-c        | Make sure the last off-diagonal element is non negative  |
-c        | If not perform a similarity transformation on H(1:j,1:j) |
-c        | and scale v(:,j) by -1.                                  |
-c        %----------------------------------------------------------%
-c
-         if (h(j,1) .lt. zero) then
-            h(j,1) = -h(j,1)
-            if ( j .lt. k+np) then 
-               call sscal(n, -one, v(1,j+1), 1)
-            else
-               call sscal(n, -one, resid, 1)
-            end if
-         end if
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tsaitr = tsaitr + (t1 - t0)
-            ido = 99
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, k+np, h(1,2), ndigit, 
-     &         '_saitr: main diagonal of matrix H of step K+NP.')
-               if (k+np .gt. 1) then
-               call svout (logfil, k+np-1, h(2,1), ndigit, 
-     &         '_saitr: sub diagonal of matrix H of step K+NP.')
-               end if
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssapps.f b/libcruft/arpack/src/ssapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssapps.f
+++ /dev/null
@@ -1,516 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP shifts implicitly resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix of order KEV+NP. Q is the product of 
-c  rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi 
-c  factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call ssapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. dimension of matrix A.
-c
-c  KEV     Integer.  (INPUT)
-c          INPUT: KEV+NP is the size of the input matrix H.
-c          OUTPUT: KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Real array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Real N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          INPUT: V contains the current KEV+NP Arnoldi vectors.
-c          OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors
-c          are in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (KEV+NP) by 2 array.  (INPUT/OUTPUT)
-c          INPUT: H contains the symmetric tridiagonal matrix of the
-c          Arnoldi factorization with the subdiagonal in the 1st column
-c          starting at H(2,1) and the main diagonal in the 2nd column.
-c          OUTPUT: H contains the updated tridiagonal matrix in the 
-c          KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length (N).  (INPUT/OUTPUT)
-c          INPUT: RESID contains the the residual vector r_{k+p}.
-c          OUTPUT: RESID is the updated residual vector rnew_{k}.
-c
-c  Q       Real KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations during the bulge
-c          chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKD   Real work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers. 
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slacpy  LAPACK matrix copy routine.
-c     slaset  LAPACK matrix initialization routine.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: sapps.F   SID: 2.6   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the subblocks of
-c     the tridiagonal matrix H and not just to the submatrix that it 
-c     comes from. This routine assumes that the subdiagonal elements 
-c     of H that are stored in h(1:kev+np,1) are nonegative upon input
-c     and enforce this condition upon output. This version incorporates
-c     deflation. See code for documentation.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h(ldh,2), q(ldq,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, iend, istart, itop, j, jj, kplusp, msglvl
-      logical    first
-      Real
-     &           a1, a2, a3, a4, big, c, epsmch, f, g, r, s
-      save       epsmch, first
-c
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, slacpy, slartg, slaset, svout, 
-     &           ivout, arscnd, sgemv
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         epsmch = slamch('Epsilon-Machine')
-         first = .false.
-      end if
-      itop = 1
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msapps
-c 
-      kplusp = kev + np 
-c 
-c     %----------------------------------------------%
-c     | Initialize Q to the identity matrix of order |
-c     | kplusp used to accumulate the rotations.     |
-c     %----------------------------------------------%
-c
-      call slaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c 
-c     %----------------------------------------------------------%
-c     | Apply the np shifts implicitly. Apply each shift to the  |
-c     | whole matrix and not just to the submatrix from which it |
-c     | comes.                                                   |
-c     %----------------------------------------------------------%
-c
-      do 90 jj = 1, np
-c 
-         istart = itop
-c
-c        %----------------------------------------------------------%
-c        | Check for splitting and deflation. Currently we consider |
-c        | an off-diagonal element h(i+1,1) negligible if           |
-c        |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |
-c        | for i=1:KEV+NP-1.                                        |
-c        | If above condition tests true then we set h(i+1,1) = 0.  |
-c        | Note that h(1:KEV+NP,1) are assumed to be non negative.  |
-c        %----------------------------------------------------------%
-c
-   20    continue
-c
-c        %------------------------------------------------%
-c        | The following loop exits early if we encounter |
-c        | a negligible off diagonal element.             |
-c        %------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-            big   = abs(h(i,2)) + abs(h(i+1,2))
-            if (h(i+1,1) .le. epsmch*big) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_sapps: occured before shift number.')
-                  call svout (logfil, 1, h(i+1,1), ndigit, 
-     &                 '_sapps: the corresponding off diagonal element')
-               end if
-               h(i+1,1) = zero
-               iend = i
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (istart .lt. iend) then
-c 
-c           %--------------------------------------------------------%
-c           | Construct the plane rotation G'(istart,istart+1,theta) |
-c           | that attempts to drive h(istart+1,1) to zero.          |
-c           %--------------------------------------------------------%
-c
-             f = h(istart,2) - shift(jj)
-             g = h(istart+1,1)
-             call slartg (f, g, c, s, r)
-c 
-c            %-------------------------------------------------------%
-c            | Apply rotation to the left and right of H;            |
-c            | H <- G' * H * G,  where G = G(istart,istart+1,theta). |
-c            | This will create a "bulge".                           |
-c            %-------------------------------------------------------%
-c
-             a1 = c*h(istart,2)   + s*h(istart+1,1)
-             a2 = c*h(istart+1,1) + s*h(istart+1,2)
-             a4 = c*h(istart+1,2) - s*h(istart+1,1)
-             a3 = c*h(istart+1,1) - s*h(istart,2) 
-             h(istart,2)   = c*a1 + s*a2
-             h(istart+1,2) = c*a4 - s*a3
-             h(istart+1,1) = c*a3 + s*a4
-c 
-c            %----------------------------------------------------%
-c            | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c            %----------------------------------------------------%
-c
-             do 60 j = 1, min(istart+jj,kplusp)
-                a1            =   c*q(j,istart) + s*q(j,istart+1)
-                q(j,istart+1) = - s*q(j,istart) + c*q(j,istart+1)
-                q(j,istart)   = a1
-   60        continue
-c
-c
-c            %----------------------------------------------%
-c            | The following loop chases the bulge created. |
-c            | Note that the previous rotation may also be  |
-c            | done within the following loop. But it is    |
-c            | kept separate to make the distinction among  |
-c            | the bulge chasing sweeps and the first plane |
-c            | rotation designed to drive h(istart+1,1) to  |
-c            | zero.                                        |
-c            %----------------------------------------------%
-c
-             do 70 i = istart+1, iend-1
-c 
-c               %----------------------------------------------%
-c               | Construct the plane rotation G'(i,i+1,theta) |
-c               | that zeros the i-th bulge that was created   |
-c               | by G(i-1,i,theta). g represents the bulge.   |
-c               %----------------------------------------------%
-c
-                f = h(i,1)
-                g = s*h(i+1,1)
-c
-c               %----------------------------------%
-c               | Final update with G(i-1,i,theta) |
-c               %----------------------------------%
-c
-                h(i+1,1) = c*h(i+1,1)
-                call slartg (f, g, c, s, r)
-c
-c               %-------------------------------------------%
-c               | The following ensures that h(1:iend-1,1), |
-c               | the first iend-2 off diagonal of elements |
-c               | H, remain non negative.                   |
-c               %-------------------------------------------%
-c
-                if (r .lt. zero) then
-                   r = -r
-                   c = -c
-                   s = -s
-                end if
-c 
-c               %--------------------------------------------%
-c               | Apply rotation to the left and right of H; |
-c               | H <- G * H * G',  where G = G(i,i+1,theta) |
-c               %--------------------------------------------%
-c
-                h(i,1) = r
-c 
-                a1 = c*h(i,2)   + s*h(i+1,1)
-                a2 = c*h(i+1,1) + s*h(i+1,2)
-                a3 = c*h(i+1,1) - s*h(i,2)
-                a4 = c*h(i+1,2) - s*h(i+1,1)
-c 
-                h(i,2)   = c*a1 + s*a2
-                h(i+1,2) = c*a4 - s*a3
-                h(i+1,1) = c*a3 + s*a4
-c 
-c               %----------------------------------------------------%
-c               | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c               %----------------------------------------------------%
-c
-                do 50 j = 1, min( i+jj, kplusp )
-                   a1       =   c*q(j,i) + s*q(j,i+1)
-                   q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                   q(j,i)   = a1
-   50           continue
-c
-   70        continue
-c
-         end if
-c
-c        %--------------------------%
-c        | Update the block pointer |
-c        %--------------------------%
-c
-         istart = iend + 1
-c
-c        %------------------------------------------%
-c        | Make sure that h(iend,1) is non-negative |
-c        | If not then set h(iend,1) <-- -h(iend,1) |
-c        | and negate the last column of Q.         |
-c        | We have effectively carried out a        |
-c        | similarity on transformation H           |
-c        %------------------------------------------%
-c
-         if (h(iend,1) .lt. zero) then
-             h(iend,1) = -h(iend,1)
-             call sscal(kplusp, -one, q(1,iend), 1)
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any |
-c        %--------------------------------------------------------%
-c
-         if (iend .lt. kplusp) go to 20
-c
-c        %-----------------------------------------------------%
-c        | Check if we can increase the the start of the block |
-c        %-----------------------------------------------------%
-c
-         do 80 i = itop, kplusp-1
-            if (h(i+1,1) .gt. zero) go to 90
-            itop  = itop + 1
-   80    continue
-c
-c        %-----------------------------------%
-c        | Finished applying the jj-th shift |
-c        %-----------------------------------%
-c
-   90 continue
-c
-c     %------------------------------------------%
-c     | All shifts have been applied. Check for  |
-c     | more possible deflation that might occur |
-c     | after the last shift is applied.         |                               
-c     %------------------------------------------%
-c
-      do 100 i = itop, kplusp-1
-         big   = abs(h(i,2)) + abs(h(i+1,2))
-         if (h(i+1,1) .le. epsmch*big) then
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, i, ndigit, 
-     &              '_sapps: deflation at row/column no.')
-               call svout (logfil, 1, h(i+1,1), ndigit, 
-     &              '_sapps: the corresponding off diagonal element')
-            end if
-            h(i+1,1) = zero
-         end if
- 100  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is not necessary if h(kev+1,1) = 0.         |
-c     %-------------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &   call sgemv ('N', n, kplusp, one, v, ldv,
-     &                q(1,kev+1), 1, zero, workd(n+1), 1)
-c 
-c     %-------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order    |
-c     | taking advantage that Q is an upper triangular matrix |    
-c     | with lower bandwidth np.                              |
-c     | Place results in v(:,kplusp-kev:kplusp) temporarily.  |
-c     %-------------------------------------------------------%
-c
-      do 130 i = 1, kev
-         call sgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call scopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  130 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call slacpy ('All', n, kev, v(1,np+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the |
-c     | appropriate place if h(kev+1,1) .ne. zero. |
-c     %--------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &     call scopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call sscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,1) .gt. zero) 
-     &   call saxpy (n, h(kev+1,1), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, 1, q(kplusp,kev), ndigit, 
-     &      '_sapps: sigmak of the updated residual vector')
-         call svout (logfil, 1, h(kev+1,1), ndigit, 
-     &      '_sapps: betak of the updated residual vector')
-         call svout (logfil, kev, h(1,2), ndigit, 
-     &      '_sapps: updated main diagonal of H for next iteration')
-         if (kev .gt. 1) then
-         call svout (logfil, kev-1, h(2,1), ndigit, 
-     &      '_sapps: updated sub diagonal of H for next iteration')
-         end if
-      end if
-c
-      call arscnd (t1)
-      tsapps = tsapps + (t1 - t0)
-c 
- 9000 continue 
-      return
-c
-c     %---------------%
-c     | End of ssapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssaup2.f b/libcruft/arpack/src/ssaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssaup2.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaup2
-c
-c\Description: 
-c  Intermediate level interface called by ssaupd.
-c
-c\Usage:
-c  call ssaup2 
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in ssaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in ssaupd.
-c  
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during 
-c          each Arnoldi/Lanczos iteration.  
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration 
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector 
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Tridiagonal matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number 
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Real N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Real (NEV+NP) by 2 array.  (OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          The subdiagonal is stored in the first column of H starting 
-c          at H(2,1).  The main diagonal is stored in the second column
-c          of H starting at H(1,2). If ssaup2 converges store the 
-c          B-norm of the final residual vector in H(1,1).
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  RITZ    Real array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV) contains the computed Ritz values of OP.
-c
-c  BOUNDS  Real array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.
-c
-c  Q       Real (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the 
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c          
-c  WORKL   Real array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in the computation of the 
-c          tridiagonal eigenvalue problem, the calculation and
-c          application of the shifts and convergence checking.
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations
-c          of WORKL are used in reverse communication to hold the user 
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for 
-c          vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in one of  
-c                    the spectral transformation modes.  X is the current
-c                    operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Lanczos iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in ssaupd.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: All possible eigenvalues of OP has been found.  
-c                   NP returns the size of the invariant subspace
-c                   spanning the operator OP. 
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from trid. eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Lanczos factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Routines called:
-c     sgetv0  ARPACK initial vector generation routine. 
-c     ssaitr  ARPACK Lanczos factorization routine.
-c     ssapps  ARPACK application of implicit shifts routine.
-c     ssconv  ARPACK convergence of Ritz values routine.
-c     sseigt  ARPACK compute Ritz values and error bounds routine.
-c     ssgets  ARPACK reorder Ritz values and error bounds routine.
-c     ssortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     sswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c     xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)
-c
-c\SCCS Information: @(#) 
-c FILE: saup2.F   SID: 2.7   DATE OF SID: 5/19/98   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd, 
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds, 
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
-     &           n, mode, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           bounds(nev+np), h(ldh,2), q(ldq,nev+np), resid(n), 
-     &           ritz(nev+np), v(ldv,nev+np), workd(3*n), 
-     &           workl(3*(nev+np))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm, getv0, initv, update, ushift
-      integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0, 
-     &           np0, nptemp, nevd2, nevm2, kp(3) 
-      Real
-     &           rnorm, temp, eps23
-      save       cnorm, getv0, initv, update, ushift,
-     &           iter, kplusp, msglvl, nconv, nev0, np0,
-     &           rnorm, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, sgetv0, ssaitr, sscal, ssconv, sseigt, ssgets, 
-     &           ssapps, ssortr, svout, ivout, arscnd, sswap
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slamch
-      external   sdot, snrm2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaup2
-c
-c        %---------------------------------%
-c        | Set machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0/3.0E+0)
-c
-c        %-------------------------------------%
-c        | nev0 and np0 are integer variables  |
-c        | hold the initial values of NEV & NP |
-c        %-------------------------------------%
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev0 + np0
-         nconv  = 0
-         iter   = 0
-c 
-c        %--------------------------------------------%
-c        | Set flags for computing the first NEV steps |
-c        | of the Lanczos factorization.              |
-c        %--------------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c        %--------------------------------------------%
-c        | User provides the initial residual vector. |
-c        %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c 
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call sgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. | 
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1200
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c 
-c     %------------------------------------------------------------%
-c     | Back from reverse communication: continue with update step |
-c     %------------------------------------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c 
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Lanczos factorization |
-c     %----------------------------------------------------------%
-c
-      call ssaitr (ido, bmat, n, 0, nev0, mode, resid, rnorm, v, ldv, 
-     &             h, ldh, ipntr, workd, info)
-c 
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-c
-c        %-----------------------------------------------------%
-c        | ssaitr was unable to build an Lanczos factorization |
-c        | of length NEV0. INFO is returned with the size of   |
-c        | the factorization built. Exit main loop.            |
-c        %-----------------------------------------------------%
-c
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Lanczos     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c 
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit, 
-     &           '_saup2: **** Start of major iteration number ****')
-         end if
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit, 
-     &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, np, ndigit, 
-     &           '_saup2: Extend the Lanczos factorization by')
-         end if
-c 
-c        %------------------------------------------------------------%
-c        | Compute NP additional steps of the Lanczos factorization. |
-c        %------------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call ssaitr (ido, bmat, n, nev, np, mode, resid, rnorm, v, 
-     &                ldv, h, ldh, ipntr, workd, info)
-c 
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-c
-c           %-----------------------------------------------------%
-c           | ssaitr was unable to build an Lanczos factorization |
-c           | of length NEV0+NP0. INFO is returned with the size  |  
-c           | of the factorization built. Exit main loop.         |
-c           %-----------------------------------------------------%
-c
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &           '_saup2: Current B-norm of residual for factorization')
-         end if
-c 
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current symmetric tridiagonal matrix.           |
-c        %--------------------------------------------------------%
-c
-         call sseigt (rnorm, kplusp, h, ldh, ritz, bounds, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from _seigt.                       |
-c        %----------------------------------------------------%
-c
-         call scopy(kplusp, ritz, 1, workl(kplusp+1), 1)
-         call scopy(kplusp, bounds, 1, workl(2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The selection is based on the requested number of |
-c        | eigenvalues instead of the current NEV and NP to  |
-c        | prevent possible misconvergence.                  |
-c        | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |
-c        | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         call ssgets (ishift, which, nev, np, ritz, bounds, workl)
-c 
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call scopy (nev, bounds(np+1), 1, workl(np+1), 1)
-         call ssconv (nev, ritz(np+1), workl(np+1), tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_saup2: NEV, NP, NCONV are')
-            call svout (logfil, kplusp, ritz, ndigit,
-     &           '_saup2: The eigenvalues of H')
-            call svout (logfil, kplusp, bounds, ndigit,
-     &          '_saup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c 
-         if ( (nconv .ge. nev0) .or. 
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c     
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP since we don't want to |
-c           | swap overlapping locations.                    |
-c           %------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %-----------------------------------------------------%
-c              | Both ends of the spectrum are requested.            |
-c              | Sort the eigenvalues into algebraically decreasing  |
-c              | order first then swap low end of the spectrum next  |
-c              | to high end in appropriate locations.               |
-c              | NOTE: when np < floor(nev/2) be careful not to swap |
-c              | overlapping locations.                              |
-c              %-----------------------------------------------------%
-c
-               wprime = 'SA'
-               call ssortr (wprime, .true., kplusp, ritz, bounds)
-               nevd2 = nev0 / 2
-               nevm2 = nev0 - nevd2 
-               if ( nev .gt. 1 ) then
-                  call sswap ( min(nevd2,np), ritz(nevm2+1), 1,
-     &                 ritz( max(kplusp-nevd2+1,kplusp-np+1) ), 1)
-                  call sswap ( min(nevd2,np), bounds(nevm2+1), 1,
-     &                 bounds( max(kplusp-nevd2+1,kplusp-np+1)), 1)
-               end if
-c
-            else
-c
-c              %--------------------------------------------------%
-c              | LM, SM, LA, SA case.                             |
-c              | Sort the eigenvalues of H into the an order that |
-c              | is opposite to WHICH, and apply the resulting    |
-c              | order to BOUNDS.  The eigenvalues are sorted so  |
-c              | that the wanted part are always within the first |
-c              | NEV locations.                                   |
-c              %--------------------------------------------------%
-c
-               if (which .eq. 'LM') wprime = 'SM'
-               if (which .eq. 'SM') wprime = 'LM'
-               if (which .eq. 'LA') wprime = 'SA'
-               if (which .eq. 'SA') wprime = 'LA'
-c
-               call ssortr (wprime, .true., kplusp, ritz, bounds)
-c
-            end if
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-               temp = max( eps23, abs(ritz(j)) )
-               bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LA'
-            call ssortr(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                temp = max( eps23, abs(ritz(j)) )
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %--------------------------------------------------%
-c           | Sort the "converged" Ritz values again so that   |
-c           | the "threshold" values and their associated Ritz |
-c           | estimates appear at the appropriate position in  |
-c           | ritz and bound.                                  |
-c           %--------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %------------------------------------------------%
-c              | Sort the "converged" Ritz values in increasing |
-c              | order.  The "threshold" values are in the      |
-c              | middle.                                        |
-c              %------------------------------------------------%
-c
-               wprime = 'LA'
-               call ssortr(wprime, .true., nconv, ritz, bounds)
-c
-            else
-c
-c              %----------------------------------------------%
-c              | In LM, SM, LA, SA case, sort the "converged" |
-c              | Ritz values according to WHICH so that the   |
-c              | "threshold" value appears at the front of    |
-c              | ritz.                                        |
-c              %----------------------------------------------%
-
-               call ssortr(which, .true., nconv, ritz, bounds)
-c
-            end if
-c
-c           %------------------------------------------%
-c           |  Use h( 1,1 ) as storage to communicate  |
-c           |  rnorm to _seupd if needed               |
-c           %------------------------------------------%
-c
-            h(1,1) = rnorm
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, kplusp, ritz, ndigit,
-     &            '_saup2: Sorted Ritz values.')
-               call svout (logfil, kplusp, bounds, ndigit,
-     &            '_saup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. | 
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. | 
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if (nconv .lt. nev .and. ishift .eq. 1) then
-c
-c           %---------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.    |
-c           | To prevent possible stagnation, adjust the number |
-c           | of Ritz values and the shifts.                    |
-c           %---------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min (nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 2) then
-               nev = 2
-            end if
-            np  = kplusp - nev
-c     
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c     
-            if (nevbef .lt. nev) 
-     &         call ssgets (ishift, which, nev, np, ritz, bounds,
-     &              workl)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_saup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_saup2: NEV and NP are')
-               call svout (logfil, nev, ritz(np+1), ndigit,
-     &              '_saup2: "wanted" Ritz values.')
-               call svout (logfil, nev, bounds(np+1), ndigit,
-     &              '_saup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-
-c 
-         if (ishift .eq. 0) then
-c
-c           %-----------------------------------------------------%
-c           | User specified shifts: reverse communication to     |
-c           | compute the shifts. They are returned in the first  |
-c           | NP locations of WORKL.                              |
-c           %-----------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c 
-c 
-c        %---------------------------------------------------------%
-c        | Move the NP shifts to the first NP locations of RITZ to |
-c        | free up WORKL.  This is for the non-exact shift case;   |
-c        | in the exact shift case, ssgets already handles this.   |
-c        %---------------------------------------------------------%
-c
-         if (ishift .eq. 0) call scopy (np, workl, 1, ritz, 1)
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_saup2: The number of shifts to apply ')
-            call svout (logfil, np, workl, ndigit,
-     &                  '_saup2: shifts selected')
-            if (ishift .eq. 1) then
-               call svout (logfil, np, bounds, ndigit,
-     &                  '_saup2: corresponding Ritz estimates')
-             end if
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Apply the NP0 implicit shifts by QR bulge chasing.      |
-c        | Each shift is applied to the entire tridiagonal matrix. |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        | After ssapps is done, we have a Lanczos                 |
-c        | factorization of length NEV.                            |
-c        %---------------------------------------------------------%
-c
-         call ssapps (n, nev, np, ritz, v, ldv, h, ldh, resid, q, ldq,
-     &        workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to ssaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd, 1)
-         end if
-c 
-  100    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         if (bmat .eq. 'G') then         
-            rnorm = sdot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-  130    continue
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &      '_saup2: B-norm of residual for NEV factorization')
-            call svout (logfil, nev, h(1,2), ndigit,
-     &           '_saup2: main diagonal of compressed H matrix')
-            call svout (logfil, nev-1, h(2,1), ndigit,
-     &           '_saup2: subdiagonal of compressed H matrix')
-         end if
-c 
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c 
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c 
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tsaup2 = t1 - t0
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssaup2 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssaupd.f b/libcruft/arpack/src/ssaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssaupd.f
+++ /dev/null
@@ -1,690 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaupd
-c
-c\Description: 
-c
-c  Reverse communication interface for the Implicitly Restarted Arnoldi 
-c  Iteration.  For symmetric problems this reduces to a variant of the Lanczos 
-c  method.  This method has been designed to compute approximations to a 
-c  few eigenpairs of a linear operator OP that is real and symmetric 
-c  with respect to a real positive semi-definite symmetric matrix B, 
-c  i.e.
-c                   
-c       B*OP = (OP`)*B.  
-c
-c  Another way to express this condition is 
-c
-c       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
-c  
-c  In the standard eigenproblem B is the identity matrix.  
-c  ( A` denotes transpose of A)
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  ssaupd is usually called iteratively to solve one of the 
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x, A symmetric 
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
-c           ===> OP = (inv[K - sigma*M])*M  and  B = M. 
-c           ===> Shift-and-Invert mode
-c
-c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite, 
-c           KG symmetric indefinite
-c           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
-c           ===> Buckling mode
-c
-c  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
-c           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c           ===> Cayley transformed mode
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call ssaupd 
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first 
-c          call to ssaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          ssaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          (If Mode = 2 see remark 5 below)
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3,4 and 5, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) shifts where
-c                    IPNTR(11) is the pointer into WORKL for
-c                    placing the shifts. See remark 6 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c             
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Specify which of the Ritz values of OP to compute.
-c
-c          'LA' - compute the NEV largest (algebraic) eigenvalues.
-c          'SA' - compute the NEV smallest (algebraic) eigenvalues.
-c          'LM' - compute the NEV largest (in magnitude) eigenvalues.
-c          'SM' - compute the NEV smallest (in magnitude) eigenvalues. 
-c          'BE' - compute NEV eigenvalues, half from each end of the
-c                 spectrum.  When NEV is odd, compute one more from the
-c                 high end than from the low end.
-c           (see remark 1 below)
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N.
-c
-c  TOL     Real  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value 
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
-c          If TOL .LE. 0. is passed a default is set:
-c          DEFAULT = SLAMCH('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine SLAMCH).
-c
-c  RESID   Real  array of length N.  (INPUT/OUTPUT)
-c          On INPUT: 
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector. 
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V (less than or equal to N).
-c          This will indicate how many Lanczos vectors are generated 
-c          at each iteration.  After the startup phase in which NEV 
-c          Lanczos vectors are generated, the algorithm generates 
-c          NCV-NEV Lanczos vectors at each subsequent update iteration.
-c          Most of the cost in generating each Lanczos vector is in the 
-c          matrix-vector product OP*x. (See remark 4 below).
-c
-c  V       Real  N by NCV array.  (OUTPUT)
-c          The NCV columns of V contain the Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the current tridiagonal matrix T are returned in
-c                      the part of WORKL array corresponding to RITZ.
-c                      See remark 6 below.
-c          ISHIFT = 1: exact shifts with respect to the reduced 
-c                      tridiagonal matrix T.  This is equivalent to 
-c                      restarting the iteration with a starting vector 
-c                      that is a linear combination of Ritz vectors 
-c                      associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = LEVEC
-c          No longer referenced. See remark 2 below.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed. 
-c          On OUTPUT: actual number of Arnoldi update iterations taken. 
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used. 
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4,5; See under \Description of ssaupd for the 
-c          five modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), ssaupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          6 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.        
-c
-c  IPNTR   Integer array of length 11.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in 
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
-c          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
-c          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZ in WORKL.
-c          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.
-c
-c          Note: IPNTR(8:10) is only referenced by sseupd. See Remark 2.
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     sseupd if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD 
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
-c          subroutine sseupd uses this output.
-c          See Data Distribution Note below.  
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least NCV**2 + 8*NCV .
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)  
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the 
-c                Implicitly restarted Arnoldi iteration. One possibility 
-c                is to increase the size of NCV relative to NEV. 
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iterations allowed
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array WORKL is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Informatinal error from LAPACK routine ssteqr.
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -13: NEV and WHICH = 'BE' are incompatable.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization. The user is advised to check that
-c                   enough workspace and array storage has been allocated.
-c
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in ascending 
-c     algebraic order.  The computed Ritz values are approximate
-c     eigenvalues of OP.  The selection of WHICH should be made
-c     with this in mind when Mode = 3,4,5.  After convergence, 
-c     approximate eigenvalues of the original problem may be obtained 
-c     with the ARPACK subroutine sseupd. 
-c
-c  2. If the Ritz vectors corresponding to the converged Ritz values
-c     are needed, the user must call sseupd immediately following completion
-c     of ssaupd. This is new starting with version 2.1 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will 
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.   The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c
-c  5. If IPARAM(7) = 2 then in the Reverse commuication interface the user
-c     must do the following. When IDO = 1, Y = OP * X is to be computed.
-c     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
-c     must overwrite X with A*X. Y is then the solution to the linear set
-c     of equations B*Y = A*X.
-c
-c  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the 
-c     NP = IPARAM(8) shifts in locations: 
-c     1   WORKL(IPNTR(11))           
-c     2   WORKL(IPNTR(11)+1)         
-c                        .           
-c                        .           
-c                        .      
-c     NP  WORKL(IPNTR(11)+NP-1). 
-c
-c     The eigenvalues of the current tridiagonal matrix are located in 
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
-c     order defined by WHICH. The associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
-c  DECOMPOSE  D1(N), D2(N,NCV)
-c  ALIGN      RESID(I) with D1(I)
-c  ALIGN      V(I,J)   with D2(I,J)
-c  ALIGN      WORKD(I) with D1(I)     range (1:N)
-c  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
-c  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
-c  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c  Cray MPP syntax:
-c  ===============
-c  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
-c  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c  
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
-c     Transformations in a k-Step Arnoldi Method". In Preparation.
-c
-c\Routines called:
-c     ssaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     sstats  ARPACK routine that initialize timing and other statistics
-c             variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.4' 
-c
-c\SCCS Information: @(#) 
-c FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2 
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real 
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(11)
-      Real 
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw, 
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ssaup2,  svout, ivout, arscnd, sstats
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call sstats
-         call arscnd (t0)
-         msglvl = msaupd
-c
-         ierr   = 0
-         ishift = iparam(1)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         if (n .le. 0) then
-            ierr = -1
-         else if (nev .le. 0) then
-            ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-            ierr = -3
-         end if
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-c 
-         if (mxiter .le. 0)                     ierr = -4
-         if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LA' .and.
-     &       which .ne. 'SA' .and.
-     &       which .ne. 'BE')                   ierr = -5
-         if (bmat .ne. 'I' .and. bmat .ne. 'G') ierr = -6
-c
-         if (lworkl .lt. ncv**2 + 8*ncv)        ierr = -7
-         if (mode .lt. 1 .or. mode .gt. 5) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         else if (nev .eq. 1 .and. which .eq. 'BE') then
-                                                ierr = -13
-         end if
-c 
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c 
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)                         nb = 1
-         if (tol .le. zero)                     tol = slamch('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev 
-c 
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, ncv**2 + 8*ncv
-            workl(j) = zero
- 10      continue
-c 
-c        %-------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c        | etc... and the remaining workspace.                   |
-c        | Also update pointer to be used on output.             |
-c        | Memory is laid out as follows:                        |
-c        | workl(1:2*ncv) := generated tridiagonal matrix        |
-c        | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c        | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |
-c        | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |
-c        | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |
-c        %-------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + 2*ldh
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ncv**2
-         next   = iw     + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = bounds
-         ipntr(11) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Lanczos Iteration. |
-c     %-------------------------------------------------------%
-c
-      call ssaup2 
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw), ipntr, workd,
-     &     info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c 
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within ssaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_saupd: number of "converged" Ritz values')
-         call svout (logfil, np, workl(Ritz), ndigit, 
-     &               '_saupd: final Ritz values')
-         call svout (logfil, np, workl(Bounds), ndigit, 
-     &               '_saupd: corresponding error bounds')
-      end if 
-c
-      call arscnd (t1)
-      tsaupd = t1 - t0
-c 
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tsaupd, tsaup2, tsaitr, titref,
-     &                  tgetv0, tseigt, tsgets, tsapps, tsconv
- 1000    format (//,
-     &      5x, '==========================================',/
-     &      5x, '= Symmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number:', ' 2.4' , 19x, ' =',/
-     &      5x, '= Version Date:  ', ' 07/31/96' , 14x, ' =',/
-     &      5x, '==========================================',/
-     &      5x, '= Summary of timing statistics           =',/
-     &      5x, '==========================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in saup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in trid eigenvalue subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6)
-      end if
-c 
- 9000 continue
-c 
-      return
-c
-c     %---------------%
-c     | End of ssaupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssconv.f b/libcruft/arpack/src/ssconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssconv.f
+++ /dev/null
@@ -1,138 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssconv
-c
-c\Description: 
-c  Convergence testing for the symmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call ssconv
-c     ( N, RITZ, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZ    Real array of length N.  (INPUT)
-c          The Ritz values to be checked for convergence.
-c
-c  BOUNDS  Real array of length N.  (INPUT)
-c          Ritz estimates associated with the Ritz values in RITZ.
-c
-c  TOL     Real scalar.  (INPUT)
-c          Desired relative accuracy for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.4, this routine no longer uses the
-c        Parlett strategy using the gap conditions. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssconv (n, ritz, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           ritz(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Real
-     &           temp, eps23
-c
-c     %-------------------%
-c     | External routines |
-c     %-------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      call arscnd (t0)
-c
-      eps23 = slamch('Epsilon-Machine') 
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-      nconv  = 0
-      do 10 i = 1, n
-c
-c        %-----------------------------------------------------%
-c        | The i-th Ritz value is considered "converged"       |
-c        | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |
-c        %-----------------------------------------------------%
-c
-         temp = max( eps23, abs(ritz(i)) )
-         if ( bounds(i) .le. tol*temp ) then
-            nconv = nconv + 1
-         end if
-c
-   10 continue
-c 
-      call arscnd (t1)
-      tsconv = tsconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of ssconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sseigt.f b/libcruft/arpack/src/sseigt.f
deleted file mode 100644
--- a/libcruft/arpack/src/sseigt.f
+++ /dev/null
@@ -1,181 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sseigt
-c
-c\Description: 
-c  Compute the eigenvalues of the current symmetric tridiagonal matrix
-c  and the corresponding error bounds given the current residual norm.
-c
-c\Usage:
-c  call sseigt
-c     ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          RNORM contains the residual norm corresponding to the current
-c          symmetric tridiagonal matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the symmetric tridiagonal matrix H.
-c
-c  H       Real N by 2 array.  (INPUT)
-c          H contains the symmetric tridiagonal matrix with the 
-c          subdiagonal in the first column starting at H(2,1) and the 
-c          main diagonal in second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  EIG     Real array of length N.  (OUTPUT)
-c          On output, EIG contains the N eigenvalues of H possibly 
-c          unsorted.  The BOUNDS arrays are returned in the
-c          same sorted order as EIG.
-c
-c  BOUNDS  Real array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the error estimates corresponding
-c          to the eigenvalues EIG.  This is equal to RNORM times the
-c          last components of the eigenvectors corresponding to the
-c          eigenvalues in EIG.
-c
-c  WORKL   Real work array of length 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from sstqrb.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     sstqrb  ARPACK routine that computes the eigenvalues and the
-c             last components of the eigenvectors of a symmetric
-c             and tridiagonal matrix.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sseigt 
-     &   ( rnorm, n, h, ldh, eig, bounds, workl, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, ldh, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           eig(n), bounds(n), h(ldh,2), workl(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           zero
-      parameter (zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, k, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, sstqrb, svout, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------% 
-c
-      call arscnd (t0)
-      msglvl = mseigt
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, n, h(1,2), ndigit,
-     &              '_seigt: main diagonal of matrix H')
-         if (n .gt. 1) then
-         call svout (logfil, n-1, h(2,1), ndigit,
-     &              '_seigt: sub diagonal of matrix H')
-         end if
-      end if
-c
-      call scopy  (n, h(1,2), 1, eig, 1)
-      call scopy  (n-1, h(2,1), 1, workl, 1)
-      call sstqrb (n, eig, workl, bounds, workl(n+1), ierr)
-      if (ierr .ne. 0) go to 9000
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, bounds, ndigit,
-     &              '_seigt: last row of the eigenvector matrix for H')
-      end if
-c
-c     %-----------------------------------------------%
-c     | Finally determine the error bounds associated |
-c     | with the n Ritz values of H.                  |
-c     %-----------------------------------------------%
-c
-      do 30 k = 1, n
-         bounds(k) = rnorm*abs(bounds(k))
-   30 continue
-c 
-      call arscnd (t1)
-      tseigt = tseigt + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sseigt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssesrt.f b/libcruft/arpack/src/ssesrt.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssesrt.f
+++ /dev/null
@@ -1,217 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssesrt
-c
-c\Description:
-c  Sort the array X in the order specified by WHICH and optionally 
-c  apply the permutation to the columns of the matrix A.
-c
-c\Usage:
-c  call ssesrt
-c     ( WHICH, APPLY, N, X, NA, A, LDA)
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X is sorted into increasing order of magnitude.
-c          'SM' -> X is sorted into decreasing order of magnitude.
-c          'LA' -> X is sorted into increasing order of algebraic.
-c          'SA' -> X is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to A.
-c          APPLY = .FALSE. -> do not apply the sorted order to A.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the array X.
-c
-c  X      Real array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  NA      Integer.  (INPUT)
-c          Number of rows of the matrix A.
-c
-c  A      Real array of length NA by N.  (INPUT/OUTPUT)
-c         
-c  LDA     Integer.  (INPUT)
-c          Leading dimension of A.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines
-c     sswap  Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO and 
-c               the ARPACK code ssortr
-c
-c\SCCS Information: @(#) 
-c FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssesrt (which, apply, n, x, na, a, lda)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    lda, n, na
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           x(0:n-1), a(lda, 0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   sswap
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x(j).lt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x(j)).lt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x(j).gt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x(j)).gt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssesrt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sseupd.f b/libcruft/arpack/src/sseupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/sseupd.f
+++ /dev/null
@@ -1,857 +0,0 @@
-c\BeginDoc
-c
-c\Name: sseupd
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) the corresponding approximate eigenvectors,
-c
-c      (2) an orthonormal (Lanczos) basis for the associated approximate
-c          invariant subspace,
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  (Lanczos) basis is always computed.  There is an additional storage cost 
-c  of n*nev if both are requested (in this case a separate array Z must be 
-c  supplied).
-c
-c  These quantities are obtained from the Lanczos factorization computed
-c  by SSAUPD for the linear operator OP prescribed by the MODE selection
-c  (see IPARAM(7) in SSAUPD documentation.)  SSAUPD must be called before
-c  this routine is called. These approximate eigenvalues and vectors are 
-c  commonly called Ritz values and Ritz vectors respectively.  They are 
-c  referred to as such in the comments that follow.   The computed orthonormal 
-c  basis for the invariant subspace corresponding to these Ritz values is 
-c  referred to as a Lanczos basis.
-c
-c  See documentation in the header of the subroutine SSAUPD for a definition 
-c  of OP as well as other terms and the relation of computed Ritz values 
-c  and vectors of OP with respect to the given problem  A*z = lambda*B*z.  
-c
-c  The approximate eigenvalues of the original problem are returned in
-c  ascending algebraic order.  The user may elect to call this routine
-c  once for each desired Ritz vector and store it peripherally if desired.
-c  There is also the option of computing a selected set of these vectors
-c  with a single call.
-c
-c\Usage:
-c  call sseupd 
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,
-c       RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether Ritz vectors corresponding to the Ritz value 
-c          approximations to the eigenproblem A*z = lambda*B*z are computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors.
-c
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies how many Ritz vectors are wanted and the form of Z
-c          the matrix of Ritz vectors. See remark 1 below.
-c          = 'A': compute NEV Ritz vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' , SELECT is used as a workspace for
-c          reordering the Ritz values.
-c
-c  D       Real  array of dimension NEV.  (OUTPUT)
-c          On exit, D contains the Ritz value approximations to the
-c          eigenvalues of A*z = lambda*B*z. The values are returned
-c          in ascending order. If IPARAM(7) = 3,4,5 then D represents
-c          the Ritz values of OP computed by ssaupd transformed to
-c          those of the original eigensystem A*z = lambda*B*z. If 
-c          IPARAM(7) = 1,2 then the Ritz values of OP are the same 
-c          as the those of A*z = lambda*B*z.
-c
-c  Z       Real  N by NEV array if HOWMNY = 'A'.  (OUTPUT)
-c          On exit, Z contains the B-orthonormal Ritz vectors of the
-c          eigensystem A*z = lambda*B*z corresponding to the Ritz
-c          value approximations.
-c          If  RVEC = .FALSE. then Z is not referenced.
-c          NOTE: The array Z may be set equal to first NEV columns of the 
-c          Arnoldi/Lanczos basis array V computed by SSAUPD.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.
-c
-c  SIGMA   Real   (INPUT)
-c          If IPARAM(7) = 3,4,5 represents the shift. Not referenced if
-c          IPARAM(7) = 1 or 2.
-c
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to SSAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to SSEUPD following the last call
-c         to SSAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to SSAUPD and the call to SSEUPD.
-c
-c  Two of these parameters (WORKL, INFO) are also output parameters:
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:4*ncv) contains information obtained in
-c          ssaupd.  They are not changed by sseupd.
-c          WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the
-c          untransformed Ritz values, the computed error estimates,
-c          and the associated eigenvector matrix of H.
-c
-c          Note: IPNTR(8:10) contains the pointer into WORKL for addresses
-c          of the above information computed by sseupd.
-c          -------------------------------------------------------------
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     sseupd if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Information error from LAPACK routine ssteqr.
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: NEV and WHICH = 'BE' are incompatible.
-c          = -14: SSAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.
-c          = -16: HOWMNY = 'S' not yet implemented
-c          = -17: SSEUPD got a different count of the number of converged
-c                 Ritz values than SSAUPD got.  This indicates the user
-c                 probably made an error in passing data from SSAUPD to
-c                 SSEUPD or that the data was modified before entering 
-c                 SSEUPD.
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in increasing 
-c     (algebraic) order.
-c
-c  2. Currently only HOWMNY = 'A' is implemented. It is included at this
-c     stage for the user who wants to incorporate it. 
-c
-c\Routines called:
-c     ssesrt  ARPACK routine that sorts an array X, and applies the
-c             corresponding permutation to a matrix A.
-c     ssortr  ssortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     svout   ARPACK utility routine that prints vectors.
-c     sgeqr2  LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     slacpy  LAPACK matrix copy routine.
-c     slamch  LAPACK routine that determines machine constants.
-c     sorm2r  LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     ssteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a tridiagonal matrix.
-c     sger    Level 2 BLAS rank one update to a matrix.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational & 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: seupd.F   SID: 2.11   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine sseupd(rvec  , howmny, select, d    ,
-     &                   z     , ldz   , sigma , bmat ,
-     &                   n     , which , nev   , tol  ,
-     &                   resid , ncv   , v     , ldv  ,
-     &                   iparam, ipntr , workd , workl,
-     &                   lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Real      
-     &           sigma, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(7), ipntr(11)
-      logical    select(ncv)
-      Real 
-     &           d(nev)     , resid(n)  , v(ldv,ncv),
-     &           z(ldz, nev), workd(2*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds , ierr   , ih    , ihb   , ihd   ,
-     &           iq     , iw     , j     , k     , ldh   ,
-     &           ldq    , mode   , msglvl, nconv , next  ,
-     &           ritz   , irz    , ibd   , np    , ishift,
-     &           leftptr, rghtptr, numcnv, jj
-      Real 
-     &           bnorm2 , rnorm, temp, temp1, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sger  , sgeqr2, slacpy, sorm2r, sscal, 
-     &           ssesrt, ssteqr, sswap , svout , ivout , ssortr
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           snrm2, slamch
-      external   snrm2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mseupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      if (nconv .eq. 0) go to 9000
-      ierr = 0
-c
-      if (nconv .le. 0)                        ierr = -14 
-      if (n .le. 0)                            ierr = -1
-      if (nev .le. 0)                          ierr = -2
-      if (ncv .le. nev .or.  ncv .gt. n)       ierr = -3
-      if (which .ne. 'LM' .and.
-     &    which .ne. 'SM' .and.
-     &    which .ne. 'LA' .and.
-     &    which .ne. 'SA' .and.
-     &    which .ne. 'BE')                     ierr = -5
-      if (bmat .ne. 'I' .and. bmat .ne. 'G')   ierr = -6
-      if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) 
-     &                                         ierr = -15
-      if (rvec .and. howmny .eq. 'S')           ierr = -16
-c
-      if (rvec .and. lworkl .lt. ncv**2+8*ncv) ierr = -7
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else if (mode .eq. 4 ) then
-         type = 'BUCKLE'
-      else if (mode .eq. 5 ) then
-         type = 'CAYLEY'
-      else 
-                                               ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')     ierr = -11
-      if (nev .eq. 1 .and. which .eq. 'BE')    ierr = -12
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c     
-c     %-------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c     | etc... and the remaining workspace.                   |
-c     | Also update pointer to be used on output.             |
-c     | Memory is laid out as follows:                        |
-c     | workl(1:2*ncv) := generated tridiagonal matrix H      |
-c     |       The subdiagonal is stored in workl(2:ncv).      |
-c     |       The dead spot is workl(1) but upon exiting      |
-c     |       ssaupd stores the B-norm of the last residual   |
-c     |       vector in workl(1). We use this !!!             |
-c     | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c     |       The wanted values are in the first NCONV spots. |
-c     | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |
-c     |       The wanted values are in the first NCONV spots. |
-c     | NOTE: workl(1:4*ncv) is set by ssaupd and is not      |
-c     |       modified by sseupd.                             |
-c     %-------------------------------------------------------%
-c
-c     %-------------------------------------------------------%
-c     | The following is used and set by sseupd.              |
-c     | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the diagonal of H. Upon EXIT contains the NCV   |
-c     |       Ritz values of the original system. The first   |
-c     |       NCONV spots have the wanted values. If MODE =   |
-c     |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |
-c     | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the subdiagonal of H. Upon EXIT contains the    |
-c     |       NCV corresponding Ritz estimates of the         |
-c     |       original system. The first NCONV spots have the |
-c     |       wanted values. If MODE = 1,2 then will equal    |
-c     |       workl(3*ncv+1:4*ncv).                           |
-c     | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |
-c     |       the eigenvector matrix for H as returned by     |
-c     |       ssteqr. Not referenced if RVEC = .False.        |
-c     |       Ordering follows that of workl(4*ncv+1:5*ncv)   |
-c     | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |
-c     |       Workspace. Needed by ssteqr and by sseupd.      |
-c     | GRAND total of NCV*(NCV+8) locations.                 |
-c     %-------------------------------------------------------%
-c
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      bounds = ipntr(7)
-      ldh    = ncv
-      ldq    = ncv
-      ihd    = bounds + ldh
-      ihb    = ihd    + ldh
-      iq     = ihb    + ldh
-      iw     = iq     + ldh*ncv
-      next   = iw     + 2*ncv
-      ipntr(4)  = next
-      ipntr(8)  = ihd
-      ipntr(9)  = ihb
-      ipntr(10) = iq
-c
-c     %----------------------------------------%
-c     | irz points to the Ritz values computed |
-c     |     by _seigt before exiting _saup2.   |
-c     | ibd points to the Ritz estimates       |
-c     |     computed by _seigt before exiting  |
-c     |     _saup2.                            |
-c     %----------------------------------------%
-c
-      irz = ipntr(11)+ncv
-      ibd = irz+ncv
-c
-c
-c     %---------------------------------%
-c     | Set machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine') 
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %---------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N).    |
-c     | BNORM2 is the 2 norm of B*RESID(1:N). |
-c     | Upon exit of ssaupd WORKD(1:N) has    |
-c     | B*RESID(1:N).                         |
-c     %---------------------------------------%
-c
-      rnorm = workl(ih)
-      if (bmat .eq. 'I') then
-         bnorm2 = rnorm
-      else if (bmat .eq. 'G') then
-         bnorm2 = snrm2(n, workd, 1)
-      end if
-c
-      if (msglvl .gt. 2) then
-         call svout(logfil, ncv, workl(irz), ndigit,
-     &   '_seupd: Ritz values passed in from _SAUPD.')
-         call svout(logfil, ncv, workl(ibd), ndigit,
-     &   '_seupd: Ritz estimates passed in from _SAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call ssgets(ishift, which       , nev          ,
-     &                np    , workl(irz)  , workl(bounds),
-     &                workl)
-c
-         if (msglvl .gt. 2) then
-            call svout(logfil, ncv, workl(irz), ndigit,
-     &      '_seupd: Ritz values after calling _SGETS.')
-            call svout(logfil, ncv, workl(bounds), ndigit,
-     &      '_seupd: Ritz value indices after calling _SGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23, abs(workl(irz+ncv-j)) )
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by _saupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the _saupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_seupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -17
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine _steqr to compute the eigenvalues and |
-c        | eigenvectors of the final symmetric tridiagonal matrix H. |
-c        | Initialize the eigenvector matrix Q to the identity.      |
-c        %-----------------------------------------------------------%
-c
-         call scopy(ncv-1, workl(ih+1), 1, workl(ihb), 1)
-         call scopy(ncv, workl(ih+ldh), 1, workl(ihd), 1)
-c
-         call ssteqr('Identity', ncv, workl(ihd), workl(ihb),
-     &                workl(iq) , ldq, workl(iw), ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call scopy(ncv, workl(iq+ncv-1), ldq, workl(iw), 1)
-            call svout(logfil, ncv, workl(ihd), ndigit,
-     &          '_seupd: NCV Ritz values of the final H matrix')
-            call svout(logfil, ncv, workl(iw), ndigit,
-     &           '_seupd: last row of the eigenvector matrix for H')
-         end if
-c
-         if (reord) then
-c
-c           %---------------------------------------------%
-c           | Reordered the eigenvalues and eigenvectors  |
-c           | computed by _steqr so that the "converged"  |
-c           | eigenvalues appear in the first NCONV       |
-c           | positions of workl(ihd), and the associated |
-c           | eigenvectors appear in the first NCONV      |
-c           | columns.                                    |
-c           %---------------------------------------------%
-c
-            leftptr = 1
-            rghtptr = ncv
-c
-            if (ncv .eq. 1) go to 30
-c
- 20         if (select(leftptr)) then
-c
-c              %-------------------------------------------%
-c              | Search, from the left, for the first Ritz |
-c              | value that has not converged.             |
-c              %-------------------------------------------%
-c
-               leftptr = leftptr + 1
-c
-            else if ( .not. select(rghtptr)) then
-c
-c              %----------------------------------------------%
-c              | Search, from the right, the first Ritz value |
-c              | that has converged.                          |
-c              %----------------------------------------------%
-c
-               rghtptr = rghtptr - 1
-c
-            else
-c
-c              %----------------------------------------------%
-c              | Swap the Ritz value on the left that has not |
-c              | converged with the Ritz value on the right   |
-c              | that has converged.  Swap the associated     |
-c              | eigenvector of the tridiagonal matrix H as   |
-c              | well.                                        |
-c              %----------------------------------------------%
-c
-               temp = workl(ihd+leftptr-1)
-               workl(ihd+leftptr-1) = workl(ihd+rghtptr-1)
-               workl(ihd+rghtptr-1) = temp
-               call scopy(ncv, workl(iq+ncv*(leftptr-1)), 1,
-     &                    workl(iw), 1)
-               call scopy(ncv, workl(iq+ncv*(rghtptr-1)), 1,
-     &                    workl(iq+ncv*(leftptr-1)), 1)
-               call scopy(ncv, workl(iw), 1,
-     &                    workl(iq+ncv*(rghtptr-1)), 1)
-               leftptr = leftptr + 1
-               rghtptr = rghtptr - 1
-c
-            end if
-c
-            if (leftptr .lt. rghtptr) go to 20
-c
-         end if
-c
- 30      if (msglvl .gt. 2) then
-             call svout (logfil, ncv, workl(ihd), ndigit,
-     &       '_seupd: The eigenvalues of H--reordered')
-         end if
-c
-c        %----------------------------------------%
-c        | Load the converged Ritz values into D. |
-c        %----------------------------------------%
-c
-         call scopy(nconv, workl(ihd), 1, d, 1)
-c
-      else
-c
-c        %-----------------------------------------------------%
-c        | Ritz vectors not required. Load Ritz values into D. |
-c        %-----------------------------------------------------%
-c
-         call scopy(nconv, workl(ritz), 1, d, 1)
-         call scopy(ncv, workl(ritz), 1, workl(ihd), 1)
-c
-      end if
-c
-c     %------------------------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors and corresponding |
-c     | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |
-c     | (and corresponding data) are returned in ascending order.        |
-c     %------------------------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-c        %---------------------------------------------------------%
-c        | Ascending sort of wanted Ritz values, vectors and error |
-c        | bounds. Not necessary if only Ritz values are desired.  |
-c        %---------------------------------------------------------%
-c
-         if (rvec) then
-            call ssesrt('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call scopy(ncv, workl(bounds), 1, workl(ihb), 1)
-         end if
-c
-      else 
-c 
-c        %-------------------------------------------------------------%
-c        | *  Make a copy of all the Ritz values.                      |
-c        | *  Transform the Ritz values back to the original system.   |
-c        |    For TYPE = 'SHIFTI' the transformation is                |
-c        |             lambda = 1/theta + sigma                        |
-c        |    For TYPE = 'BUCKLE' the transformation is                |
-c        |             lambda = sigma * theta / ( theta - 1 )          |
-c        |    For TYPE = 'CAYLEY' the transformation is                |
-c        |             lambda = sigma * (theta + 1) / (theta - 1 )     |
-c        |    where the theta are the Ritz values returned by ssaupd.  |
-c        | NOTES:                                                      |
-c        | *The Ritz vectors are not affected by the transformation.   |
-c        |  They are only reordered.                                   |
-c        %-------------------------------------------------------------%
-c
-         call scopy (ncv, workl(ihd), 1, workl(iw), 1)
-         if (type .eq. 'SHIFTI') then 
-            do 40 k=1, ncv
-               workl(ihd+k-1) = one / workl(ihd+k-1) + sigma
-  40        continue
-         else if (type .eq. 'BUCKLE') then
-            do 50 k=1, ncv
-               workl(ihd+k-1) = sigma * workl(ihd+k-1) / 
-     &                          (workl(ihd+k-1) - one)
-  50        continue
-         else if (type .eq. 'CAYLEY') then
-            do 60 k=1, ncv
-               workl(ihd+k-1) = sigma * (workl(ihd+k-1) + one) /
-     &                          (workl(ihd+k-1) - one)
-  60        continue
-         end if
-c 
-c        %-------------------------------------------------------------%
-c        | *  Store the wanted NCONV lambda values into D.             |
-c        | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |
-c        |    into ascending order and apply sort to the NCONV theta   |
-c        |    values in the transformed system. We will need this to   |
-c        |    compute Ritz estimates in the original system.           |
-c        | *  Finally sort the lambda`s into ascending order and apply |
-c        |    to Ritz vectors if wanted. Else just sort lambda`s into  |
-c        |    ascending order.                                         |
-c        | NOTES:                                                      |
-c        | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |
-c        |  match the ordering of the lambda. We`ll use them again for |
-c        |  Ritz vector purification.                                  |
-c        %-------------------------------------------------------------%
-c
-         call scopy(nconv, workl(ihd), 1, d, 1)
-         call ssortr('LA', .true., nconv, workl(ihd), workl(iw))
-         if (rvec) then
-            call ssesrt('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call scopy(ncv, workl(bounds), 1, workl(ihb), 1)
-            call sscal(ncv, bnorm2/rnorm, workl(ihb), 1)
-            call ssortr('LA', .true., nconv, d, workl(ihb))
-         end if
-c
-      end if 
-c 
-c     %------------------------------------------------%
-c     | Compute the Ritz vectors. Transform the wanted |
-c     | eigenvectors of the symmetric tridiagonal H by |
-c     | the Lanczos basis matrix V.                    |
-c     %------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A') then
-c    
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(iq,ldq).                                |
-c        %----------------------------------------------------------%
-c     
-         call sgeqr2(ncv, nconv        , workl(iq) ,
-     &                ldq, workl(iw+ncv), workl(ihb),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q.                                 |   
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(ihd).                         |
-c        %--------------------------------------------------------%
-c     
-         call sorm2r('Right', 'Notranspose', n        ,
-     &                ncv    , nconv        , workl(iq),
-     &                ldq    , workl(iw+ncv), v        ,
-     &                ldv    , workd(n+1)   , ierr)
-         call slacpy('All', n, nconv, v, ldv, z, ldz)
-c
-c        %-----------------------------------------------------%
-c        | In order to compute the Ritz estimates for the Ritz |
-c        | values in both systems, need the last row of the    |
-c        | eigenvector matrix. Remember, it`s in factored form |
-c        %-----------------------------------------------------%
-c
-         do 65 j = 1, ncv-1
-            workl(ihb+j-1) = zero 
-  65     continue
-         workl(ihb+ncv-1) = one
-         call sorm2r('Left', 'Transpose'  , ncv       ,
-     &                1     , nconv        , workl(iq) ,
-     &                ldq   , workl(iw+ncv), workl(ihb),
-     &                ncv   , temp         , ierr)
-c
-      else if (rvec .and. howmny .eq. 'S') then
-c
-c     Not yet implemented. See remark 2 above.
-c
-      end if
-c
-      if (type .eq. 'REGULR' .and. rvec) then
-c
-            do 70 j=1, ncv
-               workl(ihb+j-1) = rnorm * abs( workl(ihb+j-1) )
- 70         continue
-c
-      else if (type .ne. 'REGULR' .and. rvec) then
-c
-c        %-------------------------------------------------%
-c        | *  Determine Ritz estimates of the theta.       |
-c        |    If RVEC = .true. then compute Ritz estimates |
-c        |               of the theta.                     |
-c        |    If RVEC = .false. then copy Ritz estimates   |
-c        |              as computed by ssaupd.             |
-c        | *  Determine Ritz estimates of the lambda.      |
-c        %-------------------------------------------------%
-c
-         call sscal (ncv, bnorm2, workl(ihb), 1)
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1) ) 
-     &                        / workl(iw+k-1)**2
- 80         continue
-c
-         else if (type .eq. 'BUCKLE') then
-c
-            do 90 k=1, ncv
-               workl(ihb+k-1) = sigma * abs( workl(ihb+k-1) )
-     &                        / (workl(iw+k-1)-one )**2
- 90         continue
-c
-         else if (type .eq. 'CAYLEY') then
-c
-            do 100 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1)
-     &                        / workl(iw+k-1)*(workl(iw+k-1)-one) )
- 100        continue
-c
-         end if
-c
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, d, ndigit,
-     &          '_seupd: Untransformed converged Ritz values')
-         call svout(logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Ritz estimates of the untransformed Ritz values')
-      else if (msglvl .gt. 1) then
-         call svout(logfil, nconv, d, ndigit,
-     &          '_seupd: Converged Ritz values')
-         call svout(logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Associated Ritz estimates')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Ritz vector purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3,4,5. See reference 7               |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. (type .eq. 'SHIFTI' .or. type .eq. 'CAYLEY')) then
-c
-         do 110 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / workl(iw+k)
- 110     continue
-c
-      else if (rvec .and. type .eq. 'BUCKLE') then
-c
-         do 120 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / (workl(iw+k)-one)
- 120     continue
-c
-      end if 
-c
-      if (type .ne. 'REGULR')
-     &   call sger (n, nconv, one, resid, 1, workl(iw), 1, z, ldz)
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of sseupd|
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssgets.f b/libcruft/arpack/src/ssgets.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssgets.f
+++ /dev/null
@@ -1,219 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssgets
-c
-c\Description: 
-c  Given the eigenvalues of the symmetric tridiagonal matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors 
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: This is called even in the case of user specified shifts in 
-c  order to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call ssgets
-c     ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> KEV eigenvalues of largest magnitude are retained.
-c          'SM' -> KEV eigenvalues of smallest magnitude are retained.
-c          'LA' -> KEV eigenvalues of largest value are retained.
-c          'SA' -> KEV eigenvalues of smallest value are retained.
-c          'BE' -> KEV eigenvalues, half from each end of the spectrum.
-c                  If KEV is odd, compute one more from the high end.
-c
-c  KEV      Integer.  (INPUT)
-c          KEV+NP is the size of the matrix H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be computed.
-c
-c  RITZ    Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted eigenvalues 
-c          are in the first NP locations and the wanted part is in 
-c          the last KEV locations.  When exact shifts are selected, the
-c          unwanted part corresponds to the shifts to be applied.
-c
-c  BOUNDS  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTS  Real array of length NP.  (INPUT/OUTPUT)
-c          On INPUT:  contains the user specified shifts if ISHIFT = 0.
-c          On OUTPUT: contains the shifts sorted into decreasing order 
-c          of magnitude with respect to the Ritz estimates contained in
-c          BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     ssortr  ARPACK utility sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssgets ( ishift, which, kev, np, ritz, bounds, shifts )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(kev+np), ritz(kev+np), shifts(np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    kevd2, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   sswap, scopy, ssortr, arscnd
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    max, min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msgets
-c 
-      if (which .eq. 'BE') then
-c
-c        %-----------------------------------------------------%
-c        | Both ends of the spectrum are requested.            |
-c        | Sort the eigenvalues into algebraically increasing  |
-c        | order first then swap high end of the spectrum next |
-c        | to low end in appropriate locations.                |
-c        | NOTE: when np < floor(kev/2) be careful not to swap |
-c        | overlapping locations.                              |
-c        %-----------------------------------------------------%
-c
-         call ssortr ('LA', .true., kev+np, ritz, bounds)
-         kevd2 = kev / 2 
-         if ( kev .gt. 1 ) then
-            call sswap ( min(kevd2,np), ritz, 1, 
-     &                   ritz( max(kevd2,np)+1 ), 1)
-            call sswap ( min(kevd2,np), bounds, 1, 
-     &                   bounds( max(kevd2,np)+1 ), 1)
-         end if
-c
-      else
-c
-c        %----------------------------------------------------%
-c        | LM, SM, LA, SA case.                               |
-c        | Sort the eigenvalues of H into the desired order   |
-c        | and apply the resulting order to BOUNDS.           |
-c        | The eigenvalues are sorted so that the wanted part |
-c        | are always in the last KEV locations.               |
-c        %----------------------------------------------------%
-c
-         call ssortr (which, .true., kev+np, ritz, bounds)
-      end if
-c
-      if (ishift .eq. 1 .and. np .gt. 0) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first.       |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine ssapps.                     |
-c        %-------------------------------------------------------%
-c     
-         call ssortr ('SM', .true., np, bounds, ritz)
-         call scopy (np, ritz, 1, shifts, 1)
-      end if
-c 
-      call arscnd (t1)
-      tsgets = tsgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_sgets: NP is')
-         call svout (logfil, kev+np, ritz, ndigit,
-     &        '_sgets: Eigenvalues of current H matrix')
-         call svout (logfil, kev+np, bounds, ndigit, 
-     &        '_sgets: Associated Ritz estimates')
-      end if
-c 
-      return
-c
-c     %---------------%
-c     | End of ssgets |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssortc.f b/libcruft/arpack/src/ssortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssortc.f
+++ /dev/null
@@ -1,344 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssortc
-c
-c\Description:
-c  Sorts the complex array in XREAL and XIMAG into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  real array Y. It is assumed that if an element of XIMAG is
-c  nonzero, then its negative is also an element. In other words,
-c  both members of a complex conjugate pair are to be sorted and the
-c  pairs are kept adjacent to each other.
-c
-c\Usage:
-c  call ssortc
-c     ( WHICH, APPLY, N, XREAL, XIMAG, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort XREAL,XIMAG into increasing order of magnitude.
-c          'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.
-c          'LR' -> sort XREAL into increasing order of algebraic.
-c          'SR' -> sort XREAL into decreasing order of algebraic.
-c          'LI' -> sort XIMAG into increasing order of magnitude.
-c          'SI' -> sort XIMAG into decreasing order of magnitude.
-c          NOTE: If an element of XIMAG is non-zero, then its negative
-c                is also an element.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  XREAL,  Real array of length N.  (INPUT/OUTPUT)
-c  XIMAG   Real and imaginary part of the array to be sorted.
-c
-c  Y       Real array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssortc (which, apply, n, xreal, ximag, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real     
-     &           xreal(0:n-1), ximag(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real     
-     &           temp, temp1, temp2
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real     
-     &           slapy2
-      external   slapy2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = slapy2(xreal(j),ximag(j))
-            temp2 = slapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.gt.temp2) then
-                temp = xreal(j)
-                xreal(j) = xreal(j+igap)
-                xreal(j+igap) = temp
-c
-                temp = ximag(j)
-                ximag(j) = ximag(j+igap)
-                ximag(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = slapy2(xreal(j),ximag(j))
-            temp2 = slapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.lt.temp2) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (xreal(j).gt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (xreal(j).lt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (abs(ximag(j)).gt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (abs(ximag(j)).lt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssortr.f b/libcruft/arpack/src/ssortr.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssortr.f
+++ /dev/null
@@ -1,218 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssortr
-c
-c\Description:
-c  Sort the array X1 in the order specified by WHICH and optionally 
-c  applies the permutation to the array X2.
-c
-c\Usage:
-c  call ssortr
-c     ( WHICH, APPLY, N, X1, X2 )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X1 is sorted into increasing order of magnitude.
-c          'SM' -> X1 is sorted into decreasing order of magnitude.
-c          'LA' -> X1 is sorted into increasing order of algebraic.
-c          'SA' -> X1 is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to X2.
-c          APPLY = .FALSE. -> do not apply the sorted order to X2.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X1      Real array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  X2      Real array of length N.  (INPUT/OUTPUT)
-c          Only referenced if APPLY = .TRUE.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssortr (which, apply, n, x1, x2)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           x1(0:n-1), x2(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X1 is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x1(j).lt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X1 is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x1(j)).lt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X1 is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x1(j).gt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X1 is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x1(j)).gt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssortr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sstatn.f b/libcruft/arpack/src/sstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/sstatn.f
+++ /dev/null
@@ -1,61 +0,0 @@
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for nonsymmetric Arnoldi code.              |
-c     %---------------------------------------------%
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\SCCS Information: @(#) 
-c FILE: statn.F   SID: 2.4   DATE OF SID: 4/20/96   RELEASE: 2
-c
-      subroutine sstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-c 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-c 
-      tnaupd = 0.0E+0
-      tnaup2 = 0.0E+0
-      tnaitr = 0.0E+0
-      tneigh = 0.0E+0
-      tngets = 0.0E+0
-      tnapps = 0.0E+0
-      tnconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
-c 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-c
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
-c 
-      return
-c
-c
-c     %---------------%
-c     | End of sstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sstats.f b/libcruft/arpack/src/sstats.f
deleted file mode 100644
--- a/libcruft/arpack/src/sstats.f
+++ /dev/null
@@ -1,47 +0,0 @@
-c
-c\SCCS Information: @(#) 
-c FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for symmetric Arnoldi code.                 |
-c     %---------------------------------------------%
- 
-      subroutine sstats
-
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tsaupd = 0.0E+0
-      tsaup2 = 0.0E+0
-      tsaitr = 0.0E+0
-      tseigt = 0.0E+0
-      tsgets = 0.0E+0
-      tsapps = 0.0E+0
-      tsconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
- 
-      return
-c
-c     End of sstats
-c
-      end
diff --git a/libcruft/arpack/src/sstqrb.f b/libcruft/arpack/src/sstqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/sstqrb.f
+++ /dev/null
@@ -1,594 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sstqrb
-c
-c\Description:
-c  Computes all eigenvalues and the last component of the eigenvectors
-c  of a symmetric tridiagonal matrix using the implicit QL or QR method.
-c
-c  This is mostly a modification of the LAPACK routine ssteqr.
-c  See Remarks.
-c
-c\Usage:
-c  call sstqrb
-c     ( N, D, E, Z, WORK, INFO )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          The number of rows and columns in the matrix.  N >= 0.
-c
-c  D       Real array, dimension (N).  (INPUT/OUTPUT)
-c          On entry, D contains the diagonal elements of the
-c          tridiagonal matrix.
-c          On exit, D contains the eigenvalues, in ascending order.
-c          If an error exit is made, the eigenvalues are correct
-c          for indices 1,2,...,INFO-1, but they are unordered and
-c          may not be the smallest eigenvalues of the matrix.
-c
-c  E       Real array, dimension (N-1).  (INPUT/OUTPUT)
-c          On entry, E contains the subdiagonal elements of the
-c          tridiagonal matrix in positions 1 through N-1.
-c          On exit, E has been destroyed.
-c
-c  Z       Real array, dimension (N).  (OUTPUT)
-c          On exit, Z contains the last row of the orthonormal 
-c          eigenvector matrix of the symmetric tridiagonal matrix.  
-c          If an error exit is made, Z contains the last row of the
-c          eigenvector matrix associated with the stored eigenvalues.
-c
-c  WORK    Real array, dimension (max(1,2*N-2)).  (WORKSPACE)
-c          Workspace used in accumulating the transformation for 
-c          computing the last components of the eigenvectors.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0:  normal return.
-c          < 0:  if INFO = -i, the i-th argument had an illegal value.
-c          > 0:  if INFO = +i, the i-th eigenvalue has not converged
-c                              after a total of  30*N  iterations.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-c     lsame   LAPACK character comparison routine.
-c     slae2   LAPACK routine that computes the eigenvalues of a 2-by-2 
-c             symmetric matrix.
-c     slaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric 
-c             matrix.
-c     slamch  LAPACK routine that determines machine constants.
-c     slanst  LAPACK routine that computes the norm of a matrix.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     slaset  LAPACK matrix initialization routine.
-c     slasr   LAPACK routine that applies an orthogonal transformation to 
-c             a matrix.
-c     slasrt  LAPACK sorting routine.
-c     ssteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a symmetric tridiagonal matrix.
-c     xerbla  LAPACK error handler routine.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.5, this routine is a modified version
-c        of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,
-c        only commeted out and new lines inserted.
-c        All lines commented out have "c$$$" at the beginning.
-c        Note that the LAPACK version 1.0 subroutine SSTEQR contained
-c        bugs. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sstqrb ( n, d, e, z, work, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    info, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           d( n ), e( n-1 ), z( n ), work( 2*n-2 )
-c
-c     .. parameters ..
-      Real               
-     &                   zero, one, two, three
-      parameter          ( zero = 0.0E+0, one = 1.0E+0, 
-     &                     two = 2.0E+0, three = 3.0E+0 )
-      integer            maxit
-      parameter          ( maxit = 30 )
-c     ..
-c     .. local scalars ..
-      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
-     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
-     &                   nm1, nmaxit
-      Real               
-     &                   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
-     &                   s, safmax, safmin, ssfmax, ssfmin, tst
-c     ..
-c     .. external functions ..
-      logical            lsame
-      Real
-     &                   slamch, slanst, slapy2
-      external           lsame, slamch, slanst, slapy2
-c     ..
-c     .. external subroutines ..
-      external           slae2, slaev2, slartg, slascl, slaset, slasr,
-     &                   slasrt, sswap, xerbla
-c     ..
-c     .. intrinsic functions ..
-      intrinsic          abs, max, sign, sqrt
-c     ..
-c     .. executable statements ..
-c
-c     test the input parameters.
-c
-      info = 0
-c
-c$$$      IF( LSAME( COMPZ, 'N' ) ) THEN
-c$$$         ICOMPZ = 0
-c$$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
-c$$$         ICOMPZ = 1
-c$$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
-c$$$         ICOMPZ = 2
-c$$$      ELSE
-c$$$         ICOMPZ = -1
-c$$$      END IF
-c$$$      IF( ICOMPZ.LT.0 ) THEN
-c$$$         INFO = -1
-c$$$      ELSE IF( N.LT.0 ) THEN
-c$$$         INFO = -2
-c$$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
-c$$$     $         N ) ) ) THEN
-c$$$         INFO = -6
-c$$$      END IF
-c$$$      IF( INFO.NE.0 ) THEN
-c$$$         CALL XERBLA( 'SSTEQR', -INFO )
-c$$$         RETURN
-c$$$      END IF
-c
-c    *** New starting with version 2.5 ***
-c
-      icompz = 2
-c    *************************************
-c
-c     quick return if possible
-c
-      if( n.eq.0 )
-     $   return
-c
-      if( n.eq.1 ) then
-         if( icompz.eq.2 )  z( 1 ) = one
-         return
-      end if
-c
-c     determine the unit roundoff and over/underflow thresholds.
-c
-      eps = slamch( 'e' )
-      eps2 = eps**2
-      safmin = slamch( 's' )
-      safmax = one / safmin
-      ssfmax = sqrt( safmax ) / three
-      ssfmin = sqrt( safmin ) / eps2
-c
-c     compute the eigenvalues and eigenvectors of the tridiagonal
-c     matrix.
-c
-c$$      if( icompz.eq.2 )
-c$$$     $   call slaset( 'full', n, n, zero, one, z, ldz )
-c
-c     *** New starting with version 2.5 ***
-c
-      if ( icompz .eq. 2 ) then
-         do 5 j = 1, n-1
-            z(j) = zero
-  5      continue
-         z( n ) = one
-      end if
-c     *************************************
-c
-      nmaxit = n*maxit
-      jtot = 0
-c
-c     determine where the matrix splits and choose ql or qr iteration
-c     for each block, according to whether top or bottom diagonal
-c     element is smaller.
-c
-      l1 = 1
-      nm1 = n - 1
-c
-   10 continue
-      if( l1.gt.n )
-     $   go to 160
-      if( l1.gt.1 )
-     $   e( l1-1 ) = zero
-      if( l1.le.nm1 ) then
-         do 20 m = l1, nm1
-            tst = abs( e( m ) )
-            if( tst.eq.zero )
-     $         go to 30
-            if( tst.le.( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+
-     $          1 ) ) ) )*eps ) then
-               e( m ) = zero
-               go to 30
-            end if
-   20    continue
-      end if
-      m = n
-c
-   30 continue
-      l = l1
-      lsv = l
-      lend = m
-      lendsv = lend
-      l1 = m + 1
-      if( lend.eq.l )
-     $   go to 10
-c
-c     scale submatrix in rows and columns l to lend
-c
-      anorm = slanst( 'i', lend-l+1, d( l ), e( l ) )
-      iscale = 0
-      if( anorm.eq.zero )
-     $   go to 10
-      if( anorm.gt.ssfmax ) then
-         iscale = 1
-         call slascl( 'g', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,
-     $                info )
-         call slascl( 'g', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,
-     $                info )
-      else if( anorm.lt.ssfmin ) then
-         iscale = 2
-         call slascl( 'g', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,
-     $                info )
-         call slascl( 'g', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,
-     $                info )
-      end if
-c
-c     choose between ql and qr iteration
-c
-      if( abs( d( lend ) ).lt.abs( d( l ) ) ) then
-         lend = lsv
-         l = lendsv
-      end if
-c
-      if( lend.gt.l ) then
-c
-c        ql iteration
-c
-c        look for small subdiagonal element.
-c
-   40    continue
-         if( l.ne.lend ) then
-            lendm1 = lend - 1
-            do 50 m = l, lendm1
-               tst = abs( e( m ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+
-     $             safmin )go to 60
-   50       continue
-         end if
-c
-         m = lend
-c
-   60    continue
-         if( m.lt.lend )
-     $      e( m ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 80
-c
-c        if remaining matrix is 2-by-2, use slae2 or slaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l+1 ) then
-            if( icompz.gt.0 ) then
-               call slaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
-               work( l ) = c
-               work( n-1+l ) = s
-c$$$               call slasr( 'r', 'v', 'b', n, 2, work( l ),
-c$$$     $                     work( n-1+l ), z( 1, l ), ldz )
-c
-c              *** New starting with version 2.5 ***
-c
-               tst      = z(l+1)
-               z(l+1) = c*tst - s*z(l)
-               z(l)   = s*tst + c*z(l)
-c              *************************************
-            else
-               call slae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
-            end if
-            d( l ) = rt1
-            d( l+1 ) = rt2
-            e( l ) = zero
-            l = l + 2
-            if( l.le.lend )
-     $         go to 40
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l+1 )-p ) / ( two*e( l ) )
-         r = slapy2( g, one )
-         g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         mm1 = m - 1
-         do 70 i = mm1, l, -1
-            f = s*e( i )
-            b = c*e( i )
-            call slartg( g, f, c, s, r )
-            if( i.ne.m-1 )
-     $         e( i+1 ) = r
-            g = d( i+1 ) - p
-            r = ( d( i )-g )*s + two*c*b
-            p = s*r
-            d( i+1 ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = -s
-            end if
-c
-   70    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = m - l + 1
-c$$$            call slasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),
-c$$$     $                  z( 1, l ), ldz )
-c
-c             *** New starting with version 2.5 ***
-c
-              call slasr( 'r', 'v', 'b', 1, mm, work( l ), 
-     &                    work( n-1+l ), z( l ), 1 )
-c             *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( l ) = g
-         go to 40
-c
-c        eigenvalue found.
-c
-   80    continue
-         d( l ) = p
-c
-         l = l + 1
-         if( l.le.lend )
-     $      go to 40
-         go to 140
-c
-      else
-c
-c        qr iteration
-c
-c        look for small superdiagonal element.
-c
-   90    continue
-         if( l.ne.lend ) then
-            lendp1 = lend + 1
-            do 100 m = l, lendp1, -1
-               tst = abs( e( m-1 ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+
-     $             safmin )go to 110
-  100       continue
-         end if
-c
-         m = lend
-c
-  110    continue
-         if( m.gt.lend )
-     $      e( m-1 ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 130
-c
-c        if remaining matrix is 2-by-2, use slae2 or slaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l-1 ) then
-            if( icompz.gt.0 ) then
-               call slaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
-c$$$               work( m ) = c
-c$$$               work( n-1+m ) = s
-c$$$               call slasr( 'r', 'v', 'f', n, 2, work( m ),
-c$$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )
-c
-c               *** New starting with version 2.5 ***
-c
-                tst      = z(l)
-                z(l)   = c*tst - s*z(l-1)
-                z(l-1) = s*tst + c*z(l-1)
-c               ************************************* 
-            else
-               call slae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
-            end if
-            d( l-1 ) = rt1
-            d( l ) = rt2
-            e( l-1 ) = zero
-            l = l - 2
-            if( l.ge.lend )
-     $         go to 90
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
-         r = slapy2( g, one )
-         g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         lm1 = l - 1
-         do 120 i = m, lm1
-            f = s*e( i )
-            b = c*e( i )
-            call slartg( g, f, c, s, r )
-            if( i.ne.m )
-     $         e( i-1 ) = r
-            g = d( i ) - p
-            r = ( d( i+1 )-g )*s + two*c*b
-            p = s*r
-            d( i ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = s
-            end if
-c
-  120    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = l - m + 1
-c$$$            call slasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),
-c$$$     $                  z( 1, m ), ldz )
-c
-c           *** New starting with version 2.5 ***
-c
-            call slasr( 'r', 'v', 'f', 1, mm, work( m ), work( n-1+m ),
-     &                  z( m ), 1 )
-c           *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( lm1 ) = g
-         go to 90
-c
-c        eigenvalue found.
-c
-  130    continue
-         d( l ) = p
-c
-         l = l - 1
-         if( l.ge.lend )
-     $      go to 90
-         go to 140
-c
-      end if
-c
-c     undo scaling if necessary
-c
-  140 continue
-      if( iscale.eq.1 ) then
-         call slascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call slascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      else if( iscale.eq.2 ) then
-         call slascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call slascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      end if
-c
-c     check for no convergence to an eigenvalue after a total
-c     of n*maxit iterations.
-c
-      if( jtot.lt.nmaxit )
-     $   go to 10
-      do 150 i = 1, n - 1
-         if( e( i ).ne.zero )
-     $      info = info + 1
-  150 continue
-      go to 190
-c
-c     order eigenvalues and eigenvectors.
-c
-  160 continue
-      if( icompz.eq.0 ) then
-c
-c        use quick sort
-c
-         call slasrt( 'i', n, d, info )
-c
-      else
-c
-c        use selection sort to minimize swaps of eigenvectors
-c
-         do 180 ii = 2, n
-            i = ii - 1
-            k = i
-            p = d( i )
-            do 170 j = ii, n
-               if( d( j ).lt.p ) then
-                  k = j
-                  p = d( j )
-               end if
-  170       continue
-            if( k.ne.i ) then
-               d( k ) = d( i )
-               d( i ) = p
-c$$$               call sswap( n, z( 1, i ), 1, z( 1, k ), 1 )
-c           *** New starting with version 2.5 ***
-c
-               p    = z(k)
-               z(k) = z(i)
-               z(i) = p
-c           *************************************
-            end if
-  180    continue
-      end if
-c
-  190 continue
-      return
-c
-c     %---------------%
-c     | End of sstqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/stat.h b/libcruft/arpack/src/stat.h
deleted file mode 100644
--- a/libcruft/arpack/src/stat.h
+++ /dev/null
@@ -1,21 +0,0 @@
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-c\SCCS Information: @(#) 
-c FILE: stat.h   SID: 2.2   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-      real       t0, t1, t2, t3, t4, t5
-      save       t0, t1, t2, t3, t4, t5
-c
-      integer    nopx, nbx, nrorth, nitref, nrstrt
-      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
-      common /timing/ 
-     &           nopx, nbx, nrorth, nitref, nrstrt,
-     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
diff --git a/libcruft/arpack/src/version.h b/libcruft/arpack/src/version.h
deleted file mode 100644
--- a/libcruft/arpack/src/version.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-
- In the current version, the parameter KAPPA in the Kahan's test
- for orthogonality is set to 0.717, the same as used by Gragg & Reichel.
- However computational experience indicates that this is a little too 
- strict and will frequently force reorthogonalization when it is not
- necessary to do so. 
-
- Also the "moving boundary" idea is not currently activated in the nonsymmetric
- code since it is not conclusive that it's the right thing to do all the time.  
- Requires further investigation.
-
- As of 02/01/93 Richard Lehoucq assumes software control of the codes from
- Phuong Vu. On 03/01/93 all the *.F files were migrated SCCS. The 1.1 version
- of codes are those received from Phuong Vu. The frozen version of 07/08/92
- is now considered version 1.1.
-
- Version 2.1 contains two new symmetric routines, sesrt and seupd. 
- Changes as well as bug fixes for version 1.1 codes that were only corrected 
- for programming bugs are version 1.2. These 1.2 versions will also be in version 2.1.
- Subroutine [d,s]saupd now requires slightly more workspace. See [d,s]saupd for the
- details. 
-
- \SCCS Information: @(#) 
-  FILE: version.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2
-
- */
-
-#define VERSION_NUMBER ' 2.1'
-#define VERSION_DATE   ' 11/15/95'
diff --git a/libcruft/arpack/src/zgetv0.f b/libcruft/arpack/src/zgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/zgetv0.f
+++ /dev/null
@@ -1,414 +0,0 @@
-c\BeginDoc
-c
-c\Name: zgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call zgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to zgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that zgetv0 is called.  
-c          It should be set to 1 on the initial call to zgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Complex*16 N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Double precision scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Complex*16 work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlarnv  LAPACK routine for generating a random vector. 
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.3   DATE OF SID: 08/27/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex*16
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &            rzero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Double precision
-     &           rnorm0
-      Complex*16
-     &           cnorm
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy, zgemv, zlarnv, zvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dznrm2, dlapy2
-      Complex*16
-     &           zdotc
-      external   zdotc, dznrm2, dlapy2
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call zlarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call zcopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %----------------------------------------%
-c     | Back from computing B*(initial-vector) |
-c     %----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      call arscnd (t3)
-      tmvopx = tmvopx + (t3 - t2)
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call zcopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call zcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          cnorm  = zdotc (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(dlapy2(dble(cnorm),dimag(cnorm)))
-      else if (bmat .eq. 'I') then
-           rnorm0 = dznrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call zgemv ('C', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call zgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call zcopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call zcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         cnorm = zdotc (n, resid, 1, workd, 1)
-         rnorm = sqrt(dlapy2(dble(cnorm),dimag(cnorm)))
-      else if (bmat .eq. 'I') then
-         rnorm = dznrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call dvout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 1) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = rzero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 2) then
-         call zvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/znaitr.f b/libcruft/arpack/src/znaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/znaitr.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in znaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call znaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See znaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Complex*16 N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Complex*16 (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex*16 work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     zgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlanhs  LAPACK routine that computes various norms of a matrix.
-c     zlascl  LAPACK routine for careful scaling of a matrix.
-c     dlabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zaxpy   Level 1 BLAS that computes a vector triad.
-c     zcopy   Level 1 BLAS that copies one vector to another .
-c     zdotc   Level 1 BLAS that computes the scalar product of two vectors. 
-c     zscal   Level 1 BLAS that scales a vector.
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number. 
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.3   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in znaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex*16
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rone, rzero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0), 
-     &           rone = 1.0D+0, rzero = 0.0D+0)
-c
-c     %--------------%
-c     | Local Arrays |
-c     %--------------%
-c
-      Double precision
-     &           rtemp(2)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Double precision            
-     &           ovfl, smlnum, tst1, ulp, unfl, betaj,
-     &           temp1, rnorm1, wnorm
-      Complex*16
-     &           cnorm
-c
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zaxpy, zcopy, zscal, zdscal, zgemv, zgetv0, 
-     &           dlabad, zvout, zmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Complex*16
-     &           zdotc 
-      Double precision            
-     &           dlamch,  dznrm2, zlanhs, dlapy2
-      external   zdotc, dznrm2, zlanhs, dlamch, dlapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  dimag, dble, max, sqrt 
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine zlahqr     |
-c        %-----------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = dble(one / unfl)
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mcaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         zgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determine whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. rzero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = rzero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call zgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tcaitr = tcaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call zcopy (n, resid, 1, v(1,j), 1)
-         if ( rnorm .ge. unfl) then
-             temp1 = rone / rnorm
-             call zdscal (n, temp1, v(1,j), 1)
-             call zdscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine zlascl               |
-c            %-----------------------------------------%
-c
-             call zlascl ('General', i, i, rnorm, rone,
-     &                    n, 1, v(1,j), n, infol)
-             call zlascl ('General', i, i, rnorm, rone,  
-     &                    n, 1, workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call zcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call zcopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             cnorm = zdotc (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             wnorm = dznrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call zgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call zgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = dcmplx(betaj, rzero)
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            cnorm = zdotc (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-            rnorm = dznrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if ( rnorm .gt. 0.717*wnorm ) go to 100
-c
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            rtemp(1) = wnorm
-            rtemp(2) = rnorm
-            call dvout (logfil, 2, rtemp, ndigit, 
-     &      '_naitr: re-orthogonalization; wnorm and rnorm are')
-            call zvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call zgemv ('C', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call zgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call zaxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             cnorm  = zdotc (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             rnorm1 = dznrm2(n, resid, 1)
-         end if
-c 
-         if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                rtemp(1) = rnorm
-                rtemp(2) = rnorm1
-                call dvout (logfil, 2, rtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if ( rnorm1 .gt. 0.717*rnorm ) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue 
-            rnorm = rzero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tcaitr = tcaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine zlahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = dlapy2(dble(h(i,i)),dimag(h(i,i)))
-     &              + dlapy2(dble(h(i+1,i+1)), dimag(h(i+1,i+1)))
-               if( tst1.eq.dble(zero) )
-     &              tst1 = zlanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( dlapy2(dble(h(i+1,i)),dimag(h(i+1,i))) .le. 
-     &                    max( ulp*tst1, smlnum ) ) 
-     &             h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call zmout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of znaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/znapps.f b/libcruft/arpack/src/znapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/znapps.f
+++ /dev/null
@@ -1,507 +0,0 @@
-c\BeginDoc
-c
-c\Name: znapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call znapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW. 
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Complex*16 array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Complex*16 N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16 (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenberg matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Complex*16 KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16 work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Complex*16 work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlanhs  LAPACK routine that computes various norms of a matrix.
-c     zlartg  LAPACK Givens rotation construction routine.
-c     zlaset  LAPACK matrix initialization routine.
-c     dlabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zaxpy   Level 1 BLAS that computes a vector triad.
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.3   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine zlahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     Upon output, the subdiagonals of H are enforced to be non-negative
-c     real numbers.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           h(ldh,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rzero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, istart, j, jj, kplusp, msglvl
-      logical    first
-      Complex*16
-     &           cdum, f, g, h11, h21, r, s, sigma, t
-      Double precision             
-     &           c,  ovfl, smlnum, ulp, unfl, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zaxpy, zcopy, zgemv, zscal, zlacpy, zlartg, 
-     &           zvout, zlaset, dlabad, zmout, arscnd, ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision                 
-     &           zlanhs, dlamch, dlapy2
-      external   zlanhs, dlamch, dlapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, dimag, conjg, dcmplx, max, min, dble
-c
-c     %---------------------%
-c     | Statement Functions |
-c     %---------------------%
-c
-      Double precision     
-     &           zabs1
-      zabs1( cdum ) = abs( dble( cdum ) ) + abs( dimag( cdum ) )
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine zlahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = dble(one / unfl)
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcapps
-c 
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call zlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      do 110 jj = 1, np
-         sigma = shift(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call zvout (logfil, 1, sigma, ndigit, 
-     &               '_napps: Value of the shift ')
-         end if
-c
-         istart = 1
-   20    continue
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine zlahqr    |
-c           %----------------------------------------%
-c
-            tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
-            if( tst1.eq.rzero )
-     &         tst1 = zlanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if ( abs(dble(h(i+1,i))) 
-     &           .le. max(ulp*tst1, smlnum) )  then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call zvout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        | or if the current block starts after the point |
-c        | of compression since we'll discard this stuff  |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend .or. istart .gt. kev) go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         f = h11 - sigma
-         g = h21
-c 
-         do 80 i = istart, iend-1
-c
-c           %------------------------------------------------------%
-c           | Construct the plane rotation G to zero out the bulge |
-c           %------------------------------------------------------%
-c
-            call zlartg (f, g, c, s, r)
-            if (i .gt. istart) then
-               h(i,i-1) = r
-               h(i+1,i-1) = zero
-            end if
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the left of H;  H <- G'*H |
-c           %---------------------------------------------%
-c
-            do 50 j = i, kplusp
-               t        =  c*h(i,j) + s*h(i+1,j)
-               h(i+1,j) = -conjg(s)*h(i,j) + c*h(i+1,j)
-               h(i,j)   = t   
-   50       continue
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the right of H;  H <- H*G |
-c           %---------------------------------------------%
-c
-            do 60 j = 1, min(i+2,iend)
-               t        =  c*h(j,i) + conjg(s)*h(j,i+1)
-               h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-               h(j,i)   = t   
-   60       continue
-c
-c           %-----------------------------------------------------%
-c           | Accumulate the rotation in the matrix Q;  Q <- Q*G' |
-c           %-----------------------------------------------------%
-c
-            do 70 j = 1, min(i+jj, kplusp)
-               t        =   c*q(j,i) + conjg(s)*q(j,i+1)
-               q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-               q(j,i)   = t   
-   70       continue
-c
-c           %---------------------------%
-c           | Prepare for next rotation |
-c           %---------------------------%
-c
-            if (i .lt. iend-1) then
-               f = h(i+1,i)
-               g = h(i+2,i)
-            end if
-   80    continue
-c
-c        %-------------------------------%
-c        | Finished applying the shift.  |
-c        %-------------------------------%
-c 
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %---------------------------------------------------%
-c     | Perform a similarity transformation that makes    |
-c     | sure that the compressed H will have non-negative |
-c     | real subdiagonal elements.                        |
-c     %---------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( dble( h(j+1,j) ) .lt. rzero .or.
-     &        dimag( h(j+1,j) ) .ne. rzero ) then
-            t = h(j+1,j) / dlapy2(dble(h(j+1,j)),dimag(h(j+1,j)))
-            call zscal( kplusp-j+1, conjg(t), h(j+1,j), ldh )
-            call zscal( min(j+2, kplusp), t, h(1,j+1), 1 )
-            call zscal( min(j+np+1,kplusp), t, q(1,j+1), 1 )
-            h(j+1,j) = dcmplx( dble( h(j+1,j) ), rzero )
-         end if
-  120 continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine zlahqr.       |
-c        | Note: Since the subdiagonals of the        |
-c        | compressed H are nonnegative real numbers, |
-c        | we take advantage of this.                 |
-c        %--------------------------------------------%
-c
-         tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
-         if( tst1 .eq. rzero )
-     &       tst1 = zlanhs( '1', kev, h, ldh, workl )
-         if( dble( h( i+1,i ) ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call zgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call zcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call zlacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call zscal (n, q(kplusp,kev), resid, 1)
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zaxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call zvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call zvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call zmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tcapps = tcapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of znapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/znaup2.f b/libcruft/arpack/src/znaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/znaup2.f
+++ /dev/null
@@ -1,801 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaup2
-c
-c\Description:
-c  Intermediate level interface called by znaupd .
-c
-c\Usage:
-c  call znaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, RWORK, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in znaupd .
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in znaupd .
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Complex*16  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex*16  array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV)  contains the computed Ritz values of OP.
-c
-c  BOUNDS  Complex*16  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Complex*16  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in ZNAUPD .
-c
-c  RWORK   Double precision    work array of length  NEV+NP ( WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     zgetv0   ARPACK initial vector generation routine.
-c     znaitr   ARPACK Arnoldi factorization routine.
-c     znapps   ARPACK application of implicit shifts routine.
-c     zneigh   ARPACK compute Ritz values and error bounds routine.
-c     zngets   ARPACK reorder Ritz values and error bounds routine.
-c     zsortc   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout    ARPACK utility routine that prints matrices
-c     zvout    ARPACK utility routine that prints vectors.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zcopy    Level 1 BLAS that copies one vector to another .
-c     zdotc    Level 1 BLAS that computes the scalar product of two vectors.
-c     zswap    Level 1 BLAS that swaps two vectors.
-c     dznrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice Universitya
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.6   DATE OF SID: 06/01/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds,
-     &     q, ldq, workl, ipntr, workd, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Complex*16
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np),
-     &           resid(n), ritz(nev+np),  v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-       Double precision
-     &           rwork(nev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) ,
-     &           rzero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    cnorm , getv0, initv , update, ushift
-      integer    ierr  , iter , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0   , nptemp, i    ,
-     &           j
-      Complex*16
-     &           cmpnorm
-      Double precision
-     &           rnorm , eps23, rtemp
-      character  wprime*2
-c
-      save       cnorm,  getv0, initv , update, ushift,
-     &           rnorm,  iter , kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0   , eps23
-c
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(3)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy , zgetv0 , znaitr , zneigh , zngets , znapps ,
-     &           zsortc , zswap , zmout , zvout , ivout, arscnd
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Complex*16
-     &           zdotc
-      Double precision
-     &           dznrm2 , dlamch , dlapy2
-      external   zdotc , dznrm2 , dlamch , dlapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  dimag , dble , min, max
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mcaup2
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvalues.     |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------%
-c        | Get machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = dlamch ('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call zgetv0  (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. rzero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call znaitr  (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine znapps .                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call znaitr (ido, bmat, n, nev, np,    mode,  resid, rnorm,
-     &               v  , ldv , h, ldh, ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call zneigh  (rnorm, kplusp, h, ldh, ritz, bounds,
-     &                q, ldq, workl, rwork,  ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZ,    |
-c        | and BOUNDS respectively.                          |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-c
-c        %--------------------------------------------------%
-c        | Make a copy of Ritz values and the corresponding |
-c        | Ritz estimates obtained from zneigh .             |
-c        %--------------------------------------------------%
-c
-         call zcopy (kplusp,ritz,1,workl(kplusp**2+1),1)
-         call zcopy (kplusp,bounds,1,workl(kplusp**2+kplusp+1),1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | bounds are in the last NEV loc. of RITZ           |
-c        | BOUNDS respectively.                              |
-c        %---------------------------------------------------%
-c
-         call zngets  (ishift, which, nev, np, ritz, bounds)
-c
-c        %------------------------------------------------------------%
-c        | Convergence test: currently we use the following criteria. |
-c        | The relative accuracy of a Ritz value is considered        |
-c        | acceptable if:                                             |
-c        |                                                            |
-c        | error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)). |
-c        |                                                            |
-c        %------------------------------------------------------------%
-c
-         nconv  = 0
-c
-         do 25 i = 1, nev
-            rtemp = max( eps23, dlapy2 ( dble (ritz(np+i)),
-     &                                  dimag (ritz(np+i)) ) )
-            if ( dlapy2 (dble (bounds(np+i)),dimag (bounds(np+i)))
-     &                 .le. tol*rtemp ) then
-               nconv = nconv + 1
-            end if
-   25    continue
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_naup2: NEV, NP, NCONV are')
-            call zvout  (logfil, kplusp, ritz, ndigit,
-     &           '_naup2: The eigenvalues of H')
-            call zvout  (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. nev0) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call zvout (logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Eigenvalues computed by _neigh:')
-               call zvout (logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Ritz estimates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to zneupd  if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = dcmplx (rnorm,rzero)
-c
-c           %----------------------------------------------%
-c           | Sort Ritz values so that converged Ritz      |
-c           | values appear within the first NEV locations |
-c           | of ritz and bounds, and the most desired one |
-c           | appears at the front.                        |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call zsortc (wprime, .true., kplusp, ritz, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23, magnitude of the Ritz value).  |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-                rtemp = max( eps23, dlapy2 ( dble (ritz(j)),
-     &                                       dimag (ritz(j)) ) )
-                bounds(j) = bounds(j)/rtemp
- 35         continue
-c
-c           %---------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz |
-c           | estimates.  This will push all the converged ones |
-c           | towards the front of ritz, bounds (in the case    |
-c           | when NCONV < NEV.)                                |
-c           %---------------------------------------------------%
-c
-            wprime = 'LM'
-            call zsortc (wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                rtemp = max( eps23, dlapy2 ( dble (ritz(j)),
-     &                                       dimag (ritz(j)) ) )
-                bounds(j) = bounds(j)*rtemp
- 40         continue
-c
-c           %-----------------------------------------------%
-c           | Sort the converged Ritz values again so that  |
-c           | the "threshold" value appears at the front of |
-c           | ritz and bound.                               |
-c           %-----------------------------------------------%
-c
-            call zsortc (which, .true., nconv, ritz, bounds)
-c
-            if (msglvl .gt. 1) then
-               call zvout  (logfil, kplusp, ritz, ndigit,
-     &            '_naup2: Sorted eigenvalues')
-               call zvout  (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev0) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0)  info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. nev0) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call zngets  (ishift, which, nev, np, ritz, bounds)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call zvout  (logfil, nev, ritz(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values ')
-               call zvout  (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: pop back out to get the shifts |
-c           | and return them in the first 2*NP locations of WORKL. |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-   50    continue
-         ushift = .false.
-c
-         if ( ishift .ne. 1 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZ, to free up WORKL           |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call zcopy  (np, workl, 1, ritz, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call zvout  (logfil, np, ritz, ndigit,
-     &                  '_naup2: values of the shifts')
-            if ( ishift .eq. 1 )
-     &          call zvout  (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call znapps  (n, nev, np, ritz, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to znaitr .  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy  (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy  (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            cmpnorm = zdotc  (n, resid, 1, workd, 1)
-            rnorm = sqrt(dlapy2 (dble (cmpnorm),dimag (cmpnorm)))
-         else if (bmat .eq. 'I') then
-            rnorm = dznrm2 (n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call zmout  (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tcaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of znaup2  |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/znaupd.f b/libcruft/arpack/src/znaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/znaupd.f
+++ /dev/null
@@ -1,664 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This is intended to be used to find a few eigenpairs of a
-c  complex linear operator OP with respect to a semi-inner product defined
-c  by a hermitian positive semi-definite real matrix B. B may be the identity
-c  matrix.  NOTE: if both OP and B are real, then dsaupd  or dnaupd  should
-c  be used.
-c
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  znaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M hermitian positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M hermitian semi-definite
-c           ===> OP =  inv[A - sigma*M]*M   and  B = M.
-c           ===> shift-and-invert mode
-c           If OP*x = amu*x, then lambda = sigma + 1/amu.
-c
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call znaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to znaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          znaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = M * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute and return the shifts in the first
-c                    NP locations of WORKL.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          After the initialization phase, when the routine is used in
-c          the "shift-and-invert" mode, the vector M * X is already
-c          available and does not need to be recomputed in forming OP*X.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Double precision   scalar.  (INPUT)
-c          Stopping criteria: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = dlamch ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine dlamch ).
-c
-c  RESID   Complex*16  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 1 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x. (See remark 4 below.)
-c
-c  V       Complex*16  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to filter out
-c          the components of the unwanted eigenvector.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are to be provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the Hessenberg matrix H are returned in the part
-c                      of WORKL array corresponding to RITZ.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration from the beginning
-c                      after updating the starting vector with a linear
-c                      combination of Ritz vectors associated with the
-c                      "wanted" eigenvalues.
-c          ISHIFT = 2: other choice of internal shift to be defined.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3; See under \Description of znaupd  for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), _naupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP < NCV-NEV.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg
-c                    matrix H in WORKL.
-c          IPNTR(6): pointer to the  ritz value array  RITZ
-c          IPNTR(7): pointer to the (projected) ritz vector array Q
-c          IPNTR(8): pointer to the error BOUNDS array in WORKL.
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by zneupd . See Remark 2 below.
-c
-c          IPNTR(9): pointer to the NCV RITZ values of the
-c                    original system.
-c          IPNTR(10): Not Used
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     zneupd  if RVEC = .TRUE. See Remark 2 below.
-c
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note below.
-c
-c  WORKL   Complex*16  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 5*NCV.
-c
-c  RWORK   Double precision   work array of length NCV (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   User input error highly likely.  Please
-c                   check actual array dimensions and layout.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when using
-c     Mode = 3.  When operating in Mode = 3 setting WHICH = 'LM' will
-c     compute the NEV eigenvalues of the original problem that are
-c     closest to the shift SIGMA . After convergence, approximate eigenvalues
-c     of the original problem may be obtained with the ARPACK subroutine zneupd .
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call zneupd  immediately following
-c     completion of znaupd . This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 1.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) complex shifts in locations
-c     WORKL(IPNTR(14)), WORKL(IPNTR(14)+1), ... , WORKL(IPNTR(14)+NP).
-c     Eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are ordered
-c     according to the order defined by WHICH.  The associated Ritz estimates
-c     are located in WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... ,
-c     WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Complex*16  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Complex*16  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "_Complex_ Shift and Invert Strategies for
-c     _Real_ Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     znaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     zstatn   ARPACK routine that initializes the timing variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     zvout    ARPACK utility routine that prints vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Complex*16
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-      Double precision
-     &           rwork(ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   znaup2 , zvout , ivout, arscnd, zstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call zstatn
-         call arscnd (t0)
-         msglvl = mcaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 5*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 3) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. 0.0D+0  )			tol = dlamch ('EpsMach')
-         if (ishift .ne. 0  .and.
-     &       ishift .ne. 1  .and.
-     &       ishift .ne. 2) 			ishift = 1
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 5*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values             |
-c        | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds        |
-c        | workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace       |
-c        | The final workspace is needed by subroutine zneigh  called   |
-c        | by znaup2 . Subroutine zneigh  calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + ldh*ncv
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = iq
-         ipntr(8) = bounds
-         ipntr(14) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call znaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, rwork, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP.              |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within znaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call zvout  (logfil, np, workl(ritz), ndigit,
-     &               '_naupd: The final Ritz values')
-         call zvout  (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tcaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tcaupd, tcaup2, tcaitr, titref,
-     &                  tgetv0, tceigh, tcgets, tcapps, tcconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Complex implicit Arnoldi update code      =',/
-     &      5x, '= Version Number: ', ' 2.3' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of znaupd  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zneigh.f b/libcruft/arpack/src/zneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/zneigh.f
+++ /dev/null
@@ -1,257 +0,0 @@
-c\BeginDoc
-c
-c\Name: zneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call zneigh
-c     ( RNORM, N, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, RWORK, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Complex*16 N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex*16 array of length N.  (OUTPUT)
-c          On output, RITZ(1:N) contains the eigenvalues of H.
-c
-c  BOUNDS  Complex*16 array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues held in RITZ.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZ.
-c
-c  Q       Complex*16 N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16 work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  RWORK   Double precision  work array of length N (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end. 
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from zlahqr or ztrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     dvout   ARPACK utility routine that prints vectors.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlahqr  LAPACK routine to compute the Schur form of an
-c             upper Hessenberg matrix.
-c     zlaset  LAPACK matrix initialization routine.
-c     ztrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form
-c     zcopy   Level 1 BLAS that copies one vector to another. 
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zneigh (rnorm, n, h, ldh, ritz, bounds, 
-     &                   q, ldq, workl, rwork, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Double precision     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritz(n),
-     &           workl(n*(n+3)) 
-      Double precision 
-     &           rwork(n)
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16     
-     &           one, zero
-      Double precision
-     &           rone
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rone = 1.0D+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    j,  msglvl
-      Complex*16     
-     &           vl(1)
-      Double precision
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zlacpy, zlahqr, ztrevc, zcopy, 
-     &           zdscal, zmout, zvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dznrm2
-      external   dznrm2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mceigh
-c 
-      if (msglvl .gt. 2) then
-          call zmout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the   |
-c     |    corresponding Schur vectors and the full Schur form T |
-c     |    of the current upper Hessenberg matrix H.             |
-c     |    zlahqr returns the full Schur form of H               | 
-c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
-c     %----------------------------------------------------------%
-c
-      call zlacpy ('All', n, n, h, ldh, workl, n)
-      call zlaset ('All', n, n, zero, one, q, ldq)
-      call zlahqr (.true., .true., n, 1, n, workl, ldh, ritz,
-     &             1, n, q, ldq, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      call zcopy (n, q(n-1,1), ldq, bounds, 1)
-      if (msglvl .gt. 1) then
-         call zvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and |
-c     |    apply the Schur vectors to get the corresponding      |
-c     |    eigenvectors.                                         |
-c     %----------------------------------------------------------%
-c
-      call ztrevc ('Right', 'Back', select, n, workl, n, vl, n, q, 
-     &             ldq, n, n, workl(n*n+1), rwork, ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | Euclidean norms are all one. LAPACK subroutine |
-c     | ztrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      do 10 j=1, n
-            temp = dznrm2( n, q(1,j), 1 )
-            call zdscal ( n, rone / temp, q(1,j), 1 )
-   10 continue
-c
-      if (msglvl .gt. 1) then
-         call zcopy(n, q(n,1), ldq, workl, 1)
-         call zvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      call zcopy(n, q(n,1), n, bounds, 1)
-      call zdscal(n, rnorm, bounds, 1)
-c
-      if (msglvl .gt. 2) then
-         call zvout (logfil, n, ritz, ndigit,
-     &              '_neigh: The eigenvalues of H')
-         call zvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd(t1)
-      tceigh = tceigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zneupd.f b/libcruft/arpack/src/zneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/zneupd.f
+++ /dev/null
@@ -1,876 +0,0 @@
-c\BeginDoc
-c 
-c\Name: zneupd  
-c 
-c\Description: 
-c  This subroutine returns the converged approximations to eigenvalues 
-c  of A*z = lambda*B*z and (optionally): 
-c 
-c      (1) The corresponding approximate eigenvectors; 
-c 
-c      (2) An orthonormal basis for the associated approximate 
-c          invariant subspace; 
-c 
-c      (3) Both.  
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal 
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied). 
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to ZNAUPD .  ZNAUPD  must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such 
-c  in the comments that follow.   The computed orthonormal basis for the 
-c  invariant subspace corresponding to these Ritz values is referred to as a 
-c  Schur basis. 
-c 
-c  The definition of OP as well as other terms and the relation of computed
-c  Ritz values and vectors of OP with respect to the given problem
-c  A*z = lambda*B*z may be found in the header of ZNAUPD .  For a brief 
-c  description, see definitions of IPARAM(7), MODE and WHICH in the
-c  documentation of ZNAUPD .
-c
-c\Usage:
-c  call zneupd  
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, 
-c       WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the  Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT need not be initialized 
-c          but it is used as internal workspace.
-c
-c  D       Complex*16  array of dimension NEV+1.  (OUTPUT)
-c          On exit, D contains the  Ritz  approximations 
-c          to the eigenvalues lambda for A*z = lambda*B*z.
-c
-c  Z       Complex*16  N by NEV array    (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represents approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          If RVEC = .FALSE. or HOWMNY = 'P', then Z is NOT REFERENCED.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required, 
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi 
-c          basis array V computed by ZNAUPD .  In this case the Arnoldi basis 
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ) is required.  
-c          In any case,  LDZ .ge. 1 is required.
-c
-c  SIGMA   Complex*16   (INPUT)
-c          If IPARAM(7) = 3 then SIGMA represents the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  WORKEV  Complex*16  work array of dimension 2*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to ZNAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments 
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, 
-c           WORKD, WORKL, LWORKL, RWORK, INFO 
-c
-c         must be passed directly to ZNEUPD  following the last call 
-c         to ZNAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to ZNAUPD  and the call to ZNEUPD .
-c
-c  Three of these parameters (V, WORKL and INFO) are also output parameters:
-c
-c  V       Complex*16  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by ZNAUPD  .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+2*ncv) contains information obtained in
-c          znaupd .  They are not changed by zneupd .
-c          WORKL(ncv*ncv+2*ncv+1:3*ncv*ncv+4*ncv) holds the
-c          untransformed Ritz values, the untransformed error estimates of 
-c          the Ritz values, the upper triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by zneupd .
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): Not used
-c          IPNTR(11): pointer to the NCV corresponding error estimates.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     zneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine csheqr
-c                could not be reordered by LAPACK routine ztrsen .
-c                Re-enter subroutine zneupd  with IPARAM(5)=NCV and
-c                increase the size of the array D to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation.
-c                This should never happened.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine ztrevc .
-c          = -10: IPARAM(7) must be 1,2,3
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: ZNAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: ZNEUPD  got a different count of the number of converged
-c                 Ritz values than ZNAUPD  got.  This indicates the user
-c                 probably made an error in passing data from ZNAUPD  to
-c                 ZNEUPD  or that the data was modified before entering
-c                 ZNEUPD 
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B. Nour-Omid, B. N. Parlett, T. Ericsson and P. S. Jensen,
-c     "How to Implement the Spectral Transformation", Math Comp.,
-c     Vol. 48, No. 178, April, 1987 pp. 664-673. 
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     zmout    ARPACK utility routine that prints matrices
-c     zvout    ARPACK utility routine that prints vectors.
-c     zgeqr2   LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     zlacpy   LAPACK matrix copy routine.
-c     zlahqr   LAPACK routine that computes the Schur form of a
-c             upper Hessenberg matrix.
-c     zlaset   LAPACK matrix initialization routine.
-c     ztrevc   LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form.
-c     ztrsen   LAPACK routine that re-orders the Schur form.
-c     zunm2r   LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     dlamch   LAPACK routine that determines machine constants.
-c     ztrmm    Level 3 BLAS matrix times an upper triangular matrix.
-c     zgeru    Level 2 BLAS rank one update to a matrix.
-c     zcopy    Level 1 BLAS that copies one vector to another .
-c     zscal    Level 1 BLAS that scales a vector.
-c     zdscal   Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2   Level 1 BLAS that computes the norm of a complex vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented. 
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .true. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c       transpose( V(:,1:IPARAM(5)) ) * V(:,1:IPARAM(5)) = I
-c     are approximately satisfied.
-c     Here T is the leading submatrix of order IPARAM(5) of the 
-c     upper triangular matrix stored workl(ipntr(12)). 
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas 
-c     Dept. of Computational & 
-c     Applied Mathematics 
-c     Rice University 
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine zneupd (rvec , howmny, select, d     ,
-     &                   z    , ldz   , sigma , workev,
-     &                   bmat , n     , which , nev   ,
-     &                   tol  , resid , ncv   , v     ,
-     &                   ldv  , iparam, ipntr , workd ,
-     &                   workl, lworkl, rwork , info  )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Complex*16      
-     &           sigma
-      Double precision  
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Double precision 
-     &           rwork(ncv)
-      Complex*16 
-     &           d(nev)     , resid(n)     , v(ldv,ncv),
-     &           z(ldz, nev), 
-     &           workd(3*n) , workl(lworkl), workev(2*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16 
-     &           one, zero
-      parameter  (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds, iheig , nconv ,
-     &           invsub, iuptri, iwev  , j    , ldh   , ldq   ,
-     &           mode  , msglvl, ritz  , wr   , k     , irz   ,
-     &           ibd   , outncv, iq    , np   , numcnv, jj    ,
-     &           ishift, nconv2
-      Complex*16 
-     &           rnorm, temp, vl(1)
-      Double precision 
-     &           conds, sep, rtemp, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy  , zgeru , zgeqr2 , zlacpy , zmout ,
-     &           zunm2r , ztrmm , zvout , ivout,
-     &           zlahqr 
-c  
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dznrm2 , dlamch , dlapy2 
-      external   dznrm2 , dlamch , dlapy2 
-c
-      Complex*16 
-     &           zdotc 
-      external   zdotc 
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mceupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %-------------------------------%
-c     | Quick return                  |
-c     | Check for incompatible input  |
-c     %-------------------------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 4*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, WORKEV, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values            |
-c     | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds     |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by ZNEUPD .                 |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed |
-c     |                                      Ritz values.         |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                                      error bounds of      |
-c     |                                      the Ritz values      |
-c     | workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper |
-c     |                                      triangular matrix    |
-c     |                                      for H.               |
-c     | workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the    |
-c     |                                      associated matrix    |
-c     |                                      representation of    |
-c     |                                      the invariant        |
-c     |                                      subspace for H.      |
-c     | GRAND total of NCV * ( 3 * NCV + 4 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      iq     = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheig  = bounds + ldh
-      ihbds  = iheig  + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheig
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wr = 1
-      iwev = wr + ncv
-c
-c     %-----------------------------------------%
-c     | irz points to the Ritz values computed  |
-c     |     by _neigh before exiting _naup2.    |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irz = ipntr(14) + ncv*ncv
-      ibd = irz + ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call zvout (logfil, ncv, workl(irz), ndigit,
-     &   '_neupd: Ritz values passed in from _NAUPD.')
-         call zvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(ibd)       |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call zngets (ishift, which     , nev          ,
-     &                np    , workl(irz), workl(bounds))
-c
-         if (msglvl .gt. 2) then
-            call zvout  (logfil, ncv, workl(irz), ndigit,
-     &      '_neupd: Ritz values after calling _NGETS.')
-            call zvout  (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            rtemp = max(eps23,
-     &                 dlapy2  ( dble (workl(irz+ncv-j)),
-     &                          dimag (workl(irz+ncv-j)) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          dlapy2 ( dble (workl(ibd+jj-1)),
-     &          dimag (workl(ibd+jj-1)) )
-     &          .le. tol*rtemp) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-------------------------------------------------------%
-c        | Call LAPACK routine zlahqr  to compute the Schur form |
-c        | of the upper Hessenberg matrix returned by ZNAUPD .   |
-c        | Make a copy of the upper Hessenberg matrix.           |
-c        | Initialize the Schur vector matrix Q to the identity. |
-c        %-------------------------------------------------------%
-c
-         call zcopy (ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call zlaset ('All', ncv, ncv          , 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call zlahqr (.true., .true.       , ncv          , 
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheig) , 1            ,
-     &                ncv   , workl(invsub), ldq          ,
-     &                ierr)
-         call zcopy (ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call zvout  (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H')
-            call zvout  (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call zmout  (logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------%
-c           | Reorder the computed upper triangular matrix. |
-c           %-----------------------------------------------%
-c
-            call ztrsen ('None'       , 'V'          , select      ,
-     &                   ncv          , workl(iuptri), ldh         ,
-     &                   workl(invsub), ldq          , workl(iheig),
-     &                   nconv2       , conds        , sep         , 
-     &                   workev       , ncv          , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call zvout  (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call zmout (logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &              '_neupd: Triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------------%
-c        | Copy the last row of the Schur basis matrix |
-c        | to workl(ihbds).  This vector will be used  |
-c        | to compute the Ritz estimates of converged  |
-c        | Ritz values.                                |
-c        %---------------------------------------------%
-c
-         call zcopy (ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c 
-c        %--------------------------------------------%
-c        | Place the computed eigenvalues of H into D |
-c        | if a spectral transformation was not used. |
-c        %--------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call zcopy (nconv, workl(iheig), 1, d, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call zgeqr2 (ncv , nconv , workl(invsub),
-     &                ldq , workev, workev(ncv+1),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q using zunm2r .                    |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | * Postmultiply Z by R.                                 |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(iheig). The first NCONV       | 
-c        | columns of V are now approximate Schur vectors         |
-c        | associated with the upper triangular matrix of order   |
-c        | NCONV in workl(iuptri).                                |
-c        %--------------------------------------------------------%
-c
-         call zunm2r ('Right', 'Notranspose', n            ,
-     &                ncv    , nconv        , workl(invsub),
-     &                ldq    , workev       , v            ,
-     &                ldv    , workd(n+1)   , ierr)
-         call zlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | triangular form of workl(iuptri,ldq).             |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones.          |
-c           %---------------------------------------------------%
-c
-            if ( dble ( workl(invsub+(j-1)*ldq+j-1) ) .lt. 
-     &                  dble (zero) ) then
-               call zscal (nconv, -one, workl(iuptri+j-1), ldq)
-               call zscal (nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call ztrevc ('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , rwork        , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | ztrevc  returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1.                                   |
-c           %------------------------------------------------%
-c
-            do 40 j=1, nconv
-                  rtemp = dznrm2 (ncv, workl(invsub+(j-1)*ldq), 1)
-                  rtemp = dble (one) / rtemp
-                  call zdscal  ( ncv, rtemp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-c                 %------------------------------------------%
-c                 | Ritz estimates can be obtained by taking |
-c                 | the inner product of the last row of the |
-c                 | Schur basis of H with eigenvectors of T. |
-c                 | Note that the eigenvector matrix of T is |
-c                 | upper triangular, thus the length of the |
-c                 | inner product can be set to j.           |
-c                 %------------------------------------------%
-c 
-                  workev(j) = zdotc (j, workl(ihbds), 1,
-     &                        workl(invsub+(j-1)*ldq), 1)
- 40         continue
-c
-            if (msglvl .gt. 2) then
-               call zcopy (nconv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call zvout  (logfil, nconv, workl(ihbds), ndigit,
-     &            '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call zmout (logfil       , ncv, ncv   ,
-     &                        workl(invsub), ldq, ndigit,
-     &               '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c 
-            call zcopy (nconv, workev, 1, workl(ihbds), 1)
-c
-c           %----------------------------------------------%
-c           | The eigenvector matrix Q of T is triangular. |
-c           | Form Z*Q.                                    |
-c           %----------------------------------------------%
-c
-            call ztrmm ('Right'   , 'Upper'      , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-         end if 
-c
-      else
-c
-c        %--------------------------------------------------%
-c        | An approximate invariant subspace is not needed. |
-c        | Place the Ritz values computed ZNAUPD  into D.    |
-c        %--------------------------------------------------%
-c
-         call zcopy (nconv, workl(ritz), 1, d, 1)
-         call zcopy (nconv, workl(ritz), 1, workl(iheig), 1)
-         call zcopy (nconv, workl(bounds), 1, workl(ihbds), 1)
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call zscal (ncv, rnorm, workl(ihbds), 1)
-c      
-      else
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (rvec) 
-     &      call zscal (ncv, rnorm, workl(ihbds), 1)
-c    
-         do 50 k=1, ncv
-            temp = workl(iheig+k-1)
-            workl(ihbds+k-1) = workl(ihbds+k-1) / temp / temp
-  50     continue
-c  
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | *  Transform the Ritz values back to the original system. |
-c     |    For TYPE = 'SHIFTI' the transformation is              |
-c     |             lambda = 1/theta + sigma                      |
-c     | NOTES:                                                    |
-c     | *The Ritz vectors are not affected by the transformation. |
-c     %-----------------------------------------------------------%
-c    
-      if (type .eq. 'SHIFTI') then
-         do 60 k=1, nconv
-            d(k) = one / workl(iheig+k-1) + sigma
-  60     continue
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call zvout  (logfil, nconv, d, ndigit,
-     &     '_neupd: Untransformed Ritz values.')
-         call zvout  (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Ritz estimates of the untransformed Ritz values.')
-      else if ( msglvl .gt. 1) then
-         call zvout  (logfil, nconv, d, ndigit,
-     &     '_neupd: Converged Ritz values.')
-         call zvout  (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3. See reference 3.                  |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta.                           |
-c        %------------------------------------------------%
-c
-         do 100 j=1, nconv
-            if (workl(iheig+j-1) .ne. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheig+j-1)
-            endif
- 100     continue
-
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call zgeru  (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of zneupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zngets.f b/libcruft/arpack/src/zngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/zngets.f
+++ /dev/null
@@ -1,178 +0,0 @@
-c\BeginDoc
-c
-c\Name: zngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call zngets
-c      ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest REAL part.
-c          'SR' -> want the KEV eigenvalues of smallest REAL part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV     Integer.  (INPUT)
-c          The number of desired eigenvalues.
-c
-c  NP      Integer.  (INPUT)
-c          The number of shifts to compute.
-c
-c  RITZ    Complex*16 array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Complex*16 array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\Routines called:
-c     zsortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zvout   ARPACK utility routine that prints vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. This routine does not keep complex conjugate pairs of
-c        eigenvalues together.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zngets ( ishift, which, kev, np, ritz, bounds)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           bounds(kev+np), ritz(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zvout,  zsortc, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mcgets
-c 
-      call zsortc (which, .true., kev+np, ritz, bounds)
-c     
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine znapps.                     |
-c        | Be careful and use 'SM' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call zsortc ( 'SM', .true., np, bounds, ritz )
-c
-      end if
-c     
-      call arscnd (t1)
-      tcgets = tcgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call zvout (logfil, kev+np, ritz, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix ')
-         call zvout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of zngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/zsortc.f b/libcruft/arpack/src/zsortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/zsortc.f
+++ /dev/null
@@ -1,322 +0,0 @@
-c\BeginDoc
-c
-c\Name: zsortc
-c
-c\Description:
-c  Sorts the Complex*16 array in X into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  Double precision  array Y. 
-c
-c\Usage:
-c  call zsortc
-c     ( WHICH, APPLY, N, X, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort X into increasing order of magnitude.
-c          'SM' -> sort X into decreasing order of magnitude.
-c          'LR' -> sort X with real(X) in increasing algebraic order 
-c          'SR' -> sort X with real(X) in decreasing algebraic order
-c          'LI' -> sort X with imag(X) in increasing algebraic order
-c          'SI' -> sort X with imag(X) in decreasing algebraic order
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X       Complex*16 array of length N.  (INPUT/OUTPUT)
-c          This is the array to be sorted.
-c
-c  Y       Complex*16 array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c     Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zsortc (which, apply, n, x, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16     
-     &           x(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Complex*16     
-     &           temp
-      Double precision 
-     &           temp1, temp2
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2
-c
-c     %--------------------%
-c     | Intrinsic Functions |
-c     %--------------------%
-       Intrinsic
-     &           dble, dimag
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into increasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = dlapy2(dble(x(j)),dimag(x(j)))
-            temp2 = dlapy2(dble(x(j+igap)),dimag(x(j+igap)))
-c
-            if (temp1.gt.temp2) then
-                temp = x(j)
-                x(j) = x(j+igap)
-                x(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into decreasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = dlapy2(dble(x(j)),dimag(x(j)))
-            temp2 = dlapy2(dble(x(j+igap)),dimag(x(j+igap)))
-c
-            if (temp1.lt.temp2) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (dble(x(j)).gt.dble(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (dble(x(j)).lt.dble(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %--------------------------------------------%
-c        | Sort XIMAG into increasing algebraic order |
-c        %--------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (dimag(x(j)).gt.dimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %---------------------------------------------%
-c        | Sort XIMAG into decreasing algebraic order  |
-c        %---------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (dimag(x(j)).lt.dimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zsortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zstatn.f b/libcruft/arpack/src/zstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/zstatn.f
+++ /dev/null
@@ -1,51 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for complex nonsymmetric Arnoldi code.      |
-c     %---------------------------------------------%
-
-      subroutine zstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tcaupd = 0.0D+0
-      tcaup2 = 0.0D+0
-      tcaitr = 0.0D+0
-      tceigh = 0.0D+0
-      tcgets = 0.0D+0
-      tcapps = 0.0D+0
-      tcconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
- 
-      return
-c
-c     %---------------%
-c     | End of zstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/util/cmout.f b/libcruft/arpack/util/cmout.f
deleted file mode 100644
--- a/libcruft/arpack/util/cmout.f
+++ /dev/null
@@ -1,250 +0,0 @@
-*
-*  Routine:    CMOUT
-*
-*  Purpose:    Complex matrix output routine.
-*
-*  Usage:      CALL CMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Complex M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*\SCCS Information: @(#)
-* FILE: cmout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE CMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      Complex
-     &                   A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9984 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE 
-                     WRITE( LOUT, 9983 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 80 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9982 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF 
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N
-               WRITE( LOUT, 9995 ) ICOL, K1
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, A( I, K1 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  IF ((K1+3).LE.N) THEN 
-                     WRITE( LOUT, 9974 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.1) THEN
-                     WRITE( LOUT, 9964 )I, ( A( I, J ), J = k1, K2 )
-                  ELSE IF ((K1+3-N).EQ.2) THEN
-                     WRITE( LOUT, 9954 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.3) THEN
-                     WRITE( LOUT, 9944 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+ 2)
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9973 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9963 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9953 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 160 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-                  WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9972 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9962 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9952 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  IF ((K1+1).LE.N) THEN
-                     WRITE( LOUT, 9971 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9961 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 11X, 4( 9X, 3A1, I4, 9X ) )
- 9997 FORMAT( 10X, 4( 11X, 3A1, I4, 11X ) )
- 9996 FORMAT( 10X, 3( 13X, 3A1, I4, 13X ) )
- 9995 FORMAT( 12X, 2( 18x, 3A1, I4, 18X ) ) 
-*
-*========================================================
-*              FORMAT FOR 72 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGITS
-* 
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E10.3,',',E10.3,')  ') )
- 9984 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E12.5,',',E12.5,')  ') )
- 9983 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E14.7,',',E14.7,')  ') )
- 9982 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E20.13,',',E20.13,')') )
- 9990 FORMAT( 1X, ' ' )
-*
-*
-*========================================================
-*              FORMAT FOR 132 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGIT
-*
- 9974 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,4('(',E10.3,',',E10.3,')  ') )
- 9964 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E10.3,',',E10.3,')  ') )
- 9954 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E10.3,',',E10.3,')  ') )
- 9944 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGIT
-*
- 9973 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E12.5,',',E12.5,')  ') )
- 9963 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E12.5,',',E12.5,')  ') )
- 9953 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGIT
-*
- 9972 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E14.7,',',E14.7,')  ') )
- 9962 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E14.7,',',E14.7,')  ') )
- 9952 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGIT
-*
- 9971 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E20.13,',',E20.13,
-     &        ')  '))
- 9961 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E20.13,',',E20.13,
-     &        ')  '))
-
-*
-*
-*
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/cvout.f b/libcruft/arpack/util/cvout.f
deleted file mode 100644
--- a/libcruft/arpack/util/cvout.f
+++ /dev/null
@@ -1,240 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c\SCCS Information: @(#)
-c FILE: cvout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-c
-*-----------------------------------------------------------------------
-*  Routine:    CVOUT
-*
-*  Purpose:    Complex vector output routine.
-*
-*  Usage:      CALL CVOUT (LOUT, N, CX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array CX.  (Input)
-*     CX     - Complex array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array CX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE CVOUT( LOUT, N, CX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      Complex
-     &                   CX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9998 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9997 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9988 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9987 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 50 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9978 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9977 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N
-               WRITE( LOUT, 9968 )K1, K1, CX( I )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 4 
-               K2 = MIN0( N, K1+3 )
-               IF ((K1+3).LE.N) THEN
-                  WRITE( LOUT, 9958 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9957 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9956 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9955 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9948 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9947 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9946 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 90 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9938 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9937 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9936 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9928 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9927 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
-*
-*=======================================================================
-*                   FORMAT FOR 72 COLUMNS
-*=======================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E10.3,',',E10.3,')  ') ) 
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-* 
- 9988 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E12.5,',',E12.5,')  ') )
- 9987 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9978 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E14.7,',',E14.7,')  ') )
- 9977 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9968 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E20.13,',',E20.13,')  ') ) 
-*
-*=========================================================================
-*                   FORMAT FOR 132 COLUMNS
-*=========================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9958 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,4('(',E10.3,',',E10.3,')  ') )
- 9957 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E10.3,',',E10.3,')  ') )
- 9956 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E10.3,',',E10.3,')  ') )
- 9955 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9948 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E12.5,',',E12.5,')  ') )
- 9947 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E12.5,',',E12.5,')  ') )
- 9946 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9938 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E14.7,',',E14.7,')  ') )
- 9937 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E14.7,',',E14.7,')  ') )
- 9936 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9928 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E20.13,',',E20.13,')  ') )
- 9927 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E20.13,',',E20.13,')  ') )
-*
-*
-* 
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/arpack/util/dmout.f b/libcruft/arpack/util/dmout.f
deleted file mode 100644
--- a/libcruft/arpack/util/dmout.f
+++ /dev/null
@@ -1,167 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    DMOUT
-*
-*  Purpose:    Real matrix output routine.
-*
-*  Usage:      CALL DMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Real M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE DMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-*     .. Scalar Arguments ..
-      CHARACTER*( * )    IFMT
-      INTEGER            IDIGIT, LDA, LOUT, M, N
-*     ..
-*     .. Array Arguments ..
-      DOUBLE PRECISION   A( LDA, * )
-*     ..
-*     .. Local Scalars ..
-      CHARACTER*80       LINE
-      INTEGER            I, J, K1, K2, LLL, NDIGIT
-*     ..
-*     .. Local Arrays ..
-      CHARACTER          ICOL( 3 )
-*     ..
-*     .. Intrinsic Functions ..
-      INTRINSIC          LEN, MIN, MIN0
-*     ..
-*     .. Data statements ..
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ..
-*     .. Executable Statements ..
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, FMT = 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A, / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  WRITE( LOUT, FMT = 9994 )I, ( A( I, J ), J = K1, K2 )
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, FMT = 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  WRITE( LOUT, FMT = 9993 )I, ( A( I, J ), J = K1, K2 )
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, FMT = 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  WRITE( LOUT, FMT = 9992 )I, ( A( I, J ), J = K1, K2 )
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, FMT = 9995 )( ICOL, I, I = K1, K2 )
-               DO 90 I = 1, M
-                  WRITE( LOUT, FMT = 9991 )I, ( A( I, J ), J = K1, K2 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, FMT = 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  WRITE( LOUT, FMT = 9994 )I, ( A( I, J ), J = K1, K2 )
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, FMT = 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  WRITE( LOUT, FMT = 9993 )I, ( A( I, J ), J = K1, K2 )
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 160 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, FMT = 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  WRITE( LOUT, FMT = 9992 )I, ( A( I, J ), J = K1, K2 )
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  WRITE( LOUT, FMT = 9991 )I, ( A( I, J ), J = K1, K2 )
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, FMT = 9990 )
-*
- 9998 FORMAT( 10X, 10( 4X, 3A1, I4, 1X ) )
- 9997 FORMAT( 10X, 8( 5X, 3A1, I4, 2X ) )
- 9996 FORMAT( 10X, 6( 7X, 3A1, I4, 4X ) )
- 9995 FORMAT( 10X, 5( 9X, 3A1, I4, 6X ) )
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 10D12.3 )
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 8D14.5 )
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 6D18.9 )
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 5D22.13 )
- 9990 FORMAT( 1X, ' ' )
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/dvout.f b/libcruft/arpack/util/dvout.f
deleted file mode 100644
--- a/libcruft/arpack/util/dvout.f
+++ /dev/null
@@ -1,122 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    DVOUT
-*
-*  Purpose:    Real vector output routine.
-*
-*  Usage:      CALL DVOUT (LOUT, N, SX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array SX.  (Input)
-*     SX     - Real array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array SX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE DVOUT( LOUT, N, SX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-*     .. Scalar Arguments ..
-      CHARACTER*( * )    IFMT
-      INTEGER            IDIGIT, LOUT, N
-*     ..
-*     .. Array Arguments ..
-      DOUBLE PRECISION   SX( * )
-*     ..
-*     .. Local Scalars ..
-      CHARACTER*80       LINE
-      INTEGER            I, K1, K2, LLL, NDIGIT
-*     ..
-*     .. Intrinsic Functions ..
-      INTRINSIC          LEN, MIN, MIN0
-*     ..
-*     .. Executable Statements ..
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, FMT = 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A, / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, FMT = 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 50 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, FMT = 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, FMT = 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, FMT = 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, FMT = 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 90 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, FMT = 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, FMT = 9994 )
-      RETURN
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1P, 10D12.3 )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 8D14.5 )
- 9996 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 6D18.9 )
- 9995 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 5D24.13 )
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/arpack/util/icnteq.f b/libcruft/arpack/util/icnteq.f
deleted file mode 100644
--- a/libcruft/arpack/util/icnteq.f
+++ /dev/null
@@ -1,18 +0,0 @@
-c
-c-----------------------------------------------------------------------
-c
-c     Count the number of elements equal to a specified integer value.
-c
-      integer function icnteq (n, array, value)
-c
-      integer    n, value
-      integer    array(*)
-c
-      k = 0
-      do 10 i = 1, n
-         if (array(i) .eq. value) k = k + 1
-   10 continue
-      icnteq = k
-c
-      return
-      end
diff --git a/libcruft/arpack/util/icopy.f b/libcruft/arpack/util/icopy.f
deleted file mode 100644
--- a/libcruft/arpack/util/icopy.f
+++ /dev/null
@@ -1,77 +0,0 @@
-*--------------------------------------------------------------------
-*\Documentation
-*
-*\Name: ICOPY
-*
-*\Description:
-*     ICOPY copies an integer vector lx to an integer vector ly.
-*
-*\Usage:
-*     call icopy ( n, lx, inc, ly, incy )
-*
-*\Arguments:
-*    n        integer (input)
-*             On entry, n is the number of elements of lx to be
-c             copied to ly.
-*
-*    lx       integer array (input)
-*             On entry, lx is the integer vector to be copied.
-*
-*    incx     integer (input)
-*             On entry, incx is the increment between elements of lx.
-*
-*    ly       integer array (input)
-*             On exit, ly is the integer vector that contains the
-*             copy of lx.
-*
-*    incy     integer (input)
-*             On entry, incy is the increment between elements of ly.
-*
-*\Enddoc
-*
-*--------------------------------------------------------------------
-*
-      subroutine icopy( n, lx, incx, ly, incy )
-*
-*     ----------------------------
-*     Specifications for arguments
-*     ----------------------------
-      integer    incx, incy, n
-      integer    lx( 1 ), ly( 1 )
-*
-*     ----------------------------------
-*     Specifications for local variables
-*     ----------------------------------
-      integer           i, ix, iy
-*
-*     --------------------------
-*     First executable statement
-*     --------------------------
-      if( n.le.0 )
-     $   return
-      if( incx.eq.1 .and. incy.eq.1 )
-     $   go to 20
-c
-c.....code for unequal increments or equal increments
-c     not equal to 1
-      ix = 1
-      iy = 1
-      if( incx.lt.0 )
-     $   ix = ( -n+1 )*incx + 1
-      if( incy.lt.0 )
-     $   iy = ( -n+1 )*incy + 1
-      do 10 i = 1, n
-         ly( iy ) = lx( ix )
-         ix = ix + incx
-         iy = iy + incy
-   10 continue
-      return
-c
-c.....code for both increments equal to 1
-c
-   20 continue
-      do 30 i = 1, n
-         ly( i ) = lx( i )
-   30 continue
-      return
-      end
diff --git a/libcruft/arpack/util/iset.f b/libcruft/arpack/util/iset.f
deleted file mode 100644
--- a/libcruft/arpack/util/iset.f
+++ /dev/null
@@ -1,16 +0,0 @@
-c
-c-----------------------------------------------------------------------
-c
-c     Only work with increment equal to 1 right now.
-c
-      subroutine iset (n, value, array, inc)
-c
-      integer    n, value, inc
-      integer    array(*)
-c
-      do 10 i = 1, n
-         array(i) = value
-   10 continue
-c
-      return
-      end
diff --git a/libcruft/arpack/util/iswap.f b/libcruft/arpack/util/iswap.f
deleted file mode 100644
--- a/libcruft/arpack/util/iswap.f
+++ /dev/null
@@ -1,55 +0,0 @@
-      subroutine iswap (n,sx,incx,sy,incy)
-c
-c     interchanges two vectors.
-c     uses unrolled loops for increments equal to 1.
-c     jack dongarra, linpack, 3/11/78.
-c
-      integer sx(1),sy(1),stemp
-      integer i,incx,incy,ix,iy,m,mp1,n
-c
-      if(n.le.0)return
-      if(incx.eq.1.and.incy.eq.1)go to 20
-c
-c       code for unequal increments or equal increments not equal
-c         to 1
-c
-      ix = 1
-      iy = 1
-      if(incx.lt.0)ix = (-n+1)*incx + 1
-      if(incy.lt.0)iy = (-n+1)*incy + 1
-      do 10 i = 1,n
-        stemp = sx(ix)
-        sx(ix) = sy(iy)
-        sy(iy) = stemp
-        ix = ix + incx
-        iy = iy + incy
-   10 continue
-      return
-c
-c       code for both increments equal to 1
-c
-c
-c       clean-up loop
-c
-   20 m = mod(n,3)
-      if( m .eq. 0 ) go to 40
-      do 30 i = 1,m
-        stemp = sx(i)
-        sx(i) = sy(i)
-        sy(i) = stemp
-   30 continue
-      if( n .lt. 3 ) return
-   40 mp1 = m + 1
-      do 50 i = mp1,n,3
-        stemp = sx(i)
-        sx(i) = sy(i)
-        sy(i) = stemp
-        stemp = sx(i + 1)
-        sx(i + 1) = sy(i + 1)
-        sy(i + 1) = stemp
-        stemp = sx(i + 2)
-        sx(i + 2) = sy(i + 2)
-        sy(i + 2) = stemp
-   50 continue
-      return
-      end
diff --git a/libcruft/arpack/util/ivout.f b/libcruft/arpack/util/ivout.f
deleted file mode 100644
--- a/libcruft/arpack/util/ivout.f
+++ /dev/null
@@ -1,120 +0,0 @@
-C-----------------------------------------------------------------------
-C  Routine:    IVOUT
-C
-C  Purpose:    Integer vector output routine.
-C
-C  Usage:      CALL IVOUT (LOUT, N, IX, IDIGIT, IFMT)
-C
-C  Arguments
-C     N      - Length of array IX. (Input)
-C     IX     - Integer array to be printed. (Input)
-C     IFMT   - Format to be used in printing array IX. (Input)
-C     IDIGIT - Print up to ABS(IDIGIT) decimal digits / number. (Input)
-C              If IDIGIT .LT. 0, printing is done with 72 columns.
-C              If IDIGIT .GT. 0, printing is done with 132 columns.
-C
-C-----------------------------------------------------------------------
-C
-      SUBROUTINE IVOUT (LOUT, N, IX, IDIGIT, IFMT)
-C     ...
-C     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER    IX(*), N, IDIGIT, LOUT
-      CHARACTER  IFMT*(*)
-C     ...
-C     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER    I, NDIGIT, K1, K2, LLL
-      CHARACTER*80 LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-C
-      LLL = MIN ( LEN ( IFMT ), 80 )
-      DO 1 I = 1, LLL
-          LINE(I:I) = '-'
-    1 CONTINUE
-C
-      DO 2 I = LLL+1, 80
-          LINE(I:I) = ' '
-    2 CONTINUE
-C
-      WRITE ( LOUT, 2000 ) IFMT, LINE(1:LLL)
- 2000 FORMAT ( /1X, A  /1X, A )
-C
-      IF (N .LE. 0) RETURN
-      NDIGIT = IDIGIT
-      IF (IDIGIT .EQ. 0) NDIGIT = 4
-C
-C=======================================================================
-C             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-C=======================================================================
-C
-      IF (IDIGIT .LT. 0) THEN
-C
-      NDIGIT = -IDIGIT
-      IF (NDIGIT .LE. 4) THEN
-         DO 10 K1 = 1, N, 10
-            K2 = MIN0(N,K1+9)
-            WRITE(LOUT,1000) K1,K2,(IX(I),I=K1,K2)
-   10    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 6) THEN
-         DO 30 K1 = 1, N, 7
-            K2 = MIN0(N,K1+6)
-            WRITE(LOUT,1001) K1,K2,(IX(I),I=K1,K2)
-   30    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 10) THEN
-         DO 50 K1 = 1, N, 5
-            K2 = MIN0(N,K1+4)
-            WRITE(LOUT,1002) K1,K2,(IX(I),I=K1,K2)
-   50    CONTINUE
-C
-      ELSE
-         DO 70 K1 = 1, N, 3
-            K2 = MIN0(N,K1+2)
-            WRITE(LOUT,1003) K1,K2,(IX(I),I=K1,K2)
-   70    CONTINUE
-      END IF
-C
-C=======================================================================
-C             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-C=======================================================================
-C
-      ELSE
-C
-      IF (NDIGIT .LE. 4) THEN
-         DO 90 K1 = 1, N, 20
-            K2 = MIN0(N,K1+19)
-            WRITE(LOUT,1000) K1,K2,(IX(I),I=K1,K2)
-   90    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 6) THEN
-         DO 110 K1 = 1, N, 15
-            K2 = MIN0(N,K1+14)
-            WRITE(LOUT,1001) K1,K2,(IX(I),I=K1,K2)
-  110    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 10) THEN
-         DO 130 K1 = 1, N, 10
-            K2 = MIN0(N,K1+9)
-            WRITE(LOUT,1002) K1,K2,(IX(I),I=K1,K2)
-  130    CONTINUE
-C
-      ELSE
-         DO 150 K1 = 1, N, 7
-            K2 = MIN0(N,K1+6)
-            WRITE(LOUT,1003) K1,K2,(IX(I),I=K1,K2)
-  150    CONTINUE
-      END IF
-      END IF
-      WRITE (LOUT,1004)
-C
- 1000 FORMAT(1X,I4,' - ',I4,':',20(1X,I5))
- 1001 FORMAT(1X,I4,' - ',I4,':',15(1X,I7))
- 1002 FORMAT(1X,I4,' - ',I4,':',10(1X,I11))
- 1003 FORMAT(1X,I4,' - ',I4,':',7(1X,I15))
- 1004 FORMAT(1X,' ')
-C
-      RETURN
-      END
diff --git a/libcruft/arpack/util/second.f b/libcruft/arpack/util/second.f
deleted file mode 100644
--- a/libcruft/arpack/util/second.f
+++ /dev/null
@@ -1,36 +0,0 @@
-      SUBROUTINE ARSCND( T )
-*
-      REAL       T
-*
-*  -- LAPACK auxiliary routine (preliminary version) --
-*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
-*     Courant Institute, Argonne National Lab, and Rice University
-*     July 26, 1991
-*
-*  Purpose
-*  =======
-*
-*  SECOND returns the user time for a process in arscnds.
-*  This version gets the time from the system function ETIME.
-*
-*     .. Local Scalars ..
-      REAL               T1
-*     ..
-*     .. Local Arrays ..
-      REAL               TARRAY( 2 )
-*     ..
-*     .. External Functions ..
-      REAL               ETIME
-      INTRINSIC          ETIME
-*     ..
-*     .. Executable Statements ..
-*
-
-      T1 = ETIME( TARRAY )
-      T  = TARRAY( 1 )
-
-      RETURN
-*
-*     End of ARSCND
-*
-      END
diff --git a/libcruft/arpack/util/smout.f b/libcruft/arpack/util/smout.f
deleted file mode 100644
--- a/libcruft/arpack/util/smout.f
+++ /dev/null
@@ -1,157 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    SMOUT
-*
-*  Purpose:    Real matrix output routine.
-*
-*  Usage:      CALL SMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Real M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE SMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      REAL               A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, ( A( I, J ), J = K1, K2 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 160 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  WRITE( LOUT, 9991 )I, ( A( I, J ), J = K1, K2 )
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 10X, 10( 4X, 3A1, I4, 1X ) )
- 9997 FORMAT( 10X, 8( 5X, 3A1, I4, 2X ) )
- 9996 FORMAT( 10X, 6( 7X, 3A1, I4, 4X ) )
- 9995 FORMAT( 10X, 5( 9X, 3A1, I4, 6X ) )
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P10E12.3 )
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P8E14.5 )
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P6E18.9 )
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P5E22.13 )
- 9990 FORMAT( 1X, ' ' )
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/svout.f b/libcruft/arpack/util/svout.f
deleted file mode 100644
--- a/libcruft/arpack/util/svout.f
+++ /dev/null
@@ -1,112 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    SVOUT
-*
-*  Purpose:    Real vector output routine.
-*
-*  Usage:      CALL SVOUT (LOUT, N, SX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array SX.  (Input)
-*     SX     - Real array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array SX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE SVOUT( LOUT, N, SX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      REAL               SX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 50 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 90 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1P10E12.3 )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P8E14.5 )
- 9996 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P6E18.9 )
- 9995 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P5E24.13 )
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/arpack/util/zmout.f b/libcruft/arpack/util/zmout.f
deleted file mode 100644
--- a/libcruft/arpack/util/zmout.f
+++ /dev/null
@@ -1,250 +0,0 @@
-*
-*  Routine:    ZMOUT
-*
-*  Purpose:    Complex*16 matrix output routine.
-*
-*  Usage:      CALL ZMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Complex*16 M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*\SCCS Information: @(#)
-* FILE: zmout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE ZMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      Complex*16
-     &                   A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9984 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE 
-                     WRITE( LOUT, 9983 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 80 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9982 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF 
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N
-               WRITE( LOUT, 9995 ) ICOL, K1
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, A( I, K1 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  IF ((K1+3).LE.N) THEN 
-                     WRITE( LOUT, 9974 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.1) THEN
-                     WRITE( LOUT, 9964 )I, ( A( I, J ), J = k1, K2 )
-                  ELSE IF ((K1+3-N).EQ.2) THEN
-                     WRITE( LOUT, 9954 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.3) THEN
-                     WRITE( LOUT, 9944 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+ 2)
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9973 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9963 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9953 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 160 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-                  WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9972 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9962 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9952 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  IF ((K1+1).LE.N) THEN
-                     WRITE( LOUT, 9971 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9961 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 11X, 4( 9X, 3A1, I4, 9X ) )
- 9997 FORMAT( 10X, 4( 11X, 3A1, I4, 11X ) )
- 9996 FORMAT( 10X, 3( 13X, 3A1, I4, 13X ) )
- 9995 FORMAT( 12X, 2( 18x, 3A1, I4, 18X ) ) 
-*
-*========================================================
-*              FORMAT FOR 72 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGITS
-* 
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D10.3,',',D10.3,')  ') )
- 9984 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D12.5,',',D12.5,')  ') )
- 9983 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D14.7,',',D14.7,')  ') )
- 9982 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D20.13,',',D20.13,')') )
- 9990 FORMAT( 1X, ' ' )
-*
-*
-*========================================================
-*              FORMAT FOR 132 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGIT
-*
- 9974 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,4('(',D10.3,',',D10.3,')  ') )
- 9964 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D10.3,',',D10.3,')  ') )
- 9954 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D10.3,',',D10.3,')  ') )
- 9944 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGIT
-*
- 9973 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D12.5,',',D12.5,')  ') )
- 9963 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D12.5,',',D12.5,')  ') )
- 9953 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGIT
-*
- 9972 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D14.7,',',D14.7,')  ') )
- 9962 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D14.7,',',D14.7,')  ') )
- 9952 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGIT
-*
- 9971 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D20.13,',',D20.13,
-     &        ')  '))
- 9961 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D20.13,',',D20.13,
-     &        ')  '))
-
-*
-*
-*
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/zvout.f b/libcruft/arpack/util/zvout.f
deleted file mode 100644
--- a/libcruft/arpack/util/zvout.f
+++ /dev/null
@@ -1,240 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c\SCCS Information: @(#)
-c FILE: zvout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-c
-*-----------------------------------------------------------------------
-*  Routine:    ZVOUT
-*
-*  Purpose:    Complex*16 vector output routine.
-*
-*  Usage:      CALL ZVOUT (LOUT, N, CX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array CX.  (Input)
-*     CX     - Complex*16 array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array CX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE ZVOUT( LOUT, N, CX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      Complex*16
-     &                   CX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9998 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9997 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9988 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9987 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 50 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9978 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9977 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N
-               WRITE( LOUT, 9968 )K1, K1, CX( I )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 4 
-               K2 = MIN0( N, K1+3 )
-               IF ((K1+3).LE.N) THEN
-                  WRITE( LOUT, 9958 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9957 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9956 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9955 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9948 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9947 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9946 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 90 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9938 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9937 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9936 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9928 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9927 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
-*
-*=======================================================================
-*                   FORMAT FOR 72 COLUMNS
-*=======================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D10.3,',',D10.3,')  ') ) 
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-* 
- 9988 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D12.5,',',D12.5,')  ') )
- 9987 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9978 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D14.7,',',D14.7,')  ') )
- 9977 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9968 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D20.13,',',D20.13,')  ') ) 
-*
-*=========================================================================
-*                   FORMAT FOR 132 COLUMNS
-*=========================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9958 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,4('(',D10.3,',',D10.3,')  ') )
- 9957 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D10.3,',',D10.3,')  ') )
- 9956 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D10.3,',',D10.3,')  ') )
- 9955 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9948 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D12.5,',',D12.5,')  ') )
- 9947 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D12.5,',',D12.5,')  ') )
- 9946 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9938 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D14.7,',',D14.7,')  ') )
- 9937 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D14.7,',',D14.7,')  ') )
- 9936 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9928 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D20.13,',',D20.13,')  ') )
- 9927 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D20.13,',',D20.13,')  ') )
-*
-*
-* 
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/blas-xtra/cconv2.f b/libcruft/blas-xtra/cconv2.f
--- a/libcruft/blas-xtra/cconv2.f
+++ b/libcruft/blas-xtra/cconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/cdotc3.f b/libcruft/blas-xtra/cdotc3.f
--- a/libcruft/blas-xtra/cdotc3.f
+++ b/libcruft/blas-xtra/cdotc3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/cmatm3.f b/libcruft/blas-xtra/cmatm3.f
--- a/libcruft/blas-xtra/cmatm3.f
+++ b/libcruft/blas-xtra/cmatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/csconv2.f b/libcruft/blas-xtra/csconv2.f
--- a/libcruft/blas-xtra/csconv2.f
+++ b/libcruft/blas-xtra/csconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/dconv2.f b/libcruft/blas-xtra/dconv2.f
--- a/libcruft/blas-xtra/dconv2.f
+++ b/libcruft/blas-xtra/dconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/ddot3.f b/libcruft/blas-xtra/ddot3.f
--- a/libcruft/blas-xtra/ddot3.f
+++ b/libcruft/blas-xtra/ddot3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/dmatm3.f b/libcruft/blas-xtra/dmatm3.f
--- a/libcruft/blas-xtra/dmatm3.f
+++ b/libcruft/blas-xtra/dmatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/sconv2.f b/libcruft/blas-xtra/sconv2.f
--- a/libcruft/blas-xtra/sconv2.f
+++ b/libcruft/blas-xtra/sconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/sdot3.f b/libcruft/blas-xtra/sdot3.f
--- a/libcruft/blas-xtra/sdot3.f
+++ b/libcruft/blas-xtra/sdot3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/smatm3.f b/libcruft/blas-xtra/smatm3.f
--- a/libcruft/blas-xtra/smatm3.f
+++ b/libcruft/blas-xtra/smatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zconv2.f b/libcruft/blas-xtra/zconv2.f
--- a/libcruft/blas-xtra/zconv2.f
+++ b/libcruft/blas-xtra/zconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zdconv2.f b/libcruft/blas-xtra/zdconv2.f
--- a/libcruft/blas-xtra/zdconv2.f
+++ b/libcruft/blas-xtra/zdconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zdotc3.f b/libcruft/blas-xtra/zdotc3.f
--- a/libcruft/blas-xtra/zdotc3.f
+++ b/libcruft/blas-xtra/zdotc3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zmatm3.f b/libcruft/blas-xtra/zmatm3.f
--- a/libcruft/blas-xtra/zmatm3.f
+++ b/libcruft/blas-xtra/zmatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/lapack-xtra/crsf2csf.f b/libcruft/lapack-xtra/crsf2csf.f
--- a/libcruft/lapack-xtra/crsf2csf.f
+++ b/libcruft/lapack-xtra/crsf2csf.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/lapack-xtra/zrsf2csf.f b/libcruft/lapack-xtra/zrsf2csf.f
--- a/libcruft/lapack-xtra/zrsf2csf.f
+++ b/libcruft/lapack-xtra/zrsf2csf.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/misc/blaswrap.c b/libcruft/misc/blaswrap.c
--- a/libcruft/misc/blaswrap.c
+++ b/libcruft/misc/blaswrap.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Jarno Rajahalme
+Copyright (C) 2012 Jarno Rajahalme
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/cquit.c b/libcruft/misc/cquit.c
--- a/libcruft/misc/cquit.c
+++ b/libcruft/misc/cquit.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/f77-extern.cc b/libcruft/misc/f77-extern.cc
--- a/libcruft/misc/f77-extern.cc
+++ b/libcruft/misc/f77-extern.cc
@@ -1,12 +1,12 @@
 // misc-extern.cc                                     -*- C++ -*-
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/f77-fcn.c b/libcruft/misc/f77-fcn.c
--- a/libcruft/misc/f77-fcn.c
+++ b/libcruft/misc/f77-fcn.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/lo-error.c b/libcruft/misc/lo-error.c
--- a/libcruft/misc/lo-error.c
+++ b/libcruft/misc/lo-error.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/lo-error.h b/libcruft/misc/lo-error.h
--- a/libcruft/misc/lo-error.h
+++ b/libcruft/misc/lo-error.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/quit.cc b/libcruft/misc/quit.cc
--- a/libcruft/misc/quit.cc
+++ b/libcruft/misc/quit.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/quit.h b/libcruft/misc/quit.h
--- a/libcruft/misc/quit.h
+++ b/libcruft/misc/quit.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/mkf77def.in b/libcruft/mkf77def.in
--- a/libcruft/mkf77def.in
+++ b/libcruft/mkf77def.in
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 2006-2011 John W. Eaton
+# Copyright (C) 2006-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-b.cc b/liboctave/Array-b.cc
--- a/liboctave/Array-b.cc
+++ b/liboctave/Array-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-ch.cc b/liboctave/Array-ch.cc
--- a/liboctave/Array-ch.cc
+++ b/liboctave/Array-ch.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-f.cc b/liboctave/Array-f.cc
--- a/liboctave/Array-f.cc
+++ b/liboctave/Array-f.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-fC.cc b/liboctave/Array-fC.cc
--- a/liboctave/Array-fC.cc
+++ b/liboctave/Array-fC.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-idx-vec.cc b/liboctave/Array-idx-vec.cc
--- a/liboctave/Array-idx-vec.cc
+++ b/liboctave/Array-idx-vec.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-s.cc b/liboctave/Array-s.cc
--- a/liboctave/Array-s.cc
+++ b/liboctave/Array-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-str.cc b/liboctave/Array-str.cc
--- a/liboctave/Array-str.cc
+++ b/liboctave/Array-str.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-util.h b/liboctave/Array-util.h
--- a/liboctave/Array-util.h
+++ b/liboctave/Array-util.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-voidp.cc b/liboctave/Array-voidp.cc
--- a/liboctave/Array-voidp.cc
+++ b/liboctave/Array-voidp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -778,17 +778,17 @@ Array<T>::index (const idx_vector& i, co
       // A(:,:) produces a shallow copy.
       retval = Array<T> (*this, dv);
     }
   else
     {
       if (i.extent (r) != r)
         gripe_index_out_of_range (2, 1, i.extent (r), r); // throws
       if (j.extent (c) != c)
-        gripe_index_out_of_range (2, 2, i.extent (c), c); // throws
+        gripe_index_out_of_range (2, 2, j.extent (c), c); // throws
 
       octave_idx_type n = numel (), il = i.length (r), jl = j.length (c);
 
       idx_vector ii (i);
 
       if (ii.maybe_reduce (r, j, c))
         {
           octave_idx_type l, u;
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -1,12 +1,12 @@
 // DiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxAEPBAL.h b/liboctave/CmplxAEPBAL.h
--- a/liboctave/CmplxAEPBAL.h
+++ b/liboctave/CmplxAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxCHOL.h b/liboctave/CmplxCHOL.h
--- a/liboctave/CmplxCHOL.h
+++ b/liboctave/CmplxCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxGEPBAL.h b/liboctave/CmplxGEPBAL.h
--- a/liboctave/CmplxGEPBAL.h
+++ b/liboctave/CmplxGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxHESS.h b/liboctave/CmplxHESS.h
--- a/liboctave/CmplxHESS.h
+++ b/liboctave/CmplxHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxLU.h b/liboctave/CmplxLU.h
--- a/liboctave/CmplxLU.h
+++ b/liboctave/CmplxLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/CmplxQR.h b/liboctave/CmplxQR.h
--- a/liboctave/CmplxQR.h
+++ b/liboctave/CmplxQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxQRP.h b/liboctave/CmplxQRP.h
--- a/liboctave/CmplxQRP.h
+++ b/liboctave/CmplxQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSCHUR.h b/liboctave/CmplxSCHUR.h
--- a/liboctave/CmplxSCHUR.h
+++ b/liboctave/CmplxSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSVD.h b/liboctave/CmplxSVD.h
--- a/liboctave/CmplxSVD.h
+++ b/liboctave/CmplxSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAE.h b/liboctave/DAE.h
--- a/liboctave/DAE.h
+++ b/liboctave/DAE.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAEFunc.h b/liboctave/DAEFunc.h
--- a/liboctave/DAEFunc.h
+++ b/liboctave/DAEFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAERT.h b/liboctave/DAERT.h
--- a/liboctave/DAERT.h
+++ b/liboctave/DAERT.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAERTFunc.h b/liboctave/DAERTFunc.h
--- a/liboctave/DAERTFunc.h
+++ b/liboctave/DAERTFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASPK.h b/liboctave/DASPK.h
--- a/liboctave/DASPK.h
+++ b/liboctave/DASPK.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASRT.h b/liboctave/DASRT.h
--- a/liboctave/DASRT.h
+++ b/liboctave/DASRT.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DET.h b/liboctave/DET.h
--- a/liboctave/DET.h
+++ b/liboctave/DET.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -38,17 +38,17 @@ template <class T>
 class
 DiagArray2 : protected Array<T>
 {
 protected:
   octave_idx_type d1, d2;
 
 public:
 
-  using Array<T>::element_type;
+  using typename Array<T>::element_type;
 
   DiagArray2 (void)
     : Array<T> (), d1 (0), d2 (0) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c)
     : Array<T> (dim_vector (std::min (r, c), 1)), d1 (r), d2 (c) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val)
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/EIG.h b/liboctave/EIG.h
--- a/liboctave/EIG.h
+++ b/liboctave/EIG.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/LSODE.h b/liboctave/LSODE.h
--- a/liboctave/LSODE.h
+++ b/liboctave/LSODE.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-C.cc b/liboctave/MArray-C.cc
--- a/liboctave/MArray-C.cc
+++ b/liboctave/MArray-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-d.cc b/liboctave/MArray-d.cc
--- a/liboctave/MArray-d.cc
+++ b/liboctave/MArray-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-decl.h b/liboctave/MArray-decl.h
--- a/liboctave/MArray-decl.h
+++ b/liboctave/MArray-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MArray-f.cc b/liboctave/MArray-f.cc
--- a/liboctave/MArray-f.cc
+++ b/liboctave/MArray-f.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-fC.cc b/liboctave/MArray-fC.cc
--- a/liboctave/MArray-fC.cc
+++ b/liboctave/MArray-fC.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-s.cc b/liboctave/MArray-s.cc
--- a/liboctave/MArray-s.cc
+++ b/liboctave/MArray-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse-C.cc b/liboctave/MSparse-C.cc
--- a/liboctave/MSparse-C.cc
+++ b/liboctave/MSparse-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse-d.cc b/liboctave/MSparse-d.cc
--- a/liboctave/MSparse-d.cc
+++ b/liboctave/MSparse-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse-defs.h b/liboctave/MSparse-defs.h
--- a/liboctave/MSparse-defs.h
+++ b/liboctave/MSparse-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's liboctave directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/Matrix.h b/liboctave/Matrix.h
--- a/liboctave/Matrix.h
+++ b/liboctave/Matrix.h
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 Copyright (C) 2006 Andy Adler
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/MatrixType.h b/liboctave/MatrixType.h
--- a/liboctave/MatrixType.h
+++ b/liboctave/MatrixType.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 Copyright (C) 2006 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/ODE.h b/liboctave/ODE.h
--- a/liboctave/ODE.h
+++ b/liboctave/ODE.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODEFunc.h b/liboctave/ODEFunc.h
--- a/liboctave/ODEFunc.h
+++ b/liboctave/ODEFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODES.cc b/liboctave/ODES.cc
--- a/liboctave/ODES.cc
+++ b/liboctave/ODES.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODES.h b/liboctave/ODES.h
--- a/liboctave/ODES.h
+++ b/liboctave/ODES.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODESFunc.h b/liboctave/ODESFunc.h
--- a/liboctave/ODESFunc.h
+++ b/liboctave/ODESFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/PermMatrix.cc b/liboctave/PermMatrix.cc
--- a/liboctave/PermMatrix.cc
+++ b/liboctave/PermMatrix.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/PermMatrix.h b/liboctave/PermMatrix.h
--- a/liboctave/PermMatrix.h
+++ b/liboctave/PermMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Quad-opts.in b/liboctave/Quad-opts.in
--- a/liboctave/Quad-opts.in
+++ b/liboctave/Quad-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Quad.h b/liboctave/Quad.h
--- a/liboctave/Quad.h
+++ b/liboctave/Quad.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Sparse-C.cc b/liboctave/Sparse-C.cc
--- a/liboctave/Sparse-C.cc
+++ b/liboctave/Sparse-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Sparse-b.cc b/liboctave/Sparse-b.cc
--- a/liboctave/Sparse-b.cc
+++ b/liboctave/Sparse-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Sparse-d.cc b/liboctave/Sparse-d.cc
--- a/liboctave/Sparse-d.cc
+++ b/liboctave/Sparse-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Sparse-diag-op-defs.h b/liboctave/Sparse-diag-op-defs.h
--- a/liboctave/Sparse-diag-op-defs.h
+++ b/liboctave/Sparse-diag-op-defs.h
@@ -1,11 +1,11 @@
 /* -*- C++ -*-
 
-Copyright (C) 2009-2011 Jason Riedy, Jaroslav Hajek
+Copyright (C) 2009-2012 Jason Riedy, Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -1,11 +1,11 @@
 /* -*- C++ -*-
 
-Copyright (C) 2009-2011 Jason Riedy
+Copyright (C) 2009-2012 Jason Riedy
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1,12 +1,12 @@
 // Template sparse array class
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -1,12 +1,12 @@
 // Template sparse classes
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/SparseCmplxCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxLU.h b/liboctave/SparseCmplxLU.h
--- a/liboctave/SparseCmplxLU.h
+++ b/liboctave/SparseCmplxLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/SparsedbleCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparsedbleLU.h b/liboctave/SparsedbleLU.h
--- a/liboctave/SparsedbleLU.h
+++ b/liboctave/SparsedbleLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/base-aepbal.h b/liboctave/base-aepbal.h
--- a/liboctave/base-aepbal.h
+++ b/liboctave/base-aepbal.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-dae.h b/liboctave/base-dae.h
--- a/liboctave/base-dae.h
+++ b/liboctave/base-dae.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-de.h b/liboctave/base-de.h
--- a/liboctave/base-de.h
+++ b/liboctave/base-de.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-list.h b/liboctave/base-list.h
--- a/liboctave/base-list.h
+++ b/liboctave/base-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/base-lu.h b/liboctave/base-lu.h
--- a/liboctave/base-lu.h
+++ b/liboctave/base-lu.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/base-min.h b/liboctave/base-min.h
--- a/liboctave/base-min.h
+++ b/liboctave/base-min.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-qr.cc b/liboctave/base-qr.cc
--- a/liboctave/base-qr.cc
+++ b/liboctave/base-qr.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-qr.h b/liboctave/base-qr.h
--- a/liboctave/base-qr.h
+++ b/liboctave/base-qr.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/bsxfun-decl.h b/liboctave/bsxfun-decl.h
--- a/liboctave/bsxfun-decl.h
+++ b/liboctave/bsxfun-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/bsxfun-defs.cc
--- a/liboctave/bsxfun-defs.cc
+++ b/liboctave/bsxfun-defs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/bsxfun.h b/liboctave/bsxfun.h
--- a/liboctave/bsxfun.h
+++ b/liboctave/bsxfun.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Jordi Gutiérrez Hermoso <jordigh@octave.org>
+Copyright (C) 2012 Jordi Gutiérrez Hermoso <jordigh@octave.org>
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -37,17 +37,17 @@ is_valid_bsxfun (const std::string& name
     {
       octave_idx_type xk = dx(i), yk = dy(i);
       // Check the three conditions for valid bsxfun dims
       if (! ( (xk == yk) || (xk == 1 && yk > 1) || (xk > 1 && yk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
-    ("Octave:auto-bsxfun", "%s: automatic broadcasting operation applied", name.c_str ());
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
 
   return true;
 }
 
 // since we can't change the size of the assigned-to matrix, we cannot
 // apply singleton expansion to it, so the conditions to check are
 // different here.
 inline
@@ -64,16 +64,16 @@ is_valid_inplace_bsxfun (const std::stri
       octave_idx_type rk = dr(i), xk = dx(i);
 
       // Only two valid canditions to check; can't stretch rk
       if (! ( (rk == xk) || (rk > 1 && xk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
-    ("Octave:auto-bsxfun", "%s: automatic broadcasting operation applied", name.c_str ());
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
 
   return true;
 }
 
 #include "bsxfun-defs.cc"
 
 #endif
diff --git a/liboctave/byte-swap.h b/liboctave/byte-swap.h
--- a/liboctave/byte-swap.h
+++ b/liboctave/byte-swap.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/caseless-str.h b/liboctave/caseless-str.h
--- a/liboctave/caseless-str.h
+++ b/liboctave/caseless-str.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Shai Ayal
+Copyright (C) 2007-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/cmd-hist.h b/liboctave/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/cmd-hist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -1,12 +1,12 @@
 // DiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleAEPBAL.h b/liboctave/dbleAEPBAL.h
--- a/liboctave/dbleAEPBAL.h
+++ b/liboctave/dbleAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleCHOL.h b/liboctave/dbleCHOL.h
--- a/liboctave/dbleCHOL.h
+++ b/liboctave/dbleCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleGEPBAL.h b/liboctave/dbleGEPBAL.h
--- a/liboctave/dbleGEPBAL.h
+++ b/liboctave/dbleGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleHESS.h b/liboctave/dbleHESS.h
--- a/liboctave/dbleHESS.h
+++ b/liboctave/dbleHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleLU.h b/liboctave/dbleLU.h
--- a/liboctave/dbleLU.h
+++ b/liboctave/dbleLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/dbleQR.h b/liboctave/dbleQR.h
--- a/liboctave/dbleQR.h
+++ b/liboctave/dbleQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleQRP.h b/liboctave/dbleQRP.h
--- a/liboctave/dbleQRP.h
+++ b/liboctave/dbleQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSCHUR.h b/liboctave/dbleSCHUR.h
--- a/liboctave/dbleSCHUR.h
+++ b/liboctave/dbleSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSVD.h b/liboctave/dbleSVD.h
--- a/liboctave/dbleSVD.h
+++ b/liboctave/dbleSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyirght (C) 2009, 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyirght (C) 2009, 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -72,17 +72,17 @@ dir_entry::read (void)
   string_vector retval;
 
   if (ok ())
     {
       std::list<std::string> dirlist;
 
       struct dirent *dir_ent;
 
-      while ((dir_ent = readdir (static_cast<DIR *> (dir))))
+      while ((dir_ent = gnulib::readdir (static_cast<DIR *> (dir))))
         {
           if (dir_ent)
             dirlist.push_back (dir_ent->d_name);
           else
             break;
         }
 
       retval = string_vector (dirlist);
diff --git a/liboctave/dir-ops.h b/liboctave/dir-ops.h
--- a/liboctave/dir-ops.h
+++ b/liboctave/dir-ops.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "SparsedbleCHOL.h"
 #include "SparseCmplxCHOL.h"
 #include "oct-rand.h"
 #include "dbleCHOL.h"
 #include "CmplxCHOL.h"
 #include "dbleLU.h"
 #include "CmplxLU.h"
 
+#ifdef HAVE_ARPACK
 typedef ColumnVector (*EigsFunc) (const ColumnVector &x, int &eigs_error);
 typedef ComplexColumnVector (*EigsComplexFunc)
   (const ComplexColumnVector &x, int &eigs_error);
 
 // Arpack and blas fortran functions we call.
 extern "C"
 {
   F77_RET_T
@@ -3824,16 +3825,17 @@ extern octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
                              const std::string &_typ, Complex sigma,
                              octave_idx_type k, octave_idx_type p,
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &resid, std::ostream& os,
                              double tol = DBL_EPSILON, bool rvec = false,
                              bool cholB = 0, int disp = 0, int maxit = 300);
+#endif
 
 #ifndef _MSC_VER
 template static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
 template static octave_idx_type
 lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&,
          ComplexMatrix&);
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/fCDiagMatrix.cc
@@ -1,12 +1,12 @@
 // DiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/fCDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxAEPBAL.cc b/liboctave/fCmplxAEPBAL.cc
--- a/liboctave/fCmplxAEPBAL.cc
+++ b/liboctave/fCmplxAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxAEPBAL.h b/liboctave/fCmplxAEPBAL.h
--- a/liboctave/fCmplxAEPBAL.h
+++ b/liboctave/fCmplxAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/fCmplxCHOL.cc
--- a/liboctave/fCmplxCHOL.cc
+++ b/liboctave/fCmplxCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxCHOL.h b/liboctave/fCmplxCHOL.h
--- a/liboctave/fCmplxCHOL.h
+++ b/liboctave/fCmplxCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxGEPBAL.h b/liboctave/fCmplxGEPBAL.h
--- a/liboctave/fCmplxGEPBAL.h
+++ b/liboctave/fCmplxGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/fCmplxHESS.cc
--- a/liboctave/fCmplxHESS.cc
+++ b/liboctave/fCmplxHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxHESS.h b/liboctave/fCmplxHESS.h
--- a/liboctave/fCmplxHESS.h
+++ b/liboctave/fCmplxHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxLU.cc b/liboctave/fCmplxLU.cc
--- a/liboctave/fCmplxLU.cc
+++ b/liboctave/fCmplxLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxLU.h b/liboctave/fCmplxLU.h
--- a/liboctave/fCmplxLU.h
+++ b/liboctave/fCmplxLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/fCmplxQR.h b/liboctave/fCmplxQR.h
--- a/liboctave/fCmplxQR.h
+++ b/liboctave/fCmplxQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxQRP.h b/liboctave/fCmplxQRP.h
--- a/liboctave/fCmplxQRP.h
+++ b/liboctave/fCmplxQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/fCmplxSCHUR.cc
--- a/liboctave/fCmplxSCHUR.cc
+++ b/liboctave/fCmplxSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSCHUR.h b/liboctave/fCmplxSCHUR.h
--- a/liboctave/fCmplxSCHUR.h
+++ b/liboctave/fCmplxSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/fCmplxSVD.cc
--- a/liboctave/fCmplxSVD.cc
+++ b/liboctave/fCmplxSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSVD.h b/liboctave/fCmplxSVD.h
--- a/liboctave/fCmplxSVD.h
+++ b/liboctave/fCmplxSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -1,12 +1,12 @@
 // FloatDiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fDiagMatrix.h b/liboctave/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/fDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fEIG.h b/liboctave/fEIG.h
--- a/liboctave/fEIG.h
+++ b/liboctave/fEIG.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/file-stat.h b/liboctave/file-stat.h
--- a/liboctave/file-stat.h
+++ b/liboctave/file-stat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatAEPBAL.cc b/liboctave/floatAEPBAL.cc
--- a/liboctave/floatAEPBAL.cc
+++ b/liboctave/floatAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatAEPBAL.h b/liboctave/floatAEPBAL.h
--- a/liboctave/floatAEPBAL.h
+++ b/liboctave/floatAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatCHOL.h b/liboctave/floatCHOL.h
--- a/liboctave/floatCHOL.h
+++ b/liboctave/floatCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatGEPBAL.h b/liboctave/floatGEPBAL.h
--- a/liboctave/floatGEPBAL.h
+++ b/liboctave/floatGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatHESS.cc b/liboctave/floatHESS.cc
--- a/liboctave/floatHESS.cc
+++ b/liboctave/floatHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatHESS.h b/liboctave/floatHESS.h
--- a/liboctave/floatHESS.h
+++ b/liboctave/floatHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatLU.cc b/liboctave/floatLU.cc
--- a/liboctave/floatLU.cc
+++ b/liboctave/floatLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatLU.h b/liboctave/floatLU.h
--- a/liboctave/floatLU.h
+++ b/liboctave/floatLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/floatQR.h b/liboctave/floatQR.h
--- a/liboctave/floatQR.h
+++ b/liboctave/floatQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatQRP.h b/liboctave/floatQRP.h
--- a/liboctave/floatQRP.h
+++ b/liboctave/floatQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSCHUR.cc b/liboctave/floatSCHUR.cc
--- a/liboctave/floatSCHUR.cc
+++ b/liboctave/floatSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSCHUR.h b/liboctave/floatSCHUR.h
--- a/liboctave/floatSCHUR.h
+++ b/liboctave/floatSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSVD.h b/liboctave/floatSVD.h
--- a/liboctave/floatSVD.h
+++ b/liboctave/floatSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/functor.h b/liboctave/functor.h
--- a/liboctave/functor.h
+++ b/liboctave/functor.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 John W. Eaton
+Copyright (C) 2008-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/glob-match.cc b/liboctave/glob-match.cc
--- a/liboctave/glob-match.cc
+++ b/liboctave/glob-match.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 class NDArray;
 
 template <class T>
 class
 intNDArray : public MArray<T>
 {
 public:
 
-  using MArray<T>::element_type;
+  using typename MArray<T>::element_type;
 
   intNDArray (void) : MArray<T> () { }
 
   intNDArray (T val) : MArray<T> (dim_vector (1, 1), val) { }
 
   intNDArray (const dim_vector& dv) : MArray<T> (dv) { }
 
   intNDArray (const dim_vector& dv, T val)
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -220,20 +220,16 @@ extern "C" {
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1); DEBUGF_END ()
 #define DEBUGF2(str, e1, e2)                                            \
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2); DEBUGF_END ()
 #define DEBUGF3(str, e1, e2, e3)                                        \
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2, e3); DEBUGF_END ()
 #define DEBUGF4(str, e1, e2, e3, e4)                                    \
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2, e3, e4); DEBUGF_END ()
 
-#undef fopen
-#define fopen kpse_fopen_trace
-static FILE *fopen (const char *filename, const char *mode);
-
 #endif /* not NO_DEBUG */
 
 #ifdef KPSE_DEBUG
 static unsigned int kpathsea_debug = 0;
 #endif
 
 #if defined (WIN32) && !defined (__MINGW32__)
 
@@ -357,21 +353,25 @@ kpse_is_env_sep (char c)
 
 static FILE *
 xfopen (const std::string& filename, const char *mode)
 {
   FILE *f;
 
   assert (! filename.empty () && mode);
 
-  f = fopen (filename.c_str (), mode);
+  f = gnulib::fopen (filename.c_str (), mode);
 
   if (! f)
     FATAL_PERROR (filename.c_str ());
 
+  if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
+    DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename.c_str (), mode,
+             reinterpret_cast<unsigned long> (f));
+
   return f;
 }
 
 /* A single (key,value) pair.  */
 
 struct hash_element_type
 {
   std::string key;
@@ -2277,17 +2277,17 @@ do_subdir (str_llist_type *str_list_ptr,
       /* If we do have something to match, see if it exists.  For
          example, POST might be `pk/ljfour', and they might have a
          directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
-  while ((e = readdir (dir)))
+  while ((e = gnulib::readdir (dir)))
     {
       /* If it begins with a `.', never mind.  (This allows ``hidden''
          directories that the algorithm won't find.)  */
 
       if (e->d_name[0] != '.')
         {
           int links;
 
@@ -2441,38 +2441,16 @@ xclosedir (DIR *d)
 {
   int ret = gnulib::closedir (d);
 
   if (ret != 0)
     FATAL ("closedir failed");
 }
 #endif
 
-/* Help the user discover what's going on.  */
-
-#ifdef KPSE_DEBUG
-
-/* If the real definitions of fopen or fclose are macros, we lose -- the
-   #undef won't restore them. */
-
-static FILE *
-fopen (const char *filename, const char *mode)
-{
-#undef fopen
-  FILE *ret = fopen (filename, mode);
-
-  if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
-    DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename, mode,
-             reinterpret_cast<unsigned long> (ret));
-
-  return ret;
-}
-
-#endif
-
 /* Implementation of a linked list of strings.  */
 
 /* Add the new string STR to the end of the list L.  */
 
 static void
 str_llist_add (str_llist_type *l, const std::string& str)
 {
   str_llist_elt_type *e;
diff --git a/liboctave/lo-array-gripes.cc b/liboctave/lo-array-gripes.cc
--- a/liboctave/lo-array-gripes.cc
+++ b/liboctave/lo-array-gripes.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-array-gripes.h b/liboctave/lo-array-gripes.h
--- a/liboctave/lo-array-gripes.h
+++ b/liboctave/lo-array-gripes.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-cieee.c b/liboctave/lo-cieee.c
--- a/liboctave/lo-cieee.c
+++ b/liboctave/lo-cieee.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-cutils.c b/liboctave/lo-cutils.c
--- a/liboctave/lo-cutils.c
+++ b/liboctave/lo-cutils.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-cutils.h b/liboctave/lo-cutils.h
--- a/liboctave/lo-cutils.h
+++ b/liboctave/lo-cutils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-ieee.cc b/liboctave/lo-ieee.cc
--- a/liboctave/lo-ieee.cc
+++ b/liboctave/lo-ieee.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-macros.h b/liboctave/lo-macros.h
--- a/liboctave/lo-macros.h
+++ b/liboctave/lo-macros.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-mappers.h b/liboctave/lo-mappers.h
--- a/liboctave/lo-mappers.h
+++ b/liboctave/lo-mappers.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-math.h b/liboctave/lo-math.h
--- a/liboctave/lo-math.h
+++ b/liboctave/lo-math.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -72,17 +72,17 @@ octave_chdir (const std::string& path_ar
 {
   std::string path = file_ops::tilde_expand (path_arg);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
   if (path.length() == 2 && path[1] == ':')
     path += "\\";
 #endif
 
-  return chdir (path.c_str ());
+  return gnulib::chdir (path.c_str ());
 }
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 pid_t
 octave_popen2 (const std::string& cmd, const string_vector& args, bool sync_mode,
     int *fildes, std::string& msg)
 {
@@ -136,78 +136,8 @@ octave_popen2 (const std::string& cmd, c
   CloseHandle (childWrite);
   CloseHandle (pi.hProcess);
   CloseHandle (pi.hThread);
 
   return pid;
 }
 
 #endif
-
-#if defined (_MSC_VER) && ! defined (HAVE_DIRENT_H)
-
-// FIXME -- it would probably be better to adapt the versions of
-// opendir, readdir, and closedir from Emacs as they appear to be more
-// complete implementations (do the functions below work for network
-// paths, for example)?  We can probably get along without rewinddir.
-
-struct __DIR
-{
-  HANDLE hnd;
-  WIN32_FIND_DATA fd;
-  int dirty;
-  struct direct d;
-  const char *current;
-};
-
-DIR *
-opendir (const char *name)
-{
-  DIR *d = static_cast<DIR *> (malloc (sizeof (DIR)));
-  static char buffer[MAX_PATH];
-
-  strncpy (buffer, name, MAX_PATH);
-  if (buffer[strnlen(buffer, MAX_PATH)-1] != '\\')
-    strncat (buffer, "\\*", MAX_PATH);
-  else
-    strncat (buffer, "*", MAX_PATH);
-  d->current = buffer;
-  d->hnd = FindFirstFile (buffer, &(d->fd));
-  if (d->hnd == INVALID_HANDLE_VALUE)
-    {
-      free (d);
-      return 0;
-    }
-  d->dirty = 1;
-  return d;
-}
-
-void
-rewinddir (DIR *d)
-{
-  if (d->hnd != INVALID_HANDLE_VALUE)
-    FindClose (d->hnd);
-  d->hnd = FindFirstFile (d->current, &(d->fd));
-  d->dirty = 1;
-}
-
-void
-closedir (DIR *d)
-{
-  if (d->hnd != INVALID_HANDLE_VALUE)
-    FindClose (d->hnd);
-  free (d);
-}
-
-struct direct *
-readdir (DIR *d)
-{
-  if (! d->dirty)
-    {
-      if (! FindNextFile(d->hnd, &(d->fd)))
-        return 0;
-    }
-  d->d.d_name = d->fd.cFileName;
-  d->dirty = 0;
-  return &(d->d);
-}
-
-#endif
diff --git a/liboctave/lo-sysdep.h b/liboctave/lo-sysdep.h
--- a/liboctave/lo-sysdep.h
+++ b/liboctave/lo-sysdep.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -32,30 +32,9 @@ extern std::string octave_getcwd (void);
 
 extern int octave_chdir (const std::string&);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 extern pid_t octave_popen2 (const std::string&, const string_vector&,
     bool, int *, std::string&);
 #endif
 
-#if defined (_MSC_VER) && ! defined (HAVE_DIRENT_H)
-
-// FIXME -- it would probably be better to adapt the versions of
-// opendir, readdir, and closedir from Emacs as they appear to be more
-// complete implementations.  We can probably get along without
-// rewinddir.
-
-struct direct
-{
-  char *d_name;
-};
-
-typedef struct __DIR DIR;
-
-extern DIR* opendir (const char *name);
-extern void rewinddir (DIR *d);
-extern void closedir (DIR *d);
-extern struct direct *readdir (DIR *d);
-
 #endif
-
-#endif
diff --git a/liboctave/lo-traits.h b/liboctave/lo-traits.h
--- a/liboctave/lo-traits.h
+++ b/liboctave/lo-traits.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -1,12 +1,12 @@
 // utils.cc
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mach-info.h b/liboctave/mach-info.h
--- a/liboctave/mach-info.h
+++ b/liboctave/mach-info.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -1,9 +1,9 @@
-# Copyright (C) 2003-2011 John W. Eaton
+# Copyright (C) 2003-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/mx-base.h b/liboctave/mx-base.h
--- a/liboctave/mx-base.h
+++ b/liboctave/mx-base.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mx-defs.h b/liboctave/mx-defs.h
--- a/liboctave/mx-defs.h
+++ b/liboctave/mx-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mx-ext.h b/liboctave/mx-ext.h
--- a/liboctave/mx-ext.h
+++ b/liboctave/mx-ext.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/mx-op-decl.h b/liboctave/mx-op-decl.h
--- a/liboctave/mx-op-decl.h
+++ b/liboctave/mx-op-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/mx-ops b/liboctave/mx-ops
--- a/liboctave/mx-ops
+++ b/liboctave/mx-ops
@@ -1,9 +1,9 @@
-# Copyright (C) 2003-2011 John W. Eaton
+# Copyright (C) 2003-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-alloc.h b/liboctave/oct-alloc.h
--- a/liboctave/oct-alloc.h
+++ b/liboctave/oct-alloc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-cmplx.h b/liboctave/oct-cmplx.h
--- a/liboctave/oct-cmplx.h
+++ b/liboctave/oct-cmplx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-convn.cc b/liboctave/oct-convn.cc
--- a/liboctave/oct-convn.cc
+++ b/liboctave/oct-convn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-convn.h b/liboctave/oct-convn.h
--- a/liboctave/oct-convn.h
+++ b/liboctave/oct-convn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-env.h b/liboctave/oct-env.h
--- a/liboctave/oct-env.h
+++ b/liboctave/oct-env.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 John W. Eaton
+Copyright (C) 2001-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 John W. Eaton
+Copyright (C) 2001-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-glob.cc b/liboctave/oct-glob.cc
--- a/liboctave/oct-glob.cc
+++ b/liboctave/oct-glob.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 John W. Eaton
+Copyright (C) 2010-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-glob.h b/liboctave/oct-glob.h
--- a/liboctave/oct-glob.h
+++ b/liboctave/oct-glob.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 John W. Eaton
+Copyright (C) 2010-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
--- a/liboctave/oct-group.cc
+++ b/liboctave/oct-group.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -361,18 +361,18 @@ public:
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
-      return truncate_int (static_cast<mptype> (x)
-                           * static_cast<mptype> (y));
+      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+                                               * static_cast<mptype> (y));
     }
 
   // Division with rounding to nearest. Note that / and % are probably
   // computed by a single instruction.
   static T
   div (T x, T y)
     {
       if (y != 0)
@@ -616,18 +616,18 @@ public:
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
-      return truncate_int (static_cast<mptype> (x)
-                           * static_cast<mptype> (y));
+      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+                                               * static_cast<mptype> (y));
     }
 
   // Division.
   static T
   div (T x, T y)
     {
       T z;
       if (y == 0)
diff --git a/liboctave/oct-locbuf.cc b/liboctave/oct-locbuf.cc
--- a/liboctave/oct-locbuf.cc
+++ b/liboctave/oct-locbuf.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -57,17 +57,17 @@ oct_md5 (const std::string str)
   return oct_md5_result_to_str (buf);
 }
 
 std::string
 oct_md5_file (const std::string file)
 {
   std::string retval;
 
-  FILE *ifile = fopen (file.c_str (), "rb");
+  FILE *ifile = gnulib::fopen (file.c_str (), "rb");
 
   if (ifile)
     {
       unsigned char buf[16];
 
       int errflag = md5_stream (ifile, buf);
 
       gnulib::fclose (ifile);
diff --git a/liboctave/oct-md5.h b/liboctave/oct-md5.h
--- a/liboctave/oct-md5.h
+++ b/liboctave/oct-md5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 VZLU Prague
+Copyright (C) 2009-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-mutex.cc b/liboctave/oct-mutex.cc
--- a/liboctave/oct-mutex.cc
+++ b/liboctave/oct-mutex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-mutex.h b/liboctave/oct-mutex.h
--- a/liboctave/oct-mutex.h
+++ b/liboctave/oct-mutex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-norm.cc b/liboctave/oct-norm.cc
--- a/liboctave/oct-norm.cc
+++ b/liboctave/oct-norm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-norm.h b/liboctave/oct-norm.h
--- a/liboctave/oct-norm.h
+++ b/liboctave/oct-norm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-openmp.h b/liboctave/oct-openmp.h
--- a/liboctave/oct-openmp.h
+++ b/liboctave/oct-openmp.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 David Bateman
+Copyright (C) 2010-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-passwd.cc b/liboctave/oct-passwd.cc
--- a/liboctave/oct-passwd.cc
+++ b/liboctave/oct-passwd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-passwd.h b/liboctave/oct-passwd.h
--- a/liboctave/oct-passwd.h
+++ b/liboctave/oct-passwd.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rand.h b/liboctave/oct-rand.h
--- a/liboctave/oct-rand.h
+++ b/liboctave/oct-rand.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-refcount.h b/liboctave/oct-refcount.h
--- a/liboctave/oct-refcount.h
+++ b/liboctave/oct-refcount.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Jaroslav Hajek
+Copyright (C) 2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
--- a/liboctave/oct-rl-edit.c
+++ b/liboctave/oct-rl-edit.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-edit.h b/liboctave/oct-rl-edit.h
--- a/liboctave/oct-rl-edit.h
+++ b/liboctave/oct-rl-edit.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-hist.c b/liboctave/oct-rl-hist.c
--- a/liboctave/oct-rl-hist.c
+++ b/liboctave/oct-rl-hist.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-hist.h b/liboctave/oct-rl-hist.h
--- a/liboctave/oct-rl-hist.h
+++ b/liboctave/oct-rl-hist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 David Bateman
+Copyright (C) 2003-2012 David Bateman
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/oct-sort.h b/liboctave/oct-sort.h
--- a/liboctave/oct-sort.h
+++ b/liboctave/oct-sort.h
@@ -1,10 +1,10 @@
 /*
-Copyright (C) 2003-2011 David Bateman
+Copyright (C) 2003-2012 David Bateman
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-sparse.h b/liboctave/oct-sparse.h
--- a/liboctave/oct-sparse.h
+++ b/liboctave/oct-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-spparms.cc b/liboctave/oct-spparms.cc
--- a/liboctave/oct-spparms.cc
+++ b/liboctave/oct-spparms.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-spparms.h b/liboctave/oct-spparms.h
--- a/liboctave/oct-spparms.h
+++ b/liboctave/oct-spparms.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-syscalls.h b/liboctave/oct-syscalls.h
--- a/liboctave/oct-syscalls.h
+++ b/liboctave/oct-syscalls.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-time.h b/liboctave/oct-time.h
--- a/liboctave/oct-time.h
+++ b/liboctave/oct-time.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-uname.cc b/liboctave/oct-uname.cc
--- a/liboctave/oct-uname.cc
+++ b/liboctave/oct-uname.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-uname.h b/liboctave/oct-uname.h
--- a/liboctave/oct-uname.h
+++ b/liboctave/oct-uname.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/pathlen.h b/liboctave/pathlen.h
--- a/liboctave/pathlen.h
+++ b/liboctave/pathlen.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/pathsearch.h b/liboctave/pathsearch.h
--- a/liboctave/pathsearch.h
+++ b/liboctave/pathsearch.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randgamma.h b/liboctave/randgamma.h
--- a/liboctave/randgamma.h
+++ b/liboctave/randgamma.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randmtzig.h b/liboctave/randmtzig.h
--- a/liboctave/randmtzig.h
+++ b/liboctave/randmtzig.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randpoisson.h b/liboctave/randpoisson.h
--- a/liboctave/randpoisson.h
+++ b/liboctave/randpoisson.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/regexp.cc b/liboctave/regexp.cc
--- a/liboctave/regexp.cc
+++ b/liboctave/regexp.cc
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2012 John W. Eaton
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 2002-2005 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/regexp.h b/liboctave/regexp.h
--- a/liboctave/regexp.h
+++ b/liboctave/regexp.h
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2012 John W. Eaton
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/singleton-cleanup.cc b/liboctave/singleton-cleanup.cc
--- a/liboctave/singleton-cleanup.cc
+++ b/liboctave/singleton-cleanup.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-base-lu.h b/liboctave/sparse-base-lu.h
--- a/liboctave/sparse-base-lu.h
+++ b/liboctave/sparse-base-lu.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sparse-mk-ops.awk b/liboctave/sparse-mk-ops.awk
--- a/liboctave/sparse-mk-ops.awk
+++ b/liboctave/sparse-mk-ops.awk
@@ -1,9 +1,9 @@
-# Copyright (C) 2004-2011 John W. Eaton
+# Copyright (C) 2004-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/sparse-mx-ops b/liboctave/sparse-mx-ops
--- a/liboctave/sparse-mx-ops
+++ b/liboctave/sparse-mx-ops
@@ -1,9 +1,9 @@
-# Copyright (C) 2004-2011 John W. Eaton
+# Copyright (C) 2004-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/sparse-sort.cc b/liboctave/sparse-sort.cc
--- a/liboctave/sparse-sort.cc
+++ b/liboctave/sparse-sort.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-sort.h b/liboctave/sparse-sort.h
--- a/liboctave/sparse-sort.h
+++ b/liboctave/sparse-sort.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-util.cc b/liboctave/sparse-util.cc
--- a/liboctave/sparse-util.cc
+++ b/liboctave/sparse-util.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-util.h b/liboctave/sparse-util.h
--- a/liboctave/sparse-util.h
+++ b/liboctave/sparse-util.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/statdefs.h b/liboctave/statdefs.h
--- a/liboctave/statdefs.h
+++ b/liboctave/statdefs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sun-utils.h b/liboctave/sun-utils.h
--- a/liboctave/sun-utils.h
+++ b/liboctave/sun-utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sysdir.h b/liboctave/sysdir.h
--- a/liboctave/sysdir.h
+++ b/liboctave/sysdir.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/syswait.h b/liboctave/syswait.h
--- a/liboctave/syswait.h
+++ b/liboctave/syswait.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/vx-ops b/liboctave/vx-ops
--- a/liboctave/vx-ops
+++ b/liboctave/vx-ops
@@ -1,9 +1,9 @@
-# Copyright (C) 2003-2011 John W. Eaton
+# Copyright (C) 2003-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1,11 +1,11 @@
 dnl aclocal.m4 -- extra macros for configuring Octave
 dnl
-dnl Copyright (C) 1995-2011 John W. Eaton
+dnl Copyright (C) 1995-2012 John W. Eaton
 dnl 
 dnl This file is part of Octave.
 dnl 
 dnl Octave is free software; you can redistribute it and/or modify it
 dnl under the terms of the GNU General Public License as published by the
 dnl Free Software Foundation; either version 3 of the License, or (at
 dnl your option) any later version.
 dnl 
@@ -1010,16 +1010,166 @@ return qh_new_qhull (dim, n, points, ism
   [octave_cv_lib_qhull_ok=yes])])
   if test "$octave_cv_lib_qhull_ok" = "yes"; then
     $1
   else
     $2
   fi
 ])
 dnl
+dnl Check whether ARPACK works (does not crash)
+dnl
+dnl Using a pure Fortran program doesn't seem to crash when linked
+dnl with the buggy ARPACK library but the C++ program does.  Maybe
+dnl it is the memory allocation that exposes the bug and using statically
+dnl allocated arrays in Fortran does not?
+dnl
+AC_DEFUN([OCTAVE_CHECK_ARPACK_OK], [
+  AC_LANG_PUSH(C++)
+  AC_CACHE_CHECK([whether the arpack library works],
+    [octave_cv_lib_arpack_ok], [
+      AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+// External functions from ARPACK library
+extern "C" int
+F77_FUNC (dnaupd, DNAUPD) (int&, const char *, const int&, const char *,
+                           int&, const double&, double*, const int&,
+                           double*, const int&, int*, int*, double*,
+                           double*, const int&, int&, long int, long int);
+
+extern "C" int
+F77_FUNC (dneupd, DNEUPD) (const int&, const char *, int*, double*,
+                           double*, double*, const int&,
+                           const double&, const double&, double*,
+                           const char*, const int&, const char *,
+                           int&, const double&, double*, const int&,
+                           double*, const int&, int*, int*, double*,
+                           double*, const int&, int&, long int,
+                           long int, long int);
+
+extern "C" int
+F77_FUNC (dgemv, DGEMV) (const char *, const int&, const int&,
+                         const double&, const double*, const int&,
+                         const double*, const int&, const double&,
+                         double*, const int&, long int);
+
+#include <cfloat>
+
+void
+doit (void)
+{
+  // Based on function EigsRealNonSymmetricMatrix from liboctave/eigs-base.cc.
+
+  // Problem matrix.  See bug #31479
+  int n = 4;
+  double *m = new double [n * n];
+  m[0] = 1, m[4] = 0, m[8]  = 0, m[12] = -1;
+  m[1] = 0, m[5] = 1, m[9]  = 0, m[13] = 0;
+  m[2] = 0, m[6] = 0, m[10] = 1, m[14] = 0;
+  m[3] = 0, m[7] = 0, m[11] = 2, m[15] = 1;
+
+  double *resid = new double [4];
+
+  resid[0] = 0.960966;
+  resid[1] = 0.741195;
+  resid[2] = 0.150143;
+  resid[3] = 0.868067;
+
+  int *ip = new int [11];
+
+  ip[0] = 1;   // ishift
+  ip[1] = 0;   // ip[1] not referenced
+  ip[2] = 300; // mxiter, maximum number of iterations
+  ip[3] = 1;   // NB blocksize in recurrence
+  ip[4] = 0;   // nconv, number of Ritz values that satisfy convergence
+  ip[5] = 0;   // ip[5] not referenced
+  ip[6] = 1;   // mode
+  ip[7] = 0;   // ip[7] to ip[10] are return values
+  ip[8] = 0;
+  ip[9] = 0;
+  ip[10] = 0;
+ 
+  int *ipntr = new int [14];
+
+  int k = 1;
+  int p = 3;
+  int lwork = 3 * p * (p + 2);
+
+  double *v = new double [n * (p + 1)];
+  double *workl = new double [lwork + 1];
+  double *workd = new double [3 * n + 1];
+
+  int ido = 0;
+  int info = 0;
+
+  double tol = DBL_EPSILON;
+
+  do 
+    {
+      F77_FUNC (dnaupd, DNAUPD) (ido, "I", n, "LM", k, tol, resid, p,
+                                 v, n, ip, ipntr, workd, workl, lwork,
+                                 info, 1L, 2L);
+
+      if (ido == -1 || ido == 1 || ido == 2)
+        {
+          double *x = workd + ipntr[0] - 1;
+          double *y = workd + ipntr[1] - 1;
+
+          F77_FUNC (dgemv, DGEMV) ("N", n, n, 1.0, m, n, x, 1, 0.0,
+                                   y, 1, 1L);
+        }
+      else
+        {
+          if (info < 0)
+            {
+              return;  // Error
+            }
+
+          break;
+        }
+    } 
+  while (1);
+
+  int *sel = new int [p];
+
+  // In Octave, the dimensions of dr and di are k+1, but k+2 avoids segfault
+  double *dr = new double [k + 1];
+  double *di = new double [k + 1];
+  double *workev = new double [3 * p];
+
+  for (int i = 0; i < k + 1; i++)
+    dr[i] = di[i] = 0.;
+
+  int rvec = 1;
+
+  double sigmar = 0.0;
+  double sigmai = 0.0;
+
+  // In Octave, this is n*(k+1), but k+2 avoids segfault
+  double *z = new double [n * (k + 1)];
+
+  F77_FUNC (dneupd, DNEUPD) (rvec, "A", sel, dr, di, z, n, sigmar,
+                             sigmai, workev, "I", n, "LM", k, tol,
+                             resid, p, v, n, ip, ipntr, workd,
+                             workl, lwork, info, 1L, 1L, 2L);
+}
+]], [[
+  for (int i = 0; i < 10; i++)
+    doit ();
+]])],
+  [octave_cv_lib_arpack_ok=yes],
+  [octave_cv_lib_arpack_ok=no],
+  [octave_cv_lib_arpack_ok=yes])])
+  AC_LANG_POP(C++)
+  if test "$octave_cv_lib_arpack_ok" = "yes"; then
+    $1
+  else
+    $2
+  fi
+])
+dnl
 dnl Check for OpenGL.  If found, define OPENGL_LIBS
 dnl
 dnl FIXME -- the following tests should probably check for the
 dnl libraries separately.
 dnl
 dnl FIXME -- should we allow a way to specify a directory for OpenGL
 dnl libraries and header files?
 dnl
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -1,13 +1,13 @@
 #! /bin/sh
 ##
 ## run-octave -- run Octave in the build tree.
 ## 
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ## 
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ## 
diff --git a/scripts/@ftp/ascii.m b/scripts/@ftp/ascii.m
--- a/scripts/@ftp/ascii.m
+++ b/scripts/@ftp/ascii.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/binary.m b/scripts/@ftp/binary.m
--- a/scripts/@ftp/binary.m
+++ b/scripts/@ftp/binary.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/cd.m b/scripts/@ftp/cd.m
--- a/scripts/@ftp/cd.m
+++ b/scripts/@ftp/cd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/close.m b/scripts/@ftp/close.m
--- a/scripts/@ftp/close.m
+++ b/scripts/@ftp/close.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/delete.m b/scripts/@ftp/delete.m
--- a/scripts/@ftp/delete.m
+++ b/scripts/@ftp/delete.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/dir.m b/scripts/@ftp/dir.m
--- a/scripts/@ftp/dir.m
+++ b/scripts/@ftp/dir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/display.m b/scripts/@ftp/display.m
--- a/scripts/@ftp/display.m
+++ b/scripts/@ftp/display.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/loadobj.m b/scripts/@ftp/loadobj.m
--- a/scripts/@ftp/loadobj.m
+++ b/scripts/@ftp/loadobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/mget.m b/scripts/@ftp/mget.m
--- a/scripts/@ftp/mget.m
+++ b/scripts/@ftp/mget.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/mkdir.m b/scripts/@ftp/mkdir.m
--- a/scripts/@ftp/mkdir.m
+++ b/scripts/@ftp/mkdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/mput.m b/scripts/@ftp/mput.m
--- a/scripts/@ftp/mput.m
+++ b/scripts/@ftp/mput.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/rename.m b/scripts/@ftp/rename.m
--- a/scripts/@ftp/rename.m
+++ b/scripts/@ftp/rename.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/rmdir.m b/scripts/@ftp/rmdir.m
--- a/scripts/@ftp/rmdir.m
+++ b/scripts/@ftp/rmdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/saveobj.m b/scripts/@ftp/saveobj.m
--- a/scripts/@ftp/saveobj.m
+++ b/scripts/@ftp/saveobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's scripts directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Michael Zeising
+## Copyright (C) 2005-2012 Michael Zeising
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Michael Zeising
+## Copyright (C) 2005-2012 Michael Zeising
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/__error_text__.m b/scripts/deprecated/__error_text__.m
--- a/scripts/deprecated/__error_text__.m
+++ b/scripts/deprecated/__error_text__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/autocor.m b/scripts/deprecated/autocor.m
--- a/scripts/deprecated/autocor.m
+++ b/scripts/deprecated/autocor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/autocov.m b/scripts/deprecated/autocov.m
--- a/scripts/deprecated/autocov.m
+++ b/scripts/deprecated/autocov.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/betai.m b/scripts/deprecated/betai.m
--- a/scripts/deprecated/betai.m
+++ b/scripts/deprecated/betai.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cellidx.m b/scripts/deprecated/cellidx.m
--- a/scripts/deprecated/cellidx.m
+++ b/scripts/deprecated/cellidx.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Auburn University.  All rights reserved.
+## Copyright (C) 2000-2012 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/clg.m b/scripts/deprecated/clg.m
--- a/scripts/deprecated/clg.m
+++ b/scripts/deprecated/clg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cor.m b/scripts/deprecated/cor.m
--- a/scripts/deprecated/cor.m
+++ b/scripts/deprecated/cor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/corrcoef.m b/scripts/deprecated/corrcoef.m
--- a/scripts/deprecated/corrcoef.m
+++ b/scripts/deprecated/corrcoef.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cquad.m b/scripts/deprecated/cquad.m
--- a/scripts/deprecated/cquad.m
+++ b/scripts/deprecated/cquad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cut.m b/scripts/deprecated/cut.m
--- a/scripts/deprecated/cut.m
+++ b/scripts/deprecated/cut.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/dispatch.m b/scripts/deprecated/dispatch.m
--- a/scripts/deprecated/dispatch.m
+++ b/scripts/deprecated/dispatch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/error_text.m b/scripts/deprecated/error_text.m
--- a/scripts/deprecated/error_text.m
+++ b/scripts/deprecated/error_text.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/fstat.m b/scripts/deprecated/fstat.m
--- a/scripts/deprecated/fstat.m
+++ b/scripts/deprecated/fstat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague
+## Copyright (C) 2010-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/gammai.m b/scripts/deprecated/gammai.m
--- a/scripts/deprecated/gammai.m
+++ b/scripts/deprecated/gammai.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/glpkmex.m b/scripts/deprecated/glpkmex.m
--- a/scripts/deprecated/glpkmex.m
+++ b/scripts/deprecated/glpkmex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Nicolo' Giorgetti
+## Copyright (C) 2005-2012 Nicolo' Giorgetti
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
--- a/scripts/deprecated/intwarning.m
+++ b/scripts/deprecated/intwarning.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/is_duplicate_entry.m b/scripts/deprecated/is_duplicate_entry.m
--- a/scripts/deprecated/is_duplicate_entry.m
+++ b/scripts/deprecated/is_duplicate_entry.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 A. S. Hodel
+## Copyright (C) 1996-2012 A. S. Hodel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/is_global.m b/scripts/deprecated/is_global.m
--- a/scripts/deprecated/is_global.m
+++ b/scripts/deprecated/is_global.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/isstr.m b/scripts/deprecated/isstr.m
--- a/scripts/deprecated/isstr.m
+++ b/scripts/deprecated/isstr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/krylovb.m b/scripts/deprecated/krylovb.m
--- a/scripts/deprecated/krylovb.m
+++ b/scripts/deprecated/krylovb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 A. Scottedward Hodel
+## Copyright (C) 1993-2012 A. Scottedward Hodel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -22,18 +22,16 @@ deprecated_FCN_FILES = \
   deprecated/isstr.m \
   deprecated/krylovb.m \
   deprecated/perror.m \
   deprecated/polyderiv.m \
   deprecated/replot.m \
   deprecated/saveimage.m \
   deprecated/setstr.m \
   deprecated/shell_cmd.m \
-  deprecated/sphcat.m \
-  deprecated/spvcat.m \
   deprecated/strerror.m \
   deprecated/studentize.m \
   deprecated/sylvester_matrix.m \
   deprecated/values.m \
   deprecated/weibcdf.m \
   deprecated/weibinv.m \
   deprecated/weibpdf.m \
   deprecated/weibrnd.m
diff --git a/scripts/deprecated/perror.m b/scripts/deprecated/perror.m
--- a/scripts/deprecated/perror.m
+++ b/scripts/deprecated/perror.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/polyderiv.m b/scripts/deprecated/polyderiv.m
--- a/scripts/deprecated/polyderiv.m
+++ b/scripts/deprecated/polyderiv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/replot.m b/scripts/deprecated/replot.m
--- a/scripts/deprecated/replot.m
+++ b/scripts/deprecated/replot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/saveimage.m b/scripts/deprecated/saveimage.m
--- a/scripts/deprecated/saveimage.m
+++ b/scripts/deprecated/saveimage.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/setstr.m b/scripts/deprecated/setstr.m
--- a/scripts/deprecated/setstr.m
+++ b/scripts/deprecated/setstr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/shell_cmd.m b/scripts/deprecated/shell_cmd.m
--- a/scripts/deprecated/shell_cmd.m
+++ b/scripts/deprecated/shell_cmd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Rik Wehbring
+## Copyright (C) 2012 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/sphcat.m b/scripts/deprecated/sphcat.m
deleted file mode 100644
--- a/scripts/deprecated/sphcat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} sphcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the horizontal concatenation of sparse matrices.  This function
-## is obselete and @code{horzcat} should be used instead.
-## @seealso {horzcat, spvcat, vertcat, cat}
-## @end deftypefn
-
-function y = sphcat (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "sphcat is obsolete and will be removed from a future version of Octave; please use horzcat instead");
-  endif
-
-  y = horzcat (varargin{:});
-endfunction
diff --git a/scripts/deprecated/spvcat.m b/scripts/deprecated/spvcat.m
deleted file mode 100644
--- a/scripts/deprecated/spvcat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} spvcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the vertical concatenation of sparse matrices.  This function
-## is obselete and @code{vertcat} should be used instead.
-## @seealso{vertcat, sphcat, horzcat, cat}
-## @end deftypefn
-
-function y = spvcat (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "spvcat is obsolete and will be removed from a future version of Octave; please use vertcat instead");
-  endif
-
-  y = vertcat (varargin{:});
-endfunction
diff --git a/scripts/deprecated/strerror.m b/scripts/deprecated/strerror.m
--- a/scripts/deprecated/strerror.m
+++ b/scripts/deprecated/strerror.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/studentize.m b/scripts/deprecated/studentize.m
--- a/scripts/deprecated/studentize.m
+++ b/scripts/deprecated/studentize.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/sylvester_matrix.m b/scripts/deprecated/sylvester_matrix.m
--- a/scripts/deprecated/sylvester_matrix.m
+++ b/scripts/deprecated/sylvester_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/values.m b/scripts/deprecated/values.m
--- a/scripts/deprecated/values.m
+++ b/scripts/deprecated/values.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibcdf.m b/scripts/deprecated/weibcdf.m
--- a/scripts/deprecated/weibcdf.m
+++ b/scripts/deprecated/weibcdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibinv.m b/scripts/deprecated/weibinv.m
--- a/scripts/deprecated/weibinv.m
+++ b/scripts/deprecated/weibinv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibpdf.m b/scripts/deprecated/weibpdf.m
--- a/scripts/deprecated/weibpdf.m
+++ b/scripts/deprecated/weibpdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibrnd.m b/scripts/deprecated/weibrnd.m
--- a/scripts/deprecated/weibrnd.m
+++ b/scripts/deprecated/weibrnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acosd.m b/scripts/elfun/acosd.m
--- a/scripts/elfun/acosd.m
+++ b/scripts/elfun/acosd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acotd.m b/scripts/elfun/acotd.m
--- a/scripts/elfun/acotd.m
+++ b/scripts/elfun/acotd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acscd.m b/scripts/elfun/acscd.m
--- a/scripts/elfun/acscd.m
+++ b/scripts/elfun/acscd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/asecd.m b/scripts/elfun/asecd.m
--- a/scripts/elfun/asecd.m
+++ b/scripts/elfun/asecd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/asind.m b/scripts/elfun/asind.m
--- a/scripts/elfun/asind.m
+++ b/scripts/elfun/asind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/atand.m b/scripts/elfun/atand.m
--- a/scripts/elfun/atand.m
+++ b/scripts/elfun/atand.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/cosd.m b/scripts/elfun/cosd.m
--- a/scripts/elfun/cosd.m
+++ b/scripts/elfun/cosd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/cotd.m b/scripts/elfun/cotd.m
--- a/scripts/elfun/cotd.m
+++ b/scripts/elfun/cotd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/cscd.m b/scripts/elfun/cscd.m
--- a/scripts/elfun/cscd.m
+++ b/scripts/elfun/cscd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/secd.m b/scripts/elfun/secd.m
--- a/scripts/elfun/secd.m
+++ b/scripts/elfun/secd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/sind.m b/scripts/elfun/sind.m
--- a/scripts/elfun/sind.m
+++ b/scripts/elfun/sind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/tand.m b/scripts/elfun/tand.m
--- a/scripts/elfun/tand.m
+++ b/scripts/elfun/tand.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2009-2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -21,24 +21,26 @@
 ## @deftypefn  {Function File} {} accumarray (@var{subs}, @var{vals}, @var{sz}, @var{func}, @var{fillval}, @var{issparse})
 ## @deftypefnx {Function File} {} accumarray (@var{subs}, @var{vals}, @dots{})
 ##
 ## Create an array by accumulating the elements of a vector into the
 ## positions defined by their subscripts.  The subscripts are defined by
 ## the rows of the matrix @var{subs} and the values by @var{vals}.  Each
 ## row of @var{subs} corresponds to one of the values in @var{vals}.  If
 ## @var{vals} is a scalar, it will be used for each of the row of
-## @var{subs}.
+## @var{subs}.  If @var{subs} is a cell array of vectors, all vectors
+## must be of the same length, and the subscripts in the @var{k}th
+## vector must correspond to the @var{k}th dimension of the result.
 ##
 ## The size of the matrix will be determined by the subscripts
 ## themselves.  However, if @var{sz} is defined it determines the matrix
 ## size.  The length of @var{sz} must correspond to the number of columns
 ## in @var{subs}.  An exception is if @var{subs} has only one column, in
-## which case @var{sz} may be the dimensions of a vector and the subscripts
-## of @var{subs} are taken as the indices into it.
+## which case @var{sz} may be the dimensions of a vector and the
+## subscripts of @var{subs} are taken as the indices into it.
 ##
 ## The default action of @code{accumarray} is to sum the elements with
 ## the same subscripts.  This behavior can be modified by defining the
 ## @var{func} function.  This should be a function or function handle
 ## that accepts a column vector and returns a scalar.  The result of the
 ## function should not depend on the order of the subscripts.
 ##
 ## The elements of the returned array that have no subscripts associated
@@ -58,19 +60,19 @@
 ## The following @code{accumarray} example constructs a frequency table
 ## that in the first column counts how many occurrences each number in
 ## the second column has, taken from the vector @var{x}.  Note the usage
 ## of @code{unique}  for assigning to all repeated elements of @var{x}
 ## the same index (@pxref{doc-unique}).
 ##
 ## @example
 ## @group
-## x = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
-## [u, ~, j] = unique (x);
-## [accumarray(j', 1), u']
+## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
+## [@var{u}, ~, @var{j}] = unique (@var{x});
+## [accumarray(@var{j}', 1), @var{u}']
 ## @result{} 2    89
 ##    3    90
 ##    2    91
 ##    2    92
 ##    3   100
 ## @end group
 ## @end example
 ##
@@ -84,55 +86,91 @@
 ##              2, 3, 2;
 ##              2, 1, 2;
 ##              2, 3, 2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
 ##    ans(:,:,2) = [0, 0, 0; 206, 0, 208]
 ## @end group
 ## @end example
 ##
-## The complexity in the non-sparse case is generally O(M+N), where N is
-## the number of subscripts and M is the maximum subscript (linearized
-## in multi-dimensional case).  If @var{func} is one of @code{@@sum}
-## (default), @code{@@max}, @code{@@min} or @code{@@(x) @{x@}}, an
-## optimized code path is used.  Note that for general reduction function
-## the interpreter overhead can play a major part and it may be more
-## efficient to do multiple accumarray calls and compute the results in
-## a vectorized manner.
+## The sparse option can be used as an alternative to the @code{sparse}
+## constructor (@pxref{doc-sparse}). Thus
+##
+## @example
+## sparse (@var{i}, @var{j}, @var{sv})
+## @end example
+##
+## @noindent
+## can be written with @code{accumarray} as
+##
+## @example
+## accumarray ([@var{i}, @var{j}], @var{sv}', [], [], 0, true)
+## @end example
 ##
-## @seealso{accumdim, unique}
+## @noindent
+## For repeated indices, @code{sparse} adds the corresponding value. To
+## take the minimum instead, use @code{min} as an accumulator function:
+##
+## @example
+## accumarray ([@var{i}, @var{j}], @var{sv}', [], @@min, 0, true)
+## @end example
+##
+## The complexity of accumarray in general for the non-sparse case is
+## generally O(M+N), where N is the number of subscripts and M is the
+## maximum subscript (linearized in multi-dimensional case).  If
+## @var{func} is one of @code{@@sum} (default), @code{@@max},
+## @code{@@min} or @code{@@(x) @{x@}}, an optimized code path is used.
+## Note that for general reduction function the interpreter overhead can
+## play a major part and it may be more efficient to do multiple
+## accumarray calls and compute the results in a vectorized manner.
+##
+## @seealso{accumdim, unique, sparse}
 ## @end deftypefn
 
 function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])
 
   if (nargin < 2 || nargin > 6)
     print_usage ();
   endif
 
+  lenvals = length (vals);
+
   if (iscell (subs))
-    subs = cellfun ("vec", subs, "uniformoutput", false);
+    subs = cellfun (@vec, subs, "uniformoutput", false);
     ndims = numel (subs);
     if (ndims == 1)
       subs = subs{1};
     endif
+
+    lensubs = cellfun (@length, subs);
+
+    if (any (lensubs != lensubs(1)) || 
+        (lenvals > 1 && lenvals != lensubs(1)))
+      error ("accumarray: dimension mismatch");
+    endif
+
   else
     ndims = columns (subs);
+    if (lenvals > 1 && lenvals != rows (subs))
+      error ("accumarray: dimension mismatch")
+    endif
   endif
 
   if (isempty (fillval))
     fillval = 0;
   endif
 
   if (isempty (issparse))
     issparse = false;
   endif
 
   if (issparse)
 
-    ## Sparse case. Avoid linearizing the subscripts, because it could overflow.
+    ## Sparse case. Avoid linearizing the subscripts, because it could
+    ## overflow.
 
     if (fillval != 0)
       error ("accumarray: FILLVAL must be zero in the sparse case");
     endif
 
     ## Ensure subscripts are a two-column matrix.
     if (iscell (subs))
       subs = [subs{:}];
@@ -148,18 +186,18 @@ function A = accumarray (subs, vals, sz 
     if (isnumeric (vals) || islogical (vals))
       vals = double (vals);
     else
       error ("accumarray: in the sparse case, values must be numeric or logical");
     endif
 
     if (! (isempty (func) || func == @sum))
 
-      ## Reduce values. This is not needed if we're about to sum them, because
-      ## "sparse" can do that.
+      ## Reduce values. This is not needed if we're about to sum them,
+      ## because "sparse" can do that.
 
       ## Sort indices.
       [subs, idx] = sortrows (subs);
       n = rows (subs);
       ## Identify runs.
       jdx = find (any (diff (subs, 1, 1), 2));
       jdx = [jdx; n];
 
@@ -233,17 +271,18 @@ function A = accumarray (subs, vals, sz 
     elseif (func == @max)
       ## Fast maximization.
 
       if (isinteger (vals))
         zero = intmin (class (vals));
       elseif (islogical (vals))
         zero = false;
       elseif (fillval == 0 && all (vals(:) >= 0))
-        ## This is a common case - fillval is zero, all numbers nonegative.
+        ## This is a common case - fillval is zero, all numbers
+        ## nonegative.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_max__ (subs, vals, zero);
       else
@@ -259,17 +298,18 @@ function A = accumarray (subs, vals, sz 
     elseif (func == @min)
       ## Fast minimization.
 
       if (isinteger (vals))
         zero = intmax (class (vals));
       elseif (islogical (vals))
         zero = true;
       elseif (fillval == 0 && all (vals(:) <= 0))
-        ## This is a common case - fillval is zero, all numbers non-positive.
+        ## This is a common case - fillval is zero, all numbers
+        ## non-positive.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_min__ (subs, vals, zero);
       else
@@ -293,24 +333,31 @@ function A = accumarray (subs, vals, sz 
       endif
 
       ## Sort indices.
       [subs, idx] = sort (subs);
       ## Identify runs.
       jdx = find (subs(1:n-1) != subs(2:n));
       jdx = [jdx; n];
       vals = mat2cell (vals(idx), diff ([0; jdx]));
-      ## Optimize the case when function is @(x) {x}, i.e. we just want to
-      ## collect the values to cells.
+      ## Optimize the case when function is @(x) {x}, i.e. we just want
+      ## to collect the values to cells.
       persistent simple_cell_str = func2str (@(x) {x});
       if (! strcmp (func2str (func), simple_cell_str))
         vals = cellfun (func, vals);
       endif
       subs = subs(jdx);
 
+      if (isempty (sz))
+        sz = max (subs);
+        if (length (sz) == 1)
+          sz(2) = 1;
+        endif
+      endif
+
       ## Construct matrix of fillvals.
       if (iscell (vals))
         A = cell (sz);
       elseif (fillval == 0)
         A = zeros (sz, class (vals));
       else
         A = repmat (fillval, sz);
       endif
@@ -323,16 +370,17 @@ endfunction
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))),sin(cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
 %!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112),cat(3,[0,0,207,0;0,108,0,0;0,109,0,317],[0,0,111,0;104,0,0,219;0,103,0,0]))
 %!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN),[101,NaN,NaN,NaN;104,NaN,105,NaN])
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105, [], @prod), [101, 0, 0; 10608, 0, 10815])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 %!test
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague
+## Copyright (C) 2010-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,42 +17,47 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} accumdim (@var{subs}, @var{vals}, @var{dim}, @var{n}, @var{func}, @var{fillval})
 ## Create an array by accumulating the slices of an array into the
 ## positions defined by their subscripts along a specified dimension.
 ## The subscripts are defined by the index vector @var{subs}.
 ## The dimension is specified by @var{dim}.  If not given, it defaults
-## to the first non-singleton dimension.
+## to the first non-singleton dimension.  The length of @var{subs} must
+## be equal to @code{size (@var{vals}, @var{dim})}.
 ##
-## The extent of the result matrix in the working dimension will be determined
-## by the subscripts themselves.
-## However, if @var{n} is defined it determines this extent.
+## The extent of the result matrix in the working dimension will be
+## determined by the subscripts themselves.  However, if @var{n} is
+## defined it determines this extent.
 ##
 ## The default action of @code{accumdim} is to sum the subarrays with the
-## same subscripts.  This behavior can be modified by defining the @var{func}
-## function.  This should be a function or function handle that accepts an
-## array and a dimension, and reduces the array along this dimension.
-## As a special exception, the built-in @code{min} and @code{max} functions
-## can be used directly, and @code{accumdim} accounts for the middle empty
-## argument that is used in their calling.
+## same subscripts.  This behavior can be modified by defining the
+## @var{func} function.  This should be a function or function handle
+## that accepts an array and a dimension, and reduces the array along
+## this dimension.  As a special exception, the built-in @code{min} and
+## @code{max} functions can be used directly, and @code{accumdim}
+## accounts for the middle empty argument that is used in their calling.
 ##
-## The slices of the returned array that have no subscripts associated with
-## them are set to zero.  Defining @var{fillval} to some other value allows
-## these values to be defined.
+## The slices of the returned array that have no subscripts associated
+## with them are set to zero.  Defining @var{fillval} to some other
+## value allows these values to be defined.
 ##
 ## An example of the use of @code{accumdim} is:
 ##
-## @smallexample
+## @example
 ## @group
-## accumdim ([1, 2, 1, 2, 1], [7,-10,4;-5,-12,8;-12,2,8;-10,9,-3;-5,-3,-13])
+## accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
+##                             -5, -12,   8;
+##                            -12,   2,   8;
+##                            -10,   9,  -3;
+##                             -5,  -3, -13])
 ## @result{} ans = [-10,-11,-1;-15,-3,5]
 ## @end group
-## @end smallexample
+## @end example
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
 function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
@@ -63,17 +68,17 @@ function A = accumdim (subs, vals, dim, 
   endif
 
   if (! isvector (subs))
     error ("accumdim: SUBS must be a subscript vector");
   elseif (! isindex (subs)) # creates index cache
     error ("accumdim: indices must be positive integers");
   else
     m = max (subs);
-    if (n == 0)
+    if (n == 0 || isempty (n))
       n = m;
     elseif (n < m)
       error ("accumdim: N index out of range");
     endif
   endif
 
   sz = size (vals);
 
@@ -81,16 +86,20 @@ function A = accumdim (subs, vals, dim, 
     [~, dim] = max (sz != 1); # first non-singleton dim
   elseif (! isindex (dim))
     error ("accumdim: DIM must be a valid dimension");
   elseif (dim > length (sz))
     sz(end+1:dim) = 1;
   endif
   sz(dim) = n;
 
+  if (length (subs) != size (vals, dim))
+    error ("accumdim: dimension mismatch")
+  endif
+
   if (isempty (func) || func == @sum)
     ## Fast summation case.
     A = __accumdim_sum__ (subs, vals, dim, n);
 
     ## Fill in nonzero fill value
     if (fillval != 0)
       mask = true (n, 1);
       mask(subs) = false;
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Hoxide Ma
+## Copyright (C) 2005-2012 Hoxide Ma
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Laurent Mazet
+## Copyright (C) 2005-2012 Laurent Mazet
 ## Copyright (C) 2010 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/chop.m b/scripts/general/chop.m
--- a/scripts/general/chop.m
+++ b/scripts/general/chop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 VZLU Prague
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/deal.m b/scripts/general/deal.m
--- a/scripts/general/deal.m
+++ b/scripts/general/deal.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Ariel Tankus
+## Copyright (C) 1998-2012 Ariel Tankus
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2007  David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/display.m b/scripts/general/display.m
--- a/scripts/general/display.m
+++ b/scripts/general/display.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney, Robert Platt
+## Copyright (C) 2008-2012 Bill Denney, Robert Platt
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,17 +22,17 @@
 ##
 ## Fourier interpolation.  If @var{x} is a vector, then @var{x} is
 ## resampled with @var{n} points.  The data in @var{x} is assumed to be
 ## equispaced.  If @var{x} is an array, then operate along each column of
 ## the array separately.  If @var{dim} is specified, then interpolate
 ## along the dimension @var{dim}.
 ##
 ## @code{interpft} assumes that the interpolated function is periodic,
-## and so assumptions are made about the end points of the interpolation.
+## and so assumptions are made about the endpoints of the interpolation.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## 2001-02-11
 ##    * initial version
 ## 2002-03-17 aadler
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/iscolumn.m b/scripts/general/iscolumn.m
--- a/scripts/general/iscolumn.m
+++ b/scripts/general/iscolumn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Alois Schloegl
+## Copyright (C) 2004-2012 Alois Schloegl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isrow.m b/scripts/general/isrow.m
--- a/scripts/general/isrow.m
+++ b/scripts/general/isrow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isscalar.m b/scripts/general/isscalar.m
--- a/scripts/general/isscalar.m
+++ b/scripts/general/isscalar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/issquare.m b/scripts/general/issquare.m
--- a/scripts/general/issquare.m
+++ b/scripts/general/issquare.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isvector.m b/scripts/general/isvector.m
--- a/scripts/general/isvector.m
+++ b/scripts/general/isvector.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/loadobj.m b/scripts/general/loadobj.m
--- a/scripts/general/loadobj.m
+++ b/scripts/general/loadobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Carnë Draug
+## Copyright (C) 2012 Carnë Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Bill Denney
-## Copyright (C) 2011 Carnë Draug
+## Copyright (C) 2008-2012 Bill Denney
+## Copyright (C) 2012 Carnë Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nthargout.m b/scripts/general/nthargout.m
--- a/scripts/general/nthargout.m
+++ b/scripts/general/nthargout.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Jordi Gutiérrez Hermoso
+## Copyright (C) 2012 Jordi Gutiérrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 David M. Doolin
+## Copyright (C) 1999-2012 David M. Doolin
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Daniel Kraft
+## Copyright (C) 2012 Daniel Kraft
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Daniel Kraft
+## Copyright (C) 2012 Daniel Kraft
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Daniel Kraft
+## Copyright (C) 2012 Daniel Kraft
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Walter Gautschi
+## Copyright (C) 1998-2012 Walter Gautschi
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 David Bateman
-## Copyright (C) 2011 Alexander Klein
+## Copyright (C) 2008-2012 David Bateman
+## Copyright (C) 2012 Alexander Klein
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Rik Wehbring
+## Copyright (C) 2010-2012 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John Eaton and David Bateman
+## Copyright (C) 2004-2012 John Eaton and David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/delaunay3.m b/scripts/geometry/delaunay3.m
--- a/scripts/geometry/delaunay3.m
+++ b/scripts/geometry/delaunay3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Frederick (Rick) A Niles
+## Copyright (C) 2006-2012 Frederick (Rick) A Niles
 ##               and S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/gethelp.cc b/scripts/gethelp.cc
--- a/scripts/gethelp.cc
+++ b/scripts/gethelp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S�ren Hauberg
+## Copyright (C) 2009-2012 S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S�ren Hauberg
+## Copyright (C) 2009-2012 S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S�ren Hauberg
+## Copyright (C) 2009-2012 S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S�ren Hauberg
+## Copyright (C) 2009-2012 S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S�ren Hauberg
+## Copyright (C) 2009-2012 S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/private/__additional_help_message__.m b/scripts/help/private/__additional_help_message__.m
--- a/scripts/help/private/__additional_help_message__.m
+++ b/scripts/help/private/__additional_help_message__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/private/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
--- a/scripts/help/private/__strip_html_tags__.m
+++ b/scripts/help/private/__strip_html_tags__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S�ren Hauberg
+## Copyright (C) 2009-2012 S�ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 John W. Eaton
+## Copyright (C) 2009-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Soren Hauberg <hauberg@gmail.com>
+## Copyright (C) 2008-2012 Soren Hauberg <hauberg@gmail.com>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Thomas L. Scofield <scofield@calvin.edu>
+## Copyright (C) 2008-2012 Thomas L. Scofield <scofield@calvin.edu>
 ## Copyright (C) 2008 Kristian Rumberg <kristianrumberg@gmail.com>
 ## Copyright (C) 2006 Thomas Weber <thomas.weber.mail@gmail.com>
 ## Copyright (C) 2005 Stefan van der Walt <stefan@sun.ac.za>
 ## Copyright (C) 2002 Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/csvread.m b/scripts/io/csvread.m
--- a/scripts/io/csvread.m
+++ b/scripts/io/csvread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/csvwrite.m b/scripts/io/csvwrite.m
--- a/scripts/io/csvwrite.m
+++ b/scripts/io/csvwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 Paul Kienzle
+## Copyright (C) 2002-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague
+## Copyright (C) 2010-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/is_valid_file_id.m b/scripts/io/is_valid_file_id.m
--- a/scripts/io/is_valid_file_id.m
+++ b/scripts/io/is_valid_file_id.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2009-2011 Eric Chassande-Mottin, CNRS (France)
-## Copyright (C) 2011 Philip Nienhuis
+## Copyright (C) 2009-2012 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2012 Philip Nienhuis
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -121,17 +121,17 @@
 ## @end itemize
 ##
 ## @item "delimiter"
 ## Any character in @var{value} will be used to split @var{str} into words
 ## (default value = any whitespace).
 ##
 ## @item "emptyvalue":
 ## Value to return for empty numeric values in non-whitespace delimited data.
-## The default is NaN. When the data type does not support NaN
+## The default is NaN@.  When the data type does not support NaN
 ## (int32 for example), then default is zero.
 ##
 ## @item "multipledelimsasone"
 ## Treat a series of consecutive delimiters, without whitespace in between,
 ## as a single delimiter.  Consecutive delimiter series need not be vertically
 ## "aligned".
 ##
 ## @item "treatasempty"
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2009-2012 Eric Chassande-Mottin, CNRS (France)
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott <bpabbott@mac.com>
+## Copyright (C) 2010-2012 Ben Abbott <bpabbott@mac.com>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Regents of the University of California
+## Copyright (C) 2007-2012 Regents of the University of California
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek, Marco Caliari
+## Copyright (C) 2008-2012 Jaroslav Hajek, Marco Caliari
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 A. Scottedward Hodel
+## Copyright (C) 1995-2012 A. Scottedward Hodel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 Gabriele Pannocchia
+## Copyright (C) 2003-2012 Gabriele Pannocchia
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/ishermitian.m b/scripts/linear-algebra/ishermitian.m
--- a/scripts/linear-algebra/ishermitian.m
+++ b/scripts/linear-algebra/ishermitian.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/linear-algebra/issymmetric.m b/scripts/linear-algebra/issymmetric.m
--- a/scripts/linear-algebra/issymmetric.m
+++ b/scripts/linear-algebra/issymmetric.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Auburn University.  All rights reserved.
+## Copyright (C) 1993-2012 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 N.J. Higham
+## Copyright (C) 2008-2012 N.J. Higham
 ## Copyright (C) 2010 Richard T. Guy <guyrt7@wfu.edu>
 ## Copyright (C) 2010 Marco Caliari <marco.caliari@univr.it>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman and Marco Caliari
+## Copyright (C) 2006-2012 David Bateman and Marco Caliari
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Regents of the University of California
+## Copyright (C) 2007-2012 Regents of the University of California
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/planerot.m b/scripts/linear-algebra/planerot.m
--- a/scripts/linear-algebra/planerot.m
+++ b/scripts/linear-algebra/planerot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bunzip2.m b/scripts/miscellaneous/bunzip2.m
--- a/scripts/miscellaneous/bunzip2.m
+++ b/scripts/miscellaneous/bunzip2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Thorsten Meyer
+## Copyright (C) 2008-2012 Thorsten Meyer
 ## (based on gzip.m by David Bateman)
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/fact.m
@@ -0,0 +1,269 @@
+## Copyright (C) 2007-2012 Jordi Gutiérrez Hermoso 
+## Copyright (C) 2007 Stallmanfacts.com
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Command} {} fact
+## @deftypefnx {Function File} {T =} fact()
+## Display an amazing and random fact about the world's greatest hacker.
+## @end deftypefn
+
+
+function f = fact()
+  persistent wisdom = \
+      {
+       "Richard Stallman takes notes in binary.";
+       "Richard Stallman doesn't need sudo. I will make him a sandwich anyway.";
+       "Richard Stallman is my shephurd, and I am his GNU.";
+       "Richard Stallman doesn't wget, Richard Stallman wdemands!";
+       "Richard Stallman can touch MC Hammer";
+       "Richard Stallman doesn't read web pages. They write to him.";
+       "Richard Stallman gets 9 bits to the byte.";
+       "Richard Stallman doesn't really believe in open software, because it's not free enough.";
+       "Richard Stallman can leave neutral or negative feedback on eBay.";
+       "Richard Stallman is the only man alive who can pronounce GNU the way it is meant to be pronounced.";
+       "Richard Stallman does not own a mobile phone because he can fashion a crude convex dish and shout into it at the exact resonant frequency of the ozone, causing a voice to seemingly come from the sky above his intended recipient.";
+       "Richard Stallman is so handsome that when he was young he was responsible for all other geeks not being able to get girls. This is why he has to cover his face with a thick layer of hair.";
+       "Some people check their computers for viruses. Viruses check their computers for Richard Stallman.";
+       "Richard Stallman memorises all his documents. In binary. He just types everything in whenever he needs a document.";
+       "When Richard Stallman makes a sudo command, he loses permissions.";
+       "Richard Stallman's beard is made of parentheses.";
+       "Richard Stallman's DNA is in binary.";
+       "Richard Stallman's nervous system is completely wireless.";
+       "Richard Stallman's brain accepts UNIX commands.";
+       "If Richard Stallman has 1GB of RAM, and if you have 1GB of RAM, Richard Stallman has more RAM than you.";
+       "Richard Stallman eats ethernet cables. That's why they invented wireless.";
+       "Richard Stallman has a katana. 'Nuff said.";
+       "Richard Stallman wrote a program that divides by zero.";
+       "Ricahrd Stallman doesn't use zip drives, he just squeezes the hard drive.";
+       "Richard Stallman's compiler is afraid to report errors.";
+       "Richard Stallman wrote the compiler God used. The Big Bang was the Universe's first segfault.";
+       "Richard Stallman successfully compiled a kernel of popcorn.";
+       "Richard Stallman doesn't write programs, they write themselves out of reverence.";
+       "Richard Stallman can make infinite loops end.";
+       "Richard Stallman's anti-virus programs cures HIV.";
+       "Richard Stallman's computer doesn't have a clock; it defines what time it is.";
+       "Richard Stallman wrote a program to compute the last digit of pi.";
+       "Richard Stallman doesn't use web browsers. He sends a link to a demon that uses wget to fetch the page and sends it back to him.";
+       "Richard Stallman can solve the halting problem... in polynomial time.";
+       "For Richard Stallman, polynomial time is O(1).";
+       "Richard Stallman didn't \"write\" Emacs or created it in his own image. Richard Stallman made Emacs an instance of himself.";
+       "Richard Stallman can coerce meaningful data from /dev/null.";
+       "Some people wear Linus Torvalds pyjamas to bed, Linus Torvalds wears Richard Stallman pyjamas.";
+       "There is no software development process, only a bunch of programs Richard Stallman allows to exist. ";
+       "Richard Stallman spends his leisure time programming with Guile on GNU Hurd. ";
+       "Richard Stallman's left and right hands are named \"(\" and \")\" ";
+       "Richard Stallman first words were actually syscalls. ";
+       "Richard Stallman didn't create the singularity. He is the singularity. GNU/Linux is only the event horizon. ";
+       "When Richard Stallman pipes to more, he gets less ";
+       "Richard Stallman never showers: he runs 'make clean'. ";
+       "Richard Stallman needs neither mouse nor keyboard to operate his computer. He just stares it down until it does what he wants. ";
+       "Richard Stallman didn't write the GPL. He is the GPL. ";
+       "Richad Stallman's pinky finger is really a USB memory stick. ";
+       "Richard Stallman called his operating system GNU because he created it before computers existed, when actual gnus were used for calcuations. ";
+       "In Soviet Russia, Richard Stallman is still Richard Stallman! ";
+       "Richard Stallman's flute only plays free music. ";
+       "When Richard Stallman uses floats, there are no rounding errors.";
+       "Richard Stallman wrote a program so powerful, it knows the question to 42.";
+       "Richard Stallman released his own DNA under GNU FDL.";
+       "Richard Stallman knows the entire wikipedia by heart, markup included.";
+       "Richard Stallman wrote the HAL9000 OS.";
+       "Richard Stallman's laser pointer is a lightsaber.";
+       "Richard Stallman never steps down; he shifts the universe up .";
+       "Richard Stallman doesn't maintain code; he stares at it until it fixes itself out of reverence.";
+       "Richard Stallman doesn't use an editor; he sets the fundamental constants of the universe so that a magnetic platter with his code on it evolves itself.";
+       "Richard Stallman doesn’t code; he dares the computer to not do his bidding.";
+       "Global warming is caused by Richard Stallman’s rage toward non-free software.";
+       "Rather than being birthed like a normal child, Richard Stallman instead instantiated himself polymorphically. Shortly thereafter he grew a beard.";
+       "Richard Stallman discovered extra-terrestrial life but killed them because they used non-free software.";
+       "Richard Stallman doesn't evaluate expressions, expressions evaluate to Richard Stallman.";
+       "Richard Stallman can see Russia from his house.";
+       "Richard Stallman proved P=NP, twice!";
+       "Richard Stallman knows of an unfixed bug in TeX.";
+       "Richard Stallman can write a context-free grammar for C.";
+       "Richard Stallman can determine whether an arbitrary program will terminate.";
+       "Richard Stallman's computer has only two buttons. One is for guests.";
+       "Richard Stallman does not actually write programs. He comes up with a length and digit index in pi.";
+       "Richard Stallman's distributed version control system is a flamewar on Usenet.";
+       "Richard Stallman wrote the first version of Emacs on a typewriter.";
+       "Richard Stallman has no known weaknesses, except for a phobia against soap.";
+       "Richard Stallman is not affected by Godwin's Law.";
+       "Richard Stallman can write an anti-virus program that cures HIV. Too bad he never writes anti-virus programs.";
+       "Richard Stallman' facial hair is \"free as in beard\"";
+       "Richard Stallman is licensed under GPL, so you can clone him and redistribute copies so you can help your neighbor. For example a version that take a bath more often.";
+       "Richard Stallman doesn't code; he just travels around the world.";
+       "Richard Stallman was coded by himself in lisp with Emacs.";
+       "Richard Stallman doesn't eat McDonald's because the machine that kills the cows uses proprietary software.";
+       "There is no chin behind Richard Stallman's legendary beard, there is only another Emacs.";
+       "In an average living room there are 1,242 objects Richard Stallman could use to write an OS, including the room itself.";
+       "Vendor lock-in is when vendors lock themselves inside of a building out of fear of Richard Stallman's wrath.";
+       "When Richard Stallman executes ps -e, you show up.";
+       "When Richard Stallman gets angry he doesn't swear; he recurses.";
+       "On Richard Stallman's computer the bootloader is contained in his .emacs.";
+       "Richard Satallman can make any operating system free, free from drivers.";
+       "Richard Stallman programmed Chuck Norris.";
+       "Behind Richard Stallman's beard there is another fist, to code faster.";
+       "Richard Stallman won a Suduku that started with only one number in each line";
+       "Richard Stallman's brain compiles and runs C code.";
+       "Richard Stallman wrote the first version of Emacs using Emacs.";
+       "Richard Stallman never gonna give you up, never gonna let you down, never gonna run around and desert you, never gonna make you cry, never gonna say goodbye, never gonna tell a lie and hurt you.";
+       "Richard Stallman, upon reading these facts, didn't laugh at all. Instead, he complained that he is being linked to that dirty \"open source\" software. He also asked it to be changed to \"free software\", in order to raise awareness for software freedom in our society.";
+       "Richard Stallman has no problem using Emacs. He wrote it with his 4 hands.";
+       "Richard Stallman will revert the big rip by adding parenthesis to the dark matter.";
+       "When you make a Google search and it doesn't find the answer, Google gently consults Richard Stallman.";
+       "Richard Stallman's uptime is over 53 years. And counting up.";
+       "Richard Stallman's portable music player plays ogg and WMA.";
+       "Richard Stallman will never die, but may some day go to /dev/null.";
+       "Richard Stallman once got swine flu, but it got cleansed by hereditay GPL and thus got assimilated.";
+       "Richard Stallman don't cut his hair because there are no GNU/Scissors";
+       "Richard Stallman is the one who trims Chuck Norris beard. And he does it freely, of course.";
+       "Richard Stallman does not take bath, for the hydroelectric company uses proprietary software.";
+       "Agent Smith loves Richard Stallman's scent.";
+       "Richard Stallman is the One.";
+       "\"They can take our lives, but they can never take our freedom.\" Willian Wallace after a litle talk with Richard Stallman.";
+       "Richard Stallman can connect to any brain using an Emacs ssh client.";
+       "Richard Stallman ported Emacs to Intel 4004 chip.";
+       "Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.";
+       "Richard Stallman once used GDB to reverse-engineer Windows 7 into a free operating system - able to run on GNU Emacs!";
+       "Richard Stallman does not contribute to open source projects; open source projects contribute to Richard Stallman, and then call themselves free software projects.";
+       "Richard Stallman programmed himself before he could even exist";
+       "Richard Stallman can fill up /dev/null.";
+       "Richard Stallman is so zealous about privacy he has /dev/null as his home.";
+       "When Richard Stallman runs /bin/false, it returns \"true\".";
+       "Richard Stallman doesn't like money, because banks don't run on free software.";
+       "Richard Stallman user GNU tar to compress air.";
+       "Richard Stallman was installed in the world, it runs on a free program ..";
+       "When Richard Stallman reports a bug, the bug prefers to squash itself instead of facing Richard Stallman's wrath.";
+       "There is no Windows in Richard Stallman's house... only Doors...";
+       "Richard Stallman doesn't like neither PCs-Intel nor Burger King... He prefers e-Macs...";
+       "Richard Stallman can use grep to find Jimmy Hoffa.";
+       "Richard Stallman made it possible to not absolutely abhor HPUX.";
+       "When Richard Stallman pours his alphabets cereal into a bowl, only G's, N's, and U's come out.";
+       "Richard Stallman is pronounced \"GNU slash Stallman\"";
+       "Richard Stallman doesn't mind if you read his mail as long as you don't delete it before he reads it.";
+       "Richard Stallman is just a guy who has strong principles and decided to follow them.";
+       "Richard Stallman knows that you don't have class because it is a keyword that he defined.";
+       "Richard Stallman doesn't need a qwerty/dvorak keyboard only two buttons \"1\" and \"0\" and his erect penis.";
+       "On the first day Richard Stallman said M-x create-light.";
+       "Richard Stallman once went out of scope for a while. The garbage collector never dared to touch him.";
+       "Richard Stallman does not compile; he closes his eyes, and see energy lines created between bit blocks by the compiler optimizations...";
+       "intx80 first calls Richard Stallman before calling sys_call";
+       "Tron is actually a biographical story about Richard Stallman. The director decided to tone it down or audiences wouldn't find it believable.";
+       "Richard Stallman always wears a red shirt to make sure that whatever attacks his away-team has to go through him first.";
+       "kill -9 invokes Richard Stallman's rage against a process.";
+       "If Richard were to stumble upon stallmanfacts.com, he would find it a gnuisance.";
+       "Richard Stallman can telnet into Mordor.";
+       "sudo chown Richard:Stallman /all/your/base";
+       "Richard Stallman's nervous system is completely wireless.";
+       "Richard Stallman does not sleep. He yields.";
+       "Some people say M-x psychoanalyse-pinhead is a merely a program. Others say M-x psychoanalyse-pinhead *is* Richard Stallman. All I know is, Richard Stallman is The Stig.";
+       "If you execute Emacs backward it either undoes the industrial revolution or induces the rapture. But only Richard Stallman knows which.";
+       "If Richard Stallman's beard were ever trimmed, the clippings would re-marshal into an exact copy of Richard Stallman.";
+       "Richard Stallman never sleeps because he altered his own source to gain background garbage collection.";
+       "Richard Stallman's doctor can retrieve a blood sample via CVS.";
+       "Richard Stallman can touch this";
+       "Because Richard Stallman's DNA is licensed under the FDL, his doctor can't draw his blood without violating HIPAA.";
+       "Richard Stallman can remove his own appendix, using only gdb.";
+       "Richard Stallman's DNA includes debugging symbols. But he doesn't need them.";
+       "Richard Stallman met Chuck Norris once. Chuck tried a roundhouse, but Richard bashed him in the skull.";
+       "Richard Stallman doesn't need to buy a bigger hard drive. He can compress data infinitely. ";
+       "When Richard Stallman cannot take your call, his beard answers the phone for you.";
+       "The R in RMS stands for RMS.";
+       "Richard Stallman can parse HTML with regular expressions.";
+       "Richard Stallman's traceroute goes all the way through an infinite number of anonymous proxies back to the traffic's source.";
+       "Richard Stallman's beard is in fact not a just a beard, but a microprinted hard copy of Emacs source code. New patches must be checked against new hair growth before being approved.";
+       "In the beginning-of-buffer there was Richard Stallman.";
+       "The NOOP was created to give Richard Stallman some time to comb his beard.";
+       "Whenever Richard Stallman looks at a Windows computer, it segfaults. Whenever Richard Stallman doesn't look at a Windows computer, it segfaults.";
+       "Richard Stallman can walk on Windows!";
+       "After being unable to satisfy my wife for years, Richard Stallman was able to single-handedly unlock her orgasm within seconds and managed to write a texinfo manual minutes later for other users.";
+       "Richard Stallman's tabbed browser is a set to wget/telnet fg/bg processes.";
+       "There is no chin under Richard Stallman' beard. There's only another beard. Recursively.";
+       "Stallman can chown anything! stallman@stallman~$ chown stallman:stallman Earth (for example)";
+       "Richard Stallman freed his beard so he can always check what's in it.";
+       "In the beginning was the Word, and the Word was with RMS, and the Word was GNU.";
+       "RMS means \"RMS means Stallman\"";
+       "Richard Stallman is the babelfish of his own speeches.";
+       "Richard Stallman wrote his own library and lives in it.";
+       "Richard Stallman found Waldo using grep in /dev/null";
+       "Richard Stallman doesn't sleep; he is compiling";
+       "Richard Stallman will get Coca Cola to release their recipe under the GPL.";
+       "Richard Stallman doesn't change clothes. He makes case mods.";
+       "Richard Stallman compiled the first version of gcc with an hexadecimal editor.";
+       "Richard Stallman will be the last guest on Linux Outlaws";
+       "Richard Stallman calculates the universe's entropy by exploiting forced stack overflows.";
+       "Richard Stallman's consciousness will one day become the singularity, which will create Deep Thought, and answer the meaning of life, the universe and everything.";
+       "C is actually written in RMS.";
+       "Richard Stallman can write software that does not have a buffer overflow when counting money lost by Jerome Kerviel.";
+       "There were no double rainbows before Richard Stallman.";
+       "Chuck Norris had to shorten his beard in the presence of Stallman because two beards that awsome, so close would segfault the universe (again).";
+       "RMS is Titanic.";
+       "Richard Stallman is the answer to the Turing Test.";
+       "Richard Stallman's beard makes ads for Gillette and Braun appear.";
+       "for i = 1 to Stallman will never stop.";
+       "\"RMS\" stands for \"RMS Makes Software\"";
+       "Whenever someone writes a \"Hello, world\" program, Richard Stallman says \"Hello\" back.";
+       "Richard Stallman wasn't born. He was compiled from source.";
+       "Richard Stallman has a URL tatooed on the left side of his chest where you can download his genetic code.";
+       "The GNU command line idiom that Richard Stallman never needs: \"date | more\"";
+       "Richard Stallman's toe cheese is aged to perfection.";
+       "Richard Stallman doesn't always run an OS kernel, but when he does he prefers GNU/Hurd. He is... the most interesting hacker in the world. Stay free, my friends.";
+       "When Richard Stallman gets hungry, he just picks debris from his foot and eats it.";
+       "Richard Stallman can GPL your code just by looking at it funny.";
+       "Richard Mathew Stallman loves birds. Birds make auricular love to Richard Mathew Stallman.";
+       "Richard Stallman is so free that the primitive recursive function for computing his liberty causes a stack overflow.";
+       "GNU Hurd is taking more than twenty years to develop because Richard Stallman is using a programming language comprised entirely of different lengths of time.";
+       "Richard Stallman's beard contains Richard Stallman, whose beard contains Richard Stallman....";
+       "Richard Stallman had a Google Plus account in 2010.";
+       "sudo chown rms:gnu ~/base -R";
+       "Richard Stallman pipes the Emacs binaries to /dev/dsp before he goes to sleep.";
+       "When Richard Stallman counted his fingers as a kid, he always started with 0.";
+       "When Richard Stallman's computer gets a virus, he simply applies a GPL license to it which converts the whole botnet to Linux. I mean, GNU/Linux.";
+       "Richard Stallman's beard trimmings can cure cancer. Too bad he never shaves.";
+       "Richard Stallman's doesn't kill a process, he just dares it to stay running.";
+       "Richard Stallman exists because he compiled himself into being. ";
+       "Richard Stallman's first words were in binary. When they couldn't understand him, he wrote a parser.";
+       "Richard Stallman doesn't need any codecs, he just opens a multimedia file with Emacs, and reads the bytes of the file as plain text. He then performs all the necessary decoding in his mind. But he refuses to decode files encrypted with DRM, although his mind is able to.";
+       };
+
+  w = wisdom{randi([1, numel(wisdom)])};
+  if nargout > 0
+    f = w;
+  else
+    w = wordwrap (w);
+    printf ("%s", w);
+  endif
+endfunction
+
+function out = wordwrap (w)
+  cols = terminal_size ()(2);
+  wc = strsplit (w, " ");
+  out = "\n";
+  i = 1;
+  numwords = numel (wc);
+  while i <= numwords;
+    line = wc{i};
+    while (i < numwords && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
+      line = newline;
+      i++;
+    endwhile
+    out = cstrcat (out, line, "\n");
+    i++;
+  endwhile
+  out = cstrcat(out, "\n");
+endfunction
\ No newline at end of file
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Etienne Grossmann
+## Copyright (C) 2000-2012 Etienne Grossmann
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Julian Schnidder
+## Copyright (C) 2008-2012 Julian Schnidder
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/isdeployed.m b/scripts/miscellaneous/isdeployed.m
--- a/scripts/miscellaneous/isdeployed.m
+++ b/scripts/miscellaneous/isdeployed.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ismac.m b/scripts/miscellaneous/ismac.m
--- a/scripts/miscellaneous/ismac.m
+++ b/scripts/miscellaneous/ismac.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Thomas Treichl
+## Copyright (C) 2007-2012 Thomas Treichl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ispc.m b/scripts/miscellaneous/ispc.m
--- a/scripts/miscellaneous/ispc.m
+++ b/scripts/miscellaneous/ispc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/isunix.m b/scripts/miscellaneous/isunix.m
--- a/scripts/miscellaneous/isunix.m
+++ b/scripts/miscellaneous/isunix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ls_command.m b/scripts/miscellaneous/ls_command.m
--- a/scripts/miscellaneous/ls_command.m
+++ b/scripts/miscellaneous/ls_command.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/mex.m b/scripts/miscellaneous/mex.m
--- a/scripts/miscellaneous/mex.m
+++ b/scripts/miscellaneous/mex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/mexext.m b/scripts/miscellaneous/mexext.m
--- a/scripts/miscellaneous/mexext.m
+++ b/scripts/miscellaneous/mexext.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Keith Goodman
+## Copyright (C) 2006-2012 Keith Goodman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,24 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} mkoctfile [-options] file @dots{}
+## @deftypefnx {Function File} {[@var{output}, @var{status} =} mkoctfile (@dots{})
 ##
 ## The @code{mkoctfile} function compiles source code written in C,
 ## C++, or Fortran.  Depending on the options used with @code{mkoctfile}, the
 ## compiled code can be called within Octave or can be used as a stand-alone
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
-## prompt.
+## prompt.  Calling it from the Octave prompt simply delegates the
+## call to the shell prompt.  The output is stored in the @var{output}
+## variable and the exit status in the @var{status} variable.
 ##
 ## @code{mkoctfile} accepts the following options, all of which are optional
 ## except for the file name of the code you wish to compile:
 ##
 ## @table @samp
 ## @item -I DIR
 ## Add the include directory DIR to compile commands.
 ##
@@ -132,29 +135,35 @@
 ##                   .o    object file
 ##                   .a    library file
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
-function mkoctfile (varargin)
+function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
   cmd = cstrcat ("\"", shell_script, "\"");
   for i = 1:nargin
     cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
   endfor
 
-  status = system (cmd);
+  [sys, out] = system (cmd);
 
-  if (status == 127)
+  if (nargout > 0)
+    [output, status] = deal (out, sys);
+  else
+    printf ("%s", out);
+  endif
+
+  if (sys == 127)
     warning ("unable to find mkoctfile in expected location: `%s'",
              shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -15,16 +15,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/computer.m \
   miscellaneous/copyfile.m \
   miscellaneous/debug.m \
   miscellaneous/delete.m \
   miscellaneous/dir.m \
   miscellaneous/dos.m \
   miscellaneous/dump_prefs.m \
   miscellaneous/edit.m \
+	miscellaneous/fact.m \
   miscellaneous/fileattrib.m \
   miscellaneous/fileparts.m \
   miscellaneous/fullfile.m \
   miscellaneous/getappdata.m \
   miscellaneous/getfield.m \
   miscellaneous/gunzip.m \
   miscellaneous/gzip.m \
   miscellaneous/info.m \
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/news.m b/scripts/miscellaneous/news.m
--- a/scripts/miscellaneous/news.m
+++ b/scripts/miscellaneous/news.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Paul Kienzle
+## Copyright (C) 2006-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/pack.m b/scripts/miscellaneous/pack.m
--- a/scripts/miscellaneous/pack.m
+++ b/scripts/miscellaneous/pack.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 John W. Eaton
+## Copyright (C) 1999-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/paren.m b/scripts/miscellaneous/paren.m
--- a/scripts/miscellaneous/paren.m
+++ b/scripts/miscellaneous/paren.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Alexander Barth
+## Copyright (C) 2006-2012 Alexander Barth
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -43,17 +43,17 @@
 ## The parseparams function may be used to separate 'regular'
 ## arguments and additional arguments given as property/value pairs of
 ## the @var{varargin} cell array.
 ##
 ## In the second form of the call, available options are specified directly
 ## with their default values given as name-value pairs.
 ## If @var{params} do not form name-value pairs, or if an option occurs
 ## that does not match any of the available options, an error occurs.
-## When called from a m-file function, the error is prefixed with the
+## When called from an m-file function, the error is prefixed with the
 ## name of the caller function.
 ## The matching of options is case-insensitive.
 ##
 ## @seealso{varargin}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth93@users.sourceforge.net>
 ## Author: Aida Alvera Azcarate <aida@netecho.info>
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Julian Schnidder
+## Copyright (C) 2008-2012 Julian Schnidder
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Thorsten Meyer
+## Copyright (C) 2008-2012 Thorsten Meyer
 ## based on the original gzip function by David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Julian Schnidder
-## Copyright (C) 2011 Carnë Draug
+## Copyright (C) 2008-2012 Julian Schnidder
+## Copyright (C) 2012 Carnë Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/semicolon.m b/scripts/miscellaneous/semicolon.m
--- a/scripts/miscellaneous/semicolon.m
+++ b/scripts/miscellaneous/semicolon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Etienne Grossmann
+## Copyright (C) 2000-2012 Etienne Grossmann
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/tempname.m b/scripts/miscellaneous/tempname.m
--- a/scripts/miscellaneous/tempname.m
+++ b/scripts/miscellaneous/tempname.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/untar.m b/scripts/miscellaneous/untar.m
--- a/scripts/miscellaneous/untar.m
+++ b/scripts/miscellaneous/untar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/unzip.m b/scripts/miscellaneous/unzip.m
--- a/scripts/miscellaneous/unzip.m
+++ b/scripts/miscellaneous/unzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/usejava.m b/scripts/miscellaneous/usejava.m
--- a/scripts/miscellaneous/usejava.m
+++ b/scripts/miscellaneous/usejava.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Rik Wehbring
+## Copyright (C) 2012 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
+## @cindex warning ids
 ## @table @code
 ## @item Octave:abbreviated-property-match
 ## By default, the @code{Octave:abbreviated-property-match} warning is enabled.
 ##
 ## @item Octave:array-to-scalar
 ## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a scalar value is
 ## attempted.
@@ -115,16 +116,21 @@
 ## @item Octave:autoload-relative-file-name
 ## If the @code{Octave:autoload-relative-file-name} is enabled,
 ## Octave will warn when parsing autoload() function calls with relative
 ## paths to function files.  This usually happens when using autoload()
 ## calls in PKG_ADD files, when the PKG_ADD file is not in the same
 ## directory as the .oct file referred to by the autoload() command.
 ## By default, the @code{Octave:autoload-relative-file-name} warning is enabled.
 ##
+## @item Octave:broadcast
+## Warn when performing broadcasting operations.  By default, this is
+## enabled.  See @ref{Broadcasting} in the chapter Vectorization and Faster
+## Code Execution of the manual.
+##
 ## @item Octave:built-in-variable-assignment
 ## By default, the @code{Octave:built-in-variable-assignment} warning is
 ## enabled.
 ##
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
 ## warning is issued when Octave encounters a division by zero.
 ## By default, the @code{Octave:divide-by-zero} warning is enabled.
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Sylvain Pelissier
+## Copyright (C) 2006-2012 Sylvain Pelissier
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/mk-pkg-add b/scripts/mk-pkg-add
--- a/scripts/mk-pkg-add
+++ b/scripts/mk-pkg-add
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/scripts/mkdoc b/scripts/mkdoc
--- a/scripts/mkdoc
+++ b/scripts/mkdoc
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1999-2011 John W. Eaton
+# Copyright (C) 1999-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 VZLU Prague
+## Copyright (C) 2009-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -81,17 +81,16 @@
 ## Iteration limit exceeded.
 ##
 ## @item -3
 ## The trust region radius became excessively small.
 ## @end table
 ##
 ## Note: If you only have a single nonlinear equation of one variable, using
 ## @code{fzero} is usually a much better idea.
-## @seealso{fzero, optimset}
 ##
 ## Note about user-supplied Jacobians:
 ## As an inherent property of the algorithm, Jacobian is always requested for a
 ## solution vector whose residual vector is already known, and it is the last
 ## accepted successful step.  Often this will be one of the last two calls, but
 ## not always.  If the savings by reusing intermediate results from residual
 ## calculation in Jacobian calculation are significant, the best strategy is to
 ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
@@ -116,20 +115,21 @@
 ##   ## outputfcn call.
 ##   if (all (x == sav0.x))
 ##     sav = sav0;
 ##   endif
 ##   ## maybe output iteration status, etc.
 ## endif
 ## endfunction
 ##
-## ## @dots{}.
+## ## @dots{}
 ##
 ## fsolve (@@user_func, x0, optimset ("OutputFcn", @@user_func, @dots{}))
 ## @end example
+## @seealso{fzero, optimset}
 ## @end deftypefn
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
   ## Get default options if requested.
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Nicolo' Giorgetti
+## Copyright (C) 2005-2012 Nicolo' Giorgetti
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ## Copyright (C) 2008 Jaroslav Hajek
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ## Copyright (C) 2008 Jaroslav Hajek
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/optimization/private/__fdjac__.m b/scripts/optimization/private/__fdjac__.m
--- a/scripts/optimization/private/__fdjac__.m
+++ b/scripts/optimization/private/__fdjac__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Gabriele Pannocchia.
+## Copyright (C) 2000-2012 Gabriele Pannocchia.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/path/matlabroot.m b/scripts/path/matlabroot.m
--- a/scripts/path/matlabroot.m
+++ b/scripts/path/matlabroot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Bill Denney
+## Copyright (C) 2005-2012 Bill Denney
 ## Copyright (C) 2007-2009 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Bill Denney
+## Copyright (C) 2005-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 S�ren Hauberg
+## Copyright (C) 2005-2012 S�ren Hauberg
 ## Copyright (C) 2010 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague, a.s.
+## Copyright (C) 2010-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/allchild.m b/scripts/plot/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/allchild.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ## Copyright (C) 2007-2009 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/plot/axes.m b/scripts/plot/axes.m
--- a/scripts/plot/axes.m
+++ b/scripts/plot/axes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/barh.m b/scripts/plot/barh.m
--- a/scripts/plot/barh.m
+++ b/scripts/plot/barh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/box.m b/scripts/plot/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/box.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -1,9 +1,9 @@
-## Copyright (C)  2007-2011 David Bateman
+## Copyright (C)  2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 John W. Eaton
+## Copyright (C) 2002-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/closereq.m b/scripts/plot/closereq.m
--- a/scripts/plot/closereq.m
+++ b/scripts/plot/closereq.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/colstyle.m b/scripts/plot/colstyle.m
--- a/scripts/plot/colstyle.m
+++ b/scripts/plot/colstyle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 David Bateman
+## Copyright (C) 2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/comet.m b/scripts/plot/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/comet.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott and John W. Eaton
+## Copyright (C) 2010-2012 Ben Abbott and John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Shai Ayal
+## Copyright (C) 1993-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David BAteman
+## Copyright (C) 2007-2012 David BAteman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 Shai Ayal
+## Copyright (C) 2003-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ## Copyright (C) 2003 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul and Kai Habel
+## Copyright (C) 2007-2012 Michael Goffioul and Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/daspect.m b/scripts/plot/daspect.m
--- a/scripts/plot/daspect.m
+++ b/scripts/plot/daspect.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/diffuse.m b/scripts/plot/diffuse.m
--- a/scripts/plot/diffuse.m
+++ b/scripts/plot/diffuse.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/ellipsoid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Sylvain Pelissier
+## Copyright (C) 2007-2012 Sylvain Pelissier
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Ben Abbott
+## Copyright (C) 2007-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gca.m b/scripts/plot/gca.m
--- a/scripts/plot/gca.m
+++ b/scripts/plot/gca.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gcbf.m b/scripts/plot/gcbf.m
--- a/scripts/plot/gcbf.m
+++ b/scripts/plot/gcbf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gcbo.m b/scripts/plot/gcbo.m
--- a/scripts/plot/gcbo.m
+++ b/scripts/plot/gcbo.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ginput.m b/scripts/plot/ginput.m
--- a/scripts/plot/ginput.m
+++ b/scripts/plot/ginput.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gnuplot_binary.in b/scripts/plot/gnuplot_binary.in
--- a/scripts/plot/gnuplot_binary.in
+++ b/scripts/plot/gnuplot_binary.in
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gtext.m b/scripts/plot/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/gtext.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/guidata.m b/scripts/plot/guidata.m
--- a/scripts/plot/guidata.m
+++ b/scripts/plot/guidata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/guihandles.m b/scripts/plot/guihandles.m
--- a/scripts/plot/guihandles.m
+++ b/scripts/plot/guihandles.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hggroup.m b/scripts/plot/hggroup.m
--- a/scripts/plot/hggroup.m
+++ b/scripts/plot/hggroup.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isfigure.m b/scripts/plot/isfigure.m
--- a/scripts/plot/isfigure.m
+++ b/scripts/plot/isfigure.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/ishghandle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isprop.m b/scripts/plot/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/isprop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/linkprop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/meshc.m b/scripts/plot/meshc.m
--- a/scripts/plot/meshc.m
+++ b/scripts/plot/meshc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Alexander Barth
+## Copyright (C) 2006-2012 Alexander Barth
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2003 Alberto Terruzzi
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pbaspect.m b/scripts/plot/pbaspect.m
--- a/scripts/plot/pbaspect.m
+++ b/scripts/plot/pbaspect.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Paul Kienzle
+## Copyright (C) 2007-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2010 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/private/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/private/__actual_axis_position__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/private/__add_datasource__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__add_default_menu__.m b/scripts/plot/private/__add_default_menu__.m
--- a/scripts/plot/private/__add_default_menu__.m
+++ b/scripts/plot/private/__add_default_menu__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__axes_limits__.m b/scripts/plot/private/__axes_limits__.m
--- a/scripts/plot/private/__axes_limits__.m
+++ b/scripts/plot/private/__axes_limits__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__color_str_rgb__.m b/scripts/plot/private/__color_str_rgb__.m
--- a/scripts/plot/private/__color_str_rgb__.m
+++ b/scripts/plot/private/__color_str_rgb__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__default_plot_options__.m b/scripts/plot/private/__default_plot_options__.m
--- a/scripts/plot/private/__default_plot_options__.m
+++ b/scripts/plot/private/__default_plot_options__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__errcomm__.m b/scripts/plot/private/__errcomm__.m
--- a/scripts/plot/private/__errcomm__.m
+++ b/scripts/plot/private/__errcomm__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Teemu Ikonen
+## Copyright (C) 2001-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__file_filter__.m b/scripts/plot/private/__file_filter__.m
--- a/scripts/plot/private/__file_filter__.m
+++ b/scripts/plot/private/__file_filter__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__fltk_file_filter__.m b/scripts/plot/private/__fltk_file_filter__.m
--- a/scripts/plot/private/__fltk_file_filter__.m
+++ b/scripts/plot/private/__fltk_file_filter__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__fltk_ginput__.m b/scripts/plot/private/__fltk_ginput__.m
--- a/scripts/plot/private/__fltk_ginput__.m
+++ b/scripts/plot/private/__fltk_ginput__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Shai Ayal
+## Copyright (C) 2010-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Shai Ayal
+## Copyright (C) 2010-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -47,25 +47,27 @@ function opts = __fltk_print__ (opts)
   case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
         "pslatexstandalone", "pdflatexstandalone"}
     ## format GL2PS_TEX
     n = find (opts.devopt == "l", 1);
     suffix = opts.devopt(1:n-1);
     dot = find (opts.name == ".", 1, "last");
     if ((! isempty (dot))
         && any (strcmpi (opts.name(dot:end), ...
-                {".eps", ".ps", ".pdf", ".tex", "."})))
+                {strcat(".", suffix), ".tex", "."})))
       name = opts.name(1:dot-1);
       if (dot < numel (opts.name)
           && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
         ## If user provides eps/ps/pdf suffix, use it.
         suffix = opts.name(dot+1:end);
       endif
-    elseif (dot == numel (opts.name))
-      name = opts.name;
+    else
+      error ("print:invalid-suffix", 
+             "invalid suffix `%s' for device `%s'.",
+             opts.name(dot:end), lower (opts.devopt));
     endif
     gl2ps_device = {sprintf("%snotxt", lower (suffix))};
     gl2ps_device{2} = "tex";
     if (dos_shell)
       ## FIXME - this will only work on MinGW with the MSYS shell
       pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
       pipeline{2} = sprintf ("cat > %s.tex", name);
     else
diff --git a/scripts/plot/private/__getlegenddata__.m b/scripts/plot/private/__getlegenddata__.m
--- a/scripts/plot/private/__getlegenddata__.m
+++ b/scripts/plot/private/__getlegenddata__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_get_var__.m b/scripts/plot/private/__gnuplot_get_var__.m
--- a/scripts/plot/private/__gnuplot_get_var__.m
+++ b/scripts/plot/private/__gnuplot_get_var__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_ginput__.m b/scripts/plot/private/__gnuplot_ginput__.m
--- a/scripts/plot/private/__gnuplot_ginput__.m
+++ b/scripts/plot/private/__gnuplot_ginput__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Petr Mikulik
+## Copyright (C) 2004-2012 Petr Mikulik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_has_feature__.m b/scripts/plot/private/__gnuplot_has_feature__.m
--- a/scripts/plot/private/__gnuplot_has_feature__.m
+++ b/scripts/plot/private/__gnuplot_has_feature__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_has_terminal__.m b/scripts/plot/private/__gnuplot_has_terminal__.m
--- a/scripts/plot/private/__gnuplot_has_terminal__.m
+++ b/scripts/plot/private/__gnuplot_has_terminal__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_open_stream__.m b/scripts/plot/private/__gnuplot_open_stream__.m
--- a/scripts/plot/private/__gnuplot_open_stream__.m
+++ b/scripts/plot/private/__gnuplot_open_stream__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Daniel Heiserer
+## Copyright (C) 1999-2012 Daniel Heiserer
 ## Copyright (C) 2001 Laurent Mazet
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -64,20 +64,26 @@ function opts = __gnuplot_print__ (opts)
       pipeline = {sprintf("%s %s",
                           opts.epstool_cmd (opts, tmp_file, opts.name),
                           cleanup)};
     else
       eps_drawnow (opts, opts.name, gp_opts);
     endif
   case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
     dot = find (opts.name == ".", 1, "last");
-    if ((! isempty (dot))
-        && any (strcmpi (opts.name(dot:end),
-                {".eps", ".ps", ".pdf", ".tex", "."})))
-      name = opts.name(1:dot-1);
+    n = find (opts.devopt == "l", 1);
+    suffix = opts.devopt(1:n-1);
+    if (! isempty (dot))
+      if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
+        name = opts.name(1:dot-1);
+      else
+        error ("print:invalid-suffix", 
+               "invalid suffix `%s' for device `%s'.",
+               opts.name(dot:end), lower (opts.devopt));
+      endif
     endif
     if (strfind (opts.devopt, "standalone"))
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
     endif
     if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
diff --git a/scripts/plot/private/__gnuplot_version__.m b/scripts/plot/private/__gnuplot_version__.m
--- a/scripts/plot/private/__gnuplot_version__.m
+++ b/scripts/plot/private/__gnuplot_version__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Daniel Sebald
+## Copyright (C) 2006-2012 Daniel Sebald
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -689,35 +689,22 @@ function __go_draw_axes__ (h, plot_strea
                            && (size (obj.cdata, 2) == 1
                                || size (obj.cdata, 2) == 3)))
                      ccol = cdat (i, :);
                    elseif (ndims (obj.cdata) == 3)
                      ccol = permute (cdat (:, i, :), [1, 3, 2]);
                    else
                      ccol = cdat;
                    endif
-                   if (strncmp (obj.facecolor, "interp", 6) && nd == 3
-                       && numel (xcol) == 3 && isempty (ccol))
-                     ## FIXME - Use isonormals to render interpolated
-                     ##         triangular patches.
-                     obj.facecolor = "flat";
-                   endif
                    if (strncmp (obj.facecolor, "flat", 4))
-                     if (numel (ccol) == 3)
+                     if (isequal (size (ccol), [1, 3]))
+                       ## RGB Triplet
                        color = ccol;
                      elseif (nd == 3 && numel (xcol) == 3)
-                       if (isempty (ccol))
-                         z = mean (zcol);
-                         nr = size (cmap, 1);
-                         r = interp1 (linspace (clim(1), clim(2), nr),
-                                      (1:nr), z, "nearest", "extrap");
-                         color = cmap (r, :);
-                       else
-                         ccdat = ccol * ones (3,1);
-                       endif
+                       ccdat = ccol;
                      else
                        if (cdatadirect)
                          r = round (ccol);
                        else
                          r = 1 + round ((size (cmap, 1) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
                        r = max (1, min (r, size (cmap, 1)));
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__is_function__.m b/scripts/plot/private/__is_function__.m
--- a/scripts/plot/private/__is_function__.m
+++ b/scripts/plot/private/__is_function__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__line__.m b/scripts/plot/private/__line__.m
--- a/scripts/plot/private/__line__.m
+++ b/scripts/plot/private/__line__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__next_line_color__.m b/scripts/plot/private/__next_line_color__.m
--- a/scripts/plot/private/__next_line_color__.m
+++ b/scripts/plot/private/__next_line_color__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__next_line_style__.m b/scripts/plot/private/__next_line_style__.m
--- a/scripts/plot/private/__next_line_style__.m
+++ b/scripts/plot/private/__next_line_style__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton, Shai Ayal, Kai Habel
+## Copyright (C) 2007-2012 John W. Eaton, Shai Ayal, Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -269,18 +269,20 @@ function args = setdata (args)
 
   if (size(fvc, 1) == nc || size (fvc, 1) == 1)
     c = reshape (fvc, [1, size(fvc)]);
   else
     if (size(fvc, 2) == 3)
       c = cat(3, reshape (fvc(idx, 1), size(idx)),
               reshape (fvc(idx, 2), size(idx)),
               reshape (fvc(idx, 3), size(idx)));
-    else
+    elseif (isempty (fvc))
       c = [];
+    else ## if (size (fvc, 2) == 1)
+      c = permute (fvc(faces), [2, 1]);
     endif
   endif
   args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};
 endfunction
 
 function args = setvertexdata (args)
   args = delfields (args, {"vertices", "faces", "facevertexcdata"});
   ## Remove the readonly fields as well
@@ -330,20 +332,18 @@ function args = setvertexdata (args)
   else
     vert = [x(:), y(:)];
   endif
   faces = reshape (1:numel(x), nr, nc);
   faces = faces';
 
   if (ndims (c) == 3)
     fvc = reshape (c, size (c, 1) * size (c, 2), size(c, 3));
-  elseif (isvector (c))
+  else
     fvc = c(:);
-  else
-    fvc = c.'(:);
   endif
 
   args = {"faces", faces, "vertices", vert, "facevertexcdata", fvc, args{:}};
 endfunction
 
 function update_data (h, d)
   update_handle (h, false);
 endfunction
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2010 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2010-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,21 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{x}, @var{y}, @var{buttons}] =} ginput (@var{n})
-## Return which mouse buttons were pressed and keys were hit on the current
-## figure.  If @var{n} is defined, then wait for @var{n} mouse clicks
-## before returning.  If @var{n} is not defined, then @code{ginput} will
-## loop until the return key is pressed.
+## @deftypefn {Function File} {@var{args} =} __print_parse_opts__ (@var{propname}, @var{propvalue})
+## @deftypefnx {Function File} {@var{args} =} __print_parse_opts__ (@var{struct})
+## Undocumented internal function.
 ## @end deftypefn
 
 function arg_st = __print_parse_opts__ (varargin)
 
   persistent warn_on_missing_binary = true
 
   arg_st.append_to_file = false;
   arg_st.canvas_size = [];
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Michel D. Schmid
+## Copyright (C) 2006-2012 Michel D. Schmid
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/private/__tight_eps_bbox__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uigetdir_fltk__.m b/scripts/plot/private/__uigetdir_fltk__.m
--- a/scripts/plot/private/__uigetdir_fltk__.m
+++ b/scripts/plot/private/__uigetdir_fltk__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uigetfile_fltk__.m b/scripts/plot/private/__uigetfile_fltk__.m
--- a/scripts/plot/private/__uigetfile_fltk__.m
+++ b/scripts/plot/private/__uigetfile_fltk__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uiobject_split_args__.m b/scripts/plot/private/__uiobject_split_args__.m
--- a/scripts/plot/private/__uiobject_split_args__.m
+++ b/scripts/plot/private/__uiobject_split_args__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uiputfile_fltk__.m b/scripts/plot/private/__uiputfile_fltk__.m
--- a/scripts/plot/private/__uiputfile_fltk__.m
+++ b/scripts/plot/private/__uiputfile_fltk__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/rectangle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 David Bateman
+## Copyright (C) 2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/refresh.m b/scripts/plot/refresh.m
--- a/scripts/plot/refresh.m
+++ b/scripts/plot/refresh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Kai Habel
+## Copyright (C) 2006-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel, David Bateman
+## Copyright (C) 2007-2012 Kai Habel, David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/specular.m b/scripts/plot/specular.m
--- a/scripts/plot/specular.m
+++ b/scripts/plot/specular.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/sphere.m b/scripts/plot/sphere.m
--- a/scripts/plot/sphere.m
+++ b/scripts/plot/sphere.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/spinmap.m b/scripts/plot/spinmap.m
--- a/scripts/plot/spinmap.m
+++ b/scripts/plot/spinmap.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Michel D. Schmid
+## Copyright (C) 2006-2012 Michel D. Schmid
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/triplot.m b/scripts/plot/triplot.m
--- a/scripts/plot/triplot.m
+++ b/scripts/plot/triplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -66,16 +66,37 @@ function h = trisurf (tri, x, y, z, vara
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 
 endfunction
 
+%!demo
+%! clf
+%! N = 31;
+%! [x, y] = meshgrid (1:N);
+%! tri = delaunay (x, y);
+%! z = peaks (N);
+%! h = trisurf (tri, x, y, z, "facecolor", "interp");
+%! axis tight
+%! zlim auto
+%! title (sprintf ("facecolor = %s", get (h, "facecolor")))
+
+%!demo
+%! clf
+%! N = 31;
+%! [x, y] = meshgrid (1:N);
+%! tri = delaunay (x, y);
+%! z = peaks (N);
+%! h = trisurf (tri, x, y, z, "facecolor", "flat");
+%! axis tight
+%! zlim auto
+%! title (sprintf ("facecolor = %s", get (h, "facecolor")))
 
 %!demo
 %! clf
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
diff --git a/scripts/plot/uicontextmenu.m b/scripts/plot/uicontextmenu.m
--- a/scripts/plot/uicontextmenu.m
+++ b/scripts/plot/uicontextmenu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uicontrol.m b/scripts/plot/uicontrol.m
--- a/scripts/plot/uicontrol.m
+++ b/scripts/plot/uicontrol.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uipanel.m b/scripts/plot/uipanel.m
--- a/scripts/plot/uipanel.m
+++ b/scripts/plot/uipanel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uipushtool.m b/scripts/plot/uipushtool.m
--- a/scripts/plot/uipushtool.m
+++ b/scripts/plot/uipushtool.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uiresume.m b/scripts/plot/uiresume.m
--- a/scripts/plot/uiresume.m
+++ b/scripts/plot/uiresume.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uitoggletool.m b/scripts/plot/uitoggletool.m
--- a/scripts/plot/uitoggletool.m
+++ b/scripts/plot/uitoggletool.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uitoolbar.m b/scripts/plot/uitoolbar.m
--- a/scripts/plot/uitoolbar.m
+++ b/scripts/plot/uitoolbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uiwait.m b/scripts/plot/uiwait.m
--- a/scripts/plot/uiwait.m
+++ b/scripts/plot/uiwait.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/waitbar.m b/scripts/plot/waitbar.m
--- a/scripts/plot/waitbar.m
+++ b/scripts/plot/waitbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -138,17 +138,17 @@ endfunction
 %! endfor
 %! close (h);
 
 %!demo
 %! h = waitbar (0, "please wait...");
 %! for i = 0:0.01:0.6
 %!   waitbar (i);
 %! endfor
-%! i = 0.3
+%! i = 0.3;
 %! waitbar (i, h, "don't you hate taking a step backward?")
 %! pause (0.5);
 %! for i = i:0.005:0.7
 %!   waitbar (i, h);
 %! endfor
 %! waitbar (i, h, "or stalling?")
 %! pause (1);
 %! for i = i:0.003:0.8
diff --git a/scripts/plot/waitforbuttonpress.m b/scripts/plot/waitforbuttonpress.m
--- a/scripts/plot/waitforbuttonpress.m
+++ b/scripts/plot/waitforbuttonpress.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Petr Mikulik
+## Copyright (C) 2004-2012 Petr Mikulik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,16 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
+## @c List other forms of function in documentation index
+## @findex ylim
+## @findex zlim
+##
 ## @deftypefn  {Function File} {@var{xl} =} xlim ()
 ## @deftypefnx {Function File} {} xlim (@var{xl})
 ## @deftypefnx {Function File} {@var{m} =} xlim ('mode')
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
 ## Get or set the limits of the x-axis of the current plot.  Called without
 ## arguments @code{xlim} returns the x-axis limits of the current plot.
 ## If passed a two element vector @var{xl}, the limits of the x-axis are set
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Ben Abbott
+## Copyright (C) 2007-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Kai Habel
+## Copyright (C) 2001-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Tony Richardson, Jaroslav Hajek
+## Copyright (C) 2009-2012 Tony Richardson, Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -76,33 +76,35 @@ function [p, s, mu] = polyfit (x, y, n)
   if (! size_equal (x, y))
     error ("polyfit: X and Y must be vectors of the same size");
   endif
 
   if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == fix (n)))
     error ("polyfit: N must be a non-negative integer");
   endif
 
+  y_is_row_vector = (rows (y) == 1);
+
   ## Reshape x & y into column vectors.
   l = numel (x);
   x = x(:);
   y = y(:);
 
   ## Construct the Vandermonde matrix.
   v = vander (x, n+1);
 
   ## Solve by QR decomposition.
   [q, r, k] = qr (v, 0);
   p = r \ (q' * y);
   p(k) = p;
 
   if (nargout > 1)
     yf = v*p;
 
-    if (isrow (y))
+    if (y_is_row_vector)
       s.yf = yf.';
     else
       s.yf = yf;
     endif
 
     s.R = r;
     s.X = v;
     s.df = l - n - 1;
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Auburn University.  All rights reserved.
+## Copyright (C) 1995-2012 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
 ##
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
 ##
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
 ##
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2007 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2006 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/ispref.m b/scripts/prefs/ispref.m
--- a/scripts/prefs/ispref.m
+++ b/scripts/prefs/ispref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/private/loadprefs.m b/scripts/prefs/private/loadprefs.m
--- a/scripts/prefs/private/loadprefs.m
+++ b/scripts/prefs/private/loadprefs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/private/prefsfile.m b/scripts/prefs/private/prefsfile.m
--- a/scripts/prefs/private/prefsfile.m
+++ b/scripts/prefs/private/prefsfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/private/saveprefs.m b/scripts/prefs/private/saveprefs.m
--- a/scripts/prefs/private/saveprefs.m
+++ b/scripts/prefs/private/saveprefs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/rmpref.m b/scripts/prefs/rmpref.m
--- a/scripts/prefs/rmpref.m
+++ b/scripts/prefs/rmpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/setpref.m b/scripts/prefs/setpref.m
--- a/scripts/prefs/setpref.m
+++ b/scripts/prefs/setpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -52,30 +52,32 @@ function [c, ia, ib] = intersect (a, b, 
       b = unique (b, varargin{:});
     endif
 
     if (nargin > 2)
       c = [a; b];
       [c, ic] = sortrows (c);
       ii = find (all (c(1:end-1,:) == c(2:end,:), 2));
       c = c(ii,:);
+      len_a = rows (a);
     else
       c = [a(:); b(:)];
       [c, ic] = sort (c);               ## [a(:);b(:)](ic) == c
       if (iscellstr (c))
         ii = find (strcmp (c(1:end-1), c(2:end)));
       else
         ii = find (c(1:end-1) == c(2:end));
       endif
       c = c(ii);
+      len_a = length (a);
     endif
 
     if (nargout > 1)
       ia = ja(ic(ii));                  ## a(ia) == c
-      ib = jb(ic(ii+1) - length (a));   ## b(ib) == c
+      ib = jb(ic(ii+1) - len_a);        ## b(ib) == c
     endif
 
     if (nargin == 2 && (size (b, 1) == 1 || size (a, 1) == 1))
       c = c.';
     endif
   endif
 
 endfunction
@@ -100,8 +102,14 @@ endfunction
 %! assert(ib,[3;1]);
 %! assert(a(ia,:),c);
 %! assert(b(ib,:),c);
 %!test
 %! a = [1 1 1 2 2 2];
 %! b = [1 2 3 4 5 6];
 %! c = intersect(a,b);
 %! assert(c, [1,2]);
+%!test
+%! a = [1 2 3 4; 5 6 7 8; 9 10 11 12];
+%! [b, ia, ib] = intersect(a, a, "rows");
+%! assert(b, a);
+%! assert(ia, [1:3]');
+%! assert(ib, [1:3]');
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Jaroslav Hajek
+## Copyright (C) 2010-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/set/private/validargs.m b/scripts/set/private/validargs.m
--- a/scripts/set/private/validargs.m
+++ b/scripts/set/private/validargs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009-2010 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ## Copyright (C) 2000, 2006-2007 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1997-2011 Vincent Cautaerts
+## Copyright (C) 1997-2012 Vincent Cautaerts
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 John W. Eaton
+## Copyright (C) 2002-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1997-2011 Vincent Cautaerts
+## Copyright (C) 1997-2012 Vincent Cautaerts
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ## Copyright (C) 2010 Alois Schloegl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/signal/private/rectangle_lw.m b/scripts/signal/private/rectangle_lw.m
--- a/scripts/signal/private/rectangle_lw.m
+++ b/scripts/signal/private/rectangle_lw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/private/rectangle_sw.m b/scripts/signal/private/rectangle_sw.m
--- a/scripts/signal/private/rectangle_sw.m
+++ b/scripts/signal/private/rectangle_sw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/private/triangle_lw.m b/scripts/signal/private/triangle_lw.m
--- a/scripts/signal/private/triangle_lw.m
+++ b/scripts/signal/private/triangle_lw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/private/triangle_sw.m b/scripts/signal/private/triangle_sw.m
--- a/scripts/signal/private/triangle_sw.m
+++ b/scripts/signal/private/triangle_sw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Bill Lash
+## Copyright (C) 2000-2012 Bill Lash
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006   Sylvain Pelissier   <sylvain.pelissier@gmail.com>
-## Copyright (C) 2011   Carlo de Falco
+## Copyright (C) 2012   Carlo de Falco
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Radek Salac
-## Copyright (C) 2011 Carlo de Falco
+## Copyright (C) 2008-2012 Radek Salac
+## Copyright (C) 2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Radek Salac
-## Copyright (C) 2011 Carlo de Falco
+## Copyright (C) 2008-2012 Radek Salac
+## Copyright (C) 2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Ivana Varekova
+## Copyright (C) 2005-2012 Ivana Varekova
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Carlo de Falco
+## Copyright (C) 2009-2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at your
 ## option) any later version.
 ##
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Ivana Varekova
+## Copyright (C) 2005-2012 Ivana Varekova
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/nonzeros.m b/scripts/sparse/nonzeros.m
--- a/scripts/sparse/nonzeros.m
+++ b/scripts/sparse/nonzeros.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Piotr Krzyzanowski
+## Copyright (C) 2004-2012 Piotr Krzyzanowski
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Piotr Krzyzanowski
+## Copyright (C) 2004-2012 Piotr Krzyzanowski
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2004-2011 Paul Kienzle
-## Copyright (C) 2011 Jordi Gutiérrez Hermoso
+## Copyright (C) 2004-2012 Paul Kienzle
+## Copyright (C) 2012 Jordi Gutiérrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
-## Copyright (C) 2011 Jordi Gutiérrez Hermoso
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
+## Copyright (C) 2012 Jordi Gutiérrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Andy Adler
+## Copyright (C) 1998-2012 Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -253,17 +253,17 @@ endfunction
 %! v = v(:, idx);
 %! randn_state = randn ("state");
 %! rand_state = rand ("state");
 %! randn ("state", 42);      % Initialize to make normest function reproducible
 %! rand ("state", 42);
 %! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
 %!                         % to guarantee reproducible results
 %!
-%!test
+%!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (A,k);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s(end:-1:end-k+1), 1e-10);
 %!
 %!testif HAVE_UMFPACK
 %! [u2,s2,v2,flag] = svds (A,k,0,opts);
 %! s2 = diag (s2);
@@ -274,23 +274,23 @@ endfunction
 %! idx = floor(n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1);
 %! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
 %!
-%!test
+%!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (zeros (10), k);
 %! assert (u2, eye (10, k));
 %! assert (s2, zeros (k));
 %! assert (v2, eye (10, 7));
 %!
-%!test
+%!testif HAVE_ARPACK
 %! s = svds (speye (10));
 %! assert (s, ones (6, 1), 2*eps);
 
 %!test
 %! ## Restore random number generator seeds at end of tests
 %! rand ("state", rand_state);
 %! randn ("state", randn_state);
 
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ivana Varekova & Radek Salac
+## Copyright (C) 2008-2012 Ivana Varekova & Radek Salac
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Ivana Varekova
+## Copyright (C) 2005-2012 Ivana Varekova
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Nicol N. Schraudolph
+## Copyright (C) 1998-2012 Nicol N. Schraudolph
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/lcm.m b/scripts/specfun/lcm.m
--- a/scripts/specfun/lcm.m
+++ b/scripts/specfun/lcm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2008 Marco Caliari
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Rolf Fabian and Paul Kienzle
+## Copyright (C) 2001-2012 Rolf Fabian and Paul Kienzle
 ## Copyright (C) 2008 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Paul Kienzle
+## Copyright (C) 1993-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Dirk Laurie
+## Copyright (C) 1993-2012 Dirk Laurie
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Paul Kienzle
+## Copyright (C) 1999-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Peter Ekberg
+## Copyright (C) 1999-2012 Peter Ekberg
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Peter Ekberg
+## Copyright (C) 1999-2012 Peter Ekberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/special-matrix/wilkinson.m b/scripts/special-matrix/wilkinson.m
--- a/scripts/special-matrix/wilkinson.m
+++ b/scripts/special-matrix/wilkinson.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Peter Ekberg
+## Copyright (C) 1999-2012 Peter Ekberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Søren Hauberg
+## Copyright (C) 2009-2012 Søren Hauberg
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ## Copyright (C) 2009-2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott and Jaroslav Hajek
+## Copyright (C) 2008-2012 Ben Abbott and Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/runlength.m b/scripts/statistics/base/runlength.m
--- a/scripts/statistics/base/runlength.m
+++ b/scripts/statistics/base/runlength.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/base/zscore.m
--- a/scripts/statistics/base/zscore.m
+++ b/scripts/statistics/base/zscore.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2010 Christos Dimitrakakis
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1997-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1997-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1997-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1997-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1997-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1997-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidinv.m b/scripts/statistics/distributions/unidinv.m
--- a/scripts/statistics/distributions/unidinv.m
+++ b/scripts/statistics/distributions/unidinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/models/private/logistic_regression_derivatives.m b/scripts/statistics/models/private/logistic_regression_derivatives.m
--- a/scripts/statistics/models/private/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/private/logistic_regression_derivatives.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/models/private/logistic_regression_likelihood.m b/scripts/statistics/models/private/logistic_regression_likelihood.m
--- a/scripts/statistics/models/private/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/private/logistic_regression_likelihood.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 John W. Eaton
+## Copyright (C) 1998-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 Rolf Fabian
+## Copyright (C) 2002-2012 Rolf Fabian
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/strings/strchr.m b/scripts/strings/strchr.m
--- a/scripts/strings/strchr.m
+++ b/scripts/strings/strchr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2003 Alois Schloegl
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Jaroslav Hajek
+## Copyright (C) 2009-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2006-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Paul Kienzle
+## Copyright (C) 2006-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/eomday.m b/scripts/time/eomday.m
--- a/scripts/time/eomday.m
+++ b/scripts/time/eomday.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -1,11 +1,11 @@
 /* Contour lines for function evaluated on a grid.
 
-Copyright (C) 2007-2011 Kai Habel
+Copyright (C) 2007-2012 Kai Habel
 Copyright (C) 2004, 2007 Shai Ayal
 
 Adapted to an oct file from the stand alone contourl by Victro Munoz
 Copyright (C) 2004 Victor Munoz
 
 Based on contour plot routine (plcont.c) in PLPlot package
 http://plplot.org/
 
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Kai Habel
+Copyright (C) 2000-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/DLD-FUNCTIONS/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/DLD-FUNCTIONS/__dispatch__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 John W. Eaton and Paul Kienzle
+Copyright (C) 2001-2012 John W. Eaton and Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 Kai Habel
+Copyright (C) 2010-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Nicolo' Giorgetti
+Copyright (C) 2005-2012 Nicolo' Giorgetti
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Shai Ayal
+Copyright (C) 2007-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -30,16 +30,19 @@ To initialize:
 */
 
 // PKG_ADD: register_graphics_toolkit ("fltk");
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "defun-dld.h"
+#include "error.h"
+
 #if defined (HAVE_FLTK)
 
 #include <map>
 #include <set>
 #include <sstream>
 #include <iostream>
 
 #ifdef WIN32
@@ -64,18 +67,16 @@ To initialize:
 // conflicts with Octave's Complex typedef.  We don't need the X11
 // Complex definition in this file, so remove it before including Octave
 // headers which may require Octave's Complex typedef.
 #undef Complex
 
 #include "cmd-edit.h"
 #include "lo-ieee.h"
 
-#include "defun-dld.h"
-#include "error.h"
 #include "file-ops.h"
 #include "gl-render.h"
 #include "gl2ps-renderer.h"
 #include "graphics.h"
 #include "parse.h"
 #include "sysdep.h"
 #include "toplev.h"
 #include "variables.h"
@@ -1999,16 +2000,18 @@ DEFUN_DLD (__fltk_maxtime__, args, ,"")
         fltk_maxtime = args(0).double_value ();
       else
         error ("argument must be a real scalar");
     }
 
   return retval;
 }
 
+#endif
+
 // FIXME -- This function should be abstracted and made potentially
 // available to all graphics toolkits.  This suggests putting it in
 // graphics.cc as is done for drawnow() and having the master
 // mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
 // should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
 // just changing function names and docstrings.
 
 DEFUN_DLD (mouse_wheel_zoom, args, ,
@@ -2016,27 +2019,32 @@ DEFUN_DLD (mouse_wheel_zoom, args, ,
 @deftypefn  {Built-in Function} {@var{speed} =} mouse_wheel_zoom ()\n\
 @deftypefnx {Built-in Function} {} mouse_wheel_zoom (@var{speed})\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{gui_mode}\n\
 @end deftypefn")
 {
+#if defined (HAVE_FLTK)
   octave_value retval = wheel_zoom_speed;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         wheel_zoom_speed = args(0).double_value ();
       else
         error ("mouse_wheel_zoom: SPEED must be a real scalar");
     }
 
   return retval;
+#else 
+  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
 DEFUN_DLD (gui_mode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{mode} =} gui_mode ()\n\
 @deftypefnx {Built-in Function} {} gui_mode (@var{mode})\n\
 Query or set the GUI mode for the current graphics toolkit.\n\
 The @var{mode} argument can be one of the following strings:\n\
@@ -2050,16 +2058,17 @@ Allows rotating and zooming of current a
 @item 'none'\n\
 Mouse inputs have no effect.\n\
 @end table\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{mouse_wheel_zoom}\n\
 @end deftypefn")
 {
+#if defined (HAVE_FLTK)
   caseless_str mode_str;
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
   else if (gui_mode == rotate_zoom)
     mode_str = "3d";
   else
     mode_str = "none";
@@ -2084,11 +2093,14 @@ This function is currently implemented o
       else
         failed = true;
     }
 
   if (failed)
     error ("MODE must be one of the strings: \"2D\", \"3D\", or \"none\"");
 
   return octave_value (mode_str);
+#else
+  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
-#endif
diff --git a/src/DLD-FUNCTIONS/__init_gnuplot__.cc b/src/DLD-FUNCTIONS/__init_gnuplot__.cc
--- a/src/DLD-FUNCTIONS/__init_gnuplot__.cc
+++ b/src/DLD-FUNCTIONS/__init_gnuplot__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Alexander Barth
+Copyright (C) 2007-2012 Alexander Barth
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 Andy Adler
+Copyright (C) 2002-2012 Andy Adler
 Copyright (C) 2008 Thomas L. Scofield
 Copyright (C) 2010 David Grundberg
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -207,17 +207,18 @@ read_images (const std::vector<Magick::I
   dim_vector idim = dim_vector ();
   idim.resize (4);
   idim(0) = rows;
   idim(1) = columns;
   idim(2) = 1;
   idim(3) = nframes;
 
   Magick::ImageType type = imvec[0].type ();
-  const int divisor = (((1 << QuantumDepth) - 1) / ((1 << depth) - 1));
+  const int divisor = ((uint64_t (1) << QuantumDepth) - 1) / 
+                      ((uint64_t (1) << depth) - 1);
 
   switch (type)
     {
     case Magick::BilevelType:
     case Magick::GrayscaleType:
       {
         im = T (idim);
         P *vec = im.fortran_vec ();
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 Kai Habel
+Copyright (C) 2002-2012 Kai Habel
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Gabriele Pannocchia
+Copyright (C) 2000-2012 Gabriele Pannocchia
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Kai Habel
+Copyright (C) 2000-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2008-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -307,18 +307,18 @@ update_index (Array<int>& idx, const dim
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
-The binary singleton expansion function applier does what its name\n\
-suggests: applies a binary function @var{f} element-by-element to two\n\
+The binary singleton expansion function applier performs broadcasting,\n\
+that is, applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.  @var{f} is a function\n\
 handle, inline function, or string containing the name of the function\n\
 to evaluate.  The function @var{f} must be capable of accepting two\n\
 column-vector arguments of equal length, or one column vector argument\n\
 and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 2005-2011 Mohamed Kamoun
-Copyright (C) 2006-2011 Bill Denney
+Copyright (C) 2005-2012 Mohamed Kamoun
+Copyright (C) 2006-2012 Bill Denney
 Copyright (C) 2009 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -360,16 +360,31 @@ of the element that caused the error.  F
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (\"factorial\", @{-1,2@}, 'ErrorHandler', @@foo)\n\
 @result{} ans = [NaN 2]\n\
 @end group\n\
 @end example\n\
 \n\
+Use @code{cellfun} intelligently.  The @code{cellfun} function is a\n\
+useful tool for avoiding loops.  It is often used with anonymous\n\
+function handles; however, calling an anonymous function involves an\n\
+overhead quite comparable to the overhead of an m-file function.\n\
+Passing a handle to a built-in function is faster, because the\n\
+interpreter is not involved in the internal loop.  For example:\n\
+\n\
+@example\n\
+@group\n\
+a = @{@dots{}@}\n\
+v = cellfun (@@(x) det(x), a); # compute determinants\n\
+v = cellfun (@@det, a); # faster\n\
+@end group\n\
+@end example\n\
+\n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2008-2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 Andy Adler
+Copyright (C) 1999-2012 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Kai Habel
+Copyright (C) 2000-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jonathan Stickel
+Copyright (C) 2008-2012 Jonathan Stickel
 Copyright (C) 2010 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 VZLU Prague
+Copyright (C) 2009-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -299,17 +299,17 @@ Any other value indicates a failure to c
 This function is based on the @sc{arpack} package, written by R. Lehoucq,\n\
 K. Maschhoff, D. Sorensen, and C. Yang.  For more information see\n\
 @url{http://www.caam.rice.edu/software/ARPACK/}.\n\
 \n\
 @seealso{eig, svds}\n\
 @end deftypefn")
 {
   octave_value_list retval;
-
+#ifdef HAVE_ARPACK
   int nargin = args.length ();
   std::string fcn_name;
   octave_idx_type n = 0;
   octave_idx_type k = 6;
   Complex sigma = 0.;
   double sigmar, sigmai;
   bool have_sigma = false;
   std::string typ = "LM";
@@ -754,16 +754,19 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
         warning ("eigs: None of the %d requested eigenvalues converged", k);
       else if (nconv < k)
         warning ("eigs: Only %d of the %d requested eigenvalues converged",
                  nconv, k);
     }
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
+#else
+  error ("eigs: not available in this version of Octave");
+#endif
 
   return retval;
 }
 
 /* #### SPARSE MATRIX VERSIONS #### */
 
 /*
 
@@ -772,55 +775,55 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! n = 20;
 %! k = 4;
 %! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
 %! d0 = eig (A);
 %! d2 = sort (d0);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'la');
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sa');
 %! assert (d1, d2(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'be');
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1, 'be');
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
 %!testif HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
 %!testif HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
@@ -828,61 +831,61 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!testif HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
 %!testif HAVE_UMFPACK
 %! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
 %!testif HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (d1, eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! AA = speye (10);
 %! fn = @(x) AA * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! assert (eigs (fn, 10, AA, 3, 'lm', opts), [1; 1; 1],10*eps);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 %!testif HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'la');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sa');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'be');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -892,62 +895,62 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A =  sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(d0));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
 %!testif HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
 %!testif HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
@@ -957,62 +960,62 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
 %!testif HAVE_UMFPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
 %!testif HAVE_UMFPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
 %!testif HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 %!testif HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1022,62 +1025,62 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
 %!testif HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
 %!testif HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
@@ -1089,62 +1092,62 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
 %!testif HAVE_UMFPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
 %!testif HAVE_UMFPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
 %!testif HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 %!testif HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1157,112 +1160,112 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! n = 20;
 %! k = 4;
 %! A = full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
 %! d0 = eig (A);
 %! d2 = sort (d0);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'la');
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sa');
 %! assert (d1, d2(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'be');
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1, 'be');
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs(A, eye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (eigs(A,k,4.1), eigs(A,eye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (eigs(A,k,4.1), eigs(A,eye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (d1, eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'la');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sa');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'be');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1272,127 +1275,127 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A =  full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(d0));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs(A, eye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,eye(n),k,4.1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,eye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1402,128 +1405,128 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs(A, eye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,eye(n),k,4.1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,eye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 David Bateman
+Copyright (C) 1997-2012 David Bateman
 Copyright (C) 1996-1997 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 David Bateman
+Copyright (C) 1997-2012 David Bateman
 Copyright (C) 1996-1997 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 2010 Jaroslav Hajek, Jordi Gutiérrez Hermoso
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2008-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague a.s., Czech Republic
+Copyright (C) 2008-2012 VZLU Prague a.s., Czech Republic
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or (at
 your option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/DLD-FUNCTIONS/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/DLD-FUNCTIONS/mgorth.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Carlo de Falco
+Copyright (C) 2009-2012 Carlo de Falco
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/module-files b/src/DLD-FUNCTIONS/module-files
--- a/src/DLD-FUNCTIONS/module-files
+++ b/src/DLD-FUNCTIONS/module-files
@@ -27,17 +27,17 @@ convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_L
 daspk.cc
 dasrt.cc
 dassl.cc
 det.cc
 dlmread.cc
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 dot.cc
 eig.cc
-eigs.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
+eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
 fft.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fft2.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftn.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 filter.cc
 find.cc
 gammainc.cc
 gcd.cc
diff --git a/src/DLD-FUNCTIONS/nproc.cc b/src/DLD-FUNCTIONS/nproc.cc
--- a/src/DLD-FUNCTIONS/nproc.cc
+++ b/src/DLD-FUNCTIONS/nproc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Iain Murray
+Copyright (C) 2012 Iain Murray
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/oct-qhull.h b/src/DLD-FUNCTIONS/oct-qhull.h
--- a/src/DLD-FUNCTIONS/oct-qhull.h
+++ b/src/DLD-FUNCTIONS/oct-qhull.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -169,23 +169,24 @@ where @code{sigma_max (@var{x})} is the 
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
 %! a = reshape (rand*[1:16], 4, 4);   ## Rank 2 matrix
 %! b = pinv (a);
-%! tol = 1e-14;
-%! hitol = 15*sqrt(eps);
+%! tol = 4e-14;
+%! hitol = 40*sqrt (eps);
 %! d = diag ([rand, rand, hitol, hitol]);
 %! u = rand (4);                      ## Could be singular by freak accident
 %! x = inv (u)*d*u;
-%! y = pinv (x, sqrt(eps));
-%!assert(a*b*a, a, tol);
-%!assert(b*a*b, b, tol);
-%!assert((b*a)', b*a, tol);
-%!assert((a*b)', a*b, tol);
-%!assert(x*y*x, x, -hitol);
-%!assert(y*x*y, y, -hitol);
-%!assert((x*y)', x*y, hitol);
-%!assert((y*x)', y*x, hitol);
+%! y = pinv (x, sqrt (eps));
+%!
+%!assert (a*b*a, a, tol)
+%!assert (b*a*b, b, tol)
+%!assert ((b*a)', b*a, tol)
+%!assert ((a*b)', a*b, tol)
+%!assert (x*y*x, x, -hitol)
+%!assert (y*x*y, y, -hitol)
+%!assert ((x*y)', x*y, hitol)
+%!assert ((y*x)', y*x, hitol)
 */
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2008-2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 Pedro Gonnet
+Copyright (C) 2010-2012 Pedro Gonnet
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -26,21 +26,16 @@ along with Octave; see the file COPYING.
 
 #include <stdlib.h>
 #include "lo-math.h"
 #include "lo-ieee.h"
 #include "oct.h"
 #include "parse.h"
 #include "ov-fcn-handle.h"
 
-#if ! defined (HAVE_COPYSIGN) && defined (HAVE__COPYSIGN)
-#define copysign _copysign
-#define HAVE_COPYSIGN 1
-#endif
-
 /* Define the size of the interval heap. */
 #define cquad_heapsize                  200
 
 
 /* Data of a single interval */
 typedef struct
 {
   double a, b;
@@ -1650,17 +1645,17 @@ Mathematical Software, Vol. 37, Issue 3,
     }
 
   /* If a or b are +/-Inf, transform the integral. */
   if (xisinf (a) || xisinf (b))
     {
       wrap = true;
       for (i = 0; i <= nivals; i++)
         if (xisinf (iivals[i]))
-          iivals[i] = copysign (1.0, iivals[i]);
+          iivals[i] = gnulib::copysign (1.0, iivals[i]);
         else
           iivals[i] = 2.0 * atan (iivals[i]) / M_PI;
     }
 
 
   /* Initialize the heaps. */
   for (i = 0; i < cquad_heapsize; i++)
     heap[i] = i;
@@ -2015,17 +2010,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivl->err = ncdiff * h;
           /* Check for divergence. */
           ivl->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivl->c[0] / iv->c[0] > 2);
           if (ivl->ndiv > ndiv_max && 2 * ivl->ndiv > ivl->rdepth)
             {
-              igral = copysign (octave_Inf, igral);
+              igral = gnulib::copysign (octave_Inf, igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           /* Compute the local integral. */
           ivl->igral = h * w * ivl->c[0];
 
 
@@ -2111,17 +2106,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivr->err = ncdiff * h;
           /* Check for divergence. */
           ivr->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivr->c[0] / iv->c[0] > 2);
           if (ivr->ndiv > ndiv_max && 2 * ivr->ndiv > ivr->rdepth)
             {
-              igral = copysign (octave_Inf, igral);
+              igral = gnulib::copysign (octave_Inf, igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           /* Compute the local integral. */
           ivr->igral = h * w * ivr->c[0];
 
 
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1998-2011 A. S. Hodel
+Copyright (C) 1998-2012 A. S. Hodel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2008-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 2002-2005 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ross Lippert and Paul Kienzle
+Copyright (C) 2001-2012 Ross Lippert and Paul Kienzle
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 Jaroslav Hajek
+Copyright (C) 2010-2012 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 VZLU Prague
+Copyright (C) 2009-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Michael Weitzel
+Copyright (C) 2007-2012 Michael Weitzel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 Andreas Stahel
+Copyright (C) 2002-2012 Andreas Stahel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -1,12 +1,12 @@
 // urlwrite and urlread, a curl front-end for octave
 /*
 
-Copyright (C) 2006-2011 Alexander Barth
+Copyright (C) 2006-2012 Alexander Barth
 Copyright (C) 2009 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's src directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/src/OPERATORS/op-b-b.cc b/src/OPERATORS/op-b-b.cc
--- a/src/OPERATORS/op-b-b.cc
+++ b/src/OPERATORS/op-b-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-b-bm.cc b/src/OPERATORS/op-b-bm.cc
--- a/src/OPERATORS/op-b-bm.cc
+++ b/src/OPERATORS/op-b-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-b-sbm.cc b/src/OPERATORS/op-b-sbm.cc
--- a/src/OPERATORS/op-b-sbm.cc
+++ b/src/OPERATORS/op-b-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-bm-b.cc b/src/OPERATORS/op-bm-b.cc
--- a/src/OPERATORS/op-bm-b.cc
+++ b/src/OPERATORS/op-bm-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Cai Jianming
+Copyright (C) 2001-2012 Cai Jianming
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-bm-bm.cc b/src/OPERATORS/op-bm-bm.cc
--- a/src/OPERATORS/op-bm-bm.cc
+++ b/src/OPERATORS/op-bm-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-bm-sbm.cc b/src/OPERATORS/op-bm-sbm.cc
--- a/src/OPERATORS/op-bm-sbm.cc
+++ b/src/OPERATORS/op-bm-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cdm-cdm.cc b/src/OPERATORS/op-cdm-cdm.cc
--- a/src/OPERATORS/op-cdm-cdm.cc
+++ b/src/OPERATORS/op-cdm-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-cm.cc b/src/OPERATORS/op-cdm-cm.cc
--- a/src/OPERATORS/op-cdm-cm.cc
+++ b/src/OPERATORS/op-cdm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-cs.cc b/src/OPERATORS/op-cdm-cs.cc
--- a/src/OPERATORS/op-cdm-cs.cc
+++ b/src/OPERATORS/op-cdm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-dm.cc b/src/OPERATORS/op-cdm-dm.cc
--- a/src/OPERATORS/op-cdm-dm.cc
+++ b/src/OPERATORS/op-cdm-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-m.cc b/src/OPERATORS/op-cdm-m.cc
--- a/src/OPERATORS/op-cdm-m.cc
+++ b/src/OPERATORS/op-cdm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-s.cc b/src/OPERATORS/op-cdm-s.cc
--- a/src/OPERATORS/op-cdm-s.cc
+++ b/src/OPERATORS/op-cdm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cell.cc b/src/OPERATORS/op-cell.cc
--- a/src/OPERATORS/op-cell.cc
+++ b/src/OPERATORS/op-cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-class.cc b/src/OPERATORS/op-class.cc
--- a/src/OPERATORS/op-class.cc
+++ b/src/OPERATORS/op-class.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-cdm.cc b/src/OPERATORS/op-cm-cdm.cc
--- a/src/OPERATORS/op-cm-cdm.cc
+++ b/src/OPERATORS/op-cm-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-cs.cc b/src/OPERATORS/op-cm-cs.cc
--- a/src/OPERATORS/op-cm-cs.cc
+++ b/src/OPERATORS/op-cm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-dm.cc b/src/OPERATORS/op-cm-dm.cc
--- a/src/OPERATORS/op-cm-dm.cc
+++ b/src/OPERATORS/op-cm-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-m.cc b/src/OPERATORS/op-cm-m.cc
--- a/src/OPERATORS/op-cm-m.cc
+++ b/src/OPERATORS/op-cm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-pm.cc b/src/OPERATORS/op-cm-pm.cc
--- a/src/OPERATORS/op-cm-pm.cc
+++ b/src/OPERATORS/op-cm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-s.cc b/src/OPERATORS/op-cm-s.cc
--- a/src/OPERATORS/op-cm-s.cc
+++ b/src/OPERATORS/op-cm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cs-cm.cc b/src/OPERATORS/op-cs-cm.cc
--- a/src/OPERATORS/op-cs-cm.cc
+++ b/src/OPERATORS/op-cs-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-cs.cc b/src/OPERATORS/op-cs-cs.cc
--- a/src/OPERATORS/op-cs-cs.cc
+++ b/src/OPERATORS/op-cs-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-m.cc b/src/OPERATORS/op-cs-m.cc
--- a/src/OPERATORS/op-cs-m.cc
+++ b/src/OPERATORS/op-cs-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-s.cc b/src/OPERATORS/op-cs-s.cc
--- a/src/OPERATORS/op-cs-s.cc
+++ b/src/OPERATORS/op-cs-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-dm-cdm.cc b/src/OPERATORS/op-dm-cdm.cc
--- a/src/OPERATORS/op-dm-cdm.cc
+++ b/src/OPERATORS/op-dm-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-cm.cc b/src/OPERATORS/op-dm-cm.cc
--- a/src/OPERATORS/op-dm-cm.cc
+++ b/src/OPERATORS/op-dm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-cs.cc b/src/OPERATORS/op-dm-cs.cc
--- a/src/OPERATORS/op-dm-cs.cc
+++ b/src/OPERATORS/op-dm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-dm.cc b/src/OPERATORS/op-dm-dm.cc
--- a/src/OPERATORS/op-dm-dm.cc
+++ b/src/OPERATORS/op-dm-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-m.cc b/src/OPERATORS/op-dm-m.cc
--- a/src/OPERATORS/op-dm-m.cc
+++ b/src/OPERATORS/op-dm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-s.cc b/src/OPERATORS/op-dm-s.cc
--- a/src/OPERATORS/op-dm-s.cc
+++ b/src/OPERATORS/op-dm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-scm.cc b/src/OPERATORS/op-dm-scm.cc
--- a/src/OPERATORS/op-dm-scm.cc
+++ b/src/OPERATORS/op-dm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy, Jaroslav Hajek
+Copyright (C) 2009-2012 Jason Riedy, Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-sm.cc b/src/OPERATORS/op-dm-sm.cc
--- a/src/OPERATORS/op-dm-sm.cc
+++ b/src/OPERATORS/op-dm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy, Jaroslav Hajek
+Copyright (C) 2009-2012 Jason Riedy, Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-template.cc b/src/OPERATORS/op-dm-template.cc
--- a/src/OPERATORS/op-dm-template.cc
+++ b/src/OPERATORS/op-dm-template.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dms-template.cc b/src/OPERATORS/op-dms-template.cc
--- a/src/OPERATORS/op-dms-template.cc
+++ b/src/OPERATORS/op-dms-template.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-double-conv.cc b/src/OPERATORS/op-double-conv.cc
--- a/src/OPERATORS/op-double-conv.cc
+++ b/src/OPERATORS/op-double-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fcdm.cc b/src/OPERATORS/op-fcdm-fcdm.cc
--- a/src/OPERATORS/op-fcdm-fcdm.cc
+++ b/src/OPERATORS/op-fcdm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fcm.cc b/src/OPERATORS/op-fcdm-fcm.cc
--- a/src/OPERATORS/op-fcdm-fcm.cc
+++ b/src/OPERATORS/op-fcdm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fcs.cc b/src/OPERATORS/op-fcdm-fcs.cc
--- a/src/OPERATORS/op-fcdm-fcs.cc
+++ b/src/OPERATORS/op-fcdm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fdm.cc b/src/OPERATORS/op-fcdm-fdm.cc
--- a/src/OPERATORS/op-fcdm-fdm.cc
+++ b/src/OPERATORS/op-fcdm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fm.cc b/src/OPERATORS/op-fcdm-fm.cc
--- a/src/OPERATORS/op-fcdm-fm.cc
+++ b/src/OPERATORS/op-fcdm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fs.cc b/src/OPERATORS/op-fcdm-fs.cc
--- a/src/OPERATORS/op-fcdm-fs.cc
+++ b/src/OPERATORS/op-fcdm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fcdm.cc b/src/OPERATORS/op-fcm-fcdm.cc
--- a/src/OPERATORS/op-fcm-fcdm.cc
+++ b/src/OPERATORS/op-fcm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fcs.cc b/src/OPERATORS/op-fcm-fcs.cc
--- a/src/OPERATORS/op-fcm-fcs.cc
+++ b/src/OPERATORS/op-fcm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fdm.cc b/src/OPERATORS/op-fcm-fdm.cc
--- a/src/OPERATORS/op-fcm-fdm.cc
+++ b/src/OPERATORS/op-fcm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fm.cc b/src/OPERATORS/op-fcm-fm.cc
--- a/src/OPERATORS/op-fcm-fm.cc
+++ b/src/OPERATORS/op-fcm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fs.cc b/src/OPERATORS/op-fcm-fs.cc
--- a/src/OPERATORS/op-fcm-fs.cc
+++ b/src/OPERATORS/op-fcm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-pm.cc b/src/OPERATORS/op-fcm-pm.cc
--- a/src/OPERATORS/op-fcm-pm.cc
+++ b/src/OPERATORS/op-fcm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcn.cc b/src/OPERATORS/op-fcn.cc
--- a/src/OPERATORS/op-fcn.cc
+++ b/src/OPERATORS/op-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fcm.cc b/src/OPERATORS/op-fcs-fcm.cc
--- a/src/OPERATORS/op-fcs-fcm.cc
+++ b/src/OPERATORS/op-fcs-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fcs.cc b/src/OPERATORS/op-fcs-fcs.cc
--- a/src/OPERATORS/op-fcs-fcs.cc
+++ b/src/OPERATORS/op-fcs-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fm.cc b/src/OPERATORS/op-fcs-fm.cc
--- a/src/OPERATORS/op-fcs-fm.cc
+++ b/src/OPERATORS/op-fcs-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fs.cc b/src/OPERATORS/op-fcs-fs.cc
--- a/src/OPERATORS/op-fcs-fs.cc
+++ b/src/OPERATORS/op-fcs-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fcdm.cc b/src/OPERATORS/op-fdm-fcdm.cc
--- a/src/OPERATORS/op-fdm-fcdm.cc
+++ b/src/OPERATORS/op-fdm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fcm.cc b/src/OPERATORS/op-fdm-fcm.cc
--- a/src/OPERATORS/op-fdm-fcm.cc
+++ b/src/OPERATORS/op-fdm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fcs.cc b/src/OPERATORS/op-fdm-fcs.cc
--- a/src/OPERATORS/op-fdm-fcs.cc
+++ b/src/OPERATORS/op-fdm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fdm.cc b/src/OPERATORS/op-fdm-fdm.cc
--- a/src/OPERATORS/op-fdm-fdm.cc
+++ b/src/OPERATORS/op-fdm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fm.cc b/src/OPERATORS/op-fdm-fm.cc
--- a/src/OPERATORS/op-fdm-fm.cc
+++ b/src/OPERATORS/op-fdm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fs.cc b/src/OPERATORS/op-fdm-fs.cc
--- a/src/OPERATORS/op-fdm-fs.cc
+++ b/src/OPERATORS/op-fdm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-float-conv.cc b/src/OPERATORS/op-float-conv.cc
--- a/src/OPERATORS/op-float-conv.cc
+++ b/src/OPERATORS/op-float-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fcdm.cc b/src/OPERATORS/op-fm-fcdm.cc
--- a/src/OPERATORS/op-fm-fcdm.cc
+++ b/src/OPERATORS/op-fm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fcm.cc b/src/OPERATORS/op-fm-fcm.cc
--- a/src/OPERATORS/op-fm-fcm.cc
+++ b/src/OPERATORS/op-fm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fcs.cc b/src/OPERATORS/op-fm-fcs.cc
--- a/src/OPERATORS/op-fm-fcs.cc
+++ b/src/OPERATORS/op-fm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fdm.cc b/src/OPERATORS/op-fm-fdm.cc
--- a/src/OPERATORS/op-fm-fdm.cc
+++ b/src/OPERATORS/op-fm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fs.cc b/src/OPERATORS/op-fm-fs.cc
--- a/src/OPERATORS/op-fm-fs.cc
+++ b/src/OPERATORS/op-fm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-pm.cc b/src/OPERATORS/op-fm-pm.cc
--- a/src/OPERATORS/op-fm-pm.cc
+++ b/src/OPERATORS/op-fm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fcm.cc b/src/OPERATORS/op-fs-fcm.cc
--- a/src/OPERATORS/op-fs-fcm.cc
+++ b/src/OPERATORS/op-fs-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fcs.cc b/src/OPERATORS/op-fs-fcs.cc
--- a/src/OPERATORS/op-fs-fcs.cc
+++ b/src/OPERATORS/op-fs-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fm.cc b/src/OPERATORS/op-fs-fm.cc
--- a/src/OPERATORS/op-fs-fm.cc
+++ b/src/OPERATORS/op-fs-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fs.cc b/src/OPERATORS/op-fs-fs.cc
--- a/src/OPERATORS/op-fs-fs.cc
+++ b/src/OPERATORS/op-fs-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i16-i16.cc b/src/OPERATORS/op-i16-i16.cc
--- a/src/OPERATORS/op-i16-i16.cc
+++ b/src/OPERATORS/op-i16-i16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i32-i32.cc b/src/OPERATORS/op-i32-i32.cc
--- a/src/OPERATORS/op-i32-i32.cc
+++ b/src/OPERATORS/op-i32-i32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i64-i64.cc b/src/OPERATORS/op-i64-i64.cc
--- a/src/OPERATORS/op-i64-i64.cc
+++ b/src/OPERATORS/op-i64-i64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i8-i8.cc b/src/OPERATORS/op-i8-i8.cc
--- a/src/OPERATORS/op-i8-i8.cc
+++ b/src/OPERATORS/op-i8-i8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-int-concat.cc b/src/OPERATORS/op-int-concat.cc
--- a/src/OPERATORS/op-int-concat.cc
+++ b/src/OPERATORS/op-int-concat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-int-conv.cc b/src/OPERATORS/op-int-conv.cc
--- a/src/OPERATORS/op-int-conv.cc
+++ b/src/OPERATORS/op-int-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-cdm.cc b/src/OPERATORS/op-m-cdm.cc
--- a/src/OPERATORS/op-m-cdm.cc
+++ b/src/OPERATORS/op-m-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-cm.cc b/src/OPERATORS/op-m-cm.cc
--- a/src/OPERATORS/op-m-cm.cc
+++ b/src/OPERATORS/op-m-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-cs.cc b/src/OPERATORS/op-m-cs.cc
--- a/src/OPERATORS/op-m-cs.cc
+++ b/src/OPERATORS/op-m-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-dm.cc b/src/OPERATORS/op-m-dm.cc
--- a/src/OPERATORS/op-m-dm.cc
+++ b/src/OPERATORS/op-m-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-pm.cc b/src/OPERATORS/op-m-pm.cc
--- a/src/OPERATORS/op-m-pm.cc
+++ b/src/OPERATORS/op-m-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-s.cc b/src/OPERATORS/op-m-s.cc
--- a/src/OPERATORS/op-m-s.cc
+++ b/src/OPERATORS/op-m-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-pm-cm.cc b/src/OPERATORS/op-pm-cm.cc
--- a/src/OPERATORS/op-pm-cm.cc
+++ b/src/OPERATORS/op-pm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-fcm.cc b/src/OPERATORS/op-pm-fcm.cc
--- a/src/OPERATORS/op-pm-fcm.cc
+++ b/src/OPERATORS/op-pm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-fm.cc b/src/OPERATORS/op-pm-fm.cc
--- a/src/OPERATORS/op-pm-fm.cc
+++ b/src/OPERATORS/op-pm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-m.cc b/src/OPERATORS/op-pm-m.cc
--- a/src/OPERATORS/op-pm-m.cc
+++ b/src/OPERATORS/op-pm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-pm.cc b/src/OPERATORS/op-pm-pm.cc
--- a/src/OPERATORS/op-pm-pm.cc
+++ b/src/OPERATORS/op-pm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-scm.cc b/src/OPERATORS/op-pm-scm.cc
--- a/src/OPERATORS/op-pm-scm.cc
+++ b/src/OPERATORS/op-pm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy
+Copyright (C) 2009-2012 Jason Riedy
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy
+Copyright (C) 2009-2012 Jason Riedy
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-template.cc b/src/OPERATORS/op-pm-template.cc
--- a/src/OPERATORS/op-pm-template.cc
+++ b/src/OPERATORS/op-pm-template.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-range.cc b/src/OPERATORS/op-range.cc
--- a/src/OPERATORS/op-range.cc
+++ b/src/OPERATORS/op-range.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-cm.cc b/src/OPERATORS/op-s-cm.cc
--- a/src/OPERATORS/op-s-cm.cc
+++ b/src/OPERATORS/op-s-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-cs.cc b/src/OPERATORS/op-s-cs.cc
--- a/src/OPERATORS/op-s-cs.cc
+++ b/src/OPERATORS/op-s-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-m.cc b/src/OPERATORS/op-s-m.cc
--- a/src/OPERATORS/op-s-m.cc
+++ b/src/OPERATORS/op-s-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-s.cc b/src/OPERATORS/op-s-s.cc
--- a/src/OPERATORS/op-s-s.cc
+++ b/src/OPERATORS/op-s-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sbm-b.cc b/src/OPERATORS/op-sbm-b.cc
--- a/src/OPERATORS/op-sbm-b.cc
+++ b/src/OPERATORS/op-sbm-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sbm-bm.cc b/src/OPERATORS/op-sbm-bm.cc
--- a/src/OPERATORS/op-sbm-bm.cc
+++ b/src/OPERATORS/op-sbm-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sbm-sbm.cc b/src/OPERATORS/op-sbm-sbm.cc
--- a/src/OPERATORS/op-sbm-sbm.cc
+++ b/src/OPERATORS/op-sbm-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-str-m.cc b/src/OPERATORS/op-str-m.cc
--- a/src/OPERATORS/op-str-m.cc
+++ b/src/OPERATORS/op-str-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-str-s.cc b/src/OPERATORS/op-str-s.cc
--- a/src/OPERATORS/op-str-s.cc
+++ b/src/OPERATORS/op-str-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-struct.cc b/src/OPERATORS/op-struct.cc
--- a/src/OPERATORS/op-struct.cc
+++ b/src/OPERATORS/op-struct.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui16-ui16.cc b/src/OPERATORS/op-ui16-ui16.cc
--- a/src/OPERATORS/op-ui16-ui16.cc
+++ b/src/OPERATORS/op-ui16-ui16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui32-ui32.cc b/src/OPERATORS/op-ui32-ui32.cc
--- a/src/OPERATORS/op-ui32-ui32.cc
+++ b/src/OPERATORS/op-ui32-ui32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui64-ui64.cc b/src/OPERATORS/op-ui64-ui64.cc
--- a/src/OPERATORS/op-ui64-ui64.cc
+++ b/src/OPERATORS/op-ui64-ui64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui8-ui8.cc b/src/OPERATORS/op-ui8-ui8.cc
--- a/src/OPERATORS/op-ui8-ui8.cc
+++ b/src/OPERATORS/op-ui8-ui8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/TEMPLATE-INST/Array-os.cc b/src/TEMPLATE-INST/Array-os.cc
--- a/src/TEMPLATE-INST/Array-os.cc
+++ b/src/TEMPLATE-INST/Array-os.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/TEMPLATE-INST/Array-sym.cc b/src/TEMPLATE-INST/Array-sym.cc
--- a/src/TEMPLATE-INST/Array-sym.cc
+++ b/src/TEMPLATE-INST/Array-sym.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/TEMPLATE-INST/Array-tc.cc b/src/TEMPLATE-INST/Array-tc.cc
--- a/src/TEMPLATE-INST/Array-tc.cc
+++ b/src/TEMPLATE-INST/Array-tc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/cutils.c b/src/cutils.c
--- a/src/cutils.c
+++ b/src/cutils.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/cutils.h b/src/cutils.h
--- a/src/cutils.h
+++ b/src/cutils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -3922,16 +3922,19 @@ val = zeros (m,n, \"uint8\")\n\
 %!assert(zeros (2, 3,'int8'), int8([0, 0, 0; 0, 0, 0]));
 %!assert(zeros (3, 2,'int8'), int8([0, 0; 0, 0; 0, 0]));
 %!assert(size (zeros (3, 4, 5, 'int8')),  [3, 4, 5]);
 
  */
 
 DEFUN (Inf, args, ,
   "-*- texinfo -*-\n\
+@c List other form of function in documentation index\n\
+@findex inf\n\
+\n\
 @deftypefn  {Built-in Function} {} Inf\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the IEEE representation for positive infinity.\n\
 \n\
@@ -3979,16 +3982,19 @@ DEFALIAS (inf, Inf);
 %!error(inf (2, 3,'int8'));
 %!error(inf (3, 2,'int8'));
 %!error(inf (3, 4, 5, 'int8'));
 
  */
 
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
+@c List other form of function in documentation index\n\
+@findex nan\n\
+\n\
 @deftypefn  {Built-in Function} {} NaN\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the IEEE symbol NaN (Not a Number).\n\
 NaN is the result of operations which do not produce a well defined numerical\n\
@@ -5594,19 +5600,23 @@ This function and @w{@xcode{x ./ y}} are
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
-@var{y} power.\n\
+@var{y} power.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+\n\
 This function and @w{@xcode{x .^ y}} are equivalent.\n\
-@seealso{mpower}\n\
+@seealso{mpower, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
@@ -6631,29 +6641,34 @@ template <class NDT>
 static NDT
 do_accumdim_sum (const idx_vector& idx, const NDT& vals,
                  int dim = -1, octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
-    error ("accumarray: index out of range");
-
-  dim_vector rdv = vals.dims ();
+    error ("accumdim: index out of range");
+
+  dim_vector vals_dim = vals.dims (), rdv = vals_dim;
+
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim >= rdv.length ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
   NDT retval (rdv, T());
 
+  if (idx.length () != vals_dim(dim))
+    error ("accumdim: dimension mismatch");
+
   retval.idx_add_nd (idx, vals, dim);
+
   return retval;
 }
 
 DEFUN (__accumdim_sum__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/src/data.h b/src/data.h
--- a/src/data.h
+++ b/src/data.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 Copyright (C) 2007-2009 John Swensen
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/debug.h b/src/debug.h
--- a/src/debug.h
+++ b/src/debug.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defaults.h.in b/src/defaults.h.in
--- a/src/defaults.h.in
+++ b/src/defaults.h.in
@@ -1,12 +1,12 @@
 // defaults.h.in
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/dirfns.h b/src/dirfns.h
--- a/src/dirfns.h
+++ b/src/dirfns.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/display.cc b/src/display.cc
--- a/src/display.cc
+++ b/src/display.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/display.h b/src/display.h
--- a/src/display.h
+++ b/src/display.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -1874,16 +1874,19 @@ use @code{fclose} for the same purpose.\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tmpnam", Ftmpnam, args, ,
  "-*- texinfo -*-\n\
+@c List other forms of function in documentation index\n\
+@findex octave_tmp_file_name\n\
+\n\
 @deftypefn  {Built-in Function} {} tmpnam ()\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir})\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir}, @var{prefix})\n\
 Return a unique temporary file name as a string.\n\
 \n\
 If @var{prefix} is omitted, a value of @code{\"oct-\"} is used.\n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 is used.  If @var{dir} is provided, it must exist, otherwise the default\n\
@@ -2173,46 +2176,51 @@ this system.  The name of this directory
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} SEEK_SET ()\n\
 @deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
 @deftypefnx {Built-in Function} {} SEEK_END ()\n\
-Return the value required to request that @code{fseek} perform\n\
+Return the numerical value to pass to @code{fseek} to perform\n\
 one of the following actions:\n\
 @table @code\n\
 @item SEEK_SET\n\
 Position file relative to the beginning.\n\
 \n\
 @item SEEK_CUR\n\
 Position file relative to the current position.\n\
 \n\
 @item SEEK_END\n\
 Position file relative to the end.\n\
 @end table\n\
+@seealso{fseek}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_SET", args, -1);
 }
 
 DEFUNX ("SEEK_CUR", FSEEK_CUR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_CUR ()\n\
-See SEEK_SET.\n\
+Return the numerical value to pass to @code{fseek} to\n\
+position the file pointer relative to the current position.\n\
+@seealso{SEEK_SET, SEEK_END}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_CUR", args, 0);
 }
 
 DEFUNX ("SEEK_END", FSEEK_END, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_END ()\n\
-See SEEK_SET.\n\
+Return the numerical value to pass to @code{fseek} to\n\
+position the file pointer relative to the end of the file.\n\
+@seealso{SEEK_SET, SEEK_CUR}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_END", args, 1);
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args,
              const octave_value& val)
diff --git a/src/file-io.h b/src/file-io.h
--- a/src/file-io.h
+++ b/src/file-io.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/genprops.awk b/src/genprops.awk
--- a/src/genprops.awk
+++ b/src/genprops.awk
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ## 
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ## 
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gl-render.h b/src/gl-render.h
--- a/src/gl-render.h
+++ b/src/gl-render.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Shai Ayal
+Copyright (C) 2009-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gl2ps-renderer.h b/src/gl2ps-renderer.h
--- a/src/gl2ps-renderer.h
+++ b/src/gl2ps-renderer.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Shai Ayal
+Copyright (C) 2009-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -8992,27 +8992,29 @@ gtk_manager::do_get_toolkit (void) const
 
   return retval;
 }
 
 DEFUN (available_graphics_toolkits, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
+@seealso{graphics_toolkit, register_graphics_toolkit}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   return octave_value (gtk_manager::available_toolkits_list ());
 }
 
 DEFUN (register_graphics_toolkit, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} register_graphics_toolkit (@var{toolkit})\n\
 List @var{toolkit} as an available graphics toolkit.\n\
+@seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
 
   if (args.length () == 1)
     {
@@ -9028,16 +9030,17 @@ List @var{toolkit} as an available graph
 
   return retval;
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} loaded_graphics_toolkits ()\n\
 Return a cell array of the currently loaded graphics toolkits.\n\
+@seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   return octave_value (gtk_manager::loaded_toolkits_list ());
 }
 
 DEFUN (drawnow, args, ,
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -234,25 +234,29 @@ Array index or function argument delimit
 @deftypefn {Operator} {} *\n\
 Multiplication operator.\n\
 @seealso{.*, times}\n\
 @end deftypefn"),
 
   pair_type ("**",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} **\n\
-Power operator.\n\
-@seealso{power, ^, .**, .^}\n\
+Power operator.  This may return complex results for real inputs.  Use\n\
+@code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
+real results when possible.\n\
+@seealso{power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("^",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ^\n\
-Power operator.\n\
-@seealso{power, **, .^, .**}\n\
+Power operator.  This may return complex results for real inputs.  Use\n\
+@code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
+real results when possible.\n\
+@seealso{power, **, .^, .**, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("+",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} +\n\
 Addition operator.\n\
 @seealso{plus}\n\
 @end deftypefn"),
@@ -299,25 +303,31 @@ transpose, @emph{not} the complex conjug
 @deftypefn {Operator} {} .*\n\
 Element by element multiplication operator.\n\
 @seealso{*, times}\n\
 @end deftypefn"),
 
   pair_type (".**",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .*\n\
-Element by element power operator.\n\
-@seealso{**, ^, .^, power}\n\
+Element by element power operator.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+@seealso{**, ^, .^, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type (".^",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .^\n\
-Element by element power operator.\n\
-@seealso{.**, ^, **, power}\n\
+Element by element power operator.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+@seealso{.**, ^, **, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("./",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ./\n\
 Element by element right division operator.\n\
 @seealso{/, .\\, rdivide, mrdivide}\n\
 @end deftypefn"),
@@ -612,17 +622,17 @@ endif\n\
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("parfor",
     "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} for @var{i} = @var{range}\n\
+@deftypefn  {Keyword} {} for @var{i} = @var{range}\n\
 @deftypefnx {Keyword} {} for (@var{i} = @var{range}, @var{maxproc})\n\
 Begin a for loop that may execute in parallel.\n\
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -78,16 +78,17 @@ along with Octave; see the file COPYING.
 #include <oct-gperf.h>
 
 #if defined (GNULIB_NAMESPACE)
 // Calls to the following functions appear in the generated output from
 // flex without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define fwrite GNULIB_NAMESPACE::fwrite
+#define isatty GNULIB_NAMESPACE::isatty
 #define malloc GNULIB_NAMESPACE::malloc
 #define realloc GNULIB_NAMESPACE::realloc
 #endif
 
 #if ! (defined (FLEX_SCANNER) \
        && defined (YY_FLEX_MAJOR_VERSION) && YY_FLEX_MAJOR_VERSION >= 2 \
        && defined (YY_FLEX_MINOR_VERSION) && YY_FLEX_MINOR_VERSION >= 5)
 #error lex.l requires flex version 2.5.4 or later
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-ascii-helper.cc b/src/ls-ascii-helper.cc
--- a/src/ls-ascii-helper.cc
+++ b/src/ls-ascii-helper.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Benjamin Lindner
+Copyright (C) 2009-2012 Benjamin Lindner
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-ascii-helper.h b/src/ls-ascii-helper.h
--- a/src/ls-ascii-helper.h
+++ b/src/ls-ascii-helper.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Benjamin Lindner
+Copyright (C) 2009-2012 Benjamin Lindner
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-hdf5.h b/src/ls-hdf5.h
--- a/src/ls-hdf5.h
+++ b/src/ls-hdf5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat-ascii.h b/src/ls-mat-ascii.h
--- a/src/ls-mat-ascii.h
+++ b/src/ls-mat-ascii.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat4.h b/src/ls-mat4.h
--- a/src/ls-mat4.h
+++ b/src/ls-mat4.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat5.h b/src/ls-mat5.h
--- a/src/ls-mat5.h
+++ b/src/ls-mat5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-binary.h b/src/ls-oct-binary.h
--- a/src/ls-oct-binary.h
+++ b/src/ls-oct-binary.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-utils.cc b/src/ls-utils.cc
--- a/src/ls-utils.cc
+++ b/src/ls-utils.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-utils.h b/src/ls-utils.h
--- a/src/ls-utils.h
+++ b/src/ls-utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/main.c b/src/main.c
--- a/src/main.c
+++ b/src/main.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/matherr.c b/src/matherr.c
--- a/src/matherr.c
+++ b/src/matherr.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mex.h b/src/mex.h
--- a/src/mex.h
+++ b/src/mex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Paul Kienzle
+Copyright (C) 2001-2012 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mexproto.h b/src/mexproto.h
--- a/src/mexproto.h
+++ b/src/mexproto.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 Paul Kienzle
+Copyright (C) 2006-2012 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mk-errno-list b/src/mk-errno-list
--- a/src/mk-errno-list
+++ b/src/mk-errno-list
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 2005-2011 John W. Eaton
+# Copyright (C) 2005-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mk-pkg-add b/src/mk-pkg-add
--- a/src/mk-pkg-add
+++ b/src/mk-pkg-add
@@ -1,11 +1,11 @@
 #! /bin/sh -e
 #
-# Copyright (C) 2005-2011 John W. Eaton
+# Copyright (C) 2005-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkdefs b/src/mkdefs
--- a/src/mkdefs
+++ b/src/mkdefs
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkdocs b/src/mkdocs
--- a/src/mkdocs
+++ b/src/mkdocs
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1999-2011 John W. Eaton
+# Copyright (C) 1999-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkgendoc b/src/mkgendoc
--- a/src/mkgendoc
+++ b/src/mkgendoc
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1999-2011 John W. Eaton
+# Copyright (C) 1999-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkoctfile.cc.in b/src/mkoctfile.cc.in
--- a/src/mkoctfile.cc.in
+++ b/src/mkoctfile.cc.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mkoctfile.in b/src/mkoctfile.in
--- a/src/mkoctfile.in
+++ b/src/mkoctfile.in
@@ -1,14 +1,14 @@
 #! /bin/sh
 ##
 ## mkoctfile -- create a .oct file suitable for dynamic linking by
 ## Octave.
 ##
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/src/mkops b/src/mkops
--- a/src/mkops
+++ b/src/mkops
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1997-2011 John W. Eaton
+# Copyright (C) 1997-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mxarray.h.in b/src/mxarray.h.in
--- a/src/mxarray.h.in
+++ b/src/mxarray.h.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Paul Kienzle
+Copyright (C) 2001-2012 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-conf.h.in b/src/oct-conf.h.in
--- a/src/oct-conf.h.in
+++ b/src/oct-conf.h.in
@@ -1,12 +1,12 @@
 // oct-conf.h.in
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -55,16 +55,28 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_ARFLAGS
 #define OCTAVE_CONF_ARFLAGS %OCTAVE_CONF_ARFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_AR
 #define OCTAVE_CONF_AR %OCTAVE_CONF_AR%
 #endif
 
+#ifndef OCTAVE_CONF_ARPACK_CPPFLAGS
+#define OCTAVE_CONF_ARPACK_CPPFLAGS %OCTAVE_CONF_ARPACK_CPPFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_ARPACK_LDFLAGS
+#define OCTAVE_CONF_ARPACK_LDFLAGS %OCTAVE_CONF_ARPACK_LDFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_ARPACK_LIBS
+#define OCTAVE_CONF_ARPACK_LIBS %OCTAVE_CONF_ARPACK_LIBS%
+#endif
+
 #ifndef OCTAVE_CONF_BLAS_LIBS
 #define OCTAVE_CONF_BLAS_LIBS %OCTAVE_CONF_BLAS_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_CAMD_CPPFLAGS
 #define OCTAVE_CONF_CAMD_CPPFLAGS %OCTAVE_CONF_CAMD_CPPFLAGS%
 #endif
 
diff --git a/src/oct-errno.cc.in b/src/oct-errno.cc.in
--- a/src/oct-errno.cc.in
+++ b/src/oct-errno.cc.in
@@ -1,12 +1,12 @@
 // oct-errno.cc.in
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-errno.h b/src/oct-errno.h
--- a/src/oct-errno.h
+++ b/src/oct-errno.h
@@ -1,12 +1,12 @@
 // oct-errno.h.in
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-fstrm.h b/src/oct-fstrm.h
--- a/src/oct-fstrm.h
+++ b/src/oct-fstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-hdf5.h b/src/oct-hdf5.h
--- a/src/oct-hdf5.h
+++ b/src/oct-hdf5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-iostrm.cc b/src/oct-iostrm.cc
--- a/src/oct-iostrm.cc
+++ b/src/oct-iostrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-iostrm.h b/src/oct-iostrm.h
--- a/src/oct-iostrm.h
+++ b/src/oct-iostrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 David Grundberg
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -3607,17 +3607,17 @@ get_help_from_file (const std::string& n
   std::string retval;
 
   file = fcn_file_in_path (nm);
 
   if (! file.empty ())
     {
       symbol_found = true;
 
-      FILE *fptr = fopen (file.c_str (), "r");
+      FILE *fptr = gnulib::fopen (file.c_str (), "r");
 
       if (fptr)
         {
           unwind_protect frame;
           frame.add_fcn (safe_fclose, fptr);
 
           bool eof;
           retval = gobble_leading_white_space (fptr, eof);
@@ -4443,17 +4443,18 @@ cleanup_statement_list (tree_statement_l
     {
       delete *lst;
       *lst = 0;
     }
 }
 
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} eval (@var{try}, @var{catch})\n\
+@deftypefn  {Built-in Function} {} eval (@var{try})\n\
+@deftypefnx {Built-in Function} {} eval (@var{try}, @var{catch})\n\
 Parse the string @var{try} and evaluate it as if it were an Octave\n\
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
 \n\
 The following example makes the variable @var{a} with the approximate\n\
 value 3.1416 available.\n\
 \n\
@@ -4467,16 +4468,21 @@ string is evaluated, as the following ex
 @example\n\
 @group\n\
 eval ('error (\"This is a bad example\");',\n\
       'printf (\"This error occurred:\\n%s\\n\", lasterr ());');\n\
      @print{} This error occurred:\n\
         This is a bad example\n\
 @end group\n\
 @end example\n\
+\n\
+Consider using try/catch blocks instead if you are only using @code{eval}\n\
+as an error-capturing mechanism rather than for the execution of arbitrary\n\
+code strings.\n\
+@seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
@@ -4549,16 +4555,17 @@ eval ('error (\"This is a bad example\")
 
 */
 
 DEFUN (assignin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\n\
 Assign @var{value} to @var{varname} in context @var{context}, which\n\
 may be either @code{\"base\"} or @code{\"caller\"}.\n\
+@seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
@@ -4598,20 +4605,22 @@ may be either @code{\"base\"} or @code{\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
+@deftypefn  {Built-in Function} {} evalin (@var{context}, @var{try})\n\
+@deftypefnx {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
 Like @code{eval}, except that the expressions are evaluated in the\n\
 context @var{context}, which may be either @code{\"caller\"} or\n\
 @code{\"base\"}.\n\
+@seealso{eval, assignin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
diff --git a/src/oct-prcstrm.cc b/src/oct-prcstrm.cc
--- a/src/oct-prcstrm.cc
+++ b/src/oct-prcstrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-prcstrm.h b/src/oct-prcstrm.h
--- a/src/oct-prcstrm.h
+++ b/src/oct-prcstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-procbuf.h b/src/oct-procbuf.h
--- a/src/oct-procbuf.h
+++ b/src/oct-procbuf.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct.h b/src/oct.h
--- a/src/oct.h
+++ b/src/oct.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/octave-config.cc.in b/src/octave-config.cc.in
--- a/src/octave-config.cc.in
+++ b/src/octave-config.cc.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/octave-config.in b/src/octave-config.in
--- a/src/octave-config.in
+++ b/src/octave-config.in
@@ -1,13 +1,13 @@
 #! /bin/sh -
 ##
 ## octave-config - reports some configuration values for Octave
 ##
-## Copyright (C) 2001-2011 John W. Eaton
+## Copyright (C) 2001-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -829,19 +829,20 @@ octave_main (int argc, char **argv, int 
 
   atexit (do_octave_atexit);
 
   // Is input coming from a terminal?  If so, we are probably
   // interactive.
 
   // If stdin is not a tty, then we are reading commands from a pipe or
   // a redirected file.
-  stdin_is_tty = isatty (fileno (stdin));
+  stdin_is_tty = gnulib::isatty (fileno (stdin));
 
-  interactive = (! embedded && stdin_is_tty && isatty (fileno (stdout)));
+  interactive = (! embedded && stdin_is_tty
+                 && gnulib::isatty (fileno (stdout)));
 
   if (! interactive && ! forced_line_editing)
     line_editing = false;
 
   // Force default line editor if we don't want readline editing.
   if (! line_editing)
     command_editor::force_default_editor ();
 
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -1,12 +1,12 @@
 %{
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at
 your option) any later version.
 
diff --git a/src/octave.h b/src/octave.h
--- a/src/octave.h
+++ b/src/octave.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-diag.h b/src/ov-base-diag.h
--- a/src/ov-base-diag.h
+++ b/src/ov-base-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1998-2011 John W. Eaton
+Copyright (C) 1998-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-colon.cc b/src/ov-colon.cc
--- a/src/ov-colon.cc
+++ b/src/ov-colon.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -74,16 +74,25 @@ public:
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
+  // Use this to give a more specific error message
+  idx_vector index_vector (void) const
+  {
+    error (
+           "attempted to use a complex scalar as an index\n"
+           "       (forgot to initialize i or j?)");
+    return idx_vector ();
+  }
+
   octave_value any (int = 0) const
     {
       return (scalar != Complex (0, 0)
               && ! (lo_ieee_isnan (std::real (scalar))
                     || lo_ieee_isnan (std::imag (scalar))));
     }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
diff --git a/src/ov-cs-list.cc b/src/ov-cs-list.cc
--- a/src/ov-cs-list.cc
+++ b/src/ov-cs-list.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cs-list.h b/src/ov-cs-list.h
--- a/src/ov-cs-list.h
+++ b/src/ov-cs-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cx-diag.cc b/src/ov-cx-diag.cc
--- a/src/ov-cx-diag.cc
+++ b/src/ov-cx-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cx-diag.h b/src/ov-cx-diag.h
--- a/src/ov-cx-diag.h
+++ b/src/ov-cx-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-dld-fcn.cc b/src/ov-dld-fcn.cc
--- a/src/ov-dld-fcn.cc
+++ b/src/ov-dld-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-dld-fcn.h b/src/ov-dld-fcn.h
--- a/src/ov-dld-fcn.h
+++ b/src/ov-dld-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 Copyright (C) 2010 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -1771,16 +1771,48 @@ are ignored in the lookup.\n\
 %!    y = __testrecursionfunc (@(x) f(2*x), x, n);
 %!  endif
 %!endfunction
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
 
 */
 
+DEFUN (is_function_handle, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
+Return true if @var{x} is a function handle.\n\
+@seealso{isa, typeinfo, class}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    retval = args(0).is_function_handle ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!shared fh
+%! fh = @(x) x;
+
+%!assert (is_function_handle (fh))
+%!assert (! is_function_handle ({fh}))
+%!assert (! is_function_handle (1))
+%!error is_function_handle ();
+%!error is_function_handle (1, 2);
+
+*/
+
+
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
   arg_mask (mask), expected_nargin (exp_nargin)
 {
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -737,17 +737,17 @@ If the second argument is an integer @va
                             have_arg = true;
                             break;
                           }
 
                       if (! have_arg && tmp_arg != "i" && tmp_arg != "j" &&
                           tmp_arg != "NaN" && tmp_arg != "nan" &&
                           tmp_arg != "Inf" && tmp_arg != "inf" &&
                           tmp_arg != "NA" && tmp_arg != "pi" &&
-                          tmp_arg != "eps")
+                          tmp_arg != "e" && tmp_arg != "eps")
                         fargs.append (tmp_arg);
 
                       tmp_arg = std::string ();
                       is_arg = false;
                     }
                 }
 
               // Sort the arguments into ascii order.
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-fcn.cc b/src/ov-fcn.cc
--- a/src/ov-fcn.cc
+++ b/src/ov-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-cx-diag.cc b/src/ov-flt-cx-diag.cc
--- a/src/ov-flt-cx-diag.cc
+++ b/src/ov-flt-cx-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-cx-diag.h b/src/ov-flt-cx-diag.h
--- a/src/ov-flt-cx-diag.h
+++ b/src/ov-flt-cx-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-flt-re-diag.cc b/src/ov-flt-re-diag.cc
--- a/src/ov-flt-re-diag.cc
+++ b/src/ov-flt-re-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-re-diag.h b/src/ov-flt-re-diag.h
--- a/src/ov-flt-re-diag.h
+++ b/src/ov-flt-re-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-int-traits.h b/src/ov-int-traits.h
--- a/src/ov-int-traits.h
+++ b/src/ov-int-traits.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
--- a/src/ov-int16.cc
+++ b/src/ov-int16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int16.h b/src/ov-int16.h
--- a/src/ov-int16.h
+++ b/src/ov-int16.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
--- a/src/ov-int32.cc
+++ b/src/ov-int32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int32.h b/src/ov-int32.h
--- a/src/ov-int32.h
+++ b/src/ov-int32.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
--- a/src/ov-int64.cc
+++ b/src/ov-int64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int64.h b/src/ov-int64.h
--- a/src/ov-int64.h
+++ b/src/ov-int64.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
--- a/src/ov-int8.cc
+++ b/src/ov-int8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int8.h b/src/ov-int8.h
--- a/src/ov-int8.h
+++ b/src/ov-int8.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-lazy-idx.cc b/src/ov-lazy-idx.cc
--- a/src/ov-lazy-idx.cc
+++ b/src/ov-lazy-idx.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-lazy-idx.h b/src/ov-lazy-idx.h
--- a/src/ov-lazy-idx.h
+++ b/src/ov-lazy-idx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-mex-fcn.h b/src/ov-mex-fcn.h
--- a/src/ov-mex-fcn.h
+++ b/src/ov-mex-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-null-mat.h b/src/ov-null-mat.h
--- a/src/ov-null-mat.h
+++ b/src/ov-null-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-oncleanup.cc b/src/ov-oncleanup.cc
--- a/src/ov-oncleanup.cc
+++ b/src/ov-oncleanup.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-oncleanup.h b/src/ov-oncleanup.h
--- a/src/ov-oncleanup.h
+++ b/src/ov-oncleanup.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-perm.h b/src/ov-perm.h
--- a/src/ov-perm.h
+++ b/src/ov-perm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-re-diag.cc b/src/ov-re-diag.cc
--- a/src/ov-re-diag.cc
+++ b/src/ov-re-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-re-diag.h b/src/ov-re-diag.h
--- a/src/ov-re-diag.h
+++ b/src/ov-re-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
--- a/src/ov-type-conv.h
+++ b/src/ov-type-conv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
--- a/src/ov-uint16.cc
+++ b/src/ov-uint16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint16.h b/src/ov-uint16.h
--- a/src/ov-uint16.h
+++ b/src/ov-uint16.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
--- a/src/ov-uint32.cc
+++ b/src/ov-uint32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint32.h b/src/ov-uint32.h
--- a/src/ov-uint32.h
+++ b/src/ov-uint32.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
--- a/src/ov-uint64.cc
+++ b/src/ov-uint64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint64.h b/src/ov-uint64.h
--- a/src/ov-uint64.h
+++ b/src/ov-uint64.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
--- a/src/ov-uint8.cc
+++ b/src/ov-uint8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint8.h b/src/ov-uint8.h
--- a/src/ov-uint8.h
+++ b/src/ov-uint8.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/procstream.cc b/src/procstream.cc
--- a/src/procstream.cc
+++ b/src/procstream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/profiler.cc b/src/profiler.cc
--- a/src/profiler.cc
+++ b/src/profiler.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Daniel Kraft
+Copyright (C) 2012 Daniel Kraft
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/profiler.h b/src/profiler.h
--- a/src/profiler.h
+++ b/src/profiler.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Daniel Kraft
+Copyright (C) 2012 Daniel Kraft
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-all.h b/src/pt-all.h
--- a/src/pt-all.h
+++ b/src/pt-all.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-bp.h b/src/pt-bp.h
--- a/src/pt-bp.h
+++ b/src/pt-bp.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cbinop.cc b/src/pt-cbinop.cc
--- a/src/pt-cbinop.cc
+++ b/src/pt-cbinop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cbinop.h b/src/pt-cbinop.h
--- a/src/pt-cbinop.h
+++ b/src/pt-cbinop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-check.h b/src/pt-check.h
--- a/src/pt-check.h
+++ b/src/pt-check.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-eval.h b/src/pt-eval.h
--- a/src/pt-eval.h
+++ b/src/pt-eval.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-fcn-handle.h b/src/pt-fcn-handle.h
--- a/src/pt-fcn-handle.h
+++ b/src/pt-fcn-handle.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-walk.h b/src/pt-walk.h
--- a/src/pt-walk.h
+++ b/src/pt-walk.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt.cc b/src/pt.cc
--- a/src/pt.cc
+++ b/src/pt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt.h b/src/pt.h
--- a/src/pt.h
+++ b/src/pt.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -180,25 +180,18 @@ my_friendly_exit (const char *sig_name, 
           MINGW_SIGNAL_CLEANUP ();
 
           exit (1);
         }
       else
         {
           octave_set_signal_handler (sig_number, SIG_DFL);
 
-#if defined (HAVE_RAISE)
-          raise (sig_number);
-#elif defined (HAVE_KILL)
-          kill (getpid (), sig_number);
-#else
-          exit (1);
-#endif
+          gnulib::raise (sig_number);
         }
-
     }
 }
 
 sig_handler *
 octave_set_signal_handler (int sig, sig_handler *handler,
                            bool restart_syscalls)
 {
   struct sigaction act, oact;
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/siglist.c b/src/siglist.c
--- a/src/siglist.c
+++ b/src/siglist.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/siglist.h b/src/siglist.h
--- a/src/siglist.h
+++ b/src/siglist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse-xdiv.h b/src/sparse-xdiv.h
--- a/src/sparse-xdiv.h
+++ b/src/sparse-xdiv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse-xpow.h b/src/sparse-xpow.h
--- a/src/sparse-xpow.h
+++ b/src/sparse-xpow.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -1638,218 +1638,263 @@ const_value (const octave_value_list& ar
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
-#if defined (F_DUPFD)
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_DUPFD ()\n\
-Return the value required to request that @code{fcntl} return a\n\
+Return the numerical value to pass to @code{fcntl} to return a\n\
 duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
-}
+#else
+  error ("F_DUPFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_GETFD)
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFD ()\n\
-Return the value required to request that @code{fcntl} to return the\n\
+Return the numerical value to pass to @code{fcntl} to return the\n\
 file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_GETFD)
   return const_value (args, F_GETFD);
-}
+#else
+  error ("F_GETFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_GETFL)
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFL ()\n\
-Return the value required to request that @code{fcntl} to return the\n\
+Return the numerical value to pass to @code{fcntl} to return the\n\
 file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_GETFL)
   return const_value (args, F_GETFL);
-}
+#else
+  error ("F_GETFL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_SETFD)
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFD ()\n\
-Return the value required to request that @code{fcntl} to set the file\n\
+Return the numerical value to pass to @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_SETFD)
   return const_value (args, F_SETFD);
-}
+#else
+  error ("F_SETFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_SETFL)
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFL ()\n\
-Return the value required to request that @code{fcntl} to set the file\n\
+Return the numerical value to pass to @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
+#if defined (F_SETFL)
   return const_value (args, F_SETFL);
-}
+#else
+  error ("F_SETFL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_APPEND)
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_APPEND)
   return const_value (args, O_APPEND);
-}
+#else
+  error ("O_APPEND: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_ASYNC)
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_ASYNC)
   return const_value (args, O_ASYNC);
-}
+#else
+  error ("O_ASYNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_CREAT)
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be\n\
 created if it does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_CREAT)
   return const_value (args, O_CREAT);
-}
+#else
+  error ("O_CREAT: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_EXCL)
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_EXCL)
   return const_value (args, O_EXCL);
-}
+#else
+  error ("O_EXCL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_NONBLOCK)
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_NONBLOCK)
   return const_value (args, O_NONBLOCK);
-}
+#else
+  error ("O_NONBLOCK: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_RDONLY)
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_RDONLY)
   return const_value (args, O_RDONLY);
-}
+#else
+  error ("O_RDONLY: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_RDWR)
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both\n\
 reading and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_RDWR)
   return const_value (args, O_RDWR);
-}
+#else
+  error ("O_RDWR: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_SYNC)
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_SYNC)
   return const_value (args, O_SYNC);
-}
+#else
+  error ("O_SYNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_TRUNC)
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should\n\
 be truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_TRUNC)
   return const_value (args, O_TRUNC);
-}
+#else
+  error ("O_TRUNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_WRONLY)
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
+#if defined (O_WRONLY)
   return const_value (args, O_WRONLY);
+#else
+  error ("O_WRONLY: not available on this system");
+  return octave_value ();
+#endif
 }
-#endif
 
 #if !defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WNOHANG ()\n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -283,17 +283,17 @@ sysdep_cleanup (void)
 // It doesn't matter whether an input \n is mapped to \r, or vice versa.
 
 void
 raw_mode (bool on, bool wait)
 {
   static bool curr_on = false;
 
   int tty_fd = STDIN_FILENO;
-  if (! isatty (tty_fd))
+  if (! gnulib::isatty (tty_fd))
     {
       if (interactive)
         error ("stdin is not a tty!");
       return;
     }
 
   if (on == curr_on)
     return;
diff --git a/src/sysdep.h b/src/sysdep.h
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -1077,17 +1077,27 @@ do_octave_atexit (void)
           octave_stdout << "\n";
 
           // Yes, we want this to be separate from the call to
           // flush_octave_stdout above.
 
           OCTAVE_SAFE_CALL (flush_octave_stdout, ());
         }
 
-      OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
+      // Don't call singleton_cleanup_list::cleanup until we have the
+      // problems with registering/unregistering types worked out.  For
+      // example, uncomment the following line, then use the make_int
+      // function from the examples directory to create an integer
+      // object and then exit Octave.  Octave should crash with a
+      // segfault when cleaning up the typinfo singleton.  We need some
+      // way to force new octave_value_X types that are created in
+      // .oct files to be unregistered when the .oct file shared library
+      // is unloaded.
+      //
+      // OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
 
       OCTAVE_SAFE_CALL (octave_chunk_buffer::clear, ());
     }
 }
 
 void
 octave_add_atexit_function (const std::string& fname)
 {
@@ -1230,16 +1240,19 @@ specified option.\n\
       { false, "ALL_CXXFLAGS", OCTAVE_CONF_ALL_CXXFLAGS },
       { false, "ALL_FFLAGS", OCTAVE_CONF_ALL_FFLAGS },
       { false, "ALL_LDFLAGS", OCTAVE_CONF_ALL_LDFLAGS },
       { false, "AMD_CPPFLAGS", OCTAVE_CONF_AMD_CPPFLAGS },
       { false, "AMD_LDFLAGS", OCTAVE_CONF_AMD_LDFLAGS },
       { false, "AMD_LIBS", OCTAVE_CONF_AMD_LIBS },
       { false, "AR", OCTAVE_CONF_AR },
       { false, "ARFLAGS", OCTAVE_CONF_ARFLAGS },
+      { false, "ARPACK_CPPFLAGS", OCTAVE_CONF_ARPACK_CPPFLAGS },
+      { false, "ARPACK_LDFLAGS", OCTAVE_CONF_ARPACK_LDFLAGS },
+      { false, "ARPACK_LIBS", OCTAVE_CONF_ARPACK_LIBS },
       { false, "BLAS_LIBS", OCTAVE_CONF_BLAS_LIBS },
       { false, "CARBON_LIBS", OCTAVE_CONF_CARBON_LIBS },
       { false, "CAMD_CPPFLAGS", OCTAVE_CONF_CAMD_CPPFLAGS },
       { false, "CAMD_LDFLAGS", OCTAVE_CONF_CAMD_LDFLAGS },
       { false, "CAMD_LIBS", OCTAVE_CONF_CAMD_LIBS },
       { false, "CC", OCTAVE_CONF_CC },
       { false, "CC_VERSION", OCTAVE_CONF_CC_VERSION },
       { false, "CCOLAMD_CPPFLAGS", OCTAVE_CONF_CCOLAMD_CPPFLAGS },
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Michael Goffioul
+Copyright (C) 2009-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/txt-eng-ft.h b/src/txt-eng-ft.h
--- a/src/txt-eng-ft.h
+++ b/src/txt-eng-ft.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Michael Goffioul
+Copyright (C) 2009-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/txt-eng.h b/src/txt-eng.h
--- a/src/txt-eng.h
+++ b/src/txt-eng.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Michael Goffioul
+Copyright (C) 2009-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/version.h.in b/src/version.h.in
--- a/src/version.h.in
+++ b/src/version.h.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1992-2011 John W. Eaton
+Copyright (C) 1992-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -83,10 +83,9 @@ For more information, visit http://www.o
 
 #define OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS ("")
 
 #define OCTAVE_STARTUP_MESSAGE \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
     ("  For details, type `warranty'.") "\n\n" \
   "For information about changes from previous versions, type `news'."
-
 #endif
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/xgl2ps.c b/src/xgl2ps.c
--- a/src/xgl2ps.c
+++ b/src/xgl2ps.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/xnorm.cc b/src/xnorm.cc
--- a/src/xnorm.cc
+++ b/src/xnorm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/xnorm.h b/src/xnorm.h
--- a/src/xnorm.h
+++ b/src/xnorm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/xpow.h b/src/xpow.h
--- a/src/xpow.h
+++ b/src/xpow.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland
+Copyright (C) 2005-2012 Ludwig Schwardt, Kevin Ruland
 
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland
+Copyright (C) 2005-2012 Ludwig Schwardt, Kevin Ruland
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's test directory
 #
-# Copyright (C) 1994-2011 John W. Eaton
+# Copyright (C) 1994-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -18,29 +18,27 @@
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 FCN_FILES = \
   fntests.m \
   test_args.m \
-  test_contin.m \
   test_diag_perm.m \
   test_error.m \
   test_eval-catch.m \
   test_for.m \
   test_func.m \
   test_global.m \
   test_if.m \
-  test_index-wfi-f.m \
-  test_index-wfi-t.m \
+  test_index.m \
   test_io.m \
-  test_logical-wfi-f.m \
-  test_logical-wfi-t.m \
+  test_line_continue.m \
+  test_logical_index.m \
   test_null_assign.m \
   test_parser.m \
   test_prefer.m \
   test_range.m \
   test_recursion.m \
   test_return.m \
   test_slice.m \
   test_struct.m \
diff --git a/test/build_bc_overload_tests.sh b/test/build_bc_overload_tests.sh
--- a/test/build_bc_overload_tests.sh
+++ b/test/build_bc_overload_tests.sh
@@ -1,11 +1,11 @@
 #! /bin/sh
 
-# Copyright (C) 2010-2011 VZLU Prague
+# Copyright (C) 2010-2012 VZLU Prague
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -42,35 +42,38 @@ else
   echo "usage: build_bc_overload_tests.sh expected-results-file" 1>&2
   exit 1
 fi
 
 for class in $CLASSES; do
   DIR="@$class"
   test -d $DIR || mkdir $DIR || { echo "error: could not create $DIR"; exit; }
   cat > $DIR/tbcover.m << EOF
-% DO NOT EDIT - generated automatically
+% !!! DO NOT EDIT !!!
+% generated automatically by build_bc_overload_tests.sh
 function s = tbcover (x, y)
   s = '$class';
 EOF
 done
 
 cat > tbcover.m << EOF
-% DO NOT EDIT - generated automatically
+% !!! DO NOT EDIT !!!
+% generated automatically by build_bc_overload_tests.sh
 function s = tbcover (x, y)
   s = 'none';
 EOF
 
 if test "$1" = "overloads_only" ; then
   exit
 fi
 
 cat > test_bc_overloads.m << EOF
-## THIS IS AN AUTOMATICALLY GENERATED FILE --- DO NOT EDIT ---
-## instead modify build_bc_overload_tests.sh to generate the tests that you want.
+## !!! DO NOT EDIT !!!
+## THIS IS AN AUTOMATICALLY GENERATED FILE
+## modify build_bc_overload_tests.sh to generate the tests you need.
 
 %!shared ex
 %! ex.double = 1;
 %! ex.single = single(1);
 %! ex.logical = true;
 %! ex.char = 'char';
 %! ex.int8  = int8 (1);
 %! ex.int16 = int16 (1);
diff --git a/test/build_bc_overloads_expected.m b/test/build_bc_overloads_expected.m
--- a/test/build_bc_overloads_expected.m
+++ b/test/build_bc_overloads_expected.m
@@ -1,12 +1,12 @@
 % this script is intended to be Matlab compatible
 % first, run the script
 %
-%   ./build_bc_overloads_tests.sh overloads_onely
+%   ./build_bc_overloads_tests.sh overloads_only
 %
 % to generate the overloaded functions.
 %
 ex.double = 1;
 ex.single = single(1);
 ex.logical = true;
 ex.char = 'char';
 ex.int8  = int8 (1);
diff --git a/test/build_sparse_tests.sh b/test/build_sparse_tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build_sparse_tests.sh
@@ -1,11 +1,11 @@
 #!/bin/sh
 
-# Copyright (C) 2006-2011 David Bateman
+# Copyright (C) 2006-2012 David Bateman
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -116,18 +116,19 @@ esac
 if $preset; then
     TESTS=test_sparse.m
 else
     TESTS=test_sprandom.m
 fi
 
 # create initial file
 cat >$TESTS <<EOF
-## THIS IS AN AUTOMATICALLY GENERATED FILE --- DO NOT EDIT ---
-## instead modify build_sparse_tests.sh to generate the tests that you want.
+## !!! DO NOT EDIT !!!
+## THIS IS AN AUTOMATICALLY GENERATED FILE
+## modify build_sparse_tests.sh to generate the tests you need.
 EOF
 
 
 # define all functions
 
 
 # =======================================================
 # Section separator
@@ -145,271 +146,273 @@ EOF
 # Specific preset tests
 
 # =======================================================
 # If a sparse operation yields zeros, then those elements 
 # of the returned sparse matrix should be eaten.
 gen_eat_zeros() {
 cat >>$TESTS <<EOF
 %% Make sure newly introduced zeros get eaten
-%!assert(nnz(sparse([bf,bf,1]).^realmax),1);
-%!assert(nnz(sparse([1,bf,bf]).^realmax),1);
-%!assert(nnz(sparse([bf,bf,bf]).^realmax),0); 
+%!assert (nnz (sparse ([bf,bf,1]).^realmax), 1)
+%!assert (nnz (sparse ([1,bf,bf]).^realmax), 1)
+%!assert (nnz (sparse ([bf,bf,bf]).^realmax), 0)
 
-%!assert(nnz(sparse([bf;bf;1]).^realmax),1);
-%!assert(nnz(sparse([1;bf;bf]).^realmax),1);
-%!assert(nnz(sparse([0.5;bf;bf]).^realmax),0);
+%!assert (nnz (sparse ([bf;bf;1]).^realmax), 1)
+%!assert (nnz (sparse ([1;bf;bf]).^realmax), 1)
+%!assert (nnz (sparse ([0.5;bf;bf]).^realmax), 0)
 
-%!assert(nnz(sparse([bf,bf,1])*realmin),1);
-%!assert(nnz(sparse([1,bf,bf])*realmin),1);
-%!assert(nnz(sparse([bf,bf,bf])*realmin),0);
+%!assert (nnz (sparse ([bf,bf,1])*realmin), 1)
+%!assert (nnz (sparse ([1,bf,bf])*realmin), 1)
+%!assert (nnz (sparse ([bf,bf,bf])*realmin), 0)
 
-%!assert(nnz(sparse([bf;bf;1])*realmin),1);
-%!assert(nnz(sparse([1;bf;bf])*realmin),1);
-%!assert(nnz(sparse([bf;bf;bf])*realmin),0);
+%!assert (nnz (sparse ([bf;bf;1])*realmin), 1)
+%!assert (nnz (sparse ([1;bf;bf])*realmin), 1)
+%!assert (nnz (sparse ([bf;bf;bf])*realmin), 0)
 
 EOF
 }
 
 gen_specific() {
 cat >>$TESTS <<EOF
 
 %!test # segfault test from edd@debian.org
 %! n = 510;
-%! sparse(kron((1:n)', ones(n,1)), kron(ones(n,1), (1:n)'), ones(n)); 
+%! sparse (kron ((1:n)', ones(n,1)), kron (ones(n,1), (1:n)'), ones (n)); 
 
 %% segfault tests from Fabian@isas-berlin.de
 %% Note that the last four do not fail, but rather give a warning
 %% of a singular matrix, which is consistent with the full matrix
-%% behaviour. They are therefore disabled.. 
+%% behaviour.  They are therefore disabled.
 %!testif HAVE_UMFPACK
-%! assert(inv(sparse([1,1;1,1+i])),sparse([1-1i,1i;1i,-1i]),10*eps);
-% !error inv( sparse( [1,1;1,1]   ) );
-% !error inv( sparse( [0,0;0,1]   ) );
-% !error inv( sparse( [0,0;0,1+i] ) );
-% !error inv( sparse( [0,0;0,0]   ) );
+%! assert (inv (sparse ([1,1;1,1+i])), sparse([1-1i,1i;1i,-1i]), 10*eps);
+%#!error inv ( sparse ([1,1;1,1]  ) );
+%#!error inv ( sparse ([0,0;0,1]  ) );
+%#!error inv ( sparse ([0,0;0,1+i]) );
+%#!error inv ( sparse ([0,0;0,0]  ) );
 
 %% error handling in constructor
-%!error sparse(1,[2,3],[1,2,3]);
-%!error sparse([1,1],[1,1],[1,2],3,3,"bogus");
-%!error sparse([1,3],[1,-4],[3,5],2,2);
-%!error sparse([1,3],[1,-4],[3,5i],2,2);
-%!error sparse(-1,-1,1);
+%!error sparse (1,[2,3],[1,2,3])
+%!error sparse ([1,1],[1,1],[1,2],3,3,"bogus")
+%!error sparse ([1,3],[1,-4],[3,5],2,2)
+%!error sparse ([1,3],[1,-4],[3,5i],2,2)
+%!error sparse (-1,-1,1)
 EOF
 }
 
 
 gen_specific_tests() {
     gen_section
     gen_specific
     gen_section
     echo '%!shared bf' >> $TESTS
     echo '%!test bf=realmin;' >> $TESTS
     gen_eat_zeros
     echo '%!test bf=realmin+realmin*1i;' >> $TESTS
     gen_eat_zeros
     cat >>$TESTS <<EOF
-%!assert(nnz(sparse([-1,realmin,realmin]).^1.5),1);
-%!assert(nnz(sparse([-1,realmin,realmin,1]).^1.5),2);
+%!assert (nnz (sparse ([-1,realmin,realmin]).^1.5), 1)
+%!assert (nnz (sparse ([-1,realmin,realmin,1]).^1.5), 2)
 
-%!assert(nnz(sparse(1,1,0)),0); # Make sure scalar v==0 doesn't confuse matters
-%!assert(nnz(sparse(eye(3))*0),0);
-%!assert(nnz(sparse(eye(3))-sparse(eye(3))),0);
+## Make sure scalar v==0 doesn't confuse matters
+%!assert (nnz (sparse (1,1,0)), 0)
+%!assert (nnz (sparse (eye (3))*0), 0)
+%!assert (nnz (sparse (eye (3))-sparse (eye (3))), 0)
 
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("off", "Octave:divide-by-zero");
-%! assert(full(sparse(eye(3))/0),full(eye(3)/0));
+%! assert (full (sparse (eye (3))/0), full (eye (3)/0));
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
 EOF
 }
 
 
 # =======================================================
 # Main function definition
 
 gen_function() {
     if $preset; then
 	cat >>$TESTS <<EOF
 ##
 ## test_sparse
 ##
 ##    run preset sparse tests.  All should pass.
-function [passes,tests] = test_sparse
-  disp("writing test output to sptest.log");
-  test("test_sparse","normal","sptest.log");
+function [passes, tests] = test_sparse
+  disp ("writing test output to sptest.log");
+  test ("test_sparse", "normal", "sptest.log");
 endfunction
 
 EOF
     else
 	cat >>$TESTS <<EOF
 ##
 ## test_sprandom
 ##
 ##  total_passes=0; total_tests=0;
 ##  for i=1:10
 ##     [passes,tests] = sprandomtest;
 ##    total_passes += passes;
 ##    total_tests += tests;
 ##  end
 ##  The test log is appended to sprandomtest.log
 function [passes,total] = test_sprandom
-  warning("untested --- fix the source in build_sparse_tests.sh");
-  disp("appending test output to sprandomtest.log");
-  fid = fopen("sprandomtest.log","at");
-  test("test_sprandom","normal",fid);
+  warning ("untested --- fix the source in build_sparse_tests.sh");
+  disp ("appending test output to sprandomtest.log");
+  fid = fopen ("sprandomtest.log", "at");
+  test ("test_sprandom", "normal", fid);
   ##[passes, total] = test("sprandomtest","normal",fid);
-  fclose(fid);
+  fclose (fid);
 endfunction
 
 EOF
     fi
     
 }
 
 
 # =======================================================
 # matrix ops
 
 # test ordered comparisons: uses as,af,bs,bf
 gen_ordering_tests() {
     cat >>$TESTS <<EOF
 %% real values can be ordered (uses as,af)
-%!assert(as<=bf,sparse(af<=bf))
-%!assert(bf<=as,sparse(bf<=af))
+%!assert (as<=bf, sparse (af<=bf))
+%!assert (bf<=as, sparse (bf<=af))
 
-%!assert(as>=bf,sparse(af>=bf))
-%!assert(bf>=as,sparse(bf>=af))
+%!assert (as>=bf, sparse (af>=bf))
+%!assert (bf>=as, sparse (bf>=af))
 
-%!assert(as<bf,sparse(af<bf))
-%!assert(bf<as,sparse(bf<af))
+%!assert (as<bf, sparse (af<bf))
+%!assert (bf<as, sparse (bf<af))
 
-%!assert(as>bf,sparse(af>bf))
-%!assert(bf>as,sparse(bf>af))
+%!assert (as>bf, sparse (af>bf))
+%!assert (bf>as, sparse (bf>af))
 
 EOF
 }
 
 gen_sparsesparse_ordering_tests() {
     cat >>$TESTS <<EOF
-%!assert(as<=bs,sparse(af<=bf))
-%!assert(as>=bs,sparse(af>=bf))
-%!assert(as<bs,sparse(af<bf))
-%!assert(as>bs,sparse(af>bf))
+%!assert (as<=bs, sparse (af<=bf))
+%!assert (as>=bs, sparse (af>=bf))
+%!assert (as<bs, sparse (af<bf))
+%!assert (as>bs, sparse (af>bf))
 EOF
 }
 
 # test element-wise binary operations: uses as,af,bs,bf,scalar
 gen_elementop_tests() {
     cat >>$TESTS <<EOF
 %% Elementwise binary tests (uses as,af,bs,bf,scalar)
-%!assert(as==bs,sparse(af==bf))
-%!assert(bf==as,sparse(bf==af))
+%!assert (as==bs, sparse (af==bf))
+%!assert (bf==as, sparse (bf==af))
 
-%!assert(as!=bf,sparse(af!=bf))
-%!assert(bf!=as,sparse(bf!=af))
+%!assert (as!=bf, sparse (af!=bf))
+%!assert (bf!=as, sparse (bf!=af))
 
-%!assert(as+bf,af+bf)
-%!assert(bf+as,bf+af)
+%!assert (as+bf, af+bf)
+%!assert (bf+as, bf+af)
 
-%!assert(as-bf,af-bf)
-%!assert(bf-as,bf-af)
+%!assert (as-bf, af-bf)
+%!assert (bf-as, bf-af)
 
-%!assert(as.*bf,sparse(af.*bf))
-%!assert(bf.*as,sparse(bf.*af))
+%!assert (as.*bf, sparse (af.*bf))
+%!assert (bf.*as, sparse (bf.*af))
 
-%!assert(as./bf,sparse(af./bf),100*eps)
-%!assert(bf.\as,sparse(bf.\af),100*eps)
+%!assert (as./bf, sparse (af./bf), 100*eps)
+%!assert (bf.\as, sparse (bf.\af), 100*eps)
 
 %!test
 %! sv = as.^bf;
 %! fv = af.^bf;
-%! idx = find(af~=0);
-%! assert(sv(:)(idx),sparse(fv(:)(idx)),100*eps)
+%! idx = find (af~=0);
+%! assert (sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
 
 EOF
 }
 
 gen_sparsesparse_elementop_tests() {
     cat >>$TESTS <<EOF
-%!assert(as==bs,sparse(af==bf))
-%!assert(as!=bs,sparse(af!=bf))
-%!assert(as+bs,sparse(af+bf))
-%!assert(as-bs,sparse(af-bf))
-%!assert(as.*bs,sparse(af.*bf))
-%!xtest assert(as./bs,sparse(af./bf),100*eps);
+%!assert (as==bs, sparse (af==bf))
+%!assert (as!=bs, sparse (af!=bf))
+%!assert (as+bs, sparse (af+bf))
+%!assert (as-bs, sparse (af-bf))
+%!assert (as.*bs, sparse (af.*bf))
+%!xtest assert (as./bs, sparse (af./bf), 100*eps)
 %!test
 %! sv = as.^bs;
 %! fv = af.^bf;
-%! idx = find(af~=0);
-%! assert(sv(:)(idx),sparse(fv(:)(idx)),100*eps)
+%! idx = find (af~=0);
+%! assert(sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix left and right division: uses as,af,bs,bf
 gen_divop_tests() {
     cat >>$TESTS <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
-%!assert(as/bf,af/bf,100*eps)
-%!assert(af/bs,af/bf,100*eps)
-%!assert(as/bs,sparse(af/bf),100*eps)
-%!assert(bs\af',bf\af',100*eps)
-%!assert(bf\as',bf\af',100*eps)
-%!assert(bs\as',sparse(bf\af'),100*eps)
+%!assert (as/bf, af/bf, 100*eps)
+%!assert (af/bs, af/bf, 100*eps)
+%!assert (as/bs, sparse (af/bf), 100*eps)
+%!assert (bs\af', bf\af', 100*eps)
+%!assert (bf\as', bf\af', 100*eps)
+%!assert (bs\as', sparse (bf\af'), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix left and right division: uses as,af,bs,bf
 gen_square_divop_tests() {
     cat >>$TESTS <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
-%!assert(as/bf,af/bf,100*eps)
-%!assert(af/bs,af/bf,100*eps)
-%!assert(as/bs,sparse(af/bf),100*eps)
-%!assert(bs\af',bf\af',100*eps)
-%!assert(bf\as',bf\af',100*eps)
-%!assert(bs\as',sparse(bf\af'),100*eps)
+%!assert (as/bf, af/bf, 100*eps)
+%!assert (af/bs, af/bf, 100*eps)
+%!assert (as/bs, sparse (af/bf), 100*eps)
+%!assert (bs\af', bf\af', 100*eps)
+%!assert (bf\as', bf\af', 100*eps)
+%!assert (bs\as', sparse (bf\af'), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix operations: uses as,af,bs,bf
 gen_matrixop_tests() {
     cat >>$TESTS <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
-%!assert(as*bf',af*bf')
-%!assert(af*bs',af*bf')
-%!assert(as*bs',sparse(af*bf'))
+%!assert (as*bf', af*bf')
+%!assert (af*bs', af*bf')
+%!assert (as*bs', sparse (af*bf'))
 
 EOF
 }
 
 # test diagonal operations
 gen_matrixdiag_tests() {
     cat >>$TESTS <<EOF
 %% Matrix diagonal tests (uses af,as,bf,bs)
-%!assert(diag(as),sparse(diag(af)))
-%!assert(diag(bs),sparse(diag(bf)))
-%!assert(diag(as,1),sparse(diag(af,1)))
-%!assert(diag(bs,1),sparse(diag(bf,1)))
-%!assert(diag(as,-1),sparse(diag(af,-1)))
-%!assert(diag(bs,-1),sparse(diag(bf,-1)))
-%!assert(diag(as(:)),sparse(diag(af(:))))
-%!assert(diag(as(:),1),sparse(diag(af(:),1)))
-%!assert(diag(as(:),-1),sparse(diag(af(:),-1)))
-%!assert(diag(as(:)'),sparse(diag(af(:)')))
-%!assert(diag(as(:)',1),sparse(diag(af(:)',1)))
-%!assert(diag(as(:)',-1),sparse(diag(af(:)',-1)))
-%!assert(spdiags(as,[0,1]),[diag(af,0),diag(af,1)])
-%!test [tb,tc]=spdiags(as); 
-%! assert(spdiags(tb,tc,sparse(zeros(size(as)))),as)
-%! assert(spdiags(tb,tc,size(as,1),size(as,2)),as)
+%!assert (diag (as), sparse (diag (af)))
+%!assert (diag (bs), sparse (diag (bf)))
+%!assert (diag (as,1), sparse (diag (af,1)))
+%!assert (diag (bs,1), sparse (diag (bf,1)))
+%!assert (diag (as,-1), sparse (diag (af,-1)))
+%!assert (diag (bs,-1), sparse (diag (bf,-1)))
+%!assert (diag (as(:)), sparse (diag (af(:))))
+%!assert (diag (as(:),1), sparse (diag (af(:),1)))
+%!assert (diag (as(:),-1), sparse (diag (af(:),-1)))
+%!assert (diag (as(:)'), sparse (diag (af(:)')))
+%!assert (diag (as(:)',1), sparse (diag (af(:)',1)))
+%!assert (diag (as(:)',-1), sparse (diag (af(:)',-1)))
+%!assert (spdiags (as,[0,1]), [diag(af,0), diag(af,1)])
+%!test
+%! [tb,tc]=spdiags(as); 
+%! assert (spdiags (tb,tc,sparse (zeros (size (as)))), as);
+%! assert (spdiags (tb,tc,size (as,1),size (as,2)), as);
 
 EOF
 }
 
 # test matrix reshape operations
 gen_matrixreshape_tests() {
     cat >>$TESTS <<EOF
 %% Matrix diagonal tests (uses af,as,bf,bs)
@@ -420,29 +423,29 @@ gen_matrixreshape_tests() {
 %!assert(reshape(bs,prod(size(as)),1),sparse(reshape(bf,prod(size(af)),1)))
 %!assert(reshape(bs,fliplr(size(as))),sparse(reshape(bf,fliplr(size(af)))))
 
 EOF
 }
 
 # test mapper matrix operations: uses as,af
 print_mapper_test() {
-echo "%!assert($1(as),sparse($1(af)))" >>$TESTS
+echo "%!assert ($1(as), sparse ($1(af)))" >>$TESTS
 }
 
 print_real_mapper_test() {
     cat >>$TESTS <<EOF
 %!test
 %! wn2s = warning ("query", "Octave:num-to-str");
 %! warning ("off", "Octave:num-to-str");
-%! if isreal(af)
+%! if (isreal (af))
 %!   if ($2)
-%!     assert($1(as),sparse($1(af)))
+%!     assert ($1(as), sparse ($1(af)));
 %!   else
-%!     assert($1(as),$1(af))
+%!     assert ($1(as), $1(af));
 %!   endif
 %! endif
 %! warning (wn2s.state, "Octave:num-to-str");
 
 EOF
 }
 
 gen_mapper_tests() {
@@ -476,19 +479,19 @@ print_mapper_test sign
 print_mapper_test sin
 print_mapper_test sinh
 print_mapper_test sqrt
 print_mapper_test tan
 print_mapper_test tanh
 
 # Specific tests for certain mapper functions
     cat >>$TESTS <<EOF
-%!assert(issparse(abs(as))&&isreal(abs(as)))
-%!assert(issparse(real(as))&&isreal(real(as)))
-%!assert(issparse(imag(as))&&isreal(imag(as)))
+%!assert (issparse (abs (as))  && isreal (abs (as)))
+%!assert (issparse (real (as)) && isreal (real (as)))
+%!assert (issparse (imag (as)) && isreal (imag (as)))
 
 EOF
 }
 
 gen_real_mapper_tests() {
 echo "%% Unary matrix tests (uses af,as)">>$TESTS
 print_real_mapper_test erf 1
 print_real_mapper_test erfc 1
@@ -509,220 +512,220 @@ print_real_mapper_test isxdigit 0
 
 # Specific tests for certain mapper functions
     cat >>$TESTS <<EOF
 
 %% These mapper functions always return a full matrix
 %!test
 %! wn2s = warning ("query", "Octave:num-to-str");
 %! warning ("off", "Octave:num-to-str");
-%! if isreal(af)
-%!    assert(toascii(as),toascii(af))
-%!    assert(tolower(as),tolower(af))
-%!    assert(toupper(as),toupper(af))
+%! if (isreal (af))
+%!   assert (toascii (as), toascii (af));
+%!   assert (tolower (as), tolower (af));
+%!   assert (toupper (as), toupper (af));
 %! endif
 %! warning (wn2s.state, "Octave:num-to-str");
 
 EOF
 }
 
 # test matrix operations: uses as,af
 gen_unaryop_tests() {
     cat >>$TESTS <<EOF
 %% Unary matrix tests (uses af,as)
-%!assert(issparse(as))
-%!assert(!issparse(af))
-%!assert(!(issparse(af)&&iscomplex(af)))
-%!assert(!(issparse(af)&&isreal(af)))
-%!assert(sum(as),sparse(sum(af)))
-%!assert(sum(as,1),sparse(sum(af,1)))
-%!assert(sum(as,2),sparse(sum(af,2)))
-%!assert(cumsum(as),sparse(cumsum(af)))
-%!assert(cumsum(as,1),sparse(cumsum(af,1)))
-%!assert(cumsum(as,2),sparse(cumsum(af,2)))
-%!assert(sumsq(as),sparse(sumsq(af)))
-%!assert(sumsq(as,1),sparse(sumsq(af,1)))
-%!assert(sumsq(as,2),sparse(sumsq(af,2)))
-%!assert(prod(as),sparse(prod(af)))
-%!assert(prod(as,1),sparse(prod(af,1)))
-%!assert(prod(as,2),sparse(prod(af,2)))
-%!assert(cumprod(as),sparse(cumprod(af)))
-%!assert(cumprod(as,1),sparse(cumprod(af,1)))
-%!assert(cumprod(as,2),sparse(cumprod(af,2)))
+%!assert (issparse (as))
+%!assert (!issparse (af))
+%!assert (! (issparse (af) && iscomplex (af)))
+%!assert (! (issparse (af) && isreal (af)))
+%!assert (sum (as), sparse (sum (af)))
+%!assert (sum (as,1), sparse (sum (af,1)))
+%!assert (sum (as,2), sparse (sum (af,2)))
+%!assert (cumsum (as), sparse (cumsum (af)))
+%!assert (cumsum (as,1), sparse (cumsum (af,1)))
+%!assert (cumsum (as,2), sparse (cumsum (af,2)))
+%!assert (sumsq (as), sparse (sumsq (af)))
+%!assert (sumsq (as,1), sparse (sumsq (af,1)))
+%!assert (sumsq (as,2), sparse (sumsq (af,2)))
+%!assert (prod (as), sparse (prod (af)))
+%!assert (prod (as,1), sparse (prod (af,1)))
+%!assert (prod (as,2), sparse (prod (af,2)))
+%!assert (cumprod (as), sparse (cumprod (af)))
+%!assert (cumprod (as,1), sparse (cumprod (af,1)))
+%!assert (cumprod (as,2), sparse (cumprod (af,2)))
 
-%!assert(min(as),sparse(min(af)))
-%!assert(full(min(as(:))),min(af(:)))
-%!assert(min(as,[],1),sparse(min(af,[],1)))
-%!assert(min(as,[],2),sparse(min(af,[],2)))
-%!assert(min(as,[],1),sparse(min(af,[],1)))
-%!assert(min(as,0),sparse(min(af,0)))
-%!assert(min(as,bs),sparse(min(af,bf)))
-%!assert(max(as),sparse(max(af)))
-%!assert(full(max(as(:))),max(af(:)))
-%!assert(max(as,[],1),sparse(max(af,[],1)))
-%!assert(max(as,[],2),sparse(max(af,[],2)))
-%!assert(max(as,[],1),sparse(max(af,[],1)))
-%!assert(max(as,0),sparse(max(af,0)))
-%!assert(max(as,bs),sparse(max(af,bf)))
+%!assert (min (as), sparse (min (af)))
+%!assert (full (min (as(:))),min (af(:)))
+%!assert (min (as,[],1), sparse (min (af,[],1)))
+%!assert (min (as,[],2), sparse (min (af,[],2)))
+%!assert (min (as,[],1), sparse (min (af,[],1)))
+%!assert (min (as,0), sparse (min (af,0)))
+%!assert (min (as,bs), sparse (min (af,bf)))
+%!assert (max (as), sparse (max (af)))
+%!assert (full (max (as(:))), max (af(:)))
+%!assert (max (as,[],1), sparse (max (af,[],1)))
+%!assert (max (as,[],2), sparse (max (af,[],2)))
+%!assert (max (as,[],1), sparse (max (af,[],1)))
+%!assert (max (as,0), sparse (max (af,0)))
+%!assert (max (as,bs), sparse (max (af,bf)))
 
-%!assert(as==as)
-%!assert(as==af)
-%!assert(af==as)
+%!assert (as==as)
+%!assert (as==af)
+%!assert (af==as)
 %!test
-%! [ii,jj,vv,nr,nc] = find(as);
-%! assert(af,full(sparse(ii,jj,vv,nr,nc)));
-%!assert(nnz(as),sum(af(:)!=0))
-%!assert(nnz(as),nnz(af))
-%!assert(issparse(as.'))
-%!assert(issparse(as'))
-%!assert(issparse(-as))
-%!assert(~as,sparse(~af))
-%!assert(as.', sparse(af.'));
-%!assert(as',  sparse(af'));
-%!assert(-as, sparse(-af));
-%!assert(~as, sparse(~af));
-%!error [i,j]=size(af);as(i-1,j+1);
-%!error [i,j]=size(af);as(i+1,j-1);
+%! [ii,jj,vv,nr,nc] = find (as);
+%! assert (af, full (sparse (ii,jj,vv,nr,nc)));
+%!assert (nnz (as), sum (af(:)!=0))
+%!assert (nnz (as), nnz (af))
+%!assert (issparse (as.'))
+%!assert (issparse (as'))
+%!assert (issparse (-as))
+%!assert (~as, sparse (~af))
+%!assert (as.', sparse (af.'));
+%!assert (as',  sparse (af'));
+%!assert (-as, sparse (-af));
+%!assert (~as, sparse (~af));
+%!error [i,j]=size (af);as(i-1,j+1);
+%!error [i,j]=size (af);as(i+1,j-1);
 %!test
-%! [Is,Js,Vs] = find(as);
-%! [If,Jf,Vf] = find(af);
-%! assert(Is,If);
-%! assert(Js,Jf);
-%! assert(Vs,Vf);
+%! [Is,Js,Vs] = find (as);
+%! [If,Jf,Vf] = find (af);
+%! assert (Is, If);
+%! assert (Js, Jf);
+%! assert (Vs, Vf);
 %!error as(0,1);
 %!error as(1,0);
-%!assert(find(as),find(af))
+%!assert (find (as), find (af))
 %!test
-%! [i,j,v] = find(as);
-%! [m,n] = size(as);
-%! x = sparse(i,j,v,m,n);
-%! assert(x,as);
+%! [i,j,v] = find (as);
+%! [m,n] = size (as);
+%! x = sparse (i,j,v,m,n);
+%! assert (x, as);
 %!test
-%! [i,j,v,m,n] = find(as);
-%! x = sparse(i,j,v,m,n);
-%! assert(x,as);
-%!assert(issparse(horzcat(as,as)));
-%!assert(issparse(vertcat(as,as)));
-%!assert(issparse(cat(1,as,as)));
-%!assert(issparse(cat(2,as,as)));
-%!assert(issparse([as,as]));
-%!assert(issparse([as;as]));
-%!assert(horzcat(as,as), sparse([af,af]));
-%!assert(vertcat(as,as), sparse([af;af]));
-%!assert(horzcat(as,as,as), sparse([af,af,af]));
-%!assert(vertcat(as,as,as), sparse([af;af;af]));
-%!assert([as,as], sparse([af,af]));
-%!assert([as;as], sparse([af;af]));
-%!assert([as,as,as], sparse([af,af,af]));
-%!assert([as;as;as], sparse([af;af;af]));
-%!assert(cat(2,as,as), sparse([af,af]));
-%!assert(cat(1,as,as), sparse([af;af]));
-%!assert(cat(2,as,as,as), sparse([af,af,af]));
-%!assert(cat(1,as,as,as), sparse([af;af;af]));
-%!assert(issparse([as,af]));
-%!assert(issparse([af,as]));
-%!assert([as,af], sparse([af,af]));
-%!assert([as;af], sparse([af;af]));
+%! [i,j,v,m,n] = find (as);
+%! x = sparse (i,j,v,m,n);
+%! assert (x, as);
+%!assert (issparse (horzcat (as,as)));
+%!assert (issparse (vertcat (as,as)));
+%!assert (issparse (cat (1,as,as)));
+%!assert (issparse (cat (2,as,as)));
+%!assert (issparse ([as,as]));
+%!assert (issparse ([as;as]));
+%!assert (horzcat (as,as), sparse ([af,af]));
+%!assert (vertcat (as,as), sparse ([af;af]));
+%!assert (horzcat (as,as,as), sparse ([af,af,af]));
+%!assert (vertcat (as,as,as), sparse ([af;af;af]));
+%!assert ([as,as], sparse ([af,af]));
+%!assert ([as;as], sparse ([af;af]));
+%!assert ([as,as,as], sparse ([af,af,af]));
+%!assert ([as;as;as], sparse ([af;af;af]));
+%!assert (cat (2,as,as), sparse ([af,af]));
+%!assert (cat (1,as,as), sparse ([af;af]));
+%!assert (cat (2,as,as,as), sparse ([af,af,af]));
+%!assert (cat (1,as,as,as), sparse ([af;af;af]));
+%!assert (issparse ([as,af]));
+%!assert (issparse ([af,as]));
+%!assert ([as,af], sparse ([af,af]));
+%!assert ([as;af], sparse ([af;af]));
 
 EOF
 }
 
 # operations which require square matrices.
 gen_square_tests() {
 # The \ and / operator tests on square matrices
     gen_square_divop_tests
 
     cat >>$TESTS <<EOF
 %!testif HAVE_UMFPACK
 %! assert(det(bs+speye(size(bs))),det(bf+eye(size(bf))),100*eps*abs(det(bf+eye(size(bf)))))
 
 %!testif HAVE_UMFPACK 
-%! [l,u]=lu(sparse([1,1;1,1]));
-%! assert(l*u,[1,1;1,1],10*eps);
+%! [l,u] = lu (sparse ([1,1;1,1]));
+%! assert (l*u, [1,1;1,1], 10*eps);
 
 %!testif HAVE_UMFPACK
-%! [l,u]=lu(sparse([1,1;1,1+i]));
-%! assert(l,sparse([1,2,2],[1,1,2],1),10*eps);
-%! assert(u,sparse([1,1,2],[1,2,2],[1,1,1i]),10*eps);
+%! [l,u] = lu (sparse ([1,1;1,1+i]));
+%! assert (l, sparse ([1,2,2],[1,1,2],1), 10*eps);
+%! assert (u, sparse ([1,1,2],[1,2,2],[1,1,1i]), 10*eps);
 
 %!testif HAVE_UMFPACK ;# permuted LU
-%! [L,U] = lu(bs);
-%! assert(L*U,bs,1e-10);
+%! [L,U] = lu (bs);
+%! assert (L*U, bs, 1e-10);
 
 %!testif HAVE_UMFPACK ;# simple LU + row permutations
-%! [L,U,P] = lu(bs);
-%! assert(P'*L*U,bs,1e-10);
+%! [L,U,P] = lu (bs);
+%! assert (P'*L*U, bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# simple LU + row/col permutations
-%! [L,U,P,Q] = lu(bs);
-%! assert(P'*L*U*Q',bs,1e-10);
+%! [L,U,P,Q] = lu (bs);
+%! assert (P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# LU with vector permutations
-%! [L,U,P,Q] = lu(bs,'vector');
-%! assert(L(P,:)*U(:,Q),bs,1e-10);
+%! [L,U,P,Q] = lu (bs,'vector');
+%! assert (L(P,:)*U(:,Q), bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# LU with scaling
-%! [L,U,P,Q,R] = lu(bs);
-%! assert(R*P'*L*U*Q',bs,1e-10);
+%! [L,U,P,Q,R] = lu (bs);
+%! assert (R*P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# inverse
-%! assert(inv(bs)*bs,sparse(eye(rows(bs))),1e-10);
+%! assert (inv (bs)*bs, sparse (eye (rows (bs))), 1e-10);
 
-%!assert(bf\as',bf\af',100*eps);
-%!assert(bs\af',bf\af',100*eps);
-%!assert(bs\as',sparse(bf\af'),100*eps);
+%!assert (bf\as', bf\af', 100*eps);
+%!assert (bs\af', bf\af', 100*eps);
+%!assert (bs\as', sparse (bf\af'), 100*eps);
 
 EOF
 }
 
 # Cholesky tests
 gen_cholesky_tests() {
     cat >>$TESTS <<EOF
 %!testif HAVE_CHOLMOD
-%! assert(chol(bs)'*chol(bs),bs,1e-10);
+%! assert (chol (bs)'*chol (bs), bs, 1e-10);
 %!testif HAVE_CHOLMOD 
-%! assert(chol(bs,'lower')*chol(bs,'lower')',bs,1e-10);
+%! assert (chol (bs,'lower')*chol (bs,'lower')', bs, 1e-10);
 %!testif HAVE_CHOLMOD
-%! assert(chol(bs,'lower'),chol(bs)',1e-10);
+%! assert (chol (bs,'lower'), chol (bs)', 1e-10);
 
 %!testif HAVE_CHOLMOD ;# Return Partial Cholesky factorization
-%! [RS,PS] = chol(bs);
-%! assert(RS'*RS,bs,1e-10);
-%! assert(PS,0);
-%! [LS,PS] = chol(bs,'lower');
-%! assert(LS*LS',bs,1e-10);
-%! assert(PS,0);
+%! [RS,PS] = chol (bs);
+%! assert (RS'*RS, bs, 1e-10);
+%! assert (PS, 0);
+%! [LS,PS] = chol (bs,'lower');
+%! assert (LS*LS', bs, 1e-10);
+%! assert (PS, 0);
 
 %!testif HAVE_CHOLMOD ;# Permuted Cholesky factorization
-%! [RS,PS,QS] = chol(bs);
-%! assert(RS'*RS,QS*bs*QS',1e-10);
-%! assert(PS,0);
-%! [LS,PS,QS] = chol(bs,'lower');
-%! assert(LS*LS',QS*bs*QS',1e-10);
-%! assert(PS,0);
+%! [RS,PS,QS] = chol (bs);
+%! assert (RS'*RS, QS*bs*QS', 1e-10);
+%! assert (PS, 0);
+%! [LS,PS,QS] = chol (bs,'lower');
+%! assert (LS*LS', QS*bs*QS', 1e-10);
+%! assert (PS, 0);
 
 EOF
 }
 
 # test scalar operations: uses af and real scalar bf; modifies as,bf,bs
 gen_scalar_tests() {
     echo '%!test as=sparse(af);' >> $TESTS
     echo '%!test bs=bf;' >> $TESTS
@@ -743,381 +746,400 @@ gen_rectangular_tests() {
     gen_elementop_tests
     gen_sparsesparse_elementop_tests
     gen_matrixop_tests
     # gen_divop_tests # Disable rectangular \ and / for now
     gen_matrixdiag_tests
     gen_matrixreshape_tests
     cat >>$TESTS <<EOF
 %!testif HAVE_UMFPACK ;# permuted LU
-%! [L,U] = lu(bs);
-%! assert(L*U,bs,1e-10);
+%! [L,U] = lu (bs);
+%! assert (L*U, bs, 1e-10);
 
 %!testif HAVE_UMFPACK ;# simple LU + row permutations
-%! [L,U,P] = lu(bs);
-%! assert(P'*L*U,bs,1e-10);
+%! [L,U,P] = lu (bs);
+%! assert (P'*L*U, bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# simple LU + row/col permutations
-%! [L,U,P,Q] = lu(bs);
-%! assert(P'*L*U*Q',bs,1e-10);
+%! [L,U,P,Q] = lu (bs);
+%! assert (P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# LU with vector permutations
-%! [L,U,P,Q] = lu(bs,'vector');
-%! assert(L(P,:)*U(:,Q),bs,1e-10);
+%! [L,U,P,Q] = lu (bs,'vector');
+%! assert (L (P,:)*U (:,Q), bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK ;# LU with scaling
-%! [L,U,P,Q,R] = lu(bs);
-%! assert(R*P'*L*U*Q',bs,1e-10);
+%! [L,U,P,Q,R] = lu (bs);
+%! assert (R*P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 EOF
 }
 
 
 # =======================================================
 # sparse assembly tests
 
 gen_assembly_tests() {
 cat >>$TESTS <<EOF
 %%Assembly tests
 %!test
-%! m=max([m;r(:)]);
-%! n=max([n;c(:)]);
-%! funiq=fsum=zeros(m,n);
-%! funiq(r(:) + m*(c(:)-1) ) = ones(size(r(:)));
-%! funiq = sparse(funiq);
-%! for k=1:length(r), fsum(r(k),c(k)) += 1; end
-%! fsum = sparse(fsum);
-%!assert(sparse(r,c,1),sparse(fsum(1:max(r),1:max(c))));
-%!assert(sparse(r,c,1,"sum"),sparse(fsum(1:max(r),1:max(c))));
-%!assert(sparse(r,c,1,"unique"),sparse(funiq(1:max(r),1:max(c))));
-%!assert(sparse(r,c,1,m,n),sparse(fsum));
-%!assert(sparse(r,c,1,m,n,"sum"),sparse(fsum));
-%!assert(sparse(r,c,1,m,n,"unique"),sparse(funiq));
+%! m = max ([m;r(:)]);
+%! n = max ([n;c(:)]);
+%! funiq = fsum = zeros (m,n);
+%! funiq(r(:) + m*(c(:)-1) ) = ones (size (r(:)));
+%! funiq = sparse (funiq);
+%! for k=1:length(r)
+%!   fsum(r(k),c(k)) += 1;
+%! endfor
+%! fsum = sparse (fsum);
+%!assert (sparse (r,c,1), sparse (fsum(1:max(r), 1:max(c))))
+%!assert (sparse (r,c,1,"sum"), sparse (fsum(1:max (r),1:max (c))))
+%!assert (sparse (r,c,1,"unique"), sparse (funiq(1:max (r),1:max (c))))
+%!assert (sparse (r,c,1,m,n), sparse (fsum))
+%!assert (sparse (r,c,1,m,n,"sum"), sparse (fsum))
+%!assert (sparse (r,c,1,m,n,"unique"), sparse (funiq))
 
-%!assert(sparse(r,c,1i),sparse(fsum(1:max(r),1:max(c))*1i));
-%!assert(sparse(r,c,1i,"sum"),sparse(fsum(1:max(r),1:max(c))*1i));
-%!assert(sparse(r,c,1i,"unique"),sparse(funiq(1:max(r),1:max(c))*1i));
-%!assert(sparse(r,c,1i,m,n),sparse(fsum*1i));
-%!assert(sparse(r,c,1i,m,n,"sum"),sparse(fsum*1i));
-%!assert(sparse(r,c,1i,m,n,"unique"),sparse(funiq*1i));
+%!assert (sparse (r,c,1i), sparse (fsum(1:max (r),1:max (c))*1i))
+%!assert (sparse (r,c,1i,"sum"), sparse (fsum(1:max (r),1:max (c))*1i))
+%!assert (sparse (r,c,1i,"unique"), sparse (funiq(1:max (r),1:max (c))*1i))
+%!assert (sparse (r,c,1i,m,n), sparse (fsum*1i))
+%!assert (sparse (r,c,1i,m,n,"sum"), sparse (fsum*1i))
+%!assert (sparse (r,c,1i,m,n,"unique"), sparse (funiq*1i))
 
 %!test
-%! if (issparse(funiq))
-%!  assert(sparse(full(1i*funiq)),sparse(1i*funiq));
+%! if (issparse (funiq))
+%!   assert (sparse (full (1i*funiq)), sparse (1i*funiq));
 %! endif
 
-%!assert(sparse(full(funiq)),funiq);
+%!assert (sparse (full (funiq)), funiq)
 
 
 EOF
 }
 
 # =======================================================
 # sparse selection tests
 
 gen_scalar_select_tests () {
     cat >>$TESTS <<EOF
-%!assert (sparse(42)([1,1]),sparse([42,42]))
-%!assert (sparse(42*1i)([1,1]),sparse([42,42].*1i))
+%!assert (sparse (42)([1,1]), sparse ([42,42]))
+%!assert (sparse (42*1i)([1,1]), sparse ([42,42].*1i))
 EOF
 }
 
 gen_select_tests() {
     cat >>$TESTS <<EOF
 %!test as=sparse(af);
 
 %% Point tests
-%!test idx=ridx(:)+rows(as)*(cidx(:)-1);
-%!assert(sparse(as(idx)),sparse(af(idx)));
-%!assert(as(idx),sparse(af(idx)));
-%!assert(as(idx'),sparse(af(idx')));
-%!assert(as(flipud(idx(:))),sparse(af(flipud(idx(:)))))
-%!assert(as([idx,idx]),sparse(af([idx,idx])));
-%!error(as(reshape([idx;idx],[1,length(idx),2])));
+%!test idx = ridx(:) + rows (as) * (cidx (:)-1);
+%!assert (sparse (as(idx)), sparse (af(idx)))
+%!assert (as(idx), sparse (af(idx)));
+%!assert (as(idx'), sparse (af(idx')));
+%!assert (as(flipud (idx(:))), sparse (af(flipud (idx(:)))))
+%!assert (as([idx,idx]), sparse (af([idx,idx])))
+%!error (as(reshape ([idx;idx], [1,length(idx),2])))
 
 %% Slice tests
-%!assert(as(ridx,cidx), sparse(af(ridx,cidx)))
-%!assert(as(ridx,:), sparse(af(ridx,:)))
-%!assert(as(:,cidx), sparse(af(:,cidx)))
-%!assert(as(:,:), sparse(af(:,:)))
-%!assert(as((size(as,1):-1:1),:),sparse(af((size(af,1):-1:1),:)))
-%!assert(as(:,(size(as,2):-1:1)),sparse(af(:,(size(af,2):-1:1))))
+%!assert (as(ridx,cidx), sparse (af(ridx,cidx)))
+%!assert (as(ridx,:), sparse (af(ridx,:)))
+%!assert (as(:,cidx), sparse (af(:,cidx)))
+%!assert (as(:,:), sparse (af(:,:)))
+%!assert (as((size (as,1):-1:1),:), sparse (af((size (af,1):-1:1),:)))
+%!assert (as(:,(size (as,2):-1:1)), sparse (af(:, (size (af,2):-1:1))))
 
 %% Indexing tests
-%!assert(full(as([1,1],:)), af([1,1],:))
-%!assert(full(as(:,[1,1])), af(:,[1,1]))
+%!assert (full (as([1,1],:)), af([1,1],:))
+%!assert (full (as(:,[1,1])), af(:,[1,1]))
 %!test
 %! [i,j,v] = find (as);
-%! assert (as(i(1),j(1))([1,1]), sparse([v(1),v(1)]))
+%! assert (as(i(1),j(1))([1,1]), sparse ([v(1), v(1)]))
 
 %% Assignment test
 %!test
-%! ts=as;ts(:,:)=ts(fliplr(1:size(as,1)),:);
-%! tf=af;tf(:,:)=tf(fliplr(1:size(af,1)),:);
-%! assert(ts,sparse(tf));
+%! ts=as; ts(:,:) = ts(fliplr (1:size (as,1)),:);
+%! tf=af; tf(:,:) = tf(fliplr (1:size (af,1)),:);
+%! assert (ts, sparse (tf));
+%!test
+%! ts=as; ts(fliplr (1:size (as,1)),:) = ts;
+%! tf=af; tf(fliplr (1:size (af,1)),:) = tf;
+%! assert (ts, sparse (tf));
 %!test
-%! ts=as;ts(fliplr(1:size(as,1)),:)=ts;
-%! tf=af;tf(fliplr(1:size(af,1)),:)=tf;
-%! assert(ts,sparse(tf));
+%! ts=as; ts(:,fliplr (1:size (as,2))) = ts;
+%! tf=af; tf(:,fliplr (1:size (af,2))) = tf;
+%! assert (ts, sparse (tf));
 %!test
-%! ts=as;ts(:,fliplr(1:size(as,2)))=ts;
-%! tf=af;tf(:,fliplr(1:size(af,2)))=tf;
-%! assert(ts,sparse(tf));
-%!test
-%! ts(fliplr(1:size(as,1)))=as(:,1);tf(fliplr(1:size(af,1)))=af(:,1);
-%! assert(ts,sparse(tf));
+%! ts(fliplr (1:size (as,1))) = as(:,1);
+%! tf(fliplr (1:size (af,1))) = af(:,1);
+%! assert (ts, sparse (tf));
 
 %% Deletion tests
 %!test
-%! ts=as;ts(1,:)=[];tf=af;tf(1,:)=[];
-%! assert(ts,sparse(tf));
+%! ts=as; ts(1,:)=[]; tf=af; tf(1,:)=[];
+%! assert (ts, sparse (tf));
 %!test
-%! ts=as;ts(:,1)=[];tf=af;tf(:,1)=[];
-%! assert(ts,sparse(tf));
+%! ts=as; ts(:,1)=[]; tf=af; tf(:,1)=[];
+%! assert (ts, sparse (tf));
 
-%% Test 'end' keyword
-%!assert(full(as(end)), af(end))
-%!assert(full(as(1,end)), af(1,end))
-%!assert(full(as(end,1)), af(end,1))
-%!assert(full(as(end,end)), af(end,end))
-%!assert(as(2:end,2:end), sparse(af(2:end,2:end)))
-%!assert(as(1:end-1,1:end-1), sparse(af(1:end-1,1:end-1)))
+%% Test "end" keyword
+%!assert (full (as(end)), af(end))
+%!assert (full (as(1,end)), af(1,end))
+%!assert (full (as(end,1)), af(end,1))
+%!assert (full (as(end,end)), af(end,end))
+%!assert (as(2:end,2:end), sparse (af(2:end,2:end)))
+%!assert (as(1:end-1,1:end-1), sparse (af(1:end-1,1:end-1)))
 EOF
 }
 
 # =======================================================
 # sparse save and load tests
 
 gen_save_tests() {
     cat >>$TESTS <<EOF
 %!test # save ascii
-%! savefile= tmpnam();
-%! as_save=as; save("-text",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-text", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
 %!test # save binary
-%! savefile= tmpnam();
-%! as_save=as; save("-binary",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-binary", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
 %!testif HAVE_HDF5 # save hdf5
-%! savefile= tmpnam();
-%! as_save=as; save("-hdf5",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-hdf5", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
-## FIXME -- we should skip (or mark as an expected failure) the test for
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
+## FIXME: We should skip (or mark as an expected failure) the test for
 ## saving sparse matrices to MAT files when using 64-bit indexing since
 ## that is not implemented yet.
 %!test # save matlab
-%! savefile= tmpnam();
-%! as_save=as; save("-mat",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-mat", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
 EOF
 }
 
 # =============================================================
 # Specific solver tests for matrices that will test all of the solver
 # code. Uses alpha and beta
 gen_solver_tests() {
 
 if $preset; then
   cat >>$TESTS <<EOF
 %! n=8;
-%! lf=diag(1:n);lf(n-1,1)=0.5*alpha;lf(n,2)=0.25*alpha;ls=sparse(lf);
-%! uf=diag(1:n);uf(1,n-1)=2*alpha;uf(2,n)=alpha;us=sparse(uf);
-%! ts=spdiags(ones(n,3),-1:1,n,n)+diag(1:n); tf = full(ts);
+%! lf=diag (1:n); lf(n-1,1)=0.5*alpha; lf(n,2)=0.25*alpha; ls=sparse (lf);
+%! uf=diag (1:n); uf(1,n-1)=2*alpha; uf(2,n)=alpha; us=sparse (uf);
+%! ts=spdiags (ones (n,3),-1:1,n,n) + diag (1:n); tf = full (ts);
 EOF
 else
   cat >>$TESTS <<EOF
-%! n=floor(lognrnd(8,2)+1)'
-%! ls = tril(sprandn(8,8,0.2),-1).*alpha + n*speye(8); lf = full(ls);
-%! us = triu(sprandn(8,8,0.2),1).*alpha + n*speye(8); uf = full(us);
-%! ts = spdiags(randn(8,3),-1:1,8,8).*alpha; tf = full(ts);
+%! n = floor (lognrnd (8,2)+1)';
+%! ls = tril (sprandn (8,8,0.2),-1).*alpha + n*speye (8); lf = full (ls);
+%! us = triu (sprandn (8,8,0.2),1).*alpha + n*speye (8); uf = full (us);
+%! ts = spdiags (randn (8,3),-1:1,8,8).*alpha; tf = full (ts);
 EOF
 fi
 
 cat >>$TESTS <<EOF
-%! df = diag(1:n).* alpha; ds = sparse(df);
-%! pdf = df(randperm(n),randperm(n)); pds = sparse(pdf);
-%! plf = lf(randperm(n),randperm(n)); pls = sparse(plf);
-%! puf = uf(randperm(n),randperm(n)); pus = sparse(puf);
-%! bs = spdiags(repmat([1:n]',1,4),-2:1,n,n).*alpha; bf = full(bs);
-%! cf = lf + lf'; cs = sparse(cf);
-%! bcf = bf + bf'; bcs = sparse(bcf);
-%! tcf = tf + tf'; tcs = sparse(tcf);
-%! xf = diag(1:n) + fliplr(diag(1:n)).*beta; xs = sparse(xf);
-%!assert(ds\xf,df\xf,1e-10);
-%!assert(ds\xs,sparse(df\xf),1e-10);
-%!assert(pds\xf,pdf\xf,1e-10);
-%!assert(pds\xs,sparse(pdf\xf),1e-10);
-%!assert(ls\xf,lf\xf,1e-10);
-%!assert(sparse(ls\xs),sparse(lf\xf),1e-10);
-%!testif HAVE_UMFPACK
-%! assert(pls\xf,plf\xf,1e-10);
+%! df = diag (1:n).* alpha; ds = sparse (df);
+%! pdf = df(randperm (n),randperm (n));
+%! pds = sparse (pdf);
+%! plf = lf(randperm (n),randperm (n));
+%! pls = sparse (plf);
+%! puf = uf(randperm (n),randperm (n));
+%! pus = sparse (puf);
+%! bs = spdiags (repmat ([1:n]',1,4),-2:1,n,n).*alpha;
+%! bf = full (bs);
+%! cf = lf + lf'; cs = sparse (cf);
+%! bcf = bf + bf'; bcs = sparse (bcf);
+%! tcf = tf + tf'; tcs = sparse (tcf);
+%! xf = diag (1:n) + fliplr (diag (1:n)).*beta;
+%! xs = sparse (xf);
+%!assert (ds\xf, df\xf, 1e-10);
+%!assert (ds\xs, sparse (df\xf), 1e-10);
+%!assert (pds\xf, pdf\xf, 1e-10);
+%!assert (pds\xs, sparse (pdf\xf), 1e-10);
+%!assert (ls\xf, lf\xf, 1e-10);
+%!assert (sparse (ls\xs), sparse (lf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(pls\xs),sparse(plf\xf),1e-10);
-%!assert(us\xf,uf\xf,1e-10);
-%!assert(sparse(us\xs),sparse(uf\xf),1e-10);
+%! assert (pls\xf, plf\xf, 1e-10);
+%!testif HAVE_UMFPACK
+%! assert (sparse (pls\xs), sparse (plf\xf), 1e-10);
+%!assert (us\xf, uf\xf, 1e-10);
+%!assert (sparse (us\xs), sparse (uf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(pus\xf,puf\xf,1e-10);
+%! assert (pus\xf, puf\xf, 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(pus\xs),sparse(puf\xf),1e-10);
-%!assert(bs\xf,bf\xf,1e-10);
-%!assert(sparse(bs\xs),sparse(bf\xf),1e-10);
+%! assert (sparse (pus\xs), sparse (puf\xf), 1e-10);
+%!assert (bs\xf, bf\xf, 1e-10);
+%!assert (sparse (bs\xs), sparse (bf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(cs\xf,cf\xf,1e-10);
+%! assert (cs\xf, cf\xf, 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(cs\xs),sparse(cf\xf),1e-10);
+%! assert (sparse (cs\xs), sparse (cf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(bcs\xf,bcf\xf,1e-10);
+%! assert (bcs\xf, bcf\xf, 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(bcs\xs),sparse(bcf\xf),1e-10);
-%!assert(ts\xf,tf\xf,1e-10);
-%!assert(sparse(ts\xs),sparse(tf\xf),1e-10);
-%!assert(tcs\xf,tcf\xf,1e-10);
-%!assert(sparse(tcs\xs),sparse(tcf\xf),1e-10);
+%! assert (sparse (bcs\xs), sparse (bcf\xf), 1e-10);
+%!assert (ts\xf, tf\xf, 1e-10);
+%!assert (sparse (ts\xs), sparse (tf\xf), 1e-10);
+%!assert (tcs\xf, tcf\xf, 1e-10);
+%!assert (sparse (tcs\xs), sparse (tcf\xf), 1e-10);
 
 EOF
 
 cat >>$TESTS <<EOF
 %% QR solver tests
 
 %!function f(a, sz, feps)
-%! b = randn(sz); x = a \b; 
+%! b = randn (sz);
+%! x = a \ b; 
 %! assert (a * x, b, feps);
-%! b = randn(sz)+1i*randn(sz); x = a \ b;  
+%! b = randn (sz) + 1i*randn (sz);
+%! x = a \ b;  
 %! assert (a * x, b, feps);
-%! b = sprandn(sz(1),sz(2),0.2); x = a \b;
-%! assert (sparse(a * x), b, feps);
-%! b = sprandn(sz(1),sz(2),0.2)+1i*sprandn(sz(1),sz(2),0.2); x = a \b; 
-%! assert (sparse(a * x), b, feps);
+%! b = sprandn (sz(1),sz(2),0.2);
+%! x = a \ b;
+%! assert (sparse (a * x), b, feps);
+%! b = sprandn (sz(1),sz(2),0.2) + 1i*sprandn (sz(1),sz(2),0.2);
+%! x = a \ b; 
+%! assert (sparse (a * x), b, feps);
+%!endfunction
 %!testif HAVE_UMFPACK
-%! a = alpha*sprandn(10,11,0.2)+speye(10,11); f(a,[10,2],1e-10);
+%! a = alpha*sprandn (10,11,0.2) + speye (10,11);
+%! f(a,[10,2],1e-10);
 %! ## Test this by forcing matrix_type, as can't get a certain 
 %! ## result for over-determined systems.
-%! a = alpha*sprandn(10,10,0.2)+speye(10,10); matrix_type(a, "Singular");
+%! a = alpha*sprandn(10,10,0.2) + speye(10,10);
+%! matrix_type (a, "Singular");
 %! f(a,[10,2],1e-10);
 
 %% Rectanguar solver tests that don't use QR
 
 %!test
-%! ds = alpha * spdiags([1:11]',0,10,11);
-%! df = full(ds);
-%! xf = beta * ones(10,2);
-%! xs = speye(10,10);
-%!assert(ds\xf,df\xf,100*eps)
-%!assert(ds\xs,sparse(df\xs),100*eps)
+%! ds = alpha * spdiags ([1:11]',0,10,11);
+%! df = full (ds);
+%! xf = beta * ones (10,2);
+%! xs = speye (10,10);
+%!assert (ds\xf, df\xf, 100*eps)
+%!assert (ds\xs, sparse (df\xs), 100*eps)
 %!test
 %! pds = ds([2,1,3:10],:);
-%! pdf = full(pds);
-%!assert(pds\xf,pdf\xf,100*eps)
-%!assert(pds\xs,sparse(pdf\xs),100*eps)
+%! pdf = full (pds);
+%!assert (pds\xf, pdf\xf, 100*eps)
+%!assert (pds\xs, sparse (pdf\xs), 100*eps)
 %!test
-%! ds = alpha * spdiags([1:11]',0,11,10);
-%! df = full(ds);
-%! xf = beta * ones(11,2);
-%! xs = speye(11,11);
-%!assert(ds\xf,df\xf,100*eps)
-%!assert(ds\xs,sparse(df\xs),100*eps)
+%! ds = alpha * spdiags ([1:11]',0,11,10);
+%! df = full (ds);
+%! xf = beta * ones (11,2);
+%! xs = speye (11,11);
+%!assert (ds\xf, df\xf, 100*eps)
+%!assert (ds\xs, sparse (df\xs), 100*eps)
 %!test
 %! pds = ds([2,1,3:11],:);
-%! pdf = full(pds);
-%!assert(pds\xf,pdf\xf,100*eps)
-%!assert(pds\xs,sparse(pdf\xs),100*eps)
+%! pdf = full (pds);
+%!assert (pds\xf, pdf\xf, 100*eps)
+%!assert (pds\xs, sparse (pdf\xs), 100*eps)
 %!test
 %! us = alpha*[[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]];
 %!testif HAVE_UMFPACK
-%! assert(us*(us\xf),xf,100*eps)
+%! assert (us*(us\xf), xf, 100*eps)
 %!testif HAVE_UMFPACK
-%! assert(us*(us\xs),xs,100*eps)
+%! assert (us*(us\xs), xs, 100*eps)
 %!test
 %! pus = us(:,[2,1,3:12]);
 %!testif HAVE_UMFPACK
-%! assert(pus*(pus\xf),xf,100*eps)
+%! assert (pus*(pus\xf), xf, 100*eps)
 %!testif HAVE_UMFPACK
-%! assert(pus*(pus\xs),xs,100*eps)
+%! assert (pus*(pus\xs), xs, 100*eps)
 %!test
 %! us = alpha*[speye(11,9),[1;sparse(8,1);1;0]];
 %!testif HAVE_CXSPARSE
 %! [c,r] = qr (us, xf);
-%! assert(us\xf,r\c,100*eps)
+%! assert (us\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (us, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(us\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (us\xs, r\c, 100*eps)
 %!test
 %! pus = us(:,[1:8,10,9]);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pus, xf);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pus\xf,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pus\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pus, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pus\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pus\xs, r\c, 100*eps)
 %!test
-%! ls = alpha*[speye(9,11);[1,sparse(1,8),1,0]];
-%! xf = beta * ones(10,2);
-%! xs = speye(10,10);
-%!assert(ls*(ls\xf),xf,100*eps)
-%!assert(ls*(ls\xs),xs,100*eps)
+%! ls = alpha*[speye(9,11);[1, sparse(1,8),1,0]];
+%! xf = beta * ones (10,2);
+%! xs = speye (10,10);
+%!assert (ls*(ls\xf), xf, 100*eps)
+%!assert (ls*(ls\xs), xs, 100*eps)
 %!test
 %! pls = ls([1:8,10,9],:);
-%!assert(pls*(pls\xf),xf,100*eps)
-%!assert(pls*(pls\xs),xs,100*eps)
+%!assert (pls*(pls\xf), xf, 100*eps)
+%!assert (pls*(pls\xs), xs, 100*eps)
 %!test
-%! ls = alpha*[speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]];
-%! xf = beta * ones(12,2);
-%! xs = speye(12,12);
+%! ls = alpha*[speye(10,10), sparse(10,1);[1;1], sparse(2,9),[1;1]];
+%! xf = beta * ones (12,2);
+%! xs = speye (12,12);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (ls, xf);
-%! assert(ls\xf,r\c,100*eps)
+%! assert (ls\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (ls, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(ls\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (ls\xs, r\c, 100*eps)
 %!testif HAVE_CXSPARSE
 %! pls = ls(:,[1:8,10,9]);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pls, xf);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pls\xf,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pls\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pls, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pls\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pls\xs, r\c, 100*eps)
 
 EOF
 }
 
 
 # =============================================================
 # Putting it all together: defining the combined tests
 
@@ -1136,37 +1158,40 @@ fi
 echo '%!shared as,af,bs,bf' >> $TESTS
 if $preset; then
     echo '%!test af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%!test bf=3;' >>$TESTS
 else
     cat >>$TESTS <<EOF
 %!test
 %! % generate m,n from 1 to <5000
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
 %! bf = randn;
 EOF
 fi
 
 gen_scalar_tests
 gen_section
 
 # rectangular operations
 if $preset; then
     echo '%!test af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%!test bf=[0,1-1i,0,0;2+1i,0,0,0;3-1i,2+3i,0,0];' >> $TESTS
 else
     cat >>$TESTS <<EOF
 %!test
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
-%! bs=sprandn(m,n,0.3); bf = full(bs+1i*sprandn(bs));
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
+%! bs = sprandn (m,n,0.3);
+%! bf = full (bs + 1i*sprandn (bs));
 EOF
 fi
 
 gen_rectangular_tests
 gen_section
 gen_save_tests
 gen_section
 echo '%!test bf=real(bf);' >> $TESTS
@@ -1186,27 +1211,29 @@ gen_section
 # square operations
 if $preset; then
     echo '%!test af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%! as=sparse(af);' >> $TESTS
     echo '%!test bf=[0,1-1i,0,0;2+1i,0,0,0;3-1i,2+3i,0,0];' >> $TESTS
 else
     cat >>$TESTS <<EOF
 %!test
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
-%! bs=sprandn(m,n,0.3); bf = full(bs+1i*sprandn(bs));
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
+%! bs = sprandn (m,n,0.3);
+%! bf = full (bs + 1i*sprandn (bs));
 EOF
 fi
 
 cat >>$TESTS <<EOF
 %!test ;# invertible matrix
-%! bf=af'*bf+max(abs([af(:);bf(:)]))*sparse(eye(columns(as)));
-%! bs=sparse(bf);
+%! bf = af'*bf+max (abs ([af(:);bf(:)]))*sparse (eye (columns (as)));
+%! bs = sparse (bf);
 
 EOF
 
 gen_square_tests
 gen_section
 echo '%!test bf=real(bf);' >> $TESTS
 echo '%! bs=sparse(bf);' >> $TESTS
 gen_square_tests
@@ -1221,67 +1248,70 @@ gen_square_tests
 gen_section
 
 # cholesky tests
 if $preset; then
   echo '%!test bf=[5,0,1+1i,0;0,5,0,1-2i;1-1i,0,5,0;0,1+2i,0,5];' >> $TESTS
   echo '%! bs=sparse(bf);' >> $TESTS
 else
   echo '# This has a small chance of failing to create a positive definite matrix' >> $TESTS
-  echo '%!test n=floor(lognrnd(8,2)+1)' >> $TESTS
-  echo '%! bs = n*speye(n,n) + sprandn(n,n,0.3); bf = full(bs);' >> $TESTS
+  echo '%!test n=floor (lognrnd (8,2)+1)' >> $TESTS
+  echo '%! bs = n*speye (n,n) + sprandn (n,n,0.3);' >> $TESTS
+  echo '%! bf = full (bs);' >> $TESTS
 fi
 
 gen_cholesky_tests
 gen_section
 echo '%!test bf=real(bf);' >> $TESTS
 echo '%! bs=sparse(bf);' >> $TESTS
 gen_cholesky_tests
 gen_section
 
 # assembly tests
 echo '%!shared r,c,m,n,fsum,funiq' >>$TESTS
 if $use_preset; then
     cat >>$TESTS <<EOF
 %!test
-%! r=[1,1,2,1,2,3];
-%! c=[2,1,1,1,2,1];
-%! m=n=0;
+%! r = [1,1,2,1,2,3];
+%! c = [2,1,1,1,2,1];
+%! m = n = 0;
 EOF
 else
     cat >>$TESTS <<EOF
 %!test
 %! % generate m,n from 1 to <5000
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! nz=ceil((m+n)/2);
-%! r=floor(rand(5,nz)*n)+1;
-%! c=floor(rand(5,nn)*m)+1;
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! nz = ceil ((m+n)/2);
+%! r = floor (rand (5,nz)*n)+1;
+%! c = floor (rand (5,nn)*m)+1;
 EOF
 fi
 gen_assembly_tests #includes real and complex tests
 gen_section
 
 # slicing tests
 echo '%!shared ridx,cidx,idx,as,af' >>$TESTS
 if $use_preset; then
     cat >>$TESTS <<EOF
 %!test
-%! af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];
-%! ridx=[1,3]; cidx=[2,3];
+%! af = [1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];
+%! ridx = [1,3];
+%! cidx = [2,3];
 EOF
 else
     cat >>$TESTS <<EOF
 %!test
 %! % generate m,n from 1 to <5000
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
-%! ridx = ceil(m*rand(1,ceil(rand*m))
-%! cidx = ceil(n*rand(1,ceil(rand*n))
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
+%! ridx = ceil (m*rand (1,ceil (rand*m));
+%! cidx = ceil (n*rand (1,ceil (rand*n));
 EOF
 fi
 gen_scalar_select_tests
 gen_select_tests
 echo '%!test af=real(af);' >> $TESTS
 gen_select_tests
 gen_section
 echo '%!shared alpha,beta,df,pdf,lf,plf,uf,puf,bf,cf,bcf,tf,tcf,xf,ds,pds,ls,pls,us,pus,bs,cs,bcs,ts,tcs,xs' >>$TESTS
diff --git a/test/classes/test_classes.m b/test/classes/test_classes.m
--- a/test/classes/test_classes.m
+++ b/test/classes/test_classes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Robert T. Short
+## Copyright (C) 2009-2012 Robert T. Short
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/ctor-vs-method/test_ctor_vs_method.m b/test/ctor-vs-method/test_ctor_vs_method.m
--- a/test/ctor-vs-method/test_ctor_vs_method.m
+++ b/test/ctor-vs-method/test_ctor_vs_method.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m b/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
--- a/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
+++ b/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 David Bateman
+## Copyright (C) 2005-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/test_args.m b/test/test_args.m
--- a/test/test_args.m
+++ b/test/test_args.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,192 +18,219 @@
 
 ########################################
 ## No inputs or no outputs
 
 ## no input or output arguments
 %!function f ()
 %!  assert (nargin, 0);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f;
 
 ## one input with two possible inputs
 %!function f (x, y)
 %!  assert (nargin, 1);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f (1);
 
 ## no inputs, one of multiple outputs
 %!function [x, y] = f ()
 %!  assert (nargin, 0);
 %!  assert (nargout, 1);
 %!  x = 2;
+%!endfunction
 %!test
 %! assert (f (), 2);
 
 ## one of multiple inputs, one of multiple outputs
 %!function [x, y] = f (a, b)
 %!  assert (nargin, 1);
 %!  assert (nargout, 1);
 %!  x = a;
+%!endfunction
 %!test
 %! assert (f (1), 1);
 
 ########################################
 ## Varargin, varargout
 
 ## varargin and varargout with no inputs or outputs
 %!function [varargout] = f (varargin)
 %!  assert (nargin, 0);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f;
 
 ## varargin and varargout with one input
 %!function [varargout] = f (x, varargin)
 %!  assert (nargin, 1);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f (1);
 
 ## varargin and varargout with one output
 %!function [x, varargout] = f (varargin)
 %!  assert (nargin, 0);
 %!  assert (nargout, 1);
 %!  x = 2;
+%!endfunction
 %!test
 %! assert (f (), 2);
 
 ## varargin and varargout with one input and output
 %!function [varargout] = f (varargin)
 %!  assert (nargin, 1);
 %!  assert (nargout, 1);
 %!  varargout{1} = varargin{1};
+%!endfunction
 %!test
 %! assert (f (1), 1);
 
 ## multiple inputs, multiple outputs, but not all of either
 ## WARNING: The original test did not assign the outputs, it just
 ## requested them, and I think that is supposed to be an error.  It also
 ## still has a non-assigned output argument.
 %!function [x, y, z] = f (a, b, c, d, e)
 %!  assert (nargin, 4);
 %!  assert (nargout, 2);
 %!  x = a;
 %!  y = b;
+%!endfunction
 %!test
 %! [s, t] = f (1, 2, 3, 4);
-%! assert([s t], [1 2]);
+%! assert ([s t], [1 2]);
 
 ## Fully used varargin and varargout
 %!function [varargout] = f (varargin)
 %!  assert (nargin, 3);
 %!  assert (nargout, 4);
 %!  varargout{1} = varargin{1};
 %!  varargout{2} = varargin{2};
 %!  varargout{3} = varargin{3};
 %!  varargout{4} = 4;
+%!endfunction
 %!test
 %! [s, t, u, v] = f (1, 2, 3);
-%! assert([s t u v], [1 2 3 4]);
+%! assert ([s t u v], [1 2 3 4]);
 
 ## Test default arguments
 ## numeric
 %!function f (x = 0)
-%!  assert (x, 0)
+%!  assert (x, 0);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (spaces)
 %!function f (x = [0 1 2])
-%!  assert (x, [0 1 2])
+%!  assert (x, [0 1 2]);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (range)
 %!function f (x = 1:3)
-%!  assert (x, 1:3)
+%!  assert (x, 1:3);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (commas)
 %!function f (x = [0,1,2])
-%!  assert (x, [0 1 2])
+%!  assert (x, [0 1 2]);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (commas and spaces)
 %!function f (x = [0, 1, 2])
-%!  assert (x, [0 1 2])
+%!  assert (x, [0 1 2]);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric matrix
 %!function f (x = [0, 1, 2;3, 4, 5])
-%!  assert (x, [0 1 2;3 4 5])
+%!  assert (x, [0 1 2;3 4 5]);
+%!endfunction
 %!test
 %!  f()
 
 ## empty cell
 %!function f (x = {})
-%!  assert (x, {})
+%!  assert (x, {});
+%!endfunction
 %!test
 %!  f()
 
 ## full cell
 %!function f (x = {1})
-%!  assert (x, {1})
+%!  assert (x, {1});
+%!endfunction
 %!test
 %!  f()
 
 ## many cells
 %!function f (x = {1 'a' "b" 2.0 struct("a", 3)})
-%!  assert (x, {1 'a' "b" 2.0 struct("a", 3)})
+%!  assert (x, {1 'a' "b" 2.0 struct("a", 3)});
+%!endfunction
 %!test
 %!  f()
 
 ## struct
 %!function f (x = struct("a", 3))
-%!  assert (x, struct ("a", 3))
+%!  assert (x, struct ("a", 3));
+%!endfunction
 %!test
 %!  f()
 
 ## char (double quotes)
 %!function f (x = "a")
-%!  assert (x, "a")
+%!  assert (x, "a");
+%!endfunction
 %!test
 %!  f()
 
 ## char (single quotes)
 %!function f (x = 'a')
-%!  assert (x, "a")
+%!  assert (x, "a");
+%!endfunction
 %!test
 %!  f()
 
 ## char (string, double quotes)
 %!function f (x = "abc123")
-%!  assert (x, "abc123")
+%!  assert (x, "abc123");
+%!endfunction
 %!test
 %!  f()
 
 ## char (string, double quotes, punctuation)
 %!function f (x = "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\")
-%!  assert (x, "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\")
+%!  assert (x, "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\");
+%!endfunction
 %!test
 %!  f()
 
 ## Function handle (builtin)
 %!function f (x = @sin)
 %!  finfo = functions (x);
 %!  fname = finfo.function;
 %!  assert (isa (x, "function_handle") && strcmp (fname, "sin"));
+%!endfunction
 %!test
 %!  f()
 
 ## Function handle (anonymous)
 %!function f (x = @(x) x.^2)
 %!  finfo = functions (x);
 %!  ftype = finfo.type;
 %!  assert (isa (x, "function_handle") && strcmp (ftype, "anonymous"));
+%!endfunction
 %!test
 %!  f()
+
diff --git a/test/test_diag_perm.m b/test/test_diag_perm.m
--- a/test/test_diag_perm.m
+++ b/test/test_diag_perm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 E. Jason Riedy
+## Copyright (C) 2009-2012 E. Jason Riedy
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -214,52 +214,52 @@
 %! assert (full (Dr \ A), full (A) ./ repmat (scalefact, 1, n));
 
 ## narrow sparse inverse row scaling
 %!test
 %! n = 8;
 %! A = sprand (n, n, .5);
 %! scalefact = rand (n-2, 1);
 %! Dr = diag (scalefact, n, n-2);
-%! assert (full (Dr \ A), Dr \ full(A))
+%! assert (full (Dr \ A), Dr \ full(A));
 
 ## sparse inverse column scaling with a zero factor
 %!test
 %! n = 11;
 %! A = sprand (n, n, .5);
 %! scalefact = rand (1, n);
 %! Dc = diag (scalefact);
 %! scalefact(n-1) = Inf;
 %! Dc(n-1, n-1) = 0;
-%! assert (full (A / Dc), full(A) / Dc)
+%! assert (full (A / Dc), full(A) / Dc);
 
 ## short sparse inverse column scaling
 %!test
 %! n = 7;
 %! A = sprand (n, n, .5);
 %! scalefact = rand (1, n-2) + I () * rand(1, n-2);
 %! Dc = diag (scalefact, n-2, n);
-%! assert (full (A / Dc), full(A) / Dc)
+%! assert (full (A / Dc), full(A) / Dc);
 
 ## adding sparse and diagonal stays sparse
 %!test
 %! n = 9;
 %! A = sprand (n, n, .5);
 %! D = 2 * eye (n);
-%! assert (typeinfo (A + D), "sparse matrix")
-%! assert (typeinfo (A - D), "sparse matrix")
+%! assert (typeinfo (A + D), "sparse matrix");
+%! assert (typeinfo (A - D), "sparse matrix");
 %! D = D * I () + D;
-%! assert (typeinfo (A - D), "sparse complex matrix")
+%! assert (typeinfo (A - D), "sparse complex matrix");
 %! A = A * I () + A;
-%! assert (typeinfo (D - A), "sparse complex matrix")
+%! assert (typeinfo (D - A), "sparse complex matrix");
 
 ## adding sparse and diagonal stays sparse
 %!test
 %! n = 9;
 %! A = sprand (n, n, .5);
 %! D = 2 * eye (n);
-%! assert (full (A + D), full (A) + D)
-%! assert (full (A - D), full (A) - D)
+%! assert (full (A + D), full (A) + D);
+%! assert (full (A - D), full (A) - D);
 %! D = D * I () + D;
-%! assert (full (D + A), D + full (A))
+%! assert (full (D + A), D + full (A));
 %! A = A * I () + A;
 %! A(6, 4) = nan ();
-%! assert (full (D - A), D - full (A))
+%! assert (full (D - A), D - full (A));
diff --git a/test/test_error.m b/test/test_error.m
--- a/test/test_error.m
+++ b/test/test_error.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,73 +11,83 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
+## Test %!error usage
+
 %% test/octave.test/error/error-1.m
 %!function g () 
-%! error ("foo");
+%!  error ("foo");
+%!endfunction
 %!function f () 
-%! g (); 
-%!error <foo> f ();
+%!  g (); 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/error-2.m
 %!function g () 
-%! error ("foo\n");
+%!  error ("foo\n");
+%!endfunction
 %!function f () 
-%! g 
-%!error <foo> f ();
+%!  g 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/error-3.m
-%!error error ();
+%!error error ()
 
 %% test/octave.test/error/error-4.m
-%!error <foo> error ("foo\n");
+%!error <foo> error ("foo\n")
 
-%% FIXME Why can't I use %!warning <foo> f;
+## Test %!warning usage
+
 %% test/octave.test/error/warning-1.m
 %!function g ()
-%! warning ("foo");
+%!  warning ("foo");
+%!endfunction
 %!function f ()
-%! g;
-%!test
-%! fail("f","warning","foo");
+%!  g;
+%!endfunction
+%!warning <foo> f ()
 
 %% test/octave.test/error/warning-2.m
 %!test
 %! st.identifier = "backtrace";
-%! ws = warning ("query","backtrace");
-%! warning ("on","backtrace");
+%! ws = warning ("query", "backtrace");
+%! warning ("on", "backtrace");
 %! st.state = "on";
-%! assert(warning ("query","backtrace"),st);
-%! warning ("off","backtrace");
+%! assert(warning ("query", "backtrace"), st);
+%! warning ("off", "backtrace");
 %! st.state = "off";
-%! assert(warning ("query","backtrace"),st);
-%! warning (ws.state,"backtrace");
+%! assert(warning ("query", "backtrace"), st);
+%! warning (ws.state, "backtrace");
 
-%% FIXME This test no longer makes sense with new warning syntax
-%% test/octave.test/error/warning-3.m
-%!#warning <foo> warning ("foo", 1);
+## Test usage() function
 
 %% test/octave.test/error/usage-1.m
 %!function g () 
-%! usage ("foo");
+%!  usage ("foo");
+%!endfunction
 %!function f () 
-%! g (); 
-%!error <foo> f ();
+%!  g (); 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/usage-2.m
 %!function g () 
-%! usage ("foo");
+%!  usage ("foo");
+%!endfunction
 %!function f () 
-%! g 
-%!error <foo> f ();
+%!  g 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/usage-3.m
-%!error usage ();
+%!error usage ()
 
 %% test/octave.test/error/usage-4.m
-%!error <foo> usage ("foo\n");
+%!error <foo> usage ("foo\n")
 
diff --git a/test/test_eval-catch.m b/test/test_eval-catch.m
--- a/test/test_eval-catch.m
+++ b/test/test_eval-catch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,58 +17,57 @@
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/eval-catch/eval-catch-1.m
 %!test
 %! eval ("clear a; a;", "");
 
 %% test/octave.test/eval-catch/eval-catch-2.m
 %!test
-%! eval ("", "error('Shouldn't get here');");
+%! eval ("", "error ('Should not get here');");
 
 %% test/octave.test/eval-catch/eval-catch-3.m
 %!test
 %! eval ("clear a; a; x = 0;", "x = 1;");
 %! assert (x, 1);
 
-%% FIXME This is redundant with the changes to the above
-%% test/octave.test/eval-catch/eval-catch-4.m
-
 %% test/octave.test/eval-catch/eval-catch-5.m
 %!test
 %! eval ("clear a; a; str = '';", "str=lasterr;");
-%! assert(lasterr()(1:13),"`a' undefined");
-%! assert(str(1:13),"`a' undefined");
+%! assert (lasterr()(1:13), "`a' undefined");
+%! assert (str(1:13), "`a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-6.m
 %!test
-%! eval ("error (\"user-defined error\"); str = '';", "str = lasterr;");
-%! assert(lasterr()(1:18),"user-defined error");
-%! assert(str(1:18),"user-defined error");
+%! eval ("error ('user-defined error'); str = '';", "str = lasterr;");
+%! assert (lasterr()(1:18), "user-defined error");
+%! assert (str(1:18), "user-defined error");
 
 %% test/octave.test/eval-catch/eval-catch-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
 %!  ms = cstrcat ("<", s, ">");
+%!endfunction
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
-%! assert(mangle(lasterr)(1:14),"<`a' undefined");
-%! assert(str(1:14),"<`a' undefined");
+%! assert (mangle(lasterr)(1:14), "<`a' undefined");
+%! assert (str(1:14), "<`a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-8.m
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
 %! "str2 = lasterr;");
-%! assert(str1(1:13),"`a' undefined");
-%! assert(str2(1:13),"`b' undefined");
+%! assert (str1(1:13), "`a' undefined");
+%! assert (str2(1:13), "`b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-9.m
 %!test
 %! eval ("clear a; a; str1='';",
 %! "eval (\"clear b; b; str2='';\", \"str2=lasterr;\"); str1=lasterr;");
-%! assert(str1(1:13),"`b' undefined");
-%! assert(str2(1:13),"`b' undefined");
+%! assert (str1(1:13), "`b' undefined");
+%! assert (str2(1:13), "`b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-10.m
 %!test
 %! eval ("eval (\"clear a; a; str='';\",\"error (cstrcat (\\\"rethrow: \\\", lasterr));str='';\");",
 %! "str=lasterr;");
-%! assert(str(1:22),"rethrow: `a' undefined");
+%! assert (str(1:22), "rethrow: `a' undefined");
+
diff --git a/test/test_for.m b/test/test_for.m
--- a/test/test_for.m
+++ b/test/test_for.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,98 +14,98 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/for/for-1.m
 %!test
 %! for i = 1
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! end
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1"));
+%! assert (prog_output_assert ("1"));
 
 %% test/octave.test/for/for-2.m
 %!test
 %! for i = 1:4
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1234"));
+%! assert (prog_output_assert ("1234"));
 
 %% test/octave.test/for/for-3.m
 %!test
 %! for i = [1,2,3,4]
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1234"));
+%! assert (prog_output_assert ("1234"));
 
 %% test/octave.test/for/for-4.m
 %!test
 %! for i = [1,2;3,4]
-%! printf_assert ("%d", i(1,1));
-%! printf_assert ("%d", i(2,1));
+%!   printf_assert ("%d", i(1,1));
+%!   printf_assert ("%d", i(2,1));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1324"));
+%! assert (prog_output_assert ("1324"));
 
 %% test/octave.test/for/for-5.m
 %!test
 %! for i = I
-%! printf_assert ("%d", imag (i));
+%!   printf_assert ("%d", imag (i));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1"));
+%! assert (prog_output_assert ("1"));
 
 %% test/octave.test/for/for-6.m
 %!test
 %! for i = [1,2,3,4]*I
-%! printf_assert ("%d", imag (i));
+%!   printf_assert ("%d", imag (i));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1234"));
+%! assert (prog_output_assert ("1234"));
 
 %% test/octave.test/for/for-7.m
 %!test
 %! for i = [1,2;3,4]*I
-%! printf_assert ("%d", imag (i(1,1)));
-%! printf_assert ("%d", imag (i(2,1)));
+%!   printf_assert ("%d", imag (i(1,1)));
+%!   printf_assert ("%d", imag (i(2,1)));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1324"));
+%! assert (prog_output_assert ("1324"));
 
 %% test/octave.test/for/for-8.m
 %!test
 %! for i = [1,2,3,4]
-%! if (i > 2)
-%! break;
-%! endif
-%! printf_assert ("%d", i);
+%!   if (i > 2)
+%!     break;
+%!   endif
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("12"));
+%! assert (prog_output_assert ("12"));
 
 %% test/octave.test/for/for-9.m
 %!test
 %! for i = [1,2,3,4]
-%! if (i < 3)
-%! continue;
-%! endif
-%! printf_assert ("%d", i);
+%!   if (i < 3)
+%!     continue;
+%!   endif
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("34"));
+%! assert (prog_output_assert ("34"));
 
 %!test
 %! a = [1,3;2,4];
 %! j = 0;
 %! for i = cat (3, a, 4 + a)
 %!   assert (i, [1;2] + 2*j++)
 %! endfor
 
 %!test
 %! a = {1,3;2,4};
 %! j = 0;
-%! for i = cat (3, a, cellfun(@(x) 4 + x, a, 'UniformOutput', 0))
+%! for i = cat (3, a, cellfun(@(x) 4 + x, a, "UniformOutput", 0))
 %!   assert (i, {1 + 2*j; 2 + 2*j++})
 %! endfor
diff --git a/test/test_func.m b/test/test_func.m
--- a/test/test_func.m
+++ b/test/test_func.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,175 +18,175 @@
 
 ## This piece of test code ensures that all operations which work on 
 ## dimensions alone (squeeze, triu, etc.) work for all objects and 
 ## preserve type. Even if the object is an empty matrix. This code is
 ## not to check that the function itself returns teh correct result,
 ## just that the results are consistent for all types.
 
 %!function __fntestfunc__ (fn, mn, varargin)
-%!  typ = {'double', 'complex', 'logical', 'sparse', 'complex sparse', ...
-%!         'logical sparse', 'int8', 'int16', 'int32', 'int64', 'uint8', ...
-%!         'uint16', 'uint32', 'uint64', 'char', 'cell', 'struct', ...
-%!         'single', 'single complex'};
+%!  typ = {"double", "complex", "logical", "sparse", "complex sparse", ...
+%!         "logical sparse", "int8", "int16", "int32", "int64", "uint8", ...
+%!         "uint16", "uint32", "uint64", "char", "cell", "struct", ...
+%!         "single", "single complex"};
 %!
 %!  cmplx = [2, 5, 18];
 %!  nlogical = [3, 6];
 %!  ninteger = [7, 8, 9, 10, 11, 12, 13, 14];
 %!  nsparse = [4, 5, 6];
 %!  skip = {};
 %!
 %!  if (length (varargin) > 0 && iscell (varargin{1}))
 %!    skip = varargin{1};
 %!    varargin(1) = [];
 %!  endif
 %!
-%!  for i = 1 : length(typ)
+%!  for i = 1 : length (typ)
 %!    if (any (strcmp (skip, typ {i})))
 %!      continue;
 %!    endif
 %!    m = mn;
 %!
 %!    if (any (nsparse == i))
 %!      if (ndims (m) > 2)
 %!        sz = size (m);
-%!        m = reshape (m, [sz(1), prod(sz (2:end))]);
+%!        m = reshape (m, [sz(1), prod(sz(2:end))]);
 %!      endif
 %!      if (any (cmplx == i))
 %!        m = sparse ((1 + 1i) * m);
 %!      else
 %!        m = sparse (m);
 %!      endif
 %!    else
 %!      if (any (cmplx == i))
 %!        m = (1 + 1i) * m;
 %!      endif
 %!    endif
 %!    if (any (nlogical == i))
-%!      m = cast (m, 'logical');
+%!      m = cast (m, "logical");
 %!    endif
 %!    if (any (ninteger == i))
 %!      m = cast (m, typ{i});
 %!    endif
-%!    if (strcmp (typ{i}, 'cell'))
+%!    if (strcmp (typ{i}, "cell"))
 %!      m = num2cell (m);
-%!    elseif (strcmp (typ{i}, 'struct'))
-%!      m = struct ('fld', num2cell (m));
+%!    elseif (strcmp (typ{i}, "struct"))
+%!      m = struct ("fld", num2cell (m));
 %!    endif
 %!
 %!    y = feval (fn, m, varargin{:});
 %!    y2 = feval (fn, reshape (mn, size (m)), varargin{:});
 %!    if (!strcmp (class (y), class (m)) ||
 %!         issparse (y) != issparse (m) || !size_equal (y, y2))
-%!      error ('failed for type %s\n', typ{i});
+%!      error ("failed for type %s\n", typ{i});
 %!    endif
-%!    if (!(strcmp (typ{i}, 'cell') || strcmp (typ{i}, 'struct')) &&
-%!        any (vec (cast (real (y), 'double')) !=
-%!             vec (feval (fn , cast (real (m), 'double'), varargin{:}))))
-%!      error ('failed for type %s\n', typ{i});
+%!    if (!(strcmp (typ{i}, "cell") || strcmp (typ{i}, "struct")) &&
+%!        any (vec (cast (real (y), "double")) !=
+%!             vec (feval (fn , cast (real (m), "double"), varargin{:}))))
+%!      error ("failed for type %s\n", typ{i});
 %!    endif
 %!  endfor
-%! endfunction
+%!endfunction
 
 %!shared m0, m1, m2, m3
 %! m0 = [1:5];
 %! m1 = reshape ([1 : 30], [5, 6]);
 %! m2 = reshape ([1 : 30], [5, 1, 6]);
 %! m3 = [];
 
 %!test
-%! __fntestfunc__('triu', m1, {'struct'});
+%! __fntestfunc__("triu", m1, {"struct"});
 %!test
-%! __fntestfunc__ ('triu', m1, {'struct'}, -1);
+%! __fntestfunc__ ("triu", m1, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('triu', m1, {'struct'}, 1);
+%! __fntestfunc__ ("triu", m1, {"struct"}, 1);
 %!test
-%! __fntestfunc__('triu', m3, {'struct'});
+%! __fntestfunc__("triu", m3, {"struct"});
 %!test
-%! __fntestfunc__ ('tril', m1, {'struct'});
+%! __fntestfunc__ ("tril", m1, {"struct"});
 %!test
-%! __fntestfunc__ ('tril', m1, {'struct'}, -1);
+%! __fntestfunc__ ("tril", m1, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('tril', m1, {'struct'}, 1);
+%! __fntestfunc__ ("tril", m1, {"struct"}, 1);
 %!test
-%! __fntestfunc__('tril', m3, {'struct'});
+%! __fntestfunc__("tril", m3, {"struct"});
 %!test
-%! __fntestfunc__ ('squeeze', m2);
+%! __fntestfunc__ ("squeeze", m2);
 %!test
-%! __fntestfunc__ ('squeeze', m3);
+%! __fntestfunc__ ("squeeze", m3);
 %!test
-%! __fntestfunc__ ('permute', m1, [2, 1]);
+%! __fntestfunc__ ("permute", m1, [2, 1]);
 %!test
-%! __fntestfunc__ ('permute', m2, {'sparse', 'logical sparse', 'complex sparse'}, [3, 1, 2]);
+%! __fntestfunc__ ("permute", m2, {"sparse", "logical sparse", "complex sparse"}, [3, 1, 2]);
 %!test
-%! __fntestfunc__ ('permute', m3, [2, 1]);
+%! __fntestfunc__ ("permute", m3, [2, 1]);
 %!test
-%! __fntestfunc__ ('ipermute', m1, [2, 1]);
+%! __fntestfunc__ ("ipermute", m1, [2, 1]);
 %!test
-%! __fntestfunc__ ('ipermute', m2, {'sparse', 'logical sparse', 'complex sparse'}, [3, 1, 2]);
+%! __fntestfunc__ ("ipermute", m2, {"sparse", "logical sparse", "complex sparse"}, [3, 1, 2]);
 %!test
-%! __fntestfunc__ ('ipermute', m3, [2, 1]);
+%! __fntestfunc__ ("ipermute", m3, [2, 1]);
 %!test
-%! __fntestfunc__ ('shiftdim', m2, 1);
+%! __fntestfunc__ ("shiftdim", m2, 1);
 %!test
-%! __fntestfunc__ ('shiftdim', m2, {'sparse', 'logical sparse', 'complex sparse'}, -1);
+%! __fntestfunc__ ("shiftdim", m2, {"sparse", "logical sparse", "complex sparse"}, -1);
 %!test
-%! __fntestfunc__ ('shiftdim', m3, 1);
+%! __fntestfunc__ ("shiftdim", m3, 1);
 %!test
-%! __fntestfunc__ ('circshift', m2, 1);
+%! __fntestfunc__ ("circshift", m2, 1);
 %!test
-%! __fntestfunc__ ('circshift', m2, [1, -1]);
+%! __fntestfunc__ ("circshift", m2, [1, -1]);
 %!test
-%! __fntestfunc__ ('circshift', m3, 1);
+%! __fntestfunc__ ("circshift", m3, 1);
 %!test
-%! __fntestfunc__ ('reshape', m2, [6, 5]);
+%! __fntestfunc__ ("reshape", m2, [6, 5]);
 %!test
-%! __fntestfunc__ ('reshape', m3, [1, 0]);
+%! __fntestfunc__ ("reshape", m3, [1, 0]);
 %!test
-%! __fntestfunc__ ('diag', m0, {'struct'});
+%! __fntestfunc__ ("diag", m0, {"struct"});
 %!test
-%! __fntestfunc__ ('diag', m0, {'struct'}, 1);
+%! __fntestfunc__ ("diag", m0, {"struct"}, 1);
 %!test
-%! __fntestfunc__ ('diag', m0, {'struct'}, -1);
+%! __fntestfunc__ ("diag", m0, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('diag', m1, {'struct'});
+%! __fntestfunc__ ("diag", m1, {"struct"});
 %!test
-%! __fntestfunc__ ('diag', m1, {'struct'}, 1);
+%! __fntestfunc__ ("diag", m1, {"struct"}, 1);
 %!test
-%! __fntestfunc__ ('diag', m1, {'struct'}, -1);
+%! __fntestfunc__ ("diag", m1, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('diag', m3, {'struct'});
+%! __fntestfunc__ ("diag", m3, {"struct"});
 %!test
-%! __fntestfunc__ ('fliplr', m1);
+%! __fntestfunc__ ("fliplr", m1);
 %!test
-%! __fntestfunc__ ('fliplr', m3);
+%! __fntestfunc__ ("fliplr", m3);
 %!test
-%! __fntestfunc__ ('flipud', m1);
+%! __fntestfunc__ ("flipud", m1);
 %!test
-%! __fntestfunc__ ('flipud', m3);
+%! __fntestfunc__ ("flipud", m3);
 %!test
-%! __fntestfunc__ ('flipdim', m1, 2);
+%! __fntestfunc__ ("flipdim", m1, 2);
 %!test
-%! __fntestfunc__ ('flipdim', m3, 2);
+%! __fntestfunc__ ("flipdim", m3, 2);
 %!test
-%! __fntestfunc__ ('transpose', m1);
+%! __fntestfunc__ ("transpose", m1);
 %!test
-%! __fntestfunc__ ('transpose', m3);
+%! __fntestfunc__ ("transpose", m3);
 %!test
-%! __fntestfunc__ ('ctranspose', m1);
+%! __fntestfunc__ ("ctranspose", m1);
 %!test
-%! __fntestfunc__ ('ctranspose', m3);
+%! __fntestfunc__ ("ctranspose", m3);
 %!test
-%! __fntestfunc__ ('rot90', m1);
+%! __fntestfunc__ ("rot90", m1);
 %!test
-%! __fntestfunc__ ('rot90', m1, 2);
+%! __fntestfunc__ ("rot90", m1, 2);
 %!test
-%! __fntestfunc__ ('rot90', m1, -1);
+%! __fntestfunc__ ("rot90", m1, -1);
 %!test
-%! __fntestfunc__ ('rot90', m3);
+%! __fntestfunc__ ("rot90", m3);
 %!test
-%! __fntestfunc__ ('rotdim', m2, 1, [1, 2]);
+%! __fntestfunc__ ("rotdim", m2, 1, [1, 2]);
 %!test
-%! __fntestfunc__ ('rotdim', m2, 2, [1, 2]);
+%! __fntestfunc__ ("rotdim", m2, 2, [1, 2]);
 %!test
-%! __fntestfunc__ ('rotdim', m2, -1, [1, 2]);
+%! __fntestfunc__ ("rotdim", m2, -1, [1, 2]);
 %!test
-%! __fntestfunc__ ('rotdim', m3, 1, [1, 2]);
+%! __fntestfunc__ ("rotdim", m3, 1, [1, 2]);
diff --git a/test/test_global.m b/test/test_global.m
--- a/test/test_global.m
+++ b/test/test_global.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,69 +14,78 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/global/global-1.m
 %!test
 %! global G = 1;
-%! assert(G,1)
+%! assert (G,1);
 
 %% test/octave.test/global/global-2.m
 %!function f ()
 %!  global G;
-%!  assert(G,1);
+%!  assert (G,1);
+%!endfunction
 %!test
 %! global G = 1;
 %! f;
 
 %% test/octave.test/global/global-3.m
 %!function f ()
-%!  fail("G");
+%!  fail ("G");
+%!endfunction
 %!test
 %! global G = 1;
 %! f();
 
 %% test/octave.test/global/global-4.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!test
 %!  f;
-%!  fail("H");
+%!  fail ("H");
 
 %% test/octave.test/global/global-5.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!test
 %!function g ()
-%!  fail("H");
+%!  fail ("H");
 %!test
 %! g();
 
 %% test/octave.test/global/global-6.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!function g ()
 %!  global H;
-%!  assert(H,1);
+%!  assert (H,1);
+%!endfunction
 %!test
 %! f();
 %! g();
 
 %% test/octave.test/global/global-7.m
 %!test
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!test
-%! fail("H");
+%! fail ("H");
 
 %% test/octave.test/global/global-8.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!function g ()
 %!  global H;
-%!  assert(H,1)
+%!  assert (H,1);
+%!endfunction
 %!test
 %! f;
-%! clear H
+%! clear H;
 %! g;
 
diff --git a/test/test_if.m b/test/test_if.m
--- a/test/test_if.m
+++ b/test/test_if.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,73 +15,73 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/if/if-1.m
 %!test
 %! i = 0;
 %! if (i == 0)
-%! i++;
-%! printf_assert ("%d\n", i);
+%!   i++;
+%!   printf_assert ("%d\n", i);
 %! endif
-%! assert(prog_output_assert("1"));
+%! assert (prog_output_assert ("1"));
 
 %% test/octave.test/if/if-2.m
 %!test
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! else
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! end
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-3.m
 %!test
 %! x = 2;
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! endif
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-4.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (y)
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! end
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-5.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! else
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! endif
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-6.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (y)
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! end
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
diff --git a/test/test_index-wfi-t.m b/test/test_index-wfi-t.m
deleted file mode 100644
--- a/test/test_index-wfi-t.m
+++ /dev/null
@@ -1,262 +0,0 @@
-## Copyright (C) 2006-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% test/octave.test/index-wfi-t/s-1.m
-%!test
-%! a = [];
-%! assert(isempty (a));
-
-%% test/octave.test/index-wfi-t/s-2.m
-%!test
-%! a = 1;
-%! assert(a(1),1);
-
-%% test/octave.test/index-wfi-t/s-3.m
-%!test
-%! a = 1;
-%! assert(a(:),1);
-
-%% test/octave.test/index-wfi-t/s-4.m
-%!test
-%! a = 1;
-%! assert(a(:,:),1);
-
-%% test/octave.test/index-wfi-t/s-5.m
-%!test
-%! a = 1;
-%! assert(a(1,:),1);
-
-%% test/octave.test/index-wfi-t/s-6.m
-%!test
-%! a = 1;
-%! assert(a(:,1),1);
-
-%% test/octave.test/index-wfi-t/s-7.m
-%!test
-%! a = 1;
-%! assert(isempty (a(logical (0))));
-
-%% test/octave.test/index-wfi-t/s-8.m
-%!test
-%! a = 1;
-%! fail("a(-1);");
-
-%% test/octave.test/index-wfi-t/s-9.m
-%!test
-%! a = 1;
-%! fail("a(2);");
-
-%% test/octave.test/index-wfi-t/s-10.m
-%!test
-%! a = 1;
-%! fail("a(2,:);");
-
-%% test/octave.test/index-wfi-t/s-11.m
-%!test
-%! a = 1;
-%! fail("a(:,2);");
-
-%% test/octave.test/index-wfi-t/s-12.m
-%!test
-%! a = 1;
-%! fail("a(-1,:);");
-
-%% test/octave.test/index-wfi-t/s-13.m
-%!test
-%! a = 1;
-%! fail("a(:,-1);");
-
-%% test/octave.test/index-wfi-t/s-14.m
-%!test
-%! a = 1;
-%! fail("a([1,2,3]);");
-
-%% test/octave.test/index-wfi-t/s-15.m
-%!test
-%! a = 1;
-%! fail("a([1;2;3]);");
-
-%% test/octave.test/index-wfi-t/s-16.m
-%!test
-%! a = 1;
-%! fail("a([1,2;3,4]);");
-
-%% test/octave.test/index-wfi-t/s-17.m
-%!test
-%! a = 1;
-%! fail("a([0,1]);");
-
-%% test/octave.test/index-wfi-t/s-18.m
-%!test
-%! a = 1;
-%! fail("a([0;1]);");
-
-%% test/octave.test/index-wfi-t/s-19.m
-%!test
-%! a = 1;
-%! fail("a([-1,0]);");
-
-%% test/octave.test/index-wfi-t/s-20.m
-%!test
-%! a = 1;
-%! fail("a([-1;0]);");
-
-%% test/octave.test/index-wfi-t/v-1.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(1),4);
-
-%% test/octave.test/index-wfi-t/v-2.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(2),3);
-
-%% test/octave.test/index-wfi-t/v-3.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:) == a_prime));
-
-%% test/octave.test/index-wfi-t/v-4.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(1,:) == a));
-
-%% test/octave.test/index-wfi-t/v-5.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(:,3),2);
-
-%% test/octave.test/index-wfi-t/v-6.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:,:) == a));
-
-%% test/octave.test/index-wfi-t/v-7.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(logical ([0,1,1,0])) == mid_a));
-
-%% test/octave.test/index-wfi-t/v-8.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-t/v-9.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(5);");
-
-%% test/octave.test/index-wfi-t/v-10.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0,1);");
-
-%% test/octave.test/index-wfi-t/v-11.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(logical (0),:)));
-
-%% test/octave.test/index-wfi-t/v-12.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(:,0);");
-
-%% test/octave.test/index-wfi-t/v-13.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([])));
-
-%% test/octave.test/index-wfi-t/v-14.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([],:)));
-
-%% test/octave.test/index-wfi-t/v-15.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(:,[])));
-
-%% test/octave.test/index-wfi-t/m-1.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (all (a(:,:) == a)));
-
-%% test/octave.test/index-wfi-t/m-2.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (a(:) == a_fvec));
-
-%% test/octave.test/index-wfi-t/m-3.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-t/m-4.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(2);","warning");
diff --git a/test/test_index-wfi-f.m b/test/test_index.m
rename from test/test_index-wfi-f.m
rename to test/test_index.m
--- a/test/test_index-wfi-f.m
+++ b/test/test_index.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,316 +11,132 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/index-wfi-f/s-1.m
 %!test
 %! a = [];
-%! assert(isempty (a));
-
-%% test/octave.test/index-wfi-f/s-2.m
-%!test
-%! a = 1;
-%! assert(a(1),1);
-
-%% test/octave.test/index-wfi-f/s-3.m
-%!test
-%! a = 1;
-%! assert(a(:),1);
-
-%% test/octave.test/index-wfi-f/s-4.m
-%!test
-%! a = 1;
-%! assert(a(:,:),1);
-
-%% test/octave.test/index-wfi-f/s-5.m
-%!test
-%! a = 1;
-%! assert(a(1,:),1);
+%! assert (isempty (a));
 
-%% test/octave.test/index-wfi-f/s-6.m
-%!test
-%! a = 1;
-%! assert(a(:,1),1);
-
-%% test/octave.test/index-wfi-f/s-7.m
-%!test
-%! a = 1;
-%! assert(isempty (a(logical (0))));
-
-%% test/octave.test/index-wfi-f/s-8.m
-%!test
-%! a = 1;
-%! fail("a(-1)");
-
-%% test/octave.test/index-wfi-f/s-9.m
-%!test
-%! a = 1;
-%! fail("a(2);");
-
-%% test/octave.test/index-wfi-f/s-10.m
-%!test
-%! a = 1;
-%! fail("a(2,:);");
-
-%% test/octave.test/index-wfi-f/s-11.m
-%!test
+%!shared a
 %! a = 1;
-%! fail("a(:,2);");
-
-%% test/octave.test/index-wfi-f/s-12.m
-%!test
-%! a = 1;
-%! fail("a(-1,:);");
-
-%% test/octave.test/index-wfi-f/s-13.m
-%!test
-%! a = 1;
-%! fail("a(:,-1);");
-
-%% test/octave.test/index-wfi-f/s-14.m
-%!test
-%! a = 1;
-%! fail("a([1,2,3]);");
-
-%% test/octave.test/index-wfi-f/s-15.m
-%!test
-%! a = 1;
-%! fail("a([1;2;3]);");
+%!assert (a(1), 1)
+%!assert (a(:), 1)
+%!assert (a(:,:), 1)
+%!assert (a(1,:), 1)
+%!assert (a(:,1),1)
+%!assert (isempty (a(logical (0))))
+%!error a(-1)
+%!error a(2)
+%!error a(2,:)
+%!error a(:,2)
+%!error a(-1,:)
+%!error a(:,-1)
+%!error a([1,2,3])
+%!error a([1;2;3])
+%!error a([1,2;3,4])
+%!error a([0,1])
+%!error a([0;1])
+%!error a([-1,0])
+%!error a([-1;0])
 
-%% test/octave.test/index-wfi-f/s-16.m
-%!test
-%! a = 1;
-%! fail("a([1,2;3,4]);");
-
-%% test/octave.test/index-wfi-f/s-17.m
-%!test
-%! a = 1;
-%! fail("a([0,1]);");
-
-%% test/octave.test/index-wfi-f/s-18.m
-%!test
-%! a = 1;
-%! fail("a([0;1]);");
-
-%% test/octave.test/index-wfi-f/s-19.m
-%!test
-%! a = 1;
-%! fail("a([-1,0]);");
-
-%% test/octave.test/index-wfi-f/s-20.m
-%!test
-%! a = 1;
-%! fail("a([-1;0]);");
-
-%% test/octave.test/index-wfi-f/v-1.m
-%!test
+%!shared a, a_prime, mid_a
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
-%! assert(a(1),4);
-
-%% test/octave.test/index-wfi-f/v-2.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(2),3);
-
-%% test/octave.test/index-wfi-f/v-3.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:) == a_prime));
-
-%% test/octave.test/index-wfi-f/v-4.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(1,:) == a));
-
-%% test/octave.test/index-wfi-f/v-5.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(:,3),2);
-
-%% test/octave.test/index-wfi-f/v-6.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:,:) == a));
-
-%% test/octave.test/index-wfi-f/v-7.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(logical ([0,1,1,0])) == mid_a));
-
-%% test/octave.test/index-wfi-f/v-8.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0);");
 
-%% test/octave.test/index-wfi-f/v-9.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(5);");
-
-%% test/octave.test/index-wfi-f/v-10.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0,1);");
-
-%% test/octave.test/index-wfi-f/v-11.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(logical (0),:)));
+%!assert (a(1),4)
+%!assert (a(2),3)
+%!assert (all (a(:) == a_prime))
+%!assert (all (a(1,:) == a))
+%!assert (a(:,3),2)
+%!assert (all (a(:,:) == a))
+%!assert (all (a(logical ([0,1,1,0])) == mid_a))
+%!error a(0)
+%!error a(5)
+%!error a(0,1)
+%!assert (isempty (a(logical (0),:)))
+%!error a(:,0)
+%!assert (isempty (a([])))
+%!assert (isempty (a([],:)))
+%!assert (isempty (a(:,[])))
 
-%% test/octave.test/index-wfi-f/v-12.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(:,0);");
-
-%% test/octave.test/index-wfi-f/v-13.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([])));
-
-%% test/octave.test/index-wfi-f/v-14.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([],:)));
-
-%% test/octave.test/index-wfi-f/v-15.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(:,[])));
-
-%% test/octave.test/index-wfi-f/m-1.m
-%!test
+%!shared a, a_fvec, a_col_1, a_col_2, a_row_1, a_row_2
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
-%! assert(all (all (a(:,:) == a)));
 
-%% test/octave.test/index-wfi-f/m-2.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (a(:) == a_fvec));
-
-%% test/octave.test/index-wfi-f/m-3.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-f/m-4.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(a(2),3);
+%!assert (all (all (a(:,:) == a)))
+%!assert (all (a(:) == a_fvec))
+%!error a(0)
+%!assert (a(2), 3)
 
 %% Additional tests
+
 %!shared a, b
 %! a = [1,2;3,4];
 %! b = a;
 %! b(:,:,2) = [5,6;7,8];
 
-%!assert (a(:), [1;3;2;4]);
-%!assert (a(1:2), [1,3]);
-%!assert (a(:,:), [1,2;3,4]);
-%!assert (a(:,1), [1;3]);
-%!assert (a(1,1), 1);
-%!assert (a(1:2,1), [1;3]);
-%!assert (a(:,:,1), [1,2;3,4]);
+%!assert (a(:), [1;3;2;4])
+%!assert (a(1:2), [1,3])
+%!assert (a(:,:), [1,2;3,4])
+%!assert (a(:,1), [1;3])
+%!assert (a(1,1), 1)
+%!assert (a(1:2,1), [1;3])
+%!assert (a(:,:,1), [1,2;3,4])
 
 %!test
 %! c(:,:,1) = [1,2;3,4];
 %! c(:,:,2) = [1,2;3,4];
-%! assert (a(:,:,[1,1]),c)
+%! assert (a(:,:,[1,1]), c)
 
 %!test
 %! c(:,:,1,1) = [1,2;3,4];
 %! c(:,:,1,2) = [1,2;3,4];
-%! assert (a(:,:,1,[1,1]),c)
+%! assert (a(:,:,1,[1,1]), c)
 
 %!test
 %! c(:,:,1,1) = [1,2;3,4];
 %! c(:,:,2,1) = [1,2;3,4];
 %! c(:,:,1,2) = [1,2;3,4];
 %! c(:,:,2,2) = [1,2;3,4];
-%! assert (a(:,:,[1,1],[1,1]),c)
+%! assert (a(:,:,[1,1],[1,1]), c)
 
-%!assert (a(1,[]), zeros(1,0));
-%!assert (a(1,[],[1,1]), zeros(1,0,2));
-%!assert (a(1,1,[]), zeros(1,1,0));
+%!assert (a(1,[]), zeros (1,0))
+%!assert (a(1,[],[1,1]), zeros (1,0,2))
+%!assert (a(1,1,[]), zeros (1,1,0))
 
 %!test
 %! c (1:10,1) = 1:10;
 %! assert (c, [1:10]');
 
-%!assert (b(:), [1; 3; 2; 4; 5; 7; 6; 8]);
-%!assert (b(:,:), [1, 2, 5, 6; 3, 4, 7, 8]);
-%!assert (b(:,1), [1;3]);
-%!assert (b(:,:,:), reshape ([1,3,2,4,5,7,6,8],[2,2,2]));
-%!assert (b(:,1,1), [1;3]);
-%!assert (b(:,1,1,[1,1]),reshape([1,3,1,3],[2,1,1,2]));
-%!assert (b(1,3), 5);
-%!assert (b(1,[3,4]), [5,6]);
-%!assert (b(1,1:4), [1,2,5,6]);
-%!assert (b(1,[],:), zeros (1,0,2));
-%!assert (b(1,[]), zeros(1,0));
+%!assert (b(:), [1; 3; 2; 4; 5; 7; 6; 8])
+%!assert (b(:,:), [1, 2, 5, 6; 3, 4, 7, 8])
+%!assert (b(:,1), [1;3])
+%!assert (b(:,:,:), reshape ([1,3,2,4,5,7,6,8],[2,2,2]))
+%!assert (b(:,1,1), [1;3])
+%!assert (b(:,1,1,[1,1]),reshape ([1,3,1,3],[2,1,1,2]))
+%!assert (b(1,3), 5)
+%!assert (b(1,[3,4]), [5,6])
+%!assert (b(1,1:4), [1,2,5,6])
+%!assert (b(1,[],:), zeros (1,0,2))
+%!assert (b(1,[]), zeros(1,0))
 %!assert (b(:,3), [5;7])
 %!assert (b([1,2],3), [5;7])
 %!assert (b(true(2,1),3), [5;7])
 %!assert (b(false(2,1),3), zeros(0,1))
-%!assert (b([],3), zeros(0,1));
+%!assert (b([],3), zeros(0,1))
 
 %!shared x
 %! # Dummy shared block to clear any previous definitions
 %! x = 1;
 
 %!test
 %! a(1,:) = [1,3];
 %! assert (a, [1,3]);
@@ -351,40 +167,46 @@
 %! a(:,:,1) = 1:4;;
 %! assert (a, [1:4]);
 
 %!test
 %! a(:,:,1) = [1:4]';
 %! assert (a, [1:4]');
 
 %!test
-%! a(:,:,1) = reshape(1:4,[1,1,4]);
+%! a(:,:,1) = reshape (1:4,[1,1,4]);
 %! assert (a, [1:4]');
 
 %!test
 %! a(:,1,:) = 1:4;
 %! assert (a, reshape (1:4,[1,1,4]));
 
 %!test
 %! a(:,1,:) = [1:4]';
 %! assert (a, [1:4]');
 
 %!test
-%! a(:,1,:) = reshape(1:4,[1,1,4]);;
+%! a(:,1,:) = reshape (1:4,[1,1,4]);;
 %! assert (a, [1:4]');
 
 %!test
 %! a(1,:,:) = 1:4;
 %! assert (a, reshape (1:4,[1,1,4]));
 
 %!test
 %! a(1,:,:) = [1:4]';
 %! assert (a, [1:4]);
 
 %!test
-%! a(1,:,:) = reshape(1:4,[1,1,4]);
+%! a(1,:,:) = reshape (1:4,[1,1,4]);
 %! assert (a, [1:4]);
 
 %!test
-%! a(1,:,:,:) = reshape(1:4,[1,1,4]);
+%! a(1,:,:,:) = reshape (1:4,[1,1,4]);
 %! assert (a, reshape (1:4,[1,1,1,4]));
 
 %!error (a(1:2,1:2) = 1:4)
+
+%!shared x
+%! x = 1:5;
+%!error <attempted to use a complex scalar as an index> x(i)
+%!error <attempted to use a complex scalar as an index> x(j)
+%!error <attempted to use a complex scalar as an index> x(1+i)
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -38,45 +38,45 @@
 %!  persistent a2 = hilb(3);
 %!  ## complex scalar
 %!  persistent a3 = 1 + 1i;
 %!  ## complex matrix
 %!  persistent a4 = hilb(3) + 1i*hilb(3);
 %!  ## bool
 %!  persistent a5 = (1 == 1);
 %!  ## bool matrix
-%!  persistent a6 = ([ones(1,5), zeros(1,5)] == ones(1,10));
+%!  persistent a6 = ([ones(1,5), zeros(1,5)] == ones (1,10));
 %!  ## range
 %!  persistent a7 = 1:10;
 %!  ## structure
 %!  persistent a8 = struct ("a", a1, "b", a3);
 %!  ## cell array
 %!  persistent a9 = {a1, a3};
 %!  ## string
 %!  persistent a10 = ["test"; "strings"];
 %!  ## int8 array
-%!  persistent a11 = int8(floor(256*rand(2,2)));
+%!  persistent a11 = int8 (floor (256*rand (2,2)));
 %!  ## int16 array
-%!  persistent a12 = int16(floor(65536*rand(2,2)));
+%!  persistent a12 = int16 (floor (65536*rand (2,2)));
 %!  ## int32 array
-%!  persistent a13 = int32(floor(1e6*rand(2,2)));
+%!  persistent a13 = int32 (floor (1e6*rand (2,2)));
 %!  ## int64 array
-%!  persistent a14 = int64(floor(10*rand(2,2)));
+%!  persistent a14 = int64 (floor (10*rand (2,2)));
 %!  ## uint8 array
-%!  persistent a15 = uint8(floor(256*rand(2,2)));
+%!  persistent a15 = uint8 (floor (256*rand (2,2)));
 %!  ## uint16 array
-%!  persistent a16 = uint16(floor(65536*rand(2,2)));
+%!  persistent a16 = uint16 (floor (65536*rand (2,2)));
 %!  ## int32 array
-%!  persistent a17 = uint32(floor(1e6*rand(2,2)));
+%!  persistent a17 = uint32 (floor (1e6*rand (2,2)));
 %!  ## uint64 array
-%!  persistent a18 = uint64(floor(10*rand(2,2)));
+%!  persistent a18 = uint64 (floor (10*rand (2,2)));
 %!  ## sparse
-%!  persistent a19 = sprandn(100,100,0.01);
+%!  persistent a19 = sprandn (100,100,0.01);
 %!  ## complex sparse
-%!  persistent a20 = sprandn(100,100,0.01) + 1i * sprandn(100,100,0.01);
+%!  persistent a20 = sprandn (100,100,0.01) + 1i * sprandn (100,100,0.01);
 %!
 %!  ret = 0;
 %!
 %!  files = {"text.mat", "binary.mat", "mat5.mat", "mat7.mat"};
 %!  opts = {"-z -text", "-z -binary", "-z -mat", "-v7"};
 %!  tols = {2*eps, 0, 0, 0};
 %!
 %!  vars = "a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20";
@@ -172,85 +172,86 @@
 %!          || isglobal ("a16") || isglobal ("a17") || isglobal ("a18")
 %!          || isglobal ("a19") || isglobal ("a20"))
 %!        error ("failed: %s global test", file); 
 %!      endif
 %!    endfor
 %!  endif
 %!
 %!  ret = 1;
-%!
+%!endfunction
+
 %!test
 %! 
 %! [save_status, save_files] = testls (0);
 %! [load_status, load_files] = testls (1);
 %! 
 %! for f = [save_files, load_files]
 %!   unlink (f{1});
 %! endfor
 %! 
-%! assert(save_status && load_status);
-%!
+%! assert (save_status && load_status);
+
 %!test
 %! 
 %! STR.scalar_fld = 1;
 %! STR.matrix_fld = [1.1,2;3,4];
 %! STR.string_fld = "Octave";
 %! STR.struct_fld.x = 0;
 %! STR.struct_fld.y = 1;
 %! 
 %! save struct.dat -struct STR;
 %! STR = load ("struct.dat");
 %!
-%! assert(STR.scalar_fld == 1 && ...
-%!        STR.matrix_fld == [1.1,2;3,4] && ...
-%!        STR.string_fld == "Octave" && ...
-%!        STR.struct_fld.x == 0 && ...
-%!        STR.struct_fld.y == 1 );
+%! assert (STR.scalar_fld == 1 && ...
+%!         STR.matrix_fld == [1.1,2;3,4] && ...
+%!         STR.string_fld == "Octave" && ...
+%!         STR.struct_fld.x == 0 && ...
+%!         STR.struct_fld.y == 1 );
 %!
 %!
 %! save -binary struct.dat -struct STR matrix_fld str*_fld;
 %! STR = load ("struct.dat");
 %!
-%! assert(!isfield(STR,"scalar_fld") && ...
-%!        STR.matrix_fld == [1.1,2;3,4] && ...
-%!        STR.string_fld == "Octave" && ...
-%!        STR.struct_fld.x == 0 && ...
-%!        STR.struct_fld.y == 1);
+%! assert (!isfield(STR,"scalar_fld") && ...
+%!         STR.matrix_fld == [1.1,2;3,4] && ...
+%!         STR.string_fld == "Octave" && ...
+%!         STR.struct_fld.x == 0 && ...
+%!         STR.struct_fld.y == 1);
 %!
 %! delete struct.dat;
-%!
+
 %!test
-%! matrix1 = rand(100, 2);
+%! matrix1 = rand (100, 2);
 %! save -ascii matrix.ascii matrix1
 %! matrix2 = load ("matrix.ascii");
 %! assert (matrix1, matrix2, 1e-9)
 %!
 %! delete matrix.ascii;
 
-%% FIXME Disable this test as it writes to stdout and there is no easy
-%% way to recover output. Need to spawn new octave process and pipe stdout
-%% somewhere to treat this case
+%% FIXME: This test is disabled as it writes to stdout and there is no easy
+%% way to recover output.  Need to spawn new octave process and pipe stdout
+%% somewhere to treat this case.
 %% test/octave.test/io/puts-1.m
 %!#test
 %! puts ("foo\n");
 
 %% test/octave.test/io/puts-2.m
-%!assert(puts (1),-1);
+%!assert (puts (1),-1)
 
 %% test/octave.test/io/puts-3.m
-%!error <Invalid call to puts> puts ();
+%!error <Invalid call to puts> puts ()
 
 %% test/octave.test/io/puts-4.m
-%!error <Invalid call to puts> puts (1, 2);
+%!error <Invalid call to puts> puts (1, 2)
 
 %!assert (sscanf ('123456', '%10c'), '123456')
 %!assert (sscanf ('123456', '%10s'), '123456')
 
-%!assert (sscanf (['ab'; 'cd'], '%s'), 'acbd');
+%!assert (sscanf (['ab'; 'cd'], '%s'), 'acbd')
 
 %!test
 %! [val, count, msg, pos] = sscanf ("3I2", "%f");
 %! assert (val, 3);
 %! assert (count, 1);
 %! assert (msg, "");
 %! assert (pos, 2);
 
@@ -269,65 +270,65 @@
 %! assert (pos, 6);
 
 %% test/octave.test/io/sscanf-1.m
 %!test
 %! [a, b, c] = sscanf ("1.2 3 foo", "%f%d%s", "C");
 %! [v1, c1, m1] = sscanf ("1 2 3 4 5 6", "%d");
 %! [v2, c2, m2] = sscanf ("1 2 bar 3 4 5 6", "%d");
 %! 
-%! assert((a == 1.2 && b == 3 && c == "foo"
+%! assert ((a == 1.2 && b == 3 && c == "foo"
 %! && v1 == [1; 2; 3; 4; 5; 6] && c1 == 6 && ischar (m1)
 %! && v2 == [1; 2] && c2 == 2 && ischar (m2)));
 
 %% test/octave.test/io/sscanf-2.m
-%!error <Invalid call to sscanf> sscanf ();
+%!error <Invalid call to sscanf> sscanf ()
 
 %% test/octave.test/io/sscanf-3.m
-%!error sscanf (1, 2);
+%!error sscanf (1, 2)
 
 %% test/octave.test/io/sscanf-4.m
-%!error <Invalid call to sscanf> sscanf ("foo", "bar", "C", 1);
+%!error <Invalid call to sscanf> sscanf ("foo", "bar", "C", 1)
 
 %% test/octave.test/io/sscanf-5.m
 %!test
-%! [x, n] = sscanf("   0.024000 0.200 0.200 2.000         1987           5           0  0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 5 1 2    2 5 5 8 2 8 12 6 15 18 28 26 47 88 118 162 192 130 88 56 27 23 14 9 6 3 4 1 0    2 3 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.026000 0.250 0.250 2.100         3115           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0    0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1    1 1 0 1 0 1 3 2 0 5 15 25 44 66 145 179 193 172 104 57 17 11 12 2 1 0 1 1 0 1    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.028000 0.300 0.300 2.200         4929           3           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0    1 0 1 0 1 2 2 3 2 3 14 21 49 80 148 184 218 159 124 63 37 13 12 3 1 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.030000 0.350 0.350 2.300         7051           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1    0 0 1 0 0 0 2 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1    0 0 0 2 0 0 0 1 5 6 14 28 51 88 154 177 208 169 124 65 39 15 5 3 3 2 1 0 1 0 1   0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.032000 0.400 0.400 2.400         9113           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0    1 0 0 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 0    1 0 0 1 1 0 2 3 5 3 17 30 60 117 156 189 209 129 102 64 56 16 11 4 2 2 0 0 0 0   1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0   0.034000 0.450 0.450 2.500        11811           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0    0 0 2 1 0 0 1 0 5 5 15 21 57 99 149 190 195 159 130 69 41 16 10 2 5 3 0 1 0 0    0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.036000 0.500 0.500 2.600        14985           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0    0 0 0 0 1 0 0 2 2 6 10 34 60 95 126 177 194 155 99 71 44 17 6 7 2 0 0 0 3 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.038000 0.550 0.550 2.700        18391           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 2    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 1 1 0 1    2 1 0 0 0 1 0 1 3 6 19 27 52 95 161 154 169 134 94 64 37 19 9 6 0 2 1 0 0 0 0    1 2 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.040000 0.600 0.600 2.800        22933           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1    0 0 0 0 0 2 0 3 4 7 18 27 47 82 134 163 133 138 101 58 34 26 10 5 2 1 2 1 1 0    2 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.042000 0.650 0.650 2.900        27719           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 1 1 2 8 16 37 51 87 128 153 146 123 105 62 35 24 8 3 5 0 1 2 1 0 0   0 1 1 1 0 0 0 1 0 1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.044000 0.700 0.700 3.000        32922           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 2 0    0 0 0 0 0 0 0 2 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1    1 1 0 0 0 1 4 3 5 5 15 35 54 88 132 168 149 105 92 62 30 16 17 4 5 1 0 0 1 0 1   1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.046000 0.750 0.750 3.100        38973           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0    0 0 0 1 0 0 0 4 3 5 20 37 56 94 110 135 149 124 84 58 36 17 14 7 1 0 2 0 1 0 0   1 1 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1    1 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.048000 0.800 0.800 3.200        45376           5           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 2 1 1 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0    0 0 0 1 0 0 0 0 1 3 18 34 55 82 104 135 116 99 79 60 51 29 10 4 3 1 1 1 0 0 1    0 0 0 1 0 0 3 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.050000 0.850 0.850 3.300        52060           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1    0 0 0 0 0 2 2 1 3 12 24 40 39 107 121 127 138 100 86 68 44 23 15 7 3 1 1 0 1 1   0 0 2 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 2 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.052000 0.900 0.900 3.400        59454           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1    0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 2 0 2 1 0 0 0 1 0    0 1 0 0 0 0 0 3 3 6 21 32 68 90 132 111 122 107 73 57 47 24 11 7 4 2 2 1 0 0 0   0 0 0 0 0 1 0 0 1 0 0 2 0 1 1 0 0 1 0 0 0 0 0 3 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0   0.054000 0.950 0.950 3.500        67013           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0    1 0 1 0 1 2 4 3 7 9 28 31 71 94 115 96 108 78 82 60 38 17 12 11 4 3 1 1 0 2 1    0 0 0 2 1 3 0 0 0 0 3 0 0 1 0 0 0 0 0 0 0 2 0 0 0 1 0 2 0 1 0 2 0 1 0 0 1 0 0    0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.056000 1.000 1.000 3.600        75475           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 3 0 0 1    1 2 0 1 4 0 1 8 6 7 17 41 56 71 109 113 84 103 72 54 35 22 6 9 1 7 5 4 0 0 1 0   0 0 0 0 0 1 0 0 2 1 0 0 0 0 2 0 0 1 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 0 0 1 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 0 0 1 1 0 0 2 0 0 0 0    0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.058000 1.050 1.050 3.700        83558           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0    2 0 0 1 0 3 2 3 6 15 27 41 77 73 94 94 92 76 61 56 42 23 13 11 6 2 1 2 0 1 2 0   0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 0 2 0 0 0 0 0 1 2 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.060000 1.100 1.100 3.800        93087           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1    0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 2 2 0 0 0 1 0 1 1 0 0 0 1 1 0 4    0 0 1 2 0 3 1 3 5 13 33 31 65 75 77 96 97 80 59 45 36 32 18 2 5 0 1 0 0 1 0 0    3 0 0 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 0 2 0 0 2 0 1 0    0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.062000 1.150 1.150 3.900       102829           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 2 0 2    1 2 0 0 2 4 3 5 11 9 23 43 53 68 65 87 83 77 59 49 34 18 15 9 4 2 3 2 0 0 0 4    0 1 1 0 0 2 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 2 0 0 0 0 1 0 0 1 1 1 1 0 0 0 1 0    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.064000 1.200 1.200 4.000       113442           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0    0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1    2 0 0 0 2 0 4 5 11 13 29 39 61 68 61 75 76 74 73 44 37 29 19 6 3 3 2 0 1 2 1 0   0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 1 0 1 2 0 2 1 1 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0 0    0 0 0 0 1 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0    0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0   0.066000 1.250 1.250 4.100       126668           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1    0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 3 0 2 1 2 0 1 0 3 0 0 0 1 0 1 1 3    0 0 1 3 0 2 4 3 12 12 30 48 56 66 77 78 71 82 52 31 32 19 20 16 8 2 1 3 0 0 2    1 0 1 0 1 0 0 0 1 3 1 0 1 0 1 1 1 0 0 0 0 0 2 0 2 0 0 0 0 0 1 0 0 0 0 1 1 0 0    0 0 0 1 0 0 0 0 0 2 0 3 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.068000 1.300 1.300 4.200       138042           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 2 0 0 1 0 1 0 0 0 0 0    0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 3 0 0 1 0 0 1 2 0 0 0 3 0 1 0 0 3 0    1 0 1 1 3 1 4 7 11 14 27 36 44 68 72 70 71 45 44 46 29 13 16 11 5 2 0 3 0 0 0    0 1 1 2 0 0 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 2 0 0 1 1 0 1 1 1 0    0 1 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 0 1 0 0 1 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.070000 1.350 1.350 4.300       152335           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0    1 0 0 0 2 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 1 1 1 0 1 1 0 1 1 1 1 0 2 0    0 0 0 0 2 0 1 7 14 19 34 35 54 72 68 72 68 58 48 36 37 27 25 17 1 4 1 0 0 0 1    2 2 0 0 1 1 1 2 1 0 3 1 0 1 0 2 1 0 0 0 1 1 1 2 0 0 0 0 1 1 0 1 1 0 2 1 1 1 1    0 0 0 1 1 0 0 2 0 0 1 0 0 0 1 1 0 2 1 1 0 0 0 0 2 0 0 0 0 0 0 0 1 1 0 0 0 0 1    0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0   0.072000 1.400 1.400 4.400       166280           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0    2 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 3 4 2 2 0 0 0 0 0 1 1 3 1 0 3 2 2    1 2 2 0 2 2 1 8 14 26 24 29 47 47 68 65 63 55 42 41 26 29 17 8 4 4 1 0 1 2 0 0   0 1 1 2 0 1 2 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 2 1 2 1 0 0 0 0 0 1 1 2 0 2 2 0    0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.074000 1.450 1.450 4.500       179484           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0    1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 1 0 0 1 0 1 2 0 0 0 0 0 0 0 0 0 1 0    0 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 2 0 0 1 1 2 1 0    1 1 2 2 0 1 5 6 10 20 43 50 57 62 53 62 66 45 42 33 27 26 23 14 3 0 2 0 1 0 0    1 1 0 0 2 1 1 0 0 3 0 1 1 1 0 1 1 0 1 0 1 2 1 0 0 1 2 0 2 0 0 0 0 1 1 3 1 0 0    2 1 1 1 0 0 0 0 0 0 1 2 0 1 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 2 1 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0   0.076000 1.500 1.500 4.600       197657           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0    0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0 0 2 1 1 0 1 1 0 1 1 3 2 1 1 2 1 0 1 0 0 0 0    0 1 1 1 0 5 3 7 12 24 38 32 41 48 54 66 71 49 46 31 38 25 15 8 6 6 5 0 1 3 0 1   1 1 1 1 0 1 2 0 1 0 0 0 1 0 2 1 2 0 0 0 0 1 3 1 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0    4 1 1 1 0 3 0 0 0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0   0.078000 1.550 1.550 4.700       212054           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0    0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1    0 0 2 0 0 0 1 0 0 1 0 1 1 0 1 3 1 0 0 1 2 0 0 0 1 0 0 0 0 0 2 1 2 1 1 1 0 0 1    5 1 1 2 3 5 7 9 11 22 31 37 48 50 52 54 57 37 38 38 33 24 11 19 11 3 1 2 0 3 3   2 1 0 1 3 0 1 1 1 1 1 2 0 0 0 1 1 2 0 1 1 3 0 1 1 0 0 1 0 2 0 1 0 0 1 3 0 2 0    1 0 1 2 0 1 1 1 1 1 0 3 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0   0.080000 1.600 1.600 4.800       231971           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1    0 0 0 0 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 1 0 1 1 1 0 1 0 0 1 0 1 3 0 0 0 1 0    0 0 1 1 1 0 0 4 1 1 0 2 0 1 1 1 2 0 0 0 1 0 1 2 1 2 3 2 0 1 0 4 3 1 1 1 1 3 1    0 0 0 2 1 0 2 7 17 13 29 47 58 59 52 38 51 51 38 34 35 21 14 13 4 1 0 1 1 1 0    2 2 4 1 0 1 1 4 0 0 0 2 0 2 2 2 0 0 1 3 2 1 1 2 2 2 2 1 0 3 0 2 1 2 1 2 2 0 0    1 1 0 2 0 2 2 0 1 0 2 2 3 1 2 3 1 1 0 1 0 2 0 1 2 1 2 0 2 1 0 0 3 0 0 1 1 1 1    0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0   0.082000 1.650 1.650 4.900       252503           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 2 0 0    0 0 0 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0    0 0 0 0 2 0 0 1 0 1 2 2 2 1 0 2 0 1 0 1 1 2 2 0 3 0 0 4 1 0 0 3 0 0 1 2 0 1 1    1 3 0 1 0 2 9 11 25 27 34 53 41 49 43 47 36 31 38 22 30 22 18 9 5 9 2 2 1 2 2    3 1 4 1 1 0 0 1 2 0 2 1 0 0 1 3 2 2 1 0 0 0 1 2 1 0 0 0 2 1 1 0 2 0 0 1 0 0 2    1 3 1 1 1 0 2 1 1 0 2 1 0 1 3 0 0 0 0 2 0 0 1 0 0 0 0 0 1 2 1 1 1 0 2 1 0 0 0    2 0 1 0 0 0 0 1 0 0 0 0 1 0 0 2 0 1 0 1 0 0 0 0 0 0 0 0 0 0   0.084000 1.700 1.700 5.000       267889           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1    0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0    0 1 0 1 1 0 3 0 1 1 1 0 1 2 1 0 2 0 2 4 0 1 0 0 0 1 1 0 1 3 2 0 2 0 4 0 0 2 0    1 4 2 4 3 3 6 10 14 28 37 54 36 40 52 40 50 46 40 32 26 29 12 18 5 2 0 2 4 1 2   1 0 2 1 2 2 1 0 1 0 2 1 2 4 1 1 5 1 0 2 0 1 2 3 2 2 1 2 1 0 2 1 2 1 1 4 1 2 1    4 0 2 2 0 0 3 1 0 2 0 0 1 1 1 0 0 2 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.086000 1.750 1.750 5.100       290294           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 2    1 0 1 0 1 0 0 2 2 0 1 2 2 0 2 0 2 0 1 0 0 1 1 1 3 1 1 1 1 3 4 1 1 2 2 2 1 0 3    0 0 0 2 4 5 6 16 18 20 31 40 54 55 46 41 52 35 27 21 28 27 20 15 8 6 7 1 0 0 3   0 0 2 2 0 3 1 3 1 1 2 0 0 1 2 1 3 2 0 1 2 1 3 1 1 1 1 1 2 0 2 1 0 1 1 1 3 1 1    2 0 1 0 1 0 2 1 1 0 0 1 2 0 3 1 1 0 0 0 1 3 1 1 1 0 0 1 2 1 0 0 1 1 1 0 0 1 0    0 0 0 0 0 2 0 1 0 0 0 2 1 0 2 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0   0.088000 1.800 1.800 5.200       312476           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 0    0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 0 0 0 1 0 1 0 0 0 0 0 0 2    1 0 0 1 0 0 1 1 1 1 4 2 0 1 0 0 3 0 0 0 0 0 1 1 4 0 0 0 0 1 1 2 1 0 3 0 0 2 2    4 0 3 1 6 9 10 13 21 24 32 43 33 41 43 49 50 32 26 31 27 12 16 17 3 3 3 5 0 3    0 2 1 3 3 2 1 2 3 1 2 1 1 1 2 0 1 1 0 2 0 3 0 0 2 0 0 0 0 1 0 1 1 3 3 0 1 1 1    1 1 1 2 2 2 0 3 1 0 2 2 2 0 0 0 0 3 1 2 5 1 1 2 0 0 3 3 0 2 2 0 0 0 0 1 2 0 0    1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.090000 1.850 1.850 5.300       337348           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 2 0 1 0 1 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 2 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0    2 0 0 0 1 3 2 0 0 2 2 3 3 2 2 2 0 0 1 1 3 1 3 0 0 0 0 0 0 1 2 1 2 1 2 2 2 0 1    1 0 4 2 2 7 6 15 22 21 39 37 50 31 51 30 33 34 34 26 21 14 13 10 9 4 3 3 4 2 2   0 1 2 3 3 0 1 3 2 5 3 2 2 4 0 2 3 0 4 2 1 2 2 2 4 2 1 3 1 3 2 1 3 1 2 4 1 1 1    1 2 4 1 3 3 3 1 0 4 1 0 1 1 1 1 2 3 0 3 0 0 4 1 1 1 0 2 2 2 1 2 2 0 1 1 0 0 0    2 0 1 0 1 0 0 1 0 0 0 1 3 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0   0.092000 1.900 1.900 5.400       357303           3           0  0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 0 0 1 0    0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 3 1 0 1 0 0 0 0 1 0 0 1 0 0 1 1 2 2 0 0 2    2 1 1 1 1 1 1 0 1 0 0 1 1 1 3 1 1 1 1 1 0 1 4 0 1 1 1 3 0 1 1 2 2 2 0 2 3 2 2    2 2 1 2 1 3 8 22 14 32 36 46 39 42 39 29 36 38 26 24 26 18 16 19 10 9 3 6 5 0    3 2 1 1 1 2 0 2 1 1 0 1 1 3 1 0 2 4 2 2 1 4 1 2 2 1 1 0 1 2 0 2 2 2 4 2 1 1 0    2 1 3 1 2 3 4 2 3 2 3 0 1 2 1 0 0 0 4 1 1 1 2 1 3 1 0 5 1 0 0 0 0 0 0 1 0 2 0    1 2 1 0 1 0 0 0 0 0 1 1 0 1 0 1 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0   0.094000 1.950 1.950 5.500       383138           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0    0 0 1 0 0 2 1 0 1 1 1 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 2 1 1 1 1    2 1 0 2 0 1 0 3 2 1 3 0 1 3 1 1 0 5 0 1 0 1 2 0 0 1 1 2 0 0 6 1 0 3 2 2 3 4 5    0 4 2 1 5 4 11 15 22 27 28 57 38 38 40 38 39 38 27 26 30 18 14 10 10 4 4 4 3 3   2 2 2 2 1 1 1 1 2 2 3 4 1 2 3 1 2 1 2 2 2 1 3 2 1 5 0 1 1 1 3 2 2 2 1 3 1 1 0    3 2 2 0 0 2 2 2 0 0 0 2 0 1 3 1 2 3 2 1 1 0 1 1 1 0 3 2 2 1 0 0 1 3 1 1 0 1 0    0 0 0 0 1 0 0 0 0 1 0 0 3 1 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0   0.096000 2.000 2.000 5.600       409868           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 0 2 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 2 0 2 0 0 0 0 1 0 0 2 1    2 2 2 1 2 1 1 1 1 1 2 0 0 1 1 0 1 0 2 1 2 0 2 0 3 1 2 1 3 1 5 0 2 2 1 2 4 1 2    0 3 1 4 7 5 9 13 22 19 31 27 28 41 34 39 37 22 23 21 22 17 23 15 8 9 3 8 0 3 1   2 2 2 3 1 0 4 2 4 2 2 2 2 4 2 1 1 0 2 0 3 0 3 2 2 1 2 2 1 4 1 2 2 1 1 5 2 1 2    1 2 2 1 0 2 4 3 2 1 2 2 3 2 3 1 2 1 1 1 1 2 1 1 2 2 1 2 3 2 1 1 0 2 2 4 0 1 1    1 1 1 0 0 1 1 3 0 0 0 0 0 1 0 0 2 0 1 2 0 1 1 1 0 1 0 1 0 0   0.098000 2.050 2.050 5.700       439102           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 0    0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 2 0 1 1 0 0 0 0 1 1 1 0 4 0 0    0 2 1 1 0 3 4 0 1 2 2 1 0 3 0 3 2 0 0 2 0 1 0 0 1 0 1 3 1 3 5 0 2 2 3 5 2 2 2    0 3 2 3 6 5 16 21 19 23 28 29 35 42 42 44 39 33 23 30 18 25 24 15 13 5 4 2 2 0   3 3 0 0 1 3 0 1 1 3 2 4 3 4 2 1 1 1 3 1 0 0 2 2 4 2 2 1 4 2 4 2 2 2 1 2 2 1 2    0 4 2 2 3 1 2 1 1 2 2 1 2 4 2 1 4 1 2 2 2 2 0 2 0 3 0 1 0 2 1 0 4 2 1 3 2 1 0    2 1 1 1 1 0 1 1 2 1 1 1 2 0 1 0 2 1 1 0 0 1 0 0 1 0 0 0 0 0 0   0.100000 2.100 2.100 5.800       467340           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 0 1 2 0 0 0 0 0 1 0 2 0 0 2 0 0 1 1 0 0    0 1 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 2 0 2    2 4 1 0 1 1 2 3 4 1 4 1 5 1 2 1 0 2 2 2 1 5 4 1 5 4 0 1 2 4 2 2 0 2 1 2 5 4 1    1 1 2 5 7 9 16 23 31 15 22 36 36 44 42 29 31 28 28 18 35 12 10 13 8 4 3 2 2 5    1 2 3 3 1 3 3 5 2 0 3 4 1 2 2 3 0 0 5 2 3 6 2 1 2 5 3 4 3 1 1 1 1 2 2 4 0 2 3    1 2 1 2 4 5 4 3 5 2 1 2 0 5 0 2 2 4 1 0 4 1 0 2 1 2 0 0 1 3 2 4 3 0 2 3 3 3 4    2 2 0 0 0 0 1 1 0 3 2 0 1 2 0 4 2 1 1 1 2 0 0 0 0 0 0 0 0 0 0   0.102000 2.150 2.150 5.900       497495           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 2 1 0 0 0 0 1 0 1 0 0 0 0 1 2    0 0 0 0 0 2 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 2 0 0 1 0 0 0 1 0 2 2 1 0 0 0    2 0 2 1 1 1 6 3 2 0 3 2 2 2 1 1 3 4 1 0 1 2 4 2 3 3 1 1 1 1 3 3 1 4 1 3 4 3 2    3 1 2 2 5 11 11 14 26 27 28 28 28 36 39 42 29 33 24 20 29 18 13 17 13 6 10 4 3   3 6 1 0 1 0 2 1 3 2 3 1 2 3 1 2 1 2 0 2 2 3 1 3 1 1 2 4 4 1 4 3 2 2 3 5 5 3 0    2 5 3 5 1 4 1 1 3 4 2 2 2 2 1 3 0 1 1 2 2 4 2 1 3 2 0 1 2 1 0 2 3 1 2 0 0 0 2    0 0 1 3 0 0 1 2 0 3 1 0 3 1 2 2 1 1 2 0 0 0 0 2 0 0 1 0 0 0 0 0   0.104000 2.200 2.200 6.000       529288           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 3 0 2 0 2 0 0    3 2 2 0 4 0 3 2 2 1 3 1 7 3 1 1 0 4 3 2 1 0 0 3 2 3 5 2 1 4 1 5 1 0 3 2 3 0 1    2 4 7 3 7 8 12 15 20 24 34 39 34 35 27 36 34 23 22 26 15 24 12 12 14 5 3 0 7 1   1 3 5 1 2 2 2 4 3 1 2 5 2 2 3 1 1 4 2 1 3 0 4 5 4 6 4 5 3 3 3 3 1 1 5 0 6 1 2    4 2 3 2 1 3 2 0 0 0 1 3 3 0 1 4 0 3 2 3 0 3 3 0 2 3 4 3 1 1 1 2 5 3 1 2 1 1 2    4 1 0 2 4 1 3 0 0 3 0 1 3 0 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0   0.106000 2.250 2.250 6.100       560628           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 2 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1    1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 2 0 0 0 0 2 0 3 1 1 0 0 2 2 2 0 5 2 1    1 1 1 3 1 2 3 0 1 0 0 0 0 1 0 2 2 1 2 1 0 4 3 2 1 2 1 0 4 2 2 0 2 1 1 2 3 1 2    1 2 4 4 11 12 17 19 19 29 30 24 30 35 51 32 36 34 31 19 22 17 11 19 11 7 6 6 3   4 0 3 3 2 0 2 2 2 3 1 5 3 2 3 5 1 0 2 2 5 4 2 3 2 0 1 6 1 2 2 2 2 1 1 2 2 1 4    3 2 2 1 2 5 2 0 2 0 2 5 4 5 2 1 3 6 1 3 4 4 0 0 6 0 2 6 1 2 2 2 0 1 3 1 3 4 2    1 4 2 1 2 3 3 0 3 1 0 2 0 2 1 0 2 1 2 0 0 1 1 0 2 0 0 0 0 0 0 0   0.108000 2.300 2.300 6.200       593293           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 2 0 2 2 1 0 0 2 0 1 0 1 0 0 1 2 2 1 0    0 1 0 2 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 0 1 1 1 2 2 1 0 1 1 0 1 5 0 2 4 1 0 1 4    2 1 3 2 2 3 2 3 2 0 0 3 4 3 1 3 2 2 0 3 0 2 4 0 3 2 5 1 2 1 4 6 1 2 4 0 3 6 1    7 6 4 5 4 10 16 24 22 20 40 37 44 34 29 21 28 36 36 27 23 24 14 10 4 5 2 5 3 6   2 3 3 1 4 2 1 5 1 3 5 3 2 1 2 2 6 2 3 1 1 0 5 3 3 3 4 5 2 2 3 3 5 5 1 6 2 3 2    6 0 5 2 4 3 5 1 2 2 5 1 2 3 1 2 2 2 4 2 5 5 2 2 2 5 0 1 2 5 2 3 2 3 1 1 2 4 0    2 1 4 2 1 1 1 0 1 2 0 0 1 3 1 0 2 1 1 3 3 2 0 0 0 1 2 0 0 0 0   0.110000 2.350 2.350 6.300       636559           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 0 0 0 1 1 2 0 0 1 0 0 0 0 0 0 0    1 2 0 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 2 0 1 0 1 0 1 0 0 1 1 3 0 1 2 2 0 2 1    1 1 1 0 1 0 1 3 0 3 2 3 4 3 3 4 3 3 2 6 3 1 1 1 2 4 2 3 1 5 1 3 1 4 5 3 3 2 1    3 7 4 3 10 19 17 19 23 27 28 33 39 36 23 23 32 32 16 19 35 23 12 11 12 8 4 5 7   1 2 2 1 2 3 5 4 2 3 2 6 4 4 2 4 1 2 2 1 2 3 0 4 2 1 2 6 2 2 1 3 3 1 6 4 8 5 2    3 5 2 3 0 3 2 3 1 2 2 3 4 3 8 6 2 1 4 6 3 1 2 0 2 0 2 5 0 3 3 3 3 1 3 3 2 5 4    2 1 4 2 2 4 4 1 3 2 5 2 3 1 2 0 4 0 1 0 6 3 1 2 0 2 0 1 0 0 0 0   0.112000 2.400 2.400 6.400       670484           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 2    0 1 1 1 3 0 0 0 2 1 3 0 1 1 1 0 1 1 1 0 0 1 2 0 1 3 1 5 2 3 0 4 0 2 0 0 1 2 1    0 1 0 0 1 0 2 2 3 2 3 2 2 2 3 4 4 2 3 5 3 3 2 3 3 4 2 4 0 3 2 4 4 1 3 1 3 4 2    2 5 2 8 6 12 17 14 22 27 26 29 39 30 24 36 22 22 20 9 19 15 5 12 16 4 7 5 7 5    5 1 4 5 5 4 4 1 4 4 3 3 3 4 2 2 4 2 4 4 4 4 0 2 3 2 1 4 3 6 1 3 3 3 4 5 4 2 2    2 5 3 0 2 5 4 2 5 3 5 1 1 3 1 1 3 6 6 2 3 2 0 3 2 4 3 4 1 2 2 6 2 0 3 2 2 5 3    3 5 2 1 0 3 1 1 2 2 0 1 1 3 2 3 2 1 1 1 1 3 2 1 0 0 0 0 0 0 0   0.114000 2.450 2.450 6.500       711783           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 1 0 2 1 2 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1    1 2 0 1 1 0 0 0 2 1 1 1 1 1 2 1 2 3 3 1 1 1 2 3 1 3 2 2 1 0 1 1 4 4 4 1 0 4 0    0 1 1 2 1 3 2 0 3 4 1 1 1 1 3 2 0 1 3 2 1 2 1 0 3 3 2 5 4 2 5 3 4 2 2 5 3 3 3    3 5 5 8 7 14 12 28 22 24 23 36 33 26 32 27 26 18 30 24 15 13 19 15 17 6 5 7 5    4 3 5 3 1 4 4 9 5 3 1 4 0 0 6 2 5 3 3 3 1 2 3 2 4 1 5 5 3 8 2 1 1 4 1 7 5 6 6    4 4 3 2 6 3 3 3 3 1 3 4 5 4 3 4 3 1 2 3 1 2 1 2 2 6 5 2 2 2 4 2 2 0 2 3 3 2 7    4 4 1 4 2 0 3 1 1 2 1 2 3 1 3 2 2 4 3 1 4 0 0 4 2 2 2 1 0 0 0 0   0.116000 2.500 2.500 6.600       745364           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 2 1 1 2 1 1 1 0 1 0 2 0 1 1    0 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 2 3 0 1 4 4 0 4 0 1 0 1 3 3 0 2 1 2 3    2 1 1 1 2 0 4 0 0 4 5 2 5 4 1 3 5 5 4 0 4 4 2 3 2 3 5 2 2 4 2 3 4 2 3 3 3 3 3    2 4 12 10 13 14 19 22 23 24 36 19 32 25 25 36 24 18 20 21 14 18 13 8 6 9 2 9 5   2 5 3 4 4 3 3 0 4 3 2 5 3 4 2 2 6 3 4 0 2 4 1 3 4 7 4 5 3 2 4 5 5 3 4 4 4 2 3    2 4 4 2 1 5 7 1 5 2 4 1 5 5 3 4 4 3 2 4 2 4 0 6 2 3 4 1 2 2 2 4 1 4 2 2 2 5 6    5 1 4 4 2 3 3 3 1 4 3 4 2 6 2 5 3 2 2 1 3 2 2 5 1 1 0 0 1 0 0 0   0.118000 2.550 2.550 6.700       791846           4           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0    1 4 1 2 3 0 3 1 0 1 1 1 0 3 1 2 1 1 1 0 0 1 1 1 3 1 3 2 3 1 2 2 1 3 2 4 1 4 0    2 4 1 4 3 2 1 1 2 1 3 2 3 3 2 1 1 5 3 3 3 3 2 3 4 3 5 3 1 1 2 2 3 5 1 2 1 1 4    4 6 9 6 6 13 17 21 20 24 22 25 20 29 23 28 30 26 27 18 20 17 16 17 12 10 8 5 6   6 6 4 3 1 2 4 6 9 2 2 3 5 7 6 2 3 8 5 4 5 6 4 6 5 3 5 3 2 5 3 2 8 3 5 4 5 3 5    4 3 4 8 4 3 8 3 3 3 1 1 2 2 5 4 7 3 2 3 3 2 2 3 6 3 2 2 1 1 5 2 5 6 3 5 3 4 1    3 1 2 1 0 4 1 4 2 2 2 3 1 1 1 1 3 2 0 1 6 1 1 0 2 1 0 1 0 0 0 0   0.120000 2.600 2.600 6.800       833394           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 2 1 1 1 2 1 0 0 0 1 0 1 0 0 0 1 0 0 1 1 2 1 0 0    0 0 0 2 2 0 3 1 0 0 2 1 1 1 1 0 1 2 1 5 0 1 0 2 2 1 2 0 4 2 1 4 3 4 2 2 1 2 1    5 2 3 1 3 0 2 2 2 2 3 4 0 4 2 3 3 4 5 2 2 6 3 4 5 5 5 3 4 6 5 1 3 0 5 4 5 1 3    2 2 6 18 13 17 27 27 21 28 28 24 26 27 29 23 21 16 17 19 22 14 11 9 5 14 7 7 6   4 4 12 3 6 4 5 4 6 4 2 0 1 8 1 6 8 5 2 3 4 5 6 4 2 5 8 3 1 1 6 3 7 8 4 1 6 5 2   8 11 5 6 5 6 2 4 5 1 2 7 2 2 5 5 6 3 3 2 3 8 5 1 9 3 3 2 3 6 3 5 3 2 4 6 3 1 3   5 4 4 4 6 3 3 5 0 2 2 5 1 3 2 2 1 4 2 0 2 2 2 2 4 1 2 1 2 1 1 0   0.122000 2.650 2.650 6.900       876007           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 1 1 1 1 2 2 1 0 0 1 0 0 0 1 1 0 0 0 2 0 0    4 1 0 2 1 2 0 1 2 0 1 3 2 1 0 1 1 0 1 2 1 0 2 3 3 5 3 3 3 0 1 4 0 1 5 3 4 3 1    2 2 2 4 1 3 3 3 2 3 2 3 2 1 4 4 2 2 5 5 3 4 1 2 1 2 4 2 4 7 2 4 4 2 7 3 5 7 5    3 6 8 10 10 18 21 22 24 14 25 27 29 31 22 25 24 21 27 20 19 22 19 14 13 14 10    5 7 3 4 5 5 3 1 4 3 8 4 5 4 0 3 4 3 4 1 7 6 1 1 3 4 4 3 4 3 6 4 3 4 2 4 4 3 5    6 5 1 1 6 2 6 6 3 5 5 3 2 6 5 4 3 4 6 4 3 5 5 6 5 6 2 4 2 1 2 2 4 2 7 6 2 1 3    1 5 2 1 2 4 3 3 3 2 5 2 4 1 4 3 2 2 5 5 1 1 3 3 2 2 2 2 1 0 0 0 0 0   0.124000 2.700 2.700 7.000       925764           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 3 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0    1 2 0 0 3 2 0 1 2 1 1 2 0 2 1 2 2 0 0 2 3 2 3 2 2 3 2 2 4 0 2 0 5 1 3 2 3 1 2    3 2 0 6 4 3 6 2 5 0 5 2 1 4 4 5 7 4 2 3 5 2 0 2 5 2 4 7 4 4 4 8 5 3 1 7 2 2 1    5 5 5 14 19 16 22 18 30 29 25 36 23 23 22 25 25 27 26 23 14 20 16 16 10 6 6 6    4 2 6 6 6 6 6 4 6 1 0 3 4 4 5 2 4 3 2 4 4 5 5 5 6 10 6 3 6 8 5 5 8 7 4 6 4 3 4   8 5 5 7 4 6 3 5 8 4 3 4 4 3 4 3 1 3 3 7 2 4 8 3 6 4 3 3 2 5 4 4 3 7 4 5 4 4 3    4 7 2 3 3 4 3 0 2 2 4 3 4 2 4 2 2 6 4 4 6 6 1 5 1 1 2 1 0 0 0 0 0   0.126000 2.750 2.750 7.100       969560           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 1 2 0 2 0 2 2 0 1 1 1 0 0 1 0 1 1 1 1 2 0    1 2 2 1 2 0 0 1 0 1 0 2 1 0 1 0 1 1 2 0 3 0 3 4 3 1 3 2 0 4 0 1 2 0 3 1 1 2 3    2 2 2 5 1 7 1 5 1 5 4 2 0 0 1 2 1 3 2 3 3 5 4 10 10 2 5 11 4 1 2 1 7 3 5 4 4 1   5 10 8 7 9 9 20 20 21 33 21 28 20 27 32 21 29 22 20 24 15 13 27 14 13 15 10 9    3 11 6 7 5 3 6 8 5 4 4 1 3 3 5 2 7 3 6 6 1 6 4 6 5 3 4 2 4 3 3 9 4 5 4 4 5 2 3   10 4 3 2 6 10 6 3 6 5 5 5 4 8 8 5 4 3 6 4 4 2 4 4 4 5 7 4 4 4 4 5 2 2 3 4 5 2    1 3 2 6 2 7 7 1 6 4 4 6 5 5 4 0 2 2 3 2 7 5 0 4 1 1 4 6 1 0 3 2 0 0 1   0.128000 2.800 2.800 7.200      1022713           5           0  0 0 0 0 0 0 0 0 0 0 0 1 0 2 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 2 1 0 0 4 0 0 1 2 3    1 1 0 1 0 1 0 3 1 1 1 2 2 1 1 1 3 1 0 2 4 2 1 2 1 2 0 3 1 3 2 1 5 2 1 3 1 2 1    5 3 2 1 2 5 3 8 2 3 2 5 5 4 3 6 4 4 4 3 2 3 8 4 3 4 5 4 5 4 7 6 5 3 3 3 5 2 9    10 7 9 12 11 13 17 15 22 19 33 24 28 30 26 21 24 22 27 20 26 16 10 10 9 20 10    7 4 5 7 7 2 7 5 3 5 1 6 1 5 7 5 6 3 1 5 1 1 3 4 8 6 3 9 5 5 3 6 7 4 6 7 6 4 2    4 6 2 3 6 5 6 7 6 4 4 9 6 8 6 9 7 1 2 6 2 7 5 4 4 4 4 5 5 4 4 3 6 3 5 3 6 4 3    6 6 2 5 2 8 4 5 3 6 5 4 5 8 4 3 5 6 5 5 2 8 1 2 2 5 4 1 3 0 0 0 0 0   0.130000 2.850 2.850 7.300      1081669           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 5 0 0 2 2 0 0 1 0 0 0 1 1 0 2 0 2 2 2 1 0    1 0 2 2 3 1 1 0 2 0 1 0 2 1 1 2 2 0 1 4 3 0 2 1 1 0 2 5 2 1 0 1 3 2 5 2 1 2 5    2 3 4 3 6 6 6 4 6 6 3 1 3 2 3 4 7 5 2 9 7 4 1 4 4 3 2 2 2 7 4 8 4 7 4 6 8 5 1    8 6 10 18 21 18 15 21 24 21 26 22 30 28 27 23 22 21 17 25 20 17 13 17 9 12 7 8   5 4 4 5 5 2 4 1 1 2 5 7 6 4 9 7 7 5 5 5 5 5 2 4 5 3 6 8 2 4 9 4 10 5 1 4 5 5 5   10 3 2 8 6 5 7 3 13 3 3 6 5 1 4 5 9 5 2 7 4 5 6 3 5 6 5 4 5 9 6 4 3 4 4 4 5 8    5 5 0 3 6 3 4 3 7 5 6 4 3 3 6 8 4 1 3 1 2 7 3 4 6 6 1 3 4 1 0 1 0 0   0.132000 2.900 2.900 7.400      1131887           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 1 1 0 0 0 1 2 2 1 1 0 2 1 1 0 1 1 1 0 2 2 3 1 0 1 0    1 0 2 0 2 0 1 4 0 1 2 2 0 0 0 2 3 0 1 2 3 0 1 2 3 5 6 2 2 3 1 4 4 8 4 3 3 3 7    2 2 5 7 4 1 2 4 8 1 5 2 7 3 4 2 9 6 5 5 6 2 2 3 6 2 5 6 7 7 2 8 3 3 3 3 6 6 5    3 10 15 15 17 19 13 29 20 23 22 34 28 28 33 20 20 22 17 22 18 15 19 14 11 9 13   6 6 13 4 2 9 8 8 7 6 5 6 4 4 9 6 2 8 9 7 2 6 3 7 3 6 3 7 4 4 5 4 5 6 4 7 5 4     10 2 6 6 8 3 6 6 9 5 8 8 7 6 4 8 5 7 5 5 7 3 5 5 5 10 7 3 8 7 5 7 2 4 4 6 4 10   7 6 4 4 4 4 3 2 4 2 6 5 9 7 3 2 6 2 5 1 5 6 2 2 1 9 2 5 2 5 1 0 0 0 1 1   0.134000 2.950 2.950 7.500      1185706           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 2 1 0 1 1 0 0 0 0 0 1 0 1 1 2 0 1 0 1 2 0 0 0    1 1 0 1 1 1 0 2 2 0 1 3 3 2 3 0 0 2 2 3 2 1 1 3 0 0 1 1 3 4 3 1 1 9 1 4 0 1 3    4 1 3 2 6 4 7 7 3 2 8 5 2 5 2 4 6 7 3 7 7 8 4 7 2 4 7 7 9 9 2 5 5 8 3 5 7 3 6    10 6 10 15 10 13 14 29 21 23 37 26 20 28 20 16 24 25 16 19 21 20 20 17 11 10     12 8 7 7 5 5 5 4 5 6 7 3 6 5 7 5 11 9 6 8 11 6 4 6 8 8 7 7 7 4 5 4 8 5 4 3 4 8   10 7 9 4 7 6 8 9 7 3 5 7 7 6 2 6 4 7 3 9 8 12 7 6 6 6 4 5 7 2 4 7 3 2 4 4 7 1    4 5 0 4 6 3 10 8 5 4 3 4 5 7 5 7 5 7 3 5 2 5 6 4 5 2 4 1 6 6 2 4 2 0 0 1 0   0.136000 3.000 3.000 7.600      1238426           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 4 0 2 0 2 2 0 1 1 1 0 2 1 1 2 1 0 1 1 0 3 1 0    0 1 0 1 0 0 2 1 1 0 4 0 2 6 3 3 4 0 3 1 2 4 0 4 4 0 1 5 2 2 5 1 3 4 3 3 5 2 4    4 6 2 5 3 4 5 4 5 6 7 5 6 2 8 3 4 7 2 4 4 3 7 6 5 1 4 8 3 7 10 3 3 6 1 5 3 8     11 5 7 15 11 15 17 21 23 21 24 28 16 21 29 15 22 27 28 20 13 19 13 7 15 10 11    9 6 8 8 4 7 5 4 6 5 10 6 7 8 9 3 5 5 9 5 9 4 4 4 3 5 7 4 10 6 8 4 9 8 4 6 7 9    11 6 8 3 5 8 12 3 6 9 7 11 9 6 7 4 7 7 7 2 5 4 5 0 2 9 5 5 5 10 7 5 6 3 9 4 4    13 2 7 5 7 4 7 2 0 4 5 4 4 6 8 1 2 5 6 4 7 3 11 4 3 3 5 5 4 4 3 1 4 2 2 1 1 0   0.138000 3.050 3.050 7.700      1299809           6           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 2 1 1 0 0 1 0 0 2 0 1 2 0 0 3 0 0 1 3 1    2 0 2 0 1 1 2 1 2 3 2 1 2 5 2 2 2 4 3 2 5 3 0 3 2 4 5 4 3 0 5 4 1 4 3 8 6 4 4    7 4 5 4 3 6 5 6 10 3 6 6 2 6 3 4 4 3 6 7 6 8 3 4 7 5 4 9 2 4 8 5 9 8 3 7 5 7 7   13 7 11 15 17 16 18 18 18 20 17 26 25 19 20 26 31 22 18 20 18 14 11 16 4 7 11    10 8 9 9 6 3 8 8 7 5 6 10 3 5 6 6 3 12 7 8 8 2 10 4 13 9 9 12 4 5 9 7 9 5 7 4    8 9 6 7 8 10 8 7 5 7 11 6 4 4 4 6 4 9 4 5 9 10 7 4 12 7 4 9 5 10 10 6 8 4 7 2    4 7 2 6 8 4 11 3 3 9 7 6 7 3 8 7 4 8 5 3 7 4 5 5 7 4 6 7 5 5 3 5 2 5 4 1 2 0 0   1   0.140000 3.100 3.100 7.800      1361810           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 3 2 1 0 0 0 1 1 1 2 0 0 0 0 1 0 2 2 2 1 0 0 3 3 0    2 0 6 2 3 1 0 3 3 1 2 2 5 3 5 3 3 2 2 7 3 2 2 3 4 2 3 4 4 1 3 7 4 5 4 2 3 5 4    2 1 3 6 3 4 3 8 7 6 5 3 5 11 5 5 3 3 7 3 6 4 4 2 4 4 4 1 5 5 9 6 6 9 3 10 8 6    8 3 10 8 16 16 13 18 23 29 25 19 19 20 27 19 22 27 24 21 15 18 11 20 21 17 12    5 18 6 12 7 9 11 7 12 11 4 8 8 4 8 7 7 2 6 4 4 9 6 9 3 4 7 7 7 4 10 4 11 5 8 8   8 5 4 4 8 6 4 9 8 12 12 8 5 8 3 10 8 7 5 3 5 6 8 5 6 10 7 2 11 2 5 5 6 8 10 2    7 5 5 14 2 7 3 9 3 5 2 8 2 3 4 4 7 9 5 4 7 6 7 5 6 3 5 4 7 6 7 7 9 3 0 2 1 1 1   0 0   0.142000 3.150 3.150 7.900      1429499           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 2 1 1 0 0 0 3 0 2 2 1 0 3 0 2 1 3 0 0 1    1 3 1 2 4 1 5 3 5 1 0 7 1 3 2 3 2 2 2 3 0 0 1 3 6 3 2 2 4 4 4 6 4 3 6 4 10 3 7   2 5 4 7 4 5 8 4 7 4 1 7 11 5 2 10 2 11 3 7 8 10 9 6 3 5 3 6 3 10 11 5 5 9 7 10   8 9 5 15 11 9 18 18 15 24 17 23 17 19 25 17 24 18 37 16 17 21 17 14 20 17 15     15 9 4 11 7 3 8 10 8 8 6 8 3 4 5 8 4 6 3 9 9 6 2 10 4 4 3 8 4 9 1 7 5 9 7 10 9   10 4 6 5 8 6 6 10 10 6 5 7 6 6 10 5 7 8 8 8 7 7 11 12 8 3 10 6 9 13 11 4 6 7 6   3 10 5 8 4 7 7 7 5 8 4 9 5 5 7 6 6 7 11 11 7 8 5 3 5 7 7 10 3 3 6 5 7 9 2 3 7    1 0 0 0 0 1   0.144000 3.200 3.200 8.000      1493946           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 2 3 0 0 1 2 1 1 1 4 1 0 1 0 1 2 1 3 1 1 1 1 2    1 1 3 2 6 0 4 0 1 4 2 4 5 2 1 3 0 2 2 4 2 3 2 4 3 5 4 4 4 1 5 1 3 4 5 6 4 7 2    8 8 8 5 3 6 0 7 3 2 2 5 7 5 7 5 8 9 6 4 3 6 8 6 10 2 5 6 3 3 6 6 6 6 17 5 10 6   6 11 11 13 12 21 26 18 24 21 24 23 30 18 22 20 24 19 13 17 25 22 17 15 8 13 7    10 8 9 6 7 9 8 7 8 9 7 7 6 12 5 9 9 12 9 12 6 9 7 10 7 7 4 9 7 4 2 7 4 5 8 8 9   7 6 7 5 9 4 8 13 6 5 4 7 9 6 7 7 9 4 4 5 8 10 9 10 6 6 7 9 12 11 8 8 9 11 5 8    7 5 5 8 5 9 10 5 5 11 11 6 8 8 4 8 5 5 5 4 7 4 5 6 5 6 6 7 7 4 2 6 3 2 1 0 0 0   0 0   0.146000 3.250 3.250 8.100      1562352           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 2 0 1 2 1 1 0 0 1 0 1 2 0 0 0 3 1 2 0 4 4 2 0    0 2 3 2 0 1 3 3 4 0 1 4 3 3 4 5 5 4 2 1 4 2 5 3 2 7 6 3 5 6 5 5 5 1 5 2 7 4 8    7 4 6 5 7 5 3 5 8 1 6 4 6 8 7 6 7 6 3 4 6 3 5 8 4 10 3 3 11 6 5 3 9 6 4 3 17 9   11 11 24 13 15 14 25 26 26 21 17 32 32 22 18 25 29 29 27 24 21 12 23 14 12 11    9 17 7 9 11 3 7 6 5 5 12 3 6 8 7 4 7 11 10 8 9 5 8 2 10 9 8 10 10 7 7 4 7 5 7    7 9 10 8 7 7 16 6 8 10 5 6 6 12 12 7 11 11 8 9 7 8 12 10 7 8 7 11 8 9 7 7 4 9    4 7 14 9 8 8 13 9 8 7 13 5 9 5 7 4 9 5 7 8 7 8 7 3 10 9 3 4 4 4 5 2 6 6 3 5 10   4 4 2 3 0 1 0 0   0.148000 3.300 3.300 8.200      1630559           3           0  0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 4 2 1 1 1 2 1 2 0 2 1 5 0 1 1 4 0 2 1 4 5 3 0    1 1 1 2 1 3 3 3 1 1 1 1 1 3 4 6 6 8 8 4 3 2 7 2 2 1 7 4 4 5 1 10 6 4 4 4 3 3 3   6 11 6 4 5 4 8 5 5 9 4 5 5 7 6 4 13 12 3 6 7 5 2 7 9 7 8 8 4 7 6 4 10 6 8 9 9    9 13 15 17 23 25 13 16 24 22 26 21 27 24 24 21 21 21 15 17 22 25 21 22 17 14     11 8 12 5 9 7 8 5 11 10 6 6 5 9 13 10 9 8 8 8 6 4 9 10 9 9 7 8 7 5 7 8 14 13 5   14 5 12 11 8 9 6 5 4 9 13 7 10 13 11 11 8 5 9 10 8 7 6 7 13 3 13 8 7 13 17 5 8   5 10 7 12 7 6 6 9 7 8 8 11 8 11 9 11 11 8 5 6 10 4 9 3 10 8 7 10 8 7 8 10 10 7   4 11 5 7 8 2 4 3 0 0 1 0 1   0.150000 3.350 3.350 8.300      1707576           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 1 2 1 0 2 0 2 3 1 3 2 2 2 2 0 2 1 4 3 2 2 3    1 2 1 0 2 2 4 2 5 3 3 5 2 8 4 5 4 2 3 6 7 6 1 0 7 4 7 7 6 5 4 3 4 6 6 7 6 2 7    4 4 2 5 5 6 9 3 3 3 6 6 5 3 5 7 8 8 6 8 8 6 8 3 9 6 6 8 8 6 4 8 6 6 10 4 11 6    11 15 23 16 8 17 20 21 19 24 15 14 19 21 30 25 21 15 19 16 18 21 21 15 14 12     16 8 10 12 7 10 9 8 10 10 7 9 8 10 12 6 6 9 11 6 5 9 12 6 7 12 7 5 6 8 5 9 4     11 9 8 8 10 7 6 10 7 11 13 7 4 13 11 8 11 9 16 6 12 11 10 10 19 2 9 11 8 7 8 8   6 13 6 10 12 12 9 12 9 9 8 7 7 9 6 12 8 4 9 9 8 5 7 8 9 5 12 5 7 5 9 10 9 10 3   6 6 8 7 11 3 5 5 4 2 0 0 0 0   0.152000 3.400 3.400 8.400      1777231           3           0  0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 1 3 1 0 3 4 2 3 3 3 3 3 2 1 1 1 1 3 3 0    1 8 0 0 5 3 7 4 4 4 4 4 3 5 2 2 5 3 6 1 7 6 1 2 2 5 2 1 6 6 8 7 7 5 10 4 1 6 9   3 4 5 3 5 8 4 9 8 11 8 3 2 7 7 9 10 9 10 8 6 8 6 8 7 10 8 7 3 8 4 10 7 6 8 9 6   5 16 9 19 24 23 17 23 24 22 30 21 15 23 27 20 20 20 18 20 23 18 17 15 19 17 18   13 9 4 4 7 12 7 10 4 8 6 10 5 6 13 2 3 8 7 8 7 3 11 8 7 9 7 19 7 8 9 6 14 8 8    11 10 11 13 14 10 16 8 9 13 8 9 9 12 7 12 11 6 9 15 5 9 9 9 11 11 13 6 10 6 4    12 9 9 12 11 8 6 9 16 10 10 10 8 10 10 6 7 4 1 15 6 8 4 9 13 11 8 10 11 9 8 3    3 6 6 7 9 4 6 8 7 4 2 1 2 2 1 0   0.154000 3.450 3.450 8.500      1849489           6           0  0 0 0 0 0 0 0 0 0 0 1 1 3 0 1 2 2 0 1 4 1 1 0 1 0 2 1 0 0 1 1 1 1 6 3 6 1 3 1    3 3 0 6 0 4 2 7 4 6 4 4 3 7 4 5 7 5 5 2 3 9 9 2 5 5 3 9 4 2 7 6 2 8 2 5 7 12 6   5 4 5 10 4 12 10 6 4 14 7 9 10 11 7 7 7 7 3 9 7 4 3 8 7 5 7 9 6 8 9 6 8 8 12 6   5 11 12 13 11 13 21 26 19 23 25 18 23 22 23 23 18 27 20 15 20 25 24 19 18 12     14 13 15 8 15 10 11 7 9 13 11 12 13 11 11 7 11 13 6 5 10 6 6 10 8 14 5 14 11 8   5 9 7 10 10 8 7 15 13 3 13 12 18 15 7 10 9 10 8 15 9 6 8 9 10 10 9 5 7 7 5 10    11 13 12 12 12 10 6 17 10 11 9 4 8 7 6 6 9 12 8 16 18 7 5 10 8 12 10 15 6 13     11 6 10 16 10 11 16 8 9 5 11 10 14 11 5 2 5 7 3 1 1 0 1 0   0.156000 3.500 3.500 8.600      1920727           4           0  0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 2 1 2 0 3 0 1 1 0 1 0 3 0 4 4 1 3 1 2 3 3 4 3    1 2 3 9 5 2 3 7 3 3 6 5 2 6 1 4 3 2 3 6 5 1 8 3 8 5 3 7 6 13 11 9 5 8 7 7 5 8    7 4 8 6 4 10 4 6 5 6 9 9 12 6 7 10 9 9 8 8 3 8 9 8 8 2 12 11 13 8 13 7 8 6 6 9   6 8 16 13 14 16 16 22 20 21 21 17 20 18 19 22 20 11 20 22 21 14 19 15 23 17 15   12 14 19 16 10 11 14 11 9 11 9 12 8 16 14 9 6 18 10 11 7 10 11 17 10 13 8 10     12 9 12 7 7 10 10 11 11 9 8 8 14 10 10 9 14 9 14 13 9 19 16 17 4 11 8 12 11 10   21 6 10 8 9 12 9 7 7 12 7 16 14 10 13 6 13 8 9 10 6 10 8 7 10 4 6 11 19 12 6 7   5 8 11 10 12 13 9 6 10 5 11 11 4 14 10 7 2 6 5 1 2 5 1 1 0 0   0.158000 3.550 3.550 8.700      1999833           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 2 3 2 2 2 1 2 3 0 1 0 1 3 2 0 0 3 2 3 2 5 7 0    3 4 1 10 7 7 4 5 2 3 4 3 8 3 6 4 4 4 8 2 3 4 5 5 7 1 6 7 8 1 6 8 1 4 4 11 9 4    7 11 9 10 5 6 8 4 3 9 7 9 11 5 5 8 8 4 8 7 8 11 9 12 6 4 13 4 12 10 6 9 11 10    11 10 11 11 11 14 15 14 23 18 17 29 16 26 23 15 19 14 18 19 22 31 13 21 20 12    16 15 14 18 17 15 8 12 14 13 10 10 10 10 10 13 11 6 8 11 8 14 8 10 11 11 8 10    13 5 14 7 12 9 10 10 12 15 18 8 6 9 9 12 8 9 20 14 16 10 11 14 5 5 13 6 11 9     11 15 6 9 13 11 7 8 7 10 8 16 12 11 8 10 14 11 17 11 8 16 13 9 10 5 10 17 13     14 16 8 10 9 11 5 10 9 10 12 8 11 12 11 8 6 7 12 15 13 12 7 13 5 0 3 2 0 0 0 0   0.160000 3.600 3.600 8.800      2073149           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 1 2 1 2 2 1 0 2 2 1 0 3 6 4 5 5 2 2 2 5 5 3 6 4    6 4 5 2 4 4 3 2 4 6 3 3 6 5 7 4 5 7 5 3 5 6 13 5 3 10 5 9 7 4 5 6 5 10 6 5 5 6   6 4 14 7 6 11 6 9 10 9 8 5 3 8 10 10 6 6 8 9 5 6 14 7 11 10 9 9 11 13 8 4 5 10   12 6 16 8 8 7 19 20 23 10 16 27 25 23 19 26 21 16 20 21 24 18 25 8 11 13 16 18   13 22 18 9 16 4 16 10 12 13 9 7 9 8 17 11 10 13 10 14 4 9 12 16 8 9 16 17 13     11 14 8 8 13 9 11 15 10 11 14 8 6 4 9 11 18 9 9 8 9 15 11 11 11 9 6 13 13 10 7   8 10 15 14 9 7 4 10 12 17 10 14 13 10 10 12 20 9 7 6 11 15 11 10 8 9 6 10 13     17 6 8 9 6 13 13 16 10 15 5 11 14 11 12 6 5 12 9 4 9 2 4 1 1 0 0 0   0.162000 3.650 3.650 8.900      2156456           5           0  0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 2 0 1 1 3 2 3 4 3 3 2 1 3 6 5 2 3 4 4 3 6 2 3    4 4 5 5 3 4 1 4 5 9 3 3 4 3 3 8 5 6 12 2 10 3 4 6 8 9 8 8 2 2 7 5 8 2 8 9 7 2    6 8 6 5 8 2 7 5 6 13 5 6 8 11 6 10 5 6 3 8 10 11 10 10 14 10 11 8 11 8 12 6 12   5 15 12 13 10 13 13 18 23 12 21 18 21 23 20 30 20 23 26 24 24 21 21 29 19 21     16 23 20 13 19 13 16 11 15 13 13 11 8 11 14 14 13 4 16 15 18 13 9 19 8 11 6 9    14 8 13 12 13 10 13 10 14 11 13 11 8 10 13 11 11 14 11 8 14 11 10 9 14 12 14     18 8 12 7 13 12 10 14 14 8 12 17 11 13 9 12 12 15 7 9 13 17 11 11 11 12 17 12    11 16 15 8 9 12 7 13 15 11 16 7 10 7 14 5 18 10 10 8 8 6 6 13 14 6 9 11 9 9 3    5 1 1 3 0 0   0.164000 3.700 3.700 9.000      2234753           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 4 1 4 2 1 3 1 1 3 2 3 3 1 3 6 2 4 4 3 3 3 6 5 2    6 4 1 3 3 7 1 4 4 6 12 4 5 2 6 4 9 3 1 8 11 5 2 7 6 3 8 4 7 3 8 3 9 6 7 8 9 2    7 6 9 6 15 6 9 5 9 4 9 17 15 10 2 10 6 8 12 12 11 12 10 9 7 11 8 7 5 11 10 14    16 7 7 7 13 15 10 16 17 21 19 14 18 24 19 27 27 24 20 22 24 21 20 14 24 17 17    18 32 15 12 13 15 12 8 14 11 11 19 11 14 15 18 10 5 12 11 11 9 15 9 7 9 16 12    9 12 10 15 9 18 7 11 12 14 7 20 8 10 13 14 11 6 6 9 11 8 10 16 8 17 13 17 9 16   11 10 9 13 20 17 14 12 10 13 11 9 9 17 20 10 16 8 14 13 14 18 15 15 8 10 12 11   22 12 13 9 12 9 11 14 19 12 12 8 8 12 11 19 11 11 12 15 11 15 13 9 9 10 9 4 9    4 2 1 0 0   0.166000 3.750 3.750 9.100      2327990           3           0  0 0 0 0 0 0 0 0 0 0 0 0 3 2 2 0 1 2 2 1 1 0 0 3 1 4 2 6 4 2 4 3 2 5 5 2 3 1 3    1 2 10 2 7 4 3 4 3 3 4 3 10 6 9 6 3 8 5 5 3 4 4 6 8 4 4 7 5 5 11 14 5 3 6 8 8    7 10 11 7 17 7 11 10 8 7 8 12 13 11 12 6 13 9 7 7 6 5 8 13 10 10 14 11 11 8 12   15 14 9 13 10 9 18 13 18 12 23 14 17 24 15 23 25 31 19 17 29 19 19 19 26 25 19   17 22 19 19 19 11 11 12 22 21 8 10 18 10 14 19 17 13 14 10 6 9 10 15 11 5 13     13 11 11 17 16 9 7 14 7 19 6 10 13 7 12 18 14 7 12 15 13 13 9 13 13 13 12 12     14 12 19 10 16 18 18 12 8 10 10 9 7 14 9 11 13 12 8 15 12 11 10 12 11 17 15 19   14 14 12 7 7 12 11 15 16 12 11 12 10 19 19 12 14 12 15 11 20 13 7 18 9 15 19     16 11 5 9 8 6 2 4 0 2 0 1   0.168000 3.800 3.800 9.200      2406866           3           0  0 0 0 0 0 0 0 0 0 1 0 2 0 1 0 2 3 2 3 1 2 1 2 2 5 2 1 2 3 2 2 2 5 3 5 3 3 1 3    6 8 6 1 3 9 6 3 6 10 5 5 7 4 5 7 12 9 5 7 5 6 6 8 3 5 4 7 8 5 6 5 8 13 4 10 2    10 9 7 7 16 9 10 9 13 8 12 9 13 15 9 15 9 10 11 6 6 6 7 7 6 8 15 9 8 9 6 12 12   11 14 12 11 13 8 17 18 18 11 14 19 14 25 21 15 10 15 19 27 23 22 24 17 19 18     12 16 22 21 25 9 25 15 19 15 21 15 8 11 13 12 10 12 7 13 11 17 11 13 10 16 19    14 23 11 8 12 13 10 9 17 4 14 10 7 10 17 14 11 11 20 18 13 8 12 6 8 13 12 23     15 14 15 16 9 14 9 13 14 17 11 17 11 10 15 17 11 6 12 12 14 15 17 12 16 16 8     17 15 15 10 15 11 10 15 12 13 9 12 9 12 15 12 6 18 7 15 14 12 21 18 11 10 18     11 19 11 7 11 3 2 5 4 0 1 1   0.170000 3.850 3.850 9.300      2508471           7           0  0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 2 1 4 3 3 1 2 7 0 3 2 2 2 2 5 2 3 2 3 3 4 3 7 3    5 3 4 4 6 2 3 10 4 11 3 13 7 7 5 6 3 8 10 6 6 4 10 11 4 12 7 8 9 7 7 8 4 6 7 9   9 5 9 11 5 14 9 10 7 9 8 8 5 6 11 13 14 10 10 10 10 8 9 9 9 9 14 14 13 11 8 18   9 10 9 16 12 13 15 13 10 17 16 20 14 22 20 26 29 29 27 24 20 37 21 24 13 18 13   28 24 22 25 21 13 14 15 9 11 18 8 16 17 16 13 12 16 11 11 17 15 11 15 10 11 12   13 12 12 20 15 14 15 16 12 17 15 15 12 10 14 14 17 15 19 15 13 13 11 12 16 14    17 16 8 16 12 8 14 13 13 10 10 9 12 11 19 20 13 11 4 15 11 14 11 20 18 18 13     20 12 20 21 15 15 12 13 18 18 11 16 9 14 9 18 11 10 11 20 11 13 17 13 13 12 14   16 10 12 12 23 12 11 12 8 8 1 0 1 2 0   0.172000 3.900 3.900 9.400      2591210           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 4 4 3 2 1 3 3 2 3 0 3 6 1 3 1 5 5 4 3 9 9 0 4 7    5 3 5 5 8 7 3 3 5 5 8 5 11 10 8 10 3 6 6 6 7 7 8 8 12 9 6 10 8 7 10 8 8 10 4 6   12 20 4 6 11 7 9 10 7 5 10 6 12 11 7 13 13 16 12 6 8 14 13 9 7 5 14 17 17 10     12 11 6 13 11 17 3 23 13 21 12 21 28 11 23 30 28 23 24 26 26 17 21 15 27 23 33   16 22 25 11 20 22 23 21 20 7 21 13 16 12 16 16 13 18 18 9 13 16 15 9 20 13 19    15 8 9 11 14 13 10 9 10 16 15 14 17 15 19 16 12 14 12 14 14 16 19 19 4 24 8 12   15 16 11 15 14 20 14 13 13 14 16 19 14 13 19 14 18 23 15 15 4 14 17 14 8 10 15   20 11 15 19 12 9 13 12 11 16 12 16 13 14 16 13 16 16 19 19 12 11 10 19 15 15     14 12 5 11 18 17 10 13 12 9 6 2 0 0 1 0   0.174000 3.950 3.950 9.500      2675515           3           0  0 0 0 0 0 0 0 0 0 0 2 0 1 1 0 2 1 2 3 3 1 3 1 3 7 5 3 6 4 3 9 4 5 2 5 3 3 3 6    9 5 5 2 6 8 5 8 4 8 5 6 5 6 4 6 3 7 11 6 9 9 3 6 6 7 6 8 7 9 12 18 6 9 8 11 11   8 14 15 15 11 15 13 9 19 10 15 14 9 4 18 5 8 10 8 10 13 9 12 11 8 8 12 6 15 8    9 9 18 7 17 21 9 13 18 14 21 24 18 22 17 26 15 21 23 25 19 26 23 20 27 17 27     20 26 15 22 15 19 15 16 24 12 15 24 13 13 17 11 7 10 21 15 15 16 13 20 22 12     16 12 16 15 14 18 11 12 14 14 24 10 13 16 19 8 11 18 19 15 15 23 16 16 11 12     18 11 13 14 16 10 14 13 18 12 15 15 14 8 11 17 12 22 13 12 14 15 10 11 15 19     15 12 17 8 21 23 13 19 11 8 12 15 11 14 15 19 15 10 17 9 16 14 18 14 16 14 14    23 14 14 13 16 12 14 15 14 9 14 7 5 2 3 1 1 1   0.176000 4.000 4.000 9.600      2779386           5           0  0 0 0 0 0 0 0 0 0 0 0 2 2 3 0 1 3 0 6 2 6 3 1 5 0 4 1 6 5 1 6 3 6 5 6 2 5 4 5    3 9 8 5 7 5 8 4 12 8 12 6 8 5 7 5 7 10 5 5 6 7 9 7 10 7 10 10 8 12 10 6 13 10    11 12 11 10 10 16 9 6 12 9 11 17 10 11 10 14 11 16 7 11 13 12 10 17 14 11 13     12 10 13 16 16 17 17 15 14 11 8 15 13 27 22 14 19 17 22 22 27 18 28 19 27 32     24 33 21 17 23 12 27 25 20 20 17 22 14 15 22 21 14 9 16 12 19 16 17 16 16 20     14 18 15 14 18 10 12 9 16 12 12 10 13 19 12 12 15 14 15 22 12 11 15 18 19 18     10 6 11 14 10 23 17 14 16 19 10 10 16 19 17 23 16 18 19 18 16 12 14 14 14 13     11 10 24 21 22 26 18 18 18 14 17 5 13 17 11 13 16 14 18 16 9 15 15 18 16 14 21   13 22 17 9 8 16 17 16 16 19 7 20 19 18 16 10 6 10 6 3 5 1 0 0 2   0.178000 4.050 4.050 9.700      2869617           3           0  0 0 0 0 0 0 0 0 0 0 2 2 2 0 1 4 1 3 2 2 1 2 3 2 2 4 4 7 5 6 5 3 6 6 5 7 8 1 5    2 3 5 5 8 10 7 6 10 9 6 8 9 7 8 10 15 4 10 5 8 8 6 11 8 8 11 7 5 8 14 5 11 7     13 10 9 7 8 9 14 12 10 9 11 6 14 15 14 13 11 9 18 18 10 14 14 10 12 16 12 9 8    14 15 6 11 11 12 10 14 12 11 18 13 13 27 16 23 23 20 21 32 20 18 25 22 24 32     25 34 19 23 21 25 22 25 19 23 19 21 16 19 16 18 9 18 6 13 12 13 18 12 8 19 14    14 11 16 13 15 14 21 11 14 14 13 11 20 14 14 26 10 22 16 18 15 20 24 18 19 19    16 14 14 14 21 13 19 18 20 13 17 11 17 14 22 17 15 15 20 8 21 15 16 16 23 17     13 19 21 20 12 15 18 15 19 15 18 17 20 15 13 14 24 18 15 15 14 18 20 19 17 19    20 21 21 15 19 19 17 11 16 16 11 23 10 20 13 10 5 10 2 3 1 1 0   0.180000 4.100 4.100 9.800      2975040           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 2 4 4 2 4 4 1 2 5 0 3 3 5 2 5 5 4 9 2 7 8 4 8 3 11 6   10 4 7 8 6 6 5 8 8 7 11 4 4 11 12 7 11 7 10 11 7 11 11 10 9 7 13 12 18 8 14 12   14 12 8 8 16 10 10 14 16 10 6 8 15 15 15 22 13 19 18 12 6 11 10 7 12 12 24 15    17 9 17 21 10 17 18 14 14 14 9 22 11 23 17 15 23 32 20 11 12 20 15 23 30 20 25   19 26 29 19 27 23 15 19 11 30 16 21 24 18 18 14 8 6 25 13 21 13 13 19 13 21 25   23 18 14 14 13 20 12 14 8 10 25 14 15 20 15 10 15 16 21 8 15 20 21 20 13 16 15   20 11 18 17 17 9 12 24 19 13 18 17 20 14 15 20 10 23 19 25 8 7 13 14 11 15 18    13 10 12 10 17 11 24 16 17 11 12 13 16 20 14 26 12 17 13 14 16 16 6 20 16 23     22 11 17 16 14 25 19 17 21 22 19 13 19 16 18 10 11 7 4 6 0 0 2   0.182000 4.150 4.150 9.900      3083416           6           0  0 0 0 0 0 0 0 0 0 0 2 1 1 4 1 3 4 3 5 6 2 1 4 2 3 5 6 6 7 2 4 1 11 7 5 2 6 6 8   9 8 12 7 11 9 6 12 7 8 9 6 6 8 11 6 6 8 11 8 11 12 11 13 9 10 7 9 6 11 9 13 12   12 8 14 15 8 9 8 8 11 22 16 6 11 16 15 9 13 12 12 13 11 15 9 9 16 14 14 12 21    12 12 12 16 19 10 15 18 8 16 14 16 16 21 30 22 9 25 19 19 26 23 33 25 22 21 19   21 20 20 21 20 26 20 29 27 25 25 21 20 25 21 21 18 14 19 15 6 20 18 16 20 16     13 13 15 15 15 15 22 16 15 15 11 21 19 11 19 13 14 15 17 21 12 18 12 22 18 21    18 13 23 15 18 9 21 11 14 23 18 21 25 18 22 15 21 23 15 15 16 19 21 18 19 21     17 13 24 23 22 19 14 20 22 15 14 14 20 20 23 13 18 15 18 20 20 24 9 12 17 21     21 12 16 17 16 16 21 26 19 15 21 22 24 15 11 13 13 6 8 1 4 0 1 0   0.184000 4.200 4.200 10.00      3174897           3           0  0 0 0 0 0 0 0 0 0 0 1 1 2 3 0 5 4 3 3 0 7 3 2 4 2 8 6 4 5 9 3 8 6 4 2 7 6 8 7    9 3 5 8 5 9 7 7 6 11 14 7 12 9 9 5 15 12 14 15 12 9 11 5 8 13 11 12 10 9 17 12   11 8 17 11 19 11 15 9 11 7 15 14 16 16 16 7 12 10 14 13 13 16 16 11 15 13 14     12 16 11 12 13 17 10 13 19 11 17 11 13 14 13 10 19 19 23 24 22 24 24 31 19 23    22 28 21 25 29 17 23 17 21 30 22 19 25 27 27 22 23 23 17 25 17 20 17 12 23 21    9 17 20 16 19 16 17 20 9 16 11 22 16 15 12 15 17 23 24 16 16 18 26 11 16 20 18   10 14 17 26 19 17 15 17 19 12 21 20 24 17 27 13 16 18 19 23 14 19 14 10 11 18    19 6 15 21 23 25 17 17 18 21 27 20 17 18 20 25 22 20 18 22 18 17 15 24 16 15     22 18 22 14 20 20 22 18 22 25 19 26 12 19 19 13 12 16 19 14 9 7 5 4 2 0 2   0.186000 4.250 4.250 10.10      3283256           3           0  0 0 0 0 0 0 0 1 0 0 1 1 4 1 5 2 5 5 3 4 6 3 2 4 7 8 2 6 6 4 10 7 8 7 5 4 4 9 8   18 10 7 6 6 13 12 10 13 10 7 15 4 7 10 13 12 8 8 13 5 14 6 9 14 9 10 16 12 13    11 8 12 11 10 13 9 11 15 17 23 18 13 10 12 11 12 14 14 14 10 12 12 16 13 15 13   13 14 18 10 13 17 14 14 14 12 12 8 18 14 23 20 16 19 16 16 16 27 18 21 19 20     19 37 22 21 22 28 24 26 18 21 28 21 22 21 21 22 16 15 13 22 22 27 22 11 13 20    10 17 16 19 20 30 18 25 8 7 22 18 17 14 23 16 17 11 16 24 19 18 22 15 15 23 16   13 15 22 14 8 12 18 13 15 22 17 15 15 17 27 21 19 21 24 17 10 12 14 19 17 22     18 19 17 28 19 15 14 16 28 17 20 15 11 22 18 19 16 21 17 24 19 22 22 20 10 20    18 18 18 21 18 23 18 32 26 21 21 22 20 22 16 17 20 22 21 17 13 13 11 9 5 0 1 1   1   0.188000 4.300 4.300 10.20      3396610           5           0  0 0 0 0 0 0 0 0 0 0 1 2 3 0 2 5 5 4 3 3 5 1 2 3 6 9 3 3 3 8 7 2 9 5 7 5 11 8 9   7 6 9 6 4 5 8 6 10 9 14 10 15 6 7 13 15 10 13 7 15 10 10 11 14 14 6 7 17 13 19   3 13 9 6 13 13 14 10 11 12 16 17 13 10 15 15 19 19 11 11 15 11 13 9 13 20 8 18   14 18 23 23 23 15 19 20 14 11 7 18 16 15 22 28 20 24 22 25 17 20 39 24 26 25     25 33 25 25 25 33 15 29 18 29 18 12 18 23 17 24 28 22 16 20 33 23 18 23 26 23    15 24 16 16 16 16 17 15 15 16 14 11 9 23 17 13 13 18 12 19 20 30 20 20 15 21     19 16 18 20 23 19 15 10 11 15 19 13 22 22 18 19 16 19 23 16 10 25 23 20 21 20    31 19 19 18 15 22 18 14 13 21 18 19 22 19 16 17 21 14 20 26 18 26 22 19 26 19    20 22 15 13 24 23 15 21 21 21 27 18 22 19 24 17 22 16 18 23 10 12 3 5 3 3 0 0   0.190000 4.350 4.350 10.30      3502025           3           0  0 0 0 0 0 0 0 0 0 0 0 3 0 3 2 3 4 4 3 4 5 10 7 6 6 4 5 12 10 6 6 13 10 6 7 14    9 6 13 10 12 16 3 9 9 7 5 6 13 11 10 8 11 19 12 14 13 16 13 14 9 12 14 13 14     16 10 14 7 16 18 16 9 15 11 20 15 10 14 14 11 14 17 10 6 16 10 15 12 17 17 20    15 7 12 23 15 8 13 12 8 16 15 20 16 16 20 14 11 20 24 23 20 16 18 27 25 31 27    27 25 21 31 27 20 23 24 32 17 21 34 27 17 19 19 25 30 27 21 24 28 30 19 26 21    14 16 21 23 27 8 17 21 17 11 23 15 22 15 18 10 17 20 23 18 18 17 19 22 15 22     21 19 23 18 18 26 17 18 26 18 24 15 22 23 23 19 23 25 23 24 26 10 21 16 32 23    18 19 24 21 28 26 22 19 19 14 30 21 24 23 22 21 13 27 20 27 24 15 20 22 22 13    25 14 19 32 21 18 18 23 22 22 14 18 20 24 14 19 20 18 17 24 29 27 20 12 18 17    11 9 2 3 2 1 0   0.192000 4.400 4.400 10.40      3593938           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 1 2 3 4 7 8 1 5 6 8 3 7 5 4 9 8 8 7 7 9 7 9 9 15 5 7   8 15 14 9 9 13 8 8 15 10 7 10 9 10 14 7 8 18 16 17 11 14 15 13 8 15 8 15 18 16   16 22 12 8 16 13 10 13 13 10 21 11 10 16 16 13 13 17 16 20 23 13 22 16 14 15     22 19 22 15 22 24 16 16 16 19 12 15 16 17 20 18 19 26 17 23 18 32 20 28 36 22    25 30 29 31 36 24 24 21 29 24 32 29 30 23 34 19 33 34 25 20 31 27 24 16 14 21    20 13 24 17 28 13 24 16 26 15 26 21 11 15 20 13 20 18 25 23 18 24 26 22 16 22    14 13 16 20 24 25 19 29 20 15 20 16 25 26 21 22 17 24 22 21 17 23 23 15 19 30    23 17 21 19 18 21 26 14 29 24 20 33 19 15 20 23 28 19 23 25 15 19 17 31 23 18    29 26 25 14 24 25 18 19 19 24 35 31 23 23 14 15 19 11 20 19 24 17 16 9 10 12 3   2 2 0 1   0.194000 4.450 4.450 10.50      3712573           7           0  0 0 0 0 0 0 0 0 0 0 0 1 1 1 5 3 5 4 3 11 3 10 4 6 7 8 5 5 5 8 9 12 7 7 11 8 6    7 9 10 13 10 6 13 9 9 9 11 14 14 12 13 10 6 13 13 15 12 13 19 8 14 13 16 11 13   14 15 9 15 16 13 16 17 17 17 23 18 16 19 10 13 18 16 10 9 21 11 22 14 20 14 18   13 15 12 13 14 16 14 15 20 29 17 14 18 8 15 21 15 19 15 22 20 17 15 23 26 16     26 24 23 23 23 23 30 24 29 28 26 35 33 31 22 23 22 20 37 22 27 33 26 27 26 17    16 18 27 22 21 24 18 18 18 17 15 18 14 19 24 22 15 20 21 15 19 25 15 16 26 19    22 29 20 16 13 15 16 32 24 23 13 33 17 22 18 18 23 24 22 21 20 26 21 16 22 18    18 16 15 26 26 17 22 21 13 25 24 13 23 18 18 25 32 20 24 21 17 19 24 24 23 33    19 19 21 32 18 22 23 19 23 32 18 31 22 25 23 23 31 29 21 16 20 20 15 22 14 12    5 10 9 2 1 0 1   0.196000 4.500 4.500 10.60      3829518           3           0  0 0 0 0 0 0 0 0 0 1 2 2 1 6 2 6 5 9 3 5 6 8 6 3 8 10 7 11 9 4 8 9 5 11 10 13 9   16 13 10 9 5 12 9 15 10 13 9 12 18 14 19 9 13 14 12 13 21 17 17 18 16 13 12 16   14 18 10 15 15 16 11 15 22 17 19 17 11 12 26 12 17 19 18 21 20 27 17 18 19 21    14 19 16 12 16 21 20 18 8 17 17 13 13 18 15 19 15 19 20 28 21 29 27 27 34 24     26 31 25 24 16 17 23 23 30 28 18 28 32 28 37 18 26 18 16 33 21 31 21 20 22 19    20 25 18 18 20 11 17 20 22 23 14 14 17 18 20 25 20 19 20 22 19 16 33 25 21 21    24 18 16 22 29 22 16 27 26 28 21 20 22 17 25 23 20 23 18 16 19 26 22 21 22 23    15 20 19 17 23 19 20 15 22 18 22 26 23 23 31 17 29 18 13 15 19 18 24 22 28 22    17 23 24 26 21 23 25 24 29 26 18 41 24 29 22 27 23 28 16 30 24 18 23 19 17 18    21 17 14 8 2 5 2 0 0   0.198000 4.550 4.550 10.70      3950740           3           0  0 0 0 0 0 0 0 0 1 1 1 2 1 3 7 5 6 7 7 7 4 5 6 4 1 8 9 10 9 8 10 8 12 6 10 8 10   8 11 9 10 15 7 11 8 13 11 13 15 15 17 12 10 8 17 12 9 14 12 14 11 14 21 14 15    20 18 16 8 15 22 24 14 10 18 14 15 16 12 10 16 21 16 25 17 20 17 17 20 15 24     15 17 22 25 17 13 22 18 20 19 11 21 22 21 16 21 24 16 22 17 21 17 24 22 24 35    27 24 28 24 32 37 34 25 24 29 37 37 25 28 21 23 24 22 21 20 25 22 32 19 21 22    24 20 21 20 22 18 27 17 14 20 22 22 22 14 19 20 20 21 23 22 14 20 21 23 20 18    23 20 25 31 24 18 22 14 23 22 21 23 27 27 20 21 18 22 23 24 23 21 18 22 17 22    21 35 15 24 24 12 27 30 27 28 22 31 24 24 19 27 24 28 23 25 26 35 27 22 29 21    24 18 19 26 33 29 31 23 25 19 24 26 21 10 23 24 26 28 20 27 26 17 29 22 18 14    22 8 10 11 4 4 1 2 0   0.200000 4.600 4.600 10.80      4068161           5           0  0 0 0 0 0 0 0 0 0 1 1 0 1 5 5 2 9 3 11 6 9 8 7 7 8 3 3 13 10 8 7 5 8 13 8 7 14   12 10 7 15 13 13 11 12 12 14 12 13 12 10 15 11 14 7 16 15 8 15 13 15 13 18 13    17 21 15 12 13 13 17 18 18 18 16 19 20 17 14 17 24 13 12 18 19 19 13 21 18 26    21 23 16 14 18 19 13 33 13 19 20 14 20 23 14 26 19 22 21 21 16 27 30 25 28 22    32 21 30 27 31 21 30 22 27 27 31 27 21 17 38 41 17 21 20 19 30 24 27 20 20 21    30 20 19 19 31 25 24 13 21 23 19 24 33 24 17 20 17 12 25 23 18 24 11 24 25 22    33 20 11 22 31 21 20 26 27 21 26 24 14 23 23 20 20 26 28 10 20 27 24 22 17 27    28 20 23 23 33 20 24 26 32 33 29 21 25 24 17 18 19 27 26 20 24 26 24 24 26 21    19 24 21 36 32 18 33 33 20 23 25 33 19 27 25 27 24 27 21 21 23 28 18 27 25 19    24 15 17 12 15 7 2 1 0 0 ", "%f ", Inf);
-%! assert(rows (x) == n);
+%! [x, n] = sscanf ("   0.024000 0.200 0.200 2.000         1987           5           0  0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 5 1 2    2 5 5 8 2 8 12 6 15 18 28 26 47 88 118 162 192 130 88 56 27 23 14 9 6 3 4 1 0    2 3 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.026000 0.250 0.250 2.100         3115           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0    0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1    1 1 0 1 0 1 3 2 0 5 15 25 44 66 145 179 193 172 104 57 17 11 12 2 1 0 1 1 0 1    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.028000 0.300 0.300 2.200         4929           3           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0    1 0 1 0 1 2 2 3 2 3 14 21 49 80 148 184 218 159 124 63 37 13 12 3 1 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.030000 0.350 0.350 2.300         7051           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1    0 0 1 0 0 0 2 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1    0 0 0 2 0 0 0 1 5 6 14 28 51 88 154 177 208 169 124 65 39 15 5 3 3 2 1 0 1 0 1   0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.032000 0.400 0.400 2.400         9113           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0    1 0 0 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 0    1 0 0 1 1 0 2 3 5 3 17 30 60 117 156 189 209 129 102 64 56 16 11 4 2 2 0 0 0 0   1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0   0.034000 0.450 0.450 2.500        11811           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0    0 0 2 1 0 0 1 0 5 5 15 21 57 99 149 190 195 159 130 69 41 16 10 2 5 3 0 1 0 0    0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.036000 0.500 0.500 2.600        14985           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0    0 0 0 0 1 0 0 2 2 6 10 34 60 95 126 177 194 155 99 71 44 17 6 7 2 0 0 0 3 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.038000 0.550 0.550 2.700        18391           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 2    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 1 1 0 1    2 1 0 0 0 1 0 1 3 6 19 27 52 95 161 154 169 134 94 64 37 19 9 6 0 2 1 0 0 0 0    1 2 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.040000 0.600 0.600 2.800        22933           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1    0 0 0 0 0 2 0 3 4 7 18 27 47 82 134 163 133 138 101 58 34 26 10 5 2 1 2 1 1 0    2 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.042000 0.650 0.650 2.900        27719           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 1 1 2 8 16 37 51 87 128 153 146 123 105 62 35 24 8 3 5 0 1 2 1 0 0   0 1 1 1 0 0 0 1 0 1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.044000 0.700 0.700 3.000        32922           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 2 0    0 0 0 0 0 0 0 2 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1    1 1 0 0 0 1 4 3 5 5 15 35 54 88 132 168 149 105 92 62 30 16 17 4 5 1 0 0 1 0 1   1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.046000 0.750 0.750 3.100        38973           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0    0 0 0 1 0 0 0 4 3 5 20 37 56 94 110 135 149 124 84 58 36 17 14 7 1 0 2 0 1 0 0   1 1 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1    1 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.048000 0.800 0.800 3.200        45376           5           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 2 1 1 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0    0 0 0 1 0 0 0 0 1 3 18 34 55 82 104 135 116 99 79 60 51 29 10 4 3 1 1 1 0 0 1    0 0 0 1 0 0 3 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.050000 0.850 0.850 3.300        52060           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1    0 0 0 0 0 2 2 1 3 12 24 40 39 107 121 127 138 100 86 68 44 23 15 7 3 1 1 0 1 1   0 0 2 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 2 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.052000 0.900 0.900 3.400        59454           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1    0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 2 0 2 1 0 0 0 1 0    0 1 0 0 0 0 0 3 3 6 21 32 68 90 132 111 122 107 73 57 47 24 11 7 4 2 2 1 0 0 0   0 0 0 0 0 1 0 0 1 0 0 2 0 1 1 0 0 1 0 0 0 0 0 3 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0   0.054000 0.950 0.950 3.500        67013           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0    1 0 1 0 1 2 4 3 7 9 28 31 71 94 115 96 108 78 82 60 38 17 12 11 4 3 1 1 0 2 1    0 0 0 2 1 3 0 0 0 0 3 0 0 1 0 0 0 0 0 0 0 2 0 0 0 1 0 2 0 1 0 2 0 1 0 0 1 0 0    0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.056000 1.000 1.000 3.600        75475           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 3 0 0 1    1 2 0 1 4 0 1 8 6 7 17 41 56 71 109 113 84 103 72 54 35 22 6 9 1 7 5 4 0 0 1 0   0 0 0 0 0 1 0 0 2 1 0 0 0 0 2 0 0 1 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 0 0 1 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 0 0 1 1 0 0 2 0 0 0 0    0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.058000 1.050 1.050 3.700        83558           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0    2 0 0 1 0 3 2 3 6 15 27 41 77 73 94 94 92 76 61 56 42 23 13 11 6 2 1 2 0 1 2 0   0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 0 2 0 0 0 0 0 1 2 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.060000 1.100 1.100 3.800        93087           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1    0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 2 2 0 0 0 1 0 1 1 0 0 0 1 1 0 4    0 0 1 2 0 3 1 3 5 13 33 31 65 75 77 96 97 80 59 45 36 32 18 2 5 0 1 0 0 1 0 0    3 0 0 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 0 2 0 0 2 0 1 0    0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.062000 1.150 1.150 3.900       102829           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 2 0 2    1 2 0 0 2 4 3 5 11 9 23 43 53 68 65 87 83 77 59 49 34 18 15 9 4 2 3 2 0 0 0 4    0 1 1 0 0 2 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 2 0 0 0 0 1 0 0 1 1 1 1 0 0 0 1 0    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.064000 1.200 1.200 4.000       113442           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0    0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1    2 0 0 0 2 0 4 5 11 13 29 39 61 68 61 75 76 74 73 44 37 29 19 6 3 3 2 0 1 2 1 0   0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 1 0 1 2 0 2 1 1 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0 0    0 0 0 0 1 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0    0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0   0.066000 1.250 1.250 4.100       126668           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1    0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 3 0 2 1 2 0 1 0 3 0 0 0 1 0 1 1 3    0 0 1 3 0 2 4 3 12 12 30 48 56 66 77 78 71 82 52 31 32 19 20 16 8 2 1 3 0 0 2    1 0 1 0 1 0 0 0 1 3 1 0 1 0 1 1 1 0 0 0 0 0 2 0 2 0 0 0 0 0 1 0 0 0 0 1 1 0 0    0 0 0 1 0 0 0 0 0 2 0 3 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.068000 1.300 1.300 4.200       138042           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 2 0 0 1 0 1 0 0 0 0 0    0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 3 0 0 1 0 0 1 2 0 0 0 3 0 1 0 0 3 0    1 0 1 1 3 1 4 7 11 14 27 36 44 68 72 70 71 45 44 46 29 13 16 11 5 2 0 3 0 0 0    0 1 1 2 0 0 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 2 0 0 1 1 0 1 1 1 0    0 1 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 0 1 0 0 1 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.070000 1.350 1.350 4.300       152335           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0    1 0 0 0 2 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 1 1 1 0 1 1 0 1 1 1 1 0 2 0    0 0 0 0 2 0 1 7 14 19 34 35 54 72 68 72 68 58 48 36 37 27 25 17 1 4 1 0 0 0 1    2 2 0 0 1 1 1 2 1 0 3 1 0 1 0 2 1 0 0 0 1 1 1 2 0 0 0 0 1 1 0 1 1 0 2 1 1 1 1    0 0 0 1 1 0 0 2 0 0 1 0 0 0 1 1 0 2 1 1 0 0 0 0 2 0 0 0 0 0 0 0 1 1 0 0 0 0 1    0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0   0.072000 1.400 1.400 4.400       166280           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0    2 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 3 4 2 2 0 0 0 0 0 1 1 3 1 0 3 2 2    1 2 2 0 2 2 1 8 14 26 24 29 47 47 68 65 63 55 42 41 26 29 17 8 4 4 1 0 1 2 0 0   0 1 1 2 0 1 2 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 2 1 2 1 0 0 0 0 0 1 1 2 0 2 2 0    0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.074000 1.450 1.450 4.500       179484           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0    1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 1 0 0 1 0 1 2 0 0 0 0 0 0 0 0 0 1 0    0 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 2 0 0 1 1 2 1 0    1 1 2 2 0 1 5 6 10 20 43 50 57 62 53 62 66 45 42 33 27 26 23 14 3 0 2 0 1 0 0    1 1 0 0 2 1 1 0 0 3 0 1 1 1 0 1 1 0 1 0 1 2 1 0 0 1 2 0 2 0 0 0 0 1 1 3 1 0 0    2 1 1 1 0 0 0 0 0 0 1 2 0 1 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 2 1 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0   0.076000 1.500 1.500 4.600       197657           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0    0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0 0 2 1 1 0 1 1 0 1 1 3 2 1 1 2 1 0 1 0 0 0 0    0 1 1 1 0 5 3 7 12 24 38 32 41 48 54 66 71 49 46 31 38 25 15 8 6 6 5 0 1 3 0 1   1 1 1 1 0 1 2 0 1 0 0 0 1 0 2 1 2 0 0 0 0 1 3 1 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0    4 1 1 1 0 3 0 0 0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0   0.078000 1.550 1.550 4.700       212054           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0    0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1    0 0 2 0 0 0 1 0 0 1 0 1 1 0 1 3 1 0 0 1 2 0 0 0 1 0 0 0 0 0 2 1 2 1 1 1 0 0 1    5 1 1 2 3 5 7 9 11 22 31 37 48 50 52 54 57 37 38 38 33 24 11 19 11 3 1 2 0 3 3   2 1 0 1 3 0 1 1 1 1 1 2 0 0 0 1 1 2 0 1 1 3 0 1 1 0 0 1 0 2 0 1 0 0 1 3 0 2 0    1 0 1 2 0 1 1 1 1 1 0 3 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0   0.080000 1.600 1.600 4.800       231971           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1    0 0 0 0 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 1 0 1 1 1 0 1 0 0 1 0 1 3 0 0 0 1 0    0 0 1 1 1 0 0 4 1 1 0 2 0 1 1 1 2 0 0 0 1 0 1 2 1 2 3 2 0 1 0 4 3 1 1 1 1 3 1    0 0 0 2 1 0 2 7 17 13 29 47 58 59 52 38 51 51 38 34 35 21 14 13 4 1 0 1 1 1 0    2 2 4 1 0 1 1 4 0 0 0 2 0 2 2 2 0 0 1 3 2 1 1 2 2 2 2 1 0 3 0 2 1 2 1 2 2 0 0    1 1 0 2 0 2 2 0 1 0 2 2 3 1 2 3 1 1 0 1 0 2 0 1 2 1 2 0 2 1 0 0 3 0 0 1 1 1 1    0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0   0.082000 1.650 1.650 4.900       252503           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 2 0 0    0 0 0 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0    0 0 0 0 2 0 0 1 0 1 2 2 2 1 0 2 0 1 0 1 1 2 2 0 3 0 0 4 1 0 0 3 0 0 1 2 0 1 1    1 3 0 1 0 2 9 11 25 27 34 53 41 49 43 47 36 31 38 22 30 22 18 9 5 9 2 2 1 2 2    3 1 4 1 1 0 0 1 2 0 2 1 0 0 1 3 2 2 1 0 0 0 1 2 1 0 0 0 2 1 1 0 2 0 0 1 0 0 2    1 3 1 1 1 0 2 1 1 0 2 1 0 1 3 0 0 0 0 2 0 0 1 0 0 0 0 0 1 2 1 1 1 0 2 1 0 0 0    2 0 1 0 0 0 0 1 0 0 0 0 1 0 0 2 0 1 0 1 0 0 0 0 0 0 0 0 0 0   0.084000 1.700 1.700 5.000       267889           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1    0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0    0 1 0 1 1 0 3 0 1 1 1 0 1 2 1 0 2 0 2 4 0 1 0 0 0 1 1 0 1 3 2 0 2 0 4 0 0 2 0    1 4 2 4 3 3 6 10 14 28 37 54 36 40 52 40 50 46 40 32 26 29 12 18 5 2 0 2 4 1 2   1 0 2 1 2 2 1 0 1 0 2 1 2 4 1 1 5 1 0 2 0 1 2 3 2 2 1 2 1 0 2 1 2 1 1 4 1 2 1    4 0 2 2 0 0 3 1 0 2 0 0 1 1 1 0 0 2 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.086000 1.750 1.750 5.100       290294           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 2    1 0 1 0 1 0 0 2 2 0 1 2 2 0 2 0 2 0 1 0 0 1 1 1 3 1 1 1 1 3 4 1 1 2 2 2 1 0 3    0 0 0 2 4 5 6 16 18 20 31 40 54 55 46 41 52 35 27 21 28 27 20 15 8 6 7 1 0 0 3   0 0 2 2 0 3 1 3 1 1 2 0 0 1 2 1 3 2 0 1 2 1 3 1 1 1 1 1 2 0 2 1 0 1 1 1 3 1 1    2 0 1 0 1 0 2 1 1 0 0 1 2 0 3 1 1 0 0 0 1 3 1 1 1 0 0 1 2 1 0 0 1 1 1 0 0 1 0    0 0 0 0 0 2 0 1 0 0 0 2 1 0 2 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0   0.088000 1.800 1.800 5.200       312476           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 0    0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 0 0 0 1 0 1 0 0 0 0 0 0 2    1 0 0 1 0 0 1 1 1 1 4 2 0 1 0 0 3 0 0 0 0 0 1 1 4 0 0 0 0 1 1 2 1 0 3 0 0 2 2    4 0 3 1 6 9 10 13 21 24 32 43 33 41 43 49 50 32 26 31 27 12 16 17 3 3 3 5 0 3    0 2 1 3 3 2 1 2 3 1 2 1 1 1 2 0 1 1 0 2 0 3 0 0 2 0 0 0 0 1 0 1 1 3 3 0 1 1 1    1 1 1 2 2 2 0 3 1 0 2 2 2 0 0 0 0 3 1 2 5 1 1 2 0 0 3 3 0 2 2 0 0 0 0 1 2 0 0    1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.090000 1.850 1.850 5.300       337348           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 2 0 1 0 1 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 2 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0    2 0 0 0 1 3 2 0 0 2 2 3 3 2 2 2 0 0 1 1 3 1 3 0 0 0 0 0 0 1 2 1 2 1 2 2 2 0 1    1 0 4 2 2 7 6 15 22 21 39 37 50 31 51 30 33 34 34 26 21 14 13 10 9 4 3 3 4 2 2   0 1 2 3 3 0 1 3 2 5 3 2 2 4 0 2 3 0 4 2 1 2 2 2 4 2 1 3 1 3 2 1 3 1 2 4 1 1 1    1 2 4 1 3 3 3 1 0 4 1 0 1 1 1 1 2 3 0 3 0 0 4 1 1 1 0 2 2 2 1 2 2 0 1 1 0 0 0    2 0 1 0 1 0 0 1 0 0 0 1 3 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0   0.092000 1.900 1.900 5.400       357303           3           0  0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 0 0 1 0    0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 3 1 0 1 0 0 0 0 1 0 0 1 0 0 1 1 2 2 0 0 2    2 1 1 1 1 1 1 0 1 0 0 1 1 1 3 1 1 1 1 1 0 1 4 0 1 1 1 3 0 1 1 2 2 2 0 2 3 2 2    2 2 1 2 1 3 8 22 14 32 36 46 39 42 39 29 36 38 26 24 26 18 16 19 10 9 3 6 5 0    3 2 1 1 1 2 0 2 1 1 0 1 1 3 1 0 2 4 2 2 1 4 1 2 2 1 1 0 1 2 0 2 2 2 4 2 1 1 0    2 1 3 1 2 3 4 2 3 2 3 0 1 2 1 0 0 0 4 1 1 1 2 1 3 1 0 5 1 0 0 0 0 0 0 1 0 2 0    1 2 1 0 1 0 0 0 0 0 1 1 0 1 0 1 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0   0.094000 1.950 1.950 5.500       383138           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0    0 0 1 0 0 2 1 0 1 1 1 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 2 1 1 1 1    2 1 0 2 0 1 0 3 2 1 3 0 1 3 1 1 0 5 0 1 0 1 2 0 0 1 1 2 0 0 6 1 0 3 2 2 3 4 5    0 4 2 1 5 4 11 15 22 27 28 57 38 38 40 38 39 38 27 26 30 18 14 10 10 4 4 4 3 3   2 2 2 2 1 1 1 1 2 2 3 4 1 2 3 1 2 1 2 2 2 1 3 2 1 5 0 1 1 1 3 2 2 2 1 3 1 1 0    3 2 2 0 0 2 2 2 0 0 0 2 0 1 3 1 2 3 2 1 1 0 1 1 1 0 3 2 2 1 0 0 1 3 1 1 0 1 0    0 0 0 0 1 0 0 0 0 1 0 0 3 1 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0   0.096000 2.000 2.000 5.600       409868           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 0 2 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 2 0 2 0 0 0 0 1 0 0 2 1    2 2 2 1 2 1 1 1 1 1 2 0 0 1 1 0 1 0 2 1 2 0 2 0 3 1 2 1 3 1 5 0 2 2 1 2 4 1 2    0 3 1 4 7 5 9 13 22 19 31 27 28 41 34 39 37 22 23 21 22 17 23 15 8 9 3 8 0 3 1   2 2 2 3 1 0 4 2 4 2 2 2 2 4 2 1 1 0 2 0 3 0 3 2 2 1 2 2 1 4 1 2 2 1 1 5 2 1 2    1 2 2 1 0 2 4 3 2 1 2 2 3 2 3 1 2 1 1 1 1 2 1 1 2 2 1 2 3 2 1 1 0 2 2 4 0 1 1    1 1 1 0 0 1 1 3 0 0 0 0 0 1 0 0 2 0 1 2 0 1 1 1 0 1 0 1 0 0   0.098000 2.050 2.050 5.700       439102           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 0    0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 2 0 1 1 0 0 0 0 1 1 1 0 4 0 0    0 2 1 1 0 3 4 0 1 2 2 1 0 3 0 3 2 0 0 2 0 1 0 0 1 0 1 3 1 3 5 0 2 2 3 5 2 2 2    0 3 2 3 6 5 16 21 19 23 28 29 35 42 42 44 39 33 23 30 18 25 24 15 13 5 4 2 2 0   3 3 0 0 1 3 0 1 1 3 2 4 3 4 2 1 1 1 3 1 0 0 2 2 4 2 2 1 4 2 4 2 2 2 1 2 2 1 2    0 4 2 2 3 1 2 1 1 2 2 1 2 4 2 1 4 1 2 2 2 2 0 2 0 3 0 1 0 2 1 0 4 2 1 3 2 1 0    2 1 1 1 1 0 1 1 2 1 1 1 2 0 1 0 2 1 1 0 0 1 0 0 1 0 0 0 0 0 0   0.100000 2.100 2.100 5.800       467340           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 0 1 2 0 0 0 0 0 1 0 2 0 0 2 0 0 1 1 0 0    0 1 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 2 0 2    2 4 1 0 1 1 2 3 4 1 4 1 5 1 2 1 0 2 2 2 1 5 4 1 5 4 0 1 2 4 2 2 0 2 1 2 5 4 1    1 1 2 5 7 9 16 23 31 15 22 36 36 44 42 29 31 28 28 18 35 12 10 13 8 4 3 2 2 5    1 2 3 3 1 3 3 5 2 0 3 4 1 2 2 3 0 0 5 2 3 6 2 1 2 5 3 4 3 1 1 1 1 2 2 4 0 2 3    1 2 1 2 4 5 4 3 5 2 1 2 0 5 0 2 2 4 1 0 4 1 0 2 1 2 0 0 1 3 2 4 3 0 2 3 3 3 4    2 2 0 0 0 0 1 1 0 3 2 0 1 2 0 4 2 1 1 1 2 0 0 0 0 0 0 0 0 0 0   0.102000 2.150 2.150 5.900       497495           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 2 1 0 0 0 0 1 0 1 0 0 0 0 1 2    0 0 0 0 0 2 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 2 0 0 1 0 0 0 1 0 2 2 1 0 0 0    2 0 2 1 1 1 6 3 2 0 3 2 2 2 1 1 3 4 1 0 1 2 4 2 3 3 1 1 1 1 3 3 1 4 1 3 4 3 2    3 1 2 2 5 11 11 14 26 27 28 28 28 36 39 42 29 33 24 20 29 18 13 17 13 6 10 4 3   3 6 1 0 1 0 2 1 3 2 3 1 2 3 1 2 1 2 0 2 2 3 1 3 1 1 2 4 4 1 4 3 2 2 3 5 5 3 0    2 5 3 5 1 4 1 1 3 4 2 2 2 2 1 3 0 1 1 2 2 4 2 1 3 2 0 1 2 1 0 2 3 1 2 0 0 0 2    0 0 1 3 0 0 1 2 0 3 1 0 3 1 2 2 1 1 2 0 0 0 0 2 0 0 1 0 0 0 0 0   0.104000 2.200 2.200 6.000       529288           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 3 0 2 0 2 0 0    3 2 2 0 4 0 3 2 2 1 3 1 7 3 1 1 0 4 3 2 1 0 0 3 2 3 5 2 1 4 1 5 1 0 3 2 3 0 1    2 4 7 3 7 8 12 15 20 24 34 39 34 35 27 36 34 23 22 26 15 24 12 12 14 5 3 0 7 1   1 3 5 1 2 2 2 4 3 1 2 5 2 2 3 1 1 4 2 1 3 0 4 5 4 6 4 5 3 3 3 3 1 1 5 0 6 1 2    4 2 3 2 1 3 2 0 0 0 1 3 3 0 1 4 0 3 2 3 0 3 3 0 2 3 4 3 1 1 1 2 5 3 1 2 1 1 2    4 1 0 2 4 1 3 0 0 3 0 1 3 0 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0   0.106000 2.250 2.250 6.100       560628           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 2 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1    1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 2 0 0 0 0 2 0 3 1 1 0 0 2 2 2 0 5 2 1    1 1 1 3 1 2 3 0 1 0 0 0 0 1 0 2 2 1 2 1 0 4 3 2 1 2 1 0 4 2 2 0 2 1 1 2 3 1 2    1 2 4 4 11 12 17 19 19 29 30 24 30 35 51 32 36 34 31 19 22 17 11 19 11 7 6 6 3   4 0 3 3 2 0 2 2 2 3 1 5 3 2 3 5 1 0 2 2 5 4 2 3 2 0 1 6 1 2 2 2 2 1 1 2 2 1 4    3 2 2 1 2 5 2 0 2 0 2 5 4 5 2 1 3 6 1 3 4 4 0 0 6 0 2 6 1 2 2 2 0 1 3 1 3 4 2    1 4 2 1 2 3 3 0 3 1 0 2 0 2 1 0 2 1 2 0 0 1 1 0 2 0 0 0 0 0 0 0   0.108000 2.300 2.300 6.200       593293           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 2 0 2 2 1 0 0 2 0 1 0 1 0 0 1 2 2 1 0    0 1 0 2 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 0 1 1 1 2 2 1 0 1 1 0 1 5 0 2 4 1 0 1 4    2 1 3 2 2 3 2 3 2 0 0 3 4 3 1 3 2 2 0 3 0 2 4 0 3 2 5 1 2 1 4 6 1 2 4 0 3 6 1    7 6 4 5 4 10 16 24 22 20 40 37 44 34 29 21 28 36 36 27 23 24 14 10 4 5 2 5 3 6   2 3 3 1 4 2 1 5 1 3 5 3 2 1 2 2 6 2 3 1 1 0 5 3 3 3 4 5 2 2 3 3 5 5 1 6 2 3 2    6 0 5 2 4 3 5 1 2 2 5 1 2 3 1 2 2 2 4 2 5 5 2 2 2 5 0 1 2 5 2 3 2 3 1 1 2 4 0    2 1 4 2 1 1 1 0 1 2 0 0 1 3 1 0 2 1 1 3 3 2 0 0 0 1 2 0 0 0 0   0.110000 2.350 2.350 6.300       636559           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 0 0 0 1 1 2 0 0 1 0 0 0 0 0 0 0    1 2 0 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 2 0 1 0 1 0 1 0 0 1 1 3 0 1 2 2 0 2 1    1 1 1 0 1 0 1 3 0 3 2 3 4 3 3 4 3 3 2 6 3 1 1 1 2 4 2 3 1 5 1 3 1 4 5 3 3 2 1    3 7 4 3 10 19 17 19 23 27 28 33 39 36 23 23 32 32 16 19 35 23 12 11 12 8 4 5 7   1 2 2 1 2 3 5 4 2 3 2 6 4 4 2 4 1 2 2 1 2 3 0 4 2 1 2 6 2 2 1 3 3 1 6 4 8 5 2    3 5 2 3 0 3 2 3 1 2 2 3 4 3 8 6 2 1 4 6 3 1 2 0 2 0 2 5 0 3 3 3 3 1 3 3 2 5 4    2 1 4 2 2 4 4 1 3 2 5 2 3 1 2 0 4 0 1 0 6 3 1 2 0 2 0 1 0 0 0 0   0.112000 2.400 2.400 6.400       670484           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 2    0 1 1 1 3 0 0 0 2 1 3 0 1 1 1 0 1 1 1 0 0 1 2 0 1 3 1 5 2 3 0 4 0 2 0 0 1 2 1    0 1 0 0 1 0 2 2 3 2 3 2 2 2 3 4 4 2 3 5 3 3 2 3 3 4 2 4 0 3 2 4 4 1 3 1 3 4 2    2 5 2 8 6 12 17 14 22 27 26 29 39 30 24 36 22 22 20 9 19 15 5 12 16 4 7 5 7 5    5 1 4 5 5 4 4 1 4 4 3 3 3 4 2 2 4 2 4 4 4 4 0 2 3 2 1 4 3 6 1 3 3 3 4 5 4 2 2    2 5 3 0 2 5 4 2 5 3 5 1 1 3 1 1 3 6 6 2 3 2 0 3 2 4 3 4 1 2 2 6 2 0 3 2 2 5 3    3 5 2 1 0 3 1 1 2 2 0 1 1 3 2 3 2 1 1 1 1 3 2 1 0 0 0 0 0 0 0   0.114000 2.450 2.450 6.500       711783           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 1 0 2 1 2 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1    1 2 0 1 1 0 0 0 2 1 1 1 1 1 2 1 2 3 3 1 1 1 2 3 1 3 2 2 1 0 1 1 4 4 4 1 0 4 0    0 1 1 2 1 3 2 0 3 4 1 1 1 1 3 2 0 1 3 2 1 2 1 0 3 3 2 5 4 2 5 3 4 2 2 5 3 3 3    3 5 5 8 7 14 12 28 22 24 23 36 33 26 32 27 26 18 30 24 15 13 19 15 17 6 5 7 5    4 3 5 3 1 4 4 9 5 3 1 4 0 0 6 2 5 3 3 3 1 2 3 2 4 1 5 5 3 8 2 1 1 4 1 7 5 6 6    4 4 3 2 6 3 3 3 3 1 3 4 5 4 3 4 3 1 2 3 1 2 1 2 2 6 5 2 2 2 4 2 2 0 2 3 3 2 7    4 4 1 4 2 0 3 1 1 2 1 2 3 1 3 2 2 4 3 1 4 0 0 4 2 2 2 1 0 0 0 0   0.116000 2.500 2.500 6.600       745364           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 2 1 1 2 1 1 1 0 1 0 2 0 1 1    0 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 2 3 0 1 4 4 0 4 0 1 0 1 3 3 0 2 1 2 3    2 1 1 1 2 0 4 0 0 4 5 2 5 4 1 3 5 5 4 0 4 4 2 3 2 3 5 2 2 4 2 3 4 2 3 3 3 3 3    2 4 12 10 13 14 19 22 23 24 36 19 32 25 25 36 24 18 20 21 14 18 13 8 6 9 2 9 5   2 5 3 4 4 3 3 0 4 3 2 5 3 4 2 2 6 3 4 0 2 4 1 3 4 7 4 5 3 2 4 5 5 3 4 4 4 2 3    2 4 4 2 1 5 7 1 5 2 4 1 5 5 3 4 4 3 2 4 2 4 0 6 2 3 4 1 2 2 2 4 1 4 2 2 2 5 6    5 1 4 4 2 3 3 3 1 4 3 4 2 6 2 5 3 2 2 1 3 2 2 5 1 1 0 0 1 0 0 0   0.118000 2.550 2.550 6.700       791846           4           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0    1 4 1 2 3 0 3 1 0 1 1 1 0 3 1 2 1 1 1 0 0 1 1 1 3 1 3 2 3 1 2 2 1 3 2 4 1 4 0    2 4 1 4 3 2 1 1 2 1 3 2 3 3 2 1 1 5 3 3 3 3 2 3 4 3 5 3 1 1 2 2 3 5 1 2 1 1 4    4 6 9 6 6 13 17 21 20 24 22 25 20 29 23 28 30 26 27 18 20 17 16 17 12 10 8 5 6   6 6 4 3 1 2 4 6 9 2 2 3 5 7 6 2 3 8 5 4 5 6 4 6 5 3 5 3 2 5 3 2 8 3 5 4 5 3 5    4 3 4 8 4 3 8 3 3 3 1 1 2 2 5 4 7 3 2 3 3 2 2 3 6 3 2 2 1 1 5 2 5 6 3 5 3 4 1    3 1 2 1 0 4 1 4 2 2 2 3 1 1 1 1 3 2 0 1 6 1 1 0 2 1 0 1 0 0 0 0   0.120000 2.600 2.600 6.800       833394           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 2 1 1 1 2 1 0 0 0 1 0 1 0 0 0 1 0 0 1 1 2 1 0 0    0 0 0 2 2 0 3 1 0 0 2 1 1 1 1 0 1 2 1 5 0 1 0 2 2 1 2 0 4 2 1 4 3 4 2 2 1 2 1    5 2 3 1 3 0 2 2 2 2 3 4 0 4 2 3 3 4 5 2 2 6 3 4 5 5 5 3 4 6 5 1 3 0 5 4 5 1 3    2 2 6 18 13 17 27 27 21 28 28 24 26 27 29 23 21 16 17 19 22 14 11 9 5 14 7 7 6   4 4 12 3 6 4 5 4 6 4 2 0 1 8 1 6 8 5 2 3 4 5 6 4 2 5 8 3 1 1 6 3 7 8 4 1 6 5 2   8 11 5 6 5 6 2 4 5 1 2 7 2 2 5 5 6 3 3 2 3 8 5 1 9 3 3 2 3 6 3 5 3 2 4 6 3 1 3   5 4 4 4 6 3 3 5 0 2 2 5 1 3 2 2 1 4 2 0 2 2 2 2 4 1 2 1 2 1 1 0   0.122000 2.650 2.650 6.900       876007           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 1 1 1 1 2 2 1 0 0 1 0 0 0 1 1 0 0 0 2 0 0    4 1 0 2 1 2 0 1 2 0 1 3 2 1 0 1 1 0 1 2 1 0 2 3 3 5 3 3 3 0 1 4 0 1 5 3 4 3 1    2 2 2 4 1 3 3 3 2 3 2 3 2 1 4 4 2 2 5 5 3 4 1 2 1 2 4 2 4 7 2 4 4 2 7 3 5 7 5    3 6 8 10 10 18 21 22 24 14 25 27 29 31 22 25 24 21 27 20 19 22 19 14 13 14 10    5 7 3 4 5 5 3 1 4 3 8 4 5 4 0 3 4 3 4 1 7 6 1 1 3 4 4 3 4 3 6 4 3 4 2 4 4 3 5    6 5 1 1 6 2 6 6 3 5 5 3 2 6 5 4 3 4 6 4 3 5 5 6 5 6 2 4 2 1 2 2 4 2 7 6 2 1 3    1 5 2 1 2 4 3 3 3 2 5 2 4 1 4 3 2 2 5 5 1 1 3 3 2 2 2 2 1 0 0 0 0 0   0.124000 2.700 2.700 7.000       925764           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 3 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0    1 2 0 0 3 2 0 1 2 1 1 2 0 2 1 2 2 0 0 2 3 2 3 2 2 3 2 2 4 0 2 0 5 1 3 2 3 1 2    3 2 0 6 4 3 6 2 5 0 5 2 1 4 4 5 7 4 2 3 5 2 0 2 5 2 4 7 4 4 4 8 5 3 1 7 2 2 1    5 5 5 14 19 16 22 18 30 29 25 36 23 23 22 25 25 27 26 23 14 20 16 16 10 6 6 6    4 2 6 6 6 6 6 4 6 1 0 3 4 4 5 2 4 3 2 4 4 5 5 5 6 10 6 3 6 8 5 5 8 7 4 6 4 3 4   8 5 5 7 4 6 3 5 8 4 3 4 4 3 4 3 1 3 3 7 2 4 8 3 6 4 3 3 2 5 4 4 3 7 4 5 4 4 3    4 7 2 3 3 4 3 0 2 2 4 3 4 2 4 2 2 6 4 4 6 6 1 5 1 1 2 1 0 0 0 0 0   0.126000 2.750 2.750 7.100       969560           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 1 2 0 2 0 2 2 0 1 1 1 0 0 1 0 1 1 1 1 2 0    1 2 2 1 2 0 0 1 0 1 0 2 1 0 1 0 1 1 2 0 3 0 3 4 3 1 3 2 0 4 0 1 2 0 3 1 1 2 3    2 2 2 5 1 7 1 5 1 5 4 2 0 0 1 2 1 3 2 3 3 5 4 10 10 2 5 11 4 1 2 1 7 3 5 4 4 1   5 10 8 7 9 9 20 20 21 33 21 28 20 27 32 21 29 22 20 24 15 13 27 14 13 15 10 9    3 11 6 7 5 3 6 8 5 4 4 1 3 3 5 2 7 3 6 6 1 6 4 6 5 3 4 2 4 3 3 9 4 5 4 4 5 2 3   10 4 3 2 6 10 6 3 6 5 5 5 4 8 8 5 4 3 6 4 4 2 4 4 4 5 7 4 4 4 4 5 2 2 3 4 5 2    1 3 2 6 2 7 7 1 6 4 4 6 5 5 4 0 2 2 3 2 7 5 0 4 1 1 4 6 1 0 3 2 0 0 1   0.128000 2.800 2.800 7.200      1022713           5           0  0 0 0 0 0 0 0 0 0 0 0 1 0 2 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 2 1 0 0 4 0 0 1 2 3    1 1 0 1 0 1 0 3 1 1 1 2 2 1 1 1 3 1 0 2 4 2 1 2 1 2 0 3 1 3 2 1 5 2 1 3 1 2 1    5 3 2 1 2 5 3 8 2 3 2 5 5 4 3 6 4 4 4 3 2 3 8 4 3 4 5 4 5 4 7 6 5 3 3 3 5 2 9    10 7 9 12 11 13 17 15 22 19 33 24 28 30 26 21 24 22 27 20 26 16 10 10 9 20 10    7 4 5 7 7 2 7 5 3 5 1 6 1 5 7 5 6 3 1 5 1 1 3 4 8 6 3 9 5 5 3 6 7 4 6 7 6 4 2    4 6 2 3 6 5 6 7 6 4 4 9 6 8 6 9 7 1 2 6 2 7 5 4 4 4 4 5 5 4 4 3 6 3 5 3 6 4 3    6 6 2 5 2 8 4 5 3 6 5 4 5 8 4 3 5 6 5 5 2 8 1 2 2 5 4 1 3 0 0 0 0 0   0.130000 2.850 2.850 7.300      1081669           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 5 0 0 2 2 0 0 1 0 0 0 1 1 0 2 0 2 2 2 1 0    1 0 2 2 3 1 1 0 2 0 1 0 2 1 1 2 2 0 1 4 3 0 2 1 1 0 2 5 2 1 0 1 3 2 5 2 1 2 5    2 3 4 3 6 6 6 4 6 6 3 1 3 2 3 4 7 5 2 9 7 4 1 4 4 3 2 2 2 7 4 8 4 7 4 6 8 5 1    8 6 10 18 21 18 15 21 24 21 26 22 30 28 27 23 22 21 17 25 20 17 13 17 9 12 7 8   5 4 4 5 5 2 4 1 1 2 5 7 6 4 9 7 7 5 5 5 5 5 2 4 5 3 6 8 2 4 9 4 10 5 1 4 5 5 5   10 3 2 8 6 5 7 3 13 3 3 6 5 1 4 5 9 5 2 7 4 5 6 3 5 6 5 4 5 9 6 4 3 4 4 4 5 8    5 5 0 3 6 3 4 3 7 5 6 4 3 3 6 8 4 1 3 1 2 7 3 4 6 6 1 3 4 1 0 1 0 0   0.132000 2.900 2.900 7.400      1131887           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 1 1 0 0 0 1 2 2 1 1 0 2 1 1 0 1 1 1 0 2 2 3 1 0 1 0    1 0 2 0 2 0 1 4 0 1 2 2 0 0 0 2 3 0 1 2 3 0 1 2 3 5 6 2 2 3 1 4 4 8 4 3 3 3 7    2 2 5 7 4 1 2 4 8 1 5 2 7 3 4 2 9 6 5 5 6 2 2 3 6 2 5 6 7 7 2 8 3 3 3 3 6 6 5    3 10 15 15 17 19 13 29 20 23 22 34 28 28 33 20 20 22 17 22 18 15 19 14 11 9 13   6 6 13 4 2 9 8 8 7 6 5 6 4 4 9 6 2 8 9 7 2 6 3 7 3 6 3 7 4 4 5 4 5 6 4 7 5 4     10 2 6 6 8 3 6 6 9 5 8 8 7 6 4 8 5 7 5 5 7 3 5 5 5 10 7 3 8 7 5 7 2 4 4 6 4 10   7 6 4 4 4 4 3 2 4 2 6 5 9 7 3 2 6 2 5 1 5 6 2 2 1 9 2 5 2 5 1 0 0 0 1 1   0.134000 2.950 2.950 7.500      1185706           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 2 1 0 1 1 0 0 0 0 0 1 0 1 1 2 0 1 0 1 2 0 0 0    1 1 0 1 1 1 0 2 2 0 1 3 3 2 3 0 0 2 2 3 2 1 1 3 0 0 1 1 3 4 3 1 1 9 1 4 0 1 3    4 1 3 2 6 4 7 7 3 2 8 5 2 5 2 4 6 7 3 7 7 8 4 7 2 4 7 7 9 9 2 5 5 8 3 5 7 3 6    10 6 10 15 10 13 14 29 21 23 37 26 20 28 20 16 24 25 16 19 21 20 20 17 11 10     12 8 7 7 5 5 5 4 5 6 7 3 6 5 7 5 11 9 6 8 11 6 4 6 8 8 7 7 7 4 5 4 8 5 4 3 4 8   10 7 9 4 7 6 8 9 7 3 5 7 7 6 2 6 4 7 3 9 8 12 7 6 6 6 4 5 7 2 4 7 3 2 4 4 7 1    4 5 0 4 6 3 10 8 5 4 3 4 5 7 5 7 5 7 3 5 2 5 6 4 5 2 4 1 6 6 2 4 2 0 0 1 0   0.136000 3.000 3.000 7.600      1238426           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 4 0 2 0 2 2 0 1 1 1 0 2 1 1 2 1 0 1 1 0 3 1 0    0 1 0 1 0 0 2 1 1 0 4 0 2 6 3 3 4 0 3 1 2 4 0 4 4 0 1 5 2 2 5 1 3 4 3 3 5 2 4    4 6 2 5 3 4 5 4 5 6 7 5 6 2 8 3 4 7 2 4 4 3 7 6 5 1 4 8 3 7 10 3 3 6 1 5 3 8     11 5 7 15 11 15 17 21 23 21 24 28 16 21 29 15 22 27 28 20 13 19 13 7 15 10 11    9 6 8 8 4 7 5 4 6 5 10 6 7 8 9 3 5 5 9 5 9 4 4 4 3 5 7 4 10 6 8 4 9 8 4 6 7 9    11 6 8 3 5 8 12 3 6 9 7 11 9 6 7 4 7 7 7 2 5 4 5 0 2 9 5 5 5 10 7 5 6 3 9 4 4    13 2 7 5 7 4 7 2 0 4 5 4 4 6 8 1 2 5 6 4 7 3 11 4 3 3 5 5 4 4 3 1 4 2 2 1 1 0   0.138000 3.050 3.050 7.700      1299809           6           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 2 1 1 0 0 1 0 0 2 0 1 2 0 0 3 0 0 1 3 1    2 0 2 0 1 1 2 1 2 3 2 1 2 5 2 2 2 4 3 2 5 3 0 3 2 4 5 4 3 0 5 4 1 4 3 8 6 4 4    7 4 5 4 3 6 5 6 10 3 6 6 2 6 3 4 4 3 6 7 6 8 3 4 7 5 4 9 2 4 8 5 9 8 3 7 5 7 7   13 7 11 15 17 16 18 18 18 20 17 26 25 19 20 26 31 22 18 20 18 14 11 16 4 7 11    10 8 9 9 6 3 8 8 7 5 6 10 3 5 6 6 3 12 7 8 8 2 10 4 13 9 9 12 4 5 9 7 9 5 7 4    8 9 6 7 8 10 8 7 5 7 11 6 4 4 4 6 4 9 4 5 9 10 7 4 12 7 4 9 5 10 10 6 8 4 7 2    4 7 2 6 8 4 11 3 3 9 7 6 7 3 8 7 4 8 5 3 7 4 5 5 7 4 6 7 5 5 3 5 2 5 4 1 2 0 0   1   0.140000 3.100 3.100 7.800      1361810           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 3 2 1 0 0 0 1 1 1 2 0 0 0 0 1 0 2 2 2 1 0 0 3 3 0    2 0 6 2 3 1 0 3 3 1 2 2 5 3 5 3 3 2 2 7 3 2 2 3 4 2 3 4 4 1 3 7 4 5 4 2 3 5 4    2 1 3 6 3 4 3 8 7 6 5 3 5 11 5 5 3 3 7 3 6 4 4 2 4 4 4 1 5 5 9 6 6 9 3 10 8 6    8 3 10 8 16 16 13 18 23 29 25 19 19 20 27 19 22 27 24 21 15 18 11 20 21 17 12    5 18 6 12 7 9 11 7 12 11 4 8 8 4 8 7 7 2 6 4 4 9 6 9 3 4 7 7 7 4 10 4 11 5 8 8   8 5 4 4 8 6 4 9 8 12 12 8 5 8 3 10 8 7 5 3 5 6 8 5 6 10 7 2 11 2 5 5 6 8 10 2    7 5 5 14 2 7 3 9 3 5 2 8 2 3 4 4 7 9 5 4 7 6 7 5 6 3 5 4 7 6 7 7 9 3 0 2 1 1 1   0 0   0.142000 3.150 3.150 7.900      1429499           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 2 1 1 0 0 0 3 0 2 2 1 0 3 0 2 1 3 0 0 1    1 3 1 2 4 1 5 3 5 1 0 7 1 3 2 3 2 2 2 3 0 0 1 3 6 3 2 2 4 4 4 6 4 3 6 4 10 3 7   2 5 4 7 4 5 8 4 7 4 1 7 11 5 2 10 2 11 3 7 8 10 9 6 3 5 3 6 3 10 11 5 5 9 7 10   8 9 5 15 11 9 18 18 15 24 17 23 17 19 25 17 24 18 37 16 17 21 17 14 20 17 15     15 9 4 11 7 3 8 10 8 8 6 8 3 4 5 8 4 6 3 9 9 6 2 10 4 4 3 8 4 9 1 7 5 9 7 10 9   10 4 6 5 8 6 6 10 10 6 5 7 6 6 10 5 7 8 8 8 7 7 11 12 8 3 10 6 9 13 11 4 6 7 6   3 10 5 8 4 7 7 7 5 8 4 9 5 5 7 6 6 7 11 11 7 8 5 3 5 7 7 10 3 3 6 5 7 9 2 3 7    1 0 0 0 0 1   0.144000 3.200 3.200 8.000      1493946           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 2 3 0 0 1 2 1 1 1 4 1 0 1 0 1 2 1 3 1 1 1 1 2    1 1 3 2 6 0 4 0 1 4 2 4 5 2 1 3 0 2 2 4 2 3 2 4 3 5 4 4 4 1 5 1 3 4 5 6 4 7 2    8 8 8 5 3 6 0 7 3 2 2 5 7 5 7 5 8 9 6 4 3 6 8 6 10 2 5 6 3 3 6 6 6 6 17 5 10 6   6 11 11 13 12 21 26 18 24 21 24 23 30 18 22 20 24 19 13 17 25 22 17 15 8 13 7    10 8 9 6 7 9 8 7 8 9 7 7 6 12 5 9 9 12 9 12 6 9 7 10 7 7 4 9 7 4 2 7 4 5 8 8 9   7 6 7 5 9 4 8 13 6 5 4 7 9 6 7 7 9 4 4 5 8 10 9 10 6 6 7 9 12 11 8 8 9 11 5 8    7 5 5 8 5 9 10 5 5 11 11 6 8 8 4 8 5 5 5 4 7 4 5 6 5 6 6 7 7 4 2 6 3 2 1 0 0 0   0 0   0.146000 3.250 3.250 8.100      1562352           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 2 0 1 2 1 1 0 0 1 0 1 2 0 0 0 3 1 2 0 4 4 2 0    0 2 3 2 0 1 3 3 4 0 1 4 3 3 4 5 5 4 2 1 4 2 5 3 2 7 6 3 5 6 5 5 5 1 5 2 7 4 8    7 4 6 5 7 5 3 5 8 1 6 4 6 8 7 6 7 6 3 4 6 3 5 8 4 10 3 3 11 6 5 3 9 6 4 3 17 9   11 11 24 13 15 14 25 26 26 21 17 32 32 22 18 25 29 29 27 24 21 12 23 14 12 11    9 17 7 9 11 3 7 6 5 5 12 3 6 8 7 4 7 11 10 8 9 5 8 2 10 9 8 10 10 7 7 4 7 5 7    7 9 10 8 7 7 16 6 8 10 5 6 6 12 12 7 11 11 8 9 7 8 12 10 7 8 7 11 8 9 7 7 4 9    4 7 14 9 8 8 13 9 8 7 13 5 9 5 7 4 9 5 7 8 7 8 7 3 10 9 3 4 4 4 5 2 6 6 3 5 10   4 4 2 3 0 1 0 0   0.148000 3.300 3.300 8.200      1630559           3           0  0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 4 2 1 1 1 2 1 2 0 2 1 5 0 1 1 4 0 2 1 4 5 3 0    1 1 1 2 1 3 3 3 1 1 1 1 1 3 4 6 6 8 8 4 3 2 7 2 2 1 7 4 4 5 1 10 6 4 4 4 3 3 3   6 11 6 4 5 4 8 5 5 9 4 5 5 7 6 4 13 12 3 6 7 5 2 7 9 7 8 8 4 7 6 4 10 6 8 9 9    9 13 15 17 23 25 13 16 24 22 26 21 27 24 24 21 21 21 15 17 22 25 21 22 17 14     11 8 12 5 9 7 8 5 11 10 6 6 5 9 13 10 9 8 8 8 6 4 9 10 9 9 7 8 7 5 7 8 14 13 5   14 5 12 11 8 9 6 5 4 9 13 7 10 13 11 11 8 5 9 10 8 7 6 7 13 3 13 8 7 13 17 5 8   5 10 7 12 7 6 6 9 7 8 8 11 8 11 9 11 11 8 5 6 10 4 9 3 10 8 7 10 8 7 8 10 10 7   4 11 5 7 8 2 4 3 0 0 1 0 1   0.150000 3.350 3.350 8.300      1707576           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 1 2 1 0 2 0 2 3 1 3 2 2 2 2 0 2 1 4 3 2 2 3    1 2 1 0 2 2 4 2 5 3 3 5 2 8 4 5 4 2 3 6 7 6 1 0 7 4 7 7 6 5 4 3 4 6 6 7 6 2 7    4 4 2 5 5 6 9 3 3 3 6 6 5 3 5 7 8 8 6 8 8 6 8 3 9 6 6 8 8 6 4 8 6 6 10 4 11 6    11 15 23 16 8 17 20 21 19 24 15 14 19 21 30 25 21 15 19 16 18 21 21 15 14 12     16 8 10 12 7 10 9 8 10 10 7 9 8 10 12 6 6 9 11 6 5 9 12 6 7 12 7 5 6 8 5 9 4     11 9 8 8 10 7 6 10 7 11 13 7 4 13 11 8 11 9 16 6 12 11 10 10 19 2 9 11 8 7 8 8   6 13 6 10 12 12 9 12 9 9 8 7 7 9 6 12 8 4 9 9 8 5 7 8 9 5 12 5 7 5 9 10 9 10 3   6 6 8 7 11 3 5 5 4 2 0 0 0 0   0.152000 3.400 3.400 8.400      1777231           3           0  0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 1 3 1 0 3 4 2 3 3 3 3 3 2 1 1 1 1 3 3 0    1 8 0 0 5 3 7 4 4 4 4 4 3 5 2 2 5 3 6 1 7 6 1 2 2 5 2 1 6 6 8 7 7 5 10 4 1 6 9   3 4 5 3 5 8 4 9 8 11 8 3 2 7 7 9 10 9 10 8 6 8 6 8 7 10 8 7 3 8 4 10 7 6 8 9 6   5 16 9 19 24 23 17 23 24 22 30 21 15 23 27 20 20 20 18 20 23 18 17 15 19 17 18   13 9 4 4 7 12 7 10 4 8 6 10 5 6 13 2 3 8 7 8 7 3 11 8 7 9 7 19 7 8 9 6 14 8 8    11 10 11 13 14 10 16 8 9 13 8 9 9 12 7 12 11 6 9 15 5 9 9 9 11 11 13 6 10 6 4    12 9 9 12 11 8 6 9 16 10 10 10 8 10 10 6 7 4 1 15 6 8 4 9 13 11 8 10 11 9 8 3    3 6 6 7 9 4 6 8 7 4 2 1 2 2 1 0   0.154000 3.450 3.450 8.500      1849489           6           0  0 0 0 0 0 0 0 0 0 0 1 1 3 0 1 2 2 0 1 4 1 1 0 1 0 2 1 0 0 1 1 1 1 6 3 6 1 3 1    3 3 0 6 0 4 2 7 4 6 4 4 3 7 4 5 7 5 5 2 3 9 9 2 5 5 3 9 4 2 7 6 2 8 2 5 7 12 6   5 4 5 10 4 12 10 6 4 14 7 9 10 11 7 7 7 7 3 9 7 4 3 8 7 5 7 9 6 8 9 6 8 8 12 6   5 11 12 13 11 13 21 26 19 23 25 18 23 22 23 23 18 27 20 15 20 25 24 19 18 12     14 13 15 8 15 10 11 7 9 13 11 12 13 11 11 7 11 13 6 5 10 6 6 10 8 14 5 14 11 8   5 9 7 10 10 8 7 15 13 3 13 12 18 15 7 10 9 10 8 15 9 6 8 9 10 10 9 5 7 7 5 10    11 13 12 12 12 10 6 17 10 11 9 4 8 7 6 6 9 12 8 16 18 7 5 10 8 12 10 15 6 13     11 6 10 16 10 11 16 8 9 5 11 10 14 11 5 2 5 7 3 1 1 0 1 0   0.156000 3.500 3.500 8.600      1920727           4           0  0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 2 1 2 0 3 0 1 1 0 1 0 3 0 4 4 1 3 1 2 3 3 4 3    1 2 3 9 5 2 3 7 3 3 6 5 2 6 1 4 3 2 3 6 5 1 8 3 8 5 3 7 6 13 11 9 5 8 7 7 5 8    7 4 8 6 4 10 4 6 5 6 9 9 12 6 7 10 9 9 8 8 3 8 9 8 8 2 12 11 13 8 13 7 8 6 6 9   6 8 16 13 14 16 16 22 20 21 21 17 20 18 19 22 20 11 20 22 21 14 19 15 23 17 15   12 14 19 16 10 11 14 11 9 11 9 12 8 16 14 9 6 18 10 11 7 10 11 17 10 13 8 10     12 9 12 7 7 10 10 11 11 9 8 8 14 10 10 9 14 9 14 13 9 19 16 17 4 11 8 12 11 10   21 6 10 8 9 12 9 7 7 12 7 16 14 10 13 6 13 8 9 10 6 10 8 7 10 4 6 11 19 12 6 7   5 8 11 10 12 13 9 6 10 5 11 11 4 14 10 7 2 6 5 1 2 5 1 1 0 0   0.158000 3.550 3.550 8.700      1999833           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 2 3 2 2 2 1 2 3 0 1 0 1 3 2 0 0 3 2 3 2 5 7 0    3 4 1 10 7 7 4 5 2 3 4 3 8 3 6 4 4 4 8 2 3 4 5 5 7 1 6 7 8 1 6 8 1 4 4 11 9 4    7 11 9 10 5 6 8 4 3 9 7 9 11 5 5 8 8 4 8 7 8 11 9 12 6 4 13 4 12 10 6 9 11 10    11 10 11 11 11 14 15 14 23 18 17 29 16 26 23 15 19 14 18 19 22 31 13 21 20 12    16 15 14 18 17 15 8 12 14 13 10 10 10 10 10 13 11 6 8 11 8 14 8 10 11 11 8 10    13 5 14 7 12 9 10 10 12 15 18 8 6 9 9 12 8 9 20 14 16 10 11 14 5 5 13 6 11 9     11 15 6 9 13 11 7 8 7 10 8 16 12 11 8 10 14 11 17 11 8 16 13 9 10 5 10 17 13     14 16 8 10 9 11 5 10 9 10 12 8 11 12 11 8 6 7 12 15 13 12 7 13 5 0 3 2 0 0 0 0   0.160000 3.600 3.600 8.800      2073149           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 1 2 1 2 2 1 0 2 2 1 0 3 6 4 5 5 2 2 2 5 5 3 6 4    6 4 5 2 4 4 3 2 4 6 3 3 6 5 7 4 5 7 5 3 5 6 13 5 3 10 5 9 7 4 5 6 5 10 6 5 5 6   6 4 14 7 6 11 6 9 10 9 8 5 3 8 10 10 6 6 8 9 5 6 14 7 11 10 9 9 11 13 8 4 5 10   12 6 16 8 8 7 19 20 23 10 16 27 25 23 19 26 21 16 20 21 24 18 25 8 11 13 16 18   13 22 18 9 16 4 16 10 12 13 9 7 9 8 17 11 10 13 10 14 4 9 12 16 8 9 16 17 13     11 14 8 8 13 9 11 15 10 11 14 8 6 4 9 11 18 9 9 8 9 15 11 11 11 9 6 13 13 10 7   8 10 15 14 9 7 4 10 12 17 10 14 13 10 10 12 20 9 7 6 11 15 11 10 8 9 6 10 13     17 6 8 9 6 13 13 16 10 15 5 11 14 11 12 6 5 12 9 4 9 2 4 1 1 0 0 0   0.162000 3.650 3.650 8.900      2156456           5           0  0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 2 0 1 1 3 2 3 4 3 3 2 1 3 6 5 2 3 4 4 3 6 2 3    4 4 5 5 3 4 1 4 5 9 3 3 4 3 3 8 5 6 12 2 10 3 4 6 8 9 8 8 2 2 7 5 8 2 8 9 7 2    6 8 6 5 8 2 7 5 6 13 5 6 8 11 6 10 5 6 3 8 10 11 10 10 14 10 11 8 11 8 12 6 12   5 15 12 13 10 13 13 18 23 12 21 18 21 23 20 30 20 23 26 24 24 21 21 29 19 21     16 23 20 13 19 13 16 11 15 13 13 11 8 11 14 14 13 4 16 15 18 13 9 19 8 11 6 9    14 8 13 12 13 10 13 10 14 11 13 11 8 10 13 11 11 14 11 8 14 11 10 9 14 12 14     18 8 12 7 13 12 10 14 14 8 12 17 11 13 9 12 12 15 7 9 13 17 11 11 11 12 17 12    11 16 15 8 9 12 7 13 15 11 16 7 10 7 14 5 18 10 10 8 8 6 6 13 14 6 9 11 9 9 3    5 1 1 3 0 0   0.164000 3.700 3.700 9.000      2234753           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 4 1 4 2 1 3 1 1 3 2 3 3 1 3 6 2 4 4 3 3 3 6 5 2    6 4 1 3 3 7 1 4 4 6 12 4 5 2 6 4 9 3 1 8 11 5 2 7 6 3 8 4 7 3 8 3 9 6 7 8 9 2    7 6 9 6 15 6 9 5 9 4 9 17 15 10 2 10 6 8 12 12 11 12 10 9 7 11 8 7 5 11 10 14    16 7 7 7 13 15 10 16 17 21 19 14 18 24 19 27 27 24 20 22 24 21 20 14 24 17 17    18 32 15 12 13 15 12 8 14 11 11 19 11 14 15 18 10 5 12 11 11 9 15 9 7 9 16 12    9 12 10 15 9 18 7 11 12 14 7 20 8 10 13 14 11 6 6 9 11 8 10 16 8 17 13 17 9 16   11 10 9 13 20 17 14 12 10 13 11 9 9 17 20 10 16 8 14 13 14 18 15 15 8 10 12 11   22 12 13 9 12 9 11 14 19 12 12 8 8 12 11 19 11 11 12 15 11 15 13 9 9 10 9 4 9    4 2 1 0 0   0.166000 3.750 3.750 9.100      2327990           3           0  0 0 0 0 0 0 0 0 0 0 0 0 3 2 2 0 1 2 2 1 1 0 0 3 1 4 2 6 4 2 4 3 2 5 5 2 3 1 3    1 2 10 2 7 4 3 4 3 3 4 3 10 6 9 6 3 8 5 5 3 4 4 6 8 4 4 7 5 5 11 14 5 3 6 8 8    7 10 11 7 17 7 11 10 8 7 8 12 13 11 12 6 13 9 7 7 6 5 8 13 10 10 14 11 11 8 12   15 14 9 13 10 9 18 13 18 12 23 14 17 24 15 23 25 31 19 17 29 19 19 19 26 25 19   17 22 19 19 19 11 11 12 22 21 8 10 18 10 14 19 17 13 14 10 6 9 10 15 11 5 13     13 11 11 17 16 9 7 14 7 19 6 10 13 7 12 18 14 7 12 15 13 13 9 13 13 13 12 12     14 12 19 10 16 18 18 12 8 10 10 9 7 14 9 11 13 12 8 15 12 11 10 12 11 17 15 19   14 14 12 7 7 12 11 15 16 12 11 12 10 19 19 12 14 12 15 11 20 13 7 18 9 15 19     16 11 5 9 8 6 2 4 0 2 0 1   0.168000 3.800 3.800 9.200      2406866           3           0  0 0 0 0 0 0 0 0 0 1 0 2 0 1 0 2 3 2 3 1 2 1 2 2 5 2 1 2 3 2 2 2 5 3 5 3 3 1 3    6 8 6 1 3 9 6 3 6 10 5 5 7 4 5 7 12 9 5 7 5 6 6 8 3 5 4 7 8 5 6 5 8 13 4 10 2    10 9 7 7 16 9 10 9 13 8 12 9 13 15 9 15 9 10 11 6 6 6 7 7 6 8 15 9 8 9 6 12 12   11 14 12 11 13 8 17 18 18 11 14 19 14 25 21 15 10 15 19 27 23 22 24 17 19 18     12 16 22 21 25 9 25 15 19 15 21 15 8 11 13 12 10 12 7 13 11 17 11 13 10 16 19    14 23 11 8 12 13 10 9 17 4 14 10 7 10 17 14 11 11 20 18 13 8 12 6 8 13 12 23     15 14 15 16 9 14 9 13 14 17 11 17 11 10 15 17 11 6 12 12 14 15 17 12 16 16 8     17 15 15 10 15 11 10 15 12 13 9 12 9 12 15 12 6 18 7 15 14 12 21 18 11 10 18     11 19 11 7 11 3 2 5 4 0 1 1   0.170000 3.850 3.850 9.300      2508471           7           0  0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 2 1 4 3 3 1 2 7 0 3 2 2 2 2 5 2 3 2 3 3 4 3 7 3    5 3 4 4 6 2 3 10 4 11 3 13 7 7 5 6 3 8 10 6 6 4 10 11 4 12 7 8 9 7 7 8 4 6 7 9   9 5 9 11 5 14 9 10 7 9 8 8 5 6 11 13 14 10 10 10 10 8 9 9 9 9 14 14 13 11 8 18   9 10 9 16 12 13 15 13 10 17 16 20 14 22 20 26 29 29 27 24 20 37 21 24 13 18 13   28 24 22 25 21 13 14 15 9 11 18 8 16 17 16 13 12 16 11 11 17 15 11 15 10 11 12   13 12 12 20 15 14 15 16 12 17 15 15 12 10 14 14 17 15 19 15 13 13 11 12 16 14    17 16 8 16 12 8 14 13 13 10 10 9 12 11 19 20 13 11 4 15 11 14 11 20 18 18 13     20 12 20 21 15 15 12 13 18 18 11 16 9 14 9 18 11 10 11 20 11 13 17 13 13 12 14   16 10 12 12 23 12 11 12 8 8 1 0 1 2 0   0.172000 3.900 3.900 9.400      2591210           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 4 4 3 2 1 3 3 2 3 0 3 6 1 3 1 5 5 4 3 9 9 0 4 7    5 3 5 5 8 7 3 3 5 5 8 5 11 10 8 10 3 6 6 6 7 7 8 8 12 9 6 10 8 7 10 8 8 10 4 6   12 20 4 6 11 7 9 10 7 5 10 6 12 11 7 13 13 16 12 6 8 14 13 9 7 5 14 17 17 10     12 11 6 13 11 17 3 23 13 21 12 21 28 11 23 30 28 23 24 26 26 17 21 15 27 23 33   16 22 25 11 20 22 23 21 20 7 21 13 16 12 16 16 13 18 18 9 13 16 15 9 20 13 19    15 8 9 11 14 13 10 9 10 16 15 14 17 15 19 16 12 14 12 14 14 16 19 19 4 24 8 12   15 16 11 15 14 20 14 13 13 14 16 19 14 13 19 14 18 23 15 15 4 14 17 14 8 10 15   20 11 15 19 12 9 13 12 11 16 12 16 13 14 16 13 16 16 19 19 12 11 10 19 15 15     14 12 5 11 18 17 10 13 12 9 6 2 0 0 1 0   0.174000 3.950 3.950 9.500      2675515           3           0  0 0 0 0 0 0 0 0 0 0 2 0 1 1 0 2 1 2 3 3 1 3 1 3 7 5 3 6 4 3 9 4 5 2 5 3 3 3 6    9 5 5 2 6 8 5 8 4 8 5 6 5 6 4 6 3 7 11 6 9 9 3 6 6 7 6 8 7 9 12 18 6 9 8 11 11   8 14 15 15 11 15 13 9 19 10 15 14 9 4 18 5 8 10 8 10 13 9 12 11 8 8 12 6 15 8    9 9 18 7 17 21 9 13 18 14 21 24 18 22 17 26 15 21 23 25 19 26 23 20 27 17 27     20 26 15 22 15 19 15 16 24 12 15 24 13 13 17 11 7 10 21 15 15 16 13 20 22 12     16 12 16 15 14 18 11 12 14 14 24 10 13 16 19 8 11 18 19 15 15 23 16 16 11 12     18 11 13 14 16 10 14 13 18 12 15 15 14 8 11 17 12 22 13 12 14 15 10 11 15 19     15 12 17 8 21 23 13 19 11 8 12 15 11 14 15 19 15 10 17 9 16 14 18 14 16 14 14    23 14 14 13 16 12 14 15 14 9 14 7 5 2 3 1 1 1   0.176000 4.000 4.000 9.600      2779386           5           0  0 0 0 0 0 0 0 0 0 0 0 2 2 3 0 1 3 0 6 2 6 3 1 5 0 4 1 6 5 1 6 3 6 5 6 2 5 4 5    3 9 8 5 7 5 8 4 12 8 12 6 8 5 7 5 7 10 5 5 6 7 9 7 10 7 10 10 8 12 10 6 13 10    11 12 11 10 10 16 9 6 12 9 11 17 10 11 10 14 11 16 7 11 13 12 10 17 14 11 13     12 10 13 16 16 17 17 15 14 11 8 15 13 27 22 14 19 17 22 22 27 18 28 19 27 32     24 33 21 17 23 12 27 25 20 20 17 22 14 15 22 21 14 9 16 12 19 16 17 16 16 20     14 18 15 14 18 10 12 9 16 12 12 10 13 19 12 12 15 14 15 22 12 11 15 18 19 18     10 6 11 14 10 23 17 14 16 19 10 10 16 19 17 23 16 18 19 18 16 12 14 14 14 13     11 10 24 21 22 26 18 18 18 14 17 5 13 17 11 13 16 14 18 16 9 15 15 18 16 14 21   13 22 17 9 8 16 17 16 16 19 7 20 19 18 16 10 6 10 6 3 5 1 0 0 2   0.178000 4.050 4.050 9.700      2869617           3           0  0 0 0 0 0 0 0 0 0 0 2 2 2 0 1 4 1 3 2 2 1 2 3 2 2 4 4 7 5 6 5 3 6 6 5 7 8 1 5    2 3 5 5 8 10 7 6 10 9 6 8 9 7 8 10 15 4 10 5 8 8 6 11 8 8 11 7 5 8 14 5 11 7     13 10 9 7 8 9 14 12 10 9 11 6 14 15 14 13 11 9 18 18 10 14 14 10 12 16 12 9 8    14 15 6 11 11 12 10 14 12 11 18 13 13 27 16 23 23 20 21 32 20 18 25 22 24 32     25 34 19 23 21 25 22 25 19 23 19 21 16 19 16 18 9 18 6 13 12 13 18 12 8 19 14    14 11 16 13 15 14 21 11 14 14 13 11 20 14 14 26 10 22 16 18 15 20 24 18 19 19    16 14 14 14 21 13 19 18 20 13 17 11 17 14 22 17 15 15 20 8 21 15 16 16 23 17     13 19 21 20 12 15 18 15 19 15 18 17 20 15 13 14 24 18 15 15 14 18 20 19 17 19    20 21 21 15 19 19 17 11 16 16 11 23 10 20 13 10 5 10 2 3 1 1 0   0.180000 4.100 4.100 9.800      2975040           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 2 4 4 2 4 4 1 2 5 0 3 3 5 2 5 5 4 9 2 7 8 4 8 3 11 6   10 4 7 8 6 6 5 8 8 7 11 4 4 11 12 7 11 7 10 11 7 11 11 10 9 7 13 12 18 8 14 12   14 12 8 8 16 10 10 14 16 10 6 8 15 15 15 22 13 19 18 12 6 11 10 7 12 12 24 15    17 9 17 21 10 17 18 14 14 14 9 22 11 23 17 15 23 32 20 11 12 20 15 23 30 20 25   19 26 29 19 27 23 15 19 11 30 16 21 24 18 18 14 8 6 25 13 21 13 13 19 13 21 25   23 18 14 14 13 20 12 14 8 10 25 14 15 20 15 10 15 16 21 8 15 20 21 20 13 16 15   20 11 18 17 17 9 12 24 19 13 18 17 20 14 15 20 10 23 19 25 8 7 13 14 11 15 18    13 10 12 10 17 11 24 16 17 11 12 13 16 20 14 26 12 17 13 14 16 16 6 20 16 23     22 11 17 16 14 25 19 17 21 22 19 13 19 16 18 10 11 7 4 6 0 0 2   0.182000 4.150 4.150 9.900      3083416           6           0  0 0 0 0 0 0 0 0 0 0 2 1 1 4 1 3 4 3 5 6 2 1 4 2 3 5 6 6 7 2 4 1 11 7 5 2 6 6 8   9 8 12 7 11 9 6 12 7 8 9 6 6 8 11 6 6 8 11 8 11 12 11 13 9 10 7 9 6 11 9 13 12   12 8 14 15 8 9 8 8 11 22 16 6 11 16 15 9 13 12 12 13 11 15 9 9 16 14 14 12 21    12 12 12 16 19 10 15 18 8 16 14 16 16 21 30 22 9 25 19 19 26 23 33 25 22 21 19   21 20 20 21 20 26 20 29 27 25 25 21 20 25 21 21 18 14 19 15 6 20 18 16 20 16     13 13 15 15 15 15 22 16 15 15 11 21 19 11 19 13 14 15 17 21 12 18 12 22 18 21    18 13 23 15 18 9 21 11 14 23 18 21 25 18 22 15 21 23 15 15 16 19 21 18 19 21     17 13 24 23 22 19 14 20 22 15 14 14 20 20 23 13 18 15 18 20 20 24 9 12 17 21     21 12 16 17 16 16 21 26 19 15 21 22 24 15 11 13 13 6 8 1 4 0 1 0   0.184000 4.200 4.200 10.00      3174897           3           0  0 0 0 0 0 0 0 0 0 0 1 1 2 3 0 5 4 3 3 0 7 3 2 4 2 8 6 4 5 9 3 8 6 4 2 7 6 8 7    9 3 5 8 5 9 7 7 6 11 14 7 12 9 9 5 15 12 14 15 12 9 11 5 8 13 11 12 10 9 17 12   11 8 17 11 19 11 15 9 11 7 15 14 16 16 16 7 12 10 14 13 13 16 16 11 15 13 14     12 16 11 12 13 17 10 13 19 11 17 11 13 14 13 10 19 19 23 24 22 24 24 31 19 23    22 28 21 25 29 17 23 17 21 30 22 19 25 27 27 22 23 23 17 25 17 20 17 12 23 21    9 17 20 16 19 16 17 20 9 16 11 22 16 15 12 15 17 23 24 16 16 18 26 11 16 20 18   10 14 17 26 19 17 15 17 19 12 21 20 24 17 27 13 16 18 19 23 14 19 14 10 11 18    19 6 15 21 23 25 17 17 18 21 27 20 17 18 20 25 22 20 18 22 18 17 15 24 16 15     22 18 22 14 20 20 22 18 22 25 19 26 12 19 19 13 12 16 19 14 9 7 5 4 2 0 2   0.186000 4.250 4.250 10.10      3283256           3           0  0 0 0 0 0 0 0 1 0 0 1 1 4 1 5 2 5 5 3 4 6 3 2 4 7 8 2 6 6 4 10 7 8 7 5 4 4 9 8   18 10 7 6 6 13 12 10 13 10 7 15 4 7 10 13 12 8 8 13 5 14 6 9 14 9 10 16 12 13    11 8 12 11 10 13 9 11 15 17 23 18 13 10 12 11 12 14 14 14 10 12 12 16 13 15 13   13 14 18 10 13 17 14 14 14 12 12 8 18 14 23 20 16 19 16 16 16 27 18 21 19 20     19 37 22 21 22 28 24 26 18 21 28 21 22 21 21 22 16 15 13 22 22 27 22 11 13 20    10 17 16 19 20 30 18 25 8 7 22 18 17 14 23 16 17 11 16 24 19 18 22 15 15 23 16   13 15 22 14 8 12 18 13 15 22 17 15 15 17 27 21 19 21 24 17 10 12 14 19 17 22     18 19 17 28 19 15 14 16 28 17 20 15 11 22 18 19 16 21 17 24 19 22 22 20 10 20    18 18 18 21 18 23 18 32 26 21 21 22 20 22 16 17 20 22 21 17 13 13 11 9 5 0 1 1   1   0.188000 4.300 4.300 10.20      3396610           5           0  0 0 0 0 0 0 0 0 0 0 1 2 3 0 2 5 5 4 3 3 5 1 2 3 6 9 3 3 3 8 7 2 9 5 7 5 11 8 9   7 6 9 6 4 5 8 6 10 9 14 10 15 6 7 13 15 10 13 7 15 10 10 11 14 14 6 7 17 13 19   3 13 9 6 13 13 14 10 11 12 16 17 13 10 15 15 19 19 11 11 15 11 13 9 13 20 8 18   14 18 23 23 23 15 19 20 14 11 7 18 16 15 22 28 20 24 22 25 17 20 39 24 26 25     25 33 25 25 25 33 15 29 18 29 18 12 18 23 17 24 28 22 16 20 33 23 18 23 26 23    15 24 16 16 16 16 17 15 15 16 14 11 9 23 17 13 13 18 12 19 20 30 20 20 15 21     19 16 18 20 23 19 15 10 11 15 19 13 22 22 18 19 16 19 23 16 10 25 23 20 21 20    31 19 19 18 15 22 18 14 13 21 18 19 22 19 16 17 21 14 20 26 18 26 22 19 26 19    20 22 15 13 24 23 15 21 21 21 27 18 22 19 24 17 22 16 18 23 10 12 3 5 3 3 0 0   0.190000 4.350 4.350 10.30      3502025           3           0  0 0 0 0 0 0 0 0 0 0 0 3 0 3 2 3 4 4 3 4 5 10 7 6 6 4 5 12 10 6 6 13 10 6 7 14    9 6 13 10 12 16 3 9 9 7 5 6 13 11 10 8 11 19 12 14 13 16 13 14 9 12 14 13 14     16 10 14 7 16 18 16 9 15 11 20 15 10 14 14 11 14 17 10 6 16 10 15 12 17 17 20    15 7 12 23 15 8 13 12 8 16 15 20 16 16 20 14 11 20 24 23 20 16 18 27 25 31 27    27 25 21 31 27 20 23 24 32 17 21 34 27 17 19 19 25 30 27 21 24 28 30 19 26 21    14 16 21 23 27 8 17 21 17 11 23 15 22 15 18 10 17 20 23 18 18 17 19 22 15 22     21 19 23 18 18 26 17 18 26 18 24 15 22 23 23 19 23 25 23 24 26 10 21 16 32 23    18 19 24 21 28 26 22 19 19 14 30 21 24 23 22 21 13 27 20 27 24 15 20 22 22 13    25 14 19 32 21 18 18 23 22 22 14 18 20 24 14 19 20 18 17 24 29 27 20 12 18 17    11 9 2 3 2 1 0   0.192000 4.400 4.400 10.40      3593938           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 1 2 3 4 7 8 1 5 6 8 3 7 5 4 9 8 8 7 7 9 7 9 9 15 5 7   8 15 14 9 9 13 8 8 15 10 7 10 9 10 14 7 8 18 16 17 11 14 15 13 8 15 8 15 18 16   16 22 12 8 16 13 10 13 13 10 21 11 10 16 16 13 13 17 16 20 23 13 22 16 14 15     22 19 22 15 22 24 16 16 16 19 12 15 16 17 20 18 19 26 17 23 18 32 20 28 36 22    25 30 29 31 36 24 24 21 29 24 32 29 30 23 34 19 33 34 25 20 31 27 24 16 14 21    20 13 24 17 28 13 24 16 26 15 26 21 11 15 20 13 20 18 25 23 18 24 26 22 16 22    14 13 16 20 24 25 19 29 20 15 20 16 25 26 21 22 17 24 22 21 17 23 23 15 19 30    23 17 21 19 18 21 26 14 29 24 20 33 19 15 20 23 28 19 23 25 15 19 17 31 23 18    29 26 25 14 24 25 18 19 19 24 35 31 23 23 14 15 19 11 20 19 24 17 16 9 10 12 3   2 2 0 1   0.194000 4.450 4.450 10.50      3712573           7           0  0 0 0 0 0 0 0 0 0 0 0 1 1 1 5 3 5 4 3 11 3 10 4 6 7 8 5 5 5 8 9 12 7 7 11 8 6    7 9 10 13 10 6 13 9 9 9 11 14 14 12 13 10 6 13 13 15 12 13 19 8 14 13 16 11 13   14 15 9 15 16 13 16 17 17 17 23 18 16 19 10 13 18 16 10 9 21 11 22 14 20 14 18   13 15 12 13 14 16 14 15 20 29 17 14 18 8 15 21 15 19 15 22 20 17 15 23 26 16     26 24 23 23 23 23 30 24 29 28 26 35 33 31 22 23 22 20 37 22 27 33 26 27 26 17    16 18 27 22 21 24 18 18 18 17 15 18 14 19 24 22 15 20 21 15 19 25 15 16 26 19    22 29 20 16 13 15 16 32 24 23 13 33 17 22 18 18 23 24 22 21 20 26 21 16 22 18    18 16 15 26 26 17 22 21 13 25 24 13 23 18 18 25 32 20 24 21 17 19 24 24 23 33    19 19 21 32 18 22 23 19 23 32 18 31 22 25 23 23 31 29 21 16 20 20 15 22 14 12    5 10 9 2 1 0 1   0.196000 4.500 4.500 10.60      3829518           3           0  0 0 0 0 0 0 0 0 0 1 2 2 1 6 2 6 5 9 3 5 6 8 6 3 8 10 7 11 9 4 8 9 5 11 10 13 9   16 13 10 9 5 12 9 15 10 13 9 12 18 14 19 9 13 14 12 13 21 17 17 18 16 13 12 16   14 18 10 15 15 16 11 15 22 17 19 17 11 12 26 12 17 19 18 21 20 27 17 18 19 21    14 19 16 12 16 21 20 18 8 17 17 13 13 18 15 19 15 19 20 28 21 29 27 27 34 24     26 31 25 24 16 17 23 23 30 28 18 28 32 28 37 18 26 18 16 33 21 31 21 20 22 19    20 25 18 18 20 11 17 20 22 23 14 14 17 18 20 25 20 19 20 22 19 16 33 25 21 21    24 18 16 22 29 22 16 27 26 28 21 20 22 17 25 23 20 23 18 16 19 26 22 21 22 23    15 20 19 17 23 19 20 15 22 18 22 26 23 23 31 17 29 18 13 15 19 18 24 22 28 22    17 23 24 26 21 23 25 24 29 26 18 41 24 29 22 27 23 28 16 30 24 18 23 19 17 18    21 17 14 8 2 5 2 0 0   0.198000 4.550 4.550 10.70      3950740           3           0  0 0 0 0 0 0 0 0 1 1 1 2 1 3 7 5 6 7 7 7 4 5 6 4 1 8 9 10 9 8 10 8 12 6 10 8 10   8 11 9 10 15 7 11 8 13 11 13 15 15 17 12 10 8 17 12 9 14 12 14 11 14 21 14 15    20 18 16 8 15 22 24 14 10 18 14 15 16 12 10 16 21 16 25 17 20 17 17 20 15 24     15 17 22 25 17 13 22 18 20 19 11 21 22 21 16 21 24 16 22 17 21 17 24 22 24 35    27 24 28 24 32 37 34 25 24 29 37 37 25 28 21 23 24 22 21 20 25 22 32 19 21 22    24 20 21 20 22 18 27 17 14 20 22 22 22 14 19 20 20 21 23 22 14 20 21 23 20 18    23 20 25 31 24 18 22 14 23 22 21 23 27 27 20 21 18 22 23 24 23 21 18 22 17 22    21 35 15 24 24 12 27 30 27 28 22 31 24 24 19 27 24 28 23 25 26 35 27 22 29 21    24 18 19 26 33 29 31 23 25 19 24 26 21 10 23 24 26 28 20 27 26 17 29 22 18 14    22 8 10 11 4 4 1 2 0   0.200000 4.600 4.600 10.80      4068161           5           0  0 0 0 0 0 0 0 0 0 1 1 0 1 5 5 2 9 3 11 6 9 8 7 7 8 3 3 13 10 8 7 5 8 13 8 7 14   12 10 7 15 13 13 11 12 12 14 12 13 12 10 15 11 14 7 16 15 8 15 13 15 13 18 13    17 21 15 12 13 13 17 18 18 18 16 19 20 17 14 17 24 13 12 18 19 19 13 21 18 26    21 23 16 14 18 19 13 33 13 19 20 14 20 23 14 26 19 22 21 21 16 27 30 25 28 22    32 21 30 27 31 21 30 22 27 27 31 27 21 17 38 41 17 21 20 19 30 24 27 20 20 21    30 20 19 19 31 25 24 13 21 23 19 24 33 24 17 20 17 12 25 23 18 24 11 24 25 22    33 20 11 22 31 21 20 26 27 21 26 24 14 23 23 20 20 26 28 10 20 27 24 22 17 27    28 20 23 23 33 20 24 26 32 33 29 21 25 24 17 18 19 27 26 20 24 26 24 24 26 21    19 24 21 36 32 18 33 33 20 23 25 33 19 27 25 27 24 27 21 21 23 28 18 27 25 19    24 15 17 12 15 7 2 1 0 0 ", "%f ", Inf);
+%! assert (rows (x) == n);
 
 %% Note use fprintf so output not sent to stdout
 %% test/octave.test/io/printf-1.m
 %!test
-%! nm = tmpnam();
+%! nm = tmpnam ();
 %! fid1 = fopen(nm,"w");
 %! x = fprintf (fid1, "%s: %d\n", "test", 1);
 %! fclose(fid1);
 %! fid2 = fopen(nm,"r");
 %! str = fscanf(fid2,"%s");
 %! fclose(fid2);
 %! unlink(nm);
-%! assert(x,8);
-%! assert(str,"test:1");
+%! assert (x, 8);
+%! assert (str, "test:1");
 
 %% test/octave.test/io/printf-2.m
-%!error printf (1);
+%!error printf (1)
 
 %% test/octave.test/io/printf-3.m
-%!error <Invalid call to printf> printf ();
+%!error <Invalid call to printf> printf ()
 
 %% test/octave.test/io/sprintf-1.m
 %!test
 %! [s, msg, status] = sprintf ("%s: %d\n", "test", 1);
 %! 
-%! assert(s == "test: 1\n" && ischar (msg) && status == 8);
+%! assert (s == "test: 1\n" && ischar (msg) && status == 8);
 
 %% test/octave.test/io/sprintf-2.m
-%!error sprintf (1);
+%!error sprintf (1)
 
 %% test/octave.test/io/sprintf-3.m
-%!error <Invalid call to sprintf> sprintf ();
+%!error <Invalid call to sprintf> sprintf ()
 
 %% test/octave.test/io/fopen-1.m
 %!test
 %! arch_list = ["native"; "ieee-le"; "ieee-be"; "vaxd"; "vaxg"; "cray"];
 %! 
 %! status = 1;
 %! 
 %! for i = 1:6
@@ -373,97 +374,88 @@
 %!       break;
 %!     endif
 %!   endfor
 %!   if (status == 0)
 %!     break;
 %!   endif
 %! endfor
 %! 
-%! assert(status == 1);
+%! assert (status == 1);
 
 %% test/octave.test/io/fopen-2.m
 %!test
 %! s.a = 1;
-%! fail("fopen (s)");
+%! fail ("fopen (s)");
 
 %% test/octave.test/io/fopen-3.m
-%!error fopen ("foo", "x");
+%!error fopen ("foo", "x")
 
 %% test/octave.test/io/fopen-4.m
 %! fopen ("foo", "wb", "noodle");
-%! assert(prog_output_assert("error:.*"));
+%! assert (prog_output_assert ("error:"));
 
 %% test/octave.test/io/fopen-5.m
-%!error <Invalid call to fopen> fopen ();
+%!error <Invalid call to fopen> fopen ()
 
 %% test/octave.test/io/fopen-6.m
-%!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1);
+%!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1)
 
 %% test/octave.test/io/fclose-1.m
-%!error fclose (0);
+%!error fclose (0)
 
 %% test/octave.test/io/fclose-2.m
-%!error <Invalid call to fclose> fclose (1, 2);
+%!error <Invalid call to fclose> fclose (1, 2)
 
 %% test/octave.test/io/tmpnam-1.m
-%!assert(ischar (tmpnam ()));
+%!assert (ischar (tmpnam ()))
 
 %% test/octave.test/io/tmpnam-2.m
 %!warning tmpnam (1);
 
 %% test/octave.test/io/tmpnam-3.m
 %!warning tmpnam ("foo", 1);
 
 %% test/octave.test/io/tmpnam-4.m
-%!error <Invalid call to tmpnam> tmpnam (1, 2, 3);
+%!error <Invalid call to tmpnam> tmpnam (1, 2, 3)
 
 %% test/octave.test/io/binary-io-1.m
 %!test
 %! type_list = ["char"; "char*1"; "integer*1"; "int8";
 %! "schar"; "signed char"; "uchar"; "unsigned char";
 %! "short"; "ushort"; "unsigned short"; "int";
 %! "uint"; "unsigned int"; "long"; "ulong"; "unsigned long";
 %! "float"; "float32"; "real*4"; "double"; "float64";
 %! "real*8"; "int16"; "integer*2"; "int32"; "integer*4"];
 %! 
 %! n = rows (type_list);
-%! 
 %! nm = tmpnam ();
-%! 
 %! id = fopen (nm, "wb");
-%! 
 %! if (id > 0)
-%! 
-%! for i = 1:n
-%! fwrite (id, i, deblank (type_list(i,:)));
-%! endfor
-%! 
-%! fclose (id);
-%! 
-%! id = fopen (nm, "rb");
-%! 
-%! if (id > 0)
-%! 
-%! x = zeros (1, n);
-%! 
-%! for i = 1:n
-%! x(i) = fread (id, [1, 1], deblank (type_list(i,:)));
-%! endfor
-%! 
-%! if (x == 1:n)
-%! printf_assert ("ok\n");
-%! endif
-%! 
-%! endif
-%! 
+%!   for i = 1:n
+%!     fwrite (id, i, deblank (type_list(i,:)));
+%!   endfor
+%!
+%!   fclose (id);
+%!   
+%!   id = fopen (nm, "rb");
+%!   if (id > 0)
+%!     x = zeros (1, n);
+%!     for i = 1:n
+%!       x(i) = fread (id, [1, 1], deblank (type_list(i,:)));
+%!     endfor
+%!     
+%!     if (x == 1:n)
+%!       printf_assert ("ok\n");
+%!     endif
+%!   endif
 %! endif
 %! 
 %! unlink (nm);
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/io/file-pos-1.m
 %!test
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! if (id > 0)
 %!   fprintf (id, "%d\n", 1:100);
 %!   fclose (id);
@@ -485,136 +477,132 @@
 %!       fseek (id, pos_one, SEEK_SET);
 %!       s_one_x = fgets (id);
 %!       fseek (id, pos_fifty, SEEK_SET);
 %!       s_fifty_x = fgets (id);
 %!       if (s_one == s_one_x && s_fifty == s_fifty_x)
 %!         frewind (id);
 %!         s_one_x = fgets (id);
 %!         if (s_one != s_one_x)
-%!           error("bombed!!");
+%!           error ("bombed!!");
 %!         endif
 %!       endif
 %!     endif
 %!   endif
 %! endif
 %! unlink (nm);
 
 %% test/octave.test/io/fputs-1.m
-%!error <Invalid call to fputs> fputs ();
+%!error <Invalid call to fputs> fputs ()
 
 %% test/octave.test/io/fputs-2.m
-%!error <Invalid call to fputs> fputs (1, "foo", 1);
+%!error <Invalid call to fputs> fputs (1, "foo", 1)
 
 %% test/octave.test/io/fputs-3.m
-%!assert(fputs (1, 1),-1);
+%!assert (fputs (1, 1),-1)
 
 %% test/octave.test/io/fgetl-1.m
-%!error <Invalid call to fgetl> fgetl ();
+%!error <Invalid call to fgetl> fgetl ()
 
 %% test/octave.test/io/fgetl-2.m
-%!error <Invalid call to fgetl> fgetl (1, 2, 3);
+%!error <Invalid call to fgetl> fgetl (1, 2, 3)
 
 %% test/octave.test/io/fgetl-3.m
-%!error fgetl ("foo", 1);
+%!error fgetl ("foo", 1)
 
 %% test/octave.test/io/fgets-1.m
-%!error <Invalid call to fgets> fgets ();
+%!error <Invalid call to fgets> fgets ()
 
 %% test/octave.test/io/fgets-2.m
-%!error <Invalid call to fgets> fgets (1, 2, 3);
+%!error <Invalid call to fgets> fgets (1, 2, 3)
 
 %% test/octave.test/io/fgets-3.m
-%!error fgets ("foo", 1);
+%!error fgets ("foo", 1)
 
 %% test/octave.test/io/fprintf-1.m
-%!error <Invalid call to fprintf> fprintf ();
+%!error <Invalid call to fprintf> fprintf ()
 
 %% test/octave.test/io/fprintf-2.m
-%!error <Invalid call to fprintf> fprintf (1);
+%!error <Invalid call to fprintf> fprintf (1)
 
 %% test/octave.test/io/fprintf-3.m
 %!test
 %! s.a = 1;
-%! fail("fprintf (s)","Invalid call to fprintf.*");
+%! fail ("fprintf (s)", "Invalid call to fprintf");
 
 %% test/octave.test/io/fprintf-4.m
-%!error fprintf (1, 1);
+%!error fprintf (1, 1)
 
 %% test/octave.test/io/fprintf-5.m
-%!error fprintf (-1, "foo");
+%!error fprintf (-1, "foo")
 
 %% test/octave.test/io/fscanf-1.m
-%!error <Invalid call to fscanf> fscanf ();
+%!error <Invalid call to fscanf> fscanf ()
 
 %% test/octave.test/io/fscanf-2.m
-%!error <Invalid call to fscanf> fscanf (1);
+%!error <Invalid call to fscanf> fscanf (1)
 
 %% test/octave.test/io/fscanf-3.m
-%!error fscanf ("foo", "bar");
+%!error fscanf ("foo", "bar")
 
 %% test/octave.test/io/fread-1.m
-%!error <Invalid call to fread> fread ();
+%!error <Invalid call to fread> fread ()
 
 %% test/octave.test/io/fread-2.m
-%!error <Invalid call to fread> fread (1, 2, "char", 1, "native", 2);
+%!error <Invalid call to fread> fread (1, 2, "char", 1, "native", 2)
 
 %% test/octave.test/io/fread-3.m
-%!error fread ("foo");
+%!error fread ("foo")
 
 %% test/octave.test/io/fwrite-1.m
-%!error <Invalid call to fwrite> fwrite ();
+%!error <Invalid call to fwrite> fwrite ()
 
 %% test/octave.test/io/fwrite-2.m
-%!error <Invalid call to fwrite> fwrite (1, rand (10), "char", 1, "native", 2);
+%!error <Invalid call to fwrite> fwrite (1, rand (10), "char", 1, "native", 2)
 
 %% test/octave.test/io/fwrite-3.m
-%!error fwrite ("foo", 1);
+%!error fwrite ("foo", 1)
 
 %% test/octave.test/io/feof-1.m
-%!error <Invalid call to feof> feof ();
+%!error <Invalid call to feof> feof ()
 
 %% test/octave.test/io/feof-2.m
-%!error <Invalid call to feof> feof (1, 2);
+%!error <Invalid call to feof> feof (1, 2)
 
 %% test/octave.test/io/feof-3.m
-%!error feof ("foo");
+%!error feof ("foo")
 
-%% FIXME trimerr in test.m finds and strips ".*ferror:"!!
-%% So use fail for the next two tests instead.
 %% test/octave.test/io/ferror-1.m
-%!test
-%! fail("ferror ();","Invalid call to ferror.*");
+%!error <Invalid call to ferror> ferror ()
 
 %% test/octave.test/io/ferror-2.m
-%!test
-%! fail("ferror (1, \"clear\", 2);","Invalid call to ferror.*"); 
+%!error <Invalid call to ferror> ferror (1, 'clear', 2)
 
 %% test/octave.test/io/ferror-3.m
-%!error ferror ("foo");
+%!error ferror ("foo")
 
 %% test/octave.test/io/ftell-1.m
-%!error <Invalid call to ftell> ftell ();
+%!error <Invalid call to ftell> ftell ()
 
 %% test/octave.test/io/ftell-2.m
-%!error <Invalid call to ftell> ftell (1, 2);
+%!error <Invalid call to ftell> ftell (1, 2)
 
 %% test/octave.test/io/ftell-3.m
-%!error ftell ("foo");
+%!error ftell ("foo")
 
 %% test/octave.test/io/fseek-1.m
-%!error <Invalid call to fseek> fseek ();
+%!error <Invalid call to fseek> fseek ()
 
 %% test/octave.test/io/fseek-2.m
-%!error <Invalid call to fseek> fseek (1, 0, SEEK_SET, 1);
+%!error <Invalid call to fseek> fseek (1, 0, SEEK_SET, 1)
 
 %% test/octave.test/io/fseek-3.m
-%!error fseek ("foo", 0, SEEK_SET);
+%!error fseek ("foo", 0, SEEK_SET)
 
 %% test/octave.test/io/frewind-1.m
-%!error <Invalid call to frewind> frewind ();
+%!error <Invalid call to frewind> frewind ()
 
 %% test/octave.test/io/frewind-2.m
-%!error <Invalid call to frewind> frewind (1, 2);
+%!error <Invalid call to frewind> frewind (1, 2)
 
 %% test/octave.test/io/frewind-3.m
-%!error frewind ("foo");
+%!error frewind ("foo")
 
diff --git a/test/test_contin.m b/test/test_line_continue.m
rename from test/test_contin.m
rename to test/test_line_continue.m
--- a/test/test_contin.m
+++ b/test/test_line_continue.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,153 +11,70 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/contin/contin-1.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-2.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-3.m
-%!test
+%!shared x, a, b
 %! x = [1,2];
 %! a = 1;
 %! b = 2;
+
+%!test
 %! y = [a... # comments here ok
 %! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-4.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments ok here
-%! b];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-5.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-6.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-7.m
 %!test
 %! x = [1;2];
-%! a = 1;
-%! b = 2;
 %! y = [a... # comments here ok
 %! ;\
 %! 
 %! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-8.m
-%!test
-%! x = [1;2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! ;\
-%! 
-%! b];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-9.m
-%!test
-%! x = [1;2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! ;\
-%! 
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-10.m
-%!assert(1 + ...
+%!assert (1 + ...
 %! 2 - \# comments here ok
 %! 3 / ... # comments here ok
 %! -1,6);
 
-%% test/octave.test/contin/contin-11.m
 %!function y = f (a,...
 %!                b,  ...
 %!                c,  ...   % comments ok
 %!                x,  # continuation characters not required in parens
 %!                y,  \# but they should work too.
 %!                z)
 %!
 %!  y = 1;
-%!test
-%! assert(f (),1);
+%!endfunction
+%!
+%!assert (f (), 1)
 
-%% test/octave.test/contin/contin-12.m
 %!test
-%!assert(1 == 1
+%!assert (1 == 1
 %! && 2 == 2
 %! || 3 == 5);
 
-%% test/octave.test/contin/contin-13.m
 %!test
 %! x = [1, ...
 %! 
 %! ...
 %! 
 %! 2];
 %! y = [1;2];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-14.m
 %!test
-%! x = [1, ...
-%! 
-%! ...
-%! 
-%! 2];
-%! y = [1;2];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-15.m
-%!test
-%! x = [1,...
+%! x = [1 ,...
 %! 2];
 %! y = [1,2];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-16.m
+%% test/oc tave.test/contin/contin-16.m
 %!test
 %! x = [ 1 , ...
 %! 2];
 %! y = [1,2];
-%! assert(all (y == x));
+%! assert  (y, x);
 
diff --git a/test/test_logical-wfi-t.m b/test/test_logical-wfi-t.m
deleted file mode 100644
--- a/test/test_logical-wfi-t.m
+++ /dev/null
@@ -1,239 +0,0 @@
-## Copyright (C) 2006-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% test/octave.test/logical-wfi-t/s-1.m
-%!test
-%! a = [];
-%! fail("a(0);");
-
-%% test/octave.test/logical-wfi-t/s-2.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-t/s-3.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-t/s-4.m
-%!test
-%!shared a
-%! a = 2;
-%!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-
-%% test/octave.test/logical-wfi-t/v-1.m
-%!test
-%! a = [9,8,7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
-
-%% test/octave.test/logical-wfi-t/v-2.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-
-%% test/octave.test/logical-wfi-t/v-3.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-
-%% test/octave.test/logical-wfi-t/v-4.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-t/m-1.m
-%!test
-%! a = [9,8;7,6];
-%! isempty (a(logical ([0,0,0,0])));
-
-%% test/octave.test/logical-wfi-t/m-2.m
-%!test
-%! a = [9,8;7,6];
-%! all (a(logical ([1,1,1,1])) == [9,7,8,6]);
-
-%% test/octave.test/logical-wfi-t/m-3.m
-%!test
-%! a = [9,8;7,6];
-%! all (a(logical ([0,1,1,0])) == [7,8]);
-
-%% test/octave.test/logical-wfi-t/m-4.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-t/m-5.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-6.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-t/m-7.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-8.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-9.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),1) == 7);
-
-%% test/octave.test/logical-wfi-t/m-10.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-11.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-12.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-13.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-t/m-14.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-t/m-15.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-16.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-t/m-17.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-18.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-19.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),1) == 7);
-
-%% test/octave.test/logical-wfi-t/m-20.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-21.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-22.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-23.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-t/m-24.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-25.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-26.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-t/m-27.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical (0:1)) == 8);
-
-%% test/octave.test/logical-wfi-t/m-28.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical ([0,1])) == 8);
-
-%% test/octave.test/logical-wfi-t/m-29.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(1,logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-t/m-30.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-31.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-t/m-32.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-33.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-t/m-34.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-t/m-35.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),1) == [9;7]));
-
-%% test/octave.test/logical-wfi-t/m-36.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-
diff --git a/test/test_logical-wfi-f.m b/test/test_logical_index.m
rename from test/test_logical-wfi-f.m
rename to test/test_logical_index.m
--- a/test/test_logical-wfi-f.m
+++ b/test/test_logical_index.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,229 +11,63 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/logical-wfi-f/s-1.m
 %!test
 %! a = [];
-%! fail("a(0);");
-
-%% test/octave.test/logical-wfi-f/s-2.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-f/s-3.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-f/s-4.m
-%!test
-%!shared a
-%!  a = 2;
-%!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-
-%% test/octave.test/logical-wfi-f/v-1.m
-%!test
-%! a = [9,8,7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
+%! fail ("a(0);");
 
-%% test/octave.test/logical-wfi-f/v-2.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-
-%% test/octave.test/logical-wfi-f/v-3.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-
-%% test/octave.test/logical-wfi-f/v-4.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-f/m-1.m
-%!test
-%! a = [9,8;7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
-
-%% test/octave.test/logical-wfi-f/m-2.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,7,8,6]));
-
-%% test/octave.test/logical-wfi-f/m-3.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [7,8]));
+%!shared a
+%! a = 2;
+%!assert (a(1), 2);
+%!error id=Octave:index-out-of-bounds a(logical ([1,1]))
 
-%% test/octave.test/logical-wfi-f/m-4.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-f/m-5.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-6.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-f/m-7.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-8.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-9.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),1) == 7);
-
-%% test/octave.test/logical-wfi-f/m-10.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-11.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-12.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-13.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-f/m-14.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical (0:1)) == 6);
+%!shared a
+%! a = [9,8,7,6];
+%!assert (isempty (a(logical ([0,0,0,0]))))
+%!assert (a(logical ([1,1,1,1])), [9,8,7,6])
+%!assert (a(logical ([0,1,1,0])), [8,7])
+%!assert (a(logical ([1,1])), [9,8])
 
-%% test/octave.test/logical-wfi-f/m-15.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-16.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-f/m-17.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-18.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-19.m
-%!test
+%!shared a
 %! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),1) == 7);
-
-%% test/octave.test/logical-wfi-f/m-20.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-21.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-22.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-23.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-f/m-24.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-f/m-25.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical ([0,1])) == [8;6]));
+%!assert (isempty (a(logical ([0,0,0,0]))))
+%!assert (a(logical ([1,1,1,1])), [9,7,8,6])
+%!assert (a(logical ([0,1,1,0])), [7,8])
+%!assert (a(logical (0:1),logical (0:1)), 6)
+%!assert (a(logical (0:1),2:-1:1), [6,7])
+%!assert (a(logical (0:1),logical ([0,1])), 6)
+%!assert (a(logical (0:1),[2,1]), [6,7])
+%!assert (a(logical (0:1),:), [7,6])
+%!assert (a(logical (0:1),1), 7)
+%!assert (a(logical (0:1),logical ([1,1])), [7,6])
+%!assert (a(2:-1:1,logical (0:1)), [6;8])
+%!assert (a(2:-1:1,logical ([0,1])), [6;8])
+%!assert (a(2:-1:1,logical ([1,1])), [7,6;9,8])
+%!assert (a(logical ([0,1]),logical (0:1)), 6)
+%!assert (a(logical ([0,1]),2:-1:1), [6,7])
+%!assert (a(logical ([0,1]),logical ([0,1])), 6)
+%!assert (a(logical ([0,1]),[2,1]), [6,7])
+%!assert (a(logical ([0,1]),:), [7,6])
+%!assert (a(logical ([0,1]),1), 7)
+%!assert (a(logical ([0,1]),logical ([1,1])), [7,6])
+%!assert (a([2,1],logical (0:1)), [6;8])
+%!assert (a([2,1],logical ([0,1])), [6;8])
+%!assert (a([2,1],logical ([1,1])), [7,6;9,8])
+%!assert (a(:,logical (0:1)), [8;6])
+%!assert (a(:,logical ([0,1])), [8;6])
+%!assert (a(:,logical ([1,1])), [9,8;7,6])
+%!assert (a(1,logical (0:1)), 8)
+%!assert (a(1,logical ([0,1])), 8)
+%!assert (a(1,logical ([1,1])), [9,8])
+%!assert (a(logical ([1,1]),logical (0:1)), [8;6])
+%!assert (a(logical ([1,1]),2:-1:1), [8,9;6,7])
+%!assert (a(logical ([1,1]),logical ([0,1])), [8;6])
+%!assert (a(logical ([1,1]),[2,1]), [8,9;6,7])
+%!assert (a(logical ([1,1]),:), [9,8;7,6])
+%!assert (a(logical ([1,1]),1), [9;7])
+%!assert (a(logical ([1,1]),logical ([1,1])), [9,8;7,6])
 
-%% test/octave.test/logical-wfi-f/m-26.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-f/m-27.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical (0:1)) == 8);
-
-%% test/octave.test/logical-wfi-f/m-28.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical ([0,1])) == 8);
-
-%% test/octave.test/logical-wfi-f/m-29.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(1,logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-f/m-30.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-f/m-31.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-f/m-32.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-f/m-33.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-f/m-34.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-f/m-35.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),1) == [9;7]));
-
-%% test/octave.test/logical-wfi-f/m-36.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-
diff --git a/test/test_null_assign.m b/test/test_null_assign.m
--- a/test/test_null_assign.m
+++ b/test/test_null_assign.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -28,36 +28,36 @@
 %! a = ones (3); a(1:3,:) = []; assert (size (a), [0, 3])
 %!test
 %! a = ones (3); a(:,1:3) = []; assert (size (a), [3, 0])
 %!test
 %! a = ones (3); fail ("a(1:2,1:2) = []", ".*");
 %!test
 %! a = ones (3); fail ("a(1:3,1:3) = []", ".*");
 
-% null strings should delete. [,] and [;] should delete.
+## null strings should delete. [,] and [;] should delete.
 %!test
 %! a = ones (3); a(1:2,:) = [,]; assert (size (a), [1,3])
 %!test
 %! a = ones (3); a(1:2,:) = [;]; assert (size (a), [1,3])
 %!test
 %! a = ones (3); a(1:2,:) = ''; assert (size (a), [1,3])
 %!test
 %! a = ones (3); a(1:2,:) = ""; assert (size (a), [1,3])
 
-% null matrix stored anywhere should lose its special status
+## null matrix stored anywhere should lose its special status
 %!test
 %! a = ones (3); b = []; fail ("a(:,1:3) = b", ".")
 %!test
 %! a = ones (3); b{1} = []; fail ("a(:,1:3) = b{1}", ".")
 %!test
 %! a = ones (3); b.x = []; fail ("a(:,1:3) = b.x", ".")
 
-% filtering a null matrix through a function should not delete
+## filtering a null matrix through a function should not delete
 %!test
 %! a = ones (3); fail ("a(:,1:3) = double ([])")
 
-% subsasgn should work the same way
+## subsasgn should work the same way
 %!test
 %! a = ones (3); a = subsasgn (a, substruct ('()', {':',1:2}), []); assert (size (a), [3,1])
 %!test
 %! a = ones (3); b = []; fail ("subsasgn (a, substruct ('()', {':',1:2}), b)", ".")
 
diff --git a/test/test_parser.m b/test/test_parser.m
--- a/test/test_parser.m
+++ b/test/test_parser.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,18 +11,18 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## Tests for parser problems belong in this file.  We need many more
-## tests here!
+## Tests for parser problems belong in this file.
+## We need many more tests here!
 
 %!assert ({1 2 {3 4}}, {1,2,{3,4}})
 %!assert ({1, 2 {3 4}}, {1,2,{3,4}})
 %!assert ({1 2, {3 4}}, {1,2,{3,4}})
 %!assert ({1 2 {3, 4}}, {1,2,{3,4}})
 %!assert ({1, 2, {3 4}}, {1,2,{3,4}})
 %!assert ({1 2,{3 4}}, {1,2,{3,4}})
 %!assert ({1 2,{3,4}}, {1,2,{3,4}})
@@ -242,15 +242,18 @@
 %!  assert (0 || 1 || ++a, true)
 %!  assert (a, 1)
 ## Level 1 (assignment)
 %!test
 %! a = 2; b = 5; c = 7;
 %! assert (a += b *= c += 1, 42)
 %! assert (b == 40 && c == 8)
 
+## Test creation of anonymous functions
+
 %!test
 %! af_in_cell = {@(x) [1 2]};
 %! assert (af_in_cell{1}(), [1, 2]);
 
 %!test
 %! R = @(rot) [cos(rot) -sin(rot); sin(rot) cos(rot)];
 %! assert (R(pi/2), [cos(pi/2), -sin(pi/2); sin(pi/2),cos(pi/2)]);
+
diff --git a/test/test_prefer.m b/test/test_prefer.m
--- a/test/test_prefer.m
+++ b/test/test_prefer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,123 +14,102 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/prefer/prefer-1.m
 %!test
 %! m = [3 2];
-%! assert(all (m == (3:-1:2)));
+%! assert (all (m == (3:-1:2)));
 
 %% test/octave.test/prefer/prefer-2.m
 %!test
 %! m = [3,
 %! 2];
-%! assert(all (m == (3:-1:2)'));
+%! assert (all (m == (3:-1:2)'));
 
 %% test/octave.test/prefer/prefer-3.m
 %!test
 %! a = 2;
-%! assert([a - 1],1);
+%! assert ([a - 1], 1);
 
 %% test/octave.test/prefer/prefer-4.m
 %!test
 %! m = [3,2];
-%! fail("[m ']");
+%! fail ("[m ']");
 
 %% test/octave.test/prefer/prefer-5.m
-%!assert(all ([3 2] == (3:-1:2)));
+%!assert (all ([3 2] == (3:-1:2)));
 
 %% test/octave.test/prefer/prefer-6.m
-%!assert(all ([3, 2] == (3:-1:2)));
+%!assert (all ([3, 2] == (3:-1:2)));
 
 %% test/octave.test/prefer/prefer-7.m
 %!test
 %! m = [3,2];
-%! assert(all ([m (1)] == (3:-1:1)));
+%! assert (all ([m (1)] == (3:-1:1)));
 
 %% test/octave.test/prefer/prefer-8.m
 %!test
 %! m = [3,2];
-%! assert([m(1)],3);
-
-%% test/octave.test/prefer/prefer-9.m
-%!test
-%! m = [3,2];
-%! assert(all ([m (1)] == (3:-1:1)));
+%! assert ([m(1)],3);
 
 %% test/octave.test/prefer/prefer-10.m
 %!test
 %! a = 2;
-%! assert([a- 1],1);
+%! assert ([a- 1], 1);
 
 %% test/octave.test/prefer/prefer-11.m
 %!test
 %! a = 1;
-%! assert(all ([a -1] == (1:-2:-1)));
+%! assert (all ([a -1] == (1:-2:-1)));
 
 %% test/octave.test/prefer/prefer-12.m
 %!test
 %! wsn = warning ("query", "Octave:str-to-num");
 %! warning ("off", "Octave:str-to-num");
-%! assert("d" + 0,100);
+%! assert ("d" + 0, 100);
 %! warning (wsn.state, "Octave:str-to-num");
 
 %% test/octave.test/prefer/prefer-13.m
 %!test
 %! wsn = warning ("query", "Octave:str-to-num");
 %! warning ("on", "Octave:str-to-num");
-%! fail("'d' + 0","warning");
+%! fail ("'d' + 0", "warning");
 %! warning (wsn.state, "Octave:str-to-num");
 
 %% test/octave.test/prefer/prefer-14.m
 %!test
 %! wir = warning ("query", "Ocave:imag-to-real");
 %! warning ("off", "Ocave:imag-to-real");
-%! assert(eye (1+i),1);
+%! assert (eye (1+i), 1);
 %! warning (wir.state, "Ocave:imag-to-real");
 
 %% test/octave.test/prefer/prefer-15.m
 %!test
 %! wir = warning ("query", "Ocave:imag-to-real");
 %! warning ("on", "Ocave:imag-to-real");
-%! fail("eye (1+i)","warning");
+%! fail ("eye (1+i)", "warning");
 %! warning (wir.state, "Ocave:imag-to-real");
 
 %% test/octave.test/prefer/prefer-17.m
 %!test
 %! wrre = warning ("query", "Octave:resize-on-range-error");
 %! warning ("off", "Octave:resize-on-range-error");
 %! clear a; 
 %! a(2) = 1; a(3) = 2; 
-%! assert(all (a == [0,1,2]));
+%! assert (all (a == [0,1,2]));
 %! warning (wrre.state, "Octave:resize-on-range-error");
 
 %% test/octave.test/prefer/prefer-18.m
 %!test
 %! clear a; 
 %! a(1) = 1; a(2) = 2;
-%! assert(all (a == [1,2]));
-
-%% FIXME How the hell do I test this one in test/assert 
-%% test/octave.test/prefer/prefer-19.m
-%!#test
-%! pid = print_answer_id_name ();
-%! print_answer_id_name (0);
-%! a = 1
-%! print_answer_id_name (pid);
-
-%% FIXME How the hell do I test this one in test/assert 
-%% test/octave.test/prefer/prefer-20.m
-%!#test
-%! pid = print_answer_id_name ();
-%! print_answer_id_name (1);
-%! a = 1
-%! print_answer_id_name (pid);
+%! assert (all (a == [1,2]));
 
 %% test/octave.test/prefer/prefer-21.m
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (0);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[]")));
@@ -142,105 +121,107 @@
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (1);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[](0x0)")));
 %! print_empty_dimensions (ped);
 
 %% test/octave.test/prefer/prefer-23.m
-%!assert(all (size (inv ([])) == [0, 0]));
+%!assert (all (size (inv ([])) == [0, 0]));
 
 %% test/octave.test/prefer/prefer-24.m
-%!assert(all (svd ([]) == zeros (0, 1)));
+%!assert (all (svd ([]) == zeros (0, 1)));
 
 %% test/octave.test/prefer/prefer-27.m
 %!test
 %! sp = save_precision ();
 %! save_precision (1);
 %! x = pi;
-%! nm = tmpnam();
-%! save("-text",nm,"x");
+%! nm = tmpnam ();
+%! save("-text", nm, "x");
 %! clear x;
-%! load(nm);
-%! unlink(nm);
-%! assert(x,3);
+%! load (nm);
+%! unlink (nm);
+%! assert (x,3);
 %! save_precision (sp);
 
 %% test/octave.test/prefer/prefer-28.m
 %!test
 %! sp = save_precision ();
 %! save_precision (5);
 %! x = pi;
-%! nm = tmpnam();
-%! save("-text",nm,"x");
+%! nm = tmpnam ();
+%! save("-text", nm, "x");
 %! clear x;
-%! load(nm);
-%! unlink(nm);
-%! assert(x,3.1416);
+%! load (nm);
+%! unlink (nm);
+%! assert (x, 3.1416);
 %! save_precision (sp);
 
-%% FIXME Same problem as above!!!
+%% FIXME: How to capture standard output for comparison? 
 %% test/octave.test/prefer/prefer-29.m
 %!function f ()
 %! 1
+%!endfunction
 %!#test
 %! sf = silent_functions ();
 %! silent_functions (0);
 %! f
-%! assert(??);
+%! assert (??);
 %! silent_functions (sf);
 
 %% FIXME Same problem as above!!!
 %% test/octave.test/prefer/prefer-30.m
 %!function f ()
 %! 1
+%!endfunction
 %!#test
 %! sf = silent_functions ();
 %! silent_functions (1);
 %! f
-%! assert(??);
+%! assert (??);
 %! silent_functions (sf);
 
 %% test/octave.test/prefer/prefer-32.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("on", "Octave:neg-dim-as-zero");
-%! fail("eye (-1) == []","warning");
+%! fail ("eye (-1) == []", "warning");
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
 %% test/octave.test/prefer/prefer-33.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("off", "Octave:neg-dim-as-zero");
-%! assert(all (size (eye (-1)) == [0, 0]));
+%! assert (all (size (eye (-1)) == [0, 0]));
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
 %% test/octave.test/prefer/prefer-34.m
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("off", "Octave:assign-as-truth-value");
 %! if (x = 1) 1; endif
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
 %% test/octave.test/prefer/prefer-35.m
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("on", "Octave:assign-as-truth-value");
-%! fail("if (x = 1) 1; endif","warning");
+%! fail ("if (x = 1) 1; endif", "warning");
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
 %% test/octave.test/prefer/prefer-38.m
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("off", "Octave:divide-by-zero");
-%! assert(isinf (1/0));
+%! assert (isinf (1/0));
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
 %% test/octave.test/prefer/prefer-39.m
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("on", "Octave:divide-by-zero");
 %! a = 1;
 %! b = 0;
-%! fail("isinf (a/b);","warning")
+%! fail ("isinf (a/b);", "warning")
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
diff --git a/test/test_range.m b/test/test_range.m
--- a/test/test_range.m
+++ b/test/test_range.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,62 +13,62 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Test values of range
 
-%!assert(full(1:9), [ 1 2 3 4 5 6 7 8 9 ])
-%!assert(full(1:0.4:3), [ 1.0 1.4 1.8 2.2 2.6 3.0 ])
-%!assert(full(9:1), zeros(1,0))
-%!assert(full(9:-1:1), [ 9 8 7 6 5 4 3 2 1 ])
-%!assert(full(1:-1:9), zeros(1,0))
-
+%!assert (full (1:9), [ 1 2 3 4 5 6 7 8 9 ])
+%!assert (full (1:0.4:3), [ 1.0 1.4 1.8 2.2 2.6 3.0 ])
+%!assert (full (9:1), zeros (1,0))
+%!assert (full (9:-1:1), [ 9 8 7 6 5 4 3 2 1 ])
+%!assert (full (1:-1:9), zeros (1,0))
+%!assert (full (1:1:1), 1)
+%!assert (full (i:2i:10i), zeros (1,0))
 
 ## Test mixing integer range with other types
 
 %!shared expect, r, z
 %! expect = [ 1 2 3 4 5 6 7 8 9
 %!            0 0 0 0 0 0 0 0 0 ];
-%! z = zeros(1,9);
+%! z = zeros (1,9);
 %! r = 1:9;
 
-%!assert([ r ; z                  ], expect)
-%!assert([ r ; single(z)          ], single (expect))
-%!assert([ r ; logical(z)         ], expect)
-%!assert([ r ; sparse(z)          ], sparse (expect))
-%!assert([ r ; sparse(logical(z)) ], sparse (expect))
+%!assert ([ r ; z                  ], expect)
+%!assert ([ r ; single(z)          ], single (expect))
+%!assert ([ r ; logical(z)         ], expect)
+%!assert ([ r ; sparse(z)          ], sparse (expect))
+%!assert ([ r ; sparse(logical(z)) ], sparse (expect))
 
-%!assert([ r ; int8(z)            ], int8(expect))
-%!assert([ r ; int16(z)           ], int16(expect))
-%!assert([ r ; int32(z)           ], int32(expect))
-%!assert([ r ; int64(z)           ], int64(expect))
-%!assert([ r ; uint8(z)           ], uint8(expect))
-%!assert([ r ; uint16(z)          ], uint16(expect))
-%!assert([ r ; uint32(z)          ], uint32(expect))
-%!assert([ r ; uint64(z)          ], uint64(expect))
+%!assert ([ r ; int8(z)            ], int8(expect))
+%!assert ([ r ; int16(z)           ], int16(expect))
+%!assert ([ r ; int32(z)           ], int32(expect))
+%!assert ([ r ; int64(z)           ], int64(expect))
+%!assert ([ r ; uint8(z)           ], uint8(expect))
+%!assert ([ r ; uint16(z)          ], uint16(expect))
+%!assert ([ r ; uint32(z)          ], uint32(expect))
+%!assert ([ r ; uint64(z)          ], uint64(expect))
 
-
-## Test mixing non integer range with other types
+## Test mixing non-integer range with other types
 
 %!shared expect, r, z
 %! expect = [ 1.0 1.4 1.8 2.2 2.6 3.0
 %!            0   0   0   0   0   0   ];
-%! z = zeros(1,6);
+%! z = zeros (1,6);
 %! r = 1:0.4:3;
 
-%!assert([ r ; z                  ], expect)
-%!assert([ r ; single(z)          ], single (expect))
-%!assert([ r ; logical(z)         ], expect)
-%!assert([ r ; sparse(z)          ], sparse (expect))
-%!assert([ r ; sparse(logical(z)) ], sparse (expect))
+%!assert ([ r ; z                  ], expect)
+%!assert ([ r ; single(z)          ], single (expect))
+%!assert ([ r ; logical(z)         ], expect)
+%!assert ([ r ; sparse(z)          ], sparse (expect))
+%!assert ([ r ; sparse(logical(z)) ], sparse (expect))
 
-%!assert([ r ; int8(z)            ], int8(expect))
-%!assert([ r ; int16(z)           ], int16(expect))
-%!assert([ r ; int32(z)           ], int32(expect))
-%!assert([ r ; int64(z)           ], int64(expect))
-%!assert([ r ; uint8(z)           ], uint8(expect))
-%!assert([ r ; uint16(z)          ], uint16(expect))
-%!assert([ r ; uint32(z)          ], uint32(expect))
-%!assert([ r ; uint64(z)          ], uint64(expect))
+%!assert ([ r ; int8(z)            ], int8(expect))
+%!assert ([ r ; int16(z)           ], int16(expect))
+%!assert ([ r ; int32(z)           ], int32(expect))
+%!assert ([ r ; int64(z)           ], int64(expect))
+%!assert ([ r ; uint8(z)           ], uint8(expect))
+%!assert ([ r ; uint16(z)          ], uint16(expect))
+%!assert ([ r ; uint32(z)          ], uint32(expect))
+%!assert ([ r ; uint64(z)          ], uint64(expect))
 
diff --git a/test/test_recursion.m b/test/test_recursion.m
--- a/test/test_recursion.m
+++ b/test/test_recursion.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,22 +19,25 @@
 %% test/octave.test/recursion/recursion-1.m
 %!function y = f (x)
 %!  if (x == 1)
 %!    y = x;
 %!    return;
 %!  else
 %!    y = x * f (x-1);
 %!  endif
-%!test
-%! assert(f (5),120);
+%!endfunction
+%!
+%!assert(f (5), 120);
 
 %% test/octave.test/recursion/recursion-2.m
 %!function y = f (x)
 %!  if (x == 1)
 %!    y = x;
 %!    return;
 %!  else
 %!    y = f (x-1) * x;
 %!  endif
-%!test
-%! assert(f (5),120);
+%!endfunction
+%!
+%!assert(f (5), 120);
 
+%%FIXME: Need test for maximum recursion depth
diff --git a/test/test_return.m b/test/test_return.m
--- a/test/test_return.m
+++ b/test/test_return.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,16 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/return/return-1.m
 %!function y = f ()
 %!  y = 1;
-%!  return
+%!  return;
 %!  y = 2;
-%!assert(f(),1)
+%!endfunction
+%!
+%!assert(f(), 1)
 
 %% test/octave.test/return/return-2.m
 %!test
 %! return;
 
diff --git a/test/test_slice.m b/test/test_slice.m
--- a/test/test_slice.m
+++ b/test/test_slice.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,170 +11,170 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%!function x = set_slice(size, dim, slice)
-%!  x = ones(size);
+%!function x = set_slice (size, dim, slice)
+%!  x = ones (size);
 %!  switch dim
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    case 31
 %!      x(slice, :, :) = 2;
 %!    case 32
 %!      x(:, slice, :) = 2;
 %!    case 33
 %!      x(:, :, slice) = 2;
 %!    otherwise
 %!      error("invalid dim, '%d'", dim);
 %!  endswitch
-%! endfunction
+%!endfunction
 
 ## size = [2 0]
-%!assert(set_slice([2 0], 11, []), zeros([2 0]));
-%!error id=Octave:invalid-resize set_slice([2 0], 11, 1)
-%!error id=Octave:invalid-resize set_slice([2 0], 11, 2)
-%!error id=Octave:invalid-resize set_slice([2 0], 11, 3)
-%!assert(set_slice([2 0], 21, []), zeros([2 0]));
-%!assert(set_slice([2 0], 21, 1), zeros([2 0]));
-%!assert(set_slice([2 0], 21, 2), zeros([2 0]));
-%!assert(set_slice([2 0], 21, 3), zeros([3 0]));
-%!assert(set_slice([2 0], 22, []), zeros([2 0]));
-%!assert(set_slice([2 0], 22, 1), [2 2]');
-%!assert(set_slice([2 0], 22, 2), [0 0;2 2]');
-%!assert(set_slice([2 0], 22, 3), [0 0;0 0;2 2]');
-%!assert(set_slice([2 0], 31, []), zeros([2 0]));
-%!assert(set_slice([2 0], 31, 1), zeros([2 0]));
-%!assert(set_slice([2 0], 31, 2), zeros([2 0]));
-%!assert(set_slice([2 0], 31, 3), zeros([3 0]));
-%!assert(set_slice([2 0], 32, []), zeros([2 0]));
-%!assert(set_slice([2 0], 32, 1), [2 2]');
-%!assert(set_slice([2 0], 32, 2), [0 0;2 2]');
-%!assert(set_slice([2 0], 32, 3), [0 0;0 0;2 2]');
-%!assert(set_slice([2 0], 33, []), zeros([2 0]));
-%!assert(set_slice([2 0], 33, 1), zeros([2 0]));
-%!assert(set_slice([2 0], 33, 2), zeros([2 0 2]));
-%!assert(set_slice([2 0], 33, 3), zeros([2 0 3]));
+%!assert (set_slice ([2 0], 11, []), zeros ([2 0]))
+%!error id=Octave:invalid-resize set_slice ([2 0], 11, 1)
+%!error id=Octave:invalid-resize set_slice ([2 0], 11, 2)
+%!error id=Octave:invalid-resize set_slice ([2 0], 11, 3)
+%!assert (set_slice ([2 0], 21, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 21, 1), zeros ([2 0]))
+%!assert (set_slice ([2 0], 21, 2), zeros ([2 0]))
+%!assert (set_slice ([2 0], 21, 3), zeros ([3 0]))
+%!assert (set_slice ([2 0], 22, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 22, 1), [2 2]')
+%!assert (set_slice ([2 0], 22, 2), [0 0;2 2]')
+%!assert (set_slice ([2 0], 22, 3), [0 0;0 0;2 2]')
+%!assert (set_slice ([2 0], 31, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 31, 1), zeros ([2 0]))
+%!assert (set_slice ([2 0], 31, 2), zeros ([2 0]))
+%!assert (set_slice ([2 0], 31, 3), zeros ([3 0]))
+%!assert (set_slice ([2 0], 32, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 32, 1), [2 2]')
+%!assert (set_slice ([2 0], 32, 2), [0 0;2 2]')
+%!assert (set_slice ([2 0], 32, 3), [0 0;0 0;2 2]')
+%!assert (set_slice ([2 0], 33, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 33, 1), zeros ([2 0]))
+%!assert (set_slice ([2 0], 33, 2), zeros ([2 0 2]))
+%!assert (set_slice ([2 0], 33, 3), zeros ([2 0 3]))
 
 ## size = [0 2]
-%!assert(set_slice([0 2], 11, []), zeros([0 2]));
-%!assert(set_slice([0 2], 11, 1), 2);
-%!assert(set_slice([0 2], 11, 2), [0, 2]);
-%!assert(set_slice([0 2], 11, 3), [0, 0, 2]);
-%!assert(set_slice([0 2], 21, []), zeros([0 2]));
-%!assert(set_slice([0 2], 21, 1), [2 2]);
-%!assert(set_slice([0 2], 21, 2), [0 0;2 2]);
-%!assert(set_slice([0 2], 21, 3), [0 0;0 0;2 2]);
-%!assert(set_slice([0 2], 22, []), zeros([0 2]));
-%!assert(set_slice([0 2], 22, 1), zeros([0 2]));
-%!assert(set_slice([0 2], 22, 2), zeros([0 2]));
-%!assert(set_slice([0 2], 22, 3), zeros([0 3]));
-%!assert(set_slice([0 2], 31, []), zeros([0 2]));
-%!assert(set_slice([0 2], 31, 1), [2 2]);
-%!assert(set_slice([0 2], 31, 2), [0 0;2 2]);
-%!assert(set_slice([0 2], 31, 3), [0 0;0 0;2 2]);
-%!assert(set_slice([0 2], 32, []), zeros([0 2]));
-%!assert(set_slice([0 2], 32, 1), zeros([0 2]));
-%!assert(set_slice([0 2], 32, 2), zeros([0 2]));
-%!assert(set_slice([0 2], 32, 3), zeros([0 3]));
-%!assert(set_slice([0 2], 33, []), zeros([0 2]));
-%!assert(set_slice([0 2], 33, 1), zeros([0 2]));
-%!assert(set_slice([0 2], 33, 2), zeros([0 2 2]));
-%!assert(set_slice([0 2], 33, 3), zeros([0 2 3]));
+%!assert (set_slice ([0 2], 11, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 11, 1), 2)
+%!assert (set_slice ([0 2], 11, 2), [0, 2])
+%!assert (set_slice ([0 2], 11, 3), [0, 0, 2])
+%!assert (set_slice ([0 2], 21, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 21, 1), [2 2])
+%!assert (set_slice ([0 2], 21, 2), [0 0;2 2])
+%!assert (set_slice ([0 2], 21, 3), [0 0;0 0;2 2])
+%!assert (set_slice ([0 2], 22, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 22, 1), zeros ([0 2]))
+%!assert (set_slice ([0 2], 22, 2), zeros ([0 2]))
+%!assert (set_slice ([0 2], 22, 3), zeros ([0 3]))
+%!assert (set_slice ([0 2], 31, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 31, 1), [2 2])
+%!assert (set_slice ([0 2], 31, 2), [0 0;2 2])
+%!assert (set_slice ([0 2], 31, 3), [0 0;0 0;2 2])
+%!assert (set_slice ([0 2], 32, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 32, 1), zeros ([0 2]))
+%!assert (set_slice ([0 2], 32, 2), zeros ([0 2]))
+%!assert (set_slice ([0 2], 32, 3), zeros ([0 3]))
+%!assert (set_slice ([0 2], 33, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 33, 1), zeros ([0 2]))
+%!assert (set_slice ([0 2], 33, 2), zeros ([0 2 2]))
+%!assert (set_slice ([0 2], 33, 3), zeros ([0 2 3]))
 
 ## size = [2 1]
-%!assert(set_slice([2 1], 11, []), ones([2 1]));
-%!assert(set_slice([2 1], 11, 1), [2 1]');
-%!assert(set_slice([2 1], 11, 2), [1 2]');
-%!assert(set_slice([2 1], 11, 3), [1 1 2]');
-%!assert(set_slice([2 1], 11, 4), [1 1 0 2]');
-%!assert(set_slice([2 1], 21, []), ones([2 1]));
-%!assert(set_slice([2 1], 21, 1), [2 1]');
-%!assert(set_slice([2 1], 21, 2), [1 2]');
-%!assert(set_slice([2 1], 21, 3), [1 1 2]');
-%!assert(set_slice([2 1], 21, 4), [1 1 0 2]');
-%!assert(set_slice([2 1], 22, []), ones([2 1]));
-%!assert(set_slice([2 1], 22, 1), [2 2]');
-%!assert(set_slice([2 1], 22, 2), [1 1;2 2]');
-%!assert(set_slice([2 1], 22, 3), [1 1;0 0;2 2]');
-%!assert(set_slice([2 1], 31, []), ones([2 1]));
-%!assert(set_slice([2 1], 31, 1), [2 1]');
-%!assert(set_slice([2 1], 31, 2), [1 2]');
-%!assert(set_slice([2 1], 31, 3), [1 1 2]');
-%!assert(set_slice([2 1], 31, 4), [1 1 0 2]');
-%!assert(set_slice([2 1], 32, []), ones([2 1]));
-%!assert(set_slice([2 1], 32, 1), [2 2]');
-%!assert(set_slice([2 1], 32, 2), [1 1;2 2]');
-%!assert(set_slice([2 1], 32, 3), [1 1;0 0;2 2]');
-%!assert(set_slice([2 1], 33, []), ones([2 1]));
-%!assert(set_slice([2 1], 33, 1), [2 2]');
-%!assert(set_slice([2 1], 33, 2), reshape([1 1 2 2],[2 1 2]));
-%!assert(set_slice([2 1], 33, 3), reshape([1 1 0 0 2 2],[2 1 3]));
+%!assert (set_slice ([2 1], 11, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 11, 1), [2 1]')
+%!assert (set_slice ([2 1], 11, 2), [1 2]')
+%!assert (set_slice ([2 1], 11, 3), [1 1 2]')
+%!assert (set_slice ([2 1], 11, 4), [1 1 0 2]')
+%!assert (set_slice ([2 1], 21, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 21, 1), [2 1]')
+%!assert (set_slice ([2 1], 21, 2), [1 2]')
+%!assert (set_slice ([2 1], 21, 3), [1 1 2]')
+%!assert (set_slice ([2 1], 21, 4), [1 1 0 2]')
+%!assert (set_slice ([2 1], 22, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 22, 1), [2 2]')
+%!assert (set_slice ([2 1], 22, 2), [1 1;2 2]')
+%!assert (set_slice ([2 1], 22, 3), [1 1;0 0;2 2]')
+%!assert (set_slice ([2 1], 31, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 31, 1), [2 1]')
+%!assert (set_slice ([2 1], 31, 2), [1 2]')
+%!assert (set_slice ([2 1], 31, 3), [1 1 2]')
+%!assert (set_slice ([2 1], 31, 4), [1 1 0 2]')
+%!assert (set_slice ([2 1], 32, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 32, 1), [2 2]')
+%!assert (set_slice ([2 1], 32, 2), [1 1;2 2]')
+%!assert (set_slice ([2 1], 32, 3), [1 1;0 0;2 2]')
+%!assert (set_slice ([2 1], 33, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 33, 1), [2 2]')
+%!assert (set_slice ([2 1], 33, 2), reshape ([1 1 2 2],[2 1 2]))
+%!assert (set_slice ([2 1], 33, 3), reshape ([1 1 0 0 2 2],[2 1 3]))
 
 ## size = [1 2]
-%!assert(set_slice([1 2], 11, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 11, 1), [2 1]);
-%!assert(set_slice([1 2], 11, 2), [1 2]);
-%!assert(set_slice([1 2], 11, 3), [1 1 2]);
-%!assert(set_slice([1 2], 11, 4), [1 1 0 2]);
-%!assert(set_slice([1 2], 21, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 21, 1), [2 2]);
-%!assert(set_slice([1 2], 21, 2), [1 1;2 2]);
-%!assert(set_slice([1 2], 21, 3), [1 1;0 0;2 2]);
-%!assert(set_slice([1 2], 22, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 22, 1), [2 1]);
-%!assert(set_slice([1 2], 22, 2), [1 2]);
-%!assert(set_slice([1 2], 22, 3), [1 1 2]);
-%!assert(set_slice([1 2], 22, 4), [1 1 0 2]);
-%!assert(set_slice([1 2], 31, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 31, 1), [2 2]);
-%!assert(set_slice([1 2], 31, 2), [1 1;2 2]);
-%!assert(set_slice([1 2], 31, 3), [1 1;0 0;2 2]);
-%!assert(set_slice([1 2], 32, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 32, 1), [2 1]);
-%!assert(set_slice([1 2], 32, 2), [1 2]);
-%!assert(set_slice([1 2], 32, 3), [1 1 2]);
-%!assert(set_slice([1 2], 32, 4), [1 1 0 2]);
-%!assert(set_slice([1 2], 33, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 33, 1), [2 2]);
-%!assert(set_slice([1 2], 33, 2), reshape([1 1 2 2],[1 2 2]));
-%!assert(set_slice([1 2], 33, 3), reshape([1 1 0 0 2 2],[1 2 3]));
+%!assert (set_slice ([1 2], 11, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 11, 1), [2 1])
+%!assert (set_slice ([1 2], 11, 2), [1 2])
+%!assert (set_slice ([1 2], 11, 3), [1 1 2])
+%!assert (set_slice ([1 2], 11, 4), [1 1 0 2])
+%!assert (set_slice ([1 2], 21, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 21, 1), [2 2])
+%!assert (set_slice ([1 2], 21, 2), [1 1;2 2])
+%!assert (set_slice ([1 2], 21, 3), [1 1;0 0;2 2])
+%!assert (set_slice ([1 2], 22, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 22, 1), [2 1])
+%!assert (set_slice ([1 2], 22, 2), [1 2])
+%!assert (set_slice ([1 2], 22, 3), [1 1 2])
+%!assert (set_slice ([1 2], 22, 4), [1 1 0 2])
+%!assert (set_slice ([1 2], 31, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 31, 1), [2 2])
+%!assert (set_slice ([1 2], 31, 2), [1 1;2 2])
+%!assert (set_slice ([1 2], 31, 3), [1 1;0 0;2 2])
+%!assert (set_slice ([1 2], 32, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 32, 1), [2 1])
+%!assert (set_slice ([1 2], 32, 2), [1 2])
+%!assert (set_slice ([1 2], 32, 3), [1 1 2])
+%!assert (set_slice ([1 2], 32, 4), [1 1 0 2])
+%!assert (set_slice ([1 2], 33, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 33, 1), [2 2])
+%!assert (set_slice ([1 2], 33, 2), reshape ([1 1 2 2],[1 2 2]))
+%!assert (set_slice ([1 2], 33, 3), reshape ([1 1 0 0 2 2],[1 2 3]))
 
 ## size = [2 2]
-%!assert(set_slice([2 2], 11, []), ones([2 2]));
-%!assert(set_slice([2 2], 11, 1), [2 1;1 1]);
-%!assert(set_slice([2 2], 11, 2), [1 1;2 1]);
-%!assert(set_slice([2 2], 11, 3), [1 2;1 1]);
-%!assert(set_slice([2 2], 11, 4), [1 1;1 2]);
-%!error id=Octave:invalid-resize set_slice([2 2], 11, 5)
-%!error id=Octave:invalid-resize set_slice([2 2], 11, 6)
-%!assert(set_slice([2 2], 21, []), ones([2 2]));
-%!assert(set_slice([2 2], 21, 1), [2 2;1 1]);
-%!assert(set_slice([2 2], 21, 2), [1 1;2 2]);
-%!assert(set_slice([2 2], 21, 3), [1 1;1 1;2 2]);
-%!assert(set_slice([2 2], 21, 4), [1 1;1 1;0 0;2 2]);
-%!assert(set_slice([2 2], 22, []), ones([2 2]));
-%!assert(set_slice([2 2], 22, 1), [2 2;1 1]');
-%!assert(set_slice([2 2], 22, 2), [1 1;2 2]');
-%!assert(set_slice([2 2], 22, 3), [1 1;1 1;2 2]');
-%!assert(set_slice([2 2], 22, 4), [1 1;1 1;0 0;2 2]');
-%!assert(set_slice([2 2], 31, []), ones([2 2]));
-%!assert(set_slice([2 2], 31, 1), [2 2;1 1]);
-%!assert(set_slice([2 2], 31, 2), [1 1;2 2]);
-%!assert(set_slice([2 2], 31, 3), [1 1;1 1;2 2]);
-%!assert(set_slice([2 2], 31, 4), [1 1;1 1;0 0;2 2]);
-%!assert(set_slice([2 2], 32, []), ones([2 2]));
-%!assert(set_slice([2 2], 32, 1), [2 2;1 1]');
-%!assert(set_slice([2 2], 32, 2), [1 1;2 2]');
-%!assert(set_slice([2 2], 32, 3), [1 1;1 1;2 2]');
-%!assert(set_slice([2 2], 32, 4), [1 1;1 1;0 0;2 2]');
-%!assert(set_slice([2 2], 33, []), ones([2 2]));
-%!assert(set_slice([2 2], 33, 1), [2 2;2 2]);
-%!assert(set_slice([2 2], 33, 2), reshape([1 1 1 1 2 2 2 2],[2 2 2]));
-%!assert(set_slice([2 2], 33, 3), reshape([1 1 1 1 0 0 0 0 2 2 2 2],[2 2 3]));
+%!assert (set_slice ([2 2], 11, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 11, 1), [2 1;1 1])
+%!assert (set_slice ([2 2], 11, 2), [1 1;2 1])
+%!assert (set_slice ([2 2], 11, 3), [1 2;1 1])
+%!assert (set_slice ([2 2], 11, 4), [1 1;1 2])
+%!error id=Octave:invalid-resize set_slice ([2 2], 11, 5)
+%!error id=Octave:invalid-resize set_slice ([2 2], 11, 6)
+%!assert (set_slice ([2 2], 21, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 21, 1), [2 2;1 1])
+%!assert (set_slice ([2 2], 21, 2), [1 1;2 2])
+%!assert (set_slice ([2 2], 21, 3), [1 1;1 1;2 2])
+%!assert (set_slice ([2 2], 21, 4), [1 1;1 1;0 0;2 2])
+%!assert (set_slice ([2 2], 22, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 22, 1), [2 2;1 1]')
+%!assert (set_slice ([2 2], 22, 2), [1 1;2 2]')
+%!assert (set_slice ([ 2 2], 22, 3), [1 1;1 1;2 2]')
+%!assert (set_slice ([2 2], 22, 4), [1 1;1 1;0 0;2 2]')
+%!assert (set_slice ([2 2], 31, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 31, 1), [2 2;1 1])
+%!assert (set_slice ([2 2], 31, 2), [1 1;2 2])
+%!assert (set_slice ( [2 2], 31, 3), [1 1;1 1;2 2])
+%!assert (set_slice ([2 2], 31, 4), [1 1;1 1;0 0;2 2])
+%!assert (set_slice ([2 2], 32, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 32, 1), [2 2;1 1]')
+%!assert (set_slice ([2 2], 32, 2), [1 1;2 2]')
+%!assert (set_slice ([ 2 2], 32, 3), [1 1;1 1;2 2]')
+%!assert (set_slice ([2 2], 32, 4), [1 1;1 1;0 0;2 2]')
+%!assert (set_slice ([2 2], 33, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 33, 1), [2 2;2 2])
+%!assert (set_slice ([2 2], 33, 2), reshape ([1 1 1 1 2 2 2 2],[2 2 2]))
+%!assert (set_slice ([ 2 2], 33, 3), reshape ([1 1 1 1 0 0 0 0 2 2 2 2],[2 2 3]))
diff --git a/test/test_struct.m b/test/test_struct.m
--- a/test/test_struct.m
+++ b/test/test_struct.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,250 +15,252 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/struct/fieldnames-1.m
 %!test
 %! s.a = 1;
 %! c = fieldnames (s);
-%! assert(iscell (c) && strcmp (c{1}, "a"));
+%! assert (iscell (c) && strcmp (c{1}, "a"));
 
 %% test/octave.test/struct/fieldnames-2.m
 %!test
 %! s.a.b = 1;
 %! c = fieldnames (s.a);
-%! assert(iscell (c) && strcmp (c{1}, "b"));
+%! assert (iscell (c) && strcmp (c{1}, "b"));
 
 %% test/octave.test/struct/fieldnames-3.m
 %!error <Invalid call to fieldnames> fieldnames ();
 
 %% test/octave.test/struct/fieldnames-4.m
 %!test
 %! s.a = 1;
-%! fail("fieldnames (s, 1)","Invalid call to fieldnames.*");
+%! fail ("fieldnames (s, 1)", "Invalid call to fieldnames");
 
 %% test/octave.test/struct/fieldnames-5.m
 %!error fieldnames (1);
 
 %% test/octave.test/struct/isfield-1.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
-%! assert(isfield (s, "a"));
+%! assert (isfield (s, "a"));
 
 %% test/octave.test/struct/isfield-2.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
-%! assert(!(isfield (s, "b")));
+%! assert (!(isfield (s, "b")));
 
 %% test/octave.test/struct/isfield-3.m
 %!error <Invalid call to isfield> isfield ();
 
 %% test/octave.test/struct/isfield-4.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
-%! fail("isfield (s, 'a', 3);","Invalid call to isfield.*");
+%! fail ("isfield (s, 'a', 3);", "Invalid call to isfield");
 
 %% test/octave.test/struct/isfield-5.m
-%!assert(isfield (1, "m") == 0);
+%!assert (isfield (1, "m") == 0);
 
 %% test/octave.test/struct/isfield-6.m
 %!test
 %! s.a = 2;
-%! assert(isfield (s, 2) == 0);
+%! assert (isfield (s, 2) == 0);
 
 %% test/octave.test/struct/isstruct-1.m
-%!assert(!(isstruct (1)));
+%!assert (!(isstruct (1)))
 
 %% test/octave.test/struct/isstruct-2.m
-%!assert(!(isstruct ([1, 2])));
+%!assert (!(isstruct ([1, 2])))
 
 %% test/octave.test/struct/isstruct-3.m
-%!assert(!(isstruct ([])));
+%!assert (!(isstruct ([])))
 
 %% test/octave.test/struct/isstruct-4.m
-%!assert(!(isstruct ([1, 2; 3, 4])));
+%!assert (!(isstruct ([1, 2; 3, 4])))
 
 %% test/octave.test/struct/isstruct-5.m
-%!assert(!(isstruct ("t")));
+%!assert (!(isstruct ("t")))
 
 %% test/octave.test/struct/isstruct-6.m
-%!assert(!(isstruct ("test")));
+%!assert (!(isstruct ("test")))
 
 %% test/octave.test/struct/isstruct-7.m
-%!assert(!(isstruct (["test"; "ing"])));
+%!assert (!(isstruct (["test"; "ing"])))
+
+%!assert (!(isstruct ({1})))
 
 %% test/octave.test/struct/isstruct-8.m
 %!test
 %! s.a = 1;
-%! assert(isstruct (s));
+%! assert (isstruct (s));
 
 %% test/octave.test/struct/isstruct-9.m
 %!test
 %! s.a.b = 1;
-%! assert(isstruct (s.a));
+%! assert (isstruct (s.a));
 
 %% test/octave.test/struct/isstruct-10.m
 %!error <Invalid call to isstruct> isstruct ();
 
 %% test/octave.test/struct/isstruct-11.m
 %!test
 %! s.a = 1;
-%! fail("isstruct (s, 1)","Invalid call to isstruct.*");
+%! fail ("isstruct (s, 1)", "Invalid call to isstruct");
 
 ## increment element of matrix stored in struct array field
 %!test
-%!  a = struct("c", {[1, 2, 3], [4, 5, 6], [7, 8, 9]});
-%!  a(2).c(3)++;
-%!  assert(a(2).c, [4, 5, 7]);
+%! a = struct ("c", {[1, 2, 3], [4, 5, 6], [7, 8, 9]});
+%! a(2).c(3)++;
+%! assert (a(2).c, [4, 5, 7]);
 
 ## create struct array by assignment to cs-list
 %!test
-%!  [a(1:2).x] = deal (1, 3);
-%!  assert(a, struct("x", {1, 3}));
-%!  assert({a(1:2).x}, {1, 3});
+%! [a(1:2).x] = deal (1, 3);
+%! assert (a, struct ("x", {1, 3}));
+%! assert ({a(1:2).x}, {1, 3});
 
 ## assign to subrange of struct array field
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
-%!  [b(1:2, [1,3]).name] = deal("aaa", "ddd", "ccc", "fff");
-%!  assert ({b.name}, {"aaa", "ddd", "b", "e", "ccc", "fff"});
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
+%! [b(1:2, [1,3]).name] = deal ("aaa", "ddd", "ccc", "fff");
+%! assert ({b.name}, {"aaa", "ddd", "b", "e", "ccc", "fff"});
 
 ## index into nested struct arrays
 %!test
-%!  a = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
-%!  a(2).value = a;
-%!  assert (a(2).value(2,3).name, "f");
+%! a = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
+%! a(2).value = a;
+%! assert (a(2).value(2,3).name, "f");
 
 ## assign to subrange of field in nested struct array
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
-%!  b(3, 1).value = b;
-%!  [b(3, 1).value(1, [1, 3]).name] = deal ("aaa", "ccc");
-%!  assert (size (b), [3, 3]);
-%!  assert (b(3,1).value(1, 3).name, "ccc");
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
+%! b(3, 1).value = b;
+%! [b(3, 1).value(1, [1, 3]).name] = deal ("aaa", "ccc");
+%! assert (size (b), [3, 3]);
+%! assert (b(3,1).value(1, 3).name, "ccc");
 
-## test 4 dimensional struct array
+## test 4-dimensional struct array
 %!test
-%!  c(4, 4, 4, 4).name  = "a";
-%!  c(3, 3, 3, 3).value = 1;
-%!  assert (c(2,2,2,2), struct ("name", [], "value", []));
+%! c(4, 4, 4, 4).name  = "a";
+%! c(3, 3, 3, 3).value = 1;
+%! assert (c(2,2,2,2), struct ("name", [], "value", []));
 
-## assign to subrange of field in 4d struct array
+## assign to subrange of field in 4D struct array
 %!test
-%!  c(4, 4, 4, 4).name  = "a";
-%!  c(3, 3, 3, 3).value = 1;
-%!  [c([1, 3], 2, :, [3, 4]).value] = deal (1);
-%!  assert (length(find([c.value] == 1)), 17);
-%!  assert (length(find([c.value])), 17);
+%! c(4, 4, 4, 4).name  = "a";
+%! c(3, 3, 3, 3).value = 1;
+%! [c([1, 3], 2, :, [3, 4]).value] = deal (1);
+%! assert (length(find([c.value] == 1)), 17);
+%! assert (length(find([c.value])), 17);
 
 ## swap elements of struct array
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
-%!  [b([2, 1], [3, 1]).name] = deal(b([1, 2], [1, 2]).name);
-%!  assert ({b.name}, {"e", "b", "b", "e", "d", "a"});
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
+%! [b([2, 1], [3, 1]).name] = deal (b([1, 2], [1, 2]).name);
+%! assert ({b.name}, {"e", "b", "b", "e", "d", "a"});
 
 ## test internal ordering of struct array fields
 %!test
-%!  c(4, 4, 4, 4).value = 3;
-%!  c(1, 2, 3, 4).value = 2;
-%!  c(3, 3, 3, 3).value = 1;
-%!  d = reshape ({c.value}, size(c));
-%!  assert ([d{4, 4, 4, 4}, d{1, 2, 3, 4}, d{3, 3, 3, 3}],
-%!          [3, 2, 1]);
+%! c(4, 4, 4, 4).value = 3;
+%! c(1, 2, 3, 4).value = 2;
+%! c(3, 3, 3, 3).value = 1;
+%! d = reshape ({c.value}, size(c));
+%! assert ([d{4, 4, 4, 4}, d{1, 2, 3, 4}, d{3, 3, 3, 3}],
+%!         [3, 2, 1]);
 
 ## test assignment to mixed cs-list of field element subranges
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
-%!  [b(1:2, [1, 3]).name, b(2, 1:3).value] = ...
-%!    deal (1, 2, 3, 4, "5", "6", "7");
-%!  assert ({b.name}, {1, 2, "b", "e", 3, 4});
-%!  assert ({b.value}, {100, "5", 100, "6", 100, "7"});
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
+%! [b(1:2, [1, 3]).name, b(2, 1:3).value] = ...
+%!   deal (1, 2, 3, 4, "5", "6", "7");
+%! assert ({b.name}, {1, 2, "b", "e", 3, 4});
+%! assert ({b.value}, {100, "5", 100, "6", 100, "7"});
 
 %!error <a cs-list cannot be further indexed>
-%!  [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
-%!  [a(2:3).x(2)] = deal (10, 11);
+%! [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
+%! [a(2:3).x(2)] = deal (10, 11);
 
 %!error <a cs-list cannot be further indexed>
-%!  [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
-%!  a(2:3).x(2);
+%! [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
+%! a(2:3).x(2);
 
 %!error id=Octave:index-out-of-bounds
-%!  a(1).x.x = 1;
-%!  a(2).x;
+%! a(1).x.x = 1;
+%! a(2).x;
 
 %!error <invalid number of output arguments for constant expression>
-%!  a = struct ("value", {1, 2, 3, 4, 5});
-%!  [a(2:4).value] = 1;
+%! a = struct ("value", {1, 2, 3, 4, 5});
+%! [a(2:4).value] = 1;
 
 %!error <invalid assignment to cs-list outside multiple assignment>
-%!  c(4, 4, 4, 4).name  = "a";
-%!  c(3, 3, 3, 3).value = 1;
-%!  c([1, 3], 2, :, [3, 4]).value = 1;
+%! c(4, 4, 4, 4).name  = "a";
+%! c(3, 3, 3, 3).value = 1;
+%! c([1, 3], 2, :, [3, 4]).value = 1;
 
 ## test lazy copying in structs: nested assignment to self
 %!test
-%!  a.a = 1;
-%!  a.b = a;
-%!  a.b.c = a;
-%!  assert (a.b.c.b, struct ("a", 1));
+%! a.a = 1;
+%! a.b = a;
+%! a.b.c = a;
+%! assert (a.b.c.b, struct ("a", 1));
 
 ## test lazy copying in structs: indirect nested assignment to self
 %!test
-%!  a.a = 1;
-%!  a.b = 2;
-%!  b.c = a;
-%!  b.d = 3;
-%!  c.d = b;
-%!  c.e = 4;
-%!  a.b = c;
-%!  a.b.e = a;
-%!  assert (a.b.e.b.d.c, struct ("a", 1, "b", 2));
+%! a.a = 1;
+%! a.b = 2;
+%! b.c = a;
+%! b.d = 3;
+%! c.d = b;
+%! c.e = 4;
+%! a.b = c;
+%! a.b.e = a;
+%! assert (a.b.e.b.d.c, struct ("a", 1, "b", 2));
 
 ## test lazy copying in structs: nested assignment via function
 %!function aa = do_nest (a);
 %!  aa   = a;
 %!  aa.b = a;
-%! endfunction
+%!endfunction
 %!test
-%!  a.c = 1;
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  assert (a.b.b.b, struct ("c", 1));
+%! a.c = 1;
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! assert (a.b.b.b, struct ("c", 1));
 
 ## test lazy copying in structs: nested assignment via function
 %!function aa = do_nest (a);
 %!  aa   = a;
 %!  aa.b = a;
 %!  aa.b.c = aa;
-%! endfunction
+%!endfunction
 %!test
-%!  a.c = 1;
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  assert (a.b.c.b.b.c.b.b.c.b, struct ("c", 1));
+%! a.c = 1;
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! assert (a.b.c.b.b.c.b.b.c.b, struct ("c", 1));
 
 ## test lazy copying in structs: nested assignment on different levels.
 %!test
-%!  a.b = 1;
-%!  b.c = a;
-%!  b.d.e = a;
-%!  b.f.g.h = a;
-%!  b.i.j.k.l = a;
-%!  a.m = b;
-%!  a.m.c.b = a;
-%!  assert (a.m.c.b.m.i.j.k.l, struct ("b", 1));
+%! a.b = 1;
+%! b.c = a;
+%! b.d.e = a;
+%! b.f.g.h = a;
+%! b.i.j.k.l = a;
+%! a.m = b;
+%! a.m.c.b = a;
+%! assert (a.m.c.b.m.i.j.k.l, struct ("b", 1));
 
 ## test indexed assignment into empty struct array
 %!test
-%!  s = resize(struct(),3,2);
-%!  s(3).foo = 42;
-%!  assert (s(3), struct ("foo", 42));
+%! s = resize (struct (), 3,2);
+%! s(3).foo = 42;
+%! assert (s(3), struct ("foo", 42));
 
 %!error id=Octave:index-out-of-bounds
-%!  s = resize(struct(),3,2);
-%!  s(3).foo = 42;
-%!  s(7);
+%! s = resize (struct (),3,2);
+%! s(3).foo = 42;
+%! s(7);
diff --git a/test/test_switch.m b/test/test_switch.m
--- a/test/test_switch.m
+++ b/test/test_switch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,74 +22,74 @@
 %! b = 2;
 %! c = 3;
 %! 
 %! switch 0 case 1 x = a; case 2 x = b; otherwise x = c; endswitch
 %! switch 1 case 1 y = a; case 2 y = b; otherwise y = c; endswitch
 %! switch 2 case 1 z = a; case 2 z = b; otherwise z = c; endswitch
 %! switch 3 case 1 p = a; case 2 p = b; otherwise p = c; endswitch
 %! 
-%! assert(x == c && y == a && z == b && p == c);
+%! assert (x == c && y == a && z == b && p == c);
 
 %% test/octave.test/switch/switch-2.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %! 
 %! x = zeros (1, 4);
 %! 
 %! k = 1;
 %! 
 %! for i = 0:3
 %! switch (i)
-%! case a
-%! x(k) = a;
-%! case b
-%! x(k) = b;
-%! otherwise
-%! x(k) = c;
-%! endswitch
-%! k++;
+%!   case a
+%!    x(k) = a;
+%!   case b
+%!    x(k) = b;
+%!   otherwise
+%!    x(k) = c;
+%!   endswitch
+%!   k++;
 %! endfor
 %! 
-%! assert(all (x == [3, 1, 2, 3]));
+%! assert (all (x == [3, 1, 2, 3]));
 
 %% test/octave.test/switch/switch-3.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %! 
 %! x = zeros (1, 4);
 %! 
 %! k = 1;
 %! 
 %! for i = 0:3
-%! switch (i)
-%! case a
-%! x(k) = a;
-%! endswitch
-%! k++;
+%!   switch (i)
+%!   case a
+%!    x(k) = a;
+%!   endswitch
+%!   k++;
 %! endfor
 %! 
-%! assert(all (x == [0, 1, 0, 0]));
+%! assert (all (x == [0, 1, 0, 0]));
 
 %!test
 %! a = 1;
 %!
 %! switch 1
 %! otherwise
 %!   a = 2;
 %! endswitch
 %! 
-%! assert(a == 2);
+%! assert (a == 2);
 
 
 %% test/octave.test/switch/switch-4.m
-%!error <syntax error> eval("switch endswitch");
+%!error <syntax error> eval ("switch endswitch")
 
 %% test/octave.test/switch/switch-5.m
-%!error <syntax error> eval("switch case endswitch");
+%!error <syntax error> eval ("switch case endswitch")
 
 %% test/octave.test/switch/switch-6.m
-%!error <syntax error> eval("switch 1 default 1; endswitch");
+%!error <syntax error> eval ("switch 1 default 1; endswitch")
 
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,469 +15,475 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/system/cputime-1.m
 %!test
 %! [t1, u1, s1] = cputime ();
 %! for i = 1:200
-%! sin (i);
+%!   sin (i);
 %! endfor
 %! [t2, u2, s2] = cputime ();
-%! assert(t1 == u1 + s1 && t2 == u2 + s2 && t2 >= t1 && u2 >= u2 && s2 >= s2);
-
+%! assert (t1, u1 + s1);
+%! assert (t2 == u2 + s2);
+%! assert (t2 >= t1);
+%! assert (u2 >= u2);
+%! assert (s2 >= s2);
+%!#assert (t1 == u1 + s1 && t2 == u2 + s2 && t2 >= t1 && u2 >= u2 && s2 >= s2);
 
 %% test/octave.test/system/tic-toc-1.m
 %!test
 %! tic ();
 %! sleep (2);
-%! assert(toc () > 0);
+%! assert (toc () > 0);
 
 %% test/octave.test/system/pause-1.m
 %!test
 %! pause (0);
 %! printf_assert ("ok\n");
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/system/pause-2.m
-%!error <Invalid call to pause> pause (1, 2);
+%!error <Invalid call to pause> pause (1, 2)
 
 %% test/octave.test/system/sleep-1.m
 %!test
 %! sleep (0);
 %! printf_assert ("ok\n");
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/system/sleep-2.m
-%!error <Invalid call to sleep> sleep ();
+%!error <Invalid call to sleep> sleep ()
 
 %% test/octave.test/system/sleep-3.m
-%!error <Invalid call to sleep> sleep (1, 2);
+%!error <Invalid call to sleep> sleep (1, 2)
 
 %% test/octave.test/system/usleep-1.m
 %!test
 %! usleep (0);
 %! printf_assert ("ok\n");
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/system/usleep-2.m
-%!error <Invalid call to usleep> usleep ();
+%!error <Invalid call to usleep> usleep ()
 
 %% test/octave.test/system/usleep-3.m
-%!error <Invalid call to usleep> usleep (1, 2);
+%!error <Invalid call to usleep> usleep (1, 2)
 
 %% test/octave.test/system/rename-1.m
 %!test
 %! from = tmpnam ();
 %! to = tmpnam ();
 %! id = fopen (from, "wb");
 %! if (id > 0 && fclose (id) == 0)
 %!   [s, e] = stat (from);
 %!   if (! e)
 %!     if (rename (from, to) == 0)
 %!       [s, e] = stat (from);
 %!       if (e < 0)
 %!         [s, e] = stat (to);
-%!         assert(e == 0);
+%!         assert (e == 0);
 %!         unlink (to);
 %!       endif
 %!     endif
 %!   endif
 %! endif
 
 %% test/octave.test/system/rename-2.m
-%!error <Invalid call to rename> rename ();
+%!error <Invalid call to rename> rename ()
 
 %% test/octave.test/system/rename-3.m
-%!error <Invalid call to rename> rename ("foo", "bar", 1);
+%!error <Invalid call to rename> rename ("foo", "bar", 1)
 
 %% test/octave.test/system/unlink-1.m
 %!test
 %! nm = tmpnam ();
 %! if ((id = fopen (nm, "wb")) > 0)
 %!   [s, err] = stat (nm);
 %!   if (! err && fclose (id) == 0 && unlink (nm) == 0)
 %!     [s, err] = stat (nm);
-%!     assert(err < 0);
+%!     assert (err < 0);
 %!   endif
 %! endif
 
 %% test/octave.test/system/unlink-2.m
-%!error <Invalid call to unlink> unlink ();
+%!error <Invalid call to unlink> unlink ()
 
 %% test/octave.test/system/unlink-3.m
-%!error <Invalid call to unlink> unlink ("foo", 1);
+%!error <Invalid call to unlink> unlink ("foo", 1)
 
 %% test/octave.test/system/readdir-1.m
 %!test
 %! [files, status, msg] = readdir (filesep);
-%! assert(iscell (files) && status == 0 && strcmp (msg, ""));
+%! assert (iscell (files) && status == 0 && strcmp (msg, ""));
 
 %% test/octave.test/system/readdir-2.m
-%!error <Invalid call to readdir> readdir ();
+%!error <Invalid call to readdir> readdir ()
 
 %% test/octave.test/system/readdir-3.m
-%!error <Invalid call to readdir> readdir ("foo", 1);
+%!error <Invalid call to readdir> readdir ("foo", 1)
 
 %% test/octave.test/system/mk-rm-dir-1.m
 %!test
 %! nm = tmpnam ();
 %! e1 = mkdir (nm);
 %! [s2, e2] = stat (nm);
 %! e3 = rmdir (nm);
 %! [s4, e4] = stat (nm);
-%! assert((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
+%! assert ((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
 
 %% test/octave.test/system/mkdir-1.m
-%!error <Invalid call to mkdir> mkdir ();
+%!error <Invalid call to mkdir> mkdir ()
 
 %% test/octave.test/system/mkdir-2.m
-%!error <Invalid call to mkdir> mkdir ("foo", 1, 2);
+%!error <Invalid call to mkdir> mkdir ("foo", 1, 2)
 
 %% test/octave.test/system/rmdir-1.m
-%!error <Invalid call to rmdir> rmdir ();
+%!error <Invalid call to rmdir> rmdir ()
 
 %% test/octave.test/system/rmdir-2.m
 %!test
 %! crr = confirm_recursive_rmdir ();
 %! confirm_recursive_rmdir (0);
-%! assert(!rmdir ("foo", "s"));
+%! assert (!rmdir ("foo", "s"));
 %! confirm_recursive_rmdir (crr);
 
-%% FIXME This test messes up the path it seems!! Why?
 %% test/octave.test/system/umask-1.m
-%!#test
-%! umask (0);
+%!test
+%! orig_umask = umask (0);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s1 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %! 
 %! umask (777);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s2 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %! 
-%! assert(strcmp (s1.modestr, "-rw-rw-rw-") && strcmp (s2.modestr, "----------"));
+%! assert (deblank (s1.modestr), "-rw-rw-rw-");
+%! assert (deblank (s2.modestr), "----------");
+%! # Restore original umask value
+%! umask (orig_umask);
 
 %% test/octave.test/system/umask-2.m
-%!error <Invalid call to umask> umask ();
+%!error <Invalid call to umask> umask ()
 
 %% test/octave.test/system/umask-3.m
-%!error <Invalid call to umask> umask (1, 2);
+%!error <Invalid call to umask> umask (1, 2)
 
 %% test/octave.test/system/stat-1.m
 %!test
 %! [s, err, msg] = stat (filesep);
-%! assert((err == 0
+%! assert ((err == 0
 %! && isstruct (s)
 %! && isfield (s, "dev")
 %! && isfield (s, "ino")
 %! && isfield (s, "modestr")
 %! && isfield (s, "nlink")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "size")
 %! && isfield (s, "atime")
 %! && isfield (s, "mtime")
 %! && isfield (s, "ctime")
 %! && ischar (msg)));
 
 %% test/octave.test/system/stat-2.m
-%!error <Invalid call to stat> stat ();
+%!error <Invalid call to stat> stat ()
 
 %% test/octave.test/system/stat-3.m
-%!error <Invalid call to stat> stat ("foo", 1);
+%!error <Invalid call to stat> stat ("foo", 1)
 
 %% test/octave.test/system/lstat-1.m
 %!test
 %! [s, err, msg] = lstat (filesep);
-%! assert((err == 0
+%! assert ((err == 0
 %! && isstruct (s)
 %! && isfield (s, "dev")
 %! && isfield (s, "ino")
 %! && isfield (s, "modestr")
 %! && isfield (s, "nlink")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "size")
 %! && isfield (s, "atime")
 %! && isfield (s, "mtime")
 %! && isfield (s, "ctime")
 %! && ischar (msg)));
 
 %% test/octave.test/system/lstat-2.m
-%!error <Invalid call to lstat> lstat ();
+%!error <Invalid call to lstat> lstat ()
 
 %% test/octave.test/system/lstat-3.m
-%!error <Invalid call to lstat> lstat ("foo", 1);
+%!error <Invalid call to lstat> lstat ("foo", 1)
 
 %% test/octave.test/system/glob-1.m
-%!assert(iscell (glob ([filesep "*"])));
+%!assert (iscell (glob ([filesep "*"])))
 
 %% test/octave.test/system/glob-2.m
-%!error <Invalid call to glob*> glob ();
+%!error <Invalid call to glob> glob ()
 
 %% test/octave.test/system/glob-3.m
-%!error <Invalid call to glob> glob ("foo", 1);
+%!error <Invalid call to glob> glob ("foo", 1)
 
 %% test/octave.test/system/fnmatch-1.m
 %!test
 %! string_fill_char = setstr (0);
-%! assert((fnmatch ("a*a", {"aba"; "xxxba"; "aa"}) == [1; 0; 1]
+%! assert ((fnmatch ("a*a", {"aba"; "xxxba"; "aa"}) == [1; 0; 1]
 %! && fnmatch ({"a*a"; "b*b"}, "bob")
 %! && fnmatch ("x[0-5]*", {"x1"; "x6"}) == [1; 0]
 %! && fnmatch ("x[0-5]*", {"x1"; "x6"; "x001"}) == [1; 0; 1]
 %! && fnmatch ("x???y", {"xabcy"; "xy"}) == [1; 0]));
 
 %% test/octave.test/system/fnmatch-2.m
-%!error <Invalid call to fnmatch> fnmatch ();
+%!error <Invalid call to fnmatch> fnmatch ()
 
 %% test/octave.test/system/fnmatch-3.m
-%!error <Invalid call to fnmatch> fnmatch ("foo", "bar", 3);
+%!error <Invalid call to fnmatch> fnmatch ("foo", "bar", 3)
 
 %% test/octave.test/system/file_in_path-1.m
-%!assert(ischar (file_in_path (path (), "date.m")));
+%!assert (ischar (file_in_path (path (), "date.m")))
 
 %% test/octave.test/system/file_in_path-2.m
-%!error <invalid option> file_in_path ("foo", "bar", 1);
+%!error <invalid option> file_in_path ("foo", "bar", 1)
 
 %% test/octave.test/system/file_in_path-3.m
-%!error <Invalid call to file_in_path> file_in_path ();
+%!error <Invalid call to file_in_path> file_in_path ()
 
 %% test/octave.test/system/file_in_path-4.m
-%!error <Invalid call to file_in_path> file_in_path ("foo", "bar", "baz", "ooka");
+%!error <Invalid call to file_in_path> file_in_path ("foo", "bar", "baz", "ooka")
 
 %% test/octave.test/system/tilde_expand-1.m
 %!testif HAVE_GETPWUID
 %! x = getpwuid (getuid ());
-%! assert((strcmp (x.dir, tilde_expand ("~"))
+%! assert ((strcmp (x.dir, tilde_expand ("~"))
 %! && strcmp (x.dir, tilde_expand (sprintf ("~%s", x.name)))
 %! && strcmp ("foobar", tilde_expand ("foobar"))));
 
 %% test/octave.test/system/tilde_expand-2.m
-%!error <Invalid call to tilde_expand> tilde_expand ();
+%!error <Invalid call to tilde_expand> tilde_expand ()
 
 %% test/octave.test/system/tilde_expand-3.m
-%!error <Invalid call to tilde_expand> tilde_expand ("str", 2);
+%!error <Invalid call to tilde_expand> tilde_expand ("str", 2)
 
 %% test/octave.test/system/getpgrp-1.m
 %!testif HAVE_GETPGRP
-%! assert(getpgrp () > 0);
+%! assert (getpgrp () > 0);
 
 %% test/octave.test/system/getpgrp-2.m
-%!error <... getpgrp> getpgrp (1);
+%!error <... getpgrp> getpgrp (1)
 
 %% test/octave.test/system/getpid-1.m
-%!assert(getpid () > 0);
+%!assert (getpid () > 0)
 
 %% test/octave.test/system/getpid-2.m
-%!error <... getpid> getpid (1);
+%!error <... getpid> getpid (1)
 
 %% test/octave.test/system/getppid-1.m
 %!testif HAVE_GETPPID
-%! assert(getppid () > 0);
+%! assert (getppid () > 0);
 
 %% test/octave.test/system/getppid-2.m
-%!error <... getppid> getppid (1);
+%!error <... getppid> getppid (1)
 
 %% test/octave.test/system/geteuid-1.m
-%!assert(geteuid () >= 0);
+%!assert (geteuid () >= 0)
 
 %% test/octave.test/system/geteuid-2.m
-%!error <... geteuid> geteuid (1);
+%!error <... geteuid> geteuid (1)
 
 %% test/octave.test/system/getuid-1.m
-%!assert(getuid () >= 0);
+%!assert (getuid () >= 0)
 
 %% test/octave.test/system/getuid-2.m
-%!error <... getuid> getuid (1);
+%!error <... getuid> getuid (1)
 
 %% test/octave.test/system/getegid-1.m
-%!assert(getegid () >= 0);
+%!assert (getegid () >= 0)
 
 %% test/octave.test/system/getegid-2.m
-%!error <... getegid> getegid (1);
+%!error <... getegid> getegid (1)
 
 %% test/octave.test/system/getgid-1.m
-%!assert(getgid () >= 0);
+%!assert (getgid () >= 0)
 
 %% test/octave.test/system/getgid-2.m
-%!error <... getgid> getgid (1);
+%!error <... getgid> getgid (1)
 
 %% test/octave.test/system/getenv-1.m
-%!assert(strcmp (getenv ("HOME"), tilde_expand ("~")));
+%!assert (getenv ("HOME"), tilde_expand ("~"))
 
 %% test/octave.test/system/getenv-2.m
-%!error <Invalid call to getenv> getenv ();
+%!error <Invalid call to getenv> getenv ()
 
 %% test/octave.test/system/getenv-3.m
-%!error <Invalid call to getenv> getenv ("foo", 1);
+%!error <Invalid call to getenv> getenv ("foo", 1)
 
 %% test/octave.test/system/getenv-4.m
 %!test
 %! wns = warning ("query", "Octave:num-to-str");
 %! warning ("on", "Octave:num-to-str");
-%! fail("getenv (1)","warning");
+%! fail ("getenv (1)", "warning");
 %! warning (wns.state, "Octave:num-to-str");
 
 %% test/octave.test/system/putenv-1.m
 %!test
 %! putenv ("foobar", "baz");
-%! assert(strcmp (getenv ("foobar"), "baz"));
+%! assert (getenv ("foobar"), "baz");
 
 %% test/octave.test/system/putenv-2.m
-%!error <Invalid call to putenv> putenv ();
+%!error <Invalid call to putenv> putenv ()
 
 %% test/octave.test/system/putenv-3.m
-%!error <Invalid call to putenv> putenv ("foo", "bar", 1);
+%!error <Invalid call to putenv> putenv ("foo", "bar", 1)
 
 %% test/octave.test/system/putenv-4.m
 %!test
 %! wns = warning ("query", "Octave:num-to-str");
 %! warning ("on", "Octave:num-to-str");
-%! fail("putenv (1, 2)","warning");
+%! fail ("putenv (1, 2)","warning");
 %! warning (wns.state, "Octave:num-to-str");
 
 %% test/octave.test/system/cd-1.m
 %!test
 %! xdir = pwd ();
 %! cd /
 %! d1 = pwd ();
 %! cd (xdir);
 %! if (ispc () && ! isunix ())
 %!   # should be a drive letter
-%!   assert(length (d1), 3);
-%!   assert(d1(2), ":");
-%!   assert(d1(3), "\\");
+%!   assert (length (d1), 3);
+%!   assert (d1(2), ":");
+%!   assert (d1(3), "\\");
 %! else
-%!   assert("/", d1);
+%!   assert ("/", d1);
 %! endif
-%! assert(pwd(), xdir);
+%! assert (pwd(), xdir);
 
 %% test/octave.test/system/cd-2.m
-%!error cd (1);
+%!error cd (1)
 
 %% test/octave.test/system/pwd-1.m
-%!assert(ischar (pwd ()));
+%!assert (ischar (pwd ()))
 
 %% test/octave.test/system/getpwent-1.m
 %!testif HAVE_GETPWENT
 %! s = getpwent ();
 %! endpwent (); 
-%! assert((isstruct (s)
+%! assert ((isstruct (s)
 %! && isfield (s, "name")
 %! && isfield (s, "passwd")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "gecos")
 %! && isfield (s, "dir")
 %! && isfield (s, "shell")));
 
 %% test/octave.test/system/getpwent-2.m
-%!error <Invalid call to getpwent> getpwent (1);
+%!error <Invalid call to getpwent> getpwent (1)
 
 %% test/octave.test/system/getpwuid-1.m
 %!testif HAVE_GETPWUID
 %! x = getpwent ();
 %! y = getpwuid (x.uid);
 %! endpwent (); 
-%! assert(strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %% test/octave.test/system/getpwuid-2.m
-%!error <Invalid call to getpwuid> getpwuid ();
+%!error <Invalid call to getpwuid> getpwuid ()
 
 %% test/octave.test/system/getpwuid-3.m
-%!error <Invalid call to getpwuid> getpwuid (1, 2);
+%!error <Invalid call to getpwuid> getpwuid (1, 2)
 
 %% test/octave.test/system/getpwnam-1.m
 %!testif HAVE_GETPWNAM
 %! x = getpwent ();
 %! y = getpwnam (x.name);
 %! endpwent (); 
-%! assert(strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %% test/octave.test/system/getpwnam-2.m
-%!error <Invalid call to getpwnam> getpwnam ();
+%!error <Invalid call to getpwnam> getpwnam ()
 
 %% test/octave.test/system/getpwnam-3.m
-%!error <Invalid call to getpwnam> getpwnam ("foo", 1);
+%!error <Invalid call to getpwnam> getpwnam ("foo", 1)
 
 %% test/octave.test/system/setpwent-1.m
 %!testif HAVE_SETPWENT
 %! x = getpwent ();
 %! setpwent ();
 %! y = getpwent ();
 %! endpwent (); 
-%! assert(strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %% test/octave.test/system/setpwent-2.m
-%!error <Invalid call to setpwent> setpwent (1);
+%!error <Invalid call to setpwent> setpwent (1)
 
 %% test/octave.test/system/endpwent-1.m
-%!error <Invalid call to endpwent> endpwent (1);
+%!error <Invalid call to endpwent> endpwent (1)
 
 %% test/octave.test/system/getgrent-1.m
 %!testif HAVE_GETGRENT
 %! x = getgrent ();
 %! endgrent ();
-%! assert((isstruct (x)
+%! assert ((isstruct (x)
 %! && isfield (x, "name")
 %! && isfield (x, "passwd")
 %! && isfield (x, "gid")
 %! && isfield (x, "mem")));
 
 %% test/octave.test/system/getgrent-2.m
-%!error <Invalid call to getgrent> getgrent (1);
+%!error <Invalid call to getgrent> getgrent (1)
 
 %% test/octave.test/system/getgrgid-1.m
 %!testif HAVE_GETGRGID
 %! x = getgrent ();
 %! y = getgrgid (x.gid);
 %! endgrent ();
-%! assert(strcmp (x.name, y.name) && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
 %% test/octave.test/system/getgrgid-2.m
-%!error <Invalid call to getgrgid> getgrgid ();
+%!error <Invalid call to getgrgid> getgrgid ()
 
 %% test/octave.test/system/getgrgid-3.m
-%!error <Invalid call to getgrgid> getgrgid (1, 2);
+%!error <Invalid call to getgrgid> getgrgid (1, 2)
 
 %% test/octave.test/system/getgrnam-1.m
 %!testif HAVE_GETGRNAM
 %! x = getgrent ();
 %! y = getgrnam (x.name);
 %! endgrent ();
-%! assert(strcmp (x.name, y.name) && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
 %% test/octave.test/system/getgrnam-2.m
-%!error <Invalid call to getgrnam> getgrnam ();
+%!error <Invalid call to getgrnam> getgrnam ()
 
 %% test/octave.test/system/getgrnam-3.m
-%!error <Invalid call to getgrnam> getgrnam ("foo", 1);
+%!error <Invalid call to getgrnam> getgrnam ("foo", 1)
 
 %% test/octave.test/system/setgrent-1.m
 %!testif HAVE_SETGRENT
 %! x = getgrent ();
 %! setgrent ();
 %! y = getgrent ();
 %! endgrent ();
-%! assert(strcmp (x.name, y.name) && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
 %% test/octave.test/system/setgrent-2.m
-%!error <Invalid call to setgrent> setgrent (1);
+%!error <Invalid call to setgrent> setgrent (1)
 
 %% test/octave.test/system/endgrent-1.m
-%!error <Invalid call to endgrent> endgrent (1);
+%!error <Invalid call to endgrent> endgrent (1)
 
 %% test/octave.test/system/isieee-1.m
-%!assert(isieee () == 1 || isieee () == 0);
+%!assert (isieee () == 1 || isieee () == 0)
 
 %% test/octave.test/system/octave_config_info-1.m
-%!assert(isstruct (octave_config_info ()));
+%!assert (isstruct (octave_config_info ()))
 
 %% test/octave.test/system/getrusage-1.m
-%!assert(isstruct (getrusage ()));
+%!assert (isstruct (getrusage ()))
 
diff --git a/test/test_transpose.m b/test/test_transpose.m
--- a/test/test_transpose.m
+++ b/test/test_transpose.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,28 +11,76 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/transpose/transpose-1.m
+%% Basic tests
 %!test
 %! scalar = 2;
-%! assert(scalar',2);
+%! assert (scalar', 2);
 
-%% test/octave.test/transpose/transpose-2.m
 %!test
 %! range = 1:4;
-%! assert(range',[1;2;3;4]);
+%! assert (range', [1;2;3;4]);
 
-%% test/octave.test/transpose/transpose-3.m
 %!test
 %! vector = [1;2;3;4];
-%! assert(vector',[1,2,3,4]);
+%! assert (vector', [1,2,3,4]);
 
-%% test/octave.test/transpose/transpose-4.m
 %!test
 %! matrix = [1,2;3,4];
-%! assert(matrix',[1,3;2,4]);
+%! assert (matrix', [1,3;2,4]);
+
+%% Basic tests on complex numbers
+%!test
+%! scalar = 2i;
+%! assert (scalar', -2i);
+
+%!test
+%! range = (1:4)*i;
+%! assert (range', [-1i;-2i;-3i;-4i]);
+
+%!test
+%! vector = [1;2;3;4]*i;
+%! assert (vector', [-1i,-2i,-3i,-4i]);
+
+%!test
+%! matrix = [1,2;3,4]*i;
+%! assert (matrix', [-1i,-3i;-2i,-4i]);
+
+%% Test non-Hermitian transpose
+%!test
+%! scalar = 2i;
+%! assert (scalar.', 2i);
 
+%!test
+%! range = (1:4)*i;
+%! assert (range.', [1i;2i;3i;4i]);
+
+%!test
+%! vector = [1;2;3;4]*i;
+%! assert (vector.', [1i,2i,3i,4i]);
+
+%!test
+%! matrix = [1,2;3,4]*i;
+%! assert (matrix.', [1i,3i;2i,4i]);
+
+%% Basic tests on float complex numbers
+%!test
+%! scalar = single (2i);
+%! assert (scalar', single (-2i));
+
+%!test
+%! range = single ((1:4)*i);
+%! assert (range', single ([-1i;-2i;-3i;-4i]));
+
+%!test
+%! vector = single ([1;2;3;4]*i);
+%! assert (vector', single ([-1i,-2i,-3i,-4i]));
+
+%!test
+%! matrix = single ([1,2;3,4]*i);
+%! assert (matrix', single ([-1i,-3i;-2i,-4i]));
+
diff --git a/test/test_try.m b/test/test_try.m
--- a/test/test_try.m
+++ b/test/test_try.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,125 +15,125 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/try/try-1.m
 %!test
 %! try
 %! catch
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! end_try_catch
 
 %% test/octave.test/try/try-2.m
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
 %! catch
 %! end_try_catch
 %! a = 1;
-%! assert(a,1);
+%! assert (a,1);
 
 %% test/octave.test/try/try-3.m
 %!test
 %! clear x;
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
 %!   x = 1;
 %! catch
 %! end_try_catch
 %! a = 2;
-%! assert(!exist('x'))
-%! assert(a,2)
+%! assert (!exist ('x'));
+%! assert (a,2);
 
 %% test/octave.test/try/try-4.m
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
 %! catch
 %!   x = 1;
 %! end_try_catch
-%! assert(exist('x'))
+%! assert (exist ('x'));
 
 %% test/octave.test/try/try-5.m
 %!test
 %! try
 %!   clear a;
 %!   a;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
-%!   assert (strcmp(lasterr()(1:13), "`a' undefined"))
+%!   assert (lasterr()(1:13), "`a' undefined");
 %! end_try_catch
-%! assert (strcmp(lasterr()(1:13), "`a' undefined"))
+%! assert (lasterr()(1:13), "`a' undefined");
 
 %% test/octave.test/try/try-6.m
 %!test 
 %! try
-%!   error ("user-defined error")
+%!   error ("user-defined error");
 %! catch
-%!   assert(lasterr,"user-defined error");
+%!   assert (lasterr, "user-defined error");
 %! end_try_catch
 
 %% test/octave.test/try/try-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
 %!  ms = cstrcat ("<", s, ">");
+%!endfunction
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
-%!   assert(strcmp(mangle (lasterr)(1:14),"<`a' undefined"))
+%!   assert (mangle (lasterr)(1:14), "<`a' undefined");
 %! end_try_catch
 
-
 %% test/octave.test/try/try-8.m
 %!test
 %! try
 %!   try
-%!     clear a
+%!     clear a;
 %!     a;
-%!     error("Shoudn't get here");
+%!     error ("Shoudn't get here");
 %!   catch
-%!     assert(strcmp(lasterr()(1:13), "`a' undefined"))
+%!     assert (lasterr()(1:13), "`a' undefined");
 %!   end_try_catch
-%!   clear b
+%!   clear b;
 %!   b;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
-%!   assert(strcmp(lasterr()(1:13), "`b' undefined"))
+%!   assert (lasterr()(1:13), "`b' undefined");
 %! end_try_catch
 
 %% test/octave.test/try/try-9.m
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
 %!   try
-%!     assert(strcmp(lasterr()(1:13), "`a' undefined"))
-%!     clear b
+%!     assert (lasterr()(1:13), "`a' undefined");
+%!     clear b;
 %!     b;
-%!     error("Shoudn't get here");
+%!     error ("Shoudn't get here");
 %!   catch
-%!     assert(strcmp(lasterr()(1:13), "`b' undefined"))
+%!     assert (lasterr()(1:13), "`b' undefined");
 %!   end_try_catch
 %! end_try_catch
 
 %% test/octave.test/try/try-10.m
 %!test
 %! try
 %!   try
-%!     clear a
+%!     clear a;
 %!     a;
-%!     error("Shoudn't get here");
+%!     error ("Shoudn't get here");
 %!   catch
-%!     error(cstrcat("rethrow: ",lasterr));
+%!     error (cstrcat ("rethrow: ", lasterr));
 %!   end_try_catch
 %! catch
-%!   assert(strcmp(lasterr()(1:22), "rethrow: `a' undefined"))
+%!   assert (lasterr()(1:22), "rethrow: `a' undefined");
 %! end_try_catch
 
diff --git a/test/test_unwind.m b/test/test_unwind.m
--- a/test/test_unwind.m
+++ b/test/test_unwind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,32 +25,36 @@
 %!    y = g;
 %!    [1,2;x];
 %!    g = 1;
 %!    y = [y, g];
 %!  unwind_protect_cleanup
 %!    g = save_g;
 %!    y = [y, g];
 %!  end_unwind_protect
+%!endfunction
+%!
 %!test
 %! global g = -1;
 %! y = f ([3,4]);
-%! assert(y,[0,1,-1]);
+%! assert (y, [0,1,-1]);
 
 %% test/octave.test/unwind/unwind-2.m
 %!function y = f (x)
 %!  global g;
 %!  save_g = g;
 %!  unwind_protect
 %!    g = 0;
 %!    y = g;
 %!    [1,2;x];
 %!    g = 1;
 %!    y = [y, g];
 %!  unwind_protect_cleanup
 %!    g = save_g;
 %!    y = [y, g];
-%!    assert(y,[0,-1]);
+%!    assert (y, [0,-1]);
 %!  end_unwind_protect
+%!endfunction
+%!
 %!test
 %! global g = -1;
-%! fail("y = f (3);","mismatch");
+%! fail ("y = f (3);", "mismatch");
 
diff --git a/test/test_while.m b/test/test_while.m
--- a/test/test_while.m
+++ b/test/test_while.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,56 +15,56 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/while/while-1.m
 %!test
 %! i = 0;
 %! while (eye (2))
-%! i++;
-%! printf_assert ("%d\n", i);
-%! endwhile;
-%! assert(prog_output_assert(""));
+%!   i++;
+%!   printf_assert ("%d\n", i);
+%! endwhile
+%! assert (prog_output_assert (""));
 
 %% test/octave.test/while/while-2.m
 %!test
 %! i = 5;
 %! while (--i)
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("4321"));
+%! assert (prog_output_assert ("4321"));
 
 %% test/octave.test/while/while-3.m
 %!test
 %! i = 5;
 %! while (i)
-%! i--;
-%! printf_assert ("%d", i);
+%!   i--;
+%!   printf_assert ("%d", i);
 %! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("43210"));
+%! assert (prog_output_assert ("43210"));
 
 %% test/octave.test/while/while-4.m
 %!test
 %! i = 0;
 %! while (i++ < 20)
-%! if (i > 2)
-%! break;
-%! endif
-%! printf_assert ("%d", i);
-%! endwhile;
+%!   if (i > 2)
+%!     break;
+%!   endif
+%!   printf_assert ("%d", i);
+%! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("12"));
+%! assert (prog_output_assert ("12"));
 
 %% test/octave.test/while/while-5.m
 %!test
 %! i = 0;
 %! while (++i < 5)
-%! if (i < 3)
-%! continue;
-%! endif
-%! printf_assert ("%d", i);
+%!   if (i < 3)
+%!     continue;
+%!   endif
+%!   printf_assert ("%d", i);
 %! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("34"));
+%! assert (prog_output_assert ("34"));
 
