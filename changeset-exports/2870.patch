# HG changeset patch
# User jwe
# Date 861412986 0
#      Sat Apr 19 01:23:06 1997 +0000
# Node ID 3241d0057e786bad50f45ebc00e4eabc2d9315e1
# Parent  0da4980855bc2129355dc4b872b5d03da7738dfd
[project @ 1997-04-19 01:21:29 by jwe]

diff --git a/doc/faq/Makefile.in b/doc/faq/Makefile.in
--- a/doc/faq/Makefile.in
+++ b/doc/faq/Makefile.in
@@ -15,69 +15,71 @@ VPATH = @srcdir@
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 SOURCES =
 
-TEXINFO := FAQ.texi
+TEXINFO := Octave-FAQ.texi
 
-FORMATTED := FAQ.info FAQ.dvi FAQ.ps
+FORMATTED := Octave-FAQ.info Octave-FAQ.dvi Octave-FAQ.ps
 
 DISTFILES := Makefile.in $(TEXINFO) $(FORMATTED)
 
 BINDISTFILES =
 
 SPELL := $(patsubst %.texi, %.spell, $(ALL_TEXINFO))
 
 %.spell : %.texi
 	rm -f $@
 	sed -e 's/@@/ at /g' -e 's/@[a-zA-Z]*//g' $< | spell > $@.tmp
 	mv $@.tmp $@
 
-all: FAQ.info FAQ.dvi FAQ.ps
+all: Octave-FAQ.info Octave-FAQ.dvi Octave-FAQ.ps
 .PHONY: all
 
-FAQ.info: FAQ.texi
-	-makeinfo -I$(srcdir) $(srcdir)/FAQ.texi
+Octave-FAQ.info: Octave-FAQ.texi
+	-makeinfo -I$(srcdir) $(srcdir)/Octave-FAQ.texi
 
-FAQ.dvi: FAQ.texi
+Octave-FAQ.dvi: Octave-FAQ.texi
 	-TEXINPUTS="$(srcdir):$(srcdir)/..:$(TEXINPUTS):" ; \
 	  export TEXINPUTS ; \
-	  $(TEXI2DVI) $(srcdir)/FAQ.texi
+	  $(TEXI2DVI) $(srcdir)/Octave-FAQ.texi
 
-FAQ.ps: FAQ.dvi
-	-dvips -o FAQ.ps FAQ.dvi
+Octave-FAQ.ps: Octave-FAQ.dvi
+	-dvips -o Octave-FAQ.ps Octave-FAQ.dvi
 
 check install install-strip uninstall:
 .PHONY: check install install-strip uninstall
 
 tags: $(SOURCES)
 	ctags $(SOURCES)
 
 TAGS: $(SOURCES)
 	etags $(SOURCES)
 
 spell: $(SPELL)
 .PHONY: spell
 
 mostlyclean clean:
-	rm -f FAQ.cp FAQ.fn FAQ.ky FAQ.pg FAQ.tp FAQ.vr \
-	FAQ.cps FAQ.fns FAQ.kys FAQ.pgs FAQ.tps FAQ.vrs \
-	FAQ.aux	FAQ.log FAQ.toc
+	rm -f Octave-FAQ.cp Octave-FAQ.fn Octave-FAQ.ky Octave-FAQ.pg \
+	Octave-FAQ.tp Octave-FAQ.vr Octave-FAQ.cps Octave-FAQ.fns \
+	Octave-FAQ.kys Octave-FAQ.pgs Octave-FAQ.tps Octave-FAQ.vrs \
+	Octave-FAQ.aux	Octave-FAQ.log Octave-FAQ.toc
 .PHONY: mostlyclean clean
 
 distclean: clean
 	rm -f Makefile
 .PHONY: distclean
 
 maintainer-clean: distclean
-	rm -f tags TAGS FAQ.info FAQ.info-* FAQ.dvi FAQ.ps
+	rm -f tags TAGS Octave-FAQ.info Octave-FAQ.info-* \
+	Octave-FAQ.dvi Octave-FAQ.ps
 .PHONY: maintainer-clean
 
 dist: all
 	ln $(DISTFILES) ../../`cat ../../.fname`/doc/faq
 .PHONY: dist
 
 bin-dist:
 	if [ -n "$(BINDISTFILES)" ]; then \
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -2873,13 +2873,22 @@ operator * (const ComplexMatrix& m, cons
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgemm");
 	}
     }
 
   return retval;
 }
 
+MS_CMP_OPS(ComplexMatrix, real, Complex, real)
+MS_BOOL_OPS(ComplexMatrix, Complex)
+
+SM_CMP_OPS(Complex, real, ComplexMatrix, real)
+SM_BOOL_OPS(Complex, ComplexMatrix)
+
+MM_CMP_OPS(ComplexMatrix, real, ComplexMatrix, real)
+MM_BOOL_OPS(ComplexMatrix, ComplexMatrix)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -26,16 +26,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 
 #include "mx-defs.h"
+#include "mx-op-defs.h"
 #include "oct-cmplx.h"
 
 class ComplexMatrix : public MArray2<Complex>
 {
 friend class Matrix;
 friend class ComplexCHOL;
 friend class ComplexHESS;
 friend class ComplexLU;
@@ -254,15 +255,24 @@ ComplexMatrix Givens (const Complex&, co
 
 ComplexMatrix Sylvester (const ComplexMatrix&, const ComplexMatrix&,
 			 const ComplexMatrix&);
 
 extern ComplexMatrix operator * (const Matrix&,        const ComplexMatrix&);
 extern ComplexMatrix operator * (const ComplexMatrix&, const Matrix&);
 extern ComplexMatrix operator * (const ComplexMatrix&, const ComplexMatrix&);
 
+MS_CMP_OP_DECLS (ComplexMatrix, Complex)
+MS_BOOL_OP_DECLS (ComplexMatrix, Complex)
+
+SM_CMP_OP_DECLS (Complex, ComplexMatrix)
+SM_BOOL_OP_DECLS (Complex, ComplexMatrix)
+
+MM_CMP_OP_DECLS (ComplexMatrix, ComplexMatrix)
+MM_BOOL_OP_DECLS (ComplexMatrix, ComplexMatrix)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -3044,13 +3044,22 @@ operator * (const Matrix& m, const Matri
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgemm");
 	}
     }
 
   return retval;
 }
 
+MS_CMP_OPS(Matrix, , double, )
+MS_BOOL_OPS(Matrix, double)
+
+SM_CMP_OPS(double, , Matrix, )
+SM_BOOL_OPS(double, Matrix)
+
+MM_CMP_OPS(Matrix, , Matrix, )
+MM_BOOL_OPS(Matrix, Matrix)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -26,16 +26,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 
 #include "mx-defs.h"
+#include "mx-op-defs.h"
 
 #include "data-conv.h"
 #include "mach-info.h"
 
 class Matrix : public MArray2<double>
 {
 friend class ComplexMatrix;
 friend class AEPBAL;
@@ -232,15 +233,24 @@ private:
 extern Matrix Givens (double, double);
 
 extern Matrix Sylvester (const Matrix&, const Matrix&, const Matrix&);
 
 extern ComplexColumnVector Qzval (const Matrix& a, const Matrix& b);
 
 extern Matrix operator * (const Matrix& a, const Matrix& b);
 
+MS_CMP_OP_DECLS (Matrix, double)
+MS_BOOL_OP_DECLS (Matrix, double)
+
+SM_CMP_OP_DECLS (double, Matrix)
+SM_BOOL_OP_DECLS (double, Matrix)
+
+MM_CMP_OP_DECLS (Matrix, Matrix)
+MM_BOOL_OP_DECLS (Matrix, Matrix)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cdm-cm.cc b/liboctave/mx-cdm-cm.cc
--- a/liboctave/mx-cdm-cm.cc
+++ b/liboctave/mx-cdm-cm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cdm-cm.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-DMM_OPS (ComplexMatrix, ComplexDiagMatrix, ComplexMatrix)
+DMM_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, ComplexMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cdm-cs.cc b/liboctave/mx-cdm-cs.cc
--- a/liboctave/mx-cdm-cs.cc
+++ b/liboctave/mx-cdm-cs.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cdm-cs.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-DMS_OPS (ComplexMatrix, ComplexDiagMatrix, Complex)
+DMS_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, Complex)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cdm-dm.cc b/liboctave/mx-cdm-dm.cc
--- a/liboctave/mx-cdm-dm.cc
+++ b/liboctave/mx-cdm-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cdm-dm.h"
 
 #include "dDiagMatrix.h"
 #include "CDiagMatrix.h"
 
-DMDM_OPS (ComplexDiagMatrix, ComplexDiagMatrix, DiagMatrix)
+DMDM_BIN_OPS (ComplexDiagMatrix, ComplexDiagMatrix, DiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cdm-m.cc b/liboctave/mx-cdm-m.cc
--- a/liboctave/mx-cdm-m.cc
+++ b/liboctave/mx-cdm-m.cc
@@ -25,15 +25,15 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "mx-cdm-m.h"
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-DMM_OPS (ComplexMatrix, ComplexDiagMatrix, Matrix)
+DMM_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, Matrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cdm-s.cc b/liboctave/mx-cdm-s.cc
--- a/liboctave/mx-cdm-s.cc
+++ b/liboctave/mx-cdm-s.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cdm-s.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-DMS_OPS (ComplexMatrix, ComplexDiagMatrix, double)
+DMS_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, double)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-cdm.cc b/liboctave/mx-cm-cdm.cc
--- a/liboctave/mx-cm-cdm.cc
+++ b/liboctave/mx-cm-cdm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cm-cdm.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-MDM_OPS (ComplexMatrix, ComplexMatrix, ComplexDiagMatrix)
+MDM_BIN_OPS (ComplexMatrix, ComplexMatrix, ComplexDiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-dm.cc b/liboctave/mx-cm-dm.cc
--- a/liboctave/mx-cm-dm.cc
+++ b/liboctave/mx-cm-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cm-dm.h"
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
 
-MDM_OPS (ComplexMatrix, ComplexMatrix, DiagMatrix)
+MDM_BIN_OPS (ComplexMatrix, ComplexMatrix, DiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-m.cc b/liboctave/mx-cm-m.cc
--- a/liboctave/mx-cm-m.cc
+++ b/liboctave/mx-cm-m.cc
@@ -21,18 +21,23 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-cm-m.h"
 
+#include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
-MM_OPS (ComplexMatrix, ComplexMatrix, Matrix)
+MM_BIN_OPS (ComplexMatrix, ComplexMatrix, Matrix)
+
+MM_CMP_OPS (ComplexMatrix, real, Matrix, )
+
+MM_BOOL_OPS (ComplexMatrix, Matrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-s.cc b/liboctave/mx-cm-s.cc
--- a/liboctave/mx-cm-s.cc
+++ b/liboctave/mx-cm-s.cc
@@ -21,17 +21,22 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-cm-s.h"
 
+#include "boolMatrix.h"
 #include "CMatrix.h"
 
-MS_OPS (ComplexMatrix, ComplexMatrix, double)
+MS_BIN_OPS (ComplexMatrix, ComplexMatrix, double)
+
+MS_CMP_OPS (ComplexMatrix, real, double, )
+
+MS_BOOL_OPS (ComplexMatrix, double)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cs-cdm.cc b/liboctave/mx-cs-cdm.cc
--- a/liboctave/mx-cs-cdm.cc
+++ b/liboctave/mx-cs-cdm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cs-cdm.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-SDM_OPS (ComplexMatrix, Complex, ComplexDiagMatrix)
+SDM_BIN_OPS (ComplexMatrix, Complex, ComplexDiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cs-dm.cc b/liboctave/mx-cs-dm.cc
--- a/liboctave/mx-cs-dm.cc
+++ b/liboctave/mx-cs-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cs-dm.h"
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
 
-SDM_OPS (ComplexMatrix, Complex, DiagMatrix)
+SDM_BIN_OPS (ComplexMatrix, Complex, DiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cs-m.cc b/liboctave/mx-cs-m.cc
--- a/liboctave/mx-cs-m.cc
+++ b/liboctave/mx-cs-m.cc
@@ -21,18 +21,23 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-cs-m.h"
 
+#include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
-SM_OPS (ComplexMatrix, Complex, Matrix)
+SM_BIN_OPS (ComplexMatrix, Complex, Matrix)
+
+SM_CMP_OPS (Complex, real, Matrix, )
+
+SM_BOOL_OPS (Complex, Matrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-cdm.cc b/liboctave/mx-dm-cdm.cc
--- a/liboctave/mx-dm-cdm.cc
+++ b/liboctave/mx-dm-cdm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-cdm.h"
 
 #include "dDiagMatrix.h"
 #include "CDiagMatrix.h"
 
-DMDM_OPS (ComplexDiagMatrix, DiagMatrix, ComplexDiagMatrix)
+DMDM_BIN_OPS (ComplexDiagMatrix, DiagMatrix, ComplexDiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-cm.cc b/liboctave/mx-dm-cm.cc
--- a/liboctave/mx-dm-cm.cc
+++ b/liboctave/mx-dm-cm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-cm.h"
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
 
-DMM_OPS (ComplexMatrix, DiagMatrix, ComplexMatrix)
+DMM_BIN_OPS (ComplexMatrix, DiagMatrix, ComplexMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-cs.cc b/liboctave/mx-dm-cs.cc
--- a/liboctave/mx-dm-cs.cc
+++ b/liboctave/mx-dm-cs.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-cs.h"
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
 
-DMS_OPS (ComplexMatrix, DiagMatrix, Complex)
+DMS_BIN_OPS (ComplexMatrix, DiagMatrix, Complex)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-m.cc b/liboctave/mx-dm-m.cc
--- a/liboctave/mx-dm-m.cc
+++ b/liboctave/mx-dm-m.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-m.h"
 
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 
-DMM_OPS (Matrix, DiagMatrix, Matrix)
+DMM_BIN_OPS (Matrix, DiagMatrix, Matrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-s.cc b/liboctave/mx-dm-s.cc
--- a/liboctave/mx-dm-s.cc
+++ b/liboctave/mx-dm-s.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-s.h"
 
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 
-DMS_OPS (Matrix, DiagMatrix, double)
+DMS_BIN_OPS (Matrix, DiagMatrix, double)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -31,98 +31,98 @@ Software Foundation, 59 Temple Place - S
   template <class R, class V, class S> \
   static inline void \
   F ## _vs (R *r, const V *v, size_t n, S s) \
   { \
     for (size_t i = 0; i < n; i++) \
       r[i] = v[i] OP s; \
   }
 
-VS_OP_FCN(add, +)
-VS_OP_FCN(subtract, -)
-VS_OP_FCN(multiply, *)
-VS_OP_FCN(divide, /)
+VS_OP_FCN (add,      +)
+VS_OP_FCN (subtract, -)
+VS_OP_FCN (multiply, *)
+VS_OP_FCN (divide,   /)
 
 #define VS_OP(F, OP, R, V, S) \
   extern template void F ## _vs (R *, const V *, size_t, S); \
   static inline R * \
   F (const V *v, size_t n, S s) \
   { \
     R *r = 0; \
     if (n > 0) \
       { \
 	r = new R [n]; \
 	F ## _vs (r, v, n, s); \
       } \
     return r; \
   }
 
 #define VS_OPS(R, V, S) \
-  VS_OP (add, +, R, S, V) \
-  VS_OP (subtract, -, R, S, V) \
-  VS_OP (multiply, *, R, S, V) \
-  VS_OP (divide, /, R, S, V)
+  VS_OP (add,      +, R, V, S) \
+  VS_OP (subtract, -, R, V, S) \
+  VS_OP (multiply, *, R, V, S) \
+  VS_OP (divide,   /, R, V, S)
 
 VS_OPS (double,  double,  double)
 VS_OPS (Complex, double,  Complex)
 VS_OPS (Complex, Complex, double)
 VS_OPS (Complex, Complex, Complex)
 
 #define SV_OP_FCN(F, OP) \
   template <class R, class S, class V> \
   static inline void \
   F ## _sv (R *r, S s, const V *v, size_t n) \
   { \
     for (size_t i = 0; i < n; i++) \
       r[i] = s OP v[i]; \
   } \
 
-SV_OP_FCN(add, +)
-SV_OP_FCN(subtract, -)
-SV_OP_FCN(multiply, *)
-SV_OP_FCN(divide, /)
+SV_OP_FCN (add,      +)
+SV_OP_FCN (subtract, -)
+SV_OP_FCN (multiply, *)
+SV_OP_FCN (divide,   /)
 
 #define SV_OP(F, OP, R, S, V) \
   extern template void F ## _sv (R *, S, const V *, size_t); \
   static inline R * \
   F (S s, const V *v, size_t n) \
   { \
     R *r = 0; \
     if (n > 0) \
       { \
 	r = new R [n]; \
         F ## _sv (r, s, v, n); \
       } \
     return r; \
   }
 
 #define SV_OPS(R, S, V) \
-  SV_OP (add,      +, R, V, S) \
-  SV_OP (subtract, -, R, V, S) \
-  SV_OP (multiply, *, R, V, S) \
-  SV_OP (divide,   /, R, V, S)
+  SV_OP (add,      +, R, S, V) \
+  SV_OP (subtract, -, R, S, V) \
+  SV_OP (multiply, *, R, S, V) \
+  SV_OP (divide,   /, R, S, V)
 
 SV_OPS (double,  double,  double)
 SV_OPS (Complex, double,  Complex)
 SV_OPS (Complex, Complex, double)
 SV_OPS (Complex, Complex, Complex)
 
 #define VV_OP_FCN(F, OP) \
   template <class R, class T1, class T2> \
   static inline void \
   F ## _vv (R *r, const T1 *v1, const T2 *v2, size_t n) \
   { \
     for (size_t i = 0; i < n; i++) \
       r[i] = v1[i] OP v2[i]; \
   } \
 
-VV_OP_FCN(add, +)
-VV_OP_FCN(subtract, -)
-VV_OP_FCN(multiply, *)
-VV_OP_FCN(divide, /)
+VV_OP_FCN (add,      +)
+VV_OP_FCN (subtract, -)
+VV_OP_FCN (multiply, *)
+VV_OP_FCN (divide,   /)
 
 #define VV_OP(F, OP, R, T1, T2) \
   extern template void F ## _vv (R *, const T1 *, const T2 *, size_t); \
   static inline R * \
   F (const T1 *v1, const T2 *v2, size_t n) \
   { \
     R *r = 0; \
     if (n > 0) \
diff --git a/liboctave/mx-m-cdm.cc b/liboctave/mx-m-cdm.cc
--- a/liboctave/mx-m-cdm.cc
+++ b/liboctave/mx-m-cdm.cc
@@ -25,15 +25,15 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "mx-m-cdm.h"
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-MDM_OPS (ComplexMatrix, Matrix, ComplexDiagMatrix)
+MDM_BIN_OPS (ComplexMatrix, Matrix, ComplexDiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-m-cm.cc b/liboctave/mx-m-cm.cc
--- a/liboctave/mx-m-cm.cc
+++ b/liboctave/mx-m-cm.cc
@@ -21,18 +21,23 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-m-cm.h"
 
+#include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
-MM_OPS (ComplexMatrix, Matrix, ComplexMatrix)
+MM_BIN_OPS (ComplexMatrix, Matrix, ComplexMatrix)
+
+MM_CMP_OPS (Matrix, , ComplexMatrix, real)
+
+MM_BOOL_OPS (Matrix, ComplexMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-m-cs.cc b/liboctave/mx-m-cs.cc
--- a/liboctave/mx-m-cs.cc
+++ b/liboctave/mx-m-cs.cc
@@ -21,18 +21,23 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-m-cs.h"
 
+#include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
-MS_OPS (ComplexMatrix, Matrix, Complex)
+MS_BIN_OPS (ComplexMatrix, Matrix, Complex)
+
+MS_CMP_OPS (Matrix, , Complex, real)
+
+MS_BOOL_OPS (Matrix, Complex)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-m-dm.cc b/liboctave/mx-m-dm.cc
--- a/liboctave/mx-m-dm.cc
+++ b/liboctave/mx-m-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-m-dm.h"
 
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 
-MDM_OPS (Matrix, Matrix, DiagMatrix)
+MDM_BIN_OPS (Matrix, Matrix, DiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -23,100 +23,337 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_mx_op_defs_h)
 #define octave_mx_op_defs_h 1
 
 #include "mx-inlines.cc"
 
 #define BIN_OP_DECL(R, OP, X, Y) \
   extern R OP (const X&, const Y&)
 
-#define MS_OP_DECLS(R, M, S) \
+class boolMatrix;
+
+#define CMP_OP_DECL(OP, X, Y) \
+  extern boolMatrix OP (const X&, const Y&)
+
+#define BOOL_OP_DECL(OP, X, Y) \
+  extern boolMatrix OP (const X&, const Y&)
+
+#define TBM boolMatrix (1, 1, true)
+#define FBM boolMatrix (1, 1, false)
+#define NBM boolMatrix ()
+
+#if 0
+
+// vector by scalar operations.
+
+#define VS_BIN_OP_DECLS(R, V, S) \
+  BIN_OP_DECL (R, operator +, V, S); \
+  BIN_OP_DECL (R, operator -, V, S); \
+  BIN_OP_DECL (R, operator *, V, S); \
+  BIN_OP_DECL (R, operator /, V, S);
+
+#define VS_BIN_OP(R, F, OP, V, S) \
+  R \
+  F (const V& v, const S& s) \
+  { \
+    int len = v.length (); \
+ \
+    R r (len); \
+ \
+    for (size_t i = 0; i < len; i++) \
+      r.elem(i) = v.elem(i) OP s; \
+ \
+    return r; \
+  }
+
+#define VS_BIN_OPS(R, V, S) \
+  VS_BIN_OP (R, operator +, +, V, S) \
+  VS_BIN_OP (R, operator -, -, V, S) \
+  VS_BIN_OP (R, operator *, *, V, S) \
+  VS_BIN_OP (R, operator /, /, V, S)
+
+// scalar by vector by operations.
+
+#define SV_BIN_OP_DECLS(R, S, V) \
+  BIN_OP_DECL (R, operator +, S, V); \
+  BIN_OP_DECL (R, operator -, S, V); \
+  BIN_OP_DECL (R, operator *, S, V); \
+  BIN_OP_DECL (R, operator /, S, V);
+
+#define SV_BIN_OP(R, F, OP, S, V) \
+  R \
+  F (const S& s, const V& v) \
+  { \
+    int len = v.length (); \
+ \
+    R r (len); \
+ \
+    for (size_t i = 0; i < len; i++) \
+      r.elem(i) = s OP v.elem(i); \
+ \
+    return r; \
+  }
+
+#define SV_BIN_OPS(R, S, V) \
+  SV_BIN_OP (R, operator +, +, S, V) \
+  SV_BIN_OP (R, operator -, -, S, V) \
+  SV_BIN_OP (R, operator *, *, S, V) \
+  SV_BIN_OP (R, operator /, /, S, V)
+
+// vector by vector operations.
+
+#define VV_BIN_OP_DECLS(R, V1, V2) \
+  BIN_OP_DECL (R, operator +, V1, V2); \
+  BIN_OP_DECL (R, operator -, V1, V2); \
+  BIN_OP_DECL (R, product,    V1, V2); \
+  BIN_OP_DECL (R, quotient,   V1, V2);
+
+#define VV_BIN_OP(R, F, OP, V1, V2) \
+  R \
+  F (const V1& v1, const V2& v2) \
+  { \
+    R r; \
+ \
+    int v1_len = v1.length (); \
+    int v2_len = v2.length (); \
+ \
+    if (v1_len != v2_len) \
+      gripe_nonconformant (#OP, v1_len, v2_len); \
+    else \
+      { \
+	r.resize (v1_len); \
+ \
+	for (size_t i = 0; i < v1_len; i++) \
+	  r.elem(i) = v1.elem(i) OP v2.elem(i); \
+      } \
+ \
+    return r; \
+  }
+
+#define VV_BIN_OPS(R, V1, V2) \
+  VV_BIN_OP (R, operator +, +, V1, V2) \
+  VV_BIN_OP (R, operator -, -, V1, V2) \
+  VV_BIN_OP (R, product,    *, V1, V2) \
+  VV_BIN_OP (R, quotient,   /, V1, V2)
+
+#endif
+
+// matrix by scalar operations.
+
+#define MS_BIN_OP_DECLS(R, M, S) \
   BIN_OP_DECL (R, operator +, M, S); \
   BIN_OP_DECL (R, operator -, M, S); \
   BIN_OP_DECL (R, operator *, M, S); \
   BIN_OP_DECL (R, operator /, M, S);
 
-#define SM_OP_DECLS(R, S, M) \
-  BIN_OP_DECL (R, operator +, S, M); \
-  BIN_OP_DECL (R, operator -, S, M); \
-  BIN_OP_DECL (R, operator *, S, M); \
-  BIN_OP_DECL (R, operator /, S, M);
-
-#define MM_OP_DECLS(R, M1, M2) \
-  BIN_OP_DECL (R, operator +, M1, M2); \
-  BIN_OP_DECL (R, operator -, M1, M2); \
-  BIN_OP_DECL (R, product,    M1, M2); \
-  BIN_OP_DECL (R, quotient,   M1, M2);
-
-#define SDM_OP_DECLS(R, S, DM) \
-  BIN_OP_DECL (R, operator +, S, DM); \
-  BIN_OP_DECL (R, operator -, S, DM);
-
-#define DMS_OP_DECLS(R, DM, S) \
-  BIN_OP_DECL (R, operator +, DM, S); \
-  BIN_OP_DECL (R, operator -, DM, S);
-
-#define MDM_OP_DECLS(R, M, DM) \
-  BIN_OP_DECL (R, operator +, M, DM); \
-  BIN_OP_DECL (R, operator -, M, DM); \
-  BIN_OP_DECL (R, operator *, M, DM);
-
-#define DMM_OP_DECLS(R, DM, M) \
-  BIN_OP_DECL (R, operator +, DM, M); \
-  BIN_OP_DECL (R, operator -, DM, M); \
-  BIN_OP_DECL (R, operator *, DM, M);
-
-#define DMDM_OP_DECLS(R, DM1, DM2) \
-  BIN_OP_DECL (R, operator +, DM1, DM2); \
-  BIN_OP_DECL (R, operator -, DM1, DM2); \
-  BIN_OP_DECL (R, product, DM1, DM2);
-
-#define MS_OP(R, OP, M, S, F) \
+#define MS_BIN_OP(R, OP, M, S, F) \
   R \
   OP (const M& m, const S& s) \
   { \
     int nr = m.rows (); \
     int nc = m.cols (); \
  \
     R r (nr, nc); \
  \
     if (nr > 0 && nc > 0) \
       F ## _vs (r.fortran_vec (), m.data (), nr * nc, s); \
  \
     return r; \
   }
 
-#define MS_OPS(R, M, S) \
-  MS_OP (R, operator +, M, S, add) \
-  MS_OP (R, operator -, M, S, subtract) \
-  MS_OP (R, operator *, M, S, multiply) \
-  MS_OP (R, operator /, M, S, divide)
+#define MS_BIN_OPS(R, M, S) \
+  MS_BIN_OP (R, operator +, M, S, add) \
+  MS_BIN_OP (R, operator -, M, S, subtract) \
+  MS_BIN_OP (R, operator *, M, S, multiply) \
+  MS_BIN_OP (R, operator /, M, S, divide)
+
+#define MS_CMP_OP_DECLS(M, S) \
+  CMP_OP_DECL (mx_el_lt, M, S); \
+  CMP_OP_DECL (mx_el_le, M, S); \
+  CMP_OP_DECL (mx_el_ge, M, S); \
+  CMP_OP_DECL (mx_el_gt, M, S); \
+  CMP_OP_DECL (mx_el_eq, M, S); \
+  CMP_OP_DECL (mx_el_ne, M, S);
+
+#define MS_CMP_OP(F, OP, M, MC, S, SC, EMPTY_RESULT) \
+  boolMatrix \
+  F (const M& m, const S& s) \
+  { \
+    boolMatrix r; \
+ \
+    int nr = m.rows (); \
+    int nc = m.cols (); \
+ \
+    if (nr == 0 || nc == 0) \
+      r = EMPTY_RESULT; \
+    else \
+      { \
+        r.resize (nr, nc); \
+ \
+        for (int j = 0; j < nc; j++) \
+          for (int i = 0; i < nr; i++) \
+	    r.elem(i, j) = MC (m.elem(i, j)) OP SC (s); \
+      } \
+ \
+    return r; \
+  }
 
-#define SM_OP(R, OP, S, M, F) \
+#define MS_CMP_OPS(M, CM, S, CS) \
+  MS_CMP_OP (mx_el_lt, <,  M, CM, S, CS, NBM) \
+  MS_CMP_OP (mx_el_le, <=, M, CM, S, CS, NBM) \
+  MS_CMP_OP (mx_el_ge, >=, M, CM, S, CS, NBM) \
+  MS_CMP_OP (mx_el_gt, >,  M, CM, S, CS, NBM) \
+  MS_CMP_OP (mx_el_eq, ==, M,   , S,   , FBM) \
+  MS_CMP_OP (mx_el_ne, !=, M,   , S,   , TBM)
+
+#define MS_BOOL_OP_DECLS(M, S) \
+  BOOL_OP_DECL (mx_el_and, M, S); \
+  BOOL_OP_DECL (mx_el_or,  M, S); \
+
+#define MS_BOOL_OP(F, OP, M, S) \
+  boolMatrix \
+  F (const M& m, const S& s) \
+  { \
+    boolMatrix r; \
+ \
+    int nr = m.rows (); \
+    int nc = m.cols (); \
+ \
+    if (nr != 0 && nc != 0) \
+      { \
+        r.resize (nr, nc); \
+ \
+        for (int j = 0; j < nc; j++) \
+          for (int i = 0; i < nr; i++) \
+	    r.elem(i, j) = (m.elem(i, j) != 0) OP (s != 0); \
+      } \
+ \
+    return r; \
+  }
+
+#define MS_BOOL_OPS(M, S) \
+  MS_BOOL_OP (mx_el_and, &&, M, S) \
+  MS_BOOL_OP (mx_el_or,  ||, M, S)
+
+#define MS_OP_DECLS(R, M, S) \
+  MS_BIN_OP_DECLS (R, M, S) \
+  MS_CMP_OP_DECLS (M, S) \
+  MS_BOOL_OP_DECLS (M, S) \
+
+// scalar by matrix operations.
+
+#define SM_BIN_OP_DECLS(R, S, M) \
+  BIN_OP_DECL (R, operator +, S, M); \
+  BIN_OP_DECL (R, operator -, S, M); \
+  BIN_OP_DECL (R, operator *, S, M); \
+  BIN_OP_DECL (R, operator /, S, M);
+
+#define SM_BIN_OP(R, OP, S, M, F) \
   R \
   OP (const S& s, const M& m) \
   { \
     int nr = m.rows (); \
     int nc = m.cols (); \
  \
     R r (nr, nc); \
  \
     if (nr > 0 && nc > 0) \
       F ## _sv (r.fortran_vec (), s, m.data (), nr * nc); \
  \
     return r; \
   }
 
-#define SM_OPS(R, S, M) \
-  SM_OP (R, operator +, S, M, add) \
-  SM_OP (R, operator -, S, M, subtract) \
-  SM_OP (R, operator *, S, M, multiply) \
-  SM_OP (R, operator /, S, M, divide)
+#define SM_BIN_OPS(R, S, M) \
+  SM_BIN_OP (R, operator +, S, M, add) \
+  SM_BIN_OP (R, operator -, S, M, subtract) \
+  SM_BIN_OP (R, operator *, S, M, multiply) \
+  SM_BIN_OP (R, operator /, S, M, divide)
+
+#define SM_CMP_OP_DECLS(S, M) \
+  CMP_OP_DECL (mx_el_lt, S, M); \
+  CMP_OP_DECL (mx_el_le, S, M); \
+  CMP_OP_DECL (mx_el_ge, S, M); \
+  CMP_OP_DECL (mx_el_gt, S, M); \
+  CMP_OP_DECL (mx_el_eq, S, M); \
+  CMP_OP_DECL (mx_el_ne, S, M);
+
+#define SM_CMP_OP(F, OP, S, SC, M, MC, EMPTY_RESULT) \
+  boolMatrix \
+  F (const S& s, const M& m) \
+  { \
+    boolMatrix r; \
+ \
+    int nr = m.rows (); \
+    int nc = m.cols (); \
+ \
+    if (nr == 0 || nc == 0) \
+      r = EMPTY_RESULT; \
+    else \
+      { \
+        r.resize (nr, nc); \
+ \
+        for (int j = 0; j < nc; j++) \
+          for (int i = 0; i < nr; i++) \
+	    r.elem(i, j) = SC (s) OP MC (m.elem(i, j)); \
+      } \
+ \
+    return r; \
+  }
 
-#define MM_OP(R, OP, M1, M2, F) \
+#define SM_CMP_OPS(S, CS, M, CM) \
+  SM_CMP_OP (mx_el_lt, <,  S, CS, M, CM, NBM) \
+  SM_CMP_OP (mx_el_le, <=, S, CS, M, CM, NBM) \
+  SM_CMP_OP (mx_el_ge, >=, S, CS, M, CM, NBM) \
+  SM_CMP_OP (mx_el_gt, >,  S, CS, M, CM, NBM) \
+  SM_CMP_OP (mx_el_eq, ==, S,   , M,   , FBM) \
+  SM_CMP_OP (mx_el_ne, !=, S,   , M,   , TBM)
+
+#define SM_BOOL_OP_DECLS(S, M) \
+  BOOL_OP_DECL (mx_el_and, S, M); \
+  BOOL_OP_DECL (mx_el_or,  S, M); \
+
+#define SM_BOOL_OP(F, OP, S, M) \
+  boolMatrix \
+  F (const S& s, const M& m) \
+  { \
+    boolMatrix r; \
+ \
+    int nr = m.rows (); \
+    int nc = m.cols (); \
+ \
+    if (nr != 0 && nc != 0) \
+      { \
+        r.resize (nr, nc); \
+ \
+        for (int j = 0; j < nc; j++) \
+          for (int i = 0; i < nr; i++) \
+	    r.elem(i, j) = (s != 0) OP (m.elem(i, j) != 0); \
+      } \
+ \
+    return r; \
+  }
+
+#define SM_BOOL_OPS(S, M) \
+  SM_BOOL_OP (mx_el_and, &&, S, M) \
+  SM_BOOL_OP (mx_el_or,  ||, S, M)
+
+#define SM_OP_DECLS(R, S, M) \
+  SM_BIN_OP_DECLS (R, S, M) \
+  SM_CMP_OP_DECLS (S, M) \
+  SM_BOOL_OP_DECLS (S, M) \
+
+// matrix by matrix operations.
+
+#define MM_BIN_OP_DECLS(R, M1, M2) \
+  BIN_OP_DECL (R, operator +, M1, M2); \
+  BIN_OP_DECL (R, operator -, M1, M2); \
+  BIN_OP_DECL (R, product,    M1, M2); \
+  BIN_OP_DECL (R, quotient,   M1, M2);
+
+#define MM_BIN_OP(R, OP, M1, M2, F) \
   R \
   OP (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     int m1_nr = m1.rows (); \
     int m1_nc = m1.cols (); \
  \
@@ -131,65 +368,187 @@ Software Foundation, 59 Temple Place - S
  \
 	if (m1_nr > 0 && m1_nc > 0) \
 	  F ## _vv (r.fortran_vec (), m1.data (), m2.data (), m1_nr * m1_nc); \
       } \
  \
     return r; \
   }
 
-#define MM_OPS(R, M1, M2) \
-  MM_OP (R, operator +, M1, M2, add) \
-  MM_OP (R, operator -, M1, M2, subtract) \
-  MM_OP (R, product,    M1, M2, multiply) \
-  MM_OP (R, quotient,   M1, M2, divide)
+#define MM_BIN_OPS(R, M1, M2) \
+  MM_BIN_OP (R, operator +, M1, M2, add) \
+  MM_BIN_OP (R, operator -, M1, M2, subtract) \
+  MM_BIN_OP (R, product,    M1, M2, multiply) \
+  MM_BIN_OP (R, quotient,   M1, M2, divide)
+
+#define MM_CMP_OP_DECLS(M1, M2) \
+  CMP_OP_DECL (mx_el_lt, M1, M2); \
+  CMP_OP_DECL (mx_el_le, M1, M2); \
+  CMP_OP_DECL (mx_el_ge, M1, M2); \
+  CMP_OP_DECL (mx_el_gt, M1, M2); \
+  CMP_OP_DECL (mx_el_eq, M1, M2); \
+  CMP_OP_DECL (mx_el_ne, M1, M2);
+
+#define MM_CMP_OP(F, OP, M1, C1, M2, C2, ONE_MT_RESULT, TWO_MT_RESULT) \
+  boolMatrix \
+  F (const M1& m1, const M2& m2) \
+  { \
+    boolMatrix r; \
+ \
+    int m1_nr = m1.rows (); \
+    int m1_nc = m1.cols (); \
+ \
+    int m2_nr = m2.rows (); \
+    int m2_nc = m2.cols (); \
+ \
+    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+      { \
+	if (m1_nr == 0 && m1_nc == 0) \
+	  r = TWO_MT_RESULT; \
+	else \
+	  { \
+	    r.resize (m1_nr, m1_nc); \
+ \
+	    for (int j = 0; j < m1_nc; j++) \
+	      for (int i = 0; i < m1_nr; i++) \
+		r.elem(i, j) = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+	  } \
+      } \
+    else \
+      { \
+	if ((m1_nr == 0 && m1_nc == 0) || (m2_nr == 0 && m2_nc == 0)) \
+	  r = ONE_MT_RESULT; \
+	else \
+	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      } \
+ \
+    return r; \
+  }
 
-#define SDM_OP(R, OP, S, DM, OPEQ) \
+#define MM_CMP_OPS(M1, C1, M2, C2) \
+  MM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2, NBM, NBM) \
+  MM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2, NBM, NBM) \
+  MM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2, NBM, NBM) \
+  MM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2, NBM, NBM) \
+  MM_CMP_OP (mx_el_eq, ==, M1,   , M2,   , FBM, TBM) \
+  MM_CMP_OP (mx_el_ne, !=, M1,   , M2,   , TBM, FBM)
+
+#define MM_BOOL_OP_DECLS(M1, M2) \
+  BOOL_OP_DECL (mx_el_and, M1, M2); \
+  BOOL_OP_DECL (mx_el_or,  M1, M2);
+
+#define MM_BOOL_OP(F, OP, M1, M2) \
+  boolMatrix \
+  F (const M1& m1, const M2& m2) \
+  { \
+    boolMatrix r; \
+ \
+    int m1_nr = m1.rows (); \
+    int m1_nc = m1.cols (); \
+ \
+    int m2_nr = m2.rows (); \
+    int m2_nc = m2.cols (); \
+ \
+    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+      { \
+	if (m1_nr != 0 || m1_nc != 0) \
+	  { \
+	    r.resize (m1_nr, m1_nc); \
+ \
+	    for (int j = 0; j < m1_nc; j++) \
+	      for (int i = 0; i < m1_nr; i++) \
+		r.elem(i, j) = (m1.elem(i, j) != 0) OP (m2.elem(i, j) != 0); \
+	  } \
+      } \
+    else \
+      { \
+	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      } \
+ \
+    return r; \
+  }
+
+#define MM_BOOL_OPS(M1, M2) \
+  MM_BOOL_OP (mx_el_and, &&, M1, M2) \
+  MM_BOOL_OP (mx_el_or,  ||, M1, M2)
+
+#define MM_OP_DECLS(R, M1, M2) \
+  MM_BIN_OP_DECLS (R, M1, M2) \
+  MM_CMP_OP_DECLS (M1, M2) \
+  MM_BOOL_OP_DECLS (M1, M2)
+
+// scalar by diagonal matrix operations.
+
+#define SDM_BIN_OP_DECLS(R, S, DM) \
+  BIN_OP_DECL (R, operator +, S, DM); \
+  BIN_OP_DECL (R, operator -, S, DM);
+
+#define SDM_BIN_OP(R, OP, S, DM, OPEQ) \
   R \
   OP (const S& s, const DM& dm) \
   { \
     int nr = dm.rows (); \
     int nc = dm.cols (); \
  \
     R r (nr, nc, s); \
  \
     int len = dm.length (); \
  \
     for (int i = 0; i < len; i++) \
-      r.elem (i, i) OPEQ dm.elem (i, i); \
+      r.elem(i, i) OPEQ dm.elem(i, i); \
  \
     return r; \
 }
 
-#define SDM_OPS(R, S, DM) \
-  SDM_OP (R, operator +, S, DM, +=) \
-  SDM_OP (R, operator -, S, DM, -=)
+#define SDM_BIN_OPS(R, S, DM) \
+  SDM_BIN_OP (R, operator +, S, DM, +=) \
+  SDM_BIN_OP (R, operator -, S, DM, -=)
+
+#define SDM_OP_DECLS(R, S, DM) \
+  SDM_BIN_OP_DECLS(R, S, DM)
 
-#define DMS_OP(R, OP, DM, S, SGN) \
+// diagonal matrix by scalar operations.
+
+#define DMS_BIN_OP_DECLS(R, DM, S) \
+  BIN_OP_DECL (R, operator +, DM, S); \
+  BIN_OP_DECL (R, operator -, DM, S);
+
+#define DMS_BIN_OP(R, OP, DM, S, SGN) \
   R \
   OP (const DM& dm, const S& s) \
   { \
     int nr = dm.rows (); \
     int nc = dm.cols (); \
  \
     R r (nr, nc, SGN s); \
  \
     int len = dm.length (); \
  \
     for (int i = 0; i < len; i++) \
-      r.elem (i, i) += dm.elem (i, i); \
+      r.elem(i, i) += dm.elem(i, i); \
  \
     return r; \
   }
 
-#define DMS_OPS(R, DM, S) \
-  DMS_OP (R, operator +, DM, S, ) \
-  DMS_OP (R, operator -, DM, S, -)
+#define DMS_BIN_OPS(R, DM, S) \
+  DMS_BIN_OP (R, operator +, DM, S, ) \
+  DMS_BIN_OP (R, operator -, DM, S, -)
+
+#define DMS_OP_DECLS(R, DM, S) \
+  DMS_BIN_OP_DECLS(R, DM, S)
 
-#define MDM_OP(R, OP, M, DM, OPEQ) \
+// matrix by diagonal matrix operations.
+
+#define MDM_BIN_OP_DECLS(R, M, DM) \
+  BIN_OP_DECL (R, operator +, M, DM); \
+  BIN_OP_DECL (R, operator -, M, DM); \
+  BIN_OP_DECL (R, operator *, M, DM);
+
+#define MDM_BIN_OP(R, OP, M, DM, OPEQ) \
 R \
 OP (const M& m, const DM& dm) \
 { \
   R r; \
  \
   int m_nr = m.rows (); \
   int m_nc = m.cols (); \
  \
@@ -204,17 +563,17 @@ OP (const M& m, const DM& dm) \
  \
       if (m_nr > 0 && m_nc > 0) \
 	{ \
 	  r = m; \
  \
 	  int len = dm.length (); \
  \
 	  for (int i = 0; i < len; i++) \
-	    r.elem (i, i) OPEQ dm.elem (i, i); \
+	    r.elem(i, i) OPEQ dm.elem(i, i); \
 	} \
     } \
  \
   return r; \
 }
 
 #define MDM_MULTIPLY_OP(R, M, DM) \
 R \
@@ -233,41 +592,51 @@ operator * (const M& m, const DM& dm) \
   else \
     { \
       r.resize (m_nr, dm_nc, 0.0); \
  \
       if (m_nr > 0 && m_nc > 0 && dm_nc == 0) \
 	{ \
 	  for (int j = 0; j < dm.length (); j++) \
 	    { \
-	      if (dm.elem (j, j) == 1.0) \
+	      if (dm.elem(j, j) == 1.0) \
 		{ \
 		  for (int i = 0; i < m_nr; i++) \
-		    r.elem (i, j) = m.elem (i, j); \
+		    r.elem(i, j) = m.elem(i, j); \
 		} \
-	      else if (dm.elem (j, j) != 0.0) \
+	      else if (dm.elem(j, j) != 0.0) \
 		{ \
 		  for (int i = 0; i < m_nr; i++) \
-		    r.elem (i, j) = dm.elem (j, j) * m.elem (i, j); \
+		    r.elem(i, j) = dm.elem(j, j) * m.elem(i, j); \
 		} \
 	    } \
 	} \
     } \
  \
   return r; \
 }
 
-#define MDM_OPS(R, M, DM) \
-  MDM_OP (R, operator +, M, DM, +=) \
-  MDM_OP (R, operator -, M, DM, -=) \
+#define MDM_BIN_OPS(R, M, DM) \
+  MDM_BIN_OP (R, operator +, M, DM, +=) \
+  MDM_BIN_OP (R, operator -, M, DM, -=) \
   MDM_MULTIPLY_OP (R, M, DM)
 
+#define MDM_OP_DECLS(R, M, DM) \
+  MDM_BIN_OP_DECLS(R, M, DM)
+
+// diagonal matrix by matrix operations.
+
 // XXX FIXME XXX -- DM - M will not give the correct result.
 
-#define DMM_OP(R, OP, DM, M, OPEQ) \
+#define DMM_BIN_OP_DECLS(R, DM, M) \
+  BIN_OP_DECL (R, operator +, DM, M); \
+  BIN_OP_DECL (R, operator -, DM, M); \
+  BIN_OP_DECL (R, operator *, DM, M);
+
+#define DMM_BIN_OP(R, OP, DM, M, OPEQ) \
 R \
 OP (const DM& dm, const M& m) \
 { \
   R r; \
  \
   int dm_nr = dm.rows (); \
   int dm_nc = dm.cols (); \
  \
@@ -280,17 +649,17 @@ OP (const DM& dm, const M& m) \
     { \
       if (m_nr > 0 && m_nc > 0) \
 	{ \
 	  r = m; \
  \
 	  int len = dm.length (); \
  \
 	  for (int i = 0; i < len; i++) \
-	    r.elem (i, i) OPEQ dm.elem (i, i); \
+	    r.elem(i, i) OPEQ dm.elem(i, i); \
 	} \
       else \
 	r.resize (m_nr, m_nc); \
     } \
  \
   return r; \
 }
 
@@ -311,64 +680,49 @@ operator * (const DM& dm, const M& m) \
   else \
     { \
       r.resize (dm_nr, m_nc, 0.0); \
  \
       if (dm_nr > 0 && dm_nc > 0 && m_nc > 0) \
 	{ \
 	  for (int i = 0; i < dm.length (); i++) \
 	    { \
-	      if (dm.elem (i, i) == 1.0) \
+	      if (dm.elem(i, i) == 1.0) \
 		{ \
 		  for (int j = 0; j < m_nc; j++) \
-		    r.elem (i, j) = m.elem (i, j); \
+		    r.elem(i, j) = m.elem(i, j); \
 		} \
-	      else if (dm.elem (i, i) != 0.0) \
+	      else if (dm.elem(i, i) != 0.0) \
 		{ \
 		  for (int j = 0; j < m_nc; j++) \
-		    r.elem (i, j) = dm.elem (i, i) * m.elem (i, j); \
+		    r.elem(i, j) = dm.elem(i, i) * m.elem(i, j); \
 		} \
 	    } \
 	} \
     } \
  \
   return r; \
 }
 
-#define DMM_OPS(R, DM, M) \
-  DMM_OP (R, operator +, DM, M, +=) \
-  DMM_OP (R, operator -, DM, M, -=) \
+#define DMM_BIN_OPS(R, DM, M) \
+  DMM_BIN_OP (R, operator +, DM, M, +=) \
+  DMM_BIN_OP (R, operator -, DM, M, -=) \
   DMM_MULTIPLY_OP(R, DM, M)
 
-#define MM_OP(R, OP, M1, M2, F) \
-  R \
-  OP (const M1& m1, const M2& m2) \
-  { \
-    R r; \
- \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
- \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
- \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#OP, m1_nr, m1_nc, m2_nr, m2_nc); \
-    else \
-      { \
-	r.resize (m1_nr, m1_nc); \
- \
-	if (m1_nr > 0 && m1_nc > 0) \
-	  F ## _vv (r.fortran_vec (), m1.data (), m2.data (), m1_nr * m1_nc); \
-      } \
- \
-    return r; \
-  }
+#define DMM_OP_DECLS(R, DM, M) \
+  DMM_BIN_OP_DECLS(R, DM, M)
+
+// diagonal matrix by diagonal matrix operations.
 
-#define DMDM_OP(R, OP, DM1, DM2, F) \
+#define DMDM_BIN_OP_DECLS(R, DM1, DM2) \
+  BIN_OP_DECL (R, operator +, DM1, DM2); \
+  BIN_OP_DECL (R, operator -, DM1, DM2); \
+  BIN_OP_DECL (R, product, DM1, DM2);
+
+#define DMDM_BIN_OP(R, OP, DM1, DM2, F) \
   R \
   OP (const DM1& dm1, const DM2& dm2) \
   { \
     R r; \
  \
     int dm1_nr = dm1.rows (); \
     int dm1_nc = dm1.cols (); \
  \
@@ -384,20 +738,23 @@ operator * (const DM& dm, const M& m) \
 	if (dm1_nr > 0 && dm1_nc > 0) \
 	  F ## _vv (r.fortran_vec (), dm1.data (), dm2.data (), \
 		    dm1_nr * dm2_nc); \
       } \
  \
     return r; \
   }
 
-#define DMDM_OPS(R, DM1, DM2) \
-  DMDM_OP (R, operator +, DM1, DM2, add) \
-  DMDM_OP (R, operator -, DM1, DM2, subtract) \
-  DMDM_OP (R, product,    DM1, DM2, multiply)
+#define DMDM_BIN_OPS(R, DM1, DM2) \
+  DMDM_BIN_OP (R, operator +, DM1, DM2, add) \
+  DMDM_BIN_OP (R, operator -, DM1, DM2, subtract) \
+  DMDM_BIN_OP (R, product,    DM1, DM2, multiply)
+
+#define DMDM_OP_DECLS(R, DM1, DM2) \
+  DMDM_BIN_OP_DECLS (R, DM1, DM2)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-s-cdm.cc b/liboctave/mx-s-cdm.cc
--- a/liboctave/mx-s-cdm.cc
+++ b/liboctave/mx-s-cdm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-s-cdm.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-SDM_OPS (ComplexMatrix, double, ComplexDiagMatrix)
+SDM_BIN_OPS (ComplexMatrix, double, ComplexDiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-s-cm.cc b/liboctave/mx-s-cm.cc
--- a/liboctave/mx-s-cm.cc
+++ b/liboctave/mx-s-cm.cc
@@ -21,17 +21,22 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-s-cm.h"
 
+#include "boolMatrix.h"
 #include "CMatrix.h"
 
-SM_OPS (ComplexMatrix, double, ComplexMatrix)
+SM_BIN_OPS (ComplexMatrix, double, ComplexMatrix)
+
+SM_CMP_OPS (double, , ComplexMatrix, real)
+
+SM_BOOL_OPS (double, ComplexMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-s-dm.cc b/liboctave/mx-s-dm.cc
--- a/liboctave/mx-s-dm.cc
+++ b/liboctave/mx-s-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-s-dm.h"
 
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 
-SDM_OPS (Matrix, double, DiagMatrix)
+SDM_BIN_OPS (Matrix, double, DiagMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+Wed Apr  2 22:04:03 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* miscellaneous/xor.m: Make type of return value logical.
+
 Fri Mar 28 16:19:53 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* miscellaneous/dump_prefs.m: Delete call to dump_1_pref for
 	warn_comma_in_global_decl.
 
 Tue Mar 25 22:00:49 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* miscellaneous/bug_report.m: Use __OCTAVE_HOME__ to find
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -23,17 +23,17 @@
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function z = xor (x, y)
 
   if (nargin == 2)
     if (is_scalar (x) || is_scalar (y) || size (x) == size (y))  
-      z = (x | y) - (x & y);
+      z = logical ((x | y) - (x & y));
     else
       error ("xor: x and y must be of common size or scalars");
     endif
   else
     usage ("xor (x, y)");
   endif
 
 endfunction
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,14 @@
+Wed Apr  2 21:59:15 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* octave.test/prefer/prefer.exp: Delete prefer-36 and prefer-37.
+	* octave.test/prefer/prefer-36.m, octave.test/prefer/prefer-37.m:
+	Delete test files.
+
 Wed Mar 12 16:56:41 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install-strip): New target.
 
 Sat Mar  1 15:23:14 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Version 2.0.5 released.
 
