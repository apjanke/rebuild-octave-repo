# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1339269975 18000
#      Sat Jun 09 14:26:15 2012 -0500
# Node ID d4bbe0ef7db5718c21de6857b1f260abd733229b
# Parent  3564bb14139620ec8d4c2d3f1d919798881b8f6f
# Parent  ec924357b3759cdb3ef304be43928ebff5ec208e
maint: periodic merge of default to jit

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -60,16 +60,23 @@ Summary of important user-visible change
     Octave:array-as-vector => Octave:array-to-vector
 
  ** The colormap function now provides new options--"list", "register",
     and "unregister"--to list all available colormap functions, and to
     add or remove a function name from the list of known colormap
     functions.  Packages that implement extra colormaps should use these
     commands with PKG_ADD and PKG_DEL statements.
 
+ ** The datevec function has been extended for better Matlab compatibility.
+    It now accepts string inputs in the following numerical formats: 12, 21,
+    22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
+    In addition, the default for formats which do not specify a date is
+    January 1st of the current year.  The previous default was the current day,
+    month, and year.  This may produce changes in existing scripts.
+
  ** Other new functions added in 3.8.0:
 
       colorcube   splinefit
       lines       tetramesh
       rgbplot     shrinkfaces
       findfigs
 
  ** Deprecated functions.
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap.conf
@@ -35,34 +35,32 @@ gnulib_modules="
   gethostname
   getopt-gnu
   gettimeofday
   glob
   isatty
   link
   lstat
   mkdir
-  mkdir-p
   mkfifo
   mkostemp
   mkstemp
   mktime
   nanosleep
   nproc
   opendir
   pathmax
   progname
   readdir
   readlink
   rename
   rewinddir
   rmdir
   round
   roundf
-  savewd
   sigaction
   signal
   sigprocmask
   sleep
   sleep
   stat
   stdint
   stdio
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -645,16 +645,17 @@ AC_SUBST(FC)
 OCTAVE_F77_FLAG(-ffloat-store, [
 AC_MSG_RESULT([setting F77_FLOAT_STORE_FLAG to -ffloat-store])
 F77_FLOAT_STORE_FLAG=-ffloat-store
 AC_SUBST(F77_FLOAT_STORE_FLAG)
 ])
 
 OCTAVE_IEEE754_DATA_FORMAT
 
+OCTAVE_CXX_BITWISE_OP_TEMPLATES
 OCTAVE_CXX_COMPLEX_SETTERS
 OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 
 ### Check for the QHull library
 
 OCTAVE_CHECK_LIBRARY(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
   [libqhull/libqhull.h qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -685,24 +685,24 @@ is possible to convert numerical arrays 
 As shown in @pxref{Basic Usage of Cell Arrays} elements can be
 extracted from cell arrays using the @samp{@{} and @samp{@}}
 operators.  If you want to extract or access subarrays which are still 
 cell arrays, you need to use the @samp{(} and @samp{)} operators.  The
 following example illustrates the difference:
 
 @example
 @group
-c = @{"1", "2", "3"; "a", "b", "c"; "4", "5", "6"@};
+c = @{"1", "2", "3"; "x", "y", "z"; "4", "5", "6"@};
 c@{2,3@}
-     @result{} ans = c
+     @result{} ans = z
 
 c(2,3)
      @result{} ans = 
         @{
-          [1,1] = c
+          [1,1] = z
         @}
 @end group
 @end example
 
 @noindent So with @samp{@{@}} you access elements of a cell
 array, while with @samp{()} you access a sub array of a cell
 array.
 
diff --git a/doc/interpreter/munge-texi.pl b/doc/interpreter/munge-texi.pl
--- a/doc/interpreter/munge-texi.pl
+++ b/doc/interpreter/munge-texi.pl
@@ -11,114 +11,114 @@ die "usage: munge-texi TOP-SRCDIR DOCSTR
 $comment_line = qr/^\s*(?:$|#)/;
 # Pre-declare hash size for efficiency
 keys(%help_text) = 1800;
 
 ################################################################################
 # Load DOCSTRINGS into memory while expanding @seealso references
 foreach $DOCSTRING_file (@ARGV)
 {
-   open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
+  open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
 
-   # Skip comments
-   while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
+  # Skip comments
+  while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
 
-   # Validate DOCSTRING file format
-   die "invalid doc file format\n" if (! /$doc_delim/o);
-   
-   do 
-   {
-     chomp;
-     $symbol = substr ($_,1);
-     $docstring = extract_docstring ();
-     if ($help_text{$symbol})
-     {
-        warn "ignoring duplicate entry for $symbol\n";
-     }
-     else
-     {
-       $help_text{$symbol} = $docstring;
-     }
+  # Validate DOCSTRING file format
+  die "invalid doc file format\n" if (! /$doc_delim/o);
+  
+  do 
+  {
+    chomp;
+    $symbol = substr ($_,1);
+    $docstring = extract_docstring ();
+    if ($help_text{$symbol})
+    {
+      warn "ignoring duplicate entry for $symbol\n";
+    }
+    else
+    {
+      $help_text{$symbol} = $docstring;
+    }
 
-   } while (! eof);
+  } while (! eof);
 
 }
 
 ################################################################################
 # Process .txi to .texi by expanding @DOCSTRING, @EXAMPLEFILE macros
 
 # Add warning header
 print '@c DO NOT EDIT!  Generated automatically by munge-texi.',"\n\n";
 
 TXI_LINE: while (<STDIN>)
 {
-   if (/^\s*\@DOCSTRING\((\S+)\)/)
-   {
-      $func = $1;
-      $docstring = $help_text{$func};
-      if (! $docstring)
-      {
-        warn "no docstring entry for $func\n";
-        next TXI_LINE;
-      }
-
-      $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
-      $docstring =~ s/^$tex_delim$/\@anchor{doc-$func}/m;
-      print $docstring,"\n";
-
+  if (/^\s*\@DOCSTRING\((\S+)\)/)
+  {
+    $func = $1;
+    $docstring = $help_text{$func};
+    if (! $docstring)
+    {
+      warn "no docstring entry for $func\n";
       next TXI_LINE;
-   }
-   if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
-   {
-      $fname = "$top_srcdir/examples/$1";
-      print '@verbatim',"\n";
-      open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
-      while (<EXAMPFH>) 
-      { 
-         print $_;
-         print "\n" if (eof and substr ($_, -1) ne "\n");
-      }
-      close (EXAMPFH);
-      print '@end verbatim',"\n\n";
+    }
+
+    $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+    $docstring =~ s/^$tex_delim$/\@anchor{doc-$func}/m;
+    print $docstring,"\n";
 
-      next TXI_LINE;
-   }
+    next TXI_LINE;
+  }
+  if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
+  {
+    $fname = "$top_srcdir/examples/$1";
+    print '@verbatim',"\n";
+    open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
+    while (<EXAMPFH>) 
+    { 
+      print $_;
+      print "\n" if (eof and substr ($_, -1) ne "\n");
+    }
+    close (EXAMPFH);
+    print '@end verbatim',"\n\n";
 
-   # pass ordinary lines straight through to output
-   print $_;
+    next TXI_LINE;
+  }
+
+  # pass ordinary lines straight through to output
+  print $_;
 }
 
 
 ################################################################################
 # Subroutines 
 ################################################################################
 sub extract_docstring
 {
-   my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
-   
-   while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
-   {
-      # expand any @seealso references
-      if (m'^@seealso{')
-      {
-         # Join multiple lines until full macro body found
-         while (! /}/m) { $_ .= <DOCFH>; }
+  my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
+  
+  while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
+  {
+    # expand any @seealso references
+    if (m'^@seealso{')
+    {
+      # Join multiple lines until full macro body found
+      while (! /}/m) { $_ .= <DOCFH>; }
 
-         ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
-        
-         $func_list = $arg_list;
-         $func_list =~ s/\s+//gs;
-         $repl = "";
-         foreach $func (split (/,/, $func_list))
-         {
-            $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
-            $repl .= "\@ref{doc-$func,,$func}, ";
-         }
-         substr($repl,-2) = "";   # Remove last ', ' 
-         $_ = "\@seealso{$repl}$rest_of_line";
+      ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
+     
+      $func_list = $arg_list;
+      $func_list =~ s/\s+//gs;
+      $repl = "";
+      foreach $func (split (/,/, $func_list))
+      {
+        $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+        $repl .= "\@ref{doc-$func,,$func}, ";
       }
+      substr($repl,-2) = "";   # Remove last ', ' 
+      $_ = "\@seealso{$repl}$rest_of_line";
+    }
 
-      $docstring .= $_;
-   }
+    $docstring .= $_;
+  }
 
-   return $docstring;
+  return $docstring;
 }
 
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -43,17 +43,16 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-locbuf.h"
 #include "oct-passwd.h"
 #include "pathlen.h"
 #include "quit.h"
 #include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "lo-cutils.h"
 
 file_ops *file_ops::instance = 0;
 
 bool
 file_ops::instance_ok (void)
 {
   bool retval = true;
 
@@ -357,42 +356,32 @@ file_ops::concat (const std::string& dir
 {
   return dir.empty ()
     ? file
     : (is_dir_sep (dir[dir.length()-1])
        ? dir + file
        : dir + dir_sep_char () + file);
 }
 
-static int 
-make_ancestor (const char *, const char *component, void *options)
-{
-  mode_t* mode = reinterpret_cast<mode_t *>(options);
-  return gnulib::mkdir (component, *mode);
-}
 
 int
 octave_mkdir (const std::string& nm, mode_t md)
 {
   std::string msg;
-  return octave_mkdir (nm, md, msg, false);
+  return octave_mkdir (nm, md, msg);
 }
 
 int
-octave_mkdir (const std::string& name, mode_t mode, std::string& msg, 
-              bool make_parents)
+octave_mkdir (const std::string& name, mode_t mode, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  if (make_parents)
-    status = octave_mkdir_parents (name.c_str (), mode, make_ancestor);
-  else
-    status = gnulib::mkdir (name.c_str (), mode);
+  status = gnulib::mkdir (name.c_str (), mode);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -117,18 +117,17 @@ private:
 // We don't have these in the file_ops class with their simple names
 // (i.e., mkdir instead of octave_mdir) because function names in
 // standard headers may be #defined.
 
 extern OCTAVE_API int
 octave_mkdir (const std::string& nm, mode_t md);
 
 extern OCTAVE_API int
-octave_mkdir (const std::string& nm, mode_t md, std::string& msg,
-              bool make_parents = false);
+octave_mkdir (const std::string& nm, mode_t md, std::string& msg);
 
 extern OCTAVE_API int
 octave_mkfifo (const std::string& nm, mode_t md);
 
 extern OCTAVE_API int
 octave_mkfifo (const std::string& nm, mode_t md, std::string& msg);
 
 extern OCTAVE_API int
diff --git a/liboctave/lo-cutils.c b/liboctave/lo-cutils.c
--- a/liboctave/lo-cutils.c
+++ b/liboctave/lo-cutils.c
@@ -27,29 +27,25 @@ along with Octave; see the file COPYING.
 /* This gives us a better chance of finding a prototype for strptime
    on some systems.  */
 
 #if ! defined (_XOPEN_SOURCE)
 #define _XOPEN_SOURCE
 #endif
 
 #include <sys/types.h>
-#include <sys/stat.h>
 #include <unistd.h>
 
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 
 #include "lo-cutils.h"
 #include "syswait.h"
 
-#include "savewd.h"
-#include "mkdir-p.h"
-
 OCTAVE_API void
 octave_qsort (void *base, size_t n, size_t size,
               int (*cmp) (const void *, const void *))
 {
   qsort (base, n, size, cmp);
 }
 
 OCTAVE_API int
@@ -75,53 +71,8 @@ octave_w32_library_search (HINSTANCE han
 }
 #endif
 
 OCTAVE_API pid_t
 octave_waitpid (pid_t pid, int *status, int options)
 {
   return WAITPID (pid, status, options);
 }
-
-struct mkdir_options
-{
-  int (*make_ancestor_function) (const char *, const char *, void *);
-  mode_t ancestor_mode;
-  mode_t mode;
-  mode_t mode_bits;
-};
-
-static void
-announce_mkdir (const char *dir, void *options)
-{
-  (void) dir;
-  (void) options;
-  /* Do nothing */
-}
-
-static int
-process_dir (char *dir, struct savewd *wd, void *options)
-{
-  struct mkdir_options const *o = options;
-  mode_t ancestor_mode = o->ancestor_mode;
-  return (make_dir_parents (dir, wd, o->make_ancestor_function, &ancestor_mode,
-                            o->mode, announce_mkdir, o->mode_bits, 
-                            (uid_t) -1, (gid_t) -1, false) ? 0 : -1);
-}
-
-OCTAVE_API int
-octave_mkdir_parents (const char *dir, mode_t mode,
-                      int (*make_ancestor) (const char *, const char *, void *))
-{
-  char *argv[1];
-  int retval;
-  char *dir2 = malloc (strlen (dir) + 1);
-  strcpy (dir2, dir); /* Make a copy to avoid passing a const char* as char* */
-  argv[0] = dir2;
-  struct mkdir_options o;
-  o.make_ancestor_function = make_ancestor;
-  o.ancestor_mode = mode | S_IWUSR | S_IXUSR; 
-  o.mode = mode | umask(0);
-  o.mode_bits = ~(mode & umask(0));
-  retval = (savewd_process_files (1, argv, process_dir, &o));
-  free (dir2);
-  return retval;
-}
diff --git a/liboctave/lo-cutils.h b/liboctave/lo-cutils.h
--- a/liboctave/lo-cutils.h
+++ b/liboctave/lo-cutils.h
@@ -45,17 +45,13 @@ octave_strncasecmp (const char *s1, cons
 #ifdef HAVE_LOADLIBRARY_API
 OCTAVE_API void *
 octave_w32_library_search (HINSTANCE handle, const char *name);
 #endif
 
 OCTAVE_API pid_t
 octave_waitpid (pid_t pid, int *status, int options);
 
-OCTAVE_API int
-octave_mkdir_parents (const char *dir, mode_t mode,
-                      int (*make_ancestor) (char const *, char const *, void *));
-
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -100,16 +100,37 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]],
 [[void test(char *); int length(); char x[length()]; test(x);]])],
 octave_cv_dynamic_auto_arrays=yes, octave_cv_dynamic_auto_arrays=no)])
 if test $octave_cv_dynamic_auto_arrays = yes; then
 AC_DEFINE(HAVE_DYNAMIC_AUTO_ARRAYS,1,[Define if C++ supports dynamic auto arrays])
 fi
 AC_LANG_POP(C++)
 ])
 dnl
+dnl See if the C++ library has the bit_and, bit_or and bit_xor
+dnl templates defined.
+dnl
+AC_DEFUN([OCTAVE_CXX_BITWISE_OP_TEMPLATES],
+[AC_CACHE_CHECK([whether bit_and, bit_or and bit_xor are defined in the c++ library],
+octave_cv_cxx_bitwise_op_templates,
+[AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <functional>]],
+[[int x = 0;
+int y = 1;
+int z1 = std::bit_and<int>() (x, y);
+int z2 = std::bit_or<int>() (x, y);
+int z3 = std::bit_xor<int>() (x, y);]])],
+octave_cv_cxx_bitwise_op_templates=yes, octave_cv_cxx_bitwise_op_templates=no)])
+if test $octave_cv_cxx_bitwise_op_templates = yes; then
+AC_DEFINE(HAVE_CXX_BITWISE_OP_TEMPLATES,1,[Define if C++ library has templated bitwise operators])
+fi
+AC_LANG_POP(C++)
+])
+
+dnl
 dnl See if the C++ library has functions to set real and imaginary
 dnl parts of complex numbers independently.
 dnl
 AC_DEFUN([OCTAVE_CXX_COMPLEX_SETTERS],
 [AC_CACHE_CHECK([whether complex class can set components independently],
 octave_cv_cxx_complex_setters,
 [AC_LANG_PUSH(C++)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <complex>]],
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
--- a/scripts/mkdoc.pl
+++ b/scripts/mkdoc.pl
@@ -39,21 +39,20 @@ MFILE: foreach $m_fname (@ARGV)
   if ($m_fname eq "--")
   {
     $srcdir = "./";
     next MFILE;
   }
 
   $full_fname = $srcdir . $m_fname;
   next MFILE unless ( $full_fname =~ m{(.*)/(@|)([^/]*)/(.*)\.m} );
-  if ($2) {
-    $fcn = "$2$3/$4";
-  } else {
-    $fcn = $4;
-  }
+  if ($2)
+    { $fcn = "$2$3/$4"; }
+  else
+    { $fcn = $4; }
 
   @help_txt = gethelp ($fcn, $full_fname);
   next MFILE if ($help_txt[0] eq "");
 
   print "$fcn\n";
   print "\@c $fcn scripts/$m_fname\n";
 
   foreach $_ (@help_txt)
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -13,41 +13,48 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
-## @deftypefnx {Function File} {@var{old_name} =} graphics_toolkit (@var{name})
+## Returns the default graphics toolkit. The default graphics toolkit value
+## is assigned to new figures.
+## @deftypefnx {Function File} {@var{name} =} graphics_toolkit (@var{hlist})
+## Returns the graphics toolkits for the figures with handles @var{hlist}.
+## @deftypefnx {Function File} {} graphics_toolkit (@var{name})
+## Sets the default graphics toolkit to @var{name}.  If the toolkit is not
+## already loaded, it is initialized by calling the function
+## @code{__init_@var{name}__}.
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
-## Query or set the default graphics toolkit to @var{name}.  If the
-## toolkit is not already loaded, it is first initialized by calling the
-## function @code{__init_@var{name}__}.
-##
-## When called with a list of figure handles, @var{hlist}, the graphics
-## toolkit is changed only for the listed figures.
+## Sets the graphics toolkit for the figues with handles @var{hlist} to
+## @var{name}.
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
   endif
 
   if (nargout > 0 || nargin == 0)
     retval = get (0, "defaultfigure__graphics_toolkit__");
   endif
 
   if (nargin == 0)
     return;
   elseif (nargin == 1)
-    if (! ischar (name))
+    if (all (isfigure (name)))
+      hlist = name;
+      retval = get (hlist, "__graphics_toolkit__");
+      return
+    elseif (! ischar (name))
       error ("graphics_toolkit: invalid graphics toolkit NAME");
     endif
   elseif (nargin == 2)
     ## Swap input arguments
     [hlist, name] = deal (name, hlist);
     if (! all (isfigure (hlist)))
       error ("graphics_toolkit: invalid figure handle list HLIST");
     elseif (! ischar (name))
@@ -72,17 +79,17 @@ endfunction
 
 
 %!testif HAVE_FLTK
 %! unwind_protect
 %!   hf = figure ("visible", "off"); 
 %!   toolkit = graphics_toolkit ();
 %!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
 %!   graphics_toolkit (hf, "fltk"); 
-%!   assert (get (hf, "__graphics_toolkit__"), "fltk");
+%!   assert (graphics_toolkit (hf), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
 %! old_toolkit = graphics_toolkit ();
 %! switch old_toolkit
 %!   case {"gnuplot"}
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -505,36 +505,39 @@ function [hlegend2, hobjects2, hplot2, t
         if (isempty (hlegend))
           addprops = true;
           hlegend = axes ("tag", "legend", "userdata", struct ("handle", ud),
                           "box", box,
                           "xtick", [], "ytick", [],
                           "xticklabel", "", "yticklabel", "", "zticklabel", "",
                           "xlim", [0, 1], "ylim", [0, 1],
                           "visible", ifelse (strcmp (box, "on"), "on", "off"),
-                          "activepositionproperty", "position");
+                          "activepositionproperty", "position",
+                          "fontsize", ca_fontsize);
         else
           addprops = false;
           axes (hlegend);
           delete (get (hlegend, "children"));
         endif
         ## Add text label to the axis first, checking their extents
         nentries = numel (hplots);
         texthandle = [];
         maxwidth = 0;
         maxheight = 0;
         for k = 1 : nentries
           if (strcmp (textpos, "right"))
             texthandle = [texthandle, text(0, 0, text_strings {k},
                                            "horizontalalignment", "left",
-                                           "userdata", hplots(k))];
+                                           "userdata", hplots(k),
+                                           "fontsize", ca_fontsize)];
           else
             texthandle = [texthandle, text(0, 0, text_strings {k},
                                            "horizontalalignment", "right",
-                                           "userdata", hplots(k))];
+                                           "userdata", hplots(k),
+                                           "fontsize", ca_fontsize)];
           endif
           units = get (texthandle (end), "units");
           unwind_protect
             set (texthandle (end), "units", "points");
             extents = get (texthandle (end), "extent");
             maxwidth = max (maxwidth, extents (3));
             maxheight = max (maxheight, extents (4));
           unwind_protect_cleanup
@@ -707,16 +710,28 @@ function [hlegend2, hobjects2, hplot2, t
             addlistener(hplots(k), "color", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "linestyle", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "marker", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "markeredgecolor", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "markerfacecolor", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "markersize", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "displayname", {@updateline, hlegend, linelength});
           case "patch"
+            facecolor = get (hplots(k), "facecolor");
+            edgecolor = get (hplots(k), "edgecolor");
+            cdata = get (hplots(k), "cdata");
+            if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
+              p1 = patch ("xdata", ([0, linelength, linelength, 0] +
+                                   xoffset + xk * xstep) / lpos(3),
+                         "ydata", (lpos(4) - yoffset -
+                                   [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
+                         "facecolor", facecolor, "edgecolor", edgecolor, "cdata", cdata,
+                         "userdata", hplots (k));
+              hobjects = [hobjects, p1];
+            endif
           case "surface"
           endswitch
           set (texthandle (k), "position", [(txoffset + xk * xstep) / lpos(3), ...
                                             (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
           if (strcmp (orientation, "vertical"))
             yk++;
             if (yk > num1)
               yk = 0;
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -54,17 +54,17 @@ function q = prctile (x, p = [], dim)
     p = [0, 25, 50, 75, 100];
   endif
 
   if (! (isnumeric (p) && isvector (p)))
     error ("prctile: P must be a numeric vector");
   endif
 
   nd = ndims (x);
-  if (nargin == 2)
+  if (nargin < 3)
     if (nd == 2)
       ## If a matrix or vector, always use 1st dimension.
       dim = 1;
     else
       ## If an N-d array, find the first non-singleton dimension.
       (dim = find (sz > 1, 1)) || (dim = 1);
     endif
   else
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -12,27 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{q} =} quantile (@var{x}, @var{p})
+## @deftypefn  {Function File} {@var{q} =} quantile (@var{x})
+## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
 ## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
 ## the cumulative probability values in @var{p}.  All non-numeric values (NaNs)
 ## of @var{x} are ignored.
 ##
 ## If @var{x} is a matrix, compute the quantiles for each column and
 ## return them in a matrix, such that the i-th row of @var{q} contains
 ## the @var{p}(i)th quantiles of each column of @var{x}.
 ##
+## If @var{p} is unspecified, return the quantiles for
+## @code{[0.00 0.25 0.50 0.75 1.00]}.
 ## The optional argument @var{dim} determines the dimension along which
 ## the quantiles are calculated.  If @var{dim} is omitted, and @var{x} is
 ## a vector or matrix, it defaults to 1 (column-wise quantiles).  If
 ## @var{x} is an N-D array, @var{dim} defaults to the first non-singleton
 ## dimension.
 ##
 ## The methods available to calculate sample quantiles are the nine methods
 ## used by R (http://www.r-project.org/).  The default value is METHOD = 5.
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -62,17 +62,17 @@
 ## @item
 ## Days before the beginning of the month go to the previous month.
 ##
 ## @item
 ## Days can be fractional.
 ## @end itemize
 ##
 ## @strong{Caution:} this function does not attempt to handle Julian
-## calendars so dates before Octave 15, 1582 are wrong by as much
+## calendars so dates before October 15, 1582 are wrong by as much
 ## as eleven days.  Also, be aware that only Roman Catholic countries
 ## adopted the calendar in 1582.  It took until 1924 for it to be
 ## adopted everywhere.  See the Wikipedia entry on the Gregorian
 ## calendar for more details.
 ##
 ## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
 ## is available on the Wikipedia entry for leap seconds.
 ## @seealso{datestr, datevec, now, clock, date}
@@ -104,17 +104,22 @@ function [days, secs] = datenum (year, m
       if (nc >= 5) minute = year(:,5); endif
       if (nc >= 4) hour   = year(:,4); endif
       day   = year(:,3);
       month = year(:,2);
       year  = year(:,1);
     endif
   endif
 
-  month(month<1) = 1; ## For compatibility.  Otherwise allow negative months.
+  if (! (isa (year, "double") && isa (month, "double") && isa (day, "double") &&
+         isa (hour, "double") && isa (minute, "double") && isa (second, "double")))
+    error ("datenum: all inputs must be of class double");
+  endif
+
+  month(month<1) = 1;  # For compatibility.  Otherwise allow negative months.
 
   ## Treat fractional months, by converting the fraction to days
   if (floor (month) != month)
     fracmonth = month - floor (month);
     month = floor (month);
     if ((mod (month-1,12) + 1) == 2 && 
         (floor (year/4) - floor (year/100) + floor (year/400)) != 0)
       ## leap year
@@ -190,10 +195,11 @@ endfunction
 %!assert (datenum ("5/19/2001"), 730990)
 %!assert (datenum ({"5/19/2001"}), 730990)
 %!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
 %!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
 
 %% Test input validation
 %!error datenum ()
 %!error datenum (1,2,3,4,5,6,7)
-%!error datenum ([1, 2])
-%!error datenum ([1,2,3,4,5,6,7])
+%!error <expected date vector containing> datenum ([1, 2])
+%!error <expected date vector containing> datenum ([1,2,3,4,5,6,7])
+%!error <all inputs must be of class double> datenum (int32 (2000), int32 (1), int32 (1))
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -51,37 +51,37 @@
 ## @item 11 @tab yy                     @tab 00
 ## @item 12 @tab mmmyy                  @tab Sep00
 ## @item 13 @tab HH:MM:SS               @tab 15:38:09
 ## @item 14 @tab HH:MM:SS PM            @tab 03:38:09 PM
 ## @item 15 @tab HH:MM                  @tab 15:38
 ## @item 16 @tab HH:MM PM               @tab 03:38 PM
 ## @item 17 @tab QQ-YY                  @tab Q3-00
 ## @item 18 @tab QQ                     @tab Q3
-## @item 19 @tab dd/mm                  @tab 13/03
-## @item 20 @tab dd/mm/yy               @tab 13/03/95
-## @item 21 @tab mmm.dd.yyyy HH:MM:SS   @tab Mar.03.1962 13:53:06
-## @item 22 @tab mmm.dd.yyyy            @tab Mar.03.1962
-## @item 23 @tab mm/dd/yyyy             @tab 03/13/1962
-## @item 24 @tab dd/mm/yyyy             @tab 12/03/1962
-## @item 25 @tab yy/mm/dd               @tab 95/03/13
-## @item 26 @tab yyyy/mm/dd             @tab 1995/03/13
-## @item 27 @tab QQ-YYYY                @tab Q4-2132
-## @item 28 @tab mmmyyyy                @tab Mar2047
-## @item 29 @tab yyyymmdd               @tab 20470313
-## @item 30 @tab yyyymmddTHHMMSS        @tab 20470313T132603
-## @item 31 @tab yyyy-mm-dd HH:MM:SS    @tab 1047-03-13 13:26:03
+## @item 19 @tab dd/mm                  @tab 07/09
+## @item 20 @tab dd/mm/yy               @tab 07/09/00
+## @item 21 @tab mmm.dd,yyyy HH:MM:SS   @tab Sep.07,2000 15:38:08
+## @item 22 @tab mmm.dd,yyyy            @tab Sep.07,2000
+## @item 23 @tab mm/dd/yyyy             @tab 09/07/2000
+## @item 24 @tab dd/mm/yyyy             @tab 07/09/2000
+## @item 25 @tab yy/mm/dd               @tab 00/09/07
+## @item 26 @tab yyyy/mm/dd             @tab 2000/09/07
+## @item 27 @tab QQ-YYYY                @tab Q3-2000
+## @item 28 @tab mmmyyyy                @tab Sep2000
+## @item 29 @tab yyyy-mm-dd             @tab 2000-09-07
+## @item 30 @tab yyyymmddTHHMMSS        @tab 20000907T153808
+## @item 31 @tab yyyy-mm-dd HH:MM:SS    @tab 2000-09-07 15:38:08
 ## @end multitable
 ##
 ## If @var{f} is a format string, the following symbols are recognized:
 ##
 ## @multitable @columnfractions 0.1 0.7 0.2
 ## @headitem Symbol @tab Meaning @tab Example
 ## @item yyyy @tab Full year                                    @tab 2005
-## @item yy   @tab Two-digit year                               @tab 2005
+## @item yy   @tab Two-digit year                               @tab 05
 ## @item mmmm @tab Full month name                              @tab December
 ## @item mmm  @tab Abbreviated month name                       @tab Dec
 ## @item mm   @tab Numeric month number (padded with zeros)     @tab 01, 08, 12
 ## @item m    @tab First letter of month name (capitalized)     @tab D
 ## @item dddd @tab Full weekday name                            @tab Sunday
 ## @item ddd  @tab Abbreviated weekday name                     @tab Sun
 ## @item dd   @tab Numeric day of month (padded with zeros)     @tab 11
 ## @item d    @tab First letter of weekday name (capitalized)   @tab S
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -24,17 +24,22 @@
 ## @deftypefnx {Function File} {[@var{y}, @var{m}, @var{d}, @var{h}, @var{mi}, @var{s}] =} datevec (@dots{})
 ## Convert a serial date number (see @code{datenum}) or date string (see
 ## @code{datestr}) into a date vector.
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
-## (see @code{datestr}).
+## (see @code{datestr}).  If @var{date} is a string, but no format is
+## specified, then a relatively slow search is performed through various
+## formats.  It is always preferable to specifiy the format string @var{f}
+## if it is known.  Formats which do not specify a particular time component
+## will have the value set to zero.  Formats which do not specify a date will
+## default to January 1st of the current year.
 ##
 ## @var{p} is the year at the start of the century to which two-digit years
 ## will be referenced.  If not specified, it defaults to the current year
 ## minus 50.
 ## @seealso{datenum, datestr, clock, now, date}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
@@ -48,40 +53,47 @@
 
 function [y, m, d, h, mi, s] = datevec (date, f = [], p = [])
 
   persistent std_formats nfmt;
 
   if (isempty (std_formats))
     std_formats = cell ();
     nfmt = 0;
-    ## These formats are specified by Matlab to be parsed
+    ## These formats are specified by Matlab documentation to be parsed
     ## The '# XX' refers to the datestr numerical format code
     std_formats{++nfmt} = "dd-mmm-yyyy HH:MM:SS";   # 0
     std_formats{++nfmt} = "dd-mmm-yyyy";            # 1
     std_formats{++nfmt} = "mm/dd/yy";               # 2
     std_formats{++nfmt} = "mm/dd";                  # 6
     std_formats{++nfmt} = "HH:MM:SS";               # 13
     std_formats{++nfmt} = "HH:MM:SS PM";            # 14
     std_formats{++nfmt} = "HH:MM";                  # 15
     std_formats{++nfmt} = "HH:MM PM";               # 16
     std_formats{++nfmt} = "mm/dd/yyyy";             # 23
 
+    ## These formats are undocumented but parsed by Matlab
+    std_formats{++nfmt} = "mmmyy";                  # 12
+    std_formats{++nfmt} = "mmm.dd,yyyy HH:MM:SS";   # 21
+    std_formats{++nfmt} = "mmm.dd,yyyy";            # 22
+    std_formats{++nfmt} = "yyyy/mm/dd";             # 26
+    std_formats{++nfmt} = "yyyy-mm-dd";             # 29
+    std_formats{++nfmt} = "yyyy-mm-dd HH:MM:SS";    # 31
+
     ## These are other formats that Octave tries
     std_formats{++nfmt} = "mmm-dd-yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm-dd-yyyy";
     std_formats{++nfmt} = "dd mmm yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd mmm yyyy";
     std_formats{++nfmt} = "mmm dd yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm dd yyyy";
     std_formats{++nfmt} = "dd.mmm.yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd.mmm.yyyy";
     std_formats{++nfmt} = "mmm.dd.yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm.dd.yyyy";
-    std_formats{++nfmt} = "mmmyy";                  # 12
     std_formats{++nfmt} = "mm/dd/yyyy HH:MM";
   endif
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (ischar (date))
@@ -249,19 +261,20 @@ function [found, y, m, d, h, mi, s] = __
       endif
       y += p - mod (p, 100);
       if (y < p)
         y += 100;
       endif
     endif
     if (! fy && ! fm && ! fd)
       tmp = localtime (time ());
+      ## default is January 1st of current year
       y = tmp.year + 1900;
-      m = tmp.mon + 1;
-      d = tmp.mday;
+      m = 1;
+      d = 1;
     elseif (! fy && fm && fd)
       tmp = localtime (time ());
       y = tmp.year + 1900;
     elseif (fy && fm && ! fd)
       d = 1;
     endif
     if (! fh && ! fmi && ! fs)
       h = mi = s = 0;
@@ -275,30 +288,30 @@ function [found, y, m, d, h, mi, s] = __
 
 endfunction
 
 
 %!demo
 %! ## Current date and time
 %! datevec (now ())
 
-%!shared nowvec
-%! nowvec = datevec (now); # Some tests could fail around midnight!
-%!# tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
+%!shared yr
+%! yr = datevec (now)(1);  # Some tests could fail around midnight!
+## tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
 %!assert (datevec ("07-Sep-2000 15:38:09"), [2000,9,7,15,38,9])
 %!assert (datevec ("07-Sep-2000"), [2000,9,7,0,0,0])
 %!assert (datevec ("09/07/00"), [2000,9,7,0,0,0])
-%!assert (datevec ("09/13"), [nowvec(1),9,13,0,0,0])
-%!assert (datevec ("15:38:09"), [nowvec(1:3),15,38,9])
-%!assert (datevec ("3:38:09 PM"), [nowvec(1:3),15,38,9])
-%!assert (datevec ("15:38"), [nowvec(1:3),15,38,0])
-%!assert (datevec ("03:38 PM"), [nowvec(1:3),15,38,0])
+%!assert (datevec ("09/13"), [yr,9,13,0,0,0])
+%!assert (datevec ("15:38:09"), [yr,1,1,15,38,9])
+%!assert (datevec ("3:38:09 PM"), [yr,1,1,15,38,9])
+%!assert (datevec ("15:38"), [yr,1,1,15,38,0])
+%!assert (datevec ("03:38 PM"), [yr,1,1,15,38,0])
 %!assert (datevec ("03/13/1962"), [1962,3,13,0,0,0])
 
 %% Test millisecond format FFF
-%!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [nowvec(1:3),15,38,21.025])
+%!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [yr,1,1,15,38,21.025])
 
 # Other tests
 %!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]');
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
 
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -39,16 +39,42 @@ along with Octave; see the file COPYING.
 #include "ov-int16.h"
 #include "ov-int8.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 
 #include <functional>
 
+#if !defined (HAVE_CXX_BITWISE_OP_TEMPLATES)
+namespace std 
+{
+  template <typename T>
+  struct bit_and 
+  {
+  public: 
+    T operator() (const T & op1, const T & op2) const { return (op1 & op2); }
+  };
+
+  template <typename T>
+  struct bit_or 
+  {
+  public: 
+    T operator() (const T & op1, const T & op2) const { return (op1 | op2); }
+  };
+
+  template <typename T>
+  struct bit_xor 
+  {
+  public: 
+    T operator() (const T & op1, const T & op2) const { return (op1 ^ op2); }
+  };
+}
+#endif
+
 template <typename OP, typename T>
 octave_value
 bitopxx(const OP& op, const std::string& fname,
         const Array<T>& x, const Array<T>& y)
 {
   int nelx = x.numel ();
   int nely = y.numel ();
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -266,17 +266,17 @@ message identifier.\n\
           // directory already exists.
 
           retval(2) = "mkdir";
           retval(1) = "directory exists";
           retval(0) = true;
         }
       else
         {
-          int status = octave_mkdir (dirname, 0777, msg, true);
+          int status = octave_mkdir (dirname, 0777, msg);
 
           if (status < 0)
             {
               retval(2) = "mkdir";
               retval(1) = msg;
             }
           else
             retval(0) = true;
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -336,22 +336,16 @@ extern void install_ops (void);
 
 #define DEFNDCMPLXCMPOP_FN(name, t1, t2, e1, e2, f) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (f (v1.CONCAT2(e1, _value) (), v2.CONCAT2(e2, _value) ())); \
   }
 
-#define BINOP_NONCONFORMANT(msg) \
-  gripe_nonconformant (msg, \
-                       a1.rows (), a1.columns (), \
-                       a2.rows (), a2.columns ()); \
-  return octave_value ()
-
 #define CATOPDECL(name, a1, a2) \
   static octave_value \
   CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
                       const Array<octave_idx_type>& ra_idx)
 
 #define DEFCATOPX(name, t1, t2) \
   CATOPDECL (name, , )
 
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -132,23 +132,23 @@ private:
 
   // The first body of code to attempt to execute.
   tree_statement_list *unwind_protect_code;
 
   // The body of code to execute no matter what happens in the first
   // body of code.
   tree_statement_list *cleanup_code;
 
-  // Comment preceding TRY token.
+  // Comment preceding UNWIND_PROTECT token.
   octave_comment_list *lead_comm;
 
-  // Comment preceding CATCH token.
+  // Comment preceding UNWIND_PROTECT_CLEANUP token.
   octave_comment_list *mid_comm;
 
-  // Comment preceding END_TRY_CATCH token.
+  // Comment preceding END_UNWIND_PROTECT token.
   octave_comment_list *trail_comm;
 
   // No copying!
 
   tree_unwind_protect_command (const tree_unwind_protect_command&);
 
   tree_unwind_protect_command& operator = (const tree_unwind_protect_command&);
 };
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -119,29 +119,21 @@
 %% test/octave.test/system/readdir-2.m
 %!error <Invalid call to readdir> readdir ()
 
 %% test/octave.test/system/readdir-3.m
 %!error <Invalid call to readdir> readdir ("foo", 1)
 
 %% test/octave.test/system/mk-rm-dir-1.m
 %!test
-%! ## FIXME: saving and restoring of pwd in olldir is a hack
-%! ##        'mkdir' should not change pwd but it does since
-%! ##        changeset 14679:a543ed02e673
-%! ##        which created 'mkdir -p' capabilities.  
-%! ##        When 'mkdir' has been corrected, delete this FIXME
-%! ##        and any lines with 'HACK'.
-%! olddir = pwd;   # HACK Line #1
 %! nm = tmpnam ();
 %! e1 = mkdir (nm);
 %! [s2, e2] = stat (nm);
 %! e3 = rmdir (nm);
 %! [s4, e4] = stat (nm);
-%! cd (olddir);    # HACK Line #2
 %! assert ((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
 
 %% test/octave.test/system/mkdir-1.m
 %!error <Invalid call to mkdir> mkdir ()
 
 %% test/octave.test/system/mkdir-2.m
 %!error <Invalid call to mkdir> mkdir ("foo", 1, 2)
 
