# HG changeset patch
# User Mike Miller <mtmiller@octave.org>
# Date 1516420768 28800
#      Fri Jan 19 19:59:28 2018 -0800
# Node ID ce2eb28e0a6d8deeca8a2c82350c352a2237b7d9
# Parent  f39ae754a7d88191a6f0fb248866577133d2413b
doc: make all Doxygen comment blocks more consistent

* Array.h, dim-vector.h, gzip.cc, octave-link.h, octave-qt-link.h,
oct-parse.in.yy, oct-string.h, ov-base.h, ov.h, ovl.h, str-vec.h: Use uniform
C++ block commenting style consistent with the rest of Octave.  Don't use
unnecessary @brief or @class markers.  Use @-style commands instead of \-style.

diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -35,23 +35,22 @@ along with Octave; see the file COPYING.
 #include <QWaitCondition>
 
 #include "octave-gui.h"
 #include "octave-link.h"
 
 // Defined for purposes of sending QList<int> as part of signal.
 typedef QList<int> QIntList;
 
-// @class OctaveLink
-// @brief Provides threadsafe access to octave.
-// @author Jacob Dawid
-//
-// This class is a wrapper around octave and provides thread safety by
-// buffering access operations to octave and executing them in the
-// readline event hook, which lives in the octave thread.
+//! Provides threadsafe access to octave.
+//! @author Jacob Dawid
+//!
+//! This class is a wrapper around octave and provides thread safety by
+//! buffering access operations to octave and executing them in the
+//! readline event hook, which lives in the octave thread.
 
 class octave_qt_link : public QObject, public octave_link
 {
   Q_OBJECT
 
 public:
 
   octave_qt_link (QWidget *p, octave::gui_application *app_context);
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -32,23 +32,22 @@ along with Octave; see the file COPYING.
 
 #include "oct-mutex.h"
 
 #include "event-queue.h"
 
 class string_vector;
 class workspace_element;
 
-// \class OctaveLink
-// \brief Provides threadsafe access to octave.
-// \author Jacob Dawid
-//
-// This class is a wrapper around octave and provides thread safety by
-// buffering access operations to octave and executing them in the
-// readline event hook, which lives in the octave thread.
+//! Provides threadsafe access to octave.
+//! @author Jacob Dawid
+//!
+//! This class is a wrapper around octave and provides thread safety by
+//! buffering access operations to octave and executing them in the
+//! readline event hook, which lives in the octave thread.
 
 class
 OCTINTERP_API
 octave_link
 {
 protected:
 
   octave_link (void);
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -15,40 +15,39 @@ MERCHANTABILITY or FITNESS FOR A PARTICU
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <https://www.gnu.org/licenses/>.
 
 */
 
+//! @file gzip.cc
 //! Octave interface to the compression and uncompression libraries.
-/*!
-  This was originally implemented as an m file which directly called
-  bzip2 and gzip applications.  This may look simpler but causes some
-  issues (see bug #43431) because we have no control over the output
-  file:
-
-    - created file is always in the same directory as the original file;
-    - automatically skip files that already have gz/bz2/etc extension;
-    - some older versions lack the --keep option.
-
-  In addition, because system() does not have a method that allows
-  passing a list of arguments, there is the issue of having to escape
-  filenames.
-
-  A solution is to pipe file contents into the applications instead of
-  filenames.  However, that solution causes:
-
-    # missing file header with original file information;
-    # implementing ourselves the recursive transversion of directories;
-    # do the above in a m file which will be slow;
-    # popen2 is frail on windows.
-
-*/
+//!
+//! This was originally implemented as an m file which directly called
+//! bzip2 and gzip applications.  This may look simpler but causes some
+//! issues (see bug #43431) because we have no control over the output
+//! file:
+//!
+//!   - created file is always in the same directory as the original file;
+//!   - automatically skip files that already have gz/bz2/etc extension;
+//!   - some older versions lack the --keep option.
+//!
+//! In addition, because system() does not have a method that allows
+//! passing a list of arguments, there is the issue of having to escape
+//! filenames.
+//!
+//! A solution is to pipe file contents into the applications instead of
+//! filenames.  However, that solution causes:
+//!
+//!   # missing file header with original file information;
+//!   # implementing ourselves the recursive transversion of directories;
+//!   # do the above in a m file which will be slow;
+//!   # popen2 is frail on windows.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cstdio>
 #include <cstring>
 
@@ -77,24 +76,24 @@ along with Octave; see the file COPYING.
 #endif
 
 #if defined (HAVE_ZLIB_H)
 #  include <zlib.h>
 #endif
 
 namespace octave
 {
-  //! RIIA wrapper for std::FILE*
-  /*! If error handling is available for failing to close the file, use
-    the close method which throws.
-
-    If the file has been closed, fp is set to nullptr.  Remember that
-    behavior is undefined if the value of the pointer stream is used
-    after fclose.
-  */
+  //! RIIA wrapper for std::FILE*.
+  //!
+  //! If error handling is available for failing to close the file, use
+  //! the close method which throws.
+  //!
+  //! If the file has been closed, fp is set to nullptr.  Remember that
+  //! behavior is undefined if the value of the pointer stream is used
+  //! after fclose.
 
   class CFile
   {
   public:
 
     CFile (void) = delete;
 
     CFile (const std::string& path, const std::string& mode)
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -100,30 +100,29 @@ inline bool btyp_isinteger (builtin_type
 { return btyp >= btyp_int8 && btyp <= btyp_uint64; }
 
 inline bool btyp_isfloat (builtin_type_t btyp)
 { return btyp <= btyp_float_complex; }
 
 inline bool btyp_isarray (builtin_type_t btyp)
 { return btyp <= btyp_char; }
 
-/*!
- * \brief Determine the resulting type for a possible mixed-type operation.
- *
- * Rules for the resulting type:
- *   - bool -> double
- *   - single + double -> single
- *   - real + complex -> complex
- *   - integer + real -> integer
- *   - uint + uint -> uint (the bigger one)
- *   - sint + sint -> sint (the bigger one)
- *
- * \return The resulting type or "unknown type", if the resulting type cannot
- *         be determined.
- */
+//! Determine the resulting type for a possible mixed-type operation.
+//!
+//! Rules for the resulting type:
+//!   - bool -> double
+//!   - single + double -> single
+//!   - real + complex -> complex
+//!   - integer + real -> integer
+//!   - uint + uint -> uint (the bigger one)
+//!   - sint + sint -> sint (the bigger one)
+//!
+//! @return The resulting type or "unknown type", if the resulting type cannot
+//!         be determined.
+
 extern OCTINTERP_API
 builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y);
 
 template <typename T>
 struct class_to_btyp
 {
   static const builtin_type_t btyp = btyp_unknown;
 };
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1459,37 +1459,35 @@ public:
   MAPPER_FORWARD (xtolower)
   MAPPER_FORWARD (xtoupper)
 
 #undef MAPPER_FORWARD
 
   octave_value map (octave_base_value::unary_mapper_t umap) const
   { return rep->map (umap); }
 
-  /*!
-   * \brief Extract the n-th element, aka `val(n)`.
-   *
-   * \return Result is undefined if `val` is not an array type
-   *                                or \p n is out of range.
-   *
-   * \warning Function calls should never error.
-   */
+  //! Extract the n-th element, aka `val(n)`.
+  //!
+  //! @return Result is undefined if `val` is not an array type
+  //!         or @p n is out of range.
+  //!
+  //! @warning Function calls should never error.
+
   octave_value
   fast_elem_extract (octave_idx_type n) const
   { return rep->fast_elem_extract (n); }
 
-  /*!
-   * \brief Assign the n-th element, aka `val(n) = x`.
-   *
-   * \returns false if `val` is not an array type,
-   *                   \p x is not a matching scalar type,
-   *                   or \p n is out of range.
-   *
-   * \warning Function calls should never error.
-   */
+  //! Assign the n-th element, aka `val(n) = x`.
+  //!
+  //! @returns false if `val` is not an array type,
+  //!          @p x is not a matching scalar type,
+  //!          or @p n is out of range.
+  //!
+  //! @warning Function calls should never error.
+
   bool
   fast_elem_insert (octave_idx_type n, const octave_value& x)
   {
     make_unique ();
     return rep->fast_elem_insert (n, x);
   }
 
 protected:
diff --git a/libinterp/octave-value/ovl.h b/libinterp/octave-value/ovl.h
--- a/libinterp/octave-value/ovl.h
+++ b/libinterp/octave-value/ovl.h
@@ -169,27 +169,27 @@ private:
 
   const octave_value& elem (octave_idx_type n) const
   { return data(n); }
 
 };
 
 
 //! Construct an octave_value_list with less typing.
-/*!
-  Historically, this made it easier to create an octave_value_list
-  from multiple octave_value arguments.  It is no longer useful since
-  octave_value_list has now a constructor accepting an initializer_list
-  so all it does is save some typing.  The following are equivalent:
+//!
+//! Historically, this made it easier to create an octave_value_list
+//! from multiple octave_value arguments.  It is no longer useful since
+//! octave_value_list has now a constructor accepting an initializer_list
+//! so all it does is save some typing.  The following are equivalent:
+//!
+//! @code{.cc}
+//! return octave_value_list ({ov0, ov1, ov2});
+//! return ovl (ov0, ov1, ov2);
+//! @endcode
 
-  @code{.cc}
-  return octave_value_list ({ov0, ov1, ov2});
-  return ovl (ov0, ov1, ov2);
-  @endcode
-*/
 template<typename... OV_Args>
 inline octave_value_list
 ovl (const OV_Args&... args)
 {
   return octave_value_list (std::initializer_list<octave_value> ({args...}));
 }
 
 #endif
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -5172,27 +5172,25 @@ context of the function that called the 
 
   octave::source_file (file_name, context);
 
   return retval;
 }
 
 namespace octave
 {
-  /*!
-    Evaluate an Octave function (built-in or interpreted) and return
-    the list of result values.
-
-    @param name The name of the function to call.
-    @param args The arguments to the function.
-    @param nargout The number of output arguments expected.
-    @return A list of output values.  The length of the list is not
-    necessarily the same as @c nargout.
-
-  */
+  //! Evaluate an Octave function (built-in or interpreted) and return
+  //! the list of result values.
+  //!
+  //! @param name The name of the function to call.
+  //! @param args The arguments to the function.
+  //! @param nargout The number of output arguments expected.
+  //! @return A list of output values.  The length of the list is not
+  //!         necessarily the same as @c nargout.
+
   octave_value_list
   feval (const std::string& name, const octave_value_list& args, int nargout)
   {
     octave_value_list retval;
 
     symbol_table& symtab = __get_symbol_table__ ("feval");
 
     octave_value fcn = symtab.find_function (name, args);
@@ -5257,28 +5255,27 @@ namespace octave
 static octave_value_list
 get_feval_args (const octave_value_list& args)
 {
   return args.slice (1, args.length () - 1, true);
 }
 
 namespace octave
 {
-  /*!
-    Evaluate an Octave function (built-in or interpreted) and return
-    the list of result values.
-
-    @param args The first element of @c args is the function to call.
-    It may be the name of the function as a string, a function
-    handle, or an inline function.  The remaining arguments are
-    passed to the function.
-    @param nargout The number of output arguments expected.
-    @return A list of output values.  The length of the list is not
-    necessarily the same as @c nargout.
-  */
+  //! Evaluate an Octave function (built-in or interpreted) and return
+  //! the list of result values.
+  //!
+  //! @param args The first element of @c args is the function to call.
+  //!             It may be the name of the function as a string, a function
+  //!             handle, or an inline function.  The remaining arguments are
+  //!             passed to the function.
+  //! @param nargout The number of output arguments expected.
+  //! @return A list of output values.  The length of the list is not
+  //!         necessarily the same as @c nargout.
+
   octave_value_list
   feval (const octave_value_list& args, int nargout)
   {
     if (args.length () > 0)
       {
         octave_value f_arg = args(0);
 
         octave_value_list tmp_args = get_feval_args (args);
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -39,94 +39,93 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "lo-traits.h"
 #include "lo-utils.h"
 #include "oct-refcount.h"
 #include "oct-sort.h"
 #include "quit.h"
 
 //! N Dimensional Array with copy-on-write semantics.
-/*!
-    The Array class is at the root of Octave.  It provides a container
-    with an arbitrary number of dimensions.  The operator () provides
-    access to individual elements via subscript and linear indexing.
-    Indexing starts at 0.  Arrays are column-major order as in Fortran.
-
-    @code{.cc}
-    // 3 D Array with 10 rows, 20 columns, and 5 pages, filled with 7.0
-    Array<double> A Array<double (dim_vector (10, 20, 5), 7.0);
-
-    // set value for row 0, column 10, and page 3
-    A(0, 10, 3) = 2.5;
-
-    // get value for row 1, column 2, and page 0
-    double v = A(1, 2, 0);
-
-    // get value for 25th element (row 4, column 3, page 1)
-    double v = A(24);
-    @endcode
-
-    ## Notes on STL compatibility
-
-    ### size() and length()
-
-    To access the total number of elements in an Array, use numel()
-    which is short for number of elements and is equivalent to the
-    Octave function with same name.
-
-    @code{.cc}
-    Array<int> A (dim_vector (10, 20, 4), 1);
-
-    octave_idx_type n = A.numel (); // returns 800 (10x20x4)
-
-    octave_idx_type nr = A.size (0); // returns 10 (number of rows/dimension 0)
-    octave_idx_type nc = A.size (1); // returns 20 (number of columns)
-    octave_idx_type nc = A.size (2); // returns 4 (size of dimension 3)
-    octave_idx_type l6 = A.size (6); // returns 1 (implicit singleton dimension)
+//!
+//! The Array class is at the root of Octave.  It provides a container
+//! with an arbitrary number of dimensions.  The operator () provides
+//! access to individual elements via subscript and linear indexing.
+//! Indexing starts at 0.  Arrays are column-major order as in Fortran.
+//!
+//! @code{.cc}
+//! // 3 D Array with 10 rows, 20 columns, and 5 pages, filled with 7.0
+//! Array<double> A Array<double (dim_vector (10, 20, 5), 7.0);
+//!
+//! // set value for row 0, column 10, and page 3
+//! A(0, 10, 3) = 2.5;
+//!
+//! // get value for row 1, column 2, and page 0
+//! double v = A(1, 2, 0);
+//!
+//! // get value for 25th element (row 4, column 3, page 1)
+//! double v = A(24);
+//! @endcode
+//!
+//! ## Notes on STL compatibility
+//!
+//! ### size() and length()
+//!
+//! To access the total number of elements in an Array, use numel()
+//! which is short for number of elements and is equivalent to the
+//! Octave function with same name.
+//!
+//! @code{.cc}
+//! Array<int> A (dim_vector (10, 20, 4), 1);
+//!
+//! octave_idx_type n = A.numel (); // returns 800 (10x20x4)
+//!
+//! octave_idx_type nr = A.size (0); // returns 10 (number of rows/dimension 0)
+//! octave_idx_type nc = A.size (1); // returns 20 (number of columns)
+//! octave_idx_type nc = A.size (2); // returns 4 (size of dimension 3)
+//! octave_idx_type l6 = A.size (6); // returns 1 (implicit singleton dimension)
+//!
+//! // Alternatively, get a dim_vector which represents the dimensions.
+//! dim_vector dims = A.dims ();
+//! @endcode
+//!
+//! The methods size() and length() as they exist in the STL cause
+//! confusion in the context of a N dimensional array.
+//!
+//! The size() of an array is the length of all dimensions.  In Octave,
+//! the size() function returns a row vector with the length of each
+//! dimension, or the size of a specific dimension.  Only the latter is
+//! present in liboctave.
+//!
+//! Since there is more than 1 dimension, length() would not make sense
+//! without expliciting which dimension.  If the function existed, which
+//! length should it return?  Octave length() function returns the length
+//! of the longest dimension which is an odd definition, only useful for
+//! vectors and square matrices.  The alternatives numel(), rows(),
+//! columns(), and size(d) are more explict and recommended.
+//!
+//! ### size_type
+//!
+//! Array::size_type is `octave_idx_type` which is a typedef for `int`
+//! or `long int`, depending whether Octave was configured for 64-bit
+//! indexing.
+//!
+//! This is a signed integer which may cause problems when mixed with
+//! STL containers.  The reason is that Octave interacts with Fortran
+//! routines, providing an interface many Fortran numeric libraries.
+//!
+//! ## Subclasses
+//!
+//! The following subclasses specializations, will be of most use:
+//!   - Matrix: Array<double> with only 2 dimensions
+//!   - ComplexMatrix: Array<std::complex<double>> with only 2 dimensions
+//!   - boolNDArray: N dimensional Array<bool>
+//!   - ColumnVector: Array<double> with 1 column
+//!   - string_vector: Array<std::string> with 1 column
+//!   - Cell: Array<octave_value>, equivalent to an Octave cell.
 
-    // Alternatively, get a dim_vector which represents the dimensions.
-    dim_vector dims = A.dims ();
-    @endcode
-
-    The methods size() and length() as they exist in the STL cause
-    confusion in the context of a N dimensional array.
-
-    The size() of an array is the length of all dimensions.  In Octave,
-    the size() function returns a row vector with the length of each
-    dimension, or the size of a specific dimension.  Only the latter is
-    present in liboctave.
-
-    Since there is more than 1 dimension, length() would not make sense
-    without expliciting which dimension.  If the function existed, which
-    length should it return?  Octave length() function returns the length
-    of the longest dimension which is an odd definition, only useful for
-    vectors and square matrices.  The alternatives numel(), rows(),
-    columns(), and size(d) are more explict and recommended.
-
-    ### size_type
-
-    Array::size_type is `octave_idx_type` which is a typedef for `int`
-    or `long int`, depending whether Octave was configured for 64-bit
-    indexing.
-
-    This is a signed integer which may cause problems when mixed with
-    STL containers.  The reason is that Octave interacts with Fortran
-    routines, providing an interface many Fortran numeric libraries.
-
-    ## Subclasses
-
-    The following subclasses specializations, will be of most use:
-      - Matrix: Array<double> with only 2 dimensions
-      - ComplexMatrix: Array<std::complex<double>> with only 2 dimensions
-      - boolNDArray: N dimensional Array<bool>
-      - ColumnVector: Array<double> with 1 column
-      - string_vector: Array<std::string> with 1 column
-      - Cell: Array<octave_value>, equivalent to an Octave cell.
-
-*/
 template <typename T>
 class
 Array
 {
 protected:
 
   //! The real representation of all arrays.
   class ArrayRep
@@ -339,25 +338,26 @@ public:
   //@{
   //! Number of elements in the array.
   //! Synonymous with numel().
   //! @note This method is deprecated in favour of numel().
   OCTAVE_DEPRECATED (4.4, "use 'numel' instead")
   octave_idx_type capacity (void) const { return numel (); }
 
   //! Number of elements in the array.
-  /*! Synonymous with numel().
-      @note This method is deprecated in favour of numel().
+  //!
+  //! Synonymous with numel().
+  //! @note This method is deprecated in favour of numel().
+  //!
+  //! @note
+  //! This is @em not the same as @c %length() at the Octave interpreter.
+  //! At the Octave interpreter, the function @c %length() returns the
+  //! length of the greatest dimension.  This method returns the total
+  //! number of elements.
 
-      @note
-      This is @em not the same as @c %length() at the Octave interpreter.
-      At the Octave interpreter, the function @c %length() returns the
-      length of the greatest dimension.  This method returns the total
-      number of elements.
-   */
   OCTAVE_DEPRECATED (4.4, "use 'numel' instead")
   octave_idx_type length (void) const { return numel (); }
 
   //! Number of elements in the array.
   //! Synonymous with numel().
   //! @note This method is deprecated in favour of numel().
   OCTAVE_DEPRECATED (4.4, "use 'numel' instead")
   octave_idx_type nelem (void) const { return numel (); }
@@ -417,22 +417,22 @@ public:
   //!
   //! Get the third dimension of the array (number of pages)
   //@{
   octave_idx_type dim3 (void) const { return dimensions(2); }
   octave_idx_type pages (void) const { return dim3 (); }
   //@}
 
   //! Size of the specified dimension.
-  /*!
-      Dimensions beyond the Array number of dimensions return 1 as
-      those are implicit singleton dimensions.
+  //!
+  //! Dimensions beyond the Array number of dimensions return 1 as
+  //! those are implicit singleton dimensions.
+  //!
+  //! Equivalent to Octave's `size (A, DIM)`
 
-      Equivalent to Octave's `size (A, DIM)`
-  */
   size_type size (const size_type d) const
   {
     // Should we throw for negative values?
     // Should >= ndims () be handled by dim_vector operator() instead ?
     return d >= ndims () ? 1 : dimensions(d);
   }
 
   size_t byte_size (void) const
@@ -717,17 +717,17 @@ public:
   { return issorted (mode); }
 
   //! Sort by rows returns only indices.
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
 
   //! Ordering is auto-detected or can be specified.
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
-  //! @brief Do a binary lookup in a sorted array.  Must not contain NaNs.
+  //! Do a binary lookup in a sorted array.  Must not contain NaNs.
   //! Mode can be specified or is auto-detected by comparing 1st and last element.
   octave_idx_type lookup (const T& value, sortmode mode = UNSORTED) const;
 
   //! Ditto, but for an array of values, specializing on the case when values
   //! are sorted.  NaNs get the value N.
   Array<octave_idx_type> lookup (const Array<T>& values,
                                  sortmode mode = UNSORTED) const;
 
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -32,63 +32,62 @@ along with Octave; see the file COPYING.
 #include <initializer_list>
 #include <string>
 
 #include "oct-refcount.h"
 
 template <typename T> class Array;
 
 //! Vector representing the dimensions (size) of an Array.
-/*!
-  A dim_vector is used to represent dimensions of an Array.  It is used
-  on its constructor to specify its size, or when reshaping it.
-
-  @code{.cc}
-  // Matrix with 10 rows and 20 columns.
-  Matrix m Matrix (dim_vector (10, 20));
-
-  // Change its size to 5 rows and 40 columns.
-  Matrix m2 = m.reshape (dim_vector (5, 40));
-
-  // Five dimensional Array of length 10, 20, 3, 8, 7 on each dimension.
-  NDArray a (dim_vector (10, 20, 3, 8, 7));
-
-  // Uninitialized array of same size as other.
-  NDArray b (a.dims ());
-  @endcode
-
-  The main thing to understand about this class, is that methods such as
-  ndims() and numel(), return the value for an Array of these dimensions,
-  not the actual number of elements in the dim_vector.
-
-  @code{.cc}
-  dim_vector d (10, 5, 3);
-  octave_idx_type n = d.numel (); // returns 150
-  octave_idx_type nd = d.ndims (); // returns 3
-  @endcode
-
-  ## Implementation details ##
-
-  This implementation is more tricky than Array, but the big plus is that
-  dim_vector requires only one allocation instead of two.  It is (slightly)
-  patterned after GCC's basic_string implementation.  rep is a pointer to an
-  array of memory, comprising count, length, and the data:
-
-  @verbatim
-          <count>
-          <ndims>
-  rep --> <dims[0]>
-          <dims[1]>
-          ...
-  @endverbatim
-
-  The inlines count(), ndims() recover this data from the rep.  Note
-  that rep points to the beginning of dims to grant faster access
-  (reinterpret_cast is assumed to be an inexpensive operation).
-*/
+//!
+//! A dim_vector is used to represent dimensions of an Array.  It is used
+//! on its constructor to specify its size, or when reshaping it.
+//!
+//! @code{.cc}
+//! // Matrix with 10 rows and 20 columns.
+//! Matrix m Matrix (dim_vector (10, 20));
+//!
+//! // Change its size to 5 rows and 40 columns.
+//! Matrix m2 = m.reshape (dim_vector (5, 40));
+//!
+//! // Five dimensional Array of length 10, 20, 3, 8, 7 on each dimension.
+//! NDArray a (dim_vector (10, 20, 3, 8, 7));
+//!
+//! // Uninitialized array of same size as other.
+//! NDArray b (a.dims ());
+//! @endcode
+//!
+//! The main thing to understand about this class, is that methods such as
+//! ndims() and numel(), return the value for an Array of these dimensions,
+//! not the actual number of elements in the dim_vector.
+//!
+//! @code{.cc}
+//! dim_vector d (10, 5, 3);
+//! octave_idx_type n = d.numel (); // returns 150
+//! octave_idx_type nd = d.ndims (); // returns 3
+//! @endcode
+//!
+//! ## Implementation details ##
+//!
+//! This implementation is more tricky than Array, but the big plus is that
+//! dim_vector requires only one allocation instead of two.  It is (slightly)
+//! patterned after GCC's basic_string implementation.  rep is a pointer to an
+//! array of memory, comprising count, length, and the data:
+//!
+//! @verbatim
+//!        <count>
+//!        <ndims>
+//! rep --> <dims[0]>
+//!        <dims[1]>
+//!        ...
+//! @endverbatim
+//!
+//! The inlines count(), ndims() recover this data from the rep.  Note
+//! that rep points to the beginning of dims to grant faster access
+//! (reinterpret_cast is assumed to be an inexpensive operation).
 
 class
 OCTAVE_API
 dim_vector
 {
 private:
 
   octave_idx_type *rep;
@@ -159,51 +158,50 @@ private:
 
         rep = new_rep;
       }
   }
 
 public:
 
   //! Construct dim_vector for a N dimensional array.
-  /*!
-
-    Each argument to constructor defines the length of an additional
-    dimension.  A dim_vector always represents a minimum of 2 dimensions
-    (just like an Array has at least 2 dimensions) and there is no
-    upper limit on the number of dimensions.
-
-    @code{.cc}
-    dim_vector dv (7, 5);
-    Matrix mat (dv);
-    @endcode
-
-    The constructed dim_vector @c dv will have two elements, @f$[7, 5]@f$,
-    one for each dimension.  It can then be used to construct a Matrix
-    with such dimensions, i.e., 7 rows and 5 columns.
+  //!
+  //! Each argument to constructor defines the length of an additional
+  //! dimension.  A dim_vector always represents a minimum of 2 dimensions
+  //! (just like an Array has at least 2 dimensions) and there is no
+  //! upper limit on the number of dimensions.
+  //!
+  //! @code{.cc}
+  //! dim_vector dv (7, 5);
+  //! Matrix mat (dv);
+  //! @endcode
+  //!
+  //! The constructed dim_vector @c dv will have two elements, @f$[7, 5]@f$,
+  //! one for each dimension.  It can then be used to construct a Matrix
+  //! with such dimensions, i.e., 7 rows and 5 columns.
+  //!
+  //! @code{.cc}
+  //! NDArray x (dim_vector (7, 5, 10));
+  //! @endcode
+  //!
+  //! This will construct a 3 dimensional NDArray of lengths 7, 5, and 10,
+  //! on the first, second, and third dimension (rows, columns, and pages)
+  //! respectively.
+  //!
+  //! Note that that there is no constructor that accepts only one
+  //! dimension length to avoid confusion.  The source for such confusion
+  //! is that constructor could mean:
+  //!   - a column vector, i.e., assume @f$[N, 1]@f$;
+  //!   - a square matrix, i.e., as is common in Octave interpreter;
+  //!   - support for a 1 dimensional Array (does not exist);
+  //!
+  //! Using r, c, and lengths... as arguments, allow us to check at compile
+  //! time that there's at least 2 dimensions specified, while maintaining
+  //! type safety.
 
-    @code{.cc}
-    NDArray x (dim_vector (7, 5, 10));
-    @endcode
-
-    This will construct a 3 dimensional NDArray of lengths 7, 5, and 10,
-    on the first, second, and third dimension (rows, columns, and pages)
-    respectively.
-
-    Note that that there is no constructor that accepts only one
-    dimension length to avoid confusion.  The source for such confusion
-    is that constructor could mean:
-      - a column vector, i.e., assume @f$[N, 1]@f$;
-      - a square matrix, i.e., as is common in Octave interpreter;
-      - support for a 1 dimensional Array (does not exist);
-
-    Using r, c, and lengths... as arguments, allow us to check at compile
-    time that there's at least 2 dimensions specified, while maintaining
-    type safety.
-  */
   template <typename... Ints>
   dim_vector (const octave_idx_type r, const octave_idx_type c,
               Ints... lengths) : rep (newrep (2 + sizeof... (Ints)))
   {
     std::initializer_list<octave_idx_type> all_lengths = {r, c, lengths...};
     for (const octave_idx_type l: all_lengths)
       *rep++ = l;
     rep -= all_lengths.size ();
@@ -284,30 +282,30 @@ public:
 
   ~dim_vector (void)
   {
     if (OCTAVE_ATOMIC_DECREMENT (&(count ())) == 0)
       freerep ();
   }
 
   //! Number of dimensions.
-  /*!
-      Returns the number of dimensions of the dim_vector.  This is number of
-      elements in the dim_vector including trailing singletons.  It is also
-      the number of dimensions an Array with this dim_vector would have.
-  */
+  //!
+  //! Returns the number of dimensions of the dim_vector.  This is number of
+  //! elements in the dim_vector including trailing singletons.  It is also
+  //! the number of dimensions an Array with this dim_vector would have.
+
   octave_idx_type ndims (void) const { return rep[-1]; }
 
   //! Number of dimensions.
   //! Synonymous with ndims().
-  /*!
-    While this method is not officially deprecated, consider using ndims()
-    instead to avoid confusion.  Array does not have length because of its
-    odd definition as length of the longest dimension.
-  */
+  //!
+  //! While this method is not officially deprecated, consider using ndims()
+  //! instead to avoid confusion.  Array does not have length because of its
+  //! odd definition as length of the longest dimension.
+
   int length (void) const { return ndims (); }
 
   octave_idx_type& operator () (int i) { return elem (i); }
 
   octave_idx_type operator () (int i) const { return elem (i); }
 
   void resize (int n, int fill_value = 0)
   {
@@ -351,43 +349,40 @@ public:
   int num_ones (void) const;
 
   bool all_ones (void) const
   {
     return (num_ones () == ndims ());
   }
 
   //! Number of elements that a matrix with this dimensions would have.
-  /*!
-     Return the number of elements that a matrix with this dimension
-     vector would have, NOT the number of dimensions (elements in the
-     dimension vector).
-  */
+  //!
+  //! Return the number of elements that a matrix with this dimension
+  //! vector would have, NOT the number of dimensions (elements in the
+  //! dimension vector).
 
   octave_idx_type numel (int n = 0) const
   {
     int n_dims = ndims ();
 
     octave_idx_type retval = 1;
 
     for (int i = n; i < n_dims; i++)
       retval *= elem (i);
 
     return retval;
   }
 
-  /*!
-     The following function will throw a std::bad_alloc ()
-     exception if the requested size is larger than can be indexed by
-     octave_idx_type.  This may be smaller than the actual amount of
-     memory that can be safely allocated on a system.  However, if we
-     don't fail here, we can end up with a mysterious crash inside a
-     function that is iterating over an array using octave_idx_type
-     indices.
-  */
+  //! The following function will throw a std::bad_alloc ()
+  //! exception if the requested size is larger than can be indexed by
+  //! octave_idx_type.  This may be smaller than the actual amount of
+  //! memory that can be safely allocated on a system.  However, if we
+  //! don't fail here, we can end up with a mysterious crash inside a
+  //! function that is iterating over an array using octave_idx_type
+  //! indices.
 
   octave_idx_type safe_numel (void) const;
 
   bool any_neg (void) const
   {
     return std::any_of (rep, rep + ndims (),
                         [] (octave_idx_type dim) { return dim < 0; });
   }
@@ -396,22 +391,21 @@ public:
 
   //! This corresponds to cat().
   bool concat (const dim_vector& dvb, int dim);
 
   //! This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1).
   // The rules are more relaxed here.
   bool hvcat (const dim_vector& dvb, int dim);
 
-  /*!
-      Force certain dimensionality, preserving numel ().  Missing
-      dimensions are set to 1, redundant are folded into the trailing
-      one.  If n = 1, the result is 2d and the second dim is 1
-      (dim_vectors are always at least 2D).
-  */
+  //! Force certain dimensionality, preserving numel ().  Missing
+  //! dimensions are set to 1, redundant are folded into the trailing
+  //! one.  If n = 1, the result is 2d and the second dim is 1
+  //! (dim_vectors are always at least 2D).
+
   dim_vector redim (int n) const;
 
   dim_vector as_column (void) const
   {
     if (ndims () == 2 && xelem (1) == 1)
       return *this;
     else
       return dim_vector (numel (), 1);
@@ -498,21 +492,19 @@ public:
   {
     octave_idx_type k = 0;
     for (int i = nidx - 1; i >= 0; i--)
       k = rep[i] * k + idx[i];
 
     return k;
   }
 
-  /*/!
-      Increment a multi-dimensional index tuple, optionally starting
-      from an offset position and return the index of the last index
-      position that was changed, or length () if just cycled over.
-  */
+  //! Increment a multi-dimensional index tuple, optionally starting
+  //! from an offset position and return the index of the last index
+  //! position that was changed, or length () if just cycled over.
 
   int increment_index (octave_idx_type *idx, int start = 0) const
   {
     int i;
     for (i = start; i < ndims (); i++)
       {
         if (++(*idx) == rep[i])
           *idx++ = 0;
diff --git a/liboctave/util/oct-string.h b/liboctave/util/oct-string.h
--- a/liboctave/util/oct-string.h
+++ b/liboctave/util/oct-string.h
@@ -22,101 +22,101 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_oct_string_h)
 #define octave_oct_string_h 1
 
 #include "octave-config.h"
 
 namespace octave
 {
   //! Octave string utility functions.
-  /*!
-      This functions provide a C++ interface to most string functions
-      available in the Octave interpreter.
-
-      Specializations for Array may consider its dimensions in addition
-      to the actual string contents.
+  //!
+  //! This functions provide a C++ interface to most string functions
+  //! available in the Octave interpreter.
+  //!
+  //! Specializations for Array may consider its dimensions in addition
+  //! to the actual string contents.
+  //!
+  //! @attention
+  //! Octave's string comparison functions return true when strings are
+  //! are equal, just the opposite of the corresponding C library functions.
+  //! In addition, Octave's function only return bool and do not check
+  //! lexicographical order.
 
-      @attention
-      Octave's string comparison functions return true when strings are
-      are equal, just the opposite of the corresponding C library functions.
-      In addition, Octave's function only return bool and do not check
-      lexicographical order.
-  */
   namespace string
   {
     //! True if strings are the same.
-    /*!
-        ## Specialization for Array<char>
+    //!
+    //! ## Specialization for Array<char>
+    //!
+    //! When comparing whole Array of chars, the actual Array dimensions
+    //! are significant.  A column vector and row vector with the same
+    //! char array, will still return false.
 
-        When comparing whole Array of chars, the actual Array dimensions
-        are significant.  A column vector and row vector with the same
-        char array, will still return false.
-    */
     template <typename T>
     bool strcmp (const T& str_a, const T& str_b);
 
     //! True if string is the same as character sequence.
-    /*!
-        Compares a string to the null-terminated character sequence
-        beginning at the character pointed to by str_b.
+    //!
+    //! Compares a string to the null-terminated character sequence
+    //! beginning at the character pointed to by str_b.
+    //!
+    //! ## Specialization for Array<char>
+    //!
+    //! For purposes of comparison of dimensions, the character sequence
+    //! is considered to be a row vector.
 
-        ## Specialization for Array<char>
-
-        For purposes of comparison of dimensions, the character sequence
-        is considered to be a row vector.
-    */
     template <typename T>
     bool strcmp (const T& str_a, const typename T::value_type *str_b);
 
     //! True if strings are the same, ignoring case.
-    /*!
-        ## Specialization for Array<char>
+    //!
+    //! ## Specialization for Array<char>
+    //!
+    //! When comparing whole Array of chars, the actual Array dimensions
+    //! are significant.  A column vector and row vector with the same
+    //! char array, will still return false.
 
-        When comparing whole Array of chars, the actual Array dimensions
-        are significant.  A column vector and row vector with the same
-        char array, will still return false.
-    */
     template <typename T>
     bool strcmpi (const T& str_a, const T& str_b);
 
     //! True if string is the same as character sequence, ignoring case.
-    /*!
-        ## Specialization for Array<char>
+    //!
+    //! ## Specialization for Array<char>
+    //!
+    //! For purposes of comparison of dimensions, the character sequence
+    //! is considered to be a row vector.
 
-        For purposes of comparison of dimensions, the character sequence
-        is considered to be a row vector.
-    */
     template <typename T>
     bool strcmpi (const T& str_a, const typename T::value_type *str_b);
 
     //! True if the first N characters are the same.
-    /*!
-        ## Specialization for Array<char>
+    //!
+    //! ## Specialization for Array<char>
+    //!
+    //! The comparison is done in the first N characters, the actual
+    //! dimensions of the Array are irrelevant.  A row vector and
+    //! a column vector of the same still return true.
 
-        The comparison is done in the first N characters, the actual
-        dimensions of the Array are irrelevant.  A row vector and
-        a column vector of the same still return true.
-    */
     template <typename T>
     bool strncmp (const T& str_a, const T& str_b,
                   const typename T::size_type n);
 
     //! True if the first N characters are the same.
     template <typename T>
     bool strncmp (const T& str_a, const typename T::value_type *str_b,
                   const typename T::size_type n);
 
     //! True if the first N characters are the same, ignoring case.
-    /*!
-        ## Specialization for Array<char>
+    //!
+    //! ## Specialization for Array<char>
+    //!
+    //! The comparison is done in the first N characters, the actual
+    //! dimensions of the Array are irrelevant.  A row vector and
+    //! a column vector of the same still return true.
 
-        The comparison is done in the first N characters, the actual
-        dimensions of the Array are irrelevant.  A row vector and
-        a column vector of the same still return true.
-    */
     template <typename T>
     bool strncmpi (const T& str_a, const T& str_b,
                    const typename T::size_type n);
 
     //! True if the first N characters are the same, ignoring case.
     template <typename T>
     bool strncmpi (const T& str_a, const typename T::value_type *str_b,
                    const typename T::size_type n);
diff --git a/liboctave/util/str-vec.h b/liboctave/util/str-vec.h
--- a/liboctave/util/str-vec.h
+++ b/liboctave/util/str-vec.h
@@ -45,22 +45,22 @@ public:
   string_vector (const char *s)
     : Array<std::string> (dim_vector (1, 1), s) { }
 
   string_vector (const std::string& s)
     : Array<std::string> (dim_vector (1, 1), s) { }
 
   string_vector (const string_vector& s) : Array<std::string> (s) { }
 
-  //! Constructor for STL containers of std::string
-  /*!
-    Templated constructor for any template class with std::string as the
-    first parameter, and begin, end, and size methods, i.e., a class with
-    similar interface as the STL containers.
-  */
+  //! Constructor for STL containers of std::string.
+  //!
+  //! Templated constructor for any template class with std::string as the
+  //! first parameter, and begin, end, and size methods, i.e., a class with
+  //! similar interface as the STL containers.
+
   template<template <typename...> class String_Container, typename... Other>
   string_vector (const String_Container<std::string, Other...>& lst);
 
   string_vector (const Array<std::string>& s)
     : Array<std::string> (s.as_column ()) { }
 
   string_vector (const char * const *s);
 
