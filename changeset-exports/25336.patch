# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1525235400 14400
#      Wed May 02 00:30:00 2018 -0400
# Node ID 389757b7b6af603b3aafe07d695c0b08d055b805
# Parent  28641f4be5defa646d92917d2bcf8c07a0d95a40
eliminate redundant octave:: namespace tags

* documentation-dock-widget.cc, documentation-dock-widget.h,
documentation.cc, files-dock-widget.cc, file-editor-tab.cc,
file-editor.cc, octave-cmd.cc, webinfo.cc, resource-manager.cc,
environment.cc, ft-text-renderer.cc, gl2ps-print.cc, gtk-manager.cc,
help.cc, oct-stream.cc, sighandlers.cc, symtab.cc, bp-table.cc,
comment-list.h, jit-typeinfo.cc, oct-parse.in.yy, pt-cbinop.cc,
pt-eval.cc, pt-idx.cc, pt-jit.cc, cmd-edit.cc:
Eliminate octave:: namespace tags inside octave namespace.
Style fixes.

diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -34,17 +34,17 @@ namespace octave
   documentation_dock_widget::documentation_dock_widget (QWidget *p)
     : octave_dock_widget (p)
   {
     setObjectName ("DocumentationDockWidget");
     setWindowIcon (QIcon (":/actions/icons/logo.png"));
     set_title (tr ("Documentation"));
     setStatusTip (tr ("See the documentation for help."));
 
-    m_docs = new octave::documentation (this);
+    m_docs = new documentation (this);
     setWidget (m_docs);
 
     connect (p, SIGNAL (show_doc_signal (const QString&)),
              this, SLOT (showDoc (const QString&)));
 
     connect (p, SIGNAL (register_doc_signal (const QString&)),
              this, SLOT (registerDoc (const QString&)));
 
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -48,13 +48,13 @@ namespace octave
     void selectAll (void);
 
     void showDoc (const QString & name);
     void registerDoc (const QString & name);
     void unregisterDoc (const QString & name);
 
   private:
 
-    octave::documentation *m_docs;
+    documentation *m_docs;
   };
 }
 
 #endif
diff --git a/libgui/src/documentation.cc b/libgui/src/documentation.cc
--- a/libgui/src/documentation.cc
+++ b/libgui/src/documentation.cc
@@ -54,28 +54,28 @@ namespace octave
   // The documentation splitter, which is the main widget
   // of the doc dock widget
   documentation::documentation (QWidget *p)
     : QSplitter (Qt::Horizontal, p)
   {
     // Get original collection
     QString collection = getenv ("OCTAVE_QTHELP_COLLECTION");
     if (collection.isEmpty ())
-      collection = QString::fromStdString (octave::config::oct_doc_dir ()
-                                           + octave::sys::file_ops::dir_sep_str ()
+      collection = QString::fromStdString (config::oct_doc_dir ()
+                                           + sys::file_ops::dir_sep_str ()
                                            + "octave_interpreter.qhc");
 
     // Setup the help engine with the original collection, use a writable copy
     // of the original collection and load the help data
     m_help_engine = new QHelpEngine (collection, this);
 
     QString tmpdir = QDir::tempPath();
     m_collection
-      = QString::fromStdString (octave::sys::tempnam (tmpdir.toStdString (),
-                                                      "oct-qhelp-"));
+      = QString::fromStdString (sys::tempnam (tmpdir.toStdString (),
+                                              "oct-qhelp-"));
 
     if (m_help_engine->copyCollectionFile (m_collection))
       m_help_engine->setCollectionFile (m_collection);
     else
       QMessageBox::warning (this, tr ("Octave Documentation"),
                             tr ("Could not copy help collection to temporary\n"
                                 "file. Search capabilities may be affected.\n"
                                 "%1").arg (m_help_engine->error ()));
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -818,18 +818,17 @@ namespace octave
 
     if (m_sync_octave_dir)
       display_directory (m_octave_dir);  // sync browser to octave dir
 
   }
 
   void files_dock_widget::popdownmenu_home (bool)
   {
-    QString dir
-      = QString::fromStdString (octave::sys::env::get_home_directory ());
+    QString dir = QString::fromStdString (sys::env::get_home_directory ());
 
     if (dir.isEmpty ())
       dir = QDir::homePath ();
 
     set_current_directory (dir);
   }
 
   void files_dock_widget::popdownmenu_search_dir (bool)
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -392,18 +392,18 @@ namespace octave
           {
             try
               {
                 // Suppress error messages on the console.
                 unwind_protect frame;
                 frame.protect_var (buffer_error_messages);
                 buffer_error_messages++;
 
-                octave::bp_table& bptab
-                  = octave::__get_bp_table__ ("handle_context_menu_break_condition");
+                bp_table& bptab
+                  = __get_bp_table__ ("handle_context_menu_break_condition");
 
                 bptab.condition_valid (new_condition.toStdString ());
                 valid = true;
               }
             catch (const index_exception& e) { }
             catch (const execution_exception& e) { }
             catch (const interrupt_exception&)
               {
@@ -708,18 +708,17 @@ namespace octave
               {
                 // octave: get keywords from internal informations depending on
                 //         user preferences
 
                 // keywords are always used
                 add_octave_apis (Fiskeyword ());            // add new entries
 
                 interpreter& interp
-                  = __get_interpreter__ (
-                      "file_editor_tab::update_lexer_settings");
+                  = __get_interpreter__ ("file_editor_tab::update_lexer_settings");
 
                 if (octave_builtins)
                   add_octave_apis (F__builtins__ (interp));       // add new entries
 
                 if (octave_functions)
                   add_octave_apis (F__list_functions__ (interp)); // add new entries
 
               }
@@ -990,43 +989,40 @@ namespace octave
 
   void file_editor_tab::add_breakpoint_callback (const bp_info& info)
   {
     bp_table::intmap line_info;
     line_info[0] = info.line;
 
     if (octave_qt_link::file_in_path (info.file, info.dir))
       {
-        octave::bp_table& bptab
-          = octave::__get_bp_table__ ("octave_qt_link::file_in_path");
+        bp_table& bptab = __get_bp_table__ ("octave_qt_link::file_in_path");
 
         bptab.add_breakpoint (info.function_name, line_info, info.condition);
       }
   }
 
   void file_editor_tab::remove_breakpoint_callback (const bp_info& info)
   {
     bp_table::intmap line_info;
     line_info[0] = info.line;
 
     if (octave_qt_link::file_in_path (info.file, info.dir))
       {
-        octave::bp_table& bptab
-          = octave::__get_bp_table__ ("remove_breakpoint_callback");
+        bp_table& bptab = __get_bp_table__ ("remove_breakpoint_callback");
 
         bptab.remove_breakpoint (info.function_name, line_info);
       }
   }
 
   void file_editor_tab::remove_all_breakpoints_callback (const bp_info& info)
   {
     if (octave_qt_link::file_in_path (info.file, info.dir))
       {
-        octave::bp_table& bptab
-          = octave::__get_bp_table__ ("remove_all_breakpoints_callback");
+        bp_table& bptab = __get_bp_table__ ("remove_all_breakpoints_callback");
 
         bptab.remove_all_breakpoints_in_file (info.function_name, true);
       }
   }
 
   file_editor_tab::bp_info::bp_info (const QString& fname, int l,
                                      const QString& cond)
     : line (l), file (fname.toStdString ()), condition (cond.toStdString ())
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -1485,17 +1485,17 @@ namespace octave
       {
         foreach (QUrl url, e->mimeData ()->urls ())
           request_open_file (url.toLocalFile ());
       }
   }
 
   bool file_editor::is_editor_console_tabbed (void)
   {
-    octave::main_window *w = static_cast<octave::main_window *>(main_win ());
+    main_window *w = static_cast<main_window *>(main_win ());
     QList<QDockWidget *> w_list = w->tabifiedDockWidgets (this);
     QDockWidget *console =
       static_cast<QDockWidget *> (w->get_dock_widget_list ().at (0));
 
     for (int i = 0; i < w_list.count (); i++)
       {
         if (w_list.at (i) == console)
           return true;
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -32,50 +32,50 @@ along with Octave; see the file COPYING.
 #include "cmd-edit.h"
 #include "builtin-defun-decls.h"
 #include "utils.h"
 
 namespace octave
 {
   void octave_cmd_exec::execute (void)
   {
-    std::string pending_input = octave::command_editor::get_current_line ();
+    std::string pending_input = command_editor::get_current_line ();
 
-    octave::command_editor::set_initial_input (pending_input);
-    octave::command_editor::replace_line (m_cmd.toStdString ());
-    octave::command_editor::redisplay ();
-    octave::command_editor::accept_line ();
+    command_editor::set_initial_input (pending_input);
+    command_editor::replace_line (m_cmd.toStdString ());
+    command_editor::redisplay ();
+    command_editor::accept_line ();
   }
 
   void octave_cmd_eval::execute (void)
   {
     QString function_name = m_info.fileName ();
     function_name.chop (m_info.suffix ().length () + 1);
     std::string file_path = m_info.absoluteFilePath ().toStdString ();
 
-    std::string pending_input = octave::command_editor::get_current_line ();
+    std::string pending_input = command_editor::get_current_line ();
 
     if (valid_identifier (function_name.toStdString ()))
       {
         // valid identifier: call as function with possibility to debug
         std::string path = m_info.absolutePath ().toStdString ();
         if (octave_qt_link::file_in_path (file_path, path))
-          octave::command_editor::replace_line (function_name.toStdString ());
+          command_editor::replace_line (function_name.toStdString ());
       }
     else
       {
         // no valid identifier: use Fsource (), no debug possible
         Fsource (ovl (file_path));
-        octave::command_editor::replace_line ("");
+        command_editor::replace_line ("");
       }
 
-    octave::command_editor::set_initial_input (pending_input);
-    octave::command_editor::redisplay ();
+    command_editor::set_initial_input (pending_input);
+    command_editor::redisplay ();
 
-    octave::command_editor::accept_line ();
+    command_editor::accept_line ();
   }
 
   void octave_cmd_debug::execute (void)
   {
     if (m_cmd == "step")
       {
         F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
         Fdbstep ();
@@ -88,17 +88,17 @@ namespace octave
     else if (m_cmd == "quit")
       Fdbquit ();
     else
       {
         F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
         Fdbstep (ovl (m_cmd.toStdString ()));
       }
 
-    octave::command_editor::interrupt (true);
+    command_editor::interrupt (true);
   }
 
   // add a command to the queue
 
   void octave_command_queue::add_cmd (octave_cmd *cmd)
   {
     m_queue_mutex.lock ();
     m_queue.append (cmd);
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -51,17 +51,17 @@ namespace octave
     vbox_layout->setMargin (0);
     setLayout (vbox_layout);
 
     QHBoxLayout *hbox_layout = new QHBoxLayout ();
     hbox_layout->setMargin (0);
     hbox_layout->setSpacing (0);
     vbox_layout->addLayout (hbox_layout);
 
-    _tab_bar = new octave::tab_bar (this);
+    _tab_bar = new tab_bar (this);
     _tab_bar->setSizePolicy (QSizePolicy::Preferred,QSizePolicy::Preferred);
     _tab_bar->setExpanding (false);
     _tab_bar->setTabsClosable (true);
 #if defined (HAVE_QTABWIDGET_SETMOVABLE)
     _tab_bar->setMovable (true);
 #endif
     hbox_layout->addWidget (_tab_bar);
 
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -50,21 +50,21 @@ along with Octave; see the file COPYING.
 
 namespace octave
 {
   resource_manager *resource_manager::instance = nullptr;
 
   static QString
   default_qt_settings_file (void)
   {
-    std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
+    std::string dsf = sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
 
     if (dsf.empty ())
-      dsf = (octave::config::oct_etc_dir ()
-             + octave::sys::file_ops::dir_sep_str ()
+      dsf = (config::oct_etc_dir ()
+             + sys::file_ops::dir_sep_str ()
              + "default-qt-settings");
 
     return QString::fromStdString (dsf);
   }
 
   resource_manager::resource_manager (void)
     : m_settings_directory (), m_settings_file (), m_settings (nullptr),
       m_default_settings (nullptr)
@@ -89,19 +89,19 @@ namespace octave
   {
     delete m_settings;
     delete m_default_settings;
   }
 
   QString resource_manager::get_gui_translation_dir (void)
   {
     // get environment variable for the locale dir (e.g. from run-octave)
-    std::string dldir = octave::sys::env::getenv ("OCTAVE_LOCALE_DIR");
+    std::string dldir = sys::env::getenv ("OCTAVE_LOCALE_DIR");
     if (dldir.empty ())
-      dldir = octave::config::oct_locale_dir (); // env-var empty, load the default location
+      dldir = config::oct_locale_dir (); // env-var empty, load the default location
     return QString::fromStdString (dldir);
   }
 
   void resource_manager::config_translators (QTranslator *qt_tr,
                                              QTranslator *qsci_tr,
                                              QTranslator *gui_tr)
   {
     bool loaded;
diff --git a/libinterp/corefcn/environment.cc b/libinterp/corefcn/environment.cc
--- a/libinterp/corefcn/environment.cc
+++ b/libinterp/corefcn/environment.cc
@@ -100,29 +100,29 @@ namespace octave
     return set_internal_variable (m_image_path, args, nargout, "IMAGE_PATH",
                                   false);
   }
 
   std::string environment::init_editor (void)
   {
     std::string retval = "emacs";
 
-    std::string env_editor = octave::sys::env::getenv ("EDITOR");
+    std::string env_editor = sys::env::getenv ("EDITOR");
 
     if (! env_editor.empty ())
       retval = env_editor;
 
     return retval;
   }
 
   std::string environment::init_exec_path (void)
   {
-    std::string exec_path = octave::sys::env::getenv ("OCTAVE_EXEC_PATH");
+    std::string exec_path = sys::env::getenv ("OCTAVE_EXEC_PATH");
 
-    std::string path_sep = octave::directory_path::path_sep_str ();
+    std::string path_sep = directory_path::path_sep_str ();
 
     if (exec_path.empty ())
       exec_path = (config::local_ver_arch_lib_dir () + path_sep
                    + config::local_api_arch_lib_dir () + path_sep
                    + config::local_arch_lib_dir () + path_sep
                    + config::arch_lib_dir () + path_sep
                    + config::bin_dir ());
 
@@ -130,24 +130,24 @@ namespace octave
 
     return exec_path;
   }
 
   std::string environment::init_image_path (void)
   {
     std::string image_path = ".";
 
-    std::string path_sep = octave::directory_path::path_sep_str ();
+    std::string path_sep = directory_path::path_sep_str ();
 
-    std::string env_path = octave::sys::env::getenv ("OCTAVE_IMAGE_PATH");
+    std::string env_path = sys::env::getenv ("OCTAVE_IMAGE_PATH");
 
     if (! env_path.empty ())
       image_path += path_sep + env_path;
 
-    std::string gen_path = octave::genpath (config::image_dir (), "");
+    std::string gen_path = genpath (config::image_dir (), "");
 
     if (! gen_path.empty ())
       image_path += path_sep + gen_path;
 
     return image_path;
   }
 }
 
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -221,17 +221,17 @@ namespace octave
         }
 
 
       // Default font file
       std::string file;
 
       if (! fonts_dir.empty ())
         {
-          file = fonts_dir + octave::sys::file_ops::dir_sep_str () + "FreeSans";
+          file = fonts_dir + sys::file_ops::dir_sep_str () + "FreeSans";
 
           if (weight == "bold")
             file += "Bold";
 
           if (angle == "italic" || angle == "oblique")
             file += "Oblique";
 
           file += ".otf";
@@ -342,17 +342,17 @@ namespace octave
     bool fontconfig_initialized;
   };
 
   ft_manager *ft_manager::instance = nullptr;
 
   static void
   ft_face_destroyed (void *object)
   {
-    octave::ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object));
+    ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object));
   }
 
   class
   OCTINTERP_API
   ft_text_renderer : public base_text_renderer
   {
   public:
 
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -260,22 +260,22 @@ namespace octave
     // that have been parsed by freetype.
     void fix_strlist_position (double x, double y, double z,
                                Matrix box, double rotation,
                                std::list<text_renderer::string>& lst);
 
     // Build an svg text element from a list of parsed strings.
     std::string strlist_to_svg (double x, double y, double z, Matrix box,
                                 double rotation,
-                                std::list<octave::text_renderer::string>& lst);
+                                std::list<text_renderer::string>& lst);
 
     // Build a list of postscript commands from a list of parsed strings.
     std::string strlist_to_ps (double x, double y, double z, Matrix box,
                                double rotation,
-                               std::list<octave::text_renderer::string>& lst);
+                               std::list<text_renderer::string>& lst);
 
     int alignment_to_mode (int ha, int va) const;
     FILE *fp;
     caseless_str term;
     double fontsize;
     std::string fontname;
     bool buffer_overflow;
   };
@@ -776,17 +776,17 @@ namespace octave
         str.insert (idx, 1, '\\');
         idx = str.find (chr, idx + 2);
       }
   }
 
   std::string
   gl2ps_renderer::strlist_to_svg (double x, double y, double z,
                                   Matrix box, double rotation,
-                                  std::list<octave::text_renderer::string>& lst)
+                                  std::list<text_renderer::string>& lst)
   {
     if (lst.empty ())
       return "";
 
     //Use pixel coordinates to conform to gl2ps
     ColumnVector coord_pix = get_transform ().transform (x, y, z, false);
 
     std::ostringstream os;
@@ -872,17 +872,17 @@ namespace octave
     os << "</text>";
 
     return os.str ();
   }
 
   std::string
   gl2ps_renderer::strlist_to_ps (double x, double y, double z,
                                  Matrix box, double rotation,
-                                 std::list<octave::text_renderer::string>& lst)
+                                 std::list<text_renderer::string>& lst)
   {
     // Translate and rotate coordinates in order to use bottom-left alignment
     fix_strlist_position (x, y, z, box, rotation, lst);
     Matrix prev_color (1, 3, -1);
 
     std::ostringstream ss;
     ss << "gsave\n";
 
diff --git a/libinterp/corefcn/gtk-manager.cc b/libinterp/corefcn/gtk-manager.cc
--- a/libinterp/corefcn/gtk-manager.cc
+++ b/libinterp/corefcn/gtk-manager.cc
@@ -47,17 +47,17 @@ namespace octave
         const_available_toolkits_iterator pa = available_toolkits.find (dtk);
 
         if (pa == available_toolkits.end ())
           error ("default graphics toolkit '%s' is not available!",
                  dtk.c_str ());
 
         octave_value_list args;
         args(0) = dtk;
-        octave::feval ("graphics_toolkit", args);
+        feval ("graphics_toolkit", args);
 
         pl = loaded_toolkits.find (dtk);
 
         if (pl == loaded_toolkits.end ())
           error ("failed to load %s graphics toolkit", dtk.c_str ());
 
         retval = pl->second;
       }
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -546,17 +546,17 @@ namespace octave
   }
 
   bool help_system::raw_help_from_file (const std::string& nm,
                                         std::string& h, std::string& file,
                                         bool& symbol_found) const
   {
     bool retval = false;
 
-    h = octave::get_help_from_file (nm, symbol_found, file);
+    h = get_help_from_file (nm, symbol_found, file);
 
     if (h.length () > 0)
       retval = true;
 
     return retval;
   }
 
   bool
@@ -685,18 +685,17 @@ namespace octave
 
     return symbol_found;
   }
 
   // FIXME: It's not likely that this does the right thing now.
 
   string_vector make_name_list (void)
   {
-    octave::help_system& help_sys
-      = octave::__get_help_system__ ("make_name_list");
+    help_system& help_sys = __get_help_system__ ("make_name_list");
 
     return help_sys.make_name_list ();
   }
 }
 
 DEFMETHOD (get_help_text, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{text}, @var{format}] =} get_help_text (@var{name})
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -86,28 +86,28 @@ namespace octave
     int retval = 0;
 
     double dval = 0.0;
 
     try
       {
         dval = tc.double_value ();
       }
-    catch (const octave::execution_exception&)
-      {
-        octave::interpreter::recover_from_exception ();
+    catch (const execution_exception&)
+      {
+        interpreter::recover_from_exception ();
 
         conv_err = 1;
       }
 
     if (! conv_err)
       {
         if (! lo_ieee_isnan (dval))
           {
-            int ival = octave::math::nint (dval);
+            int ival = math::nint (dval);
 
             if (ival == dval)
               retval = ival;
             else
               conv_err = 3;
           }
         else
           conv_err = 2;
@@ -119,29 +119,29 @@ namespace octave
   static octave_idx_type
   get_size (double d, const std::string& who)
   {
     octave_idx_type retval = -1;
 
     if (lo_ieee_isnan (d))
       ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
-    if (octave::math::isinf (d))
+    if (math::isinf (d))
       retval = -1;
     else
       {
         if (d < 0.0)
           ::error ("%s: negative value invalid as size specification",
                    who.c_str ());
 
         if (d > std::numeric_limits<octave_idx_type>::max ())
           ::error ("%s: dimension too large for Octave's index type",
                    who.c_str ());
 
-        retval = octave::math::nint_big (d);
+        retval = math::nint_big (d);
       }
 
     return retval;
   }
 
   static void
   get_size (const Array<double>& size,
             octave_idx_type& nr, octave_idx_type& nc,
@@ -164,17 +164,17 @@ namespace octave
         dnr = size(0);
 
         dnc = (dnr == 0.0) ? 0.0 : 1.0;
       }
     else if (sz_len == 2)
       {
         dnr = size(0);
 
-        if (octave::math::isinf (dnr))
+        if (math::isinf (dnr))
           ::error ("%s: invalid size specification", who.c_str ());
 
         dnc = size(1);
       }
     else
       ::error ("%s: invalid size specification", who.c_str ());
 
     nr = get_size (dnr, who);
@@ -4568,17 +4568,17 @@ namespace octave
 
   octave_value
   base_stream::do_scanf (scanf_format_list& fmt_list,
                          octave_idx_type nr, octave_idx_type nc,
                          bool one_elt_size_spec,
                          octave_idx_type& conversion_count,
                          const std::string& who)
   {
-    if (octave::application::interactive () && file_number () == 0)
+    if (application::interactive () && file_number () == 0)
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
 
     octave_value retval = Matrix ();
 
     conversion_count = 0;
 
     octave_idx_type nconv = fmt_list.num_conversions ();
@@ -4896,18 +4896,18 @@ namespace octave
                       }
 
                     // If it looks like we have a matching failure, then
                     // reset the failbit in the stream state.
                     if (is.rdstate () & std::ios::failbit)
                       is.clear (is.rdstate () & (~std::ios::failbit));
 
                     // FIXME: is this the right thing to do?
-                    if (octave::application::interactive ()
-                        && ! octave::application::forced_interactive ()
+                    if (application::interactive ()
+                        && ! application::forced_interactive ()
                         && name () == "stdin")
                       {
                         is.clear ();
 
                         // Skip to end of line.
                         bool err;
                         do_gets (-1, err, false, who);
                       }
@@ -5192,18 +5192,18 @@ namespace octave
       }
 
     if (ok () && is.fail ())
       {
         error ("%s: read error", who.c_str ());
 
         // FIXME: is this the right thing to do?
 
-        if (octave::application::interactive ()
-            && ! octave::application::forced_interactive ()
+        if (application::interactive ()
+            && ! application::forced_interactive ()
             && name () == "stdin")
           {
             // Skip to end of line.
             bool err;
             do_gets (-1, err, false, who);
           }
       }
 
@@ -5286,29 +5286,29 @@ namespace octave
 
   octave_value
   base_stream::do_textscan (const std::string& fmt,
                             octave_idx_type ntimes,
                             const octave_value_list& options,
                             const std::string& who,
                             octave_idx_type& read_count)
   {
-    if (octave::application::interactive () && file_number () == 0)
+    if (application::interactive () && file_number () == 0)
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
 
     octave_value retval = Cell (dim_vector (1, 1), Matrix (0, 1));
 
     std::istream *isp = input_stream ();
 
     if (! isp)
       invalid_operation (who, "reading");
     else
       {
-        octave::textscan scanner (who);
+        textscan scanner (who);
 
         retval = scanner.scan (*isp, fmt, ntimes, options, read_count);
       }
 
     return retval;
   }
 
   // Functions that are defined for all output streams
@@ -5431,17 +5431,17 @@ namespace octave
                     const NDArray val = curr_val.array_value ();
 
                     octave_idx_type idx = elt_idx;
 
                     for (; idx < n_elts; idx++)
                       {
                         double dval = val(idx);
 
-                        if (octave::math::x_nint (dval) != dval || dval < 0 || dval > 255)
+                        if (math::x_nint (dval) != dval || dval < 0 || dval > 255)
                           break;
                       }
 
                     octave_idx_type n = idx - elt_idx;
 
                     if (n > 0)
                       {
                         std::string sval (n, '\0');
@@ -5458,17 +5458,17 @@ namespace octave
             else
               {
                 retval = curr_val.fast_elem_extract (elt_idx++);
 
                 if (type == 'c' && ! retval.is_string ())
                   {
                     double dval = retval.double_value ();
 
-                    if (octave::math::x_nint (dval) == dval && dval >= 0 && dval < 256)
+                    if (math::x_nint (dval) == dval && dval >= 0 && dval < 256)
                       retval = static_cast<char> (dval);
                   }
               }
 
             if (elt_idx >= n_elts)
               {
                 elt_idx = 0;
                 val_idx++;
@@ -5507,18 +5507,18 @@ namespace octave
   printf_value_cache::int_value (void)
   {
     int retval = 0;
 
     octave_value val = get_next_value ();
 
     double dval = val.double_value (true);
 
-    if (octave::math::x_nint (dval) == dval)
-      retval = octave::math::nint (dval);
+    if (math::x_nint (dval) == dval)
+      retval = math::nint (dval);
     else
       curr_state = conversion_error;
 
     return retval;
   }
 
   // Ugh again and again.
 
@@ -5547,17 +5547,17 @@ namespace octave
         ::error ("%s: internal error handling format", who.c_str ());
         break;
       }
 
     return retval;
   }
 
   static size_t
-  do_printf_string (std::ostream& os, const octave::printf_format_elt *elt,
+  do_printf_string (std::ostream& os, const printf_format_elt *elt,
                     int nsa, int sa_1, int sa_2, const std::string& arg,
                     const std::string& who)
   {
     if (nsa > 2)
       ::error ("%s: internal error handling format", who.c_str ());
 
     std::string flags = elt->flags;
 
@@ -5602,17 +5602,17 @@ namespace octave
           }
         else
           return true;
       }
     else
       {
         double dval = val.double_value (true);
 
-        if (dval == octave::math::round (dval) && dval <= limit)
+        if (dval == math::round (dval) && dval <= limit)
           return true;
       }
 
     return false;
   }
 
   static bool
   ok_for_unsigned_int_conv (const octave_value& val)
@@ -5629,25 +5629,25 @@ namespace octave
         return ov_is_ge_zero.is_true ();
       }
     else
       {
         double dval = val.double_value (true);
 
         uint64_t limit = std::numeric_limits<uint64_t>::max ();
 
-        if (dval == octave::math::round (dval) && dval >= 0 && dval <= limit)
+        if (dval == math::round (dval) && dval >= 0 && dval <= limit)
           return true;
       }
 
     return false;
   }
 
   static std::string
-  switch_to_g_format (const octave::printf_format_elt *elt)
+  switch_to_g_format (const printf_format_elt *elt)
   {
     std::string tfmt = elt->text;
 
     tfmt.replace (tfmt.rfind (elt->type), 1, "g");
 
     return tfmt;
   }
 
@@ -6297,17 +6297,17 @@ namespace octave
 
   template <typename SRC_T, typename DST_T>
   static octave_value
   convert_and_copy (std::list<void *>& input_buf_list,
                     octave_idx_type input_buf_elts,
                     octave_idx_type elts_read,
                     octave_idx_type nr, octave_idx_type nc, bool swap,
                     bool do_float_fmt_conv, bool do_NA_conv,
-                    octave::mach_info::float_format from_flt_fmt)
+                    mach_info::float_format from_flt_fmt)
   {
     typedef typename DST_T::element_type dst_elt_type;
 
     DST_T conv (dim_vector (nr, nc));
 
     dst_elt_type *conv_data = conv.fortran_vec ();
 
     octave_idx_type j = 0;
@@ -6324,17 +6324,17 @@ namespace octave
                 for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
                      i++, j++)
                   {
                     if (swap)
                       swap_bytes<sizeof (SRC_T)> (&data[i]);
                     else if (do_float_fmt_conv)
                       do_float_format_conversion (&data[i], sizeof (SRC_T),
                                                   1, from_flt_fmt,
-                                                  octave::mach_info::native_float_format ());
+                                                  mach_info::native_float_format ());
 
                     dst_elt_type tmp (data[i]);
 
                     if (is_old_NA (tmp))
                       tmp = replace_old_NA (tmp);
 
                     conv_data[j] = tmp;
                   }
@@ -6344,17 +6344,17 @@ namespace octave
                 for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
                      i++, j++)
                   {
                     if (swap)
                       swap_bytes<sizeof (SRC_T)> (&data[i]);
                     else if (do_float_fmt_conv)
                       do_float_format_conversion (&data[i], sizeof (SRC_T),
                                                   1, from_flt_fmt,
-                                                  octave::mach_info::native_float_format ());
+                                                  mach_info::native_float_format ());
 
                     conv_data[j] = data[i];
                   }
               }
           }
         else
           {
             if (do_NA_conv)
@@ -6388,17 +6388,17 @@ namespace octave
 
     return conv;
   }
 
   typedef octave_value (*conv_fptr)
     (std::list<void *>& input_buf_list, octave_idx_type input_buf_elts,
      octave_idx_type elts_read, octave_idx_type nr, octave_idx_type nc,
      bool swap, bool do_float_fmt_conv, bool do_NA_conv,
-     octave::mach_info::float_format from_flt_fmt);
+     mach_info::float_format from_flt_fmt);
 
 #define TABLE_ELT(T, U, V, W)                                           \
   conv_fptr_table[oct_data_conv::T][oct_data_conv::U] = convert_and_copy<V, W>
 
 #define FILL_TABLE_ROW(T, V)                    \
   TABLE_ELT (T, dt_int8, V, int8NDArray);       \
   TABLE_ELT (T, dt_uint8, V, uint8NDArray);     \
   TABLE_ELT (T, dt_int16, V, int16NDArray);     \
@@ -6771,28 +6771,28 @@ namespace octave
   public:
     typedef T type;
   };
 
   template <typename T>
   static bool
   convert_data (const T *data, void *conv_data, octave_idx_type n_elts,
                 oct_data_conv::data_type output_type,
-                octave::mach_info::float_format flt_fmt)
+                mach_info::float_format flt_fmt)
   {
     bool retval = true;
 
     bool swap = false;
 
-    if (octave::mach_info::words_big_endian ())
-      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian);
+    if (mach_info::words_big_endian ())
+      swap = (flt_fmt == mach_info::flt_fmt_ieee_little_endian);
     else
-      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
-
-    bool do_float_conversion = flt_fmt != octave::mach_info::float_format ();
+      swap = (flt_fmt == mach_info::flt_fmt_ieee_big_endian);
+
+    bool do_float_conversion = flt_fmt != mach_info::float_format ();
 
     typedef typename ultimate_element_type<T>::type ult_elt_type;
 
     switch (output_type)
       {
       case oct_data_conv::dt_char:
         convert_chars<ult_elt_type, char> (data, conv_data, n_elts);
         break;
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -181,18 +181,17 @@ namespace octave
     static int sigusr1;
     static const bool have_sigusr1
       = octave_get_sig_number ("SIGUSR1", &sigusr1);
 
     static int sigusr2;
     static const bool have_sigusr2
       = octave_get_sig_number ("SIGUSR2", &sigusr2);
 
-    octave::child_list& kids
-      = octave::__get_child_list__ ("respond_to_pending_signals");
+    child_list& kids = __get_child_list__ ("respond_to_pending_signals");
 
     for (int sig = 0; sig < octave_num_signals (); sig++)
       {
         if (signals_caught[sig])
           {
             signals_caught[sig] = false;
 
             if ((have_sigchld && sig == sigchld)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -92,17 +92,17 @@ namespace octave
   load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
                         octave_value& function,
                         const std::string& dispatch_type = "",
                         const std::string& package_name = "")
   {
     bool retval = false;
 
     octave_value ov_fcn
-      = octave::load_fcn_from_file (ff, dir_name, dispatch_type,
+      = load_fcn_from_file (ff, dir_name, dispatch_type,
                                     package_name);
 
     if (ov_fcn.is_defined ())
       {
         retval = true;
 
         function = ov_fcn;
       }
@@ -162,17 +162,18 @@ namespace octave
                         else
                           {
                             // We don't want to make this an absolute name,
                             // because load_fcn_file looks at the name to
                             // decide whether it came from a relative lookup.
 
                             if (! dispatch_type.empty ())
                               {
-                                load_path& lp = __get_load_path__ ("out_of_date_check");
+                                load_path& lp
+                                  = __get_load_path__ ("out_of_date_check");
 
                                 file = lp.find_method (dispatch_type, nm,
                                                        dir_name, pack);
 
                                 if (file.empty ())
                                   {
                                     std::string s_name;
                                     std::string s_pack;
@@ -205,17 +206,18 @@ namespace octave
                               }
 
                             // Maybe it's an autoload?
                             if (file.empty ())
                               file = lookup_autoload (nm);
 
                             if (file.empty ())
                               {
-                                load_path& lp = __get_load_path__ ("out_of_date_check");
+                                load_path& lp
+                                  = __get_load_path__ ("out_of_date_check");
                                 file = lp.find_fcn (nm, dir_name, pack);
                               }
                           }
 
                         if (! file.empty ())
                           is_same_file = same_file (file, ff);
                       }
                     else
@@ -278,18 +280,18 @@ namespace octave
 
                         clear_breakpoints = true;
                       }
 
                     // If the function has been replaced then clear any
                     // breakpoints associated with it
                     if (clear_breakpoints)
                       {
-                        octave::bp_table& bptab
-                          = octave::__get_bp_table__ ("out_of_date_check");
+                        bp_table& bptab
+                          = __get_bp_table__ ("out_of_date_check");
 
                         bptab.remove_all_breakpoints_in_file (canonical_nm,
                                                               true);
                       }
                   }
               }
           }
       }
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -65,17 +65,17 @@ namespace octave
     bp_table::m_errors_that_stop.clear ();
 
     Vdebug_on_caught = false;
     bp_table::m_caught_that_stop.clear ();
 
     Vdebug_on_warning = false;
     bp_table::m_warnings_that_stop.clear ();
 
-    octave::Vdebug_on_interrupt = false;
+    Vdebug_on_interrupt = false;
   }
 
   // Process the "warn", "errs", "caught" and "intr" fields for a call of
   // "dbstop (p)".
 
   void bp_table::dbstop_process_map_args (const octave_map& mv)
   {
     // process errs
@@ -96,16 +96,17 @@ namespace octave
             Cell V = W(0).cell_value ();
             for (int i = 0; i < V.numel (); i++)
               {
                 m_errors_that_stop.insert (V(i).string_value ());
                 Vdebug_on_error = 1;
               }
           }
       }
+
     if (fail)
       error ("dbstop: invalid 'errs' field");
 
     // process caught
     // why so many levels of indirection needed?
     fail = false;
     U = mv.contents ("caught");
     if (U.numel () != 1)
@@ -122,16 +123,17 @@ namespace octave
             Cell V = W(0).cell_value ();
             for (int i = 0; i < V.numel (); i++)
               {
                 m_caught_that_stop.insert (V(i).string_value ());
                 Vdebug_on_caught = 1;
               }
           }
       }
+
     if (fail)
       error ("dbstop: invalid 'caught' field");
 
     // process warn
     // why so many levels of indirection needed?
     fail = false;
     U = mv.contents ("warn");
     if (U.numel () != 1)
@@ -148,37 +150,38 @@ namespace octave
             Cell V = W(0).cell_value ();
             for (int i = 0; i < V.numel (); i++)
               {
                 m_warnings_that_stop.insert (V(i).string_value ());
                 Vdebug_on_warning = 1;
               }
           }
       }
+
     if (fail)
       error ("dbstop: invalid 'warn' field");
 
     // process interrupt
     if (mv.isfield ("intr"))
-      octave::Vdebug_on_interrupt = 1;
+      Vdebug_on_interrupt = 1;
   }
 
   // Insert a breakpoint in function fcn at line within file fname,
   // to stop only when condition is true.
   // Record in m_bp_set that fname contains a breakpoint.
 
   bool bp_table::add_breakpoint_1 (octave_user_code *fcn,
                                    const std::string& fname,
                                    const bp_table::intmap& line,
                                    const std::string& condition,
                                    bp_table::intmap& retval)
   {
     bool found = false;
 
-    octave::tree_statement_list *cmds = fcn->body ();
+    tree_statement_list *cmds = fcn->body ();
 
     std::string file = fcn->fcn_file_name ();
 
     if (cmds)
       {
         retval = cmds->add_breakpoint (file, line, condition);
 
         for (auto& idx_line_p : retval)
@@ -207,43 +210,44 @@ namespace octave
   // Currently allows conditions with side-effects, like 'y+=10' and 'y++';
   // it is odd that the former is not flagged by "is_assignment_expression".
   // Throws an exception if not valid.
 
   bool bp_table::condition_valid (const std::string& cond)
   {
     if (cond.length () > 0)
       {
-        octave::parser parser (cond + " ;"); // ; to reject partial expr like "y=="
+        parser parser (cond + " ;"); // ; to reject partial expr like "y=="
         parser.reset ();
         int parse_status = parser.run ();
         if (parse_status)
           error ("dbstop: Cannot parse condition '%s'", cond.c_str ());
         else
           {
-            octave::tree_statement *stmt = nullptr;
+            tree_statement *stmt = nullptr;
             if (! parser.m_stmt_list)
               error ("dbstop: "
                      "condition is not empty, but has nothing to evaluate");
             else
               {
                 if (parser.m_stmt_list->length () == 1
                     && (stmt = parser.m_stmt_list->front ())
                     && stmt->is_expression ())
                   {
-                    octave::tree_expression *expr = stmt->expression ();
+                    tree_expression *expr = stmt->expression ();
                     if (expr->is_assignment_expression ())
                       error ("dbstop: condition cannot be an assignment.  "
                              "Did you mean '=='?");
                   }
                 else
                   error ("dbstop: condition must be an expression");
               }
           }
       }
+
     return true;
   }
 
   enum dbstop_args
   {
     dbstop_in,
     dbstop_at,
     dbstop_if,
@@ -407,17 +411,17 @@ namespace octave
                          && args(pos+1).string_value () == "error")
                   {
                     id_list = &m_caught_that_stop;
                     stop_flag = &Vdebug_on_caught;
                     pos++;
                   }
                 else if (condition == "interrupt")
                   {
-                    octave::Vdebug_on_interrupt = on_off;
+                    Vdebug_on_interrupt = on_off;
                   }
                 else if (condition == "naninf")
                   {
 #if defined (DBSTOP_NANINF)
                     Vdebug_on_naninf = on_off;
                     enable_fpe (on_off);
 #else
                     warning ("%s: condition '%s' not yet supported",
@@ -450,17 +454,17 @@ namespace octave
                       }
                     else   // unqualified.  Turn all on or off
                       {
                         id_list->clear ();
                         *stop_flag = on_off;
                         if (stop_flag == &Vdebug_on_error)
                           {
                             // Matlab stops on both.
-                            octave::Vdebug_on_interrupt = on_off;
+                            Vdebug_on_interrupt = on_off;
                           }
                       }
                   }
 
                 pos = nargin;
               }
             break;
 
@@ -581,31 +585,30 @@ namespace octave
             // If multiple are in the same function, we insert multiple times.
             intmap ret_one;
             if (dbg_fcn
                 && add_breakpoint_1 (dbg_fcn, fname, line, condition, ret_one))
               retval.insert (std::pair<int,int> (i, ret_one.find (i)->second));
           }
       }
 
-    octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-                                         || Vdebugging;
+    tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
     return retval;
   }
 
   int bp_table::remove_breakpoint_1 (octave_user_code *fcn,
                                      const std::string& fname,
                                      const bp_table::intmap& line)
   {
     int retval = 0;
 
     std::string file = fcn->fcn_file_name ();
 
-    octave::tree_statement_list *cmds = fcn->body ();
+    tree_statement_list *cmds = fcn->body ();
 
     // FIXME: move the operation on cmds to the tree_statement_list class?
 
     if (cmds)
       {
         octave_value_list results = cmds->list_breakpoints ();
 
         if (results.length () > 0)
@@ -678,18 +681,17 @@ namespace octave
               {
                 octave_user_code *dbg_subfcn = q->second.user_code_value ();
 
                 retval += remove_breakpoint_1 (dbg_subfcn, fname, line);
               }
           }
       }
 
-    octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-                                         || Vdebugging;
+    tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
     return retval;
   }
 
   // Remove all breakpoints from a file, including those in subfunctions.
 
   bp_table::intmap
   bp_table::remove_all_breakpoints_in_file (const std::string& fname,
@@ -698,50 +700,48 @@ namespace octave
     intmap retval;
 
     octave_user_code *dbg_fcn = get_user_code (fname);
 
     if (dbg_fcn)
       {
         std::string file = dbg_fcn->fcn_file_name ();
 
-        octave::tree_statement_list *cmds = dbg_fcn->body ();
+        tree_statement_list *cmds = dbg_fcn->body ();
 
         if (cmds)
           {
             retval = cmds->remove_all_breakpoints (file);
 
             bp_set_iterator it = m_bp_set.find (fname);
             if (it != m_bp_set.end ())
               m_bp_set.erase (it);
           }
       }
     else if (! silent)
       error ("remove_all_breakpoint_in_file: "
              "unable to find function %s\n", fname.c_str ());
 
-    octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-                                         || Vdebugging;
+    tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
     return retval;
   }
 
   void bp_table::remove_all_breakpoints (void)
   {
     // Odd loop structure required because delete will invalidate m_bp_set iterators
     for (const_bp_set_iterator it = m_bp_set.begin (), it_next = it;
          it != m_bp_set.end ();
          it = it_next)
       {
         ++it_next;
         remove_all_breakpoints_in_file (*it);
       }
 
-    octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-                                         || Vdebugging;
+    tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
   }
 
   std::string find_bkpt_list (octave_value_list slist, std::string match)
   {
     std::string retval;
 
     for (int i = 0; i < slist.length (); i++)
       {
@@ -767,17 +767,17 @@ namespace octave
       {
         if (fname_list.empty ()
             || find_bkpt_list (fname_list, bp_fname) != "")
           {
             octave_user_code *dbg_fcn = get_user_code (bp_fname);
 
             if (dbg_fcn)
               {
-                octave::tree_statement_list *cmds = dbg_fcn->body ();
+                tree_statement_list *cmds = dbg_fcn->body ();
 
                 // FIXME: move the operation on cmds to the
                 //        tree_statement_list class?
                 if (cmds)
                   {
                     std::list<bp_type> bkpts = cmds->breakpoints_and_conds ();
 
                     if (! bkpts.empty ())
@@ -912,17 +912,17 @@ namespace octave
                   warn(i++) = w;
               }
             if (! to_screen)
               retval.assign ("warn", octave_value (warn));
           }
       }
 
     // print dbstop if interrupt information
-    if (octave::Vdebug_on_interrupt)
+    if (Vdebug_on_interrupt)
       {
         if (to_screen)
           octave_stdout << "stop if interrupt\n";
         else
           retval.assign ("intr", octave_value ());
       }
 
     return retval;
@@ -934,38 +934,37 @@ namespace octave
 
   octave_user_code *
   get_user_code (const std::string& fname)
   {
     octave_user_code *dbg_fcn = nullptr;
 
     if (fname.empty ())
       {
-        octave::call_stack& cs = octave::__get_call_stack__ ("get_user_code");
+        call_stack& cs = __get_call_stack__ ("get_user_code");
 
         dbg_fcn = cs.debug_user_code ();
       }
     else
       {
         std::string name = fname;
 
-        if (octave::sys::file_ops::dir_sep_char () != '/' && name[0] == '@')
+        if (sys::file_ops::dir_sep_char () != '/' && name[0] == '@')
           {
             auto beg = name.begin () + 2;  // never have @/method
             auto end = name.end () - 1;    // never have trailing '/'
-            std::replace (beg, end, '/', octave::sys::file_ops::dir_sep_char ());
+            std::replace (beg, end, '/', sys::file_ops::dir_sep_char ());
           }
 
         size_t name_len = name.length ();
 
         if (name_len > 2 && name.substr (name_len-2) == ".m")
           name = name.substr (0, name_len-2);
 
-        octave::symbol_table& symtab =
-          octave::__get_symbol_table__ ("get_user_code");
+        symbol_table& symtab = __get_symbol_table__ ("get_user_code");
 
         octave_value fcn = symtab.find_function (name);
 
         if (fcn.is_defined () && fcn.is_user_code ())
           dbg_fcn = fcn.user_code_value ();
       }
 
     return dbg_fcn;
diff --git a/libinterp/parse-tree/comment-list.h b/libinterp/parse-tree/comment-list.h
--- a/libinterp/parse-tree/comment-list.h
+++ b/libinterp/parse-tree/comment-list.h
@@ -80,24 +80,24 @@ namespace octave
     // The text of the comment.
     std::string m_text;
 
     // The type of comment.
     comment_type m_type;
   };
 
   class
-  comment_list : public octave::base_list<comment_elt>
+  comment_list : public base_list<comment_elt>
   {
   public:
 
     comment_list (void) { }
 
     void append (const comment_elt& elt)
-    { octave::base_list<comment_elt>::append (elt); }
+    { base_list<comment_elt>::append (elt); }
 
     void append (const std::string& s,
                  comment_elt::comment_type t = comment_elt::unknown)
     { append (comment_elt (s, t)); }
 
     comment_list * dup (void) const;
   };
 }
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -211,33 +211,33 @@ namespace octave
       return new octave_scalar (c.real ());
     else
       return new octave_complex (c);
   }
 
   extern "C" void
   octave_jit_err_nan_to_logical_conversion (void)
   {
-    octave::err_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   }
 
   extern "C" void
   octave_jit_ginvalid_index (void)
   {
     // FIXME: 0-argument form of octave::err_invalid_index removed in
     //        cset dd6345fd8a97.  Report -1 as the bad index for all
     //        occurrences.
-    octave::err_invalid_index (static_cast<octave_idx_type> (-1));
+    err_invalid_index (static_cast<octave_idx_type> (-1));
   }
 
   extern "C" void
   octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
                            octave_idx_type ext)
   {
-    octave::err_index_out_of_range (nd, dim, iext, ext);
+    err_index_out_of_range (nd, dim, iext, ext);
   }
 
   extern "C" jit_matrix
   octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
                                   double value)
   {
     NDArray *array = mat->m_array;
     if (array->numel () < index)
@@ -392,17 +392,17 @@ namespace octave
 
     return lhs / rhs;
   }
 
   // FIXME: CP form src/xpow.cc
   static inline int
   xisint (double x)
   {
-    return (octave::math::x_nint (x) == x
+    return (math::x_nint (x) == x
             && ((x >= 0 && x < std::numeric_limits<int>::max ())
                 || (x <= 0 && x > std::numeric_limits<int>::min ())));
   }
 
   extern "C" Complex
   octave_jit_pow_scalar_scalar (double lhs, double rhs)
   {
     // FIXME: almost CP from src/xpow.cc
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -5423,19 +5423,19 @@ namespace octave
 
                     if (silent)
                       expr->set_print_flag (false);
 
                     bool do_bind_ans = false;
 
                     if (expr->is_identifier ())
                       {
-                        octave::symbol_scope scope = tw.get_current_scope ();
-
-                        octave::symbol_record::context_id context
+                        symbol_scope scope = tw.get_current_scope ();
+
+                        symbol_record::context_id context
                           = scope.current_context ();
 
                         tree_identifier *id
                           = dynamic_cast<tree_identifier *> (expr);
 
                         do_bind_ans = (! id->is_variable (context));
                       }
                     else
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -31,44 +31,44 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   typedef tree_expression* tree_expression_ptr_t;
 
   // If a tree expression is a transpose or hermitian transpose, return
   // the argument and corresponding operator.
 
   static octave_value::unary_op
-  strip_trans_herm (octave::tree_expression_ptr_t& exp)
+  strip_trans_herm (tree_expression_ptr_t& exp)
   {
     if (exp->is_unary_expression ())
       {
-        octave::tree_unary_expression *uexp =
-          dynamic_cast<octave::tree_unary_expression *> (exp);
+        tree_unary_expression *uexp =
+          dynamic_cast<tree_unary_expression *> (exp);
 
         octave_value::unary_op op = uexp->op_type ();
 
         if (op == octave_value::op_transpose
             || op == octave_value::op_hermitian)
           exp = uexp->operand ();
         else
           op = octave_value::unknown_unary_op;
 
         return op;
       }
     else
       return octave_value::unknown_unary_op;
   }
 
   static octave_value::unary_op
-  strip_not (octave::tree_expression_ptr_t& exp)
+  strip_not (tree_expression_ptr_t& exp)
   {
     if (exp->is_unary_expression ())
       {
-        octave::tree_unary_expression *uexp =
-          dynamic_cast<octave::tree_unary_expression *> (exp);
+        tree_unary_expression *uexp =
+          dynamic_cast<tree_unary_expression *> (exp);
 
         octave_value::unary_op op = uexp->op_type ();
 
         if (op == octave_value::op_not)
           exp = uexp->operand ();
         else
           op = octave_value::unknown_unary_op;
 
@@ -77,18 +77,17 @@ namespace octave
     else
       return octave_value::unknown_unary_op;
   }
 
   // Possibly convert multiplication to trans_mul, mul_trans, herm_mul,
   // or mul_herm.
 
   static octave_value::compound_binary_op
-  simplify_mul_op (octave::tree_expression_ptr_t& a,
-                   octave::tree_expression_ptr_t& b)
+  simplify_mul_op (tree_expression_ptr_t& a, tree_expression_ptr_t& b)
   {
     octave_value::compound_binary_op retop
       = octave_value::unknown_compound_binary_op;
 
     octave_value::unary_op opa = strip_trans_herm (a);
 
     if (opa == octave_value::op_hermitian)
       retop = octave_value::op_herm_mul;
@@ -105,18 +104,17 @@ namespace octave
       }
 
     return retop;
   }
 
   // Possibly convert left division to trans_ldiv or herm_ldiv.
 
   static octave_value::compound_binary_op
-  simplify_ldiv_op (octave::tree_expression_ptr_t& a,
-                    octave::tree_expression_ptr_t&)
+  simplify_ldiv_op (tree_expression_ptr_t& a, tree_expression_ptr_t&)
   {
     octave_value::compound_binary_op retop
       = octave_value::unknown_compound_binary_op;
 
     octave_value::unary_op opa = strip_trans_herm (a);
 
     if (opa == octave_value::op_hermitian)
       retop = octave_value::op_herm_ldiv;
@@ -124,18 +122,17 @@ namespace octave
       retop = octave_value::op_trans_ldiv;
 
     return retop;
   }
 
   // Possibly contract and/or with negation.
 
   static octave_value::compound_binary_op
-  simplify_and_or_op (octave::tree_expression_ptr_t& a,
-                      octave::tree_expression_ptr_t& b,
+  simplify_and_or_op (tree_expression_ptr_t& a, tree_expression_ptr_t& b,
                       octave_value::binary_op op)
   {
     octave_value::compound_binary_op retop
       = octave_value::unknown_compound_binary_op;
 
     octave_value::unary_op opa = strip_not (a);
 
     if (opa == octave_value::op_not)
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -759,25 +759,25 @@ namespace octave
   // Decide if it's time to quit a for or while loop.
   static inline bool
   quit_loop_now (void)
   {
     octave_quit ();
 
     // Maybe handle 'continue N' someday...
 
-    if (octave::tree_continue_command::continuing)
-      octave::tree_continue_command::continuing--;
-
-    bool quit = (octave::tree_return_command::returning
-                 || octave::tree_break_command::breaking
-                 || octave::tree_continue_command::continuing);
-
-    if (octave::tree_break_command::breaking)
-      octave::tree_break_command::breaking--;
+    if (tree_continue_command::continuing)
+      tree_continue_command::continuing--;
+
+    bool quit = (tree_return_command::returning
+                 || tree_break_command::breaking
+                 || tree_continue_command::continuing);
+
+    if (tree_break_command::breaking)
+      tree_break_command::breaking--;
 
     return quit;
   }
 
   void
   tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
   {
     size_t line = cmd.line ();
@@ -1151,38 +1151,37 @@ namespace octave
       }
   }
 
   // Final step of processing an indexing error.  Add the name of the
   // variable being indexed, if any, then issue an error.  (Will this also
   // be needed by pt-lvalue, which calls subsref?)
 
   static void
-  final_index_error (octave::index_exception& e,
-                     const octave::tree_expression *expr)
+  final_index_error (index_exception& e,
+                     const tree_expression *expr)
   {
     std::string extra_message;
 
     // FIXME: make this a member function for direct access to symbol
     // table and scope?
 
-    octave::symbol_scope scope
-      = octave::__require_current_scope__ ("final_index_error");
-
-    octave::symbol_record::context_id context = scope.current_context ();
+    symbol_scope scope
+      = __require_current_scope__ ("final_index_error");
+
+    symbol_record::context_id context = scope.current_context ();
 
     if (expr->is_identifier ()
-        && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
+        && dynamic_cast<const tree_identifier *> (expr)->is_variable (context))
       {
         std::string var = expr->name ();
 
         e.set_var (var);
 
-        octave::symbol_table& symtab =
-          octave::__get_symbol_table__ ("final_index_error");
+        symbol_table& symtab = __get_symbol_table__ ("final_index_error");
 
         octave_value fcn = symtab.find_function (var);
 
         if (fcn.is_function ())
           {
             octave_function *fp = fcn.function_value ();
 
             if (fp && fp->name () == var)
@@ -1484,17 +1483,17 @@ namespace octave
           {
             try
               {
                 retval = base_expr_val.subsref (type.substr (beg, n-beg),
                                                 idx, nargout);
                 beg = n;
                 idx.clear ();
               }
-            catch (octave::index_exception& e)
+            catch (index_exception& e)
               {
                 final_index_error (e, expr);
               }
           }
         else
           {
             // FIXME: we want this to only be a superclass constructor
             // call Should we actually make a check for this or are all
@@ -1503,17 +1502,17 @@ namespace octave
             octave_function *fcn = base_expr_val.function_value ();
 
             if (fcn)
               {
                 try
                   {
                     retval = fcn->call (*this, nargout, idx);
                   }
-                catch (octave::index_exception& e)
+                catch (index_exception& e)
                   {
                     final_index_error (e, expr);
                   }
               }
           }
       }
 
     // FIXME: when can the following happen?  In what case does indexing
@@ -2321,17 +2320,17 @@ namespace octave
             // FIXME: We want to use error_with_id here so that give users
             // control over this error message but error_with_id will
             // require some memory allocations.  Is there anything we can
             // do to make those more likely to succeed?
 
             error_with_id ("Octave:bad-alloc",
                            "out of memory or dimension too large for Octave's index type");
           }
-        catch (const octave::interrupt_exception&)
+        catch (const interrupt_exception&)
           {
             // If we are debugging, then continue with next statement.
             // Otherwise, jump out of here.
 
             if (debug_mode)
               interpreter::recover_from_exception ();
             else
               throw;
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -140,18 +140,18 @@ namespace octave
 
   std::string
   tree_index_expression::name (void) const
   {
     return m_expr->name ();
   }
 
   static inline octave_value_list
-  make_value_list (octave::tree_evaluator *tw,
-                   octave::tree_argument_list *m_args,
+  make_value_list (tree_evaluator *tw,
+                   tree_argument_list *m_args,
                    const string_vector& m_arg_nm, const octave_value *object,
                    bool rvalue = true)
   {
     octave_value_list retval;
 
     if (m_args)
       {
         if (rvalue && object && m_args->has_magic_end ()
@@ -194,28 +194,26 @@ namespace octave
     return fn;
   }
 
   // Final step of processing an indexing error.  Add the name of the
   // variable being indexed, if any, then issue an error.  (Will this also
   // be needed by pt-lvalue, which calls subsref?)
 
   static void
-  final_index_error (octave::index_exception& e,
-                     const octave::tree_expression *expr)
+  final_index_error (index_exception& e, const tree_expression *expr)
   {
     std::string extra_message;
 
-    octave::symbol_table& symtab
-      = octave::__get_symbol_table__ ("final_index_error");
+    symbol_table& symtab = __get_symbol_table__ ("final_index_error");
 
-    octave::symbol_record::context_id context = symtab.current_context ();
+    symbol_record::context_id context = symtab.current_context ();
 
     if (expr->is_identifier ()
-        && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
+        && dynamic_cast<const tree_identifier *> (expr)->is_variable (context))
       {
         std::string var = expr->name ();
 
         e.set_var (var);
 
         octave_value fcn = symtab.find_function (var);
 
         if (fcn.is_function ())
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -795,17 +795,17 @@ namespace octave
   {
     tree_command *cmd = stmt.command ();
     tree_expression *expr = stmt.expression ();
 
     if (cmd)
       visit (cmd);
     else
       {
-        // stolen from octave::tree_evaluator::visit_statement
+        // stolen from tree_evaluator::visit_statement
         bool do_bind_ans = false;
 
         if (expr->is_identifier ())
           {
             tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
             do_bind_ans = (! id->is_variable (m_scope.current_context ()));
           }
@@ -2318,18 +2318,17 @@ namespace octave
       }
 
     return info->execute (args, retval);
   }
 
   bool
   tree_jit::enabled (void)
   {
-    octave::bp_table& bptab
-      = octave::__get_bp_table__ ("tree_jit::enabled");
+    bp_table& bptab = __get_bp_table__ ("tree_jit::enabled");
 
     // Ideally, we should only disable JIT if there is a breakpoint in the code
     // we are about to run. However, we can't figure this out in O(1) time, so
     // we conservatively check for the existence of any breakpoints.
     return (Vjit_enable && ! bptab.have_breakpoints ()
             && ! Vdebug_on_interrupt && ! Vdebug_on_error);
   }
 
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -783,17 +783,17 @@ namespace octave
   void
   gnu_readline::do_handle_interrupt_signal (void)
   {
     octave_signal_caught = 0;
     octave_interrupt_state = 0;
 
     ::octave_rl_recover_from_interrupt ();
 
-    throw octave::interrupt_exception ();
+    throw interrupt_exception ();
   }
 
   int
   gnu_readline::operate_and_get_next (int /* count */, int /* c */)
   {
     // Accept the current line.
 
     command_editor::accept_line ();
