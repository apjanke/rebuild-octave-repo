# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1498398651 14400
#      Sun Jun 25 09:50:51 2017 -0400
# Node ID b9378eff6d13d1e194d8c427e6bef2b45198d834
# Parent  4f9fd6ee0fd0868cc2121ef06c2643f46cffcf50
move symbol_table class inside octave namespace

diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1777,17 +1777,17 @@ file_editor_tab::new_file (const QString
 }
 
 // Force reloading of a file after it is saved.
 // This is needed to get the right line numbers for breakpoints (bug #46632).
 bool
 file_editor_tab::exit_debug_and_clear (const QString& full_name_q,
                                        const QString& base_name_q)
 {
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("file_editor_tab::exit_debug_and_clear");
 
   std::string base_name = base_name_q.toStdString ();
   octave_value sym;
   try
     {
       sym = symtab.find (base_name);
     }
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -2415,17 +2415,17 @@ main_window::save_workspace_callback (co
   Fsave (ovl (file));
 }
 
 void
 main_window::load_workspace_callback (const std::string& file)
 {
   Fload (ovl (file));
 
-  symbol_table::scope *scope
+  octave::symbol_table::scope *scope
    = octave::__get_current_scope__ ("main_window::load_workspace_callback");
 
   if (scope)
     octave_link::set_workspace (true, scope->workspace_info ());
 }
 
 void
 main_window::clear_workspace_callback (void)
@@ -2434,17 +2434,17 @@ main_window::clear_workspace_callback (v
     = octave::__get_interpreter__ ("main_window::clear_workspace_callback");
 
   Fclear (interp);
 }
 
 void
 main_window::rename_variable_callback (const main_window::name_pair& names)
 {
-  symbol_table::scope *scope
+  octave::symbol_table::scope *scope
     = octave::__get_current_scope__ ("main_window::rename_variable_callback");
 
   if (scope)
     {
       scope->rename (names.first, names.second);
 
       octave_link::set_workspace (true, scope->workspace_info ());
     }
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -368,17 +368,17 @@ void
 workspace_view::handle_contextmenu_copy_value (void)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
-      symbol_table::scope *scope
+      octave::symbol_table::scope *scope
         = octave::__get_current_scope__ ("workspace_view::handle_contextmenu_copy_value");
 
       octave_value val = scope ? scope->varval (var_name.toStdString ()) : 0;
       std::ostringstream buf;
       val.print_raw (buf, true);
 
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText (QString::fromStdString (buf.str ()));
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -339,17 +339,17 @@ dimensionality as the other array.
   if (args.length () != 3)
     print_usage ();
 
   octave_value func = args(0);
   if (func.is_string ())
     {
       std::string name = func.string_value ();
 
-      symbol_table& symtab = interp.get_symbol_table ();
+      octave::symbol_table& symtab = interp.get_symbol_table ();
 
       func = symtab.find_function (name);
 
       if (func.is_undefined ())
         error ("bsxfun: invalid function name: %s", name.c_str ());
     }
   else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
     error ("bsxfun: F must be a string or function handle");
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -214,17 +214,17 @@ try_cellfun_internal_ops (const octave_v
 
       retval(0) = result;
     }
 
   return retval;
 }
 
 static void
-get_mapper_fun_options (symbol_table& symtab, const octave_value_list& args,
+get_mapper_fun_options (octave::symbol_table& symtab, const octave_value_list& args,
                         int& nargin, bool& uniform_output,
                         octave_value& error_handler)
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
       std::string arg = args(nargin-2).string_value ();
 
       size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
@@ -406,17 +406,17 @@ v = cellfun (@@det, a); # faster
   if (! args(1).iscell ())
     error ("cellfun: C must be a cell array");
 
   octave_value_list retval;
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   octave_value func = args(0);
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (func.is_string ())
     {
       retval = try_cellfun_internal_ops<boolNDArray,NDArray> (args, nargin);
 
       if (! retval.empty ())
         return retval;
 
@@ -1119,17 +1119,17 @@ arrayfun (@@str2num, [1234],
   if (nargin < 2)
     print_usage ();
 
   octave_value_list retval;
   int nargout1 = (nargout < 1 ? 1 : nargout);
   bool symbol_table_lookup = false;
   octave_value func = args(0);
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (func.is_string ())
     {
       // See if we can convert the string into a function.
       std::string name = args(0).string_value ();
 
       if (! valid_identifier (name))
         {
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1621,17 +1621,17 @@ attempt_type_conversion (const octave_va
   octave_value retval;
 
   // First try to find function in the class of OV that can convert to
   // the dispatch type dtype.  It will have the name of the dispatch
   // type.
 
   std::string cname = ov.class_name ();
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("attempt_type_conversion");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("attempt_type_conversion");
 
   octave_value fcn = symtab.find_method (dtype, cname);
 
   if (fcn.is_defined ())
     {
       octave_value_list result;
 
       try
@@ -1684,19 +1684,19 @@ attempt_type_conversion (const octave_va
 
 octave_value
 do_class_concat (const octave_value_list& ovl, std::string cattype, int dim)
 {
   octave_value retval;
 
   // Get dominant type for list
 
-  std::string dtype = get_dispatch_type (ovl);
-
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_class_concat");
+  std::string dtype = octave::get_dispatch_type (ovl);
+
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_class_concat");
 
   octave_value fcn = symtab.find_method (cattype, dtype);
 
   if (fcn.is_defined ())
     {
       // Have method for dominant type.  Call it and let it handle conversions.
 
       octave_value_list tmp2;
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -86,30 +86,30 @@ check_version (const std::string& versio
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (f, name, file, doc));
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_builtin_function");
 
   symtab.install_built_in_function (name, fcn);
 }
 
 void
 install_builtin_function (octave_builtin::meth m, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (m, name, file, doc));
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_builtin_function");
 
   symtab.install_built_in_function (name, fcn);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
                       const octave::dynamic_library& shl, const std::string& doc,
@@ -117,17 +117,17 @@ install_dld_function (octave_dld_functio
 {
   octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_dld_function");
 
   symtab.install_built_in_function (name, fval);
 }
 
 void
 install_dld_function (octave_dld_function::meth m, const std::string& name,
                       const octave::dynamic_library& shl, const std::string& doc,
@@ -135,51 +135,51 @@ install_dld_function (octave_dld_functio
 {
   octave_dld_function *fcn = new octave_dld_function (m, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_dld_function");
 
   symtab.install_built_in_function (name, fval);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
                       const octave::dynamic_library& shl, bool relative)
 {
   octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_mex_function");
 
   symtab.install_built_in_function (name, fval);
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("alias_builtin");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("alias_builtin");
 
   symtab.alias_built_in_function (alias, name);
 }
 
 void
 install_builtin_dispatch (const std::string& name, const std::string& klass)
 {
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_builtin_dispatch");
 
   symtab.install_built_in_dispatch (name, klass);
 }
 
 octave::dynamic_library
 get_current_shlib (void)
 {
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1503,22 +1503,22 @@ disable escape sequence expansion use a 
 
       if (nargin >= 2)
         arg2 = argv[2];
 
       if (arg1 == "on" || arg1 == "off" || arg1 == "error")
         {
           octave_map old_warning_options = warning_options;
 
-          symbol_table& symtab = interp.get_symbol_table ();
+          octave::symbol_table& symtab = interp.get_symbol_table ();
 
           if (nargin == 3 && argv[3] == "local"
               && ! symtab.at_top_level ())
             {
-              symbol_table::scope *scope
+              octave::symbol_table::scope *scope
                 = symtab.require_current_scope ("warning");
 
               octave_scalar_map val = warning_query (arg2);
 
               octave_value curr_state = val.contents ("state");
 
               // FIXME: this might be better with a dictionary object.
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -158,17 +158,17 @@ local_functions (void)
   octave_user_code *curr_fcn = cs.caller_user_code ();
 
   if (! curr_fcn)
     return retval;
 
   // All subfunctions are listed in the top-level function of this file.
   while (curr_fcn->is_subfunction ())
     {
-      symbol_table::scope *pscope = curr_fcn->parent_fcn_scope ();
+      octave::symbol_table::scope *pscope = curr_fcn->parent_fcn_scope ();
       curr_fcn = pscope->function ();
     }
 
   // Get subfunctions.
   const std::list<std::string> names = curr_fcn->subfunction_names ();
 
   size_t sz = names.size ();
   retval.resize (sz);
@@ -184,17 +184,17 @@ local_functions (void)
 // FIXME: It's not likely that this does the right thing now.
 
 string_vector
 make_name_list (void)
 {
   const static string_vector keywords = Fiskeyword ()(0).string_vector_value ();
   const static int key_len = keywords.numel ();
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("make_name_list");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("make_name_list");
 
   const string_vector bif = symtab.built_in_function_names ();
   const int bif_len = bif.numel ();
 
   const string_vector cfl = symtab.cmdline_function_names ();
   const int cfl_len = cfl.numel ();
 
   const string_vector lcl = symtab.variable_names ();
@@ -272,17 +272,17 @@ looks_like_texinfo (const std::string& m
 }
 
 static bool
 raw_help_from_symbol_table (const std::string& nm, std::string& h,
                             std::string& w, bool& symbol_found)
 {
   bool retval = false;
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("raw_help_from_symbol_table");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("raw_help_from_symbol_table");
 
   octave_value val = symtab.find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
@@ -627,17 +627,17 @@ DEFALIAS (__keywords__, iskeyword)
 // Return a cell array of strings with the names of all builtin functions.
 
 DEFMETHOD (__builtins__, interp, , ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {} __builtins__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   const string_vector bif = symtab.built_in_function_names ();
 
   return ovl (Cell (bif));
 }
 
 DEFMETHOD (localfunctions, interp, args, ,
            doc: /* -*- texinfo -*-
@@ -710,17 +710,17 @@ the return value is an empty cell array.
 
 static std::string
 do_which (const std::string& name, std::string& type)
 {
   std::string file;
 
   type = "";
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_which");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_which");
 
   octave_value val = symtab.find_function (name);
 
   if (name.find_first_of ('.') == std::string::npos)
     {
       if (val.is_defined ())
         {
           octave_function *fcn = val.function_value ();
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -116,17 +116,17 @@ strip_trailing_separators (const std::st
 static std::string
 find_private_file (const std::string& fname)
 {
   std::string retval;
 
   // Look in private directory corresponding to current function (if
   // any).
 
-  symbol_table::scope *scope = octave::__get_current_scope__ ("find_private_file");
+  octave::symbol_table::scope *scope = octave::__get_current_scope__ ("find_private_file");
 
   octave_user_function *curr_fcn = scope ? scope->function () : 0;
 
   if (curr_fcn)
     {
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
@@ -1678,17 +1678,17 @@ namespace octave
           {
             // Warn if a built-in or library function is being shadowed,
             // but not if we are just updating (rehashing) the list.
 
             if (! updating)
               {
                 if (file_info_list.empty ())
                   {
-                    symbol_table& symtab
+                    octave::symbol_table& symtab
                       = octave::__get_symbol_table__ ("load_path::package_info::add_to_fcn_map");
 
                     if (symtab.is_built_in_function_name (base))
                       {
                         std::string fcn_path = octave::sys::file_ops::concat (dir_name, fname);
 
                         warning_with_id ("Octave:shadowed-function",
                                          "function %s shadows a built-in function",
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -140,20 +140,20 @@ err_file_open (const std::string& fcn, c
 // Install a variable with name NAME and the value VAL in the
 // symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
                          bool global, const std::string& /*doc*/)
 {
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_loaded_varaible");
 
-  symbol_table::scope *scope
+  octave::symbol_table::scope *scope
     = symtab.require_current_scope ("install_loaded_variable");
 
   if (global)
     {
       scope->clear_variable (name);
       scope->mark_global (name);
       symtab.global_assign (name, val);
     }
@@ -952,17 +952,17 @@ do_save (std::ostream& os, const octave_
       err_unrecognized_data_fmt ("save");
       break;
     }
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
-do_save (std::ostream& os, const symbol_table::symbol_record& sr,
+do_save (std::ostream& os, const octave::symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats)
 {
   octave_value val = sr.varval ();
 
   if (val.is_defined ())
     {
       std::string name = sr.name ();
       std::string help;
@@ -1002,19 +1002,19 @@ save_fields (std::ostream& os, const oct
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.
 
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
 
-  std::list<symbol_table::symbol_record> vars = symtab.glob (pattern);
+  std::list<octave::symbol_table::symbol_record> vars = symtab.glob (pattern);
 
   size_t saved = 0;
 
   for (const auto& var : vars)
     {
       do_save (os, var, fmt, save_as_floats);
 
       saved++;
@@ -1271,17 +1271,17 @@ save_vars (const string_vector& argv, in
     }
   else if (argv[argv_idx] == "-struct")
     {
       if (++argv_idx >= argc)
         error ("save: missing struct name");
 
       std::string struct_name = argv[argv_idx];
 
-      symbol_table::scope *scope = octave::__get_current_scope__ ("save_vars");
+      octave::symbol_table::scope *scope = octave::__get_current_scope__ ("save_vars");
 
       octave_value struct_var;
 
       if (scope)
         {
           if (! scope->is_variable (struct_name))
             error ("save: no such variable: '%s'", struct_name.c_str ());
 
@@ -1323,21 +1323,21 @@ save_vars (const string_vector& argv, in
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
-  symbol_table::scope *top_scope = symtab.top_scope ();
+  octave::symbol_table::scope *top_scope = symtab.top_scope ();
 
-  std::list<symbol_table::symbol_record> vars = top_scope->all_variables ();
+  std::list<octave::symbol_table::symbol_record> vars = top_scope->all_variables ();
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
       octave_value val = var.varval ();
 
       if (val.is_defined ())
diff --git a/libinterp/corefcn/load-save.h b/libinterp/corefcn/load-save.h
--- a/libinterp/corefcn/load-save.h
+++ b/libinterp/corefcn/load-save.h
@@ -81,17 +81,17 @@ extern octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
          load_save_format format, octave::mach_info::float_format flt_fmt,
          bool list_only, bool swap, bool verbose,
          const string_vector& argv, int argv_idx, int argc, int nargout);
 
 extern OCTINTERP_API bool is_octave_data_file (const std::string& file);
 
 extern void
-do_save (std::ostream& os, const symbol_table::symbol_record& sr,
+do_save (std::ostream& os, const octave::symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats);
 
 extern void
 write_header (std::ostream& os, load_save_format format);
 
 extern void octave_prepare_hdf5 (void);
 
 extern void octave_finalize_hdf5 (void);
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -964,20 +964,20 @@ read_mat5_binary_element (std::istream& 
             tc2 = m2.contents ("MCOS").cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.scalar_map_value ();
 
             octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
-            symbol_table& symtab
+            octave::symbol_table& symtab
               = octave::__get_symbol_table__ ("read_mat5_binary_element");
 
-            symbol_table::scope local_scope;
+            octave::symbol_table::scope local_scope;
 
             symtab.set_scope (&local_scope);
 
             octave::call_stack& cs
               = octave::__get_call_stack__ ("read_mat5_binary_element");
             cs.push (&local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3420,17 +3420,17 @@ mexGetVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexGetVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          symbol_table::scope *scope
+          octave::symbol_table::scope *scope
             = octave::__require_current_scope__ ("mexGetVariable");
 
           val = scope->varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
@@ -3486,17 +3486,17 @@ mexPutVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexPutVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          symbol_table::scope *scope
+          octave::symbol_table::scope *scope
             = octave::__require_current_scope__ ("mexPutVariable");
 
           scope->assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -33,18 +33,18 @@ class octave_value_list;
 #include "ovl.h"
 #include "symtab.h"
 
 class
 octave_lvalue
 {
 public:
 
-  octave_lvalue (const symbol_table::symbol_reference& s
-                   = symbol_table::symbol_reference ())
+  octave_lvalue (const octave::symbol_table::symbol_reference& s
+                   = octave::symbol_table::symbol_reference ())
     : sym (s), type (), idx (), nel (1)
   { }
 
   octave_lvalue (const octave_lvalue& vr)
     : sym (vr.sym), type (vr.type), idx (vr.idx), nel (vr.nel)
   { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
@@ -93,17 +93,17 @@ public:
   bool index_is_empty (void) const;
 
   void do_unary_op (octave_value::unary_op op);
 
   octave_value value (void) const;
 
 private:
 
-  symbol_table::symbol_reference sym;
+  octave::symbol_table::symbol_reference sym;
 
   std::string type;
 
   std::list<octave_value_list> idx;
 
   octave_idx_type nel;
 };
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -60,21 +60,21 @@ octave_link::~octave_link (void)
   delete event_queue_mutex;
 }
 
 void
 octave_link::set_workspace (void)
 {
   if (enabled ())
     {
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_link::set_workspace");
 
       std::list<workspace_element> workspace_info;
-      symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_table::scope *scope = symtab.current_scope ();
       if (scope)
         workspace_info = scope->workspace_info ();
 
       instance->do_set_workspace (symtab.at_top_level (),
                                   instance->debugging, workspace_info);
     }
 }
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -44,204 +44,207 @@ along with Octave; see the file COPYING.
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
-octave_value symbol_table::dummy_octave_value;
-
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
-void
-symbol_table::symbol_record::symbol_record_rep::clear (scope *sid)
-{
-  if (! (is_hidden () || is_inherited ())
-      && sid == decl_scope ())
-    {
-      if (is_global ())
-        unmark_global ();
-
-      if (is_persistent ())
-        {
-          sid->persistent_assign (name, varval ());
-
-          unmark_persistent ();
-        }
-
-      assign (octave_value ());
-    }
-}
-
-void
-symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
-{
-  symbol_table::scope *scope
-    = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
-
-  if (! is_defined ())
-    {
-      mark_persistent ();
-
-      assign (scope->persistent_varval (name));
-    }
-  // FIXME: this causes trouble with recursive calls.
-  // else
-  //   error ("unable to declare existing variable persistent");
-}
-
-void
-symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
-{
-  unmark_persistent ();
-
-  symbol_table::scope *scope
-    = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
-
-  scope->erase_persistent (name);
-}
-
-symbol_table::symbol_record::symbol_record_rep *
-symbol_table::symbol_record::symbol_record_rep::dup (scope *new_scope) const
-{
-  return new symbol_record_rep (new_scope, name, varval (), storage_class);
-}
-
-octave_value
-symbol_table::symbol_record::symbol_record_rep::dump (void) const
-{
-  std::map<std::string, octave_value> m
-    = {{"name", name},
-       {"local", octave_value (is_local ())},
-       {"automatic", octave_value (is_automatic ())},
-       {"formal", octave_value (is_formal ())},
-       {"hidden", octave_value (is_hidden ())},
-       {"inherited", octave_value (is_inherited ())},
-       {"global", octave_value (is_global ())},
-       {"persistent", octave_value (is_persistent ())}};
-
-  octave_value val = varval ();
-
-  if (val.is_defined ())
-    m["value"] = val;
-
-  return octave_value (m);
-}
-
-octave_value&
-symbol_table::symbol_record::symbol_record_rep::xglobal_varref (void)
-{
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varref");
-
-  symbol_table::global_symbols_iterator p
-    = symtab.m_global_symbols.find (name);
-
-  return (p == symtab.m_global_symbols.end ()
-          ? symtab.m_global_symbols[name] : p->second);
-}
-
-octave_value&
-symbol_table::symbol_record::symbol_record_rep::xpersistent_varref (void)
+namespace octave
 {
-  symbol_table::scope *scope
-    = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
+  octave_value symbol_table::dummy_octave_value;
+
+  void
+  symbol_table::symbol_record::symbol_record_rep::clear (scope *sid)
+  {
+    if (! (is_hidden () || is_inherited ())
+        && sid == decl_scope ())
+      {
+        if (is_global ())
+          unmark_global ();
 
-  return scope ? scope->persistent_varref (name) : dummy_octave_value;
-}
+        if (is_persistent ())
+          {
+            sid->persistent_assign (name, varval ());
+
+            unmark_persistent ();
+          }
+
+        assign (octave_value ());
+      }
+  }
 
-octave_value
-symbol_table::symbol_record::symbol_record_rep::xglobal_varval (void) const
-{
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varval");
+  void
+  symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
+  {
+    symbol_table::scope *scope
+      = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
+
+    if (! is_defined ())
+      {
+        mark_persistent ();
 
-  return symtab.global_varval (name);
-}
+        assign (scope->persistent_varval (name));
+      }
+    // FIXME: this causes trouble with recursive calls.
+    // else
+    //   error ("unable to declare existing variable persistent");
+  }
 
-octave_value
-symbol_table::symbol_record::symbol_record_rep::xpersistent_varval (void) const
-{
-  symbol_table::scope *scope
-    = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
+  void
+  symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
+  {
+    unmark_persistent ();
 
-  return scope ? scope->persistent_varval (name) : octave_value ();
-}
+    symbol_table::scope *scope
+      = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
+
+    scope->erase_persistent (name);
+  }
 
-symbol_table::symbol_record::symbol_record (void)
-  : rep (new symbol_record_rep (octave::__get_current_scope__ ("symbol_record"),
-                                "", octave_value (), local))
-
-{ }
+  symbol_table::symbol_record::symbol_record_rep *
+  symbol_table::symbol_record::symbol_record_rep::dup (scope *new_scope) const
+  {
+    return new symbol_record_rep (new_scope, name, varval (), storage_class);
+  }
 
-octave_value
-symbol_table::symbol_record::find (const octave_value_list& args) const
-{
-  octave_value retval;
+  octave_value
+  symbol_table::symbol_record::symbol_record_rep::dump (void) const
+  {
+    std::map<std::string, octave_value> m
+      = {{"name", name},
+         {"local", octave_value (is_local ())},
+         {"automatic", octave_value (is_automatic ())},
+         {"formal", octave_value (is_formal ())},
+         {"hidden", octave_value (is_hidden ())},
+         {"inherited", octave_value (is_inherited ())},
+         {"global", octave_value (is_global ())},
+         {"persistent", octave_value (is_persistent ())}};
+
+    octave_value val = varval ();
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::find");
+    if (val.is_defined ())
+      m["value"] = val;
+
+    return octave_value (m);
+  }
 
-  if (is_global ())
-    retval = symtab.global_varval (name ());
-  else
-    {
-      retval = varval ();
+  octave_value&
+  symbol_table::symbol_record::symbol_record_rep::xglobal_varref (void)
+  {
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varref");
+
+    symbol_table::global_symbols_iterator p
+      = symtab.m_global_symbols.find (name);
+
+    return (p == symtab.m_global_symbols.end ()
+            ? symtab.m_global_symbols[name] : p->second);
+  }
 
-      if (retval.is_undefined ())
-        {
-#if 0
-          // Use cached fcn_info pointer if possible.
-          if (rep->finfo)
-            retval = rep->finfo->find (args);
-          else
-#endif
-            {
-              retval = symtab.find_function (name (), args);
+  octave_value&
+  symbol_table::symbol_record::symbol_record_rep::xpersistent_varref (void)
+  {
+    symbol_table::scope *scope
+      = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
+
+    return scope ? scope->persistent_varref (name) : dummy_octave_value;
+  }
+
+  octave_value
+  symbol_table::symbol_record::symbol_record_rep::xglobal_varval (void) const
+  {
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varval");
+
+    return symtab.global_varval (name);
+  }
 
-              if (retval.is_defined ())
-                return retval;
-#if 0
-              {
-                  rep->finfo = symtab.get_fcn_info (name ());
-              }
-#endif
-            }
-        }
-    }
+  octave_value
+  symbol_table::symbol_record::symbol_record_rep::xpersistent_varval (void) const
+  {
+    symbol_table::scope *scope
+      = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
+
+    return scope ? scope->persistent_varval (name) : octave_value ();
+  }
+
+  symbol_table::symbol_record::symbol_record (void)
+    : rep (new symbol_record_rep (octave::__get_current_scope__ ("symbol_record"),
+                                  "", octave_value (), local))
+
+  { }
+
+  octave_value
+  symbol_table::symbol_record::find (const octave_value_list& args) const
+  {
+    octave_value retval;
+
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::symbol_record::find");
+
+    if (is_global ())
+      retval = symtab.global_varval (name ());
+    else
+      {
+        retval = varval ();
 
-  return retval;
-}
-
-symbol_table::symbol_record
-symbol_table::dummy_symbol_record (static_cast<symbol_table::scope*> (nullptr));
+        if (retval.is_undefined ())
+          {
+#if 0
+            // Use cached fcn_info pointer if possible.
+            if (rep->finfo)
+              retval = rep->finfo->find (args);
+            else
+#endif
+              {
+                retval = symtab.find_function (name (), args);
 
-symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
-  : m_scope (0), m_context (0),m_sym (record)
-{
-  m_scope = octave::__get_current_scope__ ("symbol_reference");
-}
+                if (retval.is_defined ())
+                  return retval;
+#if 0
+                {
+                  rep->finfo = symtab.get_fcn_info (name ());
+                }
+#endif
+              }
+          }
+      }
 
-void
-symbol_table::symbol_reference::update (void) const
-{
-  symbol_table::scope *curr_scope
-    = octave::__get_current_scope__ ("symbol_reference::update");
+    return retval;
+  }
+
+  symbol_table::symbol_record
+  symbol_table::dummy_symbol_record (static_cast<symbol_table::scope*> (nullptr));
+
+  symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
+    : m_scope (0), m_context (0),m_sym (record)
+  {
+    m_scope = octave::__get_current_scope__ ("symbol_reference");
+  }
 
-  if (curr_scope && (m_scope != curr_scope || ! m_sym.is_valid ()))
-    {
-      m_scope = curr_scope;
-      m_sym = m_scope->insert (m_sym.name ());  // ???
-    }
+  void
+  symbol_table::symbol_reference::update (void) const
+  {
+    symbol_table::scope *curr_scope
+      = octave::__get_current_scope__ ("symbol_reference::update");
 
-  m_context = m_scope ? m_scope->current_context () : 0;
+    if (curr_scope && (m_scope != curr_scope || ! m_sym.is_valid ()))
+      {
+        m_scope = curr_scope;
+        m_sym = m_scope->insert (m_sym.name ());  // ???
+      }
+
+    m_context = m_scope ? m_scope->current_context () : 0;
+  }
 }
 
 static void
 split_name_with_package (const std::string& name, std::string& fname,
                          std::string& pname)
 {
   size_t pos = name.rfind ('.');
 
@@ -289,391 +292,394 @@ load_out_of_date_fcn (const std::string&
       function = ov_fcn;
     }
   else
     function = octave_value ();
 
   return retval;
 }
 
-bool
-out_of_date_check (octave_value& function,
-                   const std::string& dispatch_type,
-                   bool check_relative)
+namespace octave
 {
-  bool retval = false;
+  bool
+  out_of_date_check (octave_value& function,
+                     const std::string& dispatch_type,
+                     bool check_relative)
+  {
+    bool retval = false;
 
-  octave_function *fcn = function.function_value (true);
+    octave_function *fcn = function.function_value (true);
 
-  if (fcn)
-    {
-      // FIXME: we need to handle subfunctions properly here.
+    if (fcn)
+      {
+        // FIXME: we need to handle subfunctions properly here.
 
-      if (! fcn->is_subfunction ())
-        {
-          std::string ff = fcn->fcn_file_name ();
+        if (! fcn->is_subfunction ())
+          {
+            std::string ff = fcn->fcn_file_name ();
 
-          if (! ff.empty ())
-            {
-              octave::sys::time tc = fcn->time_checked ();
+            if (! ff.empty ())
+              {
+                octave::sys::time tc = fcn->time_checked ();
 
-              bool relative = check_relative && fcn->is_relative ();
+                bool relative = check_relative && fcn->is_relative ();
 
-              if (tc <= Vlast_prompt_time
-                  || (relative && tc < Vlast_chdir_time))
-                {
-                  bool clear_breakpoints = false;
-                  std::string nm = fcn->name ();
-                  std::string pack = fcn->package_name ();
-                  std::string canonical_nm = fcn->canonical_name ();
+                if (tc <= Vlast_prompt_time
+                    || (relative && tc < Vlast_chdir_time))
+                  {
+                    bool clear_breakpoints = false;
+                    std::string nm = fcn->name ();
+                    std::string pack = fcn->package_name ();
+                    std::string canonical_nm = fcn->canonical_name ();
 
-                  bool is_same_file = false;
+                    bool is_same_file = false;
 
-                  std::string file;
-                  std::string dir_name;
+                    std::string file;
+                    std::string dir_name;
 
-                  if (check_relative)
-                    {
-                      int nm_len = nm.length ();
+                    if (check_relative)
+                      {
+                        int nm_len = nm.length ();
 
-                      if (octave::sys::env::absolute_pathname (nm)
-                          && ((nm_len > 4
-                               && (nm.substr (nm_len-4) == ".oct"
-                                   || nm.substr (nm_len-4) == ".mex"))
-                              || (nm_len > 2
-                                  && nm.substr (nm_len-2) == ".m")))
-                        file = nm;
-                      else
-                        {
-                          // We don't want to make this an absolute name,
-                          // because load_fcn_file looks at the name to
-                          // decide whether it came from a relative lookup.
+                        if (octave::sys::env::absolute_pathname (nm)
+                            && ((nm_len > 4
+                                 && (nm.substr (nm_len-4) == ".oct"
+                                     || nm.substr (nm_len-4) == ".mex"))
+                                || (nm_len > 2
+                                    && nm.substr (nm_len-2) == ".m")))
+                          file = nm;
+                        else
+                          {
+                            // We don't want to make this an absolute name,
+                            // because load_fcn_file looks at the name to
+                            // decide whether it came from a relative lookup.
 
-                          if (! dispatch_type.empty ())
-                            {
-                              octave::load_path& lp = octave::__get_load_path__ ("out_of_date_check");
+                            if (! dispatch_type.empty ())
+                              {
+                                octave::load_path& lp = octave::__get_load_path__ ("out_of_date_check");
 
-                              file = lp.find_method (dispatch_type, nm,
-                                                     dir_name, pack);
+                                file = lp.find_method (dispatch_type, nm,
+                                                       dir_name, pack);
 
-                              if (file.empty ())
-                                {
-                                  std::string s_name;
-                                  std::string s_pack;
+                                if (file.empty ())
+                                  {
+                                    std::string s_name;
+                                    std::string s_pack;
 
-                                  symbol_table& symtab
-                                    = octave::__get_symbol_table__ ("out_of_date_check");
+                                    symbol_table& symtab
+                                      = octave::__get_symbol_table__ ("out_of_date_check");
 
-                                  const std::list<std::string>& plist
-                                    = symtab.parent_classes (dispatch_type);
+                                    const std::list<std::string>& plist
+                                      = symtab.parent_classes (dispatch_type);
 
-                                  std::list<std::string>::const_iterator it
-                                    = plist.begin ();
+                                    std::list<std::string>::const_iterator it
+                                      = plist.begin ();
 
-                                  while (it != plist.end ())
-                                    {
-                                      split_name_with_package (*it, s_name,
+                                    while (it != plist.end ())
+                                      {
+                                        split_name_with_package (*it, s_name,
+                                                                 s_pack);
+
+                                        file = lp.find_method (*it, nm, dir_name,
                                                                s_pack);
+                                        if (! file.empty ())
+                                          {
+                                            pack = s_pack;
+                                            break;
+                                          }
 
-                                      file = lp.find_method (*it, nm, dir_name,
-                                                             s_pack);
-                                      if (! file.empty ())
-                                        {
-                                          pack = s_pack;
-                                          break;
-                                        }
-
-                                      it++;
-                                    }
-                                }
-                            }
+                                        it++;
+                                      }
+                                  }
+                              }
 
-                          // Maybe it's an autoload?
-                          if (file.empty ())
-                            file = octave::lookup_autoload (nm);
+                            // Maybe it's an autoload?
+                            if (file.empty ())
+                              file = octave::lookup_autoload (nm);
 
-                          if (file.empty ())
-                            {
-                              octave::load_path& lp = octave::__get_load_path__ ("out_of_date_check");
-                              file = lp.find_fcn (nm, dir_name, pack);
-                            }
-                        }
+                            if (file.empty ())
+                              {
+                                octave::load_path& lp = octave::__get_load_path__ ("out_of_date_check");
+                                file = lp.find_fcn (nm, dir_name, pack);
+                              }
+                          }
 
-                      if (! file.empty ())
-                        is_same_file = same_file (file, ff);
-                    }
-                  else
-                    {
-                      is_same_file = true;
-                      file = ff;
-                    }
+                        if (! file.empty ())
+                          is_same_file = same_file (file, ff);
+                      }
+                    else
+                      {
+                        is_same_file = true;
+                        file = ff;
+                      }
 
-                  if (file.empty ())
-                    {
-                      // Can't see this function from current
-                      // directory, so we should clear it.
+                    if (file.empty ())
+                      {
+                        // Can't see this function from current
+                        // directory, so we should clear it.
 
-                      function = octave_value ();
+                        function = octave_value ();
 
-                      clear_breakpoints = true;
-                    }
-                  else if (is_same_file)
-                    {
-                      // Same file.  If it is out of date, then reload it.
+                        clear_breakpoints = true;
+                      }
+                    else if (is_same_file)
+                      {
+                        // Same file.  If it is out of date, then reload it.
 
-                      octave::sys::time ottp = fcn->time_parsed ();
-                      time_t tp = ottp.unix_time ();
+                        octave::sys::time ottp = fcn->time_parsed ();
+                        time_t tp = ottp.unix_time ();
 
-                      fcn->mark_fcn_file_up_to_date (octave::sys::time ());
+                        fcn->mark_fcn_file_up_to_date (octave::sys::time ());
 
-                      if (! (Vignore_function_time_stamp == 2
-                             || (Vignore_function_time_stamp
-                                 && fcn->is_system_fcn_file ())))
-                        {
-                          octave::sys::file_stat fs (ff);
+                        if (! (Vignore_function_time_stamp == 2
+                               || (Vignore_function_time_stamp
+                                   && fcn->is_system_fcn_file ())))
+                          {
+                            octave::sys::file_stat fs (ff);
 
-                          if (fs)
-                            {
-                              if (fs.is_newer (tp))
-                                {
-                                  retval = load_out_of_date_fcn (ff, dir_name,
-                                                                 function,
-                                                                 dispatch_type,
-                                                                 pack);
+                            if (fs)
+                              {
+                                if (fs.is_newer (tp))
+                                  {
+                                    retval = load_out_of_date_fcn (ff, dir_name,
+                                                                   function,
+                                                                   dispatch_type,
+                                                                   pack);
 
-                                  clear_breakpoints = true;
-                                }
-                            }
-                          else
-                            {
-                              function = octave_value ();
+                                    clear_breakpoints = true;
+                                  }
+                              }
+                            else
+                              {
+                                function = octave_value ();
 
-                              clear_breakpoints = true;
-                            }
-                        }
-                    }
-                  else
-                    {
-                      // Not the same file, so load the new file in
-                      // place of the old.
+                                clear_breakpoints = true;
+                              }
+                          }
+                      }
+                    else
+                      {
+                        // Not the same file, so load the new file in
+                        // place of the old.
 
-                      retval = load_out_of_date_fcn (file, dir_name, function,
-                                                     dispatch_type, pack);
+                        retval = load_out_of_date_fcn (file, dir_name, function,
+                                                       dispatch_type, pack);
 
-                      clear_breakpoints = true;
-                    }
+                        clear_breakpoints = true;
+                      }
 
-                  // If the function has been replaced then clear any
-                  // breakpoints associated with it
-                  if (clear_breakpoints)
-                    bp_table::remove_all_breakpoints_in_file (canonical_nm,
-                                                              true);
-                }
-            }
-        }
-    }
+                    // If the function has been replaced then clear any
+                    // breakpoints associated with it
+                    if (clear_breakpoints)
+                      bp_table::remove_all_breakpoints_in_file (canonical_nm,
+                                                                true);
+                  }
+              }
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::load_private_function
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::load_private_function
   (const std::string& dir_name)
-{
-  octave_value retval;
+  {
+    octave_value retval;
 
-  octave::load_path& lp
-    = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_private_function");
+    octave::load_path& lp
+      = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_private_function");
 
-  std::string file_name = lp.find_private_fcn (dir_name, name);
+    std::string file_name = lp.find_private_fcn (dir_name, name);
 
-  if (file_name.empty ())
-    return retval;
+    if (file_name.empty ())
+      return retval;
 
-  octave_value ov_fcn = octave::load_fcn_from_file (file_name, dir_name);
+    octave_value ov_fcn = octave::load_fcn_from_file (file_name, dir_name);
 
-  if (ov_fcn.is_undefined ())
-    return retval;
+    if (ov_fcn.is_undefined ())
+      return retval;
 
-  octave_function *tmpfcn = ov_fcn.function_value ();
+    octave_function *tmpfcn = ov_fcn.function_value ();
 
-  if (! tmpfcn)
-    return retval;
+    if (! tmpfcn)
+      return retval;
 
-  std::string class_name;
+    std::string class_name;
 
-  size_t pos = dir_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+    size_t pos = dir_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
-  if (pos != std::string::npos)
-    {
-      std::string tmp = dir_name.substr (pos+1);
+    if (pos != std::string::npos)
+      {
+        std::string tmp = dir_name.substr (pos+1);
 
-      if (tmp[0] == '@')
-        class_name = tmp.substr (1);
-    }
+        if (tmp[0] == '@')
+          class_name = tmp.substr (1);
+      }
 
-  tmpfcn->mark_as_private_function (class_name);
+    tmpfcn->mark_as_private_function (class_name);
 
-  private_functions[dir_name] = ov_fcn;
+    private_functions[dir_name] = ov_fcn;
 
-  return ov_fcn;
-}
+    return ov_fcn;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
-{
-  octave_value retval;
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
+  {
+    octave_value retval;
 
-  std::string dir_name;
+    std::string dir_name;
 
-  octave::load_path& lp
-    = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_constructor");
+    octave::load_path& lp
+      = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_constructor");
 
-  std::string file_name = lp.find_method (name, name, dir_name, package_name);
+    std::string file_name = lp.find_method (name, name, dir_name, package_name);
 
-  if (! file_name.empty ())
-    {
-      octave_value ov_fcn
-        = octave::load_fcn_from_file (file_name, dir_name, name,
-                                      package_name);
+    if (! file_name.empty ())
+      {
+        octave_value ov_fcn
+          = octave::load_fcn_from_file (file_name, dir_name, name,
+                                        package_name);
 
-      if (ov_fcn.is_defined ())
-        {
-          // Note: ov_fcn may be an octave_classdef_meta object instead
-          // of the actual constructor function.
+        if (ov_fcn.is_defined ())
+          {
+            // Note: ov_fcn may be an octave_classdef_meta object instead
+            // of the actual constructor function.
 
-          retval = ov_fcn;
+            retval = ov_fcn;
 
-          class_constructors[name] = retval;
-          class_methods[name] = retval;
-        }
-    }
-  else
-    {
-      // Classdef constructors can be defined anywhere in the path, not
-      // necessarily in @-folders.  Look for a normal function and load it.
-      // If the loaded function is a classdef constructor, store it as such
-      // and restore function_on_path to its previous value.
+            class_constructors[name] = retval;
+            class_methods[name] = retval;
+          }
+      }
+    else
+      {
+        // Classdef constructors can be defined anywhere in the path, not
+        // necessarily in @-folders.  Look for a normal function and load it.
+        // If the loaded function is a classdef constructor, store it as such
+        // and restore function_on_path to its previous value.
 
-      octave_value old_function_on_path = function_on_path;
+        octave_value old_function_on_path = function_on_path;
 
-      octave_value maybe_cdef_ctor = find_user_function ();
+        octave_value maybe_cdef_ctor = find_user_function ();
 
-      if (maybe_cdef_ctor.is_defined ())
-        {
-          octave_function *fcn = maybe_cdef_ctor.function_value (true);
+        if (maybe_cdef_ctor.is_defined ())
+          {
+            octave_function *fcn = maybe_cdef_ctor.function_value (true);
 
-          if (fcn && fcn->is_classdef_constructor ())
-            {
-              retval = maybe_cdef_ctor;
+            if (fcn && fcn->is_classdef_constructor ())
+              {
+                retval = maybe_cdef_ctor;
 
-              class_constructors[name] = retval;
-              class_methods[name] = retval;
+                class_constructors[name] = retval;
+                class_methods[name] = retval;
 
-              function_on_path = old_function_on_path;
-            }
-        }
-    }
+                function_on_path = old_function_on_path;
+              }
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::load_class_method
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::load_class_method
   (const std::string& dispatch_type)
-{
-  octave_value retval;
+  {
+    octave_value retval;
 
-  if (full_name () == dispatch_type)
-    retval = load_class_constructor ();
-  else
-    {
-      cdef_manager& cdm
-        = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+    if (full_name () == dispatch_type)
+      retval = load_class_constructor ();
+    else
+      {
+        cdef_manager& cdm
+          = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
 
-      octave_function *cm = cdm.find_method_symbol (name, dispatch_type);
+        octave_function *cm = cdm.find_method_symbol (name, dispatch_type);
 
-      if (cm)
-        retval = octave_value (cm);
+        if (cm)
+          retval = octave_value (cm);
 
-      if (! retval.is_defined ())
-        {
-          std::string dir_name;
+        if (! retval.is_defined ())
+          {
+            std::string dir_name;
 
-          octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+            octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
 
-          std::string file_name = lp.find_method (dispatch_type, name,
-                                                  dir_name);
+            std::string file_name = lp.find_method (dispatch_type, name,
+                                                    dir_name);
 
-          if (! file_name.empty ())
-            {
-              octave_value ov_fcn
-                = octave::load_fcn_from_file (file_name, dir_name,
-                                              dispatch_type);
+            if (! file_name.empty ())
+              {
+                octave_value ov_fcn
+                  = octave::load_fcn_from_file (file_name, dir_name,
+                                                dispatch_type);
 
-              if (ov_fcn.is_defined ())
-                {
-                  octave_function *tmpfcn = ov_fcn.function_value ();
+                if (ov_fcn.is_defined ())
+                  {
+                    octave_function *tmpfcn = ov_fcn.function_value ();
 
-                  if (tmpfcn && tmpfcn->is_class_method (dispatch_type))
-                    {
-                      retval = ov_fcn;
+                    if (tmpfcn && tmpfcn->is_class_method (dispatch_type))
+                      {
+                        retval = ov_fcn;
+
+                        class_methods[dispatch_type] = retval;
+                      }
+                  }
+              }
 
-                      class_methods[dispatch_type] = retval;
-                    }
-                }
-            }
+            if (retval.is_undefined ())
+              {
+                // Search parent classes
 
-          if (retval.is_undefined ())
-            {
-              // Search parent classes
+                symbol_table& symtab
+                  = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+
+                const std::list<std::string>& plist =
+                  symtab.parent_classes (dispatch_type);
 
-              symbol_table& symtab
-                = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+                std::list<std::string>::const_iterator it = plist.begin ();
 
-              const std::list<std::string>& plist =
-                symtab.parent_classes (dispatch_type);
+                while (it != plist.end ())
+                  {
+                    retval = find_method (*it);
 
-              std::list<std::string>::const_iterator it = plist.begin ();
-
-              while (it != plist.end ())
-                {
-                  retval = find_method (*it);
+                    if (retval.is_defined ())
+                      {
+                        class_methods[dispatch_type] = retval;
+                        break;
+                      }
 
-                  if (retval.is_defined ())
-                    {
-                      class_methods[dispatch_type] = retval;
-                      break;
-                    }
+                    it++;
+                  }
+              }
 
-                  it++;
-                }
-            }
+            if (retval.is_undefined ())
+              {
+                // Search for built-in functions that are declared to
+                // handle specific types.
 
-          if (retval.is_undefined ())
-            {
-              // Search for built-in functions that are declared to
-              // handle specific types.
+                if (built_in_function.is_defined ())
+                  {
+                    octave_function *fcn = built_in_function.function_value ();
 
-              if (built_in_function.is_defined ())
-                {
-                  octave_function *fcn = built_in_function.function_value ();
-
-                  if (fcn && fcn->handles_dispatch_class (dispatch_type))
-                    {
-                      retval = built_in_function;
+                    if (fcn && fcn->handles_dispatch_class (dispatch_type))
+                      {
+                        retval = built_in_function;
 
-                      class_methods[dispatch_type] = retval;
-                    }
-                }
-            }
-        }
-    }
+                        class_methods[dispatch_type] = retval;
+                      }
+                  }
+              }
+          }
+      }
 
-  return retval;
+    return retval;
+  }
 }
 
 // :-) JWE, can you parse this? Returns a 2D array with second dimension equal
 // to btyp_num_types (static constant).  Only the leftmost dimension can be
 // variable in C/C++.  Typedefs are boring.
 
 static builtin_type_t (*build_sup_table (void))[btyp_num_types]
 {
@@ -695,589 +701,592 @@ static builtin_type_t (*build_sup_table 
                            || jtyp == btyp_float_complex)))));
 
         sup_table[i][j] = (use_j ? jtyp : ityp);
       }
 
   return sup_table;
 }
 
-std::string
-get_dispatch_type (const octave_value_list& args,
-                   builtin_type_t& builtin_type)
+namespace octave
 {
-  static builtin_type_t (*sup_table)[btyp_num_types] = build_sup_table ();
-  std::string dispatch_type;
-
-  int n = args.length ();
+  std::string
+  get_dispatch_type (const octave_value_list& args,
+                     builtin_type_t& builtin_type)
+  {
+    static builtin_type_t (*sup_table)[btyp_num_types] = build_sup_table ();
+    std::string dispatch_type;
 
-  if (n > 0)
-    {
-      int i = 0;
-      builtin_type = args(0).builtin_type ();
-      if (builtin_type != btyp_unknown)
-        {
-          for (i = 1; i < n; i++)
-            {
-              builtin_type_t bti = args(i).builtin_type ();
-              if (bti != btyp_unknown)
-                builtin_type = sup_table[builtin_type][bti];
-              else
-                {
-                  builtin_type = btyp_unknown;
-                  break;
-                }
-            }
-        }
+    int n = args.length ();
 
-      if (builtin_type == btyp_unknown)
-        {
-          // There's a non-builtin class in the argument list.
-          dispatch_type = args(i).class_name ();
-
-          symbol_table& symtab = octave::__get_symbol_table__ ("get_dispatch_type");
-
-          for (int j = i+1; j < n; j++)
-            {
-              octave_value arg = args(j);
+    if (n > 0)
+      {
+        int i = 0;
+        builtin_type = args(0).builtin_type ();
+        if (builtin_type != btyp_unknown)
+          {
+            for (i = 1; i < n; i++)
+              {
+                builtin_type_t bti = args(i).builtin_type ();
+                if (bti != btyp_unknown)
+                  builtin_type = sup_table[builtin_type][bti];
+                else
+                  {
+                    builtin_type = btyp_unknown;
+                    break;
+                  }
+              }
+          }
 
-              if (arg.builtin_type () == btyp_unknown)
-                {
-                  std::string cname = arg.class_name ();
+        if (builtin_type == btyp_unknown)
+          {
+            // There's a non-builtin class in the argument list.
+            dispatch_type = args(i).class_name ();
+
+            symbol_table& symtab = octave::__get_symbol_table__ ("get_dispatch_type");
 
-                  // Only switch to type of ARG if it is marked superior
-                  // to the current DISPATCH_TYPE.
-                  if (! symtab.is_superiorto (dispatch_type, cname)
-                      && symtab.is_superiorto (cname, dispatch_type))
-                    dispatch_type = cname;
-                }
-            }
-        }
-      else
-        dispatch_type = btyp_class_name[builtin_type];
-    }
-  else
-    builtin_type = btyp_unknown;
+            for (int j = i+1; j < n; j++)
+              {
+                octave_value arg = args(j);
+
+                if (arg.builtin_type () == btyp_unknown)
+                  {
+                    std::string cname = arg.class_name ();
 
-  return dispatch_type;
-}
-
-std::string
-get_dispatch_type (const octave_value_list& args)
-{
-  builtin_type_t builtin_type;
-  return get_dispatch_type (args, builtin_type);
-}
+                    // Only switch to type of ARG if it is marked superior
+                    // to the current DISPATCH_TYPE.
+                    if (! symtab.is_superiorto (dispatch_type, cname)
+                        && symtab.is_superiorto (cname, dispatch_type))
+                      dispatch_type = cname;
+                  }
+              }
+          }
+        else
+          dispatch_type = btyp_class_name[builtin_type];
+      }
+    else
+      builtin_type = btyp_unknown;
 
-// Find function definition according to the following precedence list:
-//
-//   private function
-//   class method
-//   class constructor
-//   command-line function
-//   autoload function
-//   function on the path
-//   built-in function
-//
-// Matlab documentation states that constructors have higher precedence
-// than methods, but that does not seem to be the case.
+    return dispatch_type;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::find (const octave_value_list& args,
-                                            bool local_funcs)
-{
-  octave_value retval = xfind (args, local_funcs);
+  std::string
+  get_dispatch_type (const octave_value_list& args)
+  {
+    builtin_type_t builtin_type;
+    return get_dispatch_type (args, builtin_type);
+  }
 
-  if (retval.is_undefined ())
-    {
-      // It is possible that the user created a file on the fly since
-      // the last prompt or chdir, so try updating the load path and
-      // searching again.
+  // Find function definition according to the following precedence list:
+  //
+  //   private function
+  //   class method
+  //   class constructor
+  //   command-line function
+  //   autoload function
+  //   function on the path
+  //   built-in function
+  //
+  // Matlab documentation states that constructors have higher precedence
+  // than methods, but that does not seem to be the case.
 
-      octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find");
-
-      lp.update ();
-
-      retval = xfind (args, local_funcs);
-    }
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::find (const octave_value_list& args,
+                                              bool local_funcs)
+  {
+    octave_value retval = xfind (args, local_funcs);
 
-  return retval;
-}
+    if (retval.is_undefined ())
+      {
+        // It is possible that the user created a file on the fly since
+        // the last prompt or chdir, so try updating the load path and
+        // searching again.
+
+        octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find");
+
+        lp.update ();
+
+        retval = xfind (args, local_funcs);
+      }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
-                                             bool local_funcs)
-{
-  if (local_funcs)
-    {
-      symbol_table::scope *scope
-        = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
+    return retval;
+  }
 
-      octave_user_function *current_fcn = scope ? scope->function () : 0;
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
+                                               bool local_funcs)
+  {
+    if (local_funcs)
+      {
+        symbol_table::scope *scope
+          = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
 
-      // Local function.
+        octave_user_function *current_fcn = scope ? scope->function () : 0;
+
+        // Local function.
 
-      if (current_fcn)
-        {
-          std::string fcn_file = current_fcn->fcn_file_name ();
+        if (current_fcn)
+          {
+            std::string fcn_file = current_fcn->fcn_file_name ();
 
-          if (! fcn_file.empty ())
-            {
-              str_val_iterator r = local_functions.find (fcn_file);
-
-              if (r != local_functions.end ())
-                {
-                  // We shouldn't need an out-of-date check here since
-                  // local functions may ultimately be called only from
-                  // a primary function or method defined in the same
-                  // file.
+            if (! fcn_file.empty ())
+              {
+                str_val_iterator r = local_functions.find (fcn_file);
 
-                  return r->second;
-                }
-            }
-        }
-
-      // Private function.
+                if (r != local_functions.end ())
+                  {
+                    // We shouldn't need an out-of-date check here since
+                    // local functions may ultimately be called only from
+                    // a primary function or method defined in the same
+                    // file.
 
-      if (current_fcn)
-        {
-          std::string dir_name = current_fcn->dir_name ();
+                    return r->second;
+                  }
+              }
+          }
 
-          if (! dir_name.empty ())
-            {
-              str_val_iterator q = private_functions.find (dir_name);
+        // Private function.
+
+        if (current_fcn)
+          {
+            std::string dir_name = current_fcn->dir_name ();
 
-              if (q == private_functions.end ())
-                {
-                  octave_value val = load_private_function (dir_name);
+            if (! dir_name.empty ())
+              {
+                str_val_iterator q = private_functions.find (dir_name);
 
-                  if (val.is_defined ())
-                    return val;
-                }
-              else
-                {
-                  octave_value& fval = q->second;
+                if (q == private_functions.end ())
+                  {
+                    octave_value val = load_private_function (dir_name);
 
-                  if (fval.is_defined ())
-                    out_of_date_check (fval, "", false);
+                    if (val.is_defined ())
+                      return val;
+                  }
+                else
+                  {
+                    octave_value& fval = q->second;
 
-                  if (fval.is_defined ())
-                    return fval;
-                  else
-                    {
-                      octave_value val = load_private_function (dir_name);
+                    if (fval.is_defined ())
+                      out_of_date_check (fval, "", false);
 
-                      if (val.is_defined ())
-                        return val;
-                    }
-                }
-            }
-        }
-    }
+                    if (fval.is_defined ())
+                      return fval;
+                    else
+                      {
+                        octave_value val = load_private_function (dir_name);
 
-  // Class methods.
+                        if (val.is_defined ())
+                          return val;
+                      }
+                  }
+              }
+          }
+      }
 
-  if (! args.empty ())
-    {
-      std::string dispatch_type = get_dispatch_type (args);
+    // Class methods.
 
-      octave_value fcn = find_method (dispatch_type);
+    if (! args.empty ())
+      {
+        std::string dispatch_type = get_dispatch_type (args);
 
-      if (fcn.is_defined ())
-        return fcn;
-    }
+        octave_value fcn = find_method (dispatch_type);
 
-  // Class constructors.  The class name and function name are the same.
+        if (fcn.is_defined ())
+          return fcn;
+      }
 
-  str_val_iterator q = class_constructors.find (name);
+    // Class constructors.  The class name and function name are the same.
 
-  if (q == class_constructors.end ())
-    {
-      octave_value val = load_class_constructor ();
+    str_val_iterator q = class_constructors.find (name);
+
+    if (q == class_constructors.end ())
+      {
+        octave_value val = load_class_constructor ();
 
-      if (val.is_defined ())
-        return val;
-    }
-  else
-    {
-      octave_value& fval = q->second;
+        if (val.is_defined ())
+          return val;
+      }
+    else
+      {
+        octave_value& fval = q->second;
 
-      if (fval.is_defined ())
-        out_of_date_check (fval, name);
+        if (fval.is_defined ())
+          out_of_date_check (fval, name);
 
-      if (fval.is_defined ())
-        return fval;
-      else
-        {
-          octave_value val = load_class_constructor ();
+        if (fval.is_defined ())
+          return fval;
+        else
+          {
+            octave_value val = load_class_constructor ();
 
-          if (val.is_defined ())
-            return val;
-        }
-    }
+            if (val.is_defined ())
+              return val;
+          }
+      }
 
-  // Command-line function.
-
-  if (cmdline_function.is_defined ())
-    return cmdline_function;
+    // Command-line function.
 
-  // Autoload?
+    if (cmdline_function.is_defined ())
+      return cmdline_function;
 
-  octave_value fcn = find_autoload ();
+    // Autoload?
 
-  if (fcn.is_defined ())
-    return fcn;
+    octave_value fcn = find_autoload ();
 
-  // Function on the path.
+    if (fcn.is_defined ())
+      return fcn;
 
-  fcn = find_user_function ();
+    // Function on the path.
 
-  if (fcn.is_defined ())
-    return fcn;
+    fcn = find_user_function ();
 
-  // Package
+    if (fcn.is_defined ())
+      return fcn;
 
-  fcn = find_package ();
+    // Package
 
-  if (fcn.is_defined ())
-    return fcn;
+    fcn = find_package ();
 
-  // Built-in function (might be undefined).
+    if (fcn.is_defined ())
+      return fcn;
 
-  return built_in_function;
-}
+    // Built-in function (might be undefined).
 
-// Find the definition of NAME according to the following precedence
-// list:
-//
-//   built-in function
-//   function on the path
-//   autoload function
-//   command-line function
-//   private function
-//   subfunction
+    return built_in_function;
+  }
 
-// This function is used to implement the "builtin" function, which
-// searches for "built-in" functions.  In Matlab, "builtin" only
-// returns functions that are actually built-in to the interpreter.
-// But since the list of built-in functions is different in Octave and
-// Matlab, we also search up the precedence list until we find
-// something that matches.  Note that we are only searching by name,
-// so class methods and constructors are skipped.
+  // Find the definition of NAME according to the following precedence
+  // list:
+  //
+  //   built-in function
+  //   function on the path
+  //   autoload function
+  //   command-line function
+  //   private function
+  //   subfunction
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::builtin_find (void)
-{
-  octave_value retval = x_builtin_find ();
+  // This function is used to implement the "builtin" function, which
+  // searches for "built-in" functions.  In Matlab, "builtin" only
+  // returns functions that are actually built-in to the interpreter.
+  // But since the list of built-in functions is different in Octave and
+  // Matlab, we also search up the precedence list until we find
+  // something that matches.  Note that we are only searching by name,
+  // so class methods and constructors are skipped.
 
-  if (! retval.is_defined ())
-    {
-      // It is possible that the user created a file on the fly since
-      // the last prompt or chdir, so try updating the load path and
-      // searching again.
-
-      octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::builtin_find");
-
-      lp.update ();
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::builtin_find (void)
+  {
+    octave_value retval = x_builtin_find ();
 
-      retval = x_builtin_find ();
-    }
+    if (! retval.is_defined ())
+      {
+        // It is possible that the user created a file on the fly since
+        // the last prompt or chdir, so try updating the load path and
+        // searching again.
 
-  return retval;
-}
+        octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::builtin_find");
+
+        lp.update ();
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::x_builtin_find (void)
-{
-  // Built-in function.
-  if (built_in_function.is_defined ())
-    return built_in_function;
+        retval = x_builtin_find ();
+      }
+
+    return retval;
+  }
 
-  // Function on the path.
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::x_builtin_find (void)
+  {
+    // Built-in function.
+    if (built_in_function.is_defined ())
+      return built_in_function;
 
-  octave_value fcn = find_user_function ();
+    // Function on the path.
 
-  if (fcn.is_defined ())
-    return fcn;
+    octave_value fcn = find_user_function ();
 
-  // Autoload?
+    if (fcn.is_defined ())
+      return fcn;
 
-  fcn = find_autoload ();
+    // Autoload?
 
-  if (fcn.is_defined ())
-    return fcn;
+    fcn = find_autoload ();
 
-  // Command-line function.
+    if (fcn.is_defined ())
+      return fcn;
 
-  if (cmdline_function.is_defined ())
-    return cmdline_function;
+    // Command-line function.
 
-  // Private function.
+    if (cmdline_function.is_defined ())
+      return cmdline_function;
+
+    // Private function.
 
-  symbol_table::scope *scope
-    = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+    symbol_table::scope *scope
+      = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
-  octave_user_function *current_fcn = scope ? scope->function () : 0;
+    octave_user_function *current_fcn = scope ? scope->function () : 0;
 
-  if (current_fcn)
-    {
-      std::string dir_name = current_fcn->dir_name ();
+    if (current_fcn)
+      {
+        std::string dir_name = current_fcn->dir_name ();
 
-      if (! dir_name.empty ())
-        {
-          str_val_iterator q = private_functions.find (dir_name);
+        if (! dir_name.empty ())
+          {
+            str_val_iterator q = private_functions.find (dir_name);
 
-          if (q == private_functions.end ())
-            {
-              octave_value val = load_private_function (dir_name);
+            if (q == private_functions.end ())
+              {
+                octave_value val = load_private_function (dir_name);
 
-              if (val.is_defined ())
-                return val;
-            }
-          else
-            {
-              octave_value& fval = q->second;
+                if (val.is_defined ())
+                  return val;
+              }
+            else
+              {
+                octave_value& fval = q->second;
 
-              if (fval.is_defined ())
-                out_of_date_check (fval);
+                if (fval.is_defined ())
+                  out_of_date_check (fval);
 
-              if (fval.is_defined ())
-                return fval;
-              else
-                {
-                  octave_value val = load_private_function (dir_name);
+                if (fval.is_defined ())
+                  return fval;
+                else
+                  {
+                    octave_value val = load_private_function (dir_name);
 
-                  if (val.is_defined ())
-                    return val;
-                }
-            }
-        }
-    }
+                    if (val.is_defined ())
+                      return val;
+                  }
+              }
+          }
+      }
 
-  // Local function.
+    // Local function.
 
-  if (current_fcn)
-    {
-      std::string fcn_file = current_fcn->fcn_file_name ();
+    if (current_fcn)
+      {
+        std::string fcn_file = current_fcn->fcn_file_name ();
 
-      if (! fcn_file.empty ())
-        {
-          str_val_iterator r = local_functions.find (fcn_file);
+        if (! fcn_file.empty ())
+          {
+            str_val_iterator r = local_functions.find (fcn_file);
 
-          if (r != local_functions.end ())
-            {
-              // We shouldn't need an out-of-date check here since local
-              // functions may ultimately be called only from a primary
-              // function or method defined in the same file.
+            if (r != local_functions.end ())
+              {
+                // We shouldn't need an out-of-date check here since local
+                // functions may ultimately be called only from a primary
+                // function or method defined in the same file.
 
-              return r->second;
-            }
-        }
-    }
+                return r->second;
+              }
+          }
+      }
 
-  // Subfunction.  I think it only makes sense to check for
-  // subfunctions if we are currently executing a function defined
-  // from a .m file.
+    // Subfunction.  I think it only makes sense to check for
+    // subfunctions if we are currently executing a function defined
+    // from a .m file.
 
-  symbol_table::scope *curr_scope
-    = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+    symbol_table::scope *curr_scope
+      = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
-  if (curr_scope)
-    {
-      octave_value val = curr_scope->find_subfunction (name);
+    if (curr_scope)
+      {
+        octave_value val = curr_scope->find_subfunction (name);
 
-      if (val.is_defined ())
-        return val;
-    }
+        if (val.is_defined ())
+          return val;
+      }
 
-  return octave_value ();
-}
+    return octave_value ();
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::find_method
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::find_method
   (const std::string& dispatch_type)
-{
-  octave_value retval;
+  {
+    octave_value retval;
 
-  str_val_iterator q = class_methods.find (dispatch_type);
+    str_val_iterator q = class_methods.find (dispatch_type);
 
-  if (q == class_methods.end ())
-    {
-      octave_value val = load_class_method (dispatch_type);
+    if (q == class_methods.end ())
+      {
+        octave_value val = load_class_method (dispatch_type);
 
-      if (val.is_defined ())
-        return val;
-    }
-  else
-    {
-      octave_value& fval = q->second;
+        if (val.is_defined ())
+          return val;
+      }
+    else
+      {
+        octave_value& fval = q->second;
 
-      if (fval.is_defined ())
-        out_of_date_check (fval, dispatch_type);
+        if (fval.is_defined ())
+          out_of_date_check (fval, dispatch_type);
 
-      if (fval.is_defined ())
-        return fval;
-      else
-        {
-          octave_value val = load_class_method (dispatch_type);
+        if (fval.is_defined ())
+          return fval;
+        else
+          {
+            octave_value val = load_class_method (dispatch_type);
 
-          if (val.is_defined ())
-            return val;
-        }
-    }
+            if (val.is_defined ())
+              return val;
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::find_autoload (void)
-{
-  // Autoloaded function.
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::find_autoload (void)
+  {
+    // Autoloaded function.
 
-  if (autoload_function.is_defined ())
-    out_of_date_check (autoload_function);
+    if (autoload_function.is_defined ())
+      out_of_date_check (autoload_function);
 
-  if (! autoload_function.is_defined ())
-    {
-      std::string file_name = octave::lookup_autoload (name);
+    if (! autoload_function.is_defined ())
+      {
+        std::string file_name = octave::lookup_autoload (name);
 
-      if (! file_name.empty ())
-        {
-          size_t pos = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+        if (! file_name.empty ())
+          {
+            size_t pos = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
-          std::string dir_name = file_name.substr (0, pos);
+            std::string dir_name = file_name.substr (0, pos);
 
-          octave_value ov_fcn
-            = octave::load_fcn_from_file (file_name, dir_name, "", "",
-                                          name, true);
+            octave_value ov_fcn
+              = octave::load_fcn_from_file (file_name, dir_name, "", "",
+                                            name, true);
 
-          if (ov_fcn.is_defined ())
-            autoload_function = octave_value (ov_fcn);
-        }
-    }
+            if (ov_fcn.is_defined ())
+              autoload_function = octave_value (ov_fcn);
+          }
+      }
 
-  return autoload_function;
-}
+    return autoload_function;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::find_user_function (void)
-{
-  // Function on the path.
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::find_user_function (void)
+  {
+    // Function on the path.
 
-  if (function_on_path.is_defined ())
-    out_of_date_check (function_on_path);
+    if (function_on_path.is_defined ())
+      out_of_date_check (function_on_path);
 
-  if (function_on_path.is_undefined ())
-    {
-      std::string dir_name;
+    if (function_on_path.is_undefined ())
+      {
+        std::string dir_name;
 
-      octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find_user_function");
+        octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find_user_function");
 
 
-      std::string file_name = lp.find_fcn (name, dir_name, package_name);
+        std::string file_name = lp.find_fcn (name, dir_name, package_name);
 
-      if (! file_name.empty ())
-        {
-          octave_value ov_fcn
-            = octave::load_fcn_from_file (file_name, dir_name, "",
-                                          package_name);
+        if (! file_name.empty ())
+          {
+            octave_value ov_fcn
+              = octave::load_fcn_from_file (file_name, dir_name, "",
+                                            package_name);
 
-          if (ov_fcn.is_defined ())
-            function_on_path = ov_fcn;
-        }
-    }
+            if (ov_fcn.is_defined ())
+              function_on_path = ov_fcn;
+          }
+      }
 
-  return function_on_path;
-}
+    return function_on_path;
+  }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::find_package (void)
-{
-  // FIXME: implement correct way to check out of date package
-  //if (package.is_defined ())
-  //  out_of_date_check (package);
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::find_package (void)
+  {
+    // FIXME: implement correct way to check out of date package
+    //if (package.is_defined ())
+    //  out_of_date_check (package);
 
-  if (package.is_undefined ())
-    {
-      cdef_manager& cdm
-        = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::find_package");
+    if (package.is_undefined ())
+      {
+        cdef_manager& cdm
+          = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::find_package");
 
-      octave_function *fcn = cdm.find_package_symbol (full_name ());
+        octave_function *fcn = cdm.find_package_symbol (full_name ());
 
-      if (fcn)
-        package = octave_value (fcn);
-    }
+        if (fcn)
+          package = octave_value (fcn);
+      }
 
-  return package;
-}
+    return package;
+  }
 
-// Insert INF_CLASS in the set of class names that are considered
-// inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
-// marked as superior to SUP_CLASS.
+  // Insert INF_CLASS in the set of class names that are considered
+  // inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
+  // marked as superior to SUP_CLASS.
 
-bool
-symbol_table::set_class_relationship (const std::string& sup_class,
-                                      const std::string& inf_class)
-{
-  if (is_superiorto (inf_class, sup_class))
-    return false;
+  bool
+  symbol_table::set_class_relationship (const std::string& sup_class,
+                                        const std::string& inf_class)
+  {
+    if (is_superiorto (inf_class, sup_class))
+      return false;
 
-  // If sup_class doesn't have an entry in the precedence table,
-  // this will automatically create it, and associate to it a
-  // singleton set {inf_class} of inferior classes.
-  m_class_precedence_table[sup_class].insert (inf_class);
+    // If sup_class doesn't have an entry in the precedence table,
+    // this will automatically create it, and associate to it a
+    // singleton set {inf_class} of inferior classes.
+    m_class_precedence_table[sup_class].insert (inf_class);
 
-  return true;
-}
+    return true;
+  }
 
-// Has class A been marked as superior to class B?  Also returns
-// TRUE if B has been marked as inferior to A, since we only keep
-// one table, and convert inferiorto information to a superiorto
-// relationship.  Two calls are required to determine whether there
-// is no relationship between two classes:
-//
-//  if (symbol_table::is_superiorto (a, b))
-//    // A is superior to B, or B has been marked inferior to A.
-//  else if (symbol_table::is_superiorto (b, a))
-//    // B is superior to A, or A has been marked inferior to B.
-//  else
-//    // No relation.
+  // Has class A been marked as superior to class B?  Also returns
+  // TRUE if B has been marked as inferior to A, since we only keep
+  // one table, and convert inferiorto information to a superiorto
+  // relationship.  Two calls are required to determine whether there
+  // is no relationship between two classes:
+  //
+  //  if (symbol_table::is_superiorto (a, b))
+  //    // A is superior to B, or B has been marked inferior to A.
+  //  else if (symbol_table::is_superiorto (b, a))
+  //    // B is superior to A, or A has been marked inferior to B.
+  //  else
+  //    // No relation.
 
-bool
-symbol_table::is_superiorto (const std::string& a, const std::string& b)
-{
-  class_precedence_table_const_iterator p = m_class_precedence_table.find (a);
-  // If a has no entry in the precedence table, return false
-  if (p == m_class_precedence_table.end ())
-    return false;
+  bool
+  symbol_table::is_superiorto (const std::string& a, const std::string& b)
+  {
+    class_precedence_table_const_iterator p = m_class_precedence_table.find (a);
+    // If a has no entry in the precedence table, return false
+    if (p == m_class_precedence_table.end ())
+      return false;
 
-  const std::set<std::string>& inferior_classes = p->second;
-  std::set<std::string>::const_iterator q = inferior_classes.find (b);
-  return (q != inferior_classes.end ());
-}
+    const std::set<std::string>& inferior_classes = p->second;
+    std::set<std::string>::const_iterator q = inferior_classes.find (b);
+    return (q != inferior_classes.end ());
+  }
 
-void
-symbol_table::fcn_info::fcn_info_rep::install_built_in_dispatch (const std::string& klass)
-{
-  if (built_in_function.is_defined ())
-    {
-      octave_function *fcn = built_in_function.function_value ();
+  void
+  symbol_table::fcn_info::fcn_info_rep::install_built_in_dispatch (const std::string& klass)
+  {
+    if (built_in_function.is_defined ())
+      {
+        octave_function *fcn = built_in_function.function_value ();
 
-      if (fcn)
-        {
-          if (fcn->handles_dispatch_class (klass))
-            warning ("install_built_in_dispatch: '%s' already defined for class '%s'",
-                     name.c_str (), klass.c_str ());
-          else
-            fcn->push_dispatch_class (klass);
-        }
-    }
-  else
-    error ("install_built_in_dispatch: '%s' is not a built-in function",
-           name.c_str ());
+        if (fcn)
+          {
+            if (fcn->handles_dispatch_class (klass))
+              warning ("install_built_in_dispatch: '%s' already defined for class '%s'",
+                       name.c_str (), klass.c_str ());
+            else
+              fcn->push_dispatch_class (klass);
+          }
+      }
+    else
+      error ("install_built_in_dispatch: '%s' is not a built-in function",
+             name.c_str ());
+  }
 }
 
 static octave_value
 dump_function_map (const std::map<std::string, octave_value>& fcn_map)
 {
   if (fcn_map.empty ())
     return octave_value (Matrix ());
 
@@ -1288,140 +1297,143 @@ dump_function_map (const std::map<std::s
       std::string nm = nm_fcn.first;
       const octave_value& fcn = nm_fcn.second;
       info_map[nm] = fcn.dump ();
     }
 
   return octave_value (info_map);
 }
 
-octave_value
-symbol_table::fcn_info::fcn_info_rep::dump (void) const
+namespace octave
 {
-  std::map<std::string, octave_value> m
-    = {{"name", octave_value (full_name ())},
-       {"refcount", octave_value (count.value ())},
-       {"package", package.dump ()},
-       {"local_functions", dump_function_map (local_functions)},
-       {"private_functions", dump_function_map (private_functions)},
-       {"class_methods", dump_function_map (class_methods)},
-       {"class_constructors", dump_function_map (class_constructors)},
-       {"cmdline_function", cmdline_function.dump ()},
-       {"autoload_function", autoload_function.dump ()},
-       {"function_on_path", function_on_path.dump ()},
-       {"built_in_function", built_in_function.dump ()}};
+  octave_value
+  symbol_table::fcn_info::fcn_info_rep::dump (void) const
+  {
+    std::map<std::string, octave_value> m
+      = {{"name", octave_value (full_name ())},
+         {"refcount", octave_value (count.value ())},
+         {"package", package.dump ()},
+         {"local_functions", dump_function_map (local_functions)},
+         {"private_functions", dump_function_map (private_functions)},
+         {"class_methods", dump_function_map (class_methods)},
+         {"class_constructors", dump_function_map (class_constructors)},
+         {"cmdline_function", cmdline_function.dump ()},
+         {"autoload_function", autoload_function.dump ()},
+         {"function_on_path", function_on_path.dump ()},
+         {"built_in_function", built_in_function.dump ()}};
 
-  return octave_value (m);
-}
+    return octave_value (m);
+  }
 
-octave_value
-symbol_table::find (const std::string& name, const octave_value_list& args,
-                    bool skip_variables, bool local_funcs)
-{
-  return (m_current_scope
-          ? m_current_scope->find (name, args, skip_variables, local_funcs)
-          : octave_value ());
-}
+  octave_value
+  symbol_table::find (const std::string& name, const octave_value_list& args,
+                      bool skip_variables, bool local_funcs)
+  {
+    return (m_current_scope
+            ? m_current_scope->find (name, args, skip_variables, local_funcs)
+            : octave_value ());
+  }
 
-octave_value
-symbol_table::builtin_find (const std::string& name)
-{
-  return (m_current_scope
-          ? m_current_scope->builtin_find (name) : octave_value ());
-}
+  octave_value
+  symbol_table::builtin_find (const std::string& name)
+  {
+    return (m_current_scope
+            ? m_current_scope->builtin_find (name) : octave_value ());
+  }
 
-octave_value
-symbol_table::find_function (const std::string& name,
-                             const octave_value_list& args, bool local_funcs)
-{
-  octave_value retval;
+  octave_value
+  symbol_table::find_function (const std::string& name,
+                               const octave_value_list& args, bool local_funcs)
+  {
+    octave_value retval;
 
-  if (! name.empty () && name[0] == '@')
-    {
-      // Look for a class specific function.
-      std::string dispatch_type =
-        name.substr (1, name.find_first_of (octave::sys::file_ops::dir_sep_str ()) - 1);
+    if (! name.empty () && name[0] == '@')
+      {
+        // Look for a class specific function.
+        std::string dispatch_type =
+          name.substr (1, name.find_first_of (octave::sys::file_ops::dir_sep_str ()) - 1);
 
-      std::string method;
-      size_t pos = name.find_last_of (octave::sys::file_ops::dir_sep_str ());
-      if (pos != std::string::npos)
-        method = name.substr (pos + 1);
+        std::string method;
+        size_t pos = name.find_last_of (octave::sys::file_ops::dir_sep_str ());
+        if (pos != std::string::npos)
+          method = name.substr (pos + 1);
 
-      retval = find_method (method, dispatch_type);
-    }
-  else
-    {
-      size_t pos = name.find_first_of (Vfilemarker);
+        retval = find_method (method, dispatch_type);
+      }
+    else
+      {
+        size_t pos = name.find_first_of (Vfilemarker);
 
-      if (pos == std::string::npos)
-        retval = find (name, args, true, local_funcs);
-      else
-        {
-          std::string fcn_scope = name.substr (0, pos);
-          scope *stored_scope = m_current_scope;
-          m_current_scope = m_top_scope;
-          octave_value parent = find_function (name.substr (0, pos),
-                                               octave_value_list (), false);
+        if (pos == std::string::npos)
+          retval = find (name, args, true, local_funcs);
+        else
+          {
+            std::string fcn_scope = name.substr (0, pos);
+            scope *stored_scope = m_current_scope;
+            m_current_scope = m_top_scope;
+            octave_value parent = find_function (name.substr (0, pos),
+                                                 octave_value_list (), false);
 
-          if (parent.is_defined ())
-            {
-              octave_function *parent_fcn = parent.function_value ();
+            if (parent.is_defined ())
+              {
+                octave_function *parent_fcn = parent.function_value ();
 
-              if (parent_fcn)
-                {
-                  m_current_scope = parent_fcn->scope ();
+                if (parent_fcn)
+                  {
+                    m_current_scope = parent_fcn->scope ();
 
-                  if (m_current_scope && m_current_scope != m_top_scope)
-                    retval = find_function (name.substr (pos + 1), args);
-                }
-            }
+                    if (m_current_scope && m_current_scope != m_top_scope)
+                      retval = find_function (name.substr (pos + 1), args);
+                  }
+              }
 
-          m_current_scope = stored_scope;
-        }
-    }
+            m_current_scope = stored_scope;
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-// look for @class/method>subfunction
-octave_value
-symbol_table::find_submethod (const std::string& name,
-                              const std::string& dispatch_type)
-{
-  octave_value fcn;
+  // look for @class/method>subfunction
+  octave_value
+  symbol_table::find_submethod (const std::string& name,
+                                const std::string& dispatch_type)
+  {
+    octave_value fcn;
 
-  std::string full_name = "@" + dispatch_type +
-                          octave::sys::file_ops::dir_sep_str () + name;
-  size_t pos = full_name.find_first_of (Vfilemarker);
+    std::string full_name = "@" + dispatch_type +
+      octave::sys::file_ops::dir_sep_str () + name;
+    size_t pos = full_name.find_first_of (Vfilemarker);
 
-  if (pos != std::string::npos)
-    {
-      std::string fcn_scope = full_name.substr (0, pos);
-      scope *stored_scope = m_current_scope;
-      m_current_scope = m_top_scope;
-      octave_value parent = find_function (full_name.substr (0, pos),
-                                           octave_value_list (), false);
-      if (parent.is_defined ())
-        {
-          octave_function *parent_fcn = parent.function_value ();
+    if (pos != std::string::npos)
+      {
+        std::string fcn_scope = full_name.substr (0, pos);
+        scope *stored_scope = m_current_scope;
+        m_current_scope = m_top_scope;
+        octave_value parent = find_function (full_name.substr (0, pos),
+                                             octave_value_list (), false);
+        if (parent.is_defined ())
+          {
+            octave_function *parent_fcn = parent.function_value ();
 
-          if (parent_fcn)
-            {
-              m_current_scope = parent_fcn->scope ();
+            if (parent_fcn)
+              {
+                m_current_scope = parent_fcn->scope ();
 
-              if (m_current_scope && m_current_scope != m_top_scope)
-                fcn = find_function (full_name.substr (pos + 1),
-                                     octave_value_list ());
-            }
-        }
+                if (m_current_scope && m_current_scope != m_top_scope)
+                  fcn = find_function (full_name.substr (pos + 1),
+                                       octave_value_list ());
+              }
+          }
 
-      m_current_scope = stored_scope;
-    }
+        m_current_scope = stored_scope;
+      }
 
-  return fcn;
+    return fcn;
+  }
 }
 
 template <template <typename, typename...> class C, typename V,
           typename... A>
 static octave_value
 dump_container_map (const std::map<std::string, C<V, A...>>& container_map)
 {
   if (container_map.empty ())
@@ -1434,407 +1446,410 @@ dump_container_map (const std::map<std::
       std::string nm = nm_container.first;
       const C<V, A...>& container = nm_container.second;
       info_map[nm] = Cell (container);
     }
 
   return octave_value (info_map);
 }
 
-octave_value
-symbol_table::dump (void) const
+namespace octave
 {
-  std::map<std::string, octave_value> m
-    = {{"function_info", dump_fcn_table_map ()},
-       {"precedence_table", dump_container_map (m_class_precedence_table)},
-       {"parent_classes", dump_container_map (m_parent_map)}};
-
-  return octave_value (m);
-}
+  octave_value
+  symbol_table::dump (void) const
+  {
+    std::map<std::string, octave_value> m
+      = {{"function_info", dump_fcn_table_map ()},
+         {"precedence_table", dump_container_map (m_class_precedence_table)},
+         {"parent_classes", dump_container_map (m_parent_map)}};
 
-void
-symbol_table::cleanup (void)
-{
-  clear_all (true);
+    return octave_value (m);
+  }
 
-  m_global_symbols.clear ();
-  m_fcn_table.clear ();
-  m_class_precedence_table.clear ();
-  m_parent_map.clear ();
-}
+  void
+  symbol_table::cleanup (void)
+  {
+    clear_all (true);
 
-octave_value
-symbol_table::dump_fcn_table_map (void) const
-{
-  if (m_fcn_table.empty ())
-    return octave_value (Matrix ());
+    m_global_symbols.clear ();
+    m_fcn_table.clear ();
+    m_class_precedence_table.clear ();
+    m_parent_map.clear ();
+  }
 
-  std::map<std::string, octave_value> info_map;
+  octave_value
+  symbol_table::dump_fcn_table_map (void) const
+  {
+    if (m_fcn_table.empty ())
+      return octave_value (Matrix ());
 
-  for (const auto& nm_finfo : m_fcn_table)
-    {
-      std::string nm = nm_finfo.first;
-      const fcn_info& finfo = nm_finfo.second;
-      info_map[nm] = finfo.dump ();
-    }
+    std::map<std::string, octave_value> info_map;
 
-  return octave_value (info_map);
-}
+    for (const auto& nm_finfo : m_fcn_table)
+      {
+        std::string nm = nm_finfo.first;
+        const fcn_info& finfo = nm_finfo.second;
+        info_map[nm] = finfo.dump ();
+      }
 
-octave_value
-symbol_table::scope::find (const std::string& name,
-                           const octave_value_list& args,
-                           bool skip_variables, bool local_funcs)
-{
-  octave_value retval;
+    return octave_value (info_map);
+  }
 
-  // Variable.
+  octave_value
+  symbol_table::scope::find (const std::string& name,
+                             const octave_value_list& args,
+                             bool skip_variables, bool local_funcs)
+  {
+    octave_value retval;
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::scope::find");
+    // Variable.
 
-  if (! skip_variables)
-    {
-      table_iterator p = m_symbols.find (name);
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::scope::find");
 
-      if (p != m_symbols.end ())
-        {
-          symbol_record sr = p->second;
+    if (! skip_variables)
+      {
+        table_iterator p = m_symbols.find (name);
 
-          if (sr.is_global ())
-            return symtab.global_varval (name);
-          else
-            {
-              octave_value val = sr.varval ();
+        if (p != m_symbols.end ())
+          {
+            symbol_record sr = p->second;
 
-              if (val.is_defined ())
-                return val;
-            }
-        }
-    }
+            if (sr.is_global ())
+              return symtab.global_varval (name);
+            else
+              {
+                octave_value val = sr.varval ();
 
-  if (local_funcs)
-    {
-      // Subfunction.  I think it only makes sense to check for
-      // subfunctions if we are currently executing a function defined
-      // from a .m file.
+                if (val.is_defined ())
+                  return val;
+              }
+          }
+      }
 
-      octave_value fcn = find_subfunction (name);
+    if (local_funcs)
+      {
+        // Subfunction.  I think it only makes sense to check for
+        // subfunctions if we are currently executing a function defined
+        // from a .m file.
 
-      if (fcn.is_defined ())
-        return fcn;
-    }
+        octave_value fcn = find_subfunction (name);
 
-  fcn_table_iterator p = symtab.m_fcn_table.find (name);
+        if (fcn.is_defined ())
+          return fcn;
+      }
+
+    fcn_table_iterator p = symtab.m_fcn_table.find (name);
 
-  if (p != symtab.m_fcn_table.end ())
-    return p->second.find (args, local_funcs);
-  else
-    {
-      fcn_info finfo (name);
+    if (p != symtab.m_fcn_table.end ())
+      return p->second.find (args, local_funcs);
+    else
+      {
+        fcn_info finfo (name);
 
-      octave_value fcn = finfo.find (args, local_funcs);
-
-      if (fcn.is_defined ())
-        symtab.m_fcn_table[name] = finfo;
+        octave_value fcn = finfo.find (args, local_funcs);
 
-      return fcn;
-    }
+        if (fcn.is_defined ())
+          symtab.m_fcn_table[name] = finfo;
 
-  return retval;
-}
+        return fcn;
+      }
+
+    return retval;
+  }
 
-octave_value
-symbol_table::scope::builtin_find (const std::string& name)
-{
-  octave_value retval;
+  octave_value
+  symbol_table::scope::builtin_find (const std::string& name)
+  {
+    octave_value retval;
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::scope::find");
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::scope::find");
 
-  fcn_table_iterator p = symtab.m_fcn_table.find (name);
+    fcn_table_iterator p = symtab.m_fcn_table.find (name);
 
-  if (p != symtab.m_fcn_table.end ())
-    return p->second.builtin_find ();
-  else
-    {
-      fcn_info finfo (name);
+    if (p != symtab.m_fcn_table.end ())
+      return p->second.builtin_find ();
+    else
+      {
+        fcn_info finfo (name);
 
-      octave_value fcn = finfo.builtin_find ();
+        octave_value fcn = finfo.builtin_find ();
 
-      if (fcn.is_defined ())
-        symtab.m_fcn_table[name] = finfo;
+        if (fcn.is_defined ())
+          symtab.m_fcn_table[name] = finfo;
 
-      return fcn;
-    }
+        return fcn;
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-symbol_table::symbol_record&
-symbol_table::scope::insert (const std::string& name, bool force_add)
-{
-  table_iterator p = m_symbols.find (name);
+  symbol_table::symbol_record&
+  symbol_table::scope::insert (const std::string& name, bool force_add)
+  {
+    table_iterator p = m_symbols.find (name);
 
-  if (p == m_symbols.end ())
-    {
-      symbol_table::symbol_record ret (this, name);
+    if (p == m_symbols.end ())
+      {
+        symbol_table::symbol_record ret (this, name);
 
-      if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
-        return m_symbols[name] = ret;
-      else
-        {
-          if (m_is_static && ! force_add)
-            ret.mark_added_static ();
-
+        if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
           return m_symbols[name] = ret;
-        }
-    }
-  else
-    return p->second;
-}
+        else
+          {
+            if (m_is_static && ! force_add)
+              ret.mark_added_static ();
+
+            return m_symbols[name] = ret;
+          }
+      }
+    else
+      return p->second;
+  }
 
-void
-symbol_table::scope::clear_global (const std::string& name)
-{
-  table_iterator p = m_symbols.find (name);
+  void
+  symbol_table::scope::clear_global (const std::string& name)
+  {
+    table_iterator p = m_symbols.find (name);
 
-  if (p != m_symbols.end ())
-    {
-      symbol_table::symbol_record& sr = p->second;
+    if (p != m_symbols.end ())
+      {
+        symbol_table::symbol_record& sr = p->second;
 
-      if (sr.is_global ())
-        sr.unmark_global ();
-    }
+        if (sr.is_global ())
+          sr.unmark_global ();
+      }
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::scope::clear_global");
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::scope::clear_global");
 
-  global_symbols_iterator q = symtab.m_global_symbols.find (name);
+    global_symbols_iterator q = symtab.m_global_symbols.find (name);
 
-  if (q != symtab.m_global_symbols.end ())
-    symtab.m_global_symbols.erase (q);
+    if (q != symtab.m_global_symbols.end ())
+      symtab.m_global_symbols.erase (q);
 
-}
+  }
 
-void
-symbol_table::scope::clear_global_pattern (const std::string& pat)
-{
-  glob_match pattern (pat);
+  void
+  symbol_table::scope::clear_global_pattern (const std::string& pat)
+  {
+    glob_match pattern (pat);
 
-  for (auto& nm_sr : m_symbols)
-    {
-      symbol_table::symbol_record& sr = nm_sr.second;
+    for (auto& nm_sr : m_symbols)
+      {
+        symbol_table::symbol_record& sr = nm_sr.second;
 
-      if (sr.is_global () && pattern.match (sr.name ()))
-        sr.unmark_global ();
-    }
+        if (sr.is_global () && pattern.match (sr.name ()))
+          sr.unmark_global ();
+      }
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::scope::clear_global_pattern");
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("symbol_table::scope::clear_global_pattern");
 
-  global_symbols_iterator q = symtab.m_global_symbols.begin ();
+    global_symbols_iterator q = symtab.m_global_symbols.begin ();
 
-  while (q != symtab.m_global_symbols.end ())
-    {
-      if (pattern.match (q->first))
-        symtab.m_global_symbols.erase (q++);
-      else
-        q++;
-    }
-}
+    while (q != symtab.m_global_symbols.end ())
+      {
+        if (pattern.match (q->first))
+          symtab.m_global_symbols.erase (q++);
+        else
+          q++;
+      }
+  }
 
-std::list<workspace_element>
-symbol_table::scope::workspace_info (void) const
-{
-  std::list<workspace_element> retval;
+  std::list<workspace_element>
+  symbol_table::scope::workspace_info (void) const
+  {
+    std::list<workspace_element> retval;
 
-  for (const auto& nm_sr : m_symbols)
-    {
-      std::string nm = nm_sr.first;
-      symbol_record sr = nm_sr.second;
+    for (const auto& nm_sr : m_symbols)
+      {
+        std::string nm = nm_sr.first;
+        symbol_record sr = nm_sr.second;
 
-      if (! sr.is_hidden ())
-        {
-          octave_value val = sr.varval ();
+        if (! sr.is_hidden ())
+          {
+            octave_value val = sr.varval ();
 
-          if (val.is_defined ())
-            {
-              // FIXME: fix size for objects, see kluge in variables.cc
-              //dim_vector dv = val.dims ();
-              octave_value tmp = val;
-              Matrix sz = tmp.size ();
-              dim_vector dv = dim_vector::alloc (sz.numel ());
-              for (octave_idx_type i = 0; i < dv.ndims (); i++)
-                dv(i) = sz(i);
+            if (val.is_defined ())
+              {
+                // FIXME: fix size for objects, see kluge in variables.cc
+                //dim_vector dv = val.dims ();
+                octave_value tmp = val;
+                Matrix sz = tmp.size ();
+                dim_vector dv = dim_vector::alloc (sz.numel ());
+                for (octave_idx_type i = 0; i < dv.ndims (); i++)
+                  dv(i) = sz(i);
 
-              char storage = ' ';
-              if (sr.is_global ())
-                storage = 'g';
-              else if (sr.is_persistent ())
-                storage = 'p';
-              else if (sr.is_automatic ())
-                storage = 'a';
-              else if (sr.is_formal ())
-                storage = 'f';
-              else if (sr.is_hidden ())
-                storage = 'h';
-              else if (sr.is_inherited ())
-                storage = 'i';
+                char storage = ' ';
+                if (sr.is_global ())
+                  storage = 'g';
+                else if (sr.is_persistent ())
+                  storage = 'p';
+                else if (sr.is_automatic ())
+                  storage = 'a';
+                else if (sr.is_formal ())
+                  storage = 'f';
+                else if (sr.is_hidden ())
+                  storage = 'h';
+                else if (sr.is_inherited ())
+                  storage = 'i';
 
-              std::ostringstream buf;
-              val.short_disp (buf);
-              std::string short_disp_str = buf.str ();
+                std::ostringstream buf;
+                val.short_disp (buf);
+                std::string short_disp_str = buf.str ();
 
-              workspace_element elt (storage, nm, val.class_name (),
-                                     short_disp_str, dv.str (),
-                                     val.iscomplex ());
+                workspace_element elt (storage, nm, val.class_name (),
+                                       short_disp_str, dv.str (),
+                                       val.iscomplex ());
 
-              retval.push_back (elt);
-            }
-        }
-    }
+                retval.push_back (elt);
+              }
+          }
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-symbol_table::scope::dump (void) const
-{
-  std::map<std::string, octave_value> m
-    = {{"name", octave_value (m_name)},
-       {"symbols", dump_symbols_map ()},
-       {"persistent_variables", octave_value (m_persistent_symbols)},
-       {"subfunctions", dump_function_map (m_subfunctions)}};
+  octave_value
+  symbol_table::scope::dump (void) const
+  {
+    std::map<std::string, octave_value> m
+      = {{"name", octave_value (m_name)},
+         {"symbols", dump_symbols_map ()},
+         {"persistent_variables", octave_value (m_persistent_symbols)},
+         {"subfunctions", dump_function_map (m_subfunctions)}};
 
-  return octave_value (m);
-}
+    return octave_value (m);
+  }
 
-octave_value
-symbol_table::scope::dump_symbols_map (void) const
-{
-  std::map<std::string, octave_value> info_map;
+  octave_value
+  symbol_table::scope::dump_symbols_map (void) const
+  {
+    std::map<std::string, octave_value> info_map;
 
-  for (const auto& nm_sr : m_symbols)
-    {
-      std::string nm = nm_sr.first;
-      const symbol_table::symbol_record& sr = nm_sr.second;
-      info_map[nm] = sr.dump ();
-    }
+    for (const auto& nm_sr : m_symbols)
+      {
+        std::string nm = nm_sr.first;
+        const symbol_table::symbol_record& sr = nm_sr.second;
+        info_map[nm] = sr.dump ();
+      }
 
-  return octave_value (info_map);
-}
+    return octave_value (info_map);
+  }
 
-void
-symbol_table::scope::install_subfunction (const std::string& name,
-                                          const octave_value& fval,
-                                          bool is_nested)
-{
-  m_subfunctions[name] = fval;
+  void
+  symbol_table::scope::install_subfunction (const std::string& name,
+                                            const octave_value& fval,
+                                            bool is_nested)
+  {
+    m_subfunctions[name] = fval;
 
-  // This can be simpler once the scope object is stored in the function
-  // object...
-  octave_user_function *fcn = fval.user_function_value ();
+    // This can be simpler once the scope object is stored in the function
+    // object...
+    octave_user_function *fcn = fval.user_function_value ();
 
-  scope *fcn_scope = fcn->scope ();
+    scope *fcn_scope = fcn->scope ();
 
-  fcn_scope->set_parent (this);
+    fcn_scope->set_parent (this);
 
-  if (is_nested)
-    {
-      m_children.push_back (fcn_scope);
+    if (is_nested)
+      {
+        m_children.push_back (fcn_scope);
 
-      fcn->mark_as_nested_function ();
+        fcn->mark_as_nested_function ();
 
-      fcn_scope->m_is_nested = true;
-    }
+        fcn_scope->m_is_nested = true;
+      }
 
-}
+  }
 
-octave_value
-symbol_table::scope::find_subfunction (const std::string& name) const
-{
-  subfunctions_const_iterator p = m_subfunctions.find (name);
+  octave_value
+  symbol_table::scope::find_subfunction (const std::string& name) const
+  {
+    subfunctions_const_iterator p = m_subfunctions.find (name);
 
-  if (p != m_subfunctions.end ())
-    return p->second;
+    if (p != m_subfunctions.end ())
+      return p->second;
 
-  if (m_parent)
-    return m_parent->find_subfunction (name);
+    if (m_parent)
+      return m_parent->find_subfunction (name);
 
-  return octave_value ();
-}
+    return octave_value ();
+  }
 
-void
-symbol_table::scope::mark_subfunctions_in_scope_as_private (const std::string& class_name)
-{
-  for (auto& nm_sf : m_subfunctions)
-    {
-      octave_function *fcn = nm_sf.second.function_value ();
+  void
+  symbol_table::scope::mark_subfunctions_in_scope_as_private (const std::string& class_name)
+  {
+    for (auto& nm_sf : m_subfunctions)
+      {
+        octave_function *fcn = nm_sf.second.function_value ();
 
-      if (fcn)
-        fcn->mark_as_private_function (class_name);
-    }
-}
+        if (fcn)
+          fcn->mark_as_private_function (class_name);
+      }
+  }
 
-void
-symbol_table::scope::update_nest (void)
-{
-  if (m_parent)
-    {
-      // fix bad symbol_records
-      for (auto& nm_sr : m_symbols)
-        {
-          symbol_record& ours = nm_sr.second;
-          symbol_record parents;
+  void
+  symbol_table::scope::update_nest (void)
+  {
+    if (m_parent)
+      {
+        // fix bad symbol_records
+        for (auto& nm_sr : m_symbols)
+          {
+            symbol_record& ours = nm_sr.second;
+            symbol_record parents;
 
-          if (! ours.is_formal ()
-              && m_is_nested && m_parent->look_nonlocal (nm_sr.first, parents))
-            {
-              if (ours.is_global () || ours.is_persistent ())
-                error ("global and persistent may only be used in the topmost level in which a nested variable is used");
+            if (! ours.is_formal ()
+                && m_is_nested && m_parent->look_nonlocal (nm_sr.first, parents))
+              {
+                if (ours.is_global () || ours.is_persistent ())
+                  error ("global and persistent may only be used in the topmost level in which a nested variable is used");
 
-              if (! ours.is_formal ())
-                {
-                  ours.invalidate ();
-                  nm_sr.second = parents;
-                }
-            }
-          else
-            ours.set_curr_fcn (m_fcn);
-        }
-    }
-  else if (m_children.size ())
-    {
-      m_is_static = true;
-      for (auto& nm_sr : m_symbols)
-        nm_sr.second.set_curr_fcn (m_fcn);
-    }
+                if (! ours.is_formal ())
+                  {
+                    ours.invalidate ();
+                    nm_sr.second = parents;
+                  }
+              }
+            else
+              ours.set_curr_fcn (m_fcn);
+          }
+      }
+    else if (m_children.size ())
+      {
+        m_is_static = true;
+        for (auto& nm_sr : m_symbols)
+          nm_sr.second.set_curr_fcn (m_fcn);
+      }
 
-  for (auto& symtab_p : m_children)
-    symtab_p->update_nest ();
-}
+    for (auto& symtab_p : m_children)
+      symtab_p->update_nest ();
+  }
 
-bool
-symbol_table::scope::look_nonlocal (const std::string& name,
-                                    symbol_table::symbol_record& result)
-{
-  table_iterator p = m_symbols.find (name);
-  if (p == m_symbols.end ())
-    {
-      if (m_is_nested && m_parent)
-        return m_parent->look_nonlocal (name, result);
-    }
-  else if (! p->second.is_automatic ())
-    {
-      result = p->second;
-      return true;
-    }
+  bool
+  symbol_table::scope::look_nonlocal (const std::string& name,
+                                      symbol_table::symbol_record& result)
+  {
+    table_iterator p = m_symbols.find (name);
+    if (p == m_symbols.end ())
+      {
+        if (m_is_nested && m_parent)
+          return m_parent->look_nonlocal (name, result);
+      }
+    else if (! p->second.is_automatic ())
+      {
+        result = p->second;
+        return true;
+      }
 
-  return false;
+    return false;
+  }
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} ignore_function_time_stamp ()
 @deftypefnx {} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})
 Query or set the internal variable that controls whether Octave checks
 the time stamp on files each time it looks up functions defined in
@@ -1913,17 +1928,17 @@ determine whether functions defined in f
 
 DEFMETHOD (__current_scope__, interp, , ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{scope}, @var{context}]} __current_scope__ ()
 Return the current scope and context as integers.
 @seealso{__dump_symtab_info__}
 @end deftypefn */)
 {
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   return ovl (symtab.current_scope (), symtab.current_context ());
 }
 
 DEFMETHOD (__dump_symtab_info__, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn  {} {} __dump_symtab_info__ ()
 @deftypefnx {} {} __dump_symtab_info__ (@var{function})
@@ -1931,25 +1946,25 @@ Undocumented internal function.
 @seealso{__current_scope__}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (nargin == 0)
     return symtab.dump ();
   else
     {
       std::string fname = args(0).xstring_value ("__dump_symtab_info__: argument must be a function name");
 
-      symbol_table::fcn_info *finfo = symtab.get_fcn_info (fname);
+      octave::symbol_table::fcn_info *finfo = symtab.get_fcn_info (fname);
 
       if (finfo)
         return finfo->dump ();
     }
 
   return ovl ();
 }
 
@@ -1959,17 +1974,17 @@ DEFMETHOD (__get_cmdline_fcn_txt__, inte
 Undocumented internal function.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__get_cmd_line_function_text__: first argument must be function name");
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   octave_value ov = symtab.find_cmdline_function (name);
 
   octave_user_function *f = ov.user_function_value ();
 
   octave_value_list retval;
 
   if (f)
@@ -1990,33 +2005,33 @@ Undocumented internal function.
 //
 // DEFMETHOD (set_variable, interp, args, , "set_variable (NAME, VALUE)")
 // {
 //   if (args.length () != 2)
 //     print_usage ();
 //
 //   std::string name = args(0).xstring_value ("set_variable: variable NAME must be a string");
 //
-//   symbol_table& symtab = interp.get_symbol_table ();
+//   octave::symbol_table& symtab = interp.get_symbol_table ();
 //
 //   symtab.assign (name, args(1));
 //
 //   return ovl ();
 // }
 //
 // DEFMETHOD (variable_value, interp, args, , "VALUE = variable_value (NAME)")
 // {
 //   if (args.length () != 1)
 //     print_usage ();
 //
 //   octave_value retval;
 //
 //   std::string name = args(0).xstring_value ("variable_value: variable NAME must be a string");
 //
-//   symbol_table& symtab = interp.get_symbol_table ();
+//   octave::symbol_table& symtab = interp.get_symbol_table ();
 //
 //   retval = symtab.varval (name);
 //
 //   if (retval.is_undefined ())
 //     error ("variable_value: '%s' is not a variable in the current scope",
 //            name.c_str ());
 //
 //   return retval;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -39,2077 +39,2077 @@ along with Octave; see the file COPYING.
 
 class tree_argument_list;
 class octave_user_function;
 
 #include "ov.h"
 #include "ovl.h"
 #include "workspace-element.h"
 
-class
-OCTINTERP_API
-symbol_table
+namespace octave
 {
-public:
-
-  static octave_value dummy_octave_value;
-
-  typedef size_t context_id;
-
-  class scope;
-
-  class fcn_info;
-
-  class symbol_record
+  class OCTINTERP_API symbol_table
   {
   public:
 
-    // generic variable
-    static const unsigned int local = 1;
-
-    // varargin, argn, .nargin., .nargout.
-    // (FIXME: is this really used now?)
-    static const unsigned int automatic = 2;
-
-    // formal parameter
-    static const unsigned int formal = 4;
-
-    // not listed or cleared (.nargin., .nargout.)
-    static const unsigned int hidden = 8;
-
-    // inherited from parent scope; not cleared at function exit
-    static const unsigned int inherited = 16;
-
-    // global (redirects to global scope)
-    static const unsigned int global = 32;
-
-    // not cleared at function exit
-    static const unsigned int persistent = 64;
-
-    // this symbol may NOT become a variable.
-    // (symbol added to a static workspace)
-    static const unsigned int added_static = 128;
-
-  private:
-
-    class symbol_record_rep
+    static octave_value dummy_octave_value;
+
+    typedef size_t context_id;
+
+    class scope;
+
+    class fcn_info;
+
+    class symbol_record
     {
     public:
 
-      symbol_record_rep (scope *s, const std::string& nm,
-                         const octave_value& v, unsigned int sc)
-        : m_decl_scope (s), curr_fcn (0), name (nm), value_stack (),
-          storage_class (sc), /* finfo (), */ valid (true), count (1)
+      // generic variable
+      static const unsigned int local = 1;
+
+      // varargin, argn, .nargin., .nargout.
+      // (FIXME: is this really used now?)
+      static const unsigned int automatic = 2;
+
+      // formal parameter
+      static const unsigned int formal = 4;
+
+      // not listed or cleared (.nargin., .nargout.)
+      static const unsigned int hidden = 8;
+
+      // inherited from parent scope; not cleared at function exit
+      static const unsigned int inherited = 16;
+
+      // global (redirects to global scope)
+      static const unsigned int global = 32;
+
+      // not cleared at function exit
+      static const unsigned int persistent = 64;
+
+      // this symbol may NOT become a variable.
+      // (symbol added to a static workspace)
+      static const unsigned int added_static = 128;
+
+    private:
+
+      class symbol_record_rep
       {
-        value_stack.push_back (v);
+      public:
+
+        symbol_record_rep (scope *s, const std::string& nm,
+                           const octave_value& v, unsigned int sc)
+          : m_decl_scope (s), curr_fcn (0), name (nm), value_stack (),
+            storage_class (sc), /* finfo (), */ valid (true), count (1)
+        {
+          value_stack.push_back (v);
+        }
+
+        // No copying!
+
+        symbol_record_rep (const symbol_record_rep& ov) = delete;
+
+        symbol_record_rep& operator = (const symbol_record_rep&) = delete;
+
+        ~symbol_record_rep (void) = default;
+
+        void assign (const octave_value& value)
+        {
+          varref () = value;
+        }
+
+        void assign (octave_value::assign_op op,
+                     const std::string& type,
+                     const std::list<octave_value_list>& idx,
+                     const octave_value& value)
+        {
+          varref().assign (op, type, idx, value);
+        }
+
+        void assign (octave_value::assign_op op, const octave_value& value)
+        {
+          varref().assign (op, value);
+        }
+
+        void do_non_const_unary_op (octave_value::unary_op op)
+        {
+          varref().do_non_const_unary_op (op);
+        }
+
+        void do_non_const_unary_op (octave_value::unary_op op,
+                                    const std::string& type,
+                                    const std::list<octave_value_list>& idx)
+        {
+          varref().do_non_const_unary_op (op, type, idx);
+        }
+
+        octave_value& varref (void)
+        {
+          context_id context
+            = m_decl_scope ? m_decl_scope->current_context () : 0;
+
+          if (is_global ())
+            return xglobal_varref ();
+          else if (is_persistent ())
+            return xpersistent_varref ();
+          else
+            {
+              context_id n = value_stack.size ();
+              while (n++ <= context)
+                value_stack.push_back (octave_value ());
+
+              return value_stack[context];
+            }
+        }
+
+        octave_value varval (void) const
+        {
+          context_id context
+            = m_decl_scope ? m_decl_scope->current_context () : 0;
+
+          if (is_global ())
+            return xglobal_varval ();
+          else if (is_persistent ())
+            return xpersistent_varval ();
+          else
+            {
+              if (context < value_stack.size ())
+                return value_stack[context];
+              else
+                return octave_value ();
+            }
+        }
+
+        void push_context (scope *sid)
+        {
+          if (! (is_persistent () || is_global ())
+              && sid == decl_scope ())
+            value_stack.push_back (octave_value ());
+        }
+
+        // If pop_context returns 0, we are out of values and this element
+        // of the symbol table should be deleted.  This can happen for
+        // functions like
+        //
+        //   function foo (n)
+        //     if (n > 0)
+        //       foo (n-1);
+        //     else
+        //       eval ("x = 1");
+        //     endif
+        //   endfunction
+        //
+        // Here, X should only exist in the final stack frame.
+
+        size_t pop_context (scope *sid)
+        {
+          size_t retval = 1;
+
+          if (! (is_persistent () || is_global ())
+              && sid == decl_scope ())
+            {
+              value_stack.pop_back ();
+              retval = value_stack.size ();
+            }
+
+          return retval;
+        }
+
+        void clear (void) { clear (decl_scope ()); }
+
+        void clear (scope *sid);
+
+        bool is_defined (void) const
+        {
+          return varval ().is_defined ();
+        }
+
+        bool is_valid (void) const
+        {
+          return valid;
+        }
+
+        bool is_variable (void) const
+        {
+          return (! is_local () || is_defined ());
+        }
+
+        bool is_local (void) const { return storage_class & local; }
+        bool is_automatic (void) const { return storage_class & automatic; }
+        bool is_formal (void) const { return storage_class & formal; }
+        bool is_hidden (void) const { return storage_class & hidden; }
+        bool is_inherited (void) const { return storage_class & inherited; }
+        bool is_global (void) const { return storage_class & global; }
+        bool is_persistent (void) const { return storage_class & persistent; }
+        bool is_added_static (void) const {return storage_class & added_static; }
+
+        void mark_local (void) { storage_class |= local; }
+        void mark_automatic (void) { storage_class |= automatic; }
+        void mark_formal (void) { storage_class |= formal; }
+        void mark_hidden (void) { storage_class |= hidden; }
+        void mark_inherited (void) { storage_class |= inherited; }
+        void mark_global (void)
+        {
+          if (is_persistent ())
+            error ("can't make persistent variable %s global", name.c_str ());
+
+          storage_class |= global;
+        }
+        void mark_persistent (void)
+        {
+          if (is_global ())
+            error ("can't make global variable %s persistent", name.c_str ());
+
+          storage_class |= persistent;
+        }
+        void mark_added_static (void) { storage_class |= added_static; }
+
+        void unmark_local (void) { storage_class &= ~local; }
+        void unmark_automatic (void) { storage_class &= ~automatic; }
+        void unmark_formal (void) { storage_class &= ~formal; }
+        void unmark_hidden (void) { storage_class &= ~hidden; }
+        void unmark_inherited (void) { storage_class &= ~inherited; }
+        void unmark_global (void) { storage_class &= ~global; }
+        void unmark_persistent (void) { storage_class &= ~persistent; }
+        void unmark_added_static (void) { storage_class &= ~added_static; }
+
+        void init_persistent (void);
+
+        void invalidate (void)
+        {
+          valid = false;
+        }
+
+        void erase_persistent (void);
+
+        scope *decl_scope (void) { return m_decl_scope; }
+
+        void set_curr_fcn (octave_user_function *fcn)
+        {
+          curr_fcn = fcn;
+        }
+
+        symbol_record_rep * dup (scope *new_scope) const;
+
+        octave_value dump (void) const;
+
+        scope *m_decl_scope;
+
+        octave_user_function *curr_fcn;
+
+        std::string name;
+
+        std::deque<octave_value> value_stack;
+
+        unsigned int storage_class;
+
+        //      fcn_info *finfo;
+
+        bool valid;
+
+        octave::refcount<size_t> count;
+
+      private:
+
+        octave_value& xglobal_varref (void);
+
+        octave_value& xpersistent_varref (void);
+
+        octave_value xglobal_varval (void) const;
+
+        octave_value xpersistent_varval (void) const;
+      };
+
+    public:
+
+      symbol_record (void);
+
+      symbol_record (scope *s, const std::string& nm = "",
+                     const octave_value& v = octave_value (),
+                     unsigned int sc = local)
+        : rep (new symbol_record_rep (s, nm, v, sc)) { }
+
+      symbol_record (const symbol_record& sr)
+        : rep (sr.rep)
+      {
+        rep->count++;
       }
 
-      // No copying!
-
-      symbol_record_rep (const symbol_record_rep& ov) = delete;
-
-      symbol_record_rep& operator = (const symbol_record_rep&) = delete;
-
-      ~symbol_record_rep (void) = default;
+      symbol_record& operator = (const symbol_record& sr)
+      {
+        if (this != &sr)
+          {
+            if (--rep->count == 0)
+              delete rep;
+
+            rep = sr.rep;
+            rep->count++;
+          }
+
+        return *this;
+      }
+
+      ~symbol_record (void)
+      {
+        if (--rep->count == 0)
+          delete rep;
+      }
+
+      symbol_record dup (scope *sid) const
+      {
+        return symbol_record (rep->dup (sid));
+      }
+
+      const std::string& name (void) const { return rep->name; }
+
+      void rename (const std::string& new_name) { rep->name = new_name; }
+
+      octave_value
+      find (const octave_value_list& args = octave_value_list ()) const;
 
       void assign (const octave_value& value)
       {
-        varref () = value;
+        rep->assign (value);
       }
 
       void assign (octave_value::assign_op op,
                    const std::string& type,
                    const std::list<octave_value_list>& idx,
                    const octave_value& value)
       {
-        varref().assign (op, type, idx, value);
+        rep->assign (op, type, idx, value);
       }
 
       void assign (octave_value::assign_op op, const octave_value& value)
       {
-        varref().assign (op, value);
+        rep->assign (op, value);
       }
 
       void do_non_const_unary_op (octave_value::unary_op op)
       {
-        varref().do_non_const_unary_op (op);
+        rep->do_non_const_unary_op (op);
       }
 
       void do_non_const_unary_op (octave_value::unary_op op,
                                   const std::string& type,
                                   const std::list<octave_value_list>& idx)
       {
-        varref().do_non_const_unary_op (op, type, idx);
+        rep->do_non_const_unary_op (op, type, idx);
       }
 
+      // Delete when deprecated varref functions are removed.
       octave_value& varref (void)
       {
-        context_id context
-          = m_decl_scope ? m_decl_scope->current_context () : 0;
-
-        if (is_global ())
-          return xglobal_varref ();
-        else if (is_persistent ())
-          return xpersistent_varref ();
-        else
-          {
-            context_id n = value_stack.size ();
-            while (n++ <= context)
-              value_stack.push_back (octave_value ());
-
-            return value_stack[context];
-          }
+        return rep->varref ();
       }
 
       octave_value varval (void) const
       {
-        context_id context
-          = m_decl_scope ? m_decl_scope->current_context () : 0;
-
-        if (is_global ())
-          return xglobal_varval ();
-        else if (is_persistent ())
-          return xpersistent_varval ();
-        else
-          {
-            if (context < value_stack.size ())
-              return value_stack[context];
-            else
-              return octave_value ();
-          }
-      }
-
-      void push_context (scope *sid)
-      {
-        if (! (is_persistent () || is_global ())
-            && sid == decl_scope ())
-          value_stack.push_back (octave_value ());
+        return rep->varval ();
       }
 
-      // If pop_context returns 0, we are out of values and this element
-      // of the symbol table should be deleted.  This can happen for
-      // functions like
-      //
-      //   function foo (n)
-      //     if (n > 0)
-      //       foo (n-1);
-      //     else
-      //       eval ("x = 1");
-      //     endif
-      //   endfunction
-      //
-      // Here, X should only exist in the final stack frame.
-
-      size_t pop_context (scope *sid)
-      {
-        size_t retval = 1;
-
-        if (! (is_persistent () || is_global ())
-            && sid == decl_scope ())
-          {
-            value_stack.pop_back ();
-            retval = value_stack.size ();
-          }
-
-        return retval;
-      }
-
-      void clear (void) { clear (decl_scope ()); }
-
-      void clear (scope *sid);
+      void push_context (scope *sid) { rep->push_context (sid); }
+
+      size_t pop_context (scope *sid) { return rep->pop_context (sid); }
+
+      void clear (void) { rep->clear (); }
+
+      void clear (scope *sid) { rep->clear (sid); }
 
       bool is_defined (void) const
       {
-        return varval ().is_defined ();
+        return rep->is_defined ();
+      }
+
+      bool is_undefined (void) const
+      {
+        return ! rep->is_defined ();
       }
 
       bool is_valid (void) const
       {
-        return valid;
+        return rep->is_valid ();
       }
 
       bool is_variable (void) const
       {
-        return (! is_local () || is_defined ());
-      }
-
-      bool is_local (void) const { return storage_class & local; }
-      bool is_automatic (void) const { return storage_class & automatic; }
-      bool is_formal (void) const { return storage_class & formal; }
-      bool is_hidden (void) const { return storage_class & hidden; }
-      bool is_inherited (void) const { return storage_class & inherited; }
-      bool is_global (void) const { return storage_class & global; }
-      bool is_persistent (void) const { return storage_class & persistent; }
-      bool is_added_static (void) const {return storage_class & added_static; }
-
-      void mark_local (void) { storage_class |= local; }
-      void mark_automatic (void) { storage_class |= automatic; }
-      void mark_formal (void) { storage_class |= formal; }
-      void mark_hidden (void) { storage_class |= hidden; }
-      void mark_inherited (void) { storage_class |= inherited; }
-      void mark_global (void)
-      {
-        if (is_persistent ())
-          error ("can't make persistent variable %s global", name.c_str ());
-
-        storage_class |= global;
-      }
-      void mark_persistent (void)
-      {
-        if (is_global ())
-          error ("can't make global variable %s persistent", name.c_str ());
-
-        storage_class |= persistent;
+        return rep->is_variable ();
       }
-      void mark_added_static (void) { storage_class |= added_static; }
-
-      void unmark_local (void) { storage_class &= ~local; }
-      void unmark_automatic (void) { storage_class &= ~automatic; }
-      void unmark_formal (void) { storage_class &= ~formal; }
-      void unmark_hidden (void) { storage_class &= ~hidden; }
-      void unmark_inherited (void) { storage_class &= ~inherited; }
-      void unmark_global (void) { storage_class &= ~global; }
-      void unmark_persistent (void) { storage_class &= ~persistent; }
-      void unmark_added_static (void) { storage_class &= ~added_static; }
-
-      void init_persistent (void);
-
-      void invalidate (void)
+
+      bool is_local (void) const { return rep->is_local (); }
+      bool is_automatic (void) const { return rep->is_automatic (); }
+      bool is_formal (void) const { return rep->is_formal (); }
+      bool is_global (void) const { return rep->is_global (); }
+      bool is_hidden (void) const { return rep->is_hidden (); }
+      bool is_inherited (void) const { return rep->is_inherited (); }
+      bool is_persistent (void) const { return rep->is_persistent (); }
+      bool is_added_static (void) const { return rep->is_added_static (); }
+
+      void mark_local (void) { rep->mark_local (); }
+      void mark_automatic (void) { rep->mark_automatic (); }
+      void mark_formal (void) { rep->mark_formal (); }
+      void mark_hidden (void) { rep->mark_hidden (); }
+      void mark_inherited (void) { rep->mark_inherited (); }
+      void mark_global (void) { rep->mark_global (); }
+      void mark_persistent (void) { rep->mark_persistent (); }
+      void mark_added_static (void) { rep->mark_added_static (); }
+
+      void unmark_local (void) { rep->unmark_local (); }
+      void unmark_automatic (void) { rep->unmark_automatic (); }
+      void unmark_formal (void) { rep->unmark_formal (); }
+      void unmark_hidden (void) { rep->unmark_hidden (); }
+      void unmark_inherited (void) { rep->unmark_inherited (); }
+      void unmark_global (void) { rep->unmark_global (); }
+      void unmark_persistent (void) { rep->unmark_persistent (); }
+      void unmark_added_static (void) { rep->unmark_added_static (); }
+
+      void init_persistent (void) { rep->init_persistent (); }
+
+      void erase_persistent (void) { rep->erase_persistent (); }
+
+      void invalidate (void) { rep->invalidate (); }
+
+      scope *decl_scope (void) { return rep->decl_scope (); }
+
+      unsigned int xstorage_class (void) const { return rep->storage_class; }
+
+      void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
+
+      octave_value dump (void) const { return rep->dump (); }
+
+      const symbol_record_rep *xrep (void) const { return rep; }
+
+    private:
+
+      symbol_record_rep *rep;
+
+      symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
+    };
+
+    static symbol_record dummy_symbol_record;
+
+    // Always access a symbol from the current scope.
+    // Useful for scripts, as they may be executed in more than one scope.
+    class
+      symbol_reference
+    {
+    public:
+
+      symbol_reference (void) : m_scope (0), m_context (0) { }
+
+      symbol_reference (const symbol_record& record);
+
+      symbol_reference (const symbol_record& record, scope *curr_scope,
+                        context_id context)
+        : m_scope (curr_scope), m_context (context), m_sym (record)
+      { }
+
+      symbol_reference (const symbol_reference& ref) = default;
+
+      symbol_reference& operator = (const symbol_reference& ref) = default;
+
+      bool is_black_hole (void) const { return ! m_scope; }
+
+      symbol_table::scope * scope (void) const
       {
-        valid = false;
+        update ();
+        return m_scope;
       }
 
-      void erase_persistent (void);
-
-      scope *decl_scope (void) { return m_decl_scope; }
-
-      void set_curr_fcn (octave_user_function *fcn)
+      context_id context (void) const
       {
-        curr_fcn = fcn;
+        update ();
+        return m_context;
+      }
+
+      // The name is the same regardless of scope.
+      const std::string& name (void) const { return m_sym.name (); }
+
+      symbol_record *operator-> (void)
+      {
+        update ();
+        return &m_sym;
+      }
+
+      symbol_record *operator-> (void) const
+      {
+        update ();
+        return &m_sym;
       }
 
-      symbol_record_rep * dup (scope *new_scope) const;
-
-      octave_value dump (void) const;
-
-      scope *m_decl_scope;
-
-      octave_user_function *curr_fcn;
-
-      std::string name;
-
-      std::deque<octave_value> value_stack;
-
-      unsigned int storage_class;
-
-      //      fcn_info *finfo;
-
-      bool valid;
-
-      octave::refcount<size_t> count;
+      // can be used to place symbol_reference in maps, we don't overload < as
+      // it doesn't make any sense for symbol_reference
+      struct comparator
+      {
+        bool operator ()(const symbol_reference& lhs,
+                         const symbol_reference& rhs) const
+        {
+          return lhs.name () < rhs.name ();
+        }
+      };
+    private:
+
+      void update (void) const;
+
+      mutable symbol_table::scope *m_scope;
+      mutable context_id m_context;
+      mutable symbol_record m_sym;
+    };
+
+    class fcn_info
+    {
+    public:
+
+      typedef std::map<std::string, octave_value>::const_iterator
+      str_val_const_iterator;
+      typedef std::map<std::string, octave_value>::iterator str_val_iterator;
 
     private:
 
-      octave_value& xglobal_varref (void);
-
-      octave_value& xpersistent_varref (void);
-
-      octave_value xglobal_varval (void) const;
-
-      octave_value xpersistent_varval (void) const;
-    };
-
-  public:
-
-    symbol_record (void);
-
-    symbol_record (scope *s, const std::string& nm = "",
-                   const octave_value& v = octave_value (),
-                   unsigned int sc = local)
-      : rep (new symbol_record_rep (s, nm, v, sc)) { }
-
-    symbol_record (const symbol_record& sr)
-      : rep (sr.rep)
-    {
-      rep->count++;
-    }
-
-    symbol_record& operator = (const symbol_record& sr)
-    {
-      if (this != &sr)
+      class fcn_info_rep
+      {
+      public:
+
+        fcn_info_rep (const std::string& nm)
+          : name (nm), package_name (), local_functions (),
+            private_functions (), class_constructors (), class_methods (),
+            cmdline_function (), autoload_function (), function_on_path (),
+            built_in_function (), count (1)
+        {
+          size_t pos = name.rfind ('.');
+
+          if (pos != std::string::npos)
+            {
+              package_name = name.substr (0, pos);
+              name = name.substr (pos+1);
+            }
+        }
+
+        // No copying!
+
+        fcn_info_rep (const fcn_info_rep&) = delete;
+
+        fcn_info_rep& operator = (const fcn_info_rep&) = delete;
+
+        ~fcn_info_rep (void) = default;
+
+        octave_value install_local_function (const std::string& file_name);
+
+        octave_value load_private_function (const std::string& dir_name);
+
+        octave_value load_class_constructor (void);
+
+        octave_value load_class_method (const std::string& dispatch_type);
+
+        octave_value find (const octave_value_list& args, bool local_funcs);
+
+        octave_value builtin_find (void);
+
+        octave_value find_method (const std::string& dispatch_type);
+
+        octave_value find_autoload (void);
+
+        octave_value find_package (void);
+
+        octave_value find_user_function (void);
+
+        bool is_user_function_defined (void) const
+        {
+          return function_on_path.is_defined ();
+        }
+
+        octave_value find_function (const octave_value_list& args,
+                                    bool local_funcs)
+        {
+          return find (args, local_funcs);
+        }
+
+        void install_cmdline_function (const octave_value& f)
         {
-          if (--rep->count == 0)
-            delete rep;
-
-          rep = sr.rep;
-          rep->count++;
+          cmdline_function = f;
+        }
+
+        void install_local_function (const octave_value& f,
+                                     const std::string& file_name)
+        {
+          local_functions[file_name] = f;
+        }
+
+        void install_user_function (const octave_value& f)
+        {
+          function_on_path = f;
+        }
+
+        void install_built_in_function (const octave_value& f)
+        {
+          built_in_function = f;
+        }
+
+        void install_built_in_dispatch (const std::string& klass);
+
+        template <typename T>
+        void
+        clear_map (std::map<T, octave_value>& map, bool force = false)
+        {
+          typename std::map<T, octave_value>::iterator p = map.begin ();
+
+          while (p != map.end ())
+            {
+              if (force || ! p->second.islocked ())
+                map.erase (p++);
+              else
+                p++;
+            }
+        }
+
+        void clear_autoload_function (bool force = false)
+        {
+          if (force || ! autoload_function.islocked ())
+            autoload_function = octave_value ();
+        }
+
+        // We also clear command line functions here, as these are both
+        // "user defined"
+        void clear_user_function (bool force = false)
+        {
+          clear_autoload_function (force);
+
+          if (force || ! function_on_path.islocked ())
+            function_on_path = octave_value ();
+
+          if (force || ! cmdline_function.islocked ())
+            cmdline_function = octave_value ();
+        }
+
+        void clear_mex_function (void)
+        {
+          if (function_on_path.is_mex_function ())
+            clear_user_function ();
         }
 
-      return *this;
-    }
-
-    ~symbol_record (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
-
-    symbol_record dup (scope *sid) const
-    {
-      return symbol_record (rep->dup (sid));
-    }
-
-    const std::string& name (void) const { return rep->name; }
-
-    void rename (const std::string& new_name) { rep->name = new_name; }
-
-    octave_value
-    find (const octave_value_list& args = octave_value_list ()) const;
-
-    void assign (const octave_value& value)
-    {
-      rep->assign (value);
-    }
-
-    void assign (octave_value::assign_op op,
-                 const std::string& type,
-                 const std::list<octave_value_list>& idx,
-                 const octave_value& value)
-    {
-      rep->assign (op, type, idx, value);
-    }
-
-    void assign (octave_value::assign_op op, const octave_value& value)
-    {
-      rep->assign (op, value);
-    }
-
-    void do_non_const_unary_op (octave_value::unary_op op)
-    {
-      rep->do_non_const_unary_op (op);
-    }
-
-    void do_non_const_unary_op (octave_value::unary_op op,
-                                const std::string& type,
-                                const std::list<octave_value_list>& idx)
-    {
-      rep->do_non_const_unary_op (op, type, idx);
-    }
-
-    // Delete when deprecated varref functions are removed.
-    octave_value& varref (void)
-    {
-      return rep->varref ();
-    }
-
-    octave_value varval (void) const
-    {
-      return rep->varval ();
-    }
-
-    void push_context (scope *sid) { rep->push_context (sid); }
-
-    size_t pop_context (scope *sid) { return rep->pop_context (sid); }
-
-    void clear (void) { rep->clear (); }
-
-    void clear (scope *sid) { rep->clear (sid); }
-
-    bool is_defined (void) const
-    {
-      return rep->is_defined ();
-    }
-
-    bool is_undefined (void) const
-    {
-      return ! rep->is_defined ();
-    }
-
-    bool is_valid (void) const
-    {
-      return rep->is_valid ();
-    }
-
-    bool is_variable (void) const
-    {
-      return rep->is_variable ();
-    }
-
-    bool is_local (void) const { return rep->is_local (); }
-    bool is_automatic (void) const { return rep->is_automatic (); }
-    bool is_formal (void) const { return rep->is_formal (); }
-    bool is_global (void) const { return rep->is_global (); }
-    bool is_hidden (void) const { return rep->is_hidden (); }
-    bool is_inherited (void) const { return rep->is_inherited (); }
-    bool is_persistent (void) const { return rep->is_persistent (); }
-    bool is_added_static (void) const { return rep->is_added_static (); }
-
-    void mark_local (void) { rep->mark_local (); }
-    void mark_automatic (void) { rep->mark_automatic (); }
-    void mark_formal (void) { rep->mark_formal (); }
-    void mark_hidden (void) { rep->mark_hidden (); }
-    void mark_inherited (void) { rep->mark_inherited (); }
-    void mark_global (void) { rep->mark_global (); }
-    void mark_persistent (void) { rep->mark_persistent (); }
-    void mark_added_static (void) { rep->mark_added_static (); }
-
-    void unmark_local (void) { rep->unmark_local (); }
-    void unmark_automatic (void) { rep->unmark_automatic (); }
-    void unmark_formal (void) { rep->unmark_formal (); }
-    void unmark_hidden (void) { rep->unmark_hidden (); }
-    void unmark_inherited (void) { rep->unmark_inherited (); }
-    void unmark_global (void) { rep->unmark_global (); }
-    void unmark_persistent (void) { rep->unmark_persistent (); }
-    void unmark_added_static (void) { rep->unmark_added_static (); }
-
-    void init_persistent (void) { rep->init_persistent (); }
-
-    void erase_persistent (void) { rep->erase_persistent (); }
-
-    void invalidate (void) { rep->invalidate (); }
-
-    scope *decl_scope (void) { return rep->decl_scope (); }
-
-    unsigned int xstorage_class (void) const { return rep->storage_class; }
-
-    void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
-
-    octave_value dump (void) const { return rep->dump (); }
-
-    const symbol_record_rep *xrep (void) const { return rep; }
-
-  private:
-
-    symbol_record_rep *rep;
-
-    symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
-  };
-
-  static symbol_record dummy_symbol_record;
-
-  // Always access a symbol from the current scope.
-  // Useful for scripts, as they may be executed in more than one scope.
-  class
-    symbol_reference
-  {
-  public:
-
-    symbol_reference (void) : m_scope (0), m_context (0) { }
-
-    symbol_reference (const symbol_record& record);
-
-    symbol_reference (const symbol_record& record, scope *curr_scope,
-                      context_id context)
-      : m_scope (curr_scope), m_context (context), m_sym (record)
-    { }
-
-    symbol_reference (const symbol_reference& ref) = default;
-
-    symbol_reference& operator = (const symbol_reference& ref) = default;
-
-    bool is_black_hole (void) const { return ! m_scope; }
-
-    symbol_table::scope * scope (void) const
-    {
-      update ();
-      return m_scope;
-    }
-
-    context_id context (void) const
-    {
-      update ();
-      return m_context;
-    }
-
-    // The name is the same regardless of scope.
-    const std::string& name (void) const { return m_sym.name (); }
-
-    symbol_record *operator-> (void)
-    {
-      update ();
-      return &m_sym;
-    }
-
-    symbol_record *operator-> (void) const
-    {
-      update ();
-      return &m_sym;
-    }
-
-    // can be used to place symbol_reference in maps, we don't overload < as
-    // it doesn't make any sense for symbol_reference
-    struct comparator
-    {
-      bool operator ()(const symbol_reference& lhs,
-                       const symbol_reference& rhs) const
+        void clear_package (void)
+        {
+          package = octave_value ();
+        }
+
+        void clear (bool force = false)
+        {
+          clear_map (local_functions, force);
+          clear_map (private_functions, force);
+          clear_map (class_constructors, force);
+          clear_map (class_methods, force);
+
+          clear_autoload_function (force);
+          clear_user_function (force);
+          clear_package ();
+        }
+
+        octave_value dump (void) const;
+
+        std::string full_name (void) const
+        {
+          if (package_name.empty ())
+            return name;
+          else
+            return package_name + "." + name;
+        }
+
+        std::string name;
+
+        std::string package_name;
+
+        // File name to function object.
+        std::map<std::string, octave_value> local_functions;
+
+        // Directory name to function object.
+        std::map<std::string, octave_value> private_functions;
+
+        // Class name to function object.
+        std::map<std::string, octave_value> class_constructors;
+
+        // Dispatch type to function object.
+        std::map<std::string, octave_value> class_methods;
+
+        octave_value cmdline_function;
+
+        octave_value autoload_function;
+
+        octave_value function_on_path;
+
+        octave_value package;
+
+        octave_value built_in_function;
+
+        octave::refcount<size_t> count;
+
+      private:
+
+        octave_value xfind (const octave_value_list& args, bool local_funcs);
+
+        octave_value x_builtin_find (void);
+      };
+
+    public:
+
+      fcn_info (const std::string& nm = "")
+        : rep (new fcn_info_rep (nm)) { }
+
+      fcn_info (const fcn_info& fi) : rep (fi.rep)
       {
-        return lhs.name () < rhs.name ();
+        rep->count++;
       }
-    };
-  private:
-
-    void update (void) const;
-
-    mutable symbol_table::scope *m_scope;
-    mutable context_id m_context;
-    mutable symbol_record m_sym;
-  };
-
-  class
-    fcn_info
-  {
-  public:
-
-    typedef std::map<std::string, octave_value>::const_iterator
-    str_val_const_iterator;
-    typedef std::map<std::string, octave_value>::iterator str_val_iterator;
-
-  private:
-
-    class
-    fcn_info_rep
-    {
-    public:
-
-      fcn_info_rep (const std::string& nm)
-        : name (nm), package_name (), local_functions (),
-          private_functions (), class_constructors (), class_methods (),
-          cmdline_function (), autoload_function (), function_on_path (),
-          built_in_function (), count (1)
+
+      fcn_info& operator = (const fcn_info& fi)
+      {
+        if (this != &fi)
+          {
+            if (--rep->count == 0)
+              delete rep;
+
+            rep = fi.rep;
+            rep->count++;
+          }
+
+        return *this;
+      }
+
+      ~fcn_info (void)
+      {
+        if (--rep->count == 0)
+          delete rep;
+      }
+
+      octave_value find (const octave_value_list& args = octave_value_list (),
+                         bool local_funcs = true)
       {
-        size_t pos = name.rfind ('.');
-
-        if (pos != std::string::npos)
-          {
-            package_name = name.substr (0, pos);
-            name = name.substr (pos+1);
-          }
+        return rep->find (args, local_funcs);
+      }
+
+      octave_value builtin_find (void)
+      {
+        return rep->builtin_find ();
+      }
+
+      octave_value find_method (const std::string& dispatch_type) const
+      {
+        return rep->find_method (dispatch_type);
       }
 
-      // No copying!
-
-      fcn_info_rep (const fcn_info_rep&) = delete;
-
-      fcn_info_rep& operator = (const fcn_info_rep&) = delete;
-
-      ~fcn_info_rep (void) = default;
-
-      octave_value install_local_function (const std::string& file_name);
-
-      octave_value load_private_function (const std::string& dir_name);
-
-      octave_value load_class_constructor (void);
-
-      octave_value load_class_method (const std::string& dispatch_type);
-
-      octave_value find (const octave_value_list& args, bool local_funcs);
-
-      octave_value builtin_find (void);
-
-      octave_value find_method (const std::string& dispatch_type);
-
-      octave_value find_autoload (void);
-
-      octave_value find_package (void);
-
-      octave_value find_user_function (void);
+      octave_value find_built_in_function (void) const
+      {
+        return rep->built_in_function;
+      }
+
+      octave_value find_cmdline_function (void) const
+      {
+        return rep->cmdline_function;
+      }
+
+      octave_value find_autoload (void)
+      {
+        return rep->find_autoload ();
+      }
+
+      octave_value find_user_function (void)
+      {
+        return rep->find_user_function ();
+      }
 
       bool is_user_function_defined (void) const
       {
-        return function_on_path.is_defined ();
+        return rep->is_user_function_defined ();
       }
 
-      octave_value find_function (const octave_value_list& args,
-                                  bool local_funcs)
+      octave_value find_function (const octave_value_list& args
+                                  = octave_value_list (),
+                                  bool local_funcs = true)
       {
-        return find (args, local_funcs);
+        return rep->find_function (args, local_funcs);
       }
 
       void install_cmdline_function (const octave_value& f)
       {
-        cmdline_function = f;
+        rep->install_cmdline_function (f);
       }
 
       void install_local_function (const octave_value& f,
                                    const std::string& file_name)
       {
-        local_functions[file_name] = f;
+        rep->install_local_function (f, file_name);
       }
 
       void install_user_function (const octave_value& f)
       {
-        function_on_path = f;
+        rep->install_user_function (f);
       }
 
       void install_built_in_function (const octave_value& f)
       {
-        built_in_function = f;
+        rep->install_built_in_function (f);
       }
 
-      void install_built_in_dispatch (const std::string& klass);
-
-      template <typename T>
-      void
-      clear_map (std::map<T, octave_value>& map, bool force = false)
+      void install_built_in_dispatch (const std::string& klass)
       {
-        typename std::map<T, octave_value>::iterator p = map.begin ();
-
-        while (p != map.end ())
-          {
-            if (force || ! p->second.islocked ())
-              map.erase (p++);
-            else
-              p++;
-          }
+        rep->install_built_in_dispatch (klass);
+      }
+
+      void clear (bool force = false) { rep->clear (force); }
+
+      void clear_user_function (bool force = false)
+      {
+        rep->clear_user_function (force);
       }
 
       void clear_autoload_function (bool force = false)
       {
-        if (force || ! autoload_function.islocked ())
-          autoload_function = octave_value ();
-      }
-
-      // We also clear command line functions here, as these are both
-      // "user defined"
-      void clear_user_function (bool force = false)
-      {
-        clear_autoload_function (force);
-
-        if (force || ! function_on_path.islocked ())
-          function_on_path = octave_value ();
-
-        if (force || ! cmdline_function.islocked ())
-          cmdline_function = octave_value ();
-      }
-
-      void clear_mex_function (void)
-      {
-        if (function_on_path.is_mex_function ())
-          clear_user_function ();
-      }
-
-      void clear_package (void)
-      {
-        package = octave_value ();
-      }
-
-      void clear (bool force = false)
-      {
-        clear_map (local_functions, force);
-        clear_map (private_functions, force);
-        clear_map (class_constructors, force);
-        clear_map (class_methods, force);
-
-        clear_autoload_function (force);
-        clear_user_function (force);
-        clear_package ();
+        rep->clear_autoload_function (force);
       }
 
-      octave_value dump (void) const;
-
-      std::string full_name (void) const
-      {
-        if (package_name.empty ())
-          return name;
-        else
-          return package_name + "." + name;
-      }
-
-      std::string name;
-
-      std::string package_name;
-
-      // File name to function object.
-      std::map<std::string, octave_value> local_functions;
-
-      // Directory name to function object.
-      std::map<std::string, octave_value> private_functions;
-
-      // Class name to function object.
-      std::map<std::string, octave_value> class_constructors;
-
-      // Dispatch type to function object.
-      std::map<std::string, octave_value> class_methods;
-
-      octave_value cmdline_function;
-
-      octave_value autoload_function;
-
-      octave_value function_on_path;
-
-      octave_value package;
-
-      octave_value built_in_function;
-
-      octave::refcount<size_t> count;
+      void clear_mex_function (void) { rep->clear_mex_function (); }
+
+      octave_value dump (void) const { return rep->dump (); }
 
     private:
 
-      octave_value xfind (const octave_value_list& args, bool local_funcs);
-
-      octave_value x_builtin_find (void);
+      fcn_info_rep *rep;
     };
 
-  public:
-
-    fcn_info (const std::string& nm = "")
-      : rep (new fcn_info_rep (nm)) { }
-
-    fcn_info (const fcn_info& fi) : rep (fi.rep)
-    {
-      rep->count++;
-    }
-
-    fcn_info& operator = (const fcn_info& fi)
-    {
-      if (this != &fi)
-        {
-          if (--rep->count == 0)
-            delete rep;
-
-          rep = fi.rep;
-          rep->count++;
-        }
-
-      return *this;
-    }
-
-    ~fcn_info (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
-
-    octave_value find (const octave_value_list& args = octave_value_list (),
-                       bool local_funcs = true)
-    {
-      return rep->find (args, local_funcs);
-    }
-
-    octave_value builtin_find (void)
-    {
-      return rep->builtin_find ();
-    }
-
-    octave_value find_method (const std::string& dispatch_type) const
-    {
-      return rep->find_method (dispatch_type);
-    }
-
-    octave_value find_built_in_function (void) const
-    {
-      return rep->built_in_function;
-    }
-
-    octave_value find_cmdline_function (void) const
-    {
-      return rep->cmdline_function;
-    }
-
-    octave_value find_autoload (void)
-    {
-      return rep->find_autoload ();
-    }
-
-    octave_value find_user_function (void)
-    {
-      return rep->find_user_function ();
-    }
-
-    bool is_user_function_defined (void) const
-    {
-      return rep->is_user_function_defined ();
-    }
-
-    octave_value find_function (const octave_value_list& args
-                                = octave_value_list (),
-                                bool local_funcs = true)
-    {
-      return rep->find_function (args, local_funcs);
-    }
-
-    void install_cmdline_function (const octave_value& f)
-    {
-      rep->install_cmdline_function (f);
-    }
-
-    void install_local_function (const octave_value& f,
-                                 const std::string& file_name)
-    {
-      rep->install_local_function (f, file_name);
-    }
-
-    void install_user_function (const octave_value& f)
-    {
-      rep->install_user_function (f);
-    }
-
-    void install_built_in_function (const octave_value& f)
-    {
-      rep->install_built_in_function (f);
-    }
-
-    void install_built_in_dispatch (const std::string& klass)
-    {
-      rep->install_built_in_dispatch (klass);
-    }
-
-    void clear (bool force = false) { rep->clear (force); }
-
-    void clear_user_function (bool force = false)
-    {
-      rep->clear_user_function (force);
-    }
-
-    void clear_autoload_function (bool force = false)
-    {
-      rep->clear_autoload_function (force);
-    }
-
-    void clear_mex_function (void) { rep->clear_mex_function (); }
-
-    octave_value dump (void) const { return rep->dump (); }
-
-  private:
-
-    fcn_info_rep *rep;
-  };
-
-  symbol_table (void)
-    : m_global_symbols (), m_fcn_table (), m_class_precedence_table (),
+    symbol_table (void)
+      : m_global_symbols (), m_fcn_table (), m_class_precedence_table (),
       m_parent_map (), m_global_scope (new scope ("global scope")),
       m_top_scope (new scope ("top scope")),
       m_current_scope (m_top_scope)
-  { }
-
-  // No copying!
-
-  symbol_table (const symbol_table&) = delete;
-
-  symbol_table& operator = (const symbol_table&) = delete;
-
-  ~symbol_table (void)
-    {
-      delete m_top_scope;
-      delete m_global_scope;
-    }
-
-  scope *global_scope (void) { return m_global_scope; }
-  scope *top_scope (void) { return m_top_scope; }
-
-  scope *current_scope (void) { return m_current_scope; }
-
-  scope *require_current_scope (const std::string& who)
-  {
-    if (! m_current_scope)
-      error ("%s: missing scope", who.c_str ());
-
-    return m_current_scope;
-  }
-
-  context_id current_context (void) const
-  {
-    return m_current_scope ? m_current_scope->current_context () : 0;
-  }
-
-  void set_scope (scope *sid)
-  {
-    set_scope_and_context (sid, 0);
-  }
-
-  void set_scope_and_context (scope *sid, context_id context)
-  {
-    if (sid == m_global_scope)
-      error ("can't set scope to global");
-
-    m_current_scope = sid;
-
-    if (m_current_scope)
-      m_current_scope->set_context (context);
-  }
-
-  symbol_record find_symbol (const std::string& name, scope *sid)
-  {
-    return sid ? sid->find_symbol (name) : symbol_record ();
-  }
-
-  symbol_record find_symbol (const std::string& name)
-  {
-    return find_symbol (name, m_current_scope);
-  }
-
-  void inherit (scope *recipient_scope, scope *donor_scope)
-  {
-    if (recipient_scope)
-      recipient_scope->inherit (donor_scope);
-  }
-
-  void inherit (scope *recipient_scope)
-  {
-    inherit (recipient_scope, m_current_scope);
-  }
-
-  bool at_top_level (void) { return m_current_scope == m_top_scope; }
-
-  // Find a value corresponding to the given name in the table.
-  octave_value
-    find (const std::string& name,
-          const octave_value_list& args = octave_value_list (),
-          bool skip_variables = false,
-          bool local_funcs = true);
-
-  octave_value builtin_find (const std::string& name);
-
-  void
-  global_assign (const std::string& name,
-                 const octave_value& value = octave_value ())
-
-  {
-    global_symbols_iterator p = m_global_symbols.find (name);
-
-    if (p == m_global_symbols.end ())
-      m_global_symbols[name] = value;
-    else
-      p->second = value;
-  }
-
-  octave_value
-  global_varval (const std::string& name)
-  {
-    global_symbols_const_iterator p = m_global_symbols.find (name);
-
-    return (p != m_global_symbols.end ()) ? p->second : octave_value ();
-  }
-
-  void
-  top_level_assign (const std::string& name,
-                    const octave_value& value = octave_value ())
-  {
-    m_top_scope->assign (name, value);
-  }
-
-  octave_value
-  top_level_varval (const std::string& name)
-  {
-    return m_top_scope->varval (name);
-  }
-
-  bool
-    is_built_in_function_name (const std::string& name)
-  {
-    octave_value val = find_built_in_function (name);
-
-    return val.is_defined ();
-  }
-
-  octave_value
-    find_method (const std::string& name, const std::string& dispatch_type)
-  {
-    fcn_table_const_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        octave_value fcn = p->second.find_method (dispatch_type);
-
-        if (! fcn.is_defined ())
-          fcn = find_submethod (name, dispatch_type);
-
-        return fcn;
-      }
-    else
-      {
-        fcn_info finfo (name);
-
-        octave_value fcn = finfo.find_method (dispatch_type);
-
-        if (! fcn.is_defined ())
-          fcn = find_submethod (name, dispatch_type);
-
-        if (fcn.is_defined ())
-          m_fcn_table[name] = finfo;
-
-        return fcn;
-      }
-  }
-
-  octave_value
-    find_submethod (const std::string& name, const std::string& dispatch_type);
-
-  octave_value
-    find_built_in_function (const std::string& name)
-  {
-    fcn_table_const_iterator p = m_fcn_table.find (name);
-
-    return (p != m_fcn_table.end ()
-            ? p->second.find_built_in_function () : octave_value ());
-  }
-
-  octave_value
-    find_autoload (const std::string& name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    return (p != m_fcn_table.end ()
-            ? p->second.find_autoload () : octave_value ());
-  }
-
-  octave_value
-    find_function (const std::string& name,
-                   const octave_value_list& args = octave_value_list (),
-                   bool local_funcs = true);
-
-  octave_value find_user_function (const std::string& name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    return (p != m_fcn_table.end ()
-            ? p->second.find_user_function () : octave_value ());
-  }
-
-  octave_value find_cmdline_function (const std::string& name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    return (p != m_fcn_table.end ()
-            ? p->second.find_cmdline_function () : octave_value ());
-  }
-
-  void install_cmdline_function (const std::string& name,
-                                 const octave_value& fcn)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.install_cmdline_function (fcn);
-      }
-    else
-      {
-        fcn_info finfo (name);
-
-        finfo.install_cmdline_function (fcn);
-
-        m_fcn_table[name] = finfo;
-      }
-  }
-
-  // Install local function FCN named NAME.  FILE_NAME is the name of
-  // the file containing the local function.
-
-  void install_local_function (const std::string& name,
-                               const octave_value& fcn,
-                               const std::string& file_name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.install_local_function (fcn, file_name);
-      }
-    else
-      {
-        fcn_info finfo (name);
-
-        finfo.install_local_function (fcn, file_name);
-
-        m_fcn_table[name] = finfo;
-      }
-  }
-
-  void install_user_function (const std::string& name,
-                              const octave_value& fcn)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.install_user_function (fcn);
-      }
-    else
-      {
-        fcn_info finfo (name);
-
-        finfo.install_user_function (fcn);
-
-        m_fcn_table[name] = finfo;
-      }
-  }
-
-  void install_built_in_function (const std::string& name,
-                                  const octave_value& fcn)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.install_built_in_function (fcn);
-      }
-    else
-      {
-        fcn_info finfo (name);
-
-        finfo.install_built_in_function (fcn);
-
-        m_fcn_table[name] = finfo;
-      }
-  }
-
-  void clear_all (bool force = false)
-  {
-    if (m_current_scope)
-      {
-        m_current_scope->clear_variables ();
-        m_current_scope->clear_global_pattern ("*");
-      }
-
-    clear_functions (force);
-  }
-
-  // This is written as two separate functions instead of a single
-  // function with default values so that it will work properly with
-  // unwind_protect.
-
-  void clear_functions (bool force = false)
-  {
-    fcn_table_iterator p = m_fcn_table.begin ();
-
-    while (p != m_fcn_table.end ())
-      (p++)->second.clear (force);
-  }
-
-  void clear_function (const std::string& name)
-  {
-    clear_user_function (name);
-  }
-
-  void clear_symbol (const std::string& name)
-  {
-    // FIXME: are we supposed to do both here?
-
-    if (m_current_scope)
-      m_current_scope->clear_variable (name);
-
-    clear_function (name);
-  }
-
-  void clear_function_pattern (const std::string& pat)
-  {
-    glob_match pattern (pat);
-
-    fcn_table_iterator p = m_fcn_table.begin ();
-
-    while (p != m_fcn_table.end ())
-      {
-        if (pattern.match (p->first))
-          (p++)->second.clear_user_function ();
-        else
-          p++;
-      }
-  }
-
-  void clear_symbol_pattern (const std::string& pat)
-  {
-    // FIXME: are we supposed to do both here?
-
-    if (m_current_scope)
-      m_current_scope->clear_variable_pattern (pat);
-
-    clear_function_pattern (pat);
-  }
-
-  void clear_user_function (const std::string& name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.clear_user_function ();
-      }
-    // FIXME: is this necessary, or even useful?
-    // else
-    //   error ("clear: no such function '%s'", name.c_str ());
-  }
-
-  // This clears oct and mex files, including autoloads.
-  void clear_dld_function (const std::string& name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.clear_autoload_function ();
-        finfo.clear_user_function ();
-      }
-  }
-
-  void clear_mex_functions (void)
-  {
-    fcn_table_iterator p = m_fcn_table.begin ();
-
-    while (p != m_fcn_table.end ())
-      (p++)->second.clear_mex_function ();
-  }
-
-  bool set_class_relationship (const std::string& sup_class,
-                               const std::string& inf_class);
-
-  bool is_superiorto (const std::string& a, const std::string& b);
-
-  void alias_built_in_function (const std::string& alias,
-                                const std::string& name)
-  {
-    octave_value fcn = find_built_in_function (name);
-
-    if (fcn.is_defined ())
-      {
-        fcn_info finfo (alias);
-
-        finfo.install_built_in_function (fcn);
-
-        m_fcn_table[alias] = finfo;
-      }
-    else
-      panic ("alias: '%s' is undefined", name.c_str ());
-  }
-
-  void install_built_in_dispatch (const std::string& name,
-                                  const std::string& klass)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-
-    if (p != m_fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.install_built_in_dispatch (klass);
-      }
-    else
-      error ("install_built_in_dispatch: '%s' is undefined", name.c_str ());
-  }
-
-  void push_context (void)
-  {
-    if (m_current_scope == m_top_scope)
-      error ("invalid call to symtab::push_context");
-
-    if (m_current_scope)
-      m_current_scope->push_context ();
-  }
-
-  // This is written as two separate functions instead of a single
-  // function with default values so that it will work properly with
-  // unwind_protect.
-
-  void pop_context (void)
-  {
-    if (m_current_scope == m_top_scope)
-      error ("invalid call to symtab::pop_context");
-
-    if (m_current_scope)
-      m_current_scope->pop_context ();
-  }
-
-  // For unwind_protect where a pointer argument is needed.
-
-  void pop_context (void *) { pop_context (); }
-
-  std::list<symbol_record> glob (const std::string& pattern)
-  {
-    return (m_current_scope
-            ? m_current_scope->glob (pattern) : std::list<symbol_record> ());
-  }
-
-  std::list<symbol_record>
-  glob_global_variables (const std::string& pattern)
-  {
-    std::list<symbol_record> retval;
-
-    glob_match pat (pattern);
-
-    for (const auto& nm_val : m_global_symbols)
-      {
-        // We generate a list of symbol_record objects so that the results from
-        // glob_variables and glob_global_variables may be handled the same
-        // way.
-        if (pat.match (nm_val.first))
-          retval.push_back (symbol_record (m_global_scope,
-                                           nm_val.first, nm_val.second,
-                                           symbol_record::global));
-      }
-
-    return retval;
-  }
-
-  std::list<symbol_record>
-  regexp_global_variables (const std::string& pattern)
-  {
-    std::list<symbol_record> retval;
-
-    octave::regexp pat (pattern);
-
-    for (const auto& nm_val : m_global_symbols)
-      {
-        // We generate a list of symbol_record objects so that the results from
-        // regexp_variables and regexp_global_variables may be handled the same
-        // way.
-        if (pat.is_match (nm_val.first))
-          retval.push_back (symbol_record (m_global_scope,
-                                           nm_val.first, nm_val.second,
-                                           symbol_record::global));
-      }
-
-    return retval;
-  }
-
-  std::list<symbol_record> glob_variables (const string_vector& patterns)
-  {
-    std::list<symbol_record> retval;
-
-    if (! m_current_scope)
-      return retval;
-
-    size_t len = patterns.numel ();
-
-    for (size_t i = 0; i < len; i++)
-      {
-        std::list<symbol_record> tmp = m_current_scope->glob (patterns[i]);
-
-        retval.insert (retval.begin (), tmp.begin (), tmp.end ());
-      }
-
-    return retval;
-  }
-
-  std::list<symbol_record> regexp_variables (const string_vector& patterns)
-  {
-    std::list<symbol_record> retval;
-
-    if (! m_current_scope)
-      return retval;
-
-    size_t len = patterns.numel ();
-
-    for (size_t i = 0; i < len; i++)
-      {
-        std::list<symbol_record> tmp = m_current_scope->regexp (patterns[i]);
-
-        retval.insert (retval.begin (), tmp.begin (), tmp.end ());
-      }
-
-    return retval;
-  }
-
-  std::list<std::string> user_function_names (void)
-  {
-    std::list<std::string> retval;
-
-    for (const auto& nm_finfo : m_fcn_table)
-      {
-        if (nm_finfo.second.is_user_function_defined ())
-          retval.push_back (nm_finfo.first);
-      }
-
-    if (! retval.empty ())
-      retval.sort ();
-
-    return retval;
-  }
-
-  std::list<std::string> global_variable_names (void)
-  {
-    std::list<std::string> retval;
-
-    for (const auto& nm_val : m_global_symbols)
-      retval.push_back (nm_val.first);
-
-    retval.sort ();
-
-    return retval;
-  }
-
-  std::list<std::string> top_level_variable_names (void)
-  {
-    return (m_top_scope
-            ? m_top_scope->variable_names () : std::list<std::string> ());
-  }
-
-  std::list<std::string> variable_names (void)
-  {
-    return (m_current_scope
-            ? m_current_scope->variable_names () : std::list<std::string> ());
-  }
-
-  std::list<std::string> built_in_function_names (void)
-  {
-    std::list<std::string> retval;
-
-    for (const auto& nm_finfo : m_fcn_table)
-      {
-        octave_value fcn = nm_finfo.second.find_built_in_function ();
-
-        if (fcn.is_defined ())
-          retval.push_back (nm_finfo.first);
-      }
-
-    if (! retval.empty ())
-      retval.sort ();
-
-    return retval;
-  }
-
-  std::list<std::string> cmdline_function_names (void)
-  {
-    std::list<std::string> retval;
-
-    for (const auto& nm_finfo : m_fcn_table)
-      {
-        octave_value fcn = nm_finfo.second.find_cmdline_function ();
-
-        if (fcn.is_defined ())
-          retval.push_back (nm_finfo.first);
-      }
-
-    if (! retval.empty ())
-      retval.sort ();
-
-    return retval;
-  }
-
-  octave_value dump (void) const;
-
-  void add_to_parent_map (const std::string& classname,
-                          const std::list<std::string>& parent_list)
-  {
-    m_parent_map[classname] = parent_list;
-  }
-
-  std::list<std::string>
-  parent_classes (const std::string& dispatch_type)
-  {
-    std::list<std::string> retval;
-
-    const_parent_map_iterator it = m_parent_map.find (dispatch_type);
-
-    if (it != m_parent_map.end ())
-      retval = it->second;
-
-    for (const auto& nm : retval)
-      {
-        // Search for parents of parents and append them to the list.
-
-        // FIXME: should we worry about a circular inheritance graph?
-
-        std::list<std::string> parents = parent_classes (nm);
-
-        if (! parents.empty ())
-          retval.insert (retval.end (), parents.begin (), parents.end ());
-      }
-
-    return retval;
-  }
-
-  octave_user_function * get_curr_fcn (void)
-  {
-    return m_current_scope ? m_current_scope->function () : 0;
-  }
-
-  void cleanup (void);
-
-  fcn_info * get_fcn_info (const std::string& name)
-  {
-    fcn_table_iterator p = m_fcn_table.find (name);
-    return p != m_fcn_table.end () ? &p->second : 0;
-  }
-
-  class scope
-  {
-  public:
-
-    typedef std::map<std::string, symbol_table::symbol_record>::const_iterator
-      table_const_iterator;
-    typedef std::map<std::string, symbol_table::symbol_record>::iterator
-      table_iterator;
-
-    typedef std::map<std::string, octave_value>::const_iterator
-      m_persistent_symbols_const_iterator;
-    typedef std::map<std::string, octave_value>::iterator
-      m_persistent_symbols_iterator;
-
-    typedef std::map<std::string, octave_value>::const_iterator
-      subfunctions_const_iterator;
-    typedef std::map<std::string, octave_value>::iterator subfunctions_iterator;
-
-    scope (const std::string& name = "")
-      : m_name (name), m_symbols (), m_persistent_symbols (), m_subfunctions (),
-        m_fcn (0), m_parent (0), m_children (), m_is_nested (false),
-        m_is_static (false), m_context (0)
-    { }
+      { }
 
     // No copying!
 
-    scope (const scope&) = delete;
-
-    scope& operator = (const scope&) = delete;
-
-    ~scope (void) = default;
-
-    void insert_symbol_record (const symbol_table::symbol_record& sr)
-    {
-      m_symbols[sr.name ()] = sr;
-    }
-
-    bool is_nested (void) const { return m_is_nested; }
-
-    void mark_nested (void) { m_is_nested = true; }
-
-    scope * parent_scope (void) const { return m_parent; }
-
-    scope * dup (void) const
+    symbol_table (const symbol_table&) = delete;
+
+    symbol_table& operator = (const symbol_table&) = delete;
+
+    ~symbol_table (void)
+      {
+        delete m_top_scope;
+        delete m_global_scope;
+      }
+
+    scope *global_scope (void) { return m_global_scope; }
+    scope *top_scope (void) { return m_top_scope; }
+
+    scope *current_scope (void) { return m_current_scope; }
+
+    scope *require_current_scope (const std::string& who)
     {
-      scope *new_sid = new scope ();
-
-      for (const auto& nm_sr : m_symbols)
-        new_sid->insert_symbol_record (nm_sr.second.dup (new_sid));
-
-      new_sid->m_parent = m_parent;
-
-      return new_sid;
+      if (! m_current_scope)
+        error ("%s: missing scope", who.c_str ());
+
+      return m_current_scope;
     }
 
-    void set_context (context_id context) { m_context = context; }
-
-    context_id current_context (void) const { return m_context; }
-
-    symbol_table::symbol_record find_symbol (const std::string& name)
+    context_id current_context (void) const
     {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        return insert (name);
-      else
-        return p->second;
+      return m_current_scope ? m_current_scope->current_context () : 0;
+    }
+
+    void set_scope (scope *sid)
+    {
+      set_scope_and_context (sid, 0);
     }
 
-    void inherit_internal (scope& donor_scope)
+    void set_scope_and_context (scope *sid, context_id context)
+    {
+      if (sid == m_global_scope)
+        error ("can't set scope to global");
+
+      m_current_scope = sid;
+
+      if (m_current_scope)
+        m_current_scope->set_context (context);
+    }
+
+    symbol_record find_symbol (const std::string& name, scope *sid)
+    {
+      return sid ? sid->find_symbol (name) : symbol_record ();
+    }
+
+    symbol_record find_symbol (const std::string& name)
     {
-      for (auto& nm_sr : m_symbols)
-        {
-          symbol_table::symbol_record& sr = nm_sr.second;
-
-          if (! (sr.is_automatic () || sr.is_formal ()))
-            {
-              std::string nm = sr.name ();
-
-              if (nm != "__retval__")
-                {
-                  octave_value val = donor_scope.varval (nm);
-
-                  if (val.is_defined ())
-                    {
-                      sr.assign (val);
-
-                      sr.mark_inherited ();
-                    }
-                }
-            }
-        }
+      return find_symbol (name, m_current_scope);
+    }
+
+    void inherit (scope *recipient_scope, scope *donor_scope)
+    {
+      if (recipient_scope)
+        recipient_scope->inherit (donor_scope);
     }
 
-    void inherit (scope *donor_scope)
+    void inherit (scope *recipient_scope)
     {
-      while (donor_scope)
-        {
-          inherit_internal (*donor_scope);
-
-          if (donor_scope->is_nested ())
-            donor_scope = donor_scope->parent_scope ();
-          else
-            break;
-        }
+      inherit (recipient_scope, m_current_scope);
     }
 
-
+    bool at_top_level (void) { return m_current_scope == m_top_scope; }
+
+    // Find a value corresponding to the given name in the table.
     octave_value
-    find (const std::string& name, const octave_value_list& args,
-          bool skip_variables, bool local_funcs);
+      find (const std::string& name,
+            const octave_value_list& args = octave_value_list (),
+            bool skip_variables = false,
+            bool local_funcs = true);
 
     octave_value builtin_find (const std::string& name);
 
-    symbol_table::symbol_record&
-    insert (const std::string& name, bool force_add = false);
-
-    void rename (const std::string& old_name, const std::string& new_name)
-    {
-      table_iterator p = m_symbols.find (old_name);
-
-      if (p != m_symbols.end ())
-        {
-          symbol_table::symbol_record sr = p->second;
-
-          sr.rename (new_name);
-
-          m_symbols.erase (p);
-
-          m_symbols[new_name] = sr;
-        }
-    }
-
-    void assign (const std::string& name, const octave_value& value,
-                 bool force_add)
-    {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        {
-          symbol_table::symbol_record& sr = insert (name, force_add);
-
-          sr.assign (value);
-        }
-      else
-        p->second.assign (value);
-    }
-
-    void assign (const std::string& name,
-                 const octave_value& value = octave_value ())
-    {
-      assign (name, value, false);
-    }
-
-    void force_assign (const std::string& name, const octave_value& value)
+    void
+      global_assign (const std::string& name,
+                     const octave_value& value = octave_value ())
+
     {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        {
-          symbol_table::symbol_record& sr = insert (name, true);
-
-          sr.assign (value);
-        }
-      else
-        p->second.assign (value);
-    }
-
-    // Use assign (name, value, force_add) instead.
-    // Delete when deprecated varref functions are removed.
-    octave_value& varref (const std::string& name, bool force_add)
-    {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        {
-          symbol_table::symbol_record& sr = insert (name, force_add);
-
-          return sr.varref ();
-        }
-      else
-        return p->second.varref ();
-    }
-
-    octave_value varval (const std::string& name) const
-    {
-      table_const_iterator p = m_symbols.find (name);
-
-      return (p != m_symbols.end ()
-              ? p->second.varval () : octave_value ());
-    }
-
-    void persistent_assign (const std::string& name, const octave_value& value)
-    {
-      m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
-
-      if (p == m_persistent_symbols.end ())
-        m_persistent_symbols[name] = value;
+      global_symbols_iterator p = m_global_symbols.find (name);
+
+      if (p == m_global_symbols.end ())
+        m_global_symbols[name] = value;
       else
         p->second = value;
     }
 
-    // Use persistent_assign (name, value) instead.
-    // Delete when deprecated varref functions are removed.
-    octave_value& persistent_varref (const std::string& name)
+    octave_value
+      global_varval (const std::string& name)
+    {
+      global_symbols_const_iterator p = m_global_symbols.find (name);
+
+      return (p != m_global_symbols.end ()) ? p->second : octave_value ();
+    }
+
+    void
+      top_level_assign (const std::string& name,
+                        const octave_value& value = octave_value ())
+    {
+      m_top_scope->assign (name, value);
+    }
+
+    octave_value
+      top_level_varval (const std::string& name)
+    {
+      return m_top_scope->varval (name);
+    }
+
+    bool
+      is_built_in_function_name (const std::string& name)
+    {
+      octave_value val = find_built_in_function (name);
+
+      return val.is_defined ();
+    }
+
+    octave_value
+      find_method (const std::string& name, const std::string& dispatch_type)
+    {
+      fcn_table_const_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          octave_value fcn = p->second.find_method (dispatch_type);
+
+          if (! fcn.is_defined ())
+            fcn = find_submethod (name, dispatch_type);
+
+          return fcn;
+        }
+      else
+        {
+          fcn_info finfo (name);
+
+          octave_value fcn = finfo.find_method (dispatch_type);
+
+          if (! fcn.is_defined ())
+            fcn = find_submethod (name, dispatch_type);
+
+          if (fcn.is_defined ())
+            m_fcn_table[name] = finfo;
+
+          return fcn;
+        }
+    }
+
+    octave_value
+      find_submethod (const std::string& name, const std::string& dispatch_type);
+
+    octave_value
+      find_built_in_function (const std::string& name)
+    {
+      fcn_table_const_iterator p = m_fcn_table.find (name);
+
+      return (p != m_fcn_table.end ()
+              ? p->second.find_built_in_function () : octave_value ());
+    }
+
+    octave_value
+      find_autoload (const std::string& name)
     {
-      m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
-
-      return (p == m_persistent_symbols.end ()
-              ? m_persistent_symbols[name] : p->second);
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      return (p != m_fcn_table.end ()
+              ? p->second.find_autoload () : octave_value ());
+    }
+
+    octave_value
+      find_function (const std::string& name,
+                     const octave_value_list& args = octave_value_list (),
+                     bool local_funcs = true);
+
+    octave_value find_user_function (const std::string& name)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      return (p != m_fcn_table.end ()
+              ? p->second.find_user_function () : octave_value ());
+    }
+
+    octave_value find_cmdline_function (const std::string& name)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      return (p != m_fcn_table.end ()
+              ? p->second.find_cmdline_function () : octave_value ());
     }
 
-    octave_value persistent_varval (const std::string& name)
+    void install_cmdline_function (const std::string& name,
+                                   const octave_value& fcn)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          fcn_info& finfo = p->second;
+
+          finfo.install_cmdline_function (fcn);
+        }
+      else
+        {
+          fcn_info finfo (name);
+
+          finfo.install_cmdline_function (fcn);
+
+          m_fcn_table[name] = finfo;
+        }
+    }
+
+    // Install local function FCN named NAME.  FILE_NAME is the name of
+    // the file containing the local function.
+
+    void install_local_function (const std::string& name,
+                                 const octave_value& fcn,
+                                 const std::string& file_name)
     {
-      m_persistent_symbols_const_iterator p = m_persistent_symbols.find (name);
-
-      return (p != m_persistent_symbols.end ()) ? p->second : octave_value ();
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          fcn_info& finfo = p->second;
+
+          finfo.install_local_function (fcn, file_name);
+        }
+      else
+        {
+          fcn_info finfo (name);
+
+          finfo.install_local_function (fcn, file_name);
+
+          m_fcn_table[name] = finfo;
+        }
+    }
+
+    void install_user_function (const std::string& name,
+                                const octave_value& fcn)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          fcn_info& finfo = p->second;
+
+          finfo.install_user_function (fcn);
+        }
+      else
+        {
+          fcn_info finfo (name);
+
+          finfo.install_user_function (fcn);
+
+          m_fcn_table[name] = finfo;
+        }
     }
 
-    void erase_persistent (const std::string& name)
+    void install_built_in_function (const std::string& name,
+                                    const octave_value& fcn)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          fcn_info& finfo = p->second;
+
+          finfo.install_built_in_function (fcn);
+        }
+      else
+        {
+          fcn_info finfo (name);
+
+          finfo.install_built_in_function (fcn);
+
+          m_fcn_table[name] = finfo;
+        }
+    }
+
+    void clear_all (bool force = false)
+    {
+      if (m_current_scope)
+        {
+          m_current_scope->clear_variables ();
+          m_current_scope->clear_global_pattern ("*");
+        }
+
+      clear_functions (force);
+    }
+
+    // This is written as two separate functions instead of a single
+    // function with default values so that it will work properly with
+    // unwind_protect.
+
+    void clear_functions (bool force = false)
+    {
+      fcn_table_iterator p = m_fcn_table.begin ();
+
+      while (p != m_fcn_table.end ())
+        (p++)->second.clear (force);
+    }
+
+    void clear_function (const std::string& name)
+    {
+      clear_user_function (name);
+    }
+
+    void clear_symbol (const std::string& name)
     {
-      m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
-
-      if (p != m_persistent_symbols.end ())
-        m_persistent_symbols.erase (p);
+      // FIXME: are we supposed to do both here?
+
+      if (m_current_scope)
+        m_current_scope->clear_variable (name);
+
+      clear_function (name);
+    }
+
+    void clear_function_pattern (const std::string& pat)
+    {
+      glob_match pattern (pat);
+
+      fcn_table_iterator p = m_fcn_table.begin ();
+
+      while (p != m_fcn_table.end ())
+        {
+          if (pattern.match (p->first))
+            (p++)->second.clear_user_function ();
+          else
+            p++;
+        }
     }
 
-    bool is_variable (const std::string& name) const
+    void clear_symbol_pattern (const std::string& pat)
+    {
+      // FIXME: are we supposed to do both here?
+
+      if (m_current_scope)
+        m_current_scope->clear_variable_pattern (pat);
+
+      clear_function_pattern (pat);
+    }
+
+    void clear_user_function (const std::string& name)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          fcn_info& finfo = p->second;
+
+          finfo.clear_user_function ();
+        }
+      // FIXME: is this necessary, or even useful?
+      // else
+      //   error ("clear: no such function '%s'", name.c_str ());
+    }
+
+    // This clears oct and mex files, including autoloads.
+    void clear_dld_function (const std::string& name)
     {
-      bool retval = false;
-
-      table_const_iterator p = m_symbols.find (name);
-
-      if (p != m_symbols.end ())
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
+        {
+          fcn_info& finfo = p->second;
+
+          finfo.clear_autoload_function ();
+          finfo.clear_user_function ();
+        }
+    }
+
+    void clear_mex_functions (void)
+    {
+      fcn_table_iterator p = m_fcn_table.begin ();
+
+      while (p != m_fcn_table.end ())
+        (p++)->second.clear_mex_function ();
+    }
+
+    bool set_class_relationship (const std::string& sup_class,
+                                 const std::string& inf_class);
+
+    bool is_superiorto (const std::string& a, const std::string& b);
+
+    void alias_built_in_function (const std::string& alias,
+                                  const std::string& name)
+    {
+      octave_value fcn = find_built_in_function (name);
+
+      if (fcn.is_defined ())
+        {
+          fcn_info finfo (alias);
+
+          finfo.install_built_in_function (fcn);
+
+          m_fcn_table[alias] = finfo;
+        }
+      else
+        panic ("alias: '%s' is undefined", name.c_str ());
+    }
+
+    void install_built_in_dispatch (const std::string& name,
+                                    const std::string& klass)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+
+      if (p != m_fcn_table.end ())
         {
-          const symbol_table::symbol_record& sr = p->second;
-
-          retval = sr.is_variable ();
+          fcn_info& finfo = p->second;
+
+          finfo.install_built_in_dispatch (klass);
+        }
+      else
+        error ("install_built_in_dispatch: '%s' is undefined", name.c_str ());
+    }
+
+    void push_context (void)
+    {
+      if (m_current_scope == m_top_scope)
+        error ("invalid call to symtab::push_context");
+
+      if (m_current_scope)
+        m_current_scope->push_context ();
+    }
+
+    // This is written as two separate functions instead of a single
+    // function with default values so that it will work properly with
+    // unwind_protect.
+
+    void pop_context (void)
+    {
+      if (m_current_scope == m_top_scope)
+        error ("invalid call to symtab::pop_context");
+
+      if (m_current_scope)
+        m_current_scope->pop_context ();
+    }
+
+    // For unwind_protect where a pointer argument is needed.
+
+    void pop_context (void *) { pop_context (); }
+
+    std::list<symbol_record> glob (const std::string& pattern)
+    {
+      return (m_current_scope
+              ? m_current_scope->glob (pattern) : std::list<symbol_record> ());
+    }
+
+    std::list<symbol_record>
+      glob_global_variables (const std::string& pattern)
+    {
+      std::list<symbol_record> retval;
+
+      glob_match pat (pattern);
+
+      for (const auto& nm_val : m_global_symbols)
+        {
+          // We generate a list of symbol_record objects so that the results from
+          // glob_variables and glob_global_variables may be handled the same
+          // way.
+          if (pat.match (nm_val.first))
+            retval.push_back (symbol_record (m_global_scope,
+                                             nm_val.first, nm_val.second,
+                                             symbol_record::global));
         }
 
       return retval;
     }
 
-    void push_context (void)
-    {
-      for (auto& nm_sr : m_symbols)
-        nm_sr.second.push_context (this);
-    }
-
-    void pop_context (void)
-    {
-      table_iterator tbl_it = m_symbols.begin ();
-
-      while (tbl_it != m_symbols.end ())
-        {
-          if (tbl_it->second.pop_context (this) == 0)
-            m_symbols.erase (tbl_it++);
-          else
-            tbl_it++;
-        }
-    }
-
-    void clear_variables (void)
-    {
-      for (auto& nm_sr : m_symbols)
-        nm_sr.second.clear (this);
-    }
-
-    void clear_objects (void)
+    std::list<symbol_record>
+      regexp_global_variables (const std::string& pattern)
     {
-      for (auto& nm_sr : m_symbols)
-        {
-          symbol_table::symbol_record& sr = nm_sr.second;
-          octave_value val = sr.varval ();
-          if (val.isobject ())
-            nm_sr.second.clear (this);
-        }
-    }
-
-    void clear_global (const std::string& name);
-
-    void clear_variable (const std::string& name)
-    {
-      table_iterator p = m_symbols.find (name);
-
-      if (p != m_symbols.end ())
-        p->second.clear (this);
-    }
-
-    void clear_global_pattern (const std::string& pat);
-
-    void clear_variable_pattern (const std::string& pat)
-    {
-      glob_match pattern (pat);
-
-      for (auto& nm_sr : m_symbols)
+      std::list<symbol_record> retval;
+
+      octave::regexp pat (pattern);
+
+      for (const auto& nm_val : m_global_symbols)
         {
-          symbol_table::symbol_record& sr = nm_sr.second;
-
-          if (sr.is_defined () || sr.is_global ())
-            {
-              if (pattern.match (sr.name ()))
-                sr.clear (this);
-            }
+          // We generate a list of symbol_record objects so that the results from
+          // regexp_variables and regexp_global_variables may be handled the same
+          // way.
+          if (pat.is_match (nm_val.first))
+            retval.push_back (symbol_record (m_global_scope,
+                                             nm_val.first, nm_val.second,
+                                             symbol_record::global));
         }
+
+      return retval;
     }
 
-    void clear_variable_regexp (const std::string& pat)
-    {
-      octave::regexp pattern (pat);
-
-      for (auto& nm_sr : m_symbols)
-        {
-          symbol_table::symbol_record& sr = nm_sr.second;
-
-          if (sr.is_defined () || sr.is_global ())
-            {
-              if (pattern.is_match (sr.name ()))
-                sr.clear (this);
-            }
-        }
-    }
-
-    void mark_automatic (const std::string& name)
+    std::list<symbol_record> glob_variables (const string_vector& patterns)
     {
-      insert (name).mark_automatic ();
-    }
-
-    void mark_hidden (const std::string& name)
-    {
-      insert (name).mark_hidden ();
-    }
-
-    void mark_global (const std::string& name)
-    {
-      insert (name).mark_global ();
-    }
-
-    std::list<symbol_table::symbol_record>
-    all_variables (bool defined_only = true,
-                   unsigned int exclude = symbol_table::symbol_record::hidden) const
-    {
-      std::list<symbol_table::symbol_record> retval;
-
-      for (const auto& nm_sr : m_symbols)
+      std::list<symbol_record> retval;
+
+      if (! m_current_scope)
+        return retval;
+
+      size_t len = patterns.numel ();
+
+      for (size_t i = 0; i < len; i++)
         {
-          const symbol_table::symbol_record& sr = nm_sr.second;
-
-          if ((defined_only && ! sr.is_defined ())
-              || (sr.xstorage_class () & exclude))
-            continue;
-
-          retval.push_back (sr);
+          std::list<symbol_record> tmp = m_current_scope->glob (patterns[i]);
+
+          retval.insert (retval.begin (), tmp.begin (), tmp.end ());
         }
 
       return retval;
     }
 
-    std::list<symbol_table::symbol_record>
-    glob (const std::string& pattern, bool vars_only = false) const
+    std::list<symbol_record> regexp_variables (const string_vector& patterns)
     {
-      std::list<symbol_table::symbol_record> retval;
-
-      glob_match pat (pattern);
-
-      for (const auto& nm_sr : m_symbols)
+      std::list<symbol_record> retval;
+
+      if (! m_current_scope)
+        return retval;
+
+      size_t len = patterns.numel ();
+
+      for (size_t i = 0; i < len; i++)
         {
-          if (pat.match (nm_sr.first))
-            {
-              const symbol_table::symbol_record& sr = nm_sr.second;
-
-              if (vars_only && ! sr.is_variable ())
-                continue;
-
-              retval.push_back (sr);
-            }
+          std::list<symbol_record> tmp = m_current_scope->regexp (patterns[i]);
+
+          retval.insert (retval.begin (), tmp.begin (), tmp.end ());
         }
 
       return retval;
     }
 
-    std::list<symbol_table::symbol_record>
-    regexp (const std::string& pattern, bool vars_only = false) const
+    std::list<std::string> user_function_names (void)
     {
-      std::list<symbol_table::symbol_record> retval;
-
-      octave::regexp pat (pattern);
-
-      for (const auto& nm_sr : m_symbols)
+      std::list<std::string> retval;
+
+      for (const auto& nm_finfo : m_fcn_table)
         {
-          if (pat.is_match (nm_sr.first))
-            {
-              const symbol_table::symbol_record& sr = nm_sr.second;
-
-              if (vars_only && ! sr.is_variable ())
-                continue;
-
-              retval.push_back (sr);
-            }
+          if (nm_finfo.second.is_user_function_defined ())
+            retval.push_back (nm_finfo.first);
         }
 
+      if (! retval.empty ())
+        retval.sort ();
+
       return retval;
     }
 
-    std::list<std::string> variable_names (void)
+    std::list<std::string> global_variable_names (void)
     {
       std::list<std::string> retval;
 
-      for (const auto& nm_sr : m_symbols)
-        {
-          if (nm_sr.second.is_variable ())
-            retval.push_back (nm_sr.first);
-        }
+      for (const auto& nm_val : m_global_symbols)
+        retval.push_back (nm_val.first);
 
       retval.sort ();
 
       return retval;
     }
 
-    bool is_local_variable (const std::string& name) const
-    {
-      table_const_iterator p = m_symbols.find (name);
-
-      return (p != m_symbols.end ()
-              && ! p->second.is_global ()
-              && p->second.is_defined ());
-    }
-
-    bool is_global (const std::string& name) const
+    std::list<std::string> top_level_variable_names (void)
     {
-      table_const_iterator p = m_symbols.find (name);
-
-      return p != m_symbols.end () && p->second.is_global ();
+      return (m_top_scope
+              ? m_top_scope->variable_names () : std::list<std::string> ());
     }
 
-    void install_subfunction (const std::string& name,
-                              const octave_value& fval,
-                              bool is_nested = false);
-
-    void install_nestfunction (const std::string& name,
-                               const octave_value& fval)
+    std::list<std::string> variable_names (void)
     {
-      install_subfunction (name, fval, true);
+      return (m_current_scope
+              ? m_current_scope->variable_names () : std::list<std::string> ());
     }
 
-    octave_value find_subfunction (const std::string& name) const;
-
-    void lock_subfunctions (void)
+    std::list<std::string> built_in_function_names (void)
     {
-      for (auto& nm_sf : m_subfunctions)
-        nm_sf.second.lock ();
-    }
-
-    void unlock_subfunctions (void)
-    {
-      for (auto& nm_sf : m_subfunctions)
-        nm_sf.second.unlock ();
+      std::list<std::string> retval;
+
+      for (const auto& nm_finfo : m_fcn_table)
+        {
+          octave_value fcn = nm_finfo.second.find_built_in_function ();
+
+          if (fcn.is_defined ())
+            retval.push_back (nm_finfo.first);
+        }
+
+      if (! retval.empty ())
+        retval.sort ();
+
+      return retval;
     }
 
-    std::map<std::string, octave_value> subfunctions (void)
-    {
-      return m_subfunctions;
-    }
-
-    void erase_subfunctions (void)
+    std::list<std::string> cmdline_function_names (void)
     {
-      m_subfunctions.clear ();
+      std::list<std::string> retval;
+
+      for (const auto& nm_finfo : m_fcn_table)
+        {
+          octave_value fcn = nm_finfo.second.find_cmdline_function ();
+
+          if (fcn.is_defined ())
+            retval.push_back (nm_finfo.first);
+        }
+
+      if (! retval.empty ())
+        retval.sort ();
+
+      return retval;
     }
 
-    void mark_subfunctions_in_scope_as_private (const std::string& class_name);
-
-    std::list<workspace_element> workspace_info (void) const;
-
     octave_value dump (void) const;
 
-    std::string name (void) const { return m_name; }
-
-    void cache_name (const std::string& name) { m_name = name; }
-
-    octave_user_function *function (void) { return m_fcn; }
-
-    void set_function (octave_user_function *fcn) { m_fcn = fcn; }
-
-    void set_parent (scope *p) { m_parent = p; }
-
-    void update_nest (void);
-
-    bool look_nonlocal (const std::string& name,
-                        symbol_table::symbol_record& result);
+    void add_to_parent_map (const std::string& classname,
+                            const std::list<std::string>& parent_list)
+    {
+      m_parent_map[classname] = parent_list;
+    }
+
+    std::list<std::string>
+      parent_classes (const std::string& dispatch_type)
+    {
+      std::list<std::string> retval;
+
+      const_parent_map_iterator it = m_parent_map.find (dispatch_type);
+
+      if (it != m_parent_map.end ())
+        retval = it->second;
+
+      for (const auto& nm : retval)
+        {
+          // Search for parents of parents and append them to the list.
+
+          // FIXME: should we worry about a circular inheritance graph?
+
+          std::list<std::string> parents = parent_classes (nm);
+
+          if (! parents.empty ())
+            retval.insert (retval.end (), parents.begin (), parents.end ());
+        }
+
+      return retval;
+    }
+
+    octave_user_function * get_curr_fcn (void)
+    {
+      return m_current_scope ? m_current_scope->function () : 0;
+    }
+
+    void cleanup (void);
+
+    fcn_info * get_fcn_info (const std::string& name)
+    {
+      fcn_table_iterator p = m_fcn_table.find (name);
+      return p != m_fcn_table.end () ? &p->second : 0;
+    }
+
+    class scope
+    {
+    public:
+
+      typedef std::map<std::string, symbol_table::symbol_record>::const_iterator
+      table_const_iterator;
+      typedef std::map<std::string, symbol_table::symbol_record>::iterator
+      table_iterator;
+
+      typedef std::map<std::string, octave_value>::const_iterator
+      m_persistent_symbols_const_iterator;
+      typedef std::map<std::string, octave_value>::iterator
+      m_persistent_symbols_iterator;
+
+      typedef std::map<std::string, octave_value>::const_iterator
+      subfunctions_const_iterator;
+      typedef std::map<std::string, octave_value>::iterator subfunctions_iterator;
+
+      scope (const std::string& name = "")
+        : m_name (name), m_symbols (), m_persistent_symbols (), m_subfunctions (),
+          m_fcn (0), m_parent (0), m_children (), m_is_nested (false),
+          m_is_static (false), m_context (0)
+      { }
+
+      // No copying!
+
+      scope (const scope&) = delete;
+
+      scope& operator = (const scope&) = delete;
+
+      ~scope (void) = default;
+
+      void insert_symbol_record (const symbol_table::symbol_record& sr)
+      {
+        m_symbols[sr.name ()] = sr;
+      }
+
+      bool is_nested (void) const { return m_is_nested; }
+
+      void mark_nested (void) { m_is_nested = true; }
+
+      scope * parent_scope (void) const { return m_parent; }
+
+      scope * dup (void) const
+      {
+        scope *new_sid = new scope ();
+
+        for (const auto& nm_sr : m_symbols)
+          new_sid->insert_symbol_record (nm_sr.second.dup (new_sid));
+
+        new_sid->m_parent = m_parent;
+
+        return new_sid;
+      }
+
+      void set_context (context_id context) { m_context = context; }
+
+      context_id current_context (void) const { return m_context; }
+
+      symbol_table::symbol_record find_symbol (const std::string& name)
+      {
+        table_iterator p = m_symbols.find (name);
+
+        if (p == m_symbols.end ())
+          return insert (name);
+        else
+          return p->second;
+      }
+
+      void inherit_internal (scope& donor_scope)
+      {
+        for (auto& nm_sr : m_symbols)
+          {
+            symbol_table::symbol_record& sr = nm_sr.second;
+
+            if (! (sr.is_automatic () || sr.is_formal ()))
+              {
+                std::string nm = sr.name ();
+
+                if (nm != "__retval__")
+                  {
+                    octave_value val = donor_scope.varval (nm);
+
+                    if (val.is_defined ())
+                      {
+                        sr.assign (val);
+
+                        sr.mark_inherited ();
+                      }
+                  }
+              }
+          }
+      }
+
+      void inherit (scope *donor_scope)
+      {
+        while (donor_scope)
+          {
+            inherit_internal (*donor_scope);
+
+            if (donor_scope->is_nested ())
+              donor_scope = donor_scope->parent_scope ();
+            else
+              break;
+          }
+      }
+
+
+      octave_value
+      find (const std::string& name, const octave_value_list& args,
+            bool skip_variables, bool local_funcs);
+
+      octave_value builtin_find (const std::string& name);
+
+      symbol_table::symbol_record&
+      insert (const std::string& name, bool force_add = false);
+
+      void rename (const std::string& old_name, const std::string& new_name)
+      {
+        table_iterator p = m_symbols.find (old_name);
+
+        if (p != m_symbols.end ())
+          {
+            symbol_table::symbol_record sr = p->second;
+
+            sr.rename (new_name);
+
+            m_symbols.erase (p);
+
+            m_symbols[new_name] = sr;
+          }
+      }
+
+      void assign (const std::string& name, const octave_value& value,
+                   bool force_add)
+      {
+        table_iterator p = m_symbols.find (name);
+
+        if (p == m_symbols.end ())
+          {
+            symbol_table::symbol_record& sr = insert (name, force_add);
+
+            sr.assign (value);
+          }
+        else
+          p->second.assign (value);
+      }
+
+      void assign (const std::string& name,
+                   const octave_value& value = octave_value ())
+      {
+        assign (name, value, false);
+      }
+
+      void force_assign (const std::string& name, const octave_value& value)
+      {
+        table_iterator p = m_symbols.find (name);
+
+        if (p == m_symbols.end ())
+          {
+            symbol_table::symbol_record& sr = insert (name, true);
+
+            sr.assign (value);
+          }
+        else
+          p->second.assign (value);
+      }
+
+      // Use assign (name, value, force_add) instead.
+      // Delete when deprecated varref functions are removed.
+      octave_value& varref (const std::string& name, bool force_add)
+      {
+        table_iterator p = m_symbols.find (name);
+
+        if (p == m_symbols.end ())
+          {
+            symbol_table::symbol_record& sr = insert (name, force_add);
+
+            return sr.varref ();
+          }
+        else
+          return p->second.varref ();
+      }
+
+      octave_value varval (const std::string& name) const
+      {
+        table_const_iterator p = m_symbols.find (name);
+
+        return (p != m_symbols.end ()
+                ? p->second.varval () : octave_value ());
+      }
+
+      void persistent_assign (const std::string& name, const octave_value& value)
+      {
+        m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
+
+        if (p == m_persistent_symbols.end ())
+          m_persistent_symbols[name] = value;
+        else
+          p->second = value;
+      }
+
+      // Use persistent_assign (name, value) instead.
+      // Delete when deprecated varref functions are removed.
+      octave_value& persistent_varref (const std::string& name)
+      {
+        m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
+
+        return (p == m_persistent_symbols.end ()
+                ? m_persistent_symbols[name] : p->second);
+      }
+
+      octave_value persistent_varval (const std::string& name)
+      {
+        m_persistent_symbols_const_iterator p = m_persistent_symbols.find (name);
+
+        return (p != m_persistent_symbols.end ()) ? p->second : octave_value ();
+      }
+
+      void erase_persistent (const std::string& name)
+      {
+        m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
+
+        if (p != m_persistent_symbols.end ())
+          m_persistent_symbols.erase (p);
+      }
+
+      bool is_variable (const std::string& name) const
+      {
+        bool retval = false;
+
+        table_const_iterator p = m_symbols.find (name);
+
+        if (p != m_symbols.end ())
+          {
+            const symbol_table::symbol_record& sr = p->second;
+
+            retval = sr.is_variable ();
+          }
+
+        return retval;
+      }
+
+      void push_context (void)
+      {
+        for (auto& nm_sr : m_symbols)
+          nm_sr.second.push_context (this);
+      }
+
+      void pop_context (void)
+      {
+        table_iterator tbl_it = m_symbols.begin ();
+
+        while (tbl_it != m_symbols.end ())
+          {
+            if (tbl_it->second.pop_context (this) == 0)
+              m_symbols.erase (tbl_it++);
+            else
+              tbl_it++;
+          }
+      }
+
+      void clear_variables (void)
+      {
+        for (auto& nm_sr : m_symbols)
+          nm_sr.second.clear (this);
+      }
+
+      void clear_objects (void)
+      {
+        for (auto& nm_sr : m_symbols)
+          {
+            symbol_table::symbol_record& sr = nm_sr.second;
+            octave_value val = sr.varval ();
+            if (val.isobject ())
+              nm_sr.second.clear (this);
+          }
+      }
+
+      void clear_global (const std::string& name);
+
+      void clear_variable (const std::string& name)
+      {
+        table_iterator p = m_symbols.find (name);
+
+        if (p != m_symbols.end ())
+          p->second.clear (this);
+      }
+
+      void clear_global_pattern (const std::string& pat);
+
+      void clear_variable_pattern (const std::string& pat)
+      {
+        glob_match pattern (pat);
+
+        for (auto& nm_sr : m_symbols)
+          {
+            symbol_table::symbol_record& sr = nm_sr.second;
+
+            if (sr.is_defined () || sr.is_global ())
+              {
+                if (pattern.match (sr.name ()))
+                  sr.clear (this);
+              }
+          }
+      }
+
+      void clear_variable_regexp (const std::string& pat)
+      {
+        octave::regexp pattern (pat);
+
+        for (auto& nm_sr : m_symbols)
+          {
+            symbol_table::symbol_record& sr = nm_sr.second;
+
+            if (sr.is_defined () || sr.is_global ())
+              {
+                if (pattern.is_match (sr.name ()))
+                  sr.clear (this);
+              }
+          }
+      }
+
+      void mark_automatic (const std::string& name)
+      {
+        insert (name).mark_automatic ();
+      }
+
+      void mark_hidden (const std::string& name)
+      {
+        insert (name).mark_hidden ();
+      }
+
+      void mark_global (const std::string& name)
+      {
+        insert (name).mark_global ();
+      }
+
+      std::list<symbol_table::symbol_record>
+      all_variables (bool defined_only = true,
+                     unsigned int exclude = symbol_table::symbol_record::hidden) const
+      {
+        std::list<symbol_table::symbol_record> retval;
+
+        for (const auto& nm_sr : m_symbols)
+          {
+            const symbol_table::symbol_record& sr = nm_sr.second;
+
+            if ((defined_only && ! sr.is_defined ())
+                || (sr.xstorage_class () & exclude))
+              continue;
+
+            retval.push_back (sr);
+          }
+
+        return retval;
+      }
+
+      std::list<symbol_table::symbol_record>
+      glob (const std::string& pattern, bool vars_only = false) const
+      {
+        std::list<symbol_table::symbol_record> retval;
+
+        glob_match pat (pattern);
+
+        for (const auto& nm_sr : m_symbols)
+          {
+            if (pat.match (nm_sr.first))
+              {
+                const symbol_table::symbol_record& sr = nm_sr.second;
+
+                if (vars_only && ! sr.is_variable ())
+                  continue;
+
+                retval.push_back (sr);
+              }
+          }
+
+        return retval;
+      }
+
+      std::list<symbol_table::symbol_record>
+      regexp (const std::string& pattern, bool vars_only = false) const
+      {
+        std::list<symbol_table::symbol_record> retval;
+
+        octave::regexp pat (pattern);
+
+        for (const auto& nm_sr : m_symbols)
+          {
+            if (pat.is_match (nm_sr.first))
+              {
+                const symbol_table::symbol_record& sr = nm_sr.second;
+
+                if (vars_only && ! sr.is_variable ())
+                  continue;
+
+                retval.push_back (sr);
+              }
+          }
+
+        return retval;
+      }
+
+      std::list<std::string> variable_names (void)
+      {
+        std::list<std::string> retval;
+
+        for (const auto& nm_sr : m_symbols)
+          {
+            if (nm_sr.second.is_variable ())
+              retval.push_back (nm_sr.first);
+          }
+
+        retval.sort ();
+
+        return retval;
+      }
+
+      bool is_local_variable (const std::string& name) const
+      {
+        table_const_iterator p = m_symbols.find (name);
+
+        return (p != m_symbols.end ()
+                && ! p->second.is_global ()
+                && p->second.is_defined ());
+      }
+
+      bool is_global (const std::string& name) const
+      {
+        table_const_iterator p = m_symbols.find (name);
+
+        return p != m_symbols.end () && p->second.is_global ();
+      }
+
+      void install_subfunction (const std::string& name,
+                                const octave_value& fval,
+                                bool is_nested = false);
+
+      void install_nestfunction (const std::string& name,
+                                 const octave_value& fval)
+      {
+        install_subfunction (name, fval, true);
+      }
+
+      octave_value find_subfunction (const std::string& name) const;
+
+      void lock_subfunctions (void)
+      {
+        for (auto& nm_sf : m_subfunctions)
+          nm_sf.second.lock ();
+      }
+
+      void unlock_subfunctions (void)
+      {
+        for (auto& nm_sf : m_subfunctions)
+          nm_sf.second.unlock ();
+      }
+
+      std::map<std::string, octave_value> subfunctions (void)
+      {
+        return m_subfunctions;
+      }
+
+      void erase_subfunctions (void)
+      {
+        m_subfunctions.clear ();
+      }
+
+      void mark_subfunctions_in_scope_as_private (const std::string& class_name);
+
+      std::list<workspace_element> workspace_info (void) const;
+
+      octave_value dump (void) const;
+
+      std::string name (void) const { return m_name; }
+
+      void cache_name (const std::string& name) { m_name = name; }
+
+      octave_user_function *function (void) { return m_fcn; }
+
+      void set_function (octave_user_function *fcn) { m_fcn = fcn; }
+
+      void set_parent (scope *p) { m_parent = p; }
+
+      void update_nest (void);
+
+      bool look_nonlocal (const std::string& name,
+                          symbol_table::symbol_record& result);
+
+    private:
+
+      // Name for this scope (usually the corresponding filename of the
+      // function corresponding to the scope).
+      std::string m_name;
+
+      // Map from symbol names to symbol info.
+      std::map<std::string, symbol_table::symbol_record> m_symbols;
+
+      // Map from names of persistent variables to values.
+      std::map<std::string, octave_value> m_persistent_symbols;
+
+      // Map from symbol names to subfunctions.
+      std::map<std::string, octave_value> m_subfunctions;
+
+      // The associated user code (may be null).
+      octave_user_function *m_fcn;
+
+      // Parent of nested function (may be null).
+      scope *m_parent;
+
+      // Child nested functions.
+      std::vector<scope*> m_children;
+
+      // If true, then this scope belongs to a nested function.
+      bool m_is_nested;
+
+      // If true then no variables can be added.
+      bool m_is_static;
+
+      context_id m_context;
+
+      octave_value dump_symbols_map (void) const;
+    };
 
   private:
 
-    // Name for this scope (usually the corresponding filename of the
-    // function corresponding to the scope).
-    std::string m_name;
-
-    // Map from symbol names to symbol info.
-    std::map<std::string, symbol_table::symbol_record> m_symbols;
-
-    // Map from names of persistent variables to values.
-    std::map<std::string, octave_value> m_persistent_symbols;
-
-    // Map from symbol names to subfunctions.
-    std::map<std::string, octave_value> m_subfunctions;
-
-    // The associated user code (may be null).
-    octave_user_function *m_fcn;
-
-    // Parent of nested function (may be null).
-    scope *m_parent;
-
-    // Child nested functions.
-    std::vector<scope*> m_children;
-
-    // If true, then this scope belongs to a nested function.
-    bool m_is_nested;
-
-    // If true then no variables can be added.
-    bool m_is_static;
-
-    context_id m_context;
-
-    octave_value dump_symbols_map (void) const;
+    typedef std::map<std::string, octave_value>::const_iterator
+      global_symbols_const_iterator;
+    typedef std::map<std::string, octave_value>::iterator
+      global_symbols_iterator;
+
+    typedef std::map<std::string, fcn_info>::const_iterator
+      fcn_table_const_iterator;
+    typedef std::map<std::string, fcn_info>::iterator
+      fcn_table_iterator;
+
+    // Map from names of global variables to values.
+    std::map<std::string, octave_value> m_global_symbols;
+
+    // Map from function names to function info (private
+    // functions, class constructors, class methods, etc.)
+    // Note that subfunctions are defined in the scope that contains
+    // them.
+    std::map<std::string, fcn_info> m_fcn_table;
+
+    // Map from class names to set of classes that have lower
+    // precedence.
+    std::map<std::string, std::set<std::string>> m_class_precedence_table;
+
+    typedef std::map<std::string, std::set<std::string>>::const_iterator
+      class_precedence_table_const_iterator;
+    typedef std::map<std::string, std::set<std::string>>::iterator
+      class_precedence_table_iterator;
+
+    // Map from class names to parent class names.
+    std::map<std::string, std::list<std::string>> m_parent_map;
+
+    typedef std::map<std::string, std::list<std::string>>::const_iterator
+      const_parent_map_iterator;
+    typedef std::map<std::string, std::list<std::string>>::iterator
+      parent_map_iterator;
+
+    scope *m_global_scope;
+    scope *m_top_scope;
+
+    scope *m_current_scope;
+
+    octave_value dump_fcn_table_map (void) const;
   };
 
-private:
-
-  typedef std::map<std::string, octave_value>::const_iterator
-    global_symbols_const_iterator;
-  typedef std::map<std::string, octave_value>::iterator
-    global_symbols_iterator;
-
-  typedef std::map<std::string, fcn_info>::const_iterator
-    fcn_table_const_iterator;
-  typedef std::map<std::string, fcn_info>::iterator
-    fcn_table_iterator;
-
-  // Map from names of global variables to values.
-  std::map<std::string, octave_value> m_global_symbols;
-
-  // Map from function names to function info (private
-  // functions, class constructors, class methods, etc.)
-  // Note that subfunctions are defined in the scope that contains
-  // them.
-  std::map<std::string, fcn_info> m_fcn_table;
-
-  // Map from class names to set of classes that have lower
-  // precedence.
-  std::map<std::string, std::set<std::string>> m_class_precedence_table;
-
-  typedef std::map<std::string, std::set<std::string>>::const_iterator
-    class_precedence_table_const_iterator;
-  typedef std::map<std::string, std::set<std::string>>::iterator
-    class_precedence_table_iterator;
-
-  // Map from class names to parent class names.
-  std::map<std::string, std::list<std::string>> m_parent_map;
-
-  typedef std::map<std::string, std::list<std::string>>::const_iterator
-    const_parent_map_iterator;
-  typedef std::map<std::string, std::list<std::string>>::iterator
-    parent_map_iterator;
-
-  scope *m_global_scope;
-  scope *m_top_scope;
-
-  scope *m_current_scope;
-
-  octave_value dump_fcn_table_map (void) const;
-};
-
-extern bool out_of_date_check (octave_value& function,
-                               const std::string& dispatch_type = "",
-                               bool check_relative = true);
-
-extern OCTINTERP_API std::string
-get_dispatch_type (const octave_value_list& args);
-
-extern OCTINTERP_API std::string
-get_dispatch_type (const octave_value_list& args, builtin_type_t& builtin_type);
+  extern bool out_of_date_check (octave_value& function,
+                                 const std::string& dispatch_type = "",
+                                 bool check_relative = true);
+
+  extern OCTINTERP_API std::string
+  get_dispatch_type (const octave_value_list& args);
+
+  extern OCTINTERP_API std::string
+  get_dispatch_type (const octave_value_list& args,
+                     builtin_type_t& builtin_type);
+}
 
 #endif
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -473,17 +473,17 @@ process.  If that fails, you should prob
 The call to @code{fork} failed for some reason.  You must take evasive
 action.  A system dependent error message will be waiting in @var{msg}.
 @end table
 @end deftypefn */)
 {
   if (args.length () != 0)
     print_usage ();
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (symtab.at_top_level ())
     error ("fork: cannot be called from command line");
 
   std::string msg;
 
   pid_t pid = octave::sys::fork (msg);
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -68,60 +68,60 @@ along with Octave; see the file COPYING.
 
 // Defines layout for the whos/who -long command
 static std::string Vwhos_line_format
   = "  %a:4; %ln:6; %cs:16:6:1;  %rb:12;  %lc:-1;\n";
 
 void
 clear_mex_functions (void)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("clear_mex_functions");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_mex_functions");
 
   symtab.clear_mex_functions ();
 }
 
 void
 clear_function (const std::string& nm)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
 
   symtab.clear_function (nm);
 }
 
 void
 clear_variable (const std::string& nm)
 {
-  symbol_table::scope *scope
+  octave::symbol_table::scope *scope
     = octave::__get_current_scope__ ("clear_variable");
 
   if (scope)
     scope->clear_variable (nm);
 }
 
 void
 clear_symbol (const std::string& nm)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("clear_symbol");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_symbol");
 
   symtab.clear_symbol (nm);
 }
 
 // Attributes of variables and functions.
 
 // Is this octave_value a valid function?
 
 octave_function *
 is_valid_function (const std::string& fcn_name,
                    const std::string& warn_for, bool warn)
 {
   octave_function *ans = nullptr;
 
   if (! fcn_name.empty ())
     {
-      symbol_table& symtab = octave::__get_symbol_table__ ("is_valid_function");
+      octave::symbol_table& symtab = octave::__get_symbol_table__ ("is_valid_function");
 
       octave_value val = symtab.find_function (fcn_name);
 
       if (val.is_defined ())
         ans = val.function_value (true);
     }
 
   // FIXME: Should this be "err" and "error_for", rather than warn?
@@ -232,17 +232,17 @@ get_struct_elts (const std::string& text
 
 static inline bool
 is_variable (const std::string& name)
 {
   bool retval = false;
 
   if (! name.empty ())
     {
-      symbol_table::scope *scope
+      octave::symbol_table::scope *scope
         = octave::__get_current_scope__ ("is_variable");
 
       octave_value val = scope ? scope->varval (name) : octave_value ();
 
       retval = val.is_defined ();
     }
 
   return retval;
@@ -354,17 +354,17 @@ static octave_value
 do_isglobal (const octave_value_list& args)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
 
-  symbol_table::scope *scope = octave::__get_current_scope__ ("do_isglobal");
+  octave::symbol_table::scope *scope = octave::__get_current_scope__ ("do_isglobal");
 
   std::string name = args(0).string_value ();
 
   return scope && scope->is_global (name);
 }
 
 DEFUN (isglobal, args, ,
        doc: /* -*- texinfo -*-
@@ -408,21 +408,21 @@ symbol_exist (const std::string& name, c
   bool search_file = type == "file";
   bool search_builtin = type == "builtin";
   bool search_class = type == "class";
 
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
     error ("exist: unrecognized type argument \"%s\"", type.c_str ());
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("symbol_exist");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("symbol_exist");
 
   if (search_any || search_var)
     {
-      symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_table::scope *scope = symtab.current_scope ();
 
       octave_value val = scope ? scope->varval (name) : octave_value ();
 
       if (val.is_constant () || val.isobject ()
           || val.is_function_handle ()
           || val.is_anonymous_function ()
           || val.is_inline_function ())
         return 1;
@@ -695,62 +695,62 @@ them.
 %!error <NAME must be a string> exist (1)
 %!error <unrecognized type argument "foobar"> exist ("a", "foobar")
 
 */
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
-  symbol_table::scope *scope
+  octave::symbol_table::scope *scope
     = octave::__get_current_scope__ ("lookup_function_handle");
 
   octave_value val = scope ? scope->varval (nm) : octave_value ();
 
   return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("get_global_value");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("get_global_value");
 
   octave_value val = symtab.global_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_global_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("set_global_value");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("set_global_value");
 
   symtab.global_assign (nm, val);
 }
 
 octave_value
 get_top_level_value (const std::string& nm, bool silent)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("get_top_level_value");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("get_top_level_value");
 
   octave_value val = symtab.top_level_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_top_level_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("set_top_level_value");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("set_top_level_value");
 
   symtab.top_level_assign (nm, val);
 }
 
 // Variable values.
 
 static bool
 wants_local_change (const octave_value_list& args, int& nargin)
@@ -1180,17 +1180,17 @@ get_dims_str (const octave_value& val)
 }
 
 class
 symbol_info_list
 {
 private:
   struct symbol_info
   {
-    symbol_info (const symbol_table::symbol_record& sr,
+    symbol_info (const octave::symbol_table::symbol_record& sr,
                  const std::string& expr_str = "",
                  const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
         varval (),
         is_automatic (sr.is_automatic ()),
         is_complex (varval.iscomplex ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
@@ -1344,22 +1344,22 @@ public:
     if (this != &sil)
       lst = sil.lst;
 
     return *this;
   }
 
   ~symbol_info_list (void) = default;
 
-  void append (const symbol_table::symbol_record& sr)
+  void append (const octave::symbol_table::symbol_record& sr)
   {
     lst.push_back (symbol_info (sr));
   }
 
-  void append (const symbol_table::symbol_record& sr,
+  void append (const octave::symbol_table::symbol_record& sr,
                const std::string& expr_str,
                const octave_value& expr_val)
   {
     lst.push_back (symbol_info (sr, expr_str, expr_val));
   }
 
   size_t size (void) const { return lst.size (); }
 
@@ -1678,17 +1678,17 @@ do_who (octave::interpreter& interp, int
 
   octave::call_stack& cs = interp.get_call_stack ();
 
   std::string my_name = argv[0];
 
   bool global_only = false;
   bool have_regexp = false;
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_who");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_who");
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-file")
         {
           // FIXME: This is an inefficient manner to implement this as the
           // variables are loaded in to a temporary context and then treated.
@@ -1700,24 +1700,24 @@ do_who (octave::interpreter& interp, int
             error ("whos: -file argument must be followed by a filename");
 
           std::string nm = argv[i + 1];
 
           octave::unwind_protect frame;
 
           // Set up temporary scope.
 
-          symbol_table::scope tmp_scope;
+          octave::symbol_table::scope tmp_scope;
 
           symtab.set_scope (&tmp_scope);
 
           cs.push (&tmp_scope, 0);
           frame.add_method (cs, &octave::call_stack::pop);
 
-          frame.add_method (tmp_scope, &symbol_table::scope::clear_variables);
+          frame.add_method (tmp_scope, &octave::symbol_table::scope::clear_variables);
 
           octave::feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
                                + nm + ":\n\n";
 
           retval = do_who (interp, i, argv, return_list, verbose, newmsg);
 
@@ -1746,25 +1746,25 @@ do_who (octave::interpreter& interp, int
     {
       pats.resize (++npats);
       pats[0] = "*";
     }
 
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
-  symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_table::scope *scope = symtab.current_scope ();
 
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
         {
-          std::list<symbol_table::symbol_record> tmp
+          std::list<octave::symbol_table::symbol_record> tmp
             = (global_only
                ? symtab.regexp_global_variables (pat)
                : symtab.regexp_variables (pat));
 
           for (const auto& symrec : tmp)
             {
               if (symrec.is_variable ())
                 {
@@ -1789,34 +1789,34 @@ do_who (octave::interpreter& interp, int
                   // no way of looking up the base value in the global
                   // scope and then evaluating the arguments in the
                   // current scope.
 
                   std::string base_name = pat.substr (0, pos);
 
                   if (scope && scope->is_variable (base_name))
                     {
-                      symbol_table::symbol_record sr
+                      octave::symbol_table::symbol_record sr
                         = symtab.find_symbol (base_name);
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
                           octave_value expr_val
                             = octave::eval_string (pat, true, parse_status);
 
                           symbol_stats.append (sr, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
-              std::list<symbol_table::symbol_record> tmp
+              std::list<octave::symbol_table::symbol_record> tmp
                 = (global_only
                    ? symtab.glob_global_variables (pat)
                    : symtab.glob_variables (pat));
 
               for (const auto& symrec : tmp)
                 {
                   if (symrec.is_variable ())
                     {
@@ -1995,17 +1995,17 @@ bind_ans (const octave_value& val, bool 
         {
           octave_value_list lst = val.list_value ();
 
           for (octave_idx_type i = 0; i < lst.length (); i++)
             bind_ans (lst(i), print);
         }
       else
         {
-          symbol_table::scope *scope
+          octave::symbol_table::scope *scope
             = octave::__get_current_scope__ ("bind_ans");
 
           if (scope)
             scope->force_assign (ans, val);
 
           if (print)
             {
               octave_value_list args = ovl (val);
@@ -2027,17 +2027,17 @@ mlock (void)
     error ("mlock: invalid use outside a function");
 
   fcn->lock ();
 }
 
 void
 munlock (const std::string& nm)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("munlock");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("munlock");
 
   octave_value val = symtab.find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
@@ -2045,17 +2045,17 @@ munlock (const std::string& nm)
     }
 }
 
 bool
 mislocked (const std::string& nm)
 {
   bool retval = false;
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("mislocked");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("mislocked");
 
   octave_value val = symtab.find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
@@ -2204,17 +2204,17 @@ maybe_warn_exclusive (bool exclusive)
   if (exclusive)
     warning ("clear: ignoring --exclusive option");
 }
 
 static void
 do_clear_functions (const string_vector& argv, int argc, int idx,
                     bool exclusive = false)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_functions");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_functions");
 
   if (idx == argc)
     symtab.clear_functions ();
   else
     {
       if (exclusive)
         {
           string_vector fcns = symtab.user_function_names ();
@@ -2236,19 +2236,19 @@ do_clear_functions (const string_vector&
         }
     }
 }
 
 static void
 do_clear_globals (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_globals");
-
-  symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_globals");
+
+  octave::symbol_table::scope *scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   if (idx == argc)
     {
       string_vector gvars = symtab.global_variable_names ();
 
@@ -2280,17 +2280,17 @@ do_clear_globals (const string_vector& a
         }
     }
 }
 
 static void
 do_clear_variables (const string_vector& argv, int argc, int idx,
                     bool exclusive = false, bool have_regexp = false)
 {
-  symbol_table::scope *scope
+  octave::symbol_table::scope *scope
     = octave::__get_current_scope__ ("do_clear_variables");
 
   if (! scope)
     return;
 
   if (idx == argc)
     scope->clear_variables ();
   else
@@ -2320,21 +2320,21 @@ do_clear_variables (const string_vector&
         }
     }
 }
 
 static void
 do_clear_symbols (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_symbols");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_symbols");
 
   if (idx == argc)
     {
-      symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_table::scope *scope = symtab.current_scope ();
 
       if (scope)
         scope->clear_variables ();
     }
   else
     {
       if (exclusive)
         {
@@ -2354,20 +2354,20 @@ do_clear_symbols (const string_vector& a
     }
 }
 
 static void
 do_matlab_compatible_clear (const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("do_matlab_compatible_clear");
 
-  symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_table::scope *scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   for (; idx < argc; idx++)
     {
       if (argv[idx] == "all"
           && ! scope->is_local_variable ("all"))
@@ -2504,18 +2504,18 @@ without the dash as well.
       bool clear_functions = false;
       bool clear_globals = false;
       bool clear_variables = false;
       bool clear_objects = false;
       bool exclusive = false;
       bool have_regexp = false;
       bool have_dash_option = false;
 
-      symbol_table& symtab = interp.get_symbol_table ();
-      symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_table& symtab = interp.get_symbol_table ();
+      octave::symbol_table::scope *scope = symtab.current_scope ();
 
       while (++idx < argc)
         {
           if (argv[idx] == "-all" || argv[idx] == "-a")
             {
               CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
               have_dash_option = true;
@@ -2713,17 +2713,17 @@ The original variable value is restored 
 }
 
 void
 maybe_missing_function_hook (const std::string& name)
 {
   // Don't do this if we're handling errors.
   if (buffer_error_messages == 0 && ! Vmissing_function_hook.empty ())
     {
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("maybe_missing_function_hook");
 
       octave_value val = symtab.find_function (Vmissing_function_hook);
 
       if (val.is_defined ())
         {
           // Ensure auto-restoration.
           octave::unwind_protect frame;
@@ -2745,17 +2745,17 @@ DEFMETHOD (__varval__, interp, args, ,
 Return the value of the variable @var{name} directly from the symbol table.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
-  symbol_table::scope *scope = interp.get_current_scope ();
+  octave::symbol_table::scope *scope = interp.get_current_scope ();
 
   return scope ? scope->varval (args(0).string_value ()) : octave_value ();
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -192,17 +192,17 @@ octave_class::octave_class (const octave
 
               map.assign (pcnm, c);
             }
           else
             error ("class: parent class dimension mismatch");
         }
     }
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class");
 
   symtab.add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
 {
   if (count == obsolete_copies)
@@ -293,17 +293,17 @@ octave_class::dotref (const octave_value
 Matrix
 octave_class::size (void)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::size ();
 
   Matrix retval (1, 2, 1.0);
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::size");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::size");
 
   octave_value meth = symtab.find_method ("size", class_name ());
 
   if (meth.is_defined ())
     {
       count++;
       octave_value_list args (1, octave_value (this));
 
@@ -333,17 +333,17 @@ octave_idx_type
 octave_class::numel (const octave_value_list& idx)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::numel (idx);
 
   octave_idx_type retval = -1;
   const std::string cn = class_name ();
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::numel");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::numel");
 
   octave_value meth = symtab.find_method ("numel", cn);
 
   if (meth.is_defined ())
     {
       octave_value_list args (idx.length () + 1, octave_value ());
 
       count++;
@@ -428,17 +428,17 @@ octave_class::subsref (const std::string
       // octave_value_list::next_subsref member function?  See also
       // octave_user_function::subsref.
 
       if (idx.size () > 1)
         retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
   else
     {
-      symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::subsref");
+      octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::subsref");
 
       octave_value meth = symtab.find_method ("subsref", class_name ());
 
       if (meth.is_defined ())
         {
           octave_value_list args;
 
           args(1) = make_idx_args (type, idx, "subsref");
@@ -528,17 +528,17 @@ octave_class::subsasgn_common (const oct
                                const std::string& type,
                                const std::list<octave_value_list>& idx,
                                const octave_value& rhs)
 {
   octave_value retval;
 
   if (! (in_class_method () || called_from_builtin ()))
     {
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_class::subsasgn_common");
 
       octave_value meth = symtab.find_method ("subsasgn", class_name ());
 
       if (meth.is_defined ())
         {
           octave_value_list args;
 
@@ -806,17 +806,17 @@ octave_class::subsasgn_common (const oct
     }
 
   return retval;
 }
 
 idx_vector
 octave_class::index_vector (bool require_integers) const
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::index_vector");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::index_vector");
 
   octave_value meth = symtab.find_method ("subsindex", class_name ());
 
   if (! meth.is_defined ())
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
   octave_value_list args;
@@ -854,17 +854,17 @@ octave_class::byte_size (void) const
   return retval;
 }
 
 bool
 octave_class::is_true (void) const
 {
   bool retval = false;
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::is_true");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::is_true");
 
   octave_value meth = symtab.find_method ("logical", class_name ());
 
   if (meth.is_defined ())
     {
       octave_value in = new octave_class (*this);
 
       octave_value_list tmp = octave::feval (meth.function_value (), in, 1);
@@ -972,17 +972,17 @@ octave_class::is_instance_of (const std:
   return retval;
 }
 
 string_vector
 octave_class::string_vector_value (bool pad) const
 {
   string_vector retval;
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("octave_class::string_vector_value");
 
   octave_value meth = symtab.find_method ("char", class_name ());
 
   if (! meth.is_defined ())
     error ("no char method defined for class %s", class_name ().c_str ());
 
   octave_value_list args;
@@ -1040,17 +1040,17 @@ octave_class::reconstruct_exemplar (void
 
   octave_class::exemplar_const_iterator it
     = octave_class::exemplar_map.find (c_name);
 
   if (it != octave_class::exemplar_map.end ())
     retval = true;
   else
     {
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_class::reconstruct_exemplar");
 
       octave_value ctor = symtab.find_method (c_name, c_name);
 
       bool have_ctor = false;
 
       if (ctor.is_defined () && ctor.is_function ())
         {
@@ -2040,17 +2040,17 @@ may @emph{only} be called from a class c
     {
       std::string inf_class = args(i).xstring_value ("superiorto: CLASS_NAME must be a string");
 
       // User defined classes always have higher precedence
       // than built-in classes
       if (is_built_in_class (inf_class))
         break;
 
-      symbol_table& symtab = interp.get_symbol_table ();
+      octave::symbol_table& symtab = interp.get_symbol_table ();
 
       std::string sup_class = fcn->name ();
       if (! symtab.set_class_relationship (sup_class, inf_class))
         error ("superiorto: opposite precedence already set for %s and %s",
                sup_class.c_str (), inf_class.c_str ());
     }
 
   return ovl ();
@@ -2077,17 +2077,17 @@ may @emph{only} be called from a class c
   for (int i = 0; i < args.length (); i++)
     {
       std::string sup_class = args(i).xstring_value ("inferiorto: CLASS_NAME must be a string");
 
       if (is_built_in_class (sup_class))
         error ("inferiorto: cannot give user-defined class lower "
                "precedence than built-in class");
 
-      symbol_table& symtab = interp.get_symbol_table ();
+      octave::symbol_table& symtab = interp.get_symbol_table ();
 
       std::string inf_class = fcn->name ();
       if (! symtab.set_class_relationship (sup_class, inf_class))
         error ("inferiorto: opposite precedence already set for %s and %s",
                inf_class.c_str (), sup_class.c_str ());
     }
 
   return octave_value();
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1104,17 +1104,17 @@ public:
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
 
         if (! is_constructed_object (mname))
           error ("cannot call superclass constructor with variable `%s'",
                  mname.c_str ());
 
-        symbol_table::scope *scope
+        octave::symbol_table::scope *scope
           = octave::__require_current_scope__ ("octave_classdef_superclass_ref::call");
 
         octave_value sym = scope->varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
@@ -3253,17 +3253,17 @@ Cell
 cdef_package::cdef_package_rep::get_packages (void) const
 { return map2Cell (package_map); }
 
 octave_value
 cdef_package::cdef_package_rep::find (const std::string& nm)
 {
   std::string symbol_name = get_name () + "." + nm;
 
-  symbol_table& symtab
+  octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("cdef_package::cdef_package_rep::find");
 
   return symtab.find (symbol_name, octave_value_list (), true, false);
 }
 
 octave_value_list
 cdef_package::cdef_package_rep::meta_subsref
   (const std::string& type, const std::list<octave_value_list>& idx,
@@ -3620,17 +3620,17 @@ cdef_manager::initialize (void)
 
   package_meta.install_class (tmp_meta_class, "class");
   package_meta.install_class (tmp_meta_property, "property");
   package_meta.install_class (tmp_meta_method, "method");
   package_meta.install_class (tmp_meta_package, "package");
   package_meta.install_class (tmp_meta_event, "event");
   package_meta.install_class (tmp_meta_dynproperty, "dynproperty");
 
-  symbol_table& symtab = m_interpreter.get_symbol_table ();
+  octave::symbol_table& symtab = m_interpreter.get_symbol_table ();
 
   // install built-in classes into the symbol table
   symtab.install_built_in_function
     ("meta.class",
      octave_value (tmp_meta_class.get_constructor_function ()));
 
   symtab.install_built_in_function
     ("meta.method",
@@ -3664,17 +3664,17 @@ cdef_manager::find_class (const std::str
       if (load_if_not_found)
         {
           octave_value ov_cls;
 
           size_t pos = name.rfind ('.');
 
           if (pos == std::string::npos)
             {
-              symbol_table& symtab
+              octave::symbol_table& symtab
                 = octave::__get_symbol_table__ ("cdef_manager::find_class");
 
               ov_cls = symtab.find (name);
             }
           else
             {
               std::string pack_name = name.substr (0, pos);
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -81,17 +81,17 @@ const std::string octave_fcn_handle::ano
 octave_fcn_handle::octave_fcn_handle (const octave_value& f,
                                       const std::string& n)
   : fcn (f), nm (n), has_overloads (false)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
     {
-      symbol_table::scope *uf_scope = uf->scope ();
+      octave::symbol_table::scope *uf_scope = uf->scope ();
 
       if (uf_scope)
         uf_scope->cache_name (nm);
     }
 
   if (uf && uf->is_nested_function () && ! uf->is_subfunction ())
     error ("handles to nested functions are not yet supported");
 }
@@ -135,42 +135,42 @@ octave_fcn_handle::subsref (const std::s
   return retval;
 }
 
 octave_value_list
 octave_fcn_handle::call (int nargout, const octave_value_list& args)
 {
   octave_value_list retval;
 
-  out_of_date_check (fcn, "", false);
+  octave::out_of_date_check (fcn, "", false);
 
   if (has_overloads)
     {
       // Possibly overloaded function.
       octave_value ov_fcn;
 
       // Compute dispatch type.
       builtin_type_t btyp;
-      std::string dispatch_type = get_dispatch_type (args, btyp);
+      std::string dispatch_type = octave::get_dispatch_type (args, btyp);
 
       // Retrieve overload.
       if (btyp != btyp_unknown)
         {
-          out_of_date_check (builtin_overloads[btyp], dispatch_type, false);
+          octave::out_of_date_check (builtin_overloads[btyp], dispatch_type, false);
           ov_fcn = builtin_overloads[btyp];
         }
       else
         {
           str_ov_map::iterator it = overloads.find (dispatch_type);
 
           if (it == overloads.end ())
             {
               // Try parent classes too.
 
-              symbol_table& symtab
+              octave::symbol_table& symtab
                 = octave::__get_symbol_table__ ("octave_fcn_handle::call");
 
               std::list<std::string> plist
                 = symtab.parent_classes (dispatch_type);
 
               std::list<std::string>::const_iterator pit = plist.begin ();
 
               while (pit != plist.end ())
@@ -180,28 +180,28 @@ octave_fcn_handle::call (int nargout, co
                   std::string fnm = fcn_name ();
 
                   octave_value ftmp = symtab.find_method (fnm, pname);
 
                   if (ftmp.is_defined ())
                     {
                       set_overload (pname, ftmp);
 
-                      out_of_date_check (ftmp, pname, false);
+                      octave::out_of_date_check (ftmp, pname, false);
                       ov_fcn = ftmp;
 
                       break;
                     }
 
                   pit++;
                 }
             }
           else
             {
-              out_of_date_check (it->second, dispatch_type, false);
+              octave::out_of_date_check (it->second, dispatch_type, false);
               ov_fcn = it->second;
             }
         }
 
       if (ov_fcn.is_defined ())
         retval = octave::feval (ov_fcn, args, nargout);
       else if (fcn.is_defined ())
         retval = octave::feval (fcn, args, nargout);
@@ -317,17 +317,17 @@ octave_fcn_handle::set_fcn (const std::s
 
           if (ov_fcn.is_undefined ())
             error ("function handle points to non-existent function");
 
           fcn = octave_value (new octave_fcn_handle (ov_fcn, nm));
         }
       else
         {
-          symbol_table& symtab
+          octave::symbol_table& symtab
             = octave::__get_symbol_table__ ("octave_fcn_handle::set_fcn");
 
           fcn = symtab.find_function (nm);
 
           if (! fcn.is_function ())
             error ("function handle points to non-existent function");
         }
     }
@@ -343,20 +343,20 @@ octave_fcn_handle::save_ascii (std::ostr
       os << nm << "\n";
 
       print_raw (os, true);
       os << "\n";
 
       if (fcn.is_undefined ())
         return false;
 
-      std::list<symbol_table::symbol_record> vars;
+      std::list<octave::symbol_table::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      symbol_table::scope *f_scope = f->scope ();
+      octave::symbol_table::scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
@@ -422,20 +422,20 @@ octave_fcn_handle::load_ascii (std::istr
 
       pos = is.tellg ();
 
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_ascii");
 
-      symbol_table::scope local_scope;
+      octave::symbol_table::scope local_scope;
 
       symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_ascii");
 
       cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
@@ -481,17 +481,17 @@ octave_fcn_handle::load_ascii (std::istr
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
                     {
-                      symbol_table::scope *uf_scope = uf->scope ();
+                      octave::symbol_table::scope *uf_scope = uf->scope ();
 
                       if (uf_scope)
                         uf_scope->cache_name (nm);
                     }
                 }
               else
                 success = false;
             }
@@ -512,20 +512,20 @@ octave_fcn_handle::save_binary (std::ost
 {
   if (nm == anonymous)
     {
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
         return false;
 
-      std::list<symbol_table::symbol_record> vars;
+      std::list<octave::symbol_table::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      symbol_table::scope *f_scope = f->scope ();
+      octave::symbol_table::scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << " " << varlen;
       else
@@ -617,20 +617,20 @@ octave_fcn_handle::load_binary (std::ist
       is.read (ctmp2, tmp);
       ctmp2[tmp] = 0;
 
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_binary");
 
-      symbol_table::scope local_scope;
+      octave::symbol_table::scope local_scope;
 
       symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_binary");
 
       cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
@@ -667,17 +667,17 @@ octave_fcn_handle::load_binary (std::ist
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
                     {
-                      symbol_table::scope *uf_scope = uf->scope ();
+                      octave::symbol_table::scope *uf_scope = uf->scope ();
 
                       if (uf_scope)
                         uf_scope->cache_name (nm);
                     }
                 }
               else
                 success = false;
             }
@@ -794,20 +794,20 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Sclose (space_hid);
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Dclose (data_hid);
 
-      std::list<symbol_table::symbol_record> vars;
+      std::list<octave::symbol_table::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      symbol_table::scope *f_scope = f->scope ();
+      octave::symbol_table::scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
@@ -1145,20 +1145,20 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       H5Eset_auto (err_func, err_func_data);
 #endif
 
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
-      symbol_table& symtab
+      octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
 
-      symbol_table::scope local_scope;
+      octave::symbol_table::scope local_scope;
 
       symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_hdf5");
 
       cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
@@ -1202,17 +1202,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
                     {
-                      symbol_table::scope *uf_scope = uf->scope ();
+                      octave::symbol_table::scope *uf_scope = uf->scope ();
 
                       if (uf_scope)
                         uf_scope->cache_name (nm);
                     }
                 }
               else
                 success = false;
             }
@@ -1603,17 +1603,17 @@ make_fcn_handle (const std::string& nm, 
           break;
 
         case '|':
           tnm = "or";
           break;
         }
     }
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("make_fcn_handle");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("make_fcn_handle");
 
   octave_value f = symtab.find_function (tnm, octave_value_list (),
                                          local_funcs);
 
   octave_function *fptr = f.function_value (true);
 
   // Here we are just looking to see if FCN is a method or constructor
   // for any class.
@@ -1795,20 +1795,20 @@ particular output format.
     }
 
   std::string nm = fcn->fcn_file_name ();
 
   if (fh_nm == octave_fcn_handle::anonymous)
     {
       m.setfield ("file", nm);
 
-      std::list<symbol_table::symbol_record> vars;
+      std::list<octave::symbol_table::symbol_record> vars;
 
       octave_user_function *fu = fh->user_function_value ();
-      symbol_table::scope *fu_scope = fu->scope ();
+      octave::symbol_table::scope *fu_scope = fu->scope ();
       if (fu_scope)
         vars = fu_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -99,17 +99,17 @@ octave_fcn_inline::octave_fcn_inline (co
             {
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("octave_fcn_inline");
 
               octave_function *curr_fcn = cs.current ();
 
               if (curr_fcn)
                 {
-                  symbol_table::scope *parent_scope
+                  octave::symbol_table::scope *parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
                   if (! parent_scope)
                     parent_scope = curr_fcn->scope ();
 
                   uf->stash_parent_fcn_scope (parent_scope);
                 }
             }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -75,21 +75,22 @@ public:
 
   virtual std::string src_file_name (void) const { return ""; }
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return ""; }
 
-  virtual symbol_table::scope *parent_fcn_scope (void) const { return 0; }
+  virtual octave::symbol_table::scope * parent_fcn_scope (void) const
+  { return 0; }
 
   virtual void mark_fcn_file_up_to_date (const octave::sys::time&) { }
 
-  virtual symbol_table::scope *scope (void) { return 0; }
+  virtual octave::symbol_table::scope * scope (void) { return 0; }
 
   virtual octave::sys::time time_parsed (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual octave::sys::time time_checked (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -171,17 +171,17 @@ octave_user_script::accept (octave::tree
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
                                      "user-defined function",
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
-  (symbol_table::scope *scope, octave::tree_parameter_list *pl,
+  (octave::symbol_table::scope *scope, octave::tree_parameter_list *pl,
    octave::tree_parameter_list *rl, octave::tree_statement_list *cl)
   : octave_user_code ("", ""), m_scope (scope),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
@@ -293,17 +293,17 @@ octave_user_function::maybe_relocate_end
             f->maybe_relocate_end_internal ();
         }
     }
 
   maybe_relocate_end_internal ();
 }
 
 void
-octave_user_function::stash_parent_fcn_scope (symbol_table::scope *ps)
+octave_user_function::stash_parent_fcn_scope (octave::symbol_table::scope *ps)
 {
   parent_scope = ps;
 }
 
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
@@ -460,34 +460,34 @@ octave_user_function::call (octave::tree
     error ("max_recursion_depth exceeded");
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   octave::call_stack& cs
     = octave::__get_call_stack__ ("octave_user_function::call");
 
-  symbol_table::context_id context = anonymous_function ? 0 : call_depth;
+  octave::symbol_table::context_id context = anonymous_function ? 0 : call_depth;
   cs.push (this, m_scope, context);
 
   frame.protect_var (Vtrack_line_num);
   Vtrack_line_num = true;    // update source line numbers, even if debugging
   frame.add_method (cs, &octave::call_stack::pop);
 
   if (call_depth > 0 && ! is_anonymous_function ())
     {
       m_scope->push_context ();
 
 #if 0
       std::cerr << name () << " scope: " << m_scope
                 << " call depth: " << call_depth
                 << " context: " << m_scope->current_context () << std::endl;
 #endif
 
-      frame.add_method (m_scope, &symbol_table::scope::pop_context);
+      frame.add_method (m_scope, &octave::symbol_table::scope::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
     {
 #if 0
       std::cerr << "defining param list, scope: " << m_scope
@@ -531,17 +531,17 @@ octave_user_function::call (octave::tree
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
       // variables will be cleared before the parameter lists are
       // cleared.  That way, any function parameters that have been
       // declared global will be unmarked as global before they are
       // undefined by the clear_param_list cleanup function.
 
-      frame.add_method (m_scope, &symbol_table::scope::clear_variables);
+      frame.add_method (m_scope, &octave::symbol_table::scope::clear_variables);
     }
 
   bind_automatic_vars (tw, arg_names, args.length (), nargout,
                        all_va_args (args));
 
   frame.add_method (this, &octave_user_function::restore_warning_states);
 
   bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
@@ -826,17 +826,17 @@ Programming Note: @code{nargin} does not
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value retval;
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
@@ -864,17 +864,17 @@ Programming Note: @code{nargin} does not
       octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
       retval = (param_list ? param_list->length () : 0);
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
-      symbol_table::scope *scope = symtab.require_current_scope ("nargin");
+      octave::symbol_table::scope *scope = symtab.require_current_scope ("nargin");
       retval = scope->varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
@@ -936,17 +936,17 @@ returns -1 for all anonymous functions.
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value retval;
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
@@ -990,17 +990,17 @@ returns -1 for all anonymous functions.
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
       if (symtab.at_top_level ())
         error ("nargout: invalid call at top level");
 
-      symbol_table::scope *scope = symtab.require_current_scope ("nargout");
+      octave::symbol_table::scope *scope = symtab.require_current_scope ("nargout");
       retval = scope->varval (".nargout.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
@@ -1058,22 +1058,22 @@ false.  @var{k} can also be an array, in
 element-by-element and a logical array is returned.  At the top level,
 @code{isargout} returns an error.
 @seealso{nargout, varargout, nthargout}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (symtab.at_top_level ())
     error ("isargout: invalid call at top level");
 
-  symbol_table::scope *scope = symtab.require_current_scope ("isargout");
+  octave::symbol_table::scope *scope = symtab.require_current_scope ("isargout");
 
   int nargout1 = scope->varval (".nargout.").int_value ();
 
   Matrix ignored;
   octave_value tmp = scope->varval (".ignored.");
   if (tmp.is_defined ())
     ignored = tmp.matrix_value ();
 
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -165,33 +165,33 @@ private:
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
-  octave_user_function (symbol_table::scope *scope = nullptr,
+  octave_user_function (octave::symbol_table::scope *scope = nullptr,
                         octave::tree_parameter_list *pl = nullptr,
                         octave::tree_parameter_list *rl = nullptr,
                         octave::tree_statement_list *cl = nullptr);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn) = delete;
 
   octave_user_function& operator = (const octave_user_function& fn) = delete;
 
   ~octave_user_function (void);
 
-  symbol_table::context_id active_context () const
+  octave::symbol_table::context_id active_context () const
   {
     return is_anonymous_function ()
-           ? 0 : static_cast<symbol_table::context_id>(call_depth);
+      ? 0 : static_cast<octave::symbol_table::context_id>(call_depth);
   }
 
   octave_function * function_value (bool = false) { return this; }
 
   octave_user_function * user_function_value (bool = false) { return this; }
 
   octave_user_code * user_code_value (bool = false) { return this; }
 
@@ -218,17 +218,17 @@ public:
 
   int ending_line (void) const { return end_location_line; }
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
-  void stash_parent_fcn_scope (symbol_table::scope *ps);
+  void stash_parent_fcn_scope (octave::symbol_table::scope *ps);
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave::sys::time& t)
@@ -238,19 +238,20 @@ public:
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string profiler_name (void) const;
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
-  symbol_table::scope *parent_fcn_scope (void) const { return parent_scope; }
+  octave::symbol_table::scope *
+  parent_fcn_scope (void) const { return parent_scope; }
 
-  symbol_table::scope *scope (void) { return m_scope; }
+  octave::symbol_table::scope *scope (void) { return m_scope; }
 
   octave::sys::time time_parsed (void) const { return t_parsed; }
 
   octave::sys::time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
@@ -391,17 +392,17 @@ private:
     none,
     legacy,
     classdef
   };
 
   std::string ctor_type_str (void) const;
 
   // Our symbol table scope.
-  symbol_table::scope *m_scope;
+  octave::symbol_table::scope *m_scope;
 
   // List of arguments for this function.  These are local variables.
   octave::tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
   octave::tree_parameter_list *ret_list;
 
@@ -462,17 +463,17 @@ private:
 
   // Enum describing whether this function is the constructor for class object.
   class_ctor_type class_constructor;
 
   // TRUE means this function is a method for a class.
   bool class_method;
 
   // The scope of the parent function, if any.
-  symbol_table::scope *parent_scope;
+  octave::symbol_table::scope *parent_scope;
 
   // pointer to the current unwind_protect frame of this function.
   octave::unwind_protect *curr_unwind_protect_frame;
 
 #if defined (HAVE_LLVM)
   jit_function_info *jit_info;
 #endif
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2467,17 +2467,17 @@ do_colon_op (const octave_value& base, c
 
       if (base.isobject ())
         dispatch_type = base.class_name ();
       else if (increment.is_defined () && increment.isobject ())
         dispatch_type = increment.class_name ();
       else
         dispatch_type = limit.class_name ();
 
-      symbol_table& symtab = octave::__get_symbol_table__ ("do_colon_op");
+      octave::symbol_table& symtab = octave::__get_symbol_table__ ("do_colon_op");
 
       octave_value meth = symtab.find_method ("colon", dispatch_type);
 
       if (! meth.is_defined ())
         error ("colon method not defined for %s class", dispatch_type.c_str ());
 
       octave_value_list args;
 
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -42,17 +42,18 @@ along with Octave; see the file COPYING.
 #define DEF_CLASS_UNOP(name)                                            \
   static octave_value                                                   \
   oct_unop_ ## name (const octave_value& a)                             \
   {                                                                     \
     octave_value retval;                                                \
                                                                         \
     std::string class_name = a.class_name ();                           \
                                                                         \
-    symbol_table& symtab = octave::__get_symbol_table__ ("oct_unop_" #name);    \
+    octave::symbol_table& symtab                                        \
+      = octave::__get_symbol_table__ ("oct_unop_" #name);               \
                                                                         \
     octave_value meth = symtab.find_method (#name, class_name);         \
                                                                         \
     if (meth.is_undefined ())                                           \
       error ("%s method not defined for %s class", #name,               \
              class_name.c_str ());                                      \
                                                                         \
     octave_value_list args;                                             \
@@ -77,19 +78,20 @@ DEF_CLASS_UNOP (ctranspose)
 
 #define DEF_CLASS_BINOP(name) \
   static octave_value                                                   \
   oct_binop_ ## name (const octave_value& a1, const octave_value& a2)   \
   {                                                                     \
     octave_value retval;                                                \
                                                                         \
     std::string dispatch_type                                           \
-      = (a1.isobject () ? a1.class_name () : a2.class_name ());        \
+      = (a1.isobject () ? a1.class_name () : a2.class_name ());         \
                                                                         \
-    symbol_table& symtab = octave::__get_symbol_table__ ("oct_unop_" #name);    \
+    octave::symbol_table& symtab                                        \
+      = octave::__get_symbol_table__ ("oct_unop_" #name);               \
                                                                         \
     octave_value meth = symtab.find_method (#name, dispatch_type);      \
                                                                         \
     if (meth.is_undefined ())                                           \
       error ("%s method not defined for %s class", #name,               \
              dispatch_type.c_str ());                                   \
                                                                         \
     octave_value_list args;                                             \
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -190,17 +190,17 @@ get_user_code (const std::string& fname)
               name[i] = octave::sys::file_ops::dir_sep_char ();
         }
 
       size_t name_len = name.length ();
 
       if (! name.empty () && name_len > 2 && name.substr (name_len-2) == ".m")
         name = name.substr (0, name_len-2);
 
-      symbol_table& symtab = octave::__get_symbol_table__ ("get_user_code");
+      octave::symbol_table& symtab = octave::__get_symbol_table__ ("get_user_code");
 
       octave_value fcn = symtab.find_function (name);
 
       if (fcn.is_defined () && fcn.is_user_code ())
         dbg_fcn = fcn.user_code_value ();
     }
 
   return dbg_fcn;
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -2044,17 +2044,18 @@ jit_typeinfo::register_intrinsic (const 
   llvm::Value *ret = builder.CreateCall (ifun, fargs);
   fn.do_return (builder, ret);
   paren_subsref_fn.add_overload (fn);
 }
 
 octave_builtin *
 jit_typeinfo::find_builtin (const std::string& name)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("jit_typeinfo::find_builtin");
+  octave::symbol_table& symtab
+    = octave::__get_symbol_table__ ("jit_typeinfo::find_builtin");
 
   // FIXME: Finalize what we want to store in octave_builtin, then add functions
   // to access these values in octave_value
   octave_value ov_builtin = symtab.find (name);
   return dynamic_cast<octave_builtin *> (ov_builtin.internal_rep ());
 }
 
 void
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -30,21 +30,20 @@ along with Octave; see the file COPYING.
 #include <list>
 #include <set>
 #include <stack>
 
 #include "comment-list.h"
 #include "input.h"
 #include "token.h"
 
-class symbol_table;
-
 namespace octave
 {
   class interpreter;
+  class symbol_table;
 
   // Is the given string a keyword?
   extern bool is_keyword (const std::string& s);
 
   // For communication between the lexer and parser.
 
   class
   lexical_feedback
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -496,17 +496,17 @@ word_list       : string
                 ;
 
 // ===========
 // Expressions
 // ===========
 
 identifier      : NAME
                   {
-                    symbol_table::symbol_record sr = $1->sym_rec ();
+                    octave::symbol_table::symbol_record sr = $1->sym_rec ();
                     $$ = new octave::tree_identifier (sr, $1->line (), $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
                     std::string method_nm = $1->superclass_method_name ();
@@ -1270,17 +1270,17 @@ push_fcn_symtab : // empty
                   {
                     $$ = 0;
 
                     parser.curr_fcn_depth++;
 
                     if (parser.max_fcn_depth < parser.curr_fcn_depth)
                       parser.max_fcn_depth = parser.curr_fcn_depth;
 
-                    lexer.symtab_context.push (new symbol_table::scope ());
+                    lexer.symtab_context.push (new octave::symbol_table::scope ());
 
                     parser.function_scopes.push (lexer.symtab_context.curr_scope ());
 
                     if (! lexer.reading_script_file
                         && parser.curr_fcn_depth == 1
                         && ! parser.parsing_subfunctions)
                       parser.primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
@@ -1300,17 +1300,17 @@ push_fcn_symtab : // empty
 
 param_list_beg  : '('
                   {
                     $$ = 0;
                     lexer.looking_at_parameter_list = true;
 
                     if (lexer.looking_at_function_handle)
                       {
-                        lexer.symtab_context.push (new symbol_table::scope ());
+                        lexer.symtab_context.push (new octave::symbol_table::scope ());
                         lexer.looking_at_function_handle--;
                         lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
@@ -1499,17 +1499,17 @@ fcn_name        : identifier
                         parser.bison_error ("duplicate subfunction or nested function name",
                                             $1->line (), $1->column ());
 
                         delete $1;
 
                         YYABORT;
                       }
 
-                    symbol_table::scope *curr_scope
+                    octave::symbol_table::scope *curr_scope
                       = lexer.symtab_context.curr_scope ();
                     curr_scope->cache_name (id);
 
                     lexer.parsed_function_name.top () = true;
                     lexer.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
@@ -4789,17 +4789,17 @@ not loaded anymore during the current Oc
         autoload_map[argv[1]] = nm;
       else if (nargin == 3)
         {
           if (argv[3] != "remove")
             error_with_id ("Octave:invalid-input-arg",
                            "autoload: third argument can only be 'remove'");
 
           // Remove function from symbol table and autoload map.
-          symbol_table& symtab = interp.get_symbol_table ();
+          octave::symbol_table& symtab = interp.get_symbol_table ();
           symtab.clear_dld_function (argv[1]);
           autoload_map.erase (argv[1]);
         }
     }
 
   return retval;
 }
 
@@ -5245,17 +5245,17 @@ builtin ("sin", 0)
 {
   octave_value_list retval;
 
   if (args.length () == 0)
     print_usage ();
 
   const std::string name (args(0).xstring_value ("builtin: function name (F) must be a string"));
 
-  symbol_table& symtab = interp.get_symbol_table ();
+  octave::symbol_table& symtab = interp.get_symbol_table ();
 
   octave_value fcn = symtab.builtin_find (name);
 
   if (fcn.is_defined ())
     retval = octave::feval (fcn.function_value (), args.splice (0, 1), nargout);
   else
     error ("builtin: lookup for symbol '%s' failed", name.c_str ());
 
@@ -5539,17 +5539,17 @@ may be either @qcode{"base"} or @qcode{"
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
 
       if (octave::is_keyword (nm))
         error ("assignin: invalid assignment to keyword '%s'", nm.c_str ());
 
-      symbol_table::scope *scope = interp.get_current_scope ();
+      octave::symbol_table::scope *scope = interp.get_current_scope ();
 
       if (scope)
         scope->assign (nm, args(2));
     }
   else
     error ("assignin: invalid variable name in argument VARNAME");
 
   return retval;
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -160,17 +160,17 @@ Example:
       octave_value_list args;
 
       args(2) = num_indices;
       args(1) = index_position + 1;
       args(0) = *indexed_object;
 
       std::string class_name = indexed_object->class_name ();
 
-      symbol_table& symtab = interp.get_symbol_table ();
+      octave::symbol_table& symtab = interp.get_symbol_table ();
 
       octave_value meth = symtab.find_method ("end", class_name);
 
       if (meth.is_defined ())
         return octave::feval (meth.function_value (), args, 1);
     }
 
   dim_vector dv = indexed_object->dims ();
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -1088,17 +1088,17 @@ final_index_error (octave::index_excepti
 
   if (expr->is_identifier ()
       && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
-      symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+      octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
 
       octave_value fcn = symtab.find_function (var);
 
       if (fcn.is_function ())
         {
           octave_function *fp = fcn.function_value ();
 
           if (fp && fp->name () == var)
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -208,17 +208,17 @@ final_index_error (octave::index_excepti
 
   if (expr->is_identifier ()
       && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
-      symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+      octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
 
       octave_value fcn = symtab.find_function (var);
 
       if (fcn.is_function ())
         {
           octave_function *fp = fcn.function_value ();
 
           if (fp && fp->name () == var)
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -113,17 +113,17 @@ static llvm::LLVMContext& context = llvm
 // is dead.
 class jit_break_exception : public std::exception
 { };
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree& tee, jit_type *for_bounds)
   : converting_function (false)
 {
-  symbol_table::scope *scope = octave::__get_current_scope__ ("jit_convert::jit_convert");
+  octave::symbol_table::scope *scope = octave::__get_current_scope__ ("jit_convert::jit_convert");
 
   initialize (scope);
 
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
   try
     {
@@ -1077,17 +1077,17 @@ jit_convert::visit_do_until_command (tre
       block->append (factory.create<jit_cond_branch> (check, tail, body));
     }
 
   blocks.push_back (tail);
   block = tail;
 }
 
 void
-jit_convert::initialize (symbol_table::scope *s)
+jit_convert::initialize (octave::symbol_table::scope *s)
 {
   scope = s;
   iterator_count = 0;
   for_bounds_count = 0;
   short_count = 0;
   jit_instruction::reset_ids ();
 
   entry_block = factory.create<jit_block> ("body");
@@ -1123,19 +1123,19 @@ jit_convert::find_variable (const std::s
 
 jit_variable *
 jit_convert::get_variable (const std::string& vname)
 {
   jit_variable *ret = find_variable (vname);
   if (ret)
     return ret;
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::find_variable");
-
-  symbol_table::symbol_record record = symtab.find_symbol (vname, scope);
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::find_variable");
+
+  octave::symbol_table::symbol_record record = symtab.find_symbol (vname, scope);
   if (record.is_persistent () || record.is_global ())
     throw jit_fail_exception ("Persistent and global not yet supported");
 
   if (converting_function)
     return create_variable (vname, jit_typeinfo::get_any (), false);
   else
     {
       octave_value val = record.varval ();
@@ -2399,17 +2399,17 @@ jit_info::execute (const vmap& extra_var
           octave_base_value *obv = current.internal_rep ();
           obv->grab ();
           real_arguments[i] = obv;
         }
     }
 
   function (&real_arguments[0]);
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("jit_info::execute");
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("jit_info::execute");
 
   for (size_t i = 0; i < arguments.size (); ++i)
     {
       const std::string& name = arguments[i].first;
 
       // do not store for loop bounds temporary
       if (name.size () && name[0] != '#')
         symtab::assign (arguments[i].first, real_arguments[i]);
@@ -2505,17 +2505,17 @@ jit_info::compile (tree_jit& tjit, tree&
 
 octave_value
 jit_info::find (const vmap& extra_vars, const std::string& vname) const
 {
   vmap::const_iterator iter = extra_vars.find (vname);
 
   if (iter == extra_vars.end ())
     {
-      symbol_table::scope *scope = octave::__require_current_scope__ ("jit_convert::find");
+      octave::symbol_table::scope *scope = octave::__require_current_scope__ ("jit_convert::find");
 
       return scope->varval (vname);
     }
   else
     return *iter->second;
 }
 
 #endif
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -164,17 +164,17 @@ public:
   void visit_do_until_command (tree_do_until_command&);
 private:
   std::vector<std::pair<std::string, bool>> arguments;
   type_bound_vector bounds;
 
   bool converting_function;
 
   // the scope of the function we are converting, or the current scope
-  symbol_table::scope *scope;
+  octave::symbol_table::scope *scope;
 
   jit_factory factory;
 
   // used instead of return values from visit_* functions
   jit_value *result;
 
   jit_block *entry_block;
 
@@ -189,17 +189,17 @@ private:
   std::vector<jit_magic_end::context> end_context;
 
   size_t iterator_count;
   size_t for_bounds_count;
   size_t short_count;
 
   variable_map vmap;
 
-  void initialize (symbol_table::scope *s);
+  void initialize (octave::symbol_table::scope *s);
 
   jit_call * create_checked_impl (jit_call *ret);
 
   // get an existing vairable.  If the variable does not exist, it will not be
   // created
   jit_variable * find_variable (const std::string& vname) const;
 
   // get a variable, create it if it does not exist.  The type will default to
