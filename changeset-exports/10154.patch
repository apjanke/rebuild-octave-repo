# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1264026821 18000
#      Wed Jan 20 17:33:41 2010 -0500
# Node ID 40dfc0c991168c1b029038bcc5f7da2f15e6f3de
# Parent  2c28f9d0360f3081e2a0263148159a2bd7287b3a
DLD-FUNCTIONS/*.cc: untabify

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,48 @@
+2010-01-20  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/__contourc__.cc, DLD-FUNCTIONS/__convn__.cc,
+	DLD-FUNCTIONS/__delaunayn__.cc, DLD-FUNCTIONS/__dsearchn__.cc,
+	DLD-FUNCTIONS/__glpk__.cc, DLD-FUNCTIONS/__lin_interpn__.cc,
+	DLD-FUNCTIONS/__magick_read__.cc,
+	DLD-FUNCTIONS/__pchip_deriv__.cc, DLD-FUNCTIONS/__qp__.cc,
+	DLD-FUNCTIONS/__voronoi__.cc, DLD-FUNCTIONS/amd.cc,
+	DLD-FUNCTIONS/balance.cc, DLD-FUNCTIONS/besselj.cc,
+	DLD-FUNCTIONS/betainc.cc, DLD-FUNCTIONS/bsxfun.cc,
+	DLD-FUNCTIONS/ccolamd.cc, DLD-FUNCTIONS/cellfun.cc,
+	DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/colamd.cc,
+	DLD-FUNCTIONS/colloc.cc, DLD-FUNCTIONS/conv2.cc,
+	DLD-FUNCTIONS/convhulln.cc, DLD-FUNCTIONS/daspk.cc,
+	DLD-FUNCTIONS/dasrt.cc, DLD-FUNCTIONS/dassl.cc,
+	DLD-FUNCTIONS/det.cc, DLD-FUNCTIONS/dispatch.cc,
+	DLD-FUNCTIONS/dlmread.cc, DLD-FUNCTIONS/dmperm.cc,
+	DLD-FUNCTIONS/eig.cc, DLD-FUNCTIONS/eigs.cc,
+	DLD-FUNCTIONS/fft.cc, DLD-FUNCTIONS/fft2.cc,
+	DLD-FUNCTIONS/fftn.cc, DLD-FUNCTIONS/fftw.cc,
+	DLD-FUNCTIONS/filter.cc, DLD-FUNCTIONS/find.cc,
+	DLD-FUNCTIONS/fltk_backend.cc, DLD-FUNCTIONS/gammainc.cc,
+	DLD-FUNCTIONS/gcd.cc, DLD-FUNCTIONS/getgrent.cc,
+	DLD-FUNCTIONS/getpwent.cc, DLD-FUNCTIONS/givens.cc,
+	DLD-FUNCTIONS/hess.cc, DLD-FUNCTIONS/hex2num.cc,
+	DLD-FUNCTIONS/inv.cc, DLD-FUNCTIONS/kron.cc,
+	DLD-FUNCTIONS/lookup.cc, DLD-FUNCTIONS/lsode.cc,
+	DLD-FUNCTIONS/lu.cc, DLD-FUNCTIONS/luinc.cc,
+	DLD-FUNCTIONS/matrix_type.cc, DLD-FUNCTIONS/md5sum.cc,
+	DLD-FUNCTIONS/pinv.cc, DLD-FUNCTIONS/qr.cc,
+	DLD-FUNCTIONS/quad.cc, DLD-FUNCTIONS/qz.cc,
+	DLD-FUNCTIONS/rand.cc, DLD-FUNCTIONS/rcond.cc,
+	DLD-FUNCTIONS/regexp.cc, DLD-FUNCTIONS/schur.cc,
+	DLD-FUNCTIONS/sparse.cc, DLD-FUNCTIONS/spparms.cc,
+	DLD-FUNCTIONS/sqrtm.cc, DLD-FUNCTIONS/svd.cc,
+	DLD-FUNCTIONS/syl.cc, DLD-FUNCTIONS/symbfact.cc,
+	DLD-FUNCTIONS/symrcm.cc, DLD-FUNCTIONS/time.cc,
+	DLD-FUNCTIONS/tril.cc, DLD-FUNCTIONS/tsearch.cc,
+	DLD-FUNCTIONS/urlwrite.cc: Untabify.
+
 2010-01-20  John W. Eaton  <jwe@octave.org>
 
 	* TEMPLATE-INST/Array-os.cc, TEMPLATE-INST/Array-tc.cc,
 	TEMPLATE-INST/Array-sym.cc: Delete Emacs local-variable settings.
 
 2010-01-20  Jaroslav Hajek  <highegg@gmail.com>
 
 	* xpow.cc (xpow, elem_xpow): Don't do redundant real->complex
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -88,18 +88,18 @@ start_contour (double lvl, double x, dou
   end_contour ();
   this_contour.resize (2, 0);
   add_point (lvl, 0);
   add_point (x, y);
 }
 
 static void
 drawcn (const RowVector& X, const RowVector& Y, const Matrix& Z,
-	double lvl, int r, int c, double ct_x, double ct_y,
-	unsigned int start_edge, bool first, charMatrix& mark)
+        double lvl, int r, int c, double ct_x, double ct_y,
+        unsigned int start_edge, bool first, charMatrix& mark)
 {
   double px[4], py[4], pz[4], tmp;
   unsigned int stop_edge, next_edge, pt[2];
   int next_r, next_c;
 
   //get x, y, and z - lvl for current facet
   px[0] = px[3] = X(c);
   px[1] = px[2] = X(c+1);
@@ -145,20 +145,20 @@ drawcn (const RowVector& X, const RowVec
   // Calculate contour segment start if first of contour.
   if (first)
     {
       tmp = fabs (pz[pt[1]]) / fabs (pz[pt[0]]);
 
       if (xisnan (tmp))
         ct_x = ct_y = 0.5;
       else
-	{
-	  ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
-	  ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
-	}
+        {
+          ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
+          ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
+        }
 
       start_contour (lvl, ct_x, ct_y);
     }
 
   // Find stop edge.
   // FIXME -- perhaps this should use a while loop?
   for (unsigned int k = 1; k <= 4; k++)
     {
@@ -228,39 +228,39 @@ mark_facets (const Matrix& Z, charMatrix
         f[3] = Z(r+1, c) - lvl;
         f[2] = Z(r+1, c+1) - lvl;
 
         for (unsigned int i = 0; i < 4; i++)
           if (fabs(f[i]) < DBL_EPSILON)
             f[i] = DBL_EPSILON;
 
         if (f[1] * f[2] < 0)
-	  mark(r, c) += 2;
+          mark(r, c) += 2;
 
         if (f[0] * f[3] < 0)
-	  mark(r, c) += 8;
+          mark(r, c) += 8;
       }
 
   for (unsigned int r = 0; r < nr; r++)
     for (unsigned int c = 0; c < nc; c++)
       {
         f[0] = Z(r, c) - lvl;
         f[1] = Z(r, c+1) - lvl;
         f[3] = Z(r+1, c) - lvl;
         f[2] = Z(r+1, c+1) - lvl;
 
         for (unsigned int i = 0; i < 4; i++)
           if (fabs(f[i]) < DBL_EPSILON)
             f[i] = DBL_EPSILON;
 
         if (f[0] * f[1] < 0)
-	  mark(r, c) += 1;
+          mark(r, c) += 1;
 
         if (f[2] * f[3] < 0)
-	  mark(r, c) += 4;
+          mark(r, c) += 4;
       }
 }
 
 static void
 cntr (const RowVector& X, const RowVector& Y, const Matrix& Z, double lvl)
 {
   unsigned int nr = Z.rows ();
   unsigned int nc = Z.cols ();
@@ -274,17 +274,17 @@ cntr (const RowVector& X, const RowVecto
   for (unsigned int c = 0; c < nc - 1; c++)
     {
       // Top.
       if (mark(0, c) & 1)
         drawcn (X, Y, Z, lvl, 0, c, 0.0, 0.0, 0, true, mark);
 
       // Bottom.
       if (mark(nr - 2, c) & 4)
-	drawcn (X, Y, Z, lvl, nr - 2, c, 0.0, 0.0, 2, true, mark);
+        drawcn (X, Y, Z, lvl, nr - 2, c, 0.0, 0.0, 2, true, mark);
     }
 
   for (unsigned int r = 0; r < nr - 1; r++)
     {
       // Left.
       if (mark(r, 0) & 8)
         drawcn (X, Y, Z, lvl, r, 0, 0.0, 0.0, 3, true, mark);
 
@@ -310,26 +310,26 @@ Undocumented internal function.\n\
   if (args.length () == 4)
     {
       RowVector X = args (0).row_vector_value ();
       RowVector Y = args (1).row_vector_value ();
       Matrix Z = args (2).matrix_value ();
       RowVector L = args (3).row_vector_value ();
 
       if (! error_state)
-	{
-	  contourc.resize (2, 0);
+        {
+          contourc.resize (2, 0);
 
-	  for (int i = 0; i < L.length (); i++)
-	    cntr (X, Y, Z, L (i));
+          for (int i = 0; i < L.length (); i++)
+            cntr (X, Y, Z, L (i));
 
-	  end_contour ();
+          end_contour ();
 
-	  retval = contourc;
-	}
+          retval = contourc;
+        }
       else
-	error ("__contourc__: invalid argument values");
+        error ("__contourc__: invalid argument values");
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__convn__.cc b/src/DLD-FUNCTIONS/__convn__.cc
--- a/src/DLD-FUNCTIONS/__convn__.cc
+++ b/src/DLD-FUNCTIONS/__convn__.cc
@@ -77,17 +77,17 @@ convn (const MTa& a, const MTb& b)
       error ("__convn__: first and second argument must have same dimensionality");
       return retval;
     }
 
   // Allocate output
   dim_vector out_size (a_size);
   for (octave_idx_type n = 0; n < ndims; n++)
     out_size(n) = std::max (a_size(n) - b_size(n) + 1,
-			    static_cast<octave_idx_type> (0));
+                            static_cast<octave_idx_type> (0));
 
   typedef typename octave_convn_traits<MTa, MTb>::TR MTout;
 
   MTout out (out_size);
 
   const octave_idx_type out_numel = out.numel ();
   
   // Iterate over every element of 'out'.
@@ -134,107 +134,107 @@ Undocumented internal function.\n\
 @end deftypefn\n\
 ")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       if (args(0).is_single_type() || args(1).is_single_type())
-	{
-	  if (args(0).is_real_type ())
-	    {
-	      if (args(1).is_real_type ())
-		{
-		  const FloatNDArray a = args (0).float_array_value ();
-		  const FloatNDArray b = args (1).float_array_value ();
+        {
+          if (args(0).is_real_type ())
+            {
+              if (args(1).is_real_type ())
+                {
+                  const FloatNDArray a = args (0).float_array_value ();
+                  const FloatNDArray b = args (1).float_array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else if (args(1).is_complex_type ())
-		{
-		  const FloatNDArray a = args (0).float_array_value ();
-		  const FloatComplexNDArray b = args (1).float_complex_array_value ();
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else if (args(1).is_complex_type ())
+                {
+                  const FloatNDArray a = args (0).float_array_value ();
+                  const FloatComplexNDArray b = args (1).float_complex_array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else
-		error ("__convn__: invalid call");
-	    }
-	  else if (args(0).is_complex_type ())
-	    {
-	      if (args(1).is_complex_type ())
-		{
-		  const FloatComplexNDArray a = args (0).float_complex_array_value ();
-		  const FloatComplexNDArray b = args (1).float_complex_array_value ();
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else
+                error ("__convn__: invalid call");
+            }
+          else if (args(0).is_complex_type ())
+            {
+              if (args(1).is_complex_type ())
+                {
+                  const FloatComplexNDArray a = args (0).float_complex_array_value ();
+                  const FloatComplexNDArray b = args (1).float_complex_array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else if (args(1).is_real_type ())
-		{
-		  const FloatComplexNDArray a = args (0).float_complex_array_value ();
-		  const FloatNDArray b = args (1).float_array_value ();
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else if (args(1).is_real_type ())
+                {
+                  const FloatComplexNDArray a = args (0).float_complex_array_value ();
+                  const FloatNDArray b = args (1).float_array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else
-		error ("__convn__: invalid call");
-	    }
-	  else
-	    error ("__convn__: invalid call");
-	}
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else
+                error ("__convn__: invalid call");
+            }
+          else
+            error ("__convn__: invalid call");
+        }
       else
-	{
-	  if (args(0).is_real_type ())
-	    {
-	      if (args(1).is_real_type ())
-		{
-		  const NDArray a = args (0).array_value ();
-		  const NDArray b = args (1).array_value ();
+        {
+          if (args(0).is_real_type ())
+            {
+              if (args(1).is_real_type ())
+                {
+                  const NDArray a = args (0).array_value ();
+                  const NDArray b = args (1).array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else if (args(1).is_complex_type ())
-		{
-		  const NDArray a = args (0).array_value ();
-		  const ComplexNDArray b = args (1).complex_array_value ();
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else if (args(1).is_complex_type ())
+                {
+                  const NDArray a = args (0).array_value ();
+                  const ComplexNDArray b = args (1).complex_array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else
-		error ("__convn__: invalid call");
-	    }
-	  else if (args(0).is_complex_type ())
-	    {
-	      if (args(1).is_complex_type ())
-		{
-		  const ComplexNDArray a = args (0).complex_array_value ();
-		  const ComplexNDArray b = args (1).complex_array_value ();
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else
+                error ("__convn__: invalid call");
+            }
+          else if (args(0).is_complex_type ())
+            {
+              if (args(1).is_complex_type ())
+                {
+                  const ComplexNDArray a = args (0).complex_array_value ();
+                  const ComplexNDArray b = args (1).complex_array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else if (args(1).is_real_type ())
-		{
-		  const ComplexNDArray a = args (0).complex_array_value ();
-		  const NDArray b = args (1).array_value ();
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else if (args(1).is_real_type ())
+                {
+                  const ComplexNDArray a = args (0).complex_array_value ();
+                  const NDArray b = args (1).array_value ();
 
-		  if (! error_state)
-		    retval = convn (a, b);
-		}
-	      else
-		error ("__convn__: invalid call");
-	    }
-	  else
-	    error ("__convn__: invalid call");
-	}
+                  if (! error_state)
+                    retval = convn (a, b);
+                }
+              else
+                error ("__convn__: invalid call");
+            }
+          else
+            error ("__convn__: invalid call");
+        }
     }
   else
     print_usage ();
     
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -56,17 +56,17 @@ extern "C" {
 }
 
 #ifdef NEED_QHULL_VERSION
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
 #endif
 #endif
 
 DEFUN_DLD (__delaunayn__, args, ,
-	   "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{T} =} __delaunayn__ (@var{P}[, @var{opt}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
@@ -91,44 +91,44 @@ Undocumented internal function.\n\
   else
     options = "Qt Qbb Qc Qx";
 
 
   if (nargin == 2)
     {
     if (args(1).is_empty ())
       {
-	// keep default options
+        // keep default options
       }
     else if (args(1).is_string ()) 
       {
-	// option string is directly provided
-	options = args(1).string_value ();
+        // option string is directly provided
+        options = args(1).string_value ();
       }
     else if (args(1).is_cell ()) 
       {
-	options = "";
+        options = "";
 
-	Cell c = args(1).cell_value ();
-	for (octave_idx_type i = 0; i < c.numel (); i++)
-	  {
+        Cell c = args(1).cell_value ();
+        for (octave_idx_type i = 0; i < c.numel (); i++)
+          {
 
-	    if (! c.elem(i).is_string ()) 
-	      {
-		error ("__delaunayn__: all options must be strings");
-		return retval;
-	      }
+            if (! c.elem(i).is_string ()) 
+              {
+                error ("__delaunayn__: all options must be strings");
+                return retval;
+              }
 
-	    options = options + c.elem(i).string_value () + " ";
-	  }
+            options = options + c.elem(i).string_value () + " ";
+          }
       }
     else 
       {
-	error ("__delaunayn__: second argument must be a string, cell of stringsor empty");
-	return retval;
+        error ("__delaunayn__: second argument must be a string, cell of stringsor empty");
+        return retval;
       }
     } 
 
   //octave_stdout << "options " << options << std::endl;
 
   if (n > dim + 1) 
     {
       p = p.transpose ();
@@ -141,85 +141,85 @@ Undocumented internal function.\n\
 
       // If you want some debugging information replace the 0 pointer
       // with stdout or some other file open for writing.
 
       FILE *outfile = 0;
       FILE *errfile = stderr;
 
       if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, outfile, errfile))
-	{
-	  // triangulate non-simplicial facets
-	  qh_triangulate (); 
+        {
+          // triangulate non-simplicial facets
+          qh_triangulate (); 
 
-	  facetT *facet;
-	  vertexT *vertex, **vertexp;
-	  octave_idx_type nf = 0, i = 0;
+          facetT *facet;
+          vertexT *vertex, **vertexp;
+          octave_idx_type nf = 0, i = 0;
 
-	  FORALLfacets
-	    {
-	      if (! facet->upperdelaunay)
-		nf++;
+          FORALLfacets
+            {
+              if (! facet->upperdelaunay)
+                nf++;
 
-	      // Double check
-	      if (! facet->simplicial) 
-		{
-		  error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
-		  break;
-		}
-	    }
+              // Double check
+              if (! facet->simplicial) 
+                {
+                  error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
+                  break;
+                }
+            }
 
-	  Matrix simpl (nf, dim+1);
+          Matrix simpl (nf, dim+1);
 
-	  FORALLfacets
-	    {
-	      if (! facet->upperdelaunay) 
-		{
-		  octave_idx_type j = 0;
+          FORALLfacets
+            {
+              if (! facet->upperdelaunay) 
+                {
+                  octave_idx_type j = 0;
 
-		  FOREACHvertex_ (facet->vertices)
-		    {
-		      // if delaunayn crashes, enable this check
+                  FOREACHvertex_ (facet->vertices)
+                    {
+                      // if delaunayn crashes, enable this check
 #if 0
-		      if (j > dim)
-			{
-			  error ("__delaunayn__: internal error. Qhull returned non-simplicial facets");
-			  return retval;
-			}
+                      if (j > dim)
+                        {
+                          error ("__delaunayn__: internal error. Qhull returned non-simplicial facets");
+                          return retval;
+                        }
 #endif
 
-		      simpl(i, j++) = 1 + qh_pointid(vertex->point);
-		    }
-		  i++;
-		}
-	    }
+                      simpl(i, j++) = 1 + qh_pointid(vertex->point);
+                    }
+                  i++;
+                }
+            }
 
-	  retval(0) = simpl;
+          retval(0) = simpl;
 
-	  // free long memory
-	  qh_freeqhull (! qh_ALL);
+          // free long memory
+          qh_freeqhull (! qh_ALL);
 
-	  // free short memory and memory allocator
-	  int curlong, totlong;
-	  qh_memfreeshort (&curlong, &totlong);
+          // free short memory and memory allocator
+          int curlong, totlong;
+          qh_memfreeshort (&curlong, &totlong);
 
-	  if (curlong || totlong)
-	    warning ("__delaunay__: did not free %d bytes of long memory (%d pieces)",
-		     totlong, curlong);
-	}
+          if (curlong || totlong)
+            warning ("__delaunay__: did not free %d bytes of long memory (%d pieces)",
+                     totlong, curlong);
+        }
       else
-	error ("__delaunayn__: qhull failed.");
+        error ("__delaunayn__: qhull failed.");
     }
   else if (n == dim + 1) 
     {
       // one should check if nx points span a simplex
       // I will look at this later.
       RowVector vec (n);
       for (octave_idx_type i = 0; i < n; i++) 
-	vec(i) = i + 1.0;
+        vec(i) = i + 1.0;
 
       retval(0) = vec;
     }
 
 #else
   error ("__delaunayn__: not available in this version of Octave");
 #endif
 
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-math.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN_DLD (__dsearchn__, args, ,
-	"-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
 
   if (nargin != 2)
@@ -50,61 +50,61 @@ Undocumented internal function.\n\
     }
 
   Matrix x = args(0).matrix_value().transpose ();
   Matrix xi = args(1).matrix_value().transpose ();
 
   if (! error_state)
     {
       if (x.rows() != xi.rows() || x.columns() < 1)
-	error ("__dsearch__: dimensional mismatch");
+        error ("__dsearch__: dimensional mismatch");
       else
-	{
-	  octave_idx_type n = x.rows();
-	  octave_idx_type nx = x.columns();
-	  octave_idx_type nxi = xi.columns();
+        {
+          octave_idx_type n = x.rows();
+          octave_idx_type nx = x.columns();
+          octave_idx_type nxi = xi.columns();
 
-	  ColumnVector idx (nxi);
-	  double *pidx = idx.fortran_vec ();
-	  ColumnVector dist (nxi);
-	  double *pdist = dist.fortran_vec ();
+          ColumnVector idx (nxi);
+          double *pidx = idx.fortran_vec ();
+          ColumnVector dist (nxi);
+          double *pdist = dist.fortran_vec ();
 
 #define DIST(dd, y, yi, m) \
   dd = 0.; \
   for (octave_idx_type k = 0; k < m; k++) \
    { \
      double yd = y[k] - yi[k]; \
      dd += yd * yd; \
    } \
   dd = sqrt (dd);
 
-	  const double *pxi = xi.fortran_vec ();
-	  for (octave_idx_type i = 0; i < nxi; i++)
-	    {
-	      double d0;
-	      const double *px = x.fortran_vec ();
-	      DIST(d0, px, pxi, n);
-	      *pidx = 1.;
-	      for (octave_idx_type j = 1; j < nx; j++)
-		{
-		  px += n;
-		  double d;
-		  DIST (d, px, pxi, n);
-		  if (d < d0)
-		    {
-		      d0 = d;
-		      *pidx = static_cast<double>(j + 1);
-		    }
-		  OCTAVE_QUIT;
- 		}
+          const double *pxi = xi.fortran_vec ();
+          for (octave_idx_type i = 0; i < nxi; i++)
+            {
+              double d0;
+              const double *px = x.fortran_vec ();
+              DIST(d0, px, pxi, n);
+              *pidx = 1.;
+              for (octave_idx_type j = 1; j < nx; j++)
+                {
+                  px += n;
+                  double d;
+                  DIST (d, px, pxi, n);
+                  if (d < d0)
+                    {
+                      d0 = d;
+                      *pidx = static_cast<double>(j + 1);
+                    }
+                  OCTAVE_QUIT;
+                }
 
-	      *pdist++ = d0; 
-	      pidx++;
-	      pxi += n;
-	    }
+              *pdist++ = d0; 
+              pidx++;
+              pxi += n;
+            }
 
-	  retval(1) = dist;
-	  retval(0) = idx;
-	}
+          retval(1) = dist;
+          retval(0) = idx;
+        }
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -198,92 +198,92 @@ glpk (int sense, int n, int m, double *c
   if (isMIP)
     lpx_set_class (lp, LPX_MIP);
 
   lpx_add_cols (lp, n);
   for (int i = 0; i < n; i++)
     {
       //-- Define type of the structural variables
       if (! freeLB[i] && ! freeUB[i])
-	{
-	  if (lb[i] != ub[i])
-	    lpx_set_col_bnds (lp, i+1, LPX_DB, lb[i], ub[i]);
-	  else
-	    lpx_set_col_bnds (lp, i+1, LPX_FX, lb[i], ub[i]);
-	}
+        {
+          if (lb[i] != ub[i])
+            lpx_set_col_bnds (lp, i+1, LPX_DB, lb[i], ub[i]);
+          else
+            lpx_set_col_bnds (lp, i+1, LPX_FX, lb[i], ub[i]);
+        }
       else
-	{
-	  if (! freeLB[i] && freeUB[i])
+        {
+          if (! freeLB[i] && freeUB[i])
             lpx_set_col_bnds (lp, i+1, LPX_LO, lb[i], ub[i]);
-	  else
-	    {
-	      if (freeLB[i] && ! freeUB[i])
-		lpx_set_col_bnds (lp, i+1, LPX_UP, lb[i], ub[i]);
-	      else
-		lpx_set_col_bnds (lp, i+1, LPX_FR, lb[i], ub[i]);
-	    }
-	}
+          else
+            {
+              if (freeLB[i] && ! freeUB[i])
+                lpx_set_col_bnds (lp, i+1, LPX_UP, lb[i], ub[i]);
+              else
+                lpx_set_col_bnds (lp, i+1, LPX_FR, lb[i], ub[i]);
+            }
+        }
 
       // -- Set the objective coefficient of the corresponding
       // -- structural variable. No constant term is assumed.
       lpx_set_obj_coef(lp,i+1,c[i]);
 
       if (isMIP)
-	lpx_set_col_kind (lp, i+1, vartype[i]);
+        lpx_set_col_kind (lp, i+1, vartype[i]);
     }
 
   lpx_add_rows (lp, m);
 
   for (int i = 0; i < m; i++)
     {
       /* If the i-th row has no lower bound (types F,U), the
          corrispondent parameter will be ignored.
          If the i-th row has no upper bound (types F,L), the corrispondent
          parameter will be ignored.
          If the i-th row is of S type, the i-th LB is used, but
          the i-th UB is ignored.
       */
 
       switch (ctype[i])
-	{
-	case 'F':
-	  typx = LPX_FR;
-	  break;
+        {
+        case 'F':
+          typx = LPX_FR;
+          break;
 
-	case 'U':
-	  typx = LPX_UP;
-	  break;
+        case 'U':
+          typx = LPX_UP;
+          break;
 
-	case 'L':
-	  typx = LPX_LO;
-	  break;
+        case 'L':
+          typx = LPX_LO;
+          break;
 
-	case 'S':
-	  typx = LPX_FX;
-	  break;
+        case 'S':
+          typx = LPX_FX;
+          break;
 
-	case 'D':
-	  typx = LPX_DB;
-	  break;
-	}
+        case 'D':
+          typx = LPX_DB;
+          break;
+        }
       
       lpx_set_row_bnds (lp, i+1, typx, b[i], b[i]);
 
     }
 
   lpx_load_matrix (lp, nz, rn, cn, a);
 
   if (save_pb)
     {
       static char tmp[] = "outpb.lp";
       if (lpx_write_cpxlp (lp, tmp) != 0)
-	{
-	  error ("__glpk__: unable to write problem");
-	  longjmp (mark, -1);
-	}
+        {
+          error ("__glpk__: unable to write problem");
+          longjmp (mark, -1);
+        }
     }
 
   //-- scale the problem data (if required)
   //-- if (scale && (!presol || method == 1)) lpx_scale_prob(lp);
   //-- LPX_K_SCALE=IParam[1]  LPX_K_PRESOL=IParam[16]
   if (lpxIntParam[1] && (! lpxIntParam[16] || lpsolver != 1))
     lpx_scale_prob (lp);
 
@@ -301,24 +301,24 @@ glpk (int sense, int n, int m, double *c
     method = 'S';
   else
     method = 'T';
 
   switch (method)
     {
     case 'S':
       {
-	if (isMIP)
-	  {
-	    method = 'I';
-	    errnum = lpx_simplex (lp);
-	    errnum = lpx_integer (lp);
-	  }
-	else
-	  errnum = lpx_simplex(lp);
+        if (isMIP)
+          {
+            method = 'I';
+            errnum = lpx_simplex (lp);
+            errnum = lpx_integer (lp);
+          }
+        else
+          errnum = lpx_simplex(lp);
       }
      break;
 
     case 'T':
       errnum = lpx_interior(lp);
       break;
 
     default:
@@ -336,68 +336,68 @@ glpk (int sense, int n, int m, double *c
   /*  errnum assumes the following results:
       errnum = 0 <=> No errors
       errnum = 1 <=> Iteration limit exceeded.
       errnum = 2 <=> Numerical problems with basis matrix.
   */
   if (errnum == LPX_E_OK)
     {
       if (isMIP)
-	{
-	  *status = lpx_mip_status (lp);
-	  *fmin = lpx_mip_obj_val (lp);
-	}
+        {
+          *status = lpx_mip_status (lp);
+          *fmin = lpx_mip_obj_val (lp);
+        }
       else
-	{
-	  if (lpsolver == 1)
-	    {
-	      *status = lpx_get_status (lp);
-	      *fmin = lpx_get_obj_val (lp);
-	    }
-	  else
-	    {
-	      *status = lpx_ipt_status (lp);
-	      *fmin = lpx_ipt_obj_val (lp);
-	    }
-	}
+        {
+          if (lpsolver == 1)
+            {
+              *status = lpx_get_status (lp);
+              *fmin = lpx_get_obj_val (lp);
+            }
+          else
+            {
+              *status = lpx_ipt_status (lp);
+              *fmin = lpx_ipt_obj_val (lp);
+            }
+        }
 
       if (isMIP)
-	{
-	  for (int i = 0; i < n; i++)
-	    xmin[i] = lpx_mip_col_val (lp, i+1);
-	}
+        {
+          for (int i = 0; i < n; i++)
+            xmin[i] = lpx_mip_col_val (lp, i+1);
+        }
       else
-	{
-	  /* Primal values */
-	  for (int i = 0; i < n; i++)
-	    {
-	      if (lpsolver == 1)
-		xmin[i] = lpx_get_col_prim (lp, i+1);
-	      else
-		xmin[i] = lpx_ipt_col_prim (lp, i+1);
-	    }
+        {
+          /* Primal values */
+          for (int i = 0; i < n; i++)
+            {
+              if (lpsolver == 1)
+                xmin[i] = lpx_get_col_prim (lp, i+1);
+              else
+                xmin[i] = lpx_ipt_col_prim (lp, i+1);
+            }
 
-	  /* Dual values */
-	  for (int i = 0; i < m; i++)
-	    {
-	      if (lpsolver == 1)
-		lambda[i] = lpx_get_row_dual (lp, i+1);
-	      else
-		lambda[i] = lpx_ipt_row_dual (lp, i+1);
-	    }
+          /* Dual values */
+          for (int i = 0; i < m; i++)
+            {
+              if (lpsolver == 1)
+                lambda[i] = lpx_get_row_dual (lp, i+1);
+              else
+                lambda[i] = lpx_ipt_row_dual (lp, i+1);
+            }
 
-	  /* Reduced costs */
-	  for (int i = 0; i < lpx_get_num_cols (lp); i++)
-	    {
-	      if (lpsolver == 1)
-		redcosts[i] = lpx_get_col_dual (lp, i+1);
-	      else
-		redcosts[i] = lpx_ipt_col_dual (lp, i+1);
-	    }
-	}
+          /* Reduced costs */
+          for (int i = 0; i < lpx_get_num_cols (lp); i++)
+            {
+              if (lpsolver == 1)
+                redcosts[i] = lpx_get_col_dual (lp, i+1);
+              else
+                redcosts[i] = lpx_ipt_col_dual (lp, i+1);
+            }
+        }
 
       *time = (clock () - t_start) / CLOCKS_PER_SEC;
 
 #ifdef GLPK_PRE_4_14
       *mem = (lib_env_ptr () -> mem_tpeak);
 #else
       *mem = 0;
 #endif
@@ -414,61 +414,61 @@ glpk (int sense, int n, int m, double *c
 }
 
 #endif
 
 #define OCTAVE_GLPK_GET_REAL_PARAM(NAME, IDX) \
   do \
     { \
       if (PARAM.contains (NAME)) \
-	{ \
-	  Cell tmp = PARAM.contents (NAME); \
+        { \
+          Cell tmp = PARAM.contents (NAME); \
  \
           if (! tmp.is_empty ()) \
-	    { \
-	      lpxRealParam[IDX] = tmp(0).scalar_value (); \
+            { \
+              lpxRealParam[IDX] = tmp(0).scalar_value (); \
  \
               if (error_state) \
-		{ \
-		  error ("glpk: invalid value in param." NAME); \
-		  return retval; \
-		} \
-	    } \
-	  else \
-	    { \
-	      error ("glpk: invalid value in param." NAME); \
-	      return retval; \
-	    } \
-	} \
+                { \
+                  error ("glpk: invalid value in param." NAME); \
+                  return retval; \
+                } \
+            } \
+          else \
+            { \
+              error ("glpk: invalid value in param." NAME); \
+              return retval; \
+            } \
+        } \
     } \
   while (0)
 
 #define OCTAVE_GLPK_GET_INT_PARAM(NAME, VAL) \
   do \
     { \
       if (PARAM.contains (NAME)) \
-	{ \
-	  Cell tmp = PARAM.contents (NAME); \
+        { \
+          Cell tmp = PARAM.contents (NAME); \
  \
           if (! tmp.is_empty ()) \
-	    { \
-	      VAL = tmp(0).int_value (); \
+            { \
+              VAL = tmp(0).int_value (); \
  \
               if (error_state) \
-		{ \
-		  error ("glpk: invalid value in param." NAME); \
-		  return retval; \
-		} \
-	    } \
-	  else \
-	    { \
-	      error ("glpk: invalid value in param." NAME); \
-	      return retval; \
-	    } \
-	} \
+                { \
+                  error ("glpk: invalid value in param." NAME); \
+                  return retval; \
+                } \
+            } \
+          else \
+            { \
+              error ("glpk: invalid value in param." NAME); \
+              return retval; \
+            } \
+        } \
     } \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{values}] =} __glpk__ (@var{args})\n\
 Undocumented internal function.\n\
 @end deftypefn")
@@ -507,76 +507,76 @@ Undocumented internal function.\n\
 
   //-- 2nd Input. A matrix containing the constraints coefficients.
   // If matrix A is NOT a sparse matrix
   if (args(1).is_sparse_type ())
     {
       SparseMatrix A = args(1).sparse_matrix_value (); // get the sparse matrix
 
       if (error_state)
-	{
-	  error ("__glpk__: invalid value of A");
-	  return retval;
-	}
+        {
+          error ("__glpk__: invalid value of A");
+          return retval;
+        }
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nzmax ();
       rn.resize (Anz+1);
       cn.resize (Anz+1);
       a.resize (Anz+1, 0.0);
 
       if (Anc != mrowsc)
-	{
-	  error ("__glpk__: invalid value of A");
-	  return retval;
-	}
+        {
+          error ("__glpk__: invalid value of A");
+          return retval;
+        }
 
       for (octave_idx_type j = 0; j < Anc; j++)
-	for (octave_idx_type i = A.cidx(j); i < A.cidx(j+1); i++)
-	  {
-	    nz++;
-	    rn(nz) = A.ridx(i) + 1;
-	    cn(nz) = j + 1;
-	    a(nz) = A.data(i);
-	  }
+        for (octave_idx_type i = A.cidx(j); i < A.cidx(j+1); i++)
+          {
+            nz++;
+            rn(nz) = A.ridx(i) + 1;
+            cn(nz) = j + 1;
+            a(nz) = A.data(i);
+          }
     }
   else
     {
       Matrix A (args(1).matrix_value ()); // get the matrix
 
       if (error_state)
-	{
-	  error ("__glpk__: invalid value of A");
-	  return retval;
-	}
+        {
+          error ("__glpk__: invalid value of A");
+          return retval;
+        }
 
       mrowsA = A.rows ();
       rn.resize (mrowsA*mrowsc+1);
       cn.resize (mrowsA*mrowsc+1);
       a.resize (mrowsA*mrowsc+1, 0.0);
 
       for (int i = 0; i < mrowsA; i++)
-	{
-	  for (int j = 0; j < mrowsc; j++)
-	    {
-	      if (A(i,j) != 0)
-		{
-		  nz++;
-		  rn(nz) = i + 1;
-		  cn(nz) = j + 1;
-		  a(nz) = A(i,j);
-		}
-	    }
-	}
+        {
+          for (int j = 0; j < mrowsc; j++)
+            {
+              if (A(i,j) != 0)
+                {
+                  nz++;
+                  rn(nz) = i + 1;
+                  cn(nz) = j + 1;
+                  a(nz) = A(i,j);
+                }
+            }
+        }
 
     }
 
   //-- 3rd Input. A column array containing the right-hand side value
-  //	           for each constraint in the constraint matrix.
+  //               for each constraint in the constraint matrix.
   Matrix B (args(2).matrix_value ());
 
   if (error_state)
     {
       error ("__glpk__: invalid value of b");
       return retval;
     }
 
@@ -594,22 +594,22 @@ Undocumented internal function.\n\
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
   Array<int> freeLB (mrowsc);
   for (int i = 0; i < mrowsc; i++)
      {
        if (xisinf (lb[i]))
-	 {
-	   freeLB(i) = 1;
-	   lb[i] = -octave_Inf;
-	 }
+         {
+           freeLB(i) = 1;
+           lb[i] = -octave_Inf;
+         }
        else
-	 freeLB(i) = 0;
+         freeLB(i) = 0;
      }
 
   //-- 5th Input. An array of at least length numcols containing the upper
   //--            bound on each of the variables.
   Matrix UB (args(4).matrix_value ());
 
   if (error_state || UB.length () < mrowsc)
     {
@@ -618,22 +618,22 @@ Undocumented internal function.\n\
     }
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (mrowsc);
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (ub[i]))
-	{
-	  freeUB(i) = 1;
-	  ub[i] = octave_Inf;
-	}
+        {
+          freeUB(i) = 1;
+          ub[i] = octave_Inf;
+        }
       else
-	freeUB(i) = 0;
+        freeUB(i) = 0;
     }
 
   //-- 6th Input. A column array containing the sense of each constraint
   //--            in the constraint matrix.
   charMatrix CTYPE (args(5).char_matrix_value ());
 
   if (error_state)
     {
@@ -652,22 +652,22 @@ Undocumented internal function.\n\
       return retval;
     }
 
   Array<int> vartype (mrowsc);
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
-	{
-	  isMIP = 1;
-	  vartype(i) = LPX_IV;
-	}
+        {
+          isMIP = 1;
+          vartype(i) = LPX_IV;
+        }
       else
-	vartype(i) = LPX_CV;
+        vartype(i) = LPX_CV;
     }
 
   //-- 8th Input. Sense of optimization.
   volatile int sense;
   double SENSE = args(7).scalar_value ();
 
   if (error_state)
     {
@@ -791,17 +791,17 @@ Undocumented internal function.\n\
   //-- is primal feasible
   OCTAVE_GLPK_GET_REAL_PARAM ("tolbnd", 1);
 
   //-- Absolute tolerance used to check if the current basic solution
   //-- is dual feasible
   OCTAVE_GLPK_GET_REAL_PARAM ("toldj", 2);
 
   //-- Relative tolerance used to choose eligible pivotal elements of
-  //--	the simplex table in the ratio test
+  //--  the simplex table in the ratio test
   OCTAVE_GLPK_GET_REAL_PARAM ("tolpiv", 3);
 
   OCTAVE_GLPK_GET_REAL_PARAM ("objll", 4);
 
   OCTAVE_GLPK_GET_REAL_PARAM ("objul", 5);
 
   OCTAVE_GLPK_GET_REAL_PARAM ("tmlim", 6);
 
@@ -819,23 +819,23 @@ Undocumented internal function.\n\
   ColumnVector redcosts (mrowsc, octave_NA);
   ColumnVector time (1);
   ColumnVector mem (1);
 
   int jmpret = setjmp (mark);
 
   if (jmpret == 0)
     glpk (sense, mrowsc, mrowsA, c, nz, rn.fortran_vec (),
-	  cn.fortran_vec (), a.fortran_vec (), b, ctype,
-	  freeLB.fortran_vec (), lb, freeUB.fortran_vec (),
-	  ub, vartype.fortran_vec (), isMIP, lpsolver,
-	  save_pb, xmin.fortran_vec (), fmin.fortran_vec (),
-	  status.fortran_vec (), lambda.fortran_vec (),
-	  redcosts.fortran_vec (), time.fortran_vec (),
-	  mem.fortran_vec ());
+          cn.fortran_vec (), a.fortran_vec (), b, ctype,
+          freeLB.fortran_vec (), lb, freeUB.fortran_vec (),
+          ub, vartype.fortran_vec (), isMIP, lpsolver,
+          save_pb, xmin.fortran_vec (), fmin.fortran_vec (),
+          status.fortran_vec (), lambda.fortran_vec (),
+          redcosts.fortran_vec (), time.fortran_vec (),
+          mem.fortran_vec ());
 
   Octave_map extra;
 
   if (! isMIP)
     {
       extra.assign ("lambda", octave_value (lambda));
       extra.assign ("redcosts", octave_value (redcosts));
     }
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -49,140 +49,140 @@ lookup (const T *x, octave_idx_type n, T
 {
   octave_idx_type j;
 
   if (x[0] < x[n-1])
     {
       // increasing x
 
       if (y > x[n-1] || y < x[0])
-	return -1;
+        return -1;
 
 #ifdef EXHAUSTIF
       for (j = 0; j < n - 1; j++)
-	{
-	  if (x[j] <= y && y <= x[j+1])
-	    return j;
-	}
+        {
+          if (x[j] <= y && y <= x[j+1])
+            return j;
+        }
 #else
       octave_idx_type j0 = 0;
       octave_idx_type j1 = n - 1;
 
       while (true)
-	{
-	  j = (j0+j1)/2;
+        {
+          j = (j0+j1)/2;
 
-	  if (y <= x[j+1])
-	    {
-	      if (x[j] <= y)
-		return j;
+          if (y <= x[j+1])
+            {
+              if (x[j] <= y)
+                return j;
 
-	      j1 = j;
-	    }
+              j1 = j;
+            }
 
-	  if (x[j] <= y)
-	    j0 = j;
-	}
+          if (x[j] <= y)
+            j0 = j;
+        }
 #endif
     }
   else
     {
       // decreasing x
       // previous code with x -> -x and y -> -y
 
       if (y > x[0] || y < x[n-1])
-	return -1;
+        return -1;
 
 #ifdef EXHAUSTIF
       for (j = 0; j < n - 1; j++)
-	{
-	  if (x[j+1] <= y && y <= x[j])
-	    return j;
-	}
+        {
+          if (x[j+1] <= y && y <= x[j])
+            return j;
+        }
 #else
       octave_idx_type j0 = 0;
       octave_idx_type j1 = n - 1;
 
       while (true)
-	{
-	  j = (j0+j1)/2;
+        {
+          j = (j0+j1)/2;
 
-	  if (y >= x[j+1])
-	    {
-	      if (x[j] >= y)
-		return j;
+          if (y >= x[j+1])
+            {
+              if (x[j] >= y)
+                return j;
 
-	      j1 = j;
-	    }
+              j1 = j;
+            }
 
-	  if (x[j] >= y)
-	    j0 = j;
-	}
+          if (x[j] >= y)
+            j0 = j;
+        }
 #endif
     }
 }
 
 // n-dimensional linear interpolation
 
 template <class T>
 void
 lin_interpn (int n, const octave_idx_type *size, const octave_idx_type *scale,
-	     octave_idx_type Ni, T extrapval, const T **x,
-	     const T *v, const T **y, T *vi)
+             octave_idx_type Ni, T extrapval, const T **x,
+             const T *v, const T **y, T *vi)
 {
   bool out = false;
   int bit;
 
   OCTAVE_LOCAL_BUFFER (T, coef, 2*n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, index, n);
 
   // loop over all points
   for (octave_idx_type m = 0; m < Ni; m++)
     {
       // loop over all dimensions
       for (int i = 0; i < n; i++)
-	{
+        {
           index[i] = lookup (x[i], size[i], y[i][m]);
-	  out = index[i] == -1;
+          out = index[i] == -1;
 
-	  if (out)
-	    break;
-	  else
+          if (out)
+            break;
+          else
             {
-	      octave_idx_type j = index[i];
-	      coef[2*i+1] = (y[i][m] - x[i][j])/(x[i][j+1] - x[i][j]);
-	      coef[2*i] = 1 - coef[2*i+1];
-	    }
-	}
+              octave_idx_type j = index[i];
+              coef[2*i+1] = (y[i][m] - x[i][j])/(x[i][j+1] - x[i][j]);
+              coef[2*i] = 1 - coef[2*i+1];
+            }
+        }
 
 
       if (out)
-	vi[m] = extrapval;
+        vi[m] = extrapval;
       else
-	{
-	  vi[m] = 0;
+        {
+          vi[m] = 0;
 
-	  // loop over all corners of hypercube (1<<n = 2^n)
-	  for (int i = 0; i < (1 << n); i++)
-	    {
-	      T c = 1;
-	      octave_idx_type l = 0;
+          // loop over all corners of hypercube (1<<n = 2^n)
+          for (int i = 0; i < (1 << n); i++)
+            {
+              T c = 1;
+              octave_idx_type l = 0;
 
-	      // loop over all dimensions
-	      for (int j = 0; j < n; j++)
-		{
-		  // test if the jth bit in i is set
-		  bit = i >> j & 1;
-		  l += scale[j] * (index[j] + bit);
-		  c *= coef[2*j+bit];
-		}
+              // loop over all dimensions
+              for (int j = 0; j < n; j++)
+                {
+                  // test if the jth bit in i is set
+                  bit = i >> j & 1;
+                  l += scale[j] * (index[j] + bit);
+                  c *= coef[2*j+bit];
+                }
 
-	      vi[m] += c * v[l];
-	    }
-	}
+              vi[m] += c * v[l];
+            }
+        }
     }
 }
 
 template <class T, class M>
 octave_value
 lin_interpn (int n, M *X, const M V, M *Y)
 {
   octave_value retval;
@@ -215,43 +215,43 @@ lin_interpn (int n, M *X, const M V, M *
     scale[i] = scale[i-1] * size[i-1];
 
   // tests if X[0] is a vector, if yes, assume that all elements of X are
   // in the ndgrid format.
 
   if (! isvector (X[0]))
     {
       for (int i = 0; i < n; i++)
-	{
-	  if (X[i].dims () != V.dims ())
-	    {
-	      error ("interpn: incompatible size of argument number %d", i+1);
-	      return retval;
-	    }
-	  else
-	    {
+        {
+          if (X[i].dims () != V.dims ())
+            {
+              error ("interpn: incompatible size of argument number %d", i+1);
+              return retval;
+            }
+          else
+            {
               M tmp = M (dim_vector (size[i], 1));
 
-	      for (octave_idx_type j = 0; j < size[i]; j++)
-		tmp(j) =  X[i](scale[i]*j);
+              for (octave_idx_type j = 0; j < size[i]; j++)
+                tmp(j) =  X[i](scale[i]*j);
 
               X[i] = tmp;
-	    }
-	}
+            }
+        }
     }
 
   for (int i = 0; i < n; i++)
     {
       if (! isvector (X[i]) && X[i].numel () != size[i])
-	{
-	  error ("interpn: incompatible size of argument number %d", i+1);
-	  return retval;
-	}
+        {
+          error ("interpn: incompatible size of argument number %d", i+1);
+          return retval;
+        }
       else
-	x[i] = X[i].data ();
+        x[i] = X[i].data ();
     }
 
   lin_interpn (n, size, scale, Ni, extrapval, x, v, y, vi);
 
   retval = Vi;
 
   return retval;
 }
@@ -289,69 +289,69 @@ Undocumented internal function.\n\
   if (args(n).is_single_type())
     {
       OCTAVE_LOCAL_BUFFER (FloatNDArray, X, n);
       OCTAVE_LOCAL_BUFFER (FloatNDArray, Y, n);
 
       const FloatNDArray V = args(n).float_array_value ();
 
       if (error_state)
-	{
-	  print_usage ();
-	  return retval;
-	}
+        {
+          print_usage ();
+          return retval;
+        }
 
       for (int i = 0; i < n; i++)
-	{
-	  X[i] = args(i).float_array_value ();
-	  Y[i] = args(n+i+1).float_array_value ();
+        {
+          X[i] = args(i).float_array_value ();
+          Y[i] = args(n+i+1).float_array_value ();
 
-	  if (error_state)
-	    {
-	      print_usage ();
-	      return retval;
-	    }
+          if (error_state)
+            {
+              print_usage ();
+              return retval;
+            }
 
-	  if (Y[0].dims () != Y[i].dims ())
-	    {
-	      error ("interpn: incompatible size of argument number %d", n+i+2);
-	      return retval;
-	    }
-	}
+          if (Y[0].dims () != Y[i].dims ())
+            {
+              error ("interpn: incompatible size of argument number %d", n+i+2);
+              return retval;
+            }
+        }
 
       retval = lin_interpn<float, FloatNDArray> (n, X, V, Y);
     }
   else  
     {
       OCTAVE_LOCAL_BUFFER (NDArray, X, n);
       OCTAVE_LOCAL_BUFFER (NDArray, Y, n);
 
       const NDArray V = args(n).array_value ();
 
       if (error_state)
-	{
-	  print_usage ();
-	  return retval;
-	}
+        {
+          print_usage ();
+          return retval;
+        }
 
       for (int i = 0; i < n; i++)
-	{
-	  X[i] = args(i).array_value ();
-	  Y[i] = args(n+i+1).array_value ();
+        {
+          X[i] = args(i).array_value ();
+          Y[i] = args(n+i+1).array_value ();
 
-	  if (error_state)
-	    {
-	      print_usage ();
-	      return retval;
-	    }
+          if (error_state)
+            {
+              print_usage ();
+              return retval;
+            }
 
-	  if (Y[0].dims () != Y[i].dims ())
-	    {
-	      error ("interpn: incompatible size of argument number %d", n+i+2);
-	      return retval;
-	    }
-	}
+          if (Y[0].dims () != Y[i].dims ())
+            {
+              error ("interpn: incompatible size of argument number %d", n+i+2);
+              return retval;
+            }
+        }
       
       retval = lin_interpn<double, NDArray> (n, X, V, Y);
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -410,23 +410,23 @@ Instead you should use @code{imread}.\n\
   Magick::ClassType klass = imvec[0].classType ();
 
   if (klass == Magick::PseudoClass && nargout > 1)
     output = read_indexed_images (imvec, frameidx, (nargout == 3));
   else
     {
       unsigned int depth = imvec[0].modulusDepth ();
       if (depth > 1)
-	{
-	  --depth;
-	  int i = 1;
-	  while (depth >>= 1)
+        {
+          --depth;
+          int i = 1;
+          while (depth >>= 1)
             i++;
-	  depth = 1 << i;
-	}
+          depth = 1 << i;
+        }
       
       switch (depth)
         {
         case 1:
           output = read_images<boolNDArray> (imvec, frameidx, depth);
           break;
 
         case 2:
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -31,23 +31,23 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "utils.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dpchim, DPCHIM) (const octave_idx_type& n, const double *x, const double *f,
-			     double *d, const octave_idx_type &incfd,
-			     octave_idx_type *ierr);
+                             double *d, const octave_idx_type &incfd,
+                             octave_idx_type *ierr);
 
   F77_RET_T
   F77_FUNC (pchim, PCHIM) (const octave_idx_type& n, const float *x, const float *f,
-			   float *d, const octave_idx_type &incfd,
-			   octave_idx_type *ierr);
+                           float *d, const octave_idx_type &incfd,
+                           octave_idx_type *ierr);
 }
 
 // Wrapper for SLATEC/PCHIP function DPCHIM to calculate the derivates
 // for piecewise polynomials.
 
 DEFUN_DLD (__pchip_deriv__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
@@ -57,91 +57,91 @@ Undocumented internal function.\n\
   octave_value retval;
   const int nargin = args.length ();
 
   bool rows = (nargin == 3 && args (2).uint_value() == 2);
 
   if (nargin >= 2)
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
-	{
-	  FloatColumnVector xvec (args(0).float_vector_value ());
-	  FloatMatrix ymat (args(1).float_matrix_value ());
+        {
+          FloatColumnVector xvec (args(0).float_vector_value ());
+          FloatMatrix ymat (args(1).float_matrix_value ());
 
-	  octave_idx_type nx = xvec.length ();
-	  octave_idx_type nyr = ymat.rows ();
-	  octave_idx_type nyc = ymat.columns ();
+          octave_idx_type nx = xvec.length ();
+          octave_idx_type nyr = ymat.rows ();
+          octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
-	    {
+            {
               error ("__pchip_deriv__: dimension mismatch");
-	      return retval;
-	    }
+              return retval;
+            }
 
           const float *yvec = ymat.data ();
-	  FloatMatrix dmat (nyr, nyc);
+          FloatMatrix dmat (nyr, nyc);
           float *dvec = dmat.fortran_vec ();
 
-	  octave_idx_type ierr;
+          octave_idx_type ierr;
           const octave_idx_type incfd = rows ? nyr : 1;
           const octave_idx_type inc = rows ? 1 : nyr;
 
           for (octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
-	    {
+            {
               F77_FUNC (pchim, PCHIM) (nx, xvec.data (), 
                                        yvec, dvec, incfd, &ierr);
 
               yvec += inc;
               dvec += inc;
 
-	      if (ierr < 0)
-		{
-		  error ("PCHIM error: %i\n", ierr);
-		  return retval;
-		}
-	    }
+              if (ierr < 0)
+                {
+                  error ("PCHIM error: %i\n", ierr);
+                  return retval;
+                }
+            }
 
-	  retval = dmat;
-	}
+          retval = dmat;
+        }
       else
-	{
-	  ColumnVector xvec (args(0).vector_value ());
-	  Matrix ymat (args(1).matrix_value ());
+        {
+          ColumnVector xvec (args(0).vector_value ());
+          Matrix ymat (args(1).matrix_value ());
 
-	  octave_idx_type nx = xvec.length ();
-	  octave_idx_type nyr = ymat.rows ();
-	  octave_idx_type nyc = ymat.columns ();
+          octave_idx_type nx = xvec.length ();
+          octave_idx_type nyr = ymat.rows ();
+          octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
-	    {
+            {
               error ("__pchip_deriv__: dimension mismatch");
-	      return retval;
-	    }
+              return retval;
+            }
 
           const double *yvec = ymat.data ();
-	  Matrix dmat (nyr, nyc);
+          Matrix dmat (nyr, nyc);
           double *dvec = dmat.fortran_vec ();
 
-	  octave_idx_type ierr;
+          octave_idx_type ierr;
           const octave_idx_type incfd = rows ? nyr : 1;
           const octave_idx_type inc = rows ? 1 : nyr;
 
           for (octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
-	    {
+            {
               F77_FUNC (dpchim, DPCHIM) (nx, xvec.data (), 
                                          yvec, dvec, incfd, &ierr);
 
               yvec += inc;
               dvec += inc;
 
-	      if (ierr < 0)
-		{
-		  error ("DPCHIM error: %i\n", ierr);
-		  return retval;
-		}
-	    }
+              if (ierr < 0)
+                {
+                  error ("DPCHIM error: %i\n", ierr);
+                  return retval;
+                }
+            }
 
-	  retval = dmat;
-	}
+          retval = dmat;
+        }
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -60,29 +60,29 @@ null (const Matrix& A, octave_idx_type& 
 
       octave_idx_type tmp = A_nr > A_nc ? A_nr : A_nc;
 
       double tol = tmp * s(0) * DBL_EPSILON;
 
       octave_idx_type n = s.length ();
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  if (s(i) > tol)
-	    rank++;
-	}
+        {
+          if (s(i) > tol)
+            rank++;
+        }
 
       if (rank < A_nc)
-	retval = V.extract (0, rank, A_nc-1, A_nc-1);
+        retval = V.extract (0, rank, A_nc-1, A_nc-1);
       else
-	retval.resize (A_nc, 0);
+        retval.resize (A_nc, 0);
 
       for (octave_idx_type i = 0; i < retval.numel (); i++)
-	if (std::abs (retval(i)) < DBL_EPSILON)
-	  retval(i) = 0;
+        if (std::abs (retval(i)) < DBL_EPSILON)
+          retval(i) = 0;
     }
 
   return retval;
 }
 
 static int
 qp (const Matrix& H, const ColumnVector& q,
     const Matrix& Aeq, const ColumnVector& beq,
@@ -116,27 +116,27 @@ qp (const Matrix& H, const ColumnVector&
   ColumnVector bact = beq;
   ColumnVector Wact;
 
   if (n_in > 0)
     {
       ColumnVector res = Ain*x - bin;
 
       for (octave_idx_type i = 0; i < n_in; i++)
-	{
-	  res(i) /= (1.0 + std::abs (bin(i)));
+        {
+          res(i) /= (1.0 + std::abs (bin(i)));
 
-	  if (res(i) < rtol)
-	    {
-	      n_act++;
-	      Aact = Aact.stack (Ain.row (i));
-	      bact.resize (n_act, bin(i));
-	      Wact.resize (n_act-n_eq, i);
-	    }
-	}
+          if (res(i) < rtol)
+            {
+              n_act++;
+              Aact = Aact.stack (Ain.row (i));
+              bact.resize (n_act, bin(i));
+              Wact.resize (n_act-n_eq, i);
+            }
+        }
     }
 
   // Computing the ???
 
   EIG eigH (H);
 
   if (error_state)
     {
@@ -146,20 +146,20 @@ qp (const Matrix& H, const ColumnVector&
 
   ColumnVector eigenvalH = real (eigH.eigenvalues ());
   Matrix eigenvecH = real (eigH.eigenvectors ());
   double minReal = eigenvalH.min ();
   octave_idx_type indminR = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (minReal == eigenvalH(i))
-	{
-	  indminR = i;
-	  break;
-	}
+        {
+          indminR = i;
+          break;
+        }
     }
 
   bool done = false;
 
   double alpha = 0.0;
 
   Matrix R;
   Matrix Y (n, 0, 0.0);
@@ -174,311 +174,311 @@ qp (const Matrix& H, const ColumnVector&
       iter++;
 
       // Current Gradient
       // g = q + H * x;
 
       g = q + H * x;
 
       if (n_act == 0)
-	{
-	  // There are no active constraints.
+        {
+          // There are no active constraints.
 
-	  if (minReal > 0.0)
-	    {
-	      // Inverting the Hessian.  Using the Cholesky
-	      // factorization since the Hessian is positive
-	      // definite.
+          if (minReal > 0.0)
+            {
+              // Inverting the Hessian.  Using the Cholesky
+              // factorization since the Hessian is positive
+              // definite.
 
-	      CHOL cholH (H);
+              CHOL cholH (H);
 
-	      R = cholH.chol_matrix ();
+              R = cholH.chol_matrix ();
 
-	      Matrix Hinv = chol2inv (R);
+              Matrix Hinv = chol2inv (R);
 
-	      // Computing the unconstrained step.
-	      // p = -Hinv * g;
+              // Computing the unconstrained step.
+              // p = -Hinv * g;
 
-	      p = -Hinv * g;
+              p = -Hinv * g;
 
-	      info = 0;
-	    }
-	  else
-	    {
-	      // Finding the negative curvature of H.
+              info = 0;
+            }
+          else
+            {
+              // Finding the negative curvature of H.
 
-	      p = eigenvecH.column (indminR);
+              p = eigenvecH.column (indminR);
 
-	      // Following the negative curvature of H.
+              // Following the negative curvature of H.
 
-	      if (p.transpose () * g > DBL_EPSILON)
-	        p = -p;
+              if (p.transpose () * g > DBL_EPSILON)
+                p = -p;
 
-	      info = 1;
-	    }
+              info = 1;
+            }
 
-	  // Multipliers are zero.
+          // Multipliers are zero.
           lambda_tmp.fill (0.0);
-	}
+        }
       else
         {
-	  // There are active constraints.
+          // There are active constraints.
 
-	  // Computing the null space.
+          // Computing the null space.
 
-	  octave_idx_type rank;
+          octave_idx_type rank;
 
-	  Matrix Z = null (Aact, rank);
+          Matrix Z = null (Aact, rank);
 
-	  octave_idx_type dimZ = n - rank;
+          octave_idx_type dimZ = n - rank;
 
-	  // FIXME -- still remain to handle the case of
-	  // non-full rank active set matrix.
+          // FIXME -- still remain to handle the case of
+          // non-full rank active set matrix.
 
-	  // Computing the Y matrix (orthogonal to Z)
-	  Y = Aact.pseudo_inverse ();
+          // Computing the Y matrix (orthogonal to Z)
+          Y = Aact.pseudo_inverse ();
 
-	  // Reduced Hessian
-	  Matrix Zt = Z.transpose ();
-	  Matrix rH = Zt * H * Z;
+          // Reduced Hessian
+          Matrix Zt = Z.transpose ();
+          Matrix rH = Zt * H * Z;
 
-	  octave_idx_type pR = 0;
+          octave_idx_type pR = 0;
 
-	  if (dimZ > 0)
-	    {
-	      // Computing the Cholesky factorization (pR = 0 means
-	      // that the reduced Hessian was positive definite).
+          if (dimZ > 0)
+            {
+              // Computing the Cholesky factorization (pR = 0 means
+              // that the reduced Hessian was positive definite).
 
-	      CHOL cholrH (rH, pR);
-	      Matrix tR = cholrH.chol_matrix ();
-	      if (pR == 0)
-		R = tR;
-	    }
+              CHOL cholrH (rH, pR);
+              Matrix tR = cholrH.chol_matrix ();
+              if (pR == 0)
+                R = tR;
+            }
 
-	  if (pR == 0)
-	    {
-	      info = 0;
+          if (pR == 0)
+            {
+              info = 0;
 
-	      // Computing the step pz. 
-	      if (dimZ > 0)
-		{
-		  // Using the Cholesky factorization to invert rH
+              // Computing the step pz. 
+              if (dimZ > 0)
+                {
+                  // Using the Cholesky factorization to invert rH
 
-		  Matrix rHinv = chol2inv (R);
+                  Matrix rHinv = chol2inv (R);
 
-		  ColumnVector pz = -rHinv * Zt * g;
+                  ColumnVector pz = -rHinv * Zt * g;
 
-		  // Global step.
-		  p = Z * pz;
-		}
-	      else
-		{
-		  // Global step.
-		  p.fill (0.0);
-		}
-	    }
-	  else
-	    {
-	      info = 1;
+                  // Global step.
+                  p = Z * pz;
+                }
+              else
+                {
+                  // Global step.
+                  p.fill (0.0);
+                }
+            }
+          else
+            {
+              info = 1;
 
-	      // Searching for the most negative curvature.
+              // Searching for the most negative curvature.
 
-	      EIG eigrH (rH);
+              EIG eigrH (rH);
 
-	      if (error_state)
-		{
-		  error ("qp: failed to compute eigenvalues of rH");
-		  return -1;
-		}
+              if (error_state)
+                {
+                  error ("qp: failed to compute eigenvalues of rH");
+                  return -1;
+                }
 
-	      ColumnVector eigenvalrH = real (eigrH.eigenvalues ());
-	      Matrix eigenvecrH = real (eigrH.eigenvectors ());
-	      double mRrH = eigenvalrH.min ();
-	      indminR = 0;
-	      for (octave_idx_type i = 0; i < n; i++)
-		{
-		  if (mRrH == eigenvalH(i))
-		    {
-		      indminR = i;
-		      break;
-		    }
-		}
+              ColumnVector eigenvalrH = real (eigrH.eigenvalues ());
+              Matrix eigenvecrH = real (eigrH.eigenvectors ());
+              double mRrH = eigenvalrH.min ();
+              indminR = 0;
+              for (octave_idx_type i = 0; i < n; i++)
+                {
+                  if (mRrH == eigenvalH(i))
+                    {
+                      indminR = i;
+                      break;
+                    }
+                }
 
-	      ColumnVector eVrH = eigenvecrH.column (indminR);
+              ColumnVector eVrH = eigenvecrH.column (indminR);
 
-	      // Computing the step pz.
-	      p = Z * eVrH;
+              // Computing the step pz.
+              p = Z * eVrH;
 
-	      if (p.transpose () * g > DBL_EPSILON)
-		p = -p;
-	    }
-	}
+              if (p.transpose () * g > DBL_EPSILON)
+                p = -p;
+            }
+        }
 
       // Checking the step-size.
       ColumnVector abs_p (n);
       for (octave_idx_type i = 0; i < n; i++)
-	abs_p(i) = std::abs (p(i));
+        abs_p(i) = std::abs (p(i));
       double max_p = abs_p.max ();
 
       if (max_p < rtol)
-	{
-	  // The step is null.  Checking constraints.
-	  if (n_act - n_eq == 0)
-	    // Solution is found because no inequality
-	    // constraints are active.
-	    done = true;
-	  else
-	    {
-	      // Computing the multipliers only for the inequality
-	      // constraints that are active.  We do NOT compute
-	      // multipliers for the equality constraints.
-	      Matrix Yt = Y.transpose ();
-	      Yt = Yt.extract_n (n_eq, 0, n_act-n_eq, n);
-	      lambda_tmp = Yt * (g + H * p);
+        {
+          // The step is null.  Checking constraints.
+          if (n_act - n_eq == 0)
+            // Solution is found because no inequality
+            // constraints are active.
+            done = true;
+          else
+            {
+              // Computing the multipliers only for the inequality
+              // constraints that are active.  We do NOT compute
+              // multipliers for the equality constraints.
+              Matrix Yt = Y.transpose ();
+              Yt = Yt.extract_n (n_eq, 0, n_act-n_eq, n);
+              lambda_tmp = Yt * (g + H * p);
 
-	      // Checking the multipliers.  We remove the most
-	      // negative from the set (if any).
-	      double min_lambda = lambda_tmp.min ();
-	      if (min_lambda >= 0)
-		{
-		  // Solution is found.
-		  done = true;
-		}
-	      else
-		{
-		  octave_idx_type which_eig = 0;
-		  for (octave_idx_type i = 0; i < n_act; i++)
-		    {
-		      if (lambda_tmp(i) == min_lambda)
-			{
-			  which_eig = i;
-			  break;
-			}
-		    }
+              // Checking the multipliers.  We remove the most
+              // negative from the set (if any).
+              double min_lambda = lambda_tmp.min ();
+              if (min_lambda >= 0)
+                {
+                  // Solution is found.
+                  done = true;
+                }
+              else
+                {
+                  octave_idx_type which_eig = 0;
+                  for (octave_idx_type i = 0; i < n_act; i++)
+                    {
+                      if (lambda_tmp(i) == min_lambda)
+                        {
+                          which_eig = i;
+                          break;
+                        }
+                    }
 
-		  // At least one multiplier is negative, we
-		  // remove it from the set.
+                  // At least one multiplier is negative, we
+                  // remove it from the set.
 
-		  n_act--;
-		  for (octave_idx_type i = which_eig; i < n_act - n_eq; i++)
-		    {
-		      Wact(i) = Wact(i+1);
-		      for (octave_idx_type j = 0; j < n; j++)
-			Aact(n_eq+i,j) = Aact(n_eq+i+1,j);
-		      bact(n_eq+i) = bact(n_eq+i+1);
-		    }
+                  n_act--;
+                  for (octave_idx_type i = which_eig; i < n_act - n_eq; i++)
+                    {
+                      Wact(i) = Wact(i+1);
+                      for (octave_idx_type j = 0; j < n; j++)
+                        Aact(n_eq+i,j) = Aact(n_eq+i+1,j);
+                      bact(n_eq+i) = bact(n_eq+i+1);
+                    }
 
-		  // Resizing the active set.
-		  Wact.resize (n_act-n_eq);
-		  bact.resize (n_act);
-		  Aact.resize (n_act, n);
-		}
-	    }
-	}
+                  // Resizing the active set.
+                  Wact.resize (n_act-n_eq);
+                  bact.resize (n_act);
+                  Aact.resize (n_act, n);
+                }
+            }
+        }
       else
-	{
-	  // The step is not null.
-	  if (n_act - n_eq == n_in)
-	    {
-	      // All inequality constraints were active.  We can
-	      // add the whole step.
-	      x += p;
-	    }
-	  else
-	    {
-	      // Some constraints were not active.  Checking if
-	      // there is a blocking constraint.
-	      alpha = 1.0;
-	      octave_idx_type is_block = -1;
+        {
+          // The step is not null.
+          if (n_act - n_eq == n_in)
+            {
+              // All inequality constraints were active.  We can
+              // add the whole step.
+              x += p;
+            }
+          else
+            {
+              // Some constraints were not active.  Checking if
+              // there is a blocking constraint.
+              alpha = 1.0;
+              octave_idx_type is_block = -1;
 
-	      for (octave_idx_type i = 0; i < n_in; i++)
-		{
-		  bool found = false;
+              for (octave_idx_type i = 0; i < n_in; i++)
+                {
+                  bool found = false;
 
-		  for (octave_idx_type j = 0; j < n_act-n_eq; j++)
-		    {
-		      if (Wact(j) == i)
-			{
-			  found = true;
-			  break;
-			}
-		    }
+                  for (octave_idx_type j = 0; j < n_act-n_eq; j++)
+                    {
+                      if (Wact(j) == i)
+                        {
+                          found = true;
+                          break;
+                        }
+                    }
 
-		  if (! found)
-		    {
-		      // The i-th constraint was not in the set.  Is it a
-		      // blocking constraint?
+                  if (! found)
+                    {
+                      // The i-th constraint was not in the set.  Is it a
+                      // blocking constraint?
 
-		      RowVector tmp_row = Ain.row (i);
-		      double tmp = tmp_row * p;
-		      double res = tmp_row * x;
+                      RowVector tmp_row = Ain.row (i);
+                      double tmp = tmp_row * p;
+                      double res = tmp_row * x;
 
-		      if (tmp < 0.0)
-		        {
-			  double alpha_tmp = (bin(i) - res) / tmp;
+                      if (tmp < 0.0)
+                        {
+                          double alpha_tmp = (bin(i) - res) / tmp;
 
-			  if (alpha_tmp < alpha)
-			    {
-			      alpha = alpha_tmp;
-			      is_block = i;
-			    }
-			}
-		    }
-		}
+                          if (alpha_tmp < alpha)
+                            {
+                              alpha = alpha_tmp;
+                              is_block = i;
+                            }
+                        }
+                    }
+                }
 
-	      // In is_block there is the index of the blocking
-	      // constraint (if any).
-	      if (is_block >= 0)
-		{
-		  // There is a blocking constraint (index in
-		  // is_block) which is added to the active set.
-		  n_act++;
-		  Aact = Aact.stack (Ain.row (is_block));
-		  bact.resize (n_act, bin(is_block));
-		  Wact.resize (n_act-n_eq, is_block);
+              // In is_block there is the index of the blocking
+              // constraint (if any).
+              if (is_block >= 0)
+                {
+                  // There is a blocking constraint (index in
+                  // is_block) which is added to the active set.
+                  n_act++;
+                  Aact = Aact.stack (Ain.row (is_block));
+                  bact.resize (n_act, bin(is_block));
+                  Wact.resize (n_act-n_eq, is_block);
 
-		  // Adding the reduced step
-		  x += alpha * p;
-		}
-	      else
-		{
-		  // There are no blocking constraints.  Adding the
-		  // whole step.
-		  x += alpha * p;
-		}
-	    }
-	}
+                  // Adding the reduced step
+                  x += alpha * p;
+                }
+              else
+                {
+                  // There are no blocking constraints.  Adding the
+                  // whole step.
+                  x += alpha * p;
+                }
+            }
+        }
 
       if (iter == maxit)
-	{
-	  done = true;
-	  // warning ("qp_main: maximum number of iteration reached");
-	  info = 3;
-	}
+        {
+          done = true;
+          // warning ("qp_main: maximum number of iteration reached");
+          info = 3;
+        }
     }
 
   lambda_tmp = Y.transpose () * (g + H * p);
 
   // Reordering the Lagrange multipliers.
 
   lambda.resize (n_tot);
   lambda.fill (0.0);
   for (octave_idx_type i = 0; i < n_eq; i++)
     lambda(i) = lambda_tmp(i);
 
   for (octave_idx_type i = n_eq; i < n_tot; i++)
     {
       for (octave_idx_type j = 0; j < n_act-n_eq; j++)
-	{
-	  if (Wact(j) == i - n_eq)
-	    {
-	      lambda(i) = lambda_tmp(n_eq+j);
-	      break;
-	    }
-	}
+        {
+          if (Wact(j) == i - n_eq)
+            {
+              lambda(i) = lambda_tmp(n_eq+j);
+              break;
+            }
+        }
     }
 
   return info;
 }
 
 DEFUN_DLD (__qp__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
@@ -494,37 +494,37 @@ Undocumented internal function.\n\
       const ColumnVector q   (args(2) . vector_value ());
       const Matrix Aeq       (args(3) . matrix_value ());
       const ColumnVector beq (args(4) . vector_value ());
       const Matrix Ain       (args(5) . matrix_value ());
       const ColumnVector bin (args(6) . vector_value ());
       const int maxit        (args(7) . int_value ());
 
       if (! error_state)
-	{
-	  int iter = 0;
+        {
+          int iter = 0;
 
-	  // Copying the initial guess in the working variable
-	  ColumnVector x = x0;
+          // Copying the initial guess in the working variable
+          ColumnVector x = x0;
 
-	  // Reordering the Lagrange multipliers
-	  ColumnVector lambda;
+          // Reordering the Lagrange multipliers
+          ColumnVector lambda;
 
-	  int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
+          int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
 
-	  if (! error_state)
-	    {
-	      retval(3) = iter;
-	      retval(2) = info;
-	      retval(1) = lambda;
-	      retval(0) = x;
-	    }
-	  else
-	    error ("qp: internal error");
-	}
+          if (! error_state)
+            {
+              retval(3) = iter;
+              retval(2) = info;
+              retval(1) = lambda;
+              retval(0) = x;
+            }
+          else
+            error ("qp: internal error");
+        }
       else
-	error ("__qp__: invalid arguments");
+        error ("__qp__: invalid arguments");
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -73,20 +73,20 @@ Undocumented internal function.\n\
       return retval;
     }
 
   const char *options;
 
   if (nargin == 2) 
     {
       if (! args (1).is_string ()) 
-	{
-	  error ("__voronoi__: second argument must be a string");
-	  return retval;
-	}
+        {
+          error ("__voronoi__: second argument must be a string");
+          return retval;
+        }
 
       options = args (1).string_value().c_str ();
     }
   else
     options = "";
 
   Matrix p (args(0).matrix_value ());
 
@@ -95,19 +95,19 @@ Undocumented internal function.\n\
   p = p.transpose ();
 
   double *pt_array = p.fortran_vec ();
 
   //double  pt_array[dim * np];
   //for (int i = 0; i < np; i++) 
   //  {
   //    for (int j = 0; j < dim; j++)
-  //	  {
-  //	    pt_array[j+i*dim] = p(i,j);
-  //	  }
+  //      {
+  //        pt_array[j+i*dim] = p(i,j);
+  //      }
   //  }
 
   boolT ismalloc = false;
 
   OCTAVE_LOCAL_BUFFER (char, flags, 250);
 
   // hmm  lot's of options for qhull here
   sprintf (flags, "qhull v Fv T0 %s", options);
@@ -122,127 +122,127 @@ Undocumented internal function.\n\
     {
       facetT *facet;
       vertexT *vertex;
 
       octave_idx_type i = 0, n = 1, k = 0, m = 0, fidx = 0, j = 0, r = 0;
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ni, np);
       
       for (i = 0; i < np; i++) 
-	ni[i] = 0;
+        ni[i] = 0;
       qh_setvoronoi_all ();
       bool infinity_seen = false;
       facetT *neighbor, **neighborp;
       coordT *voronoi_vertex;
 
       FORALLfacets 
-	{
-	  facet->seen = false;
-	}
+        {
+          facet->seen = false;
+        }
 
       FORALLvertices 
-	{
-	  if (qh hull_dim == 3)
-	    qh_order_vertexneighbors (vertex);
-	  infinity_seen = false;
+        {
+          if (qh hull_dim == 3)
+            qh_order_vertexneighbors (vertex);
+          infinity_seen = false;
 
-	  FOREACHneighbor_ (vertex)
-	    {
-	      if (! neighbor->upperdelaunay)
-		{
-		  if (! neighbor->seen)
-		    {
-		      n++;
-		      neighbor->seen = true;
-		    }
-		  ni[k]++;
-		}
-	      else if (! infinity_seen)
-		{
-		  infinity_seen = true;
-		  ni[k]++;
-		}
-	    }
-	  k++;
-	}
+          FOREACHneighbor_ (vertex)
+            {
+              if (! neighbor->upperdelaunay)
+                {
+                  if (! neighbor->seen)
+                    {
+                      n++;
+                      neighbor->seen = true;
+                    }
+                  ni[k]++;
+                }
+              else if (! infinity_seen)
+                {
+                  infinity_seen = true;
+                  ni[k]++;
+                }
+            }
+          k++;
+        }
 
       Matrix v (n, dim);
       for (octave_idx_type d = 0; d < dim; d++)
-	v(0,d) = octave_Inf;
+        v(0,d) = octave_Inf;
 
       boolMatrix AtInf (np, 1);
       for (i = 0; i < np; i++) 
-	AtInf(i) = false;
+        AtInf(i) = false;
       octave_value_list F (np, octave_value ());
       k = 0;
       i = 0;
 
       FORALLfacets 
-	{
-	  facet->seen = false;
-	}
+        {
+          facet->seen = false;
+        }
 
       FORALLvertices
-	{
-	  if (qh hull_dim == 3)
-	    qh_order_vertexneighbors(vertex);
-	  infinity_seen = false;
-	  RowVector facet_list (ni[k++]);
-	  m = 0;
+        {
+          if (qh hull_dim == 3)
+            qh_order_vertexneighbors(vertex);
+          infinity_seen = false;
+          RowVector facet_list (ni[k++]);
+          m = 0;
 
-	  FOREACHneighbor_(vertex)
-	    {
-	      if (neighbor->upperdelaunay)
-		{
-		  if (! infinity_seen)
-		    {
-		      infinity_seen = true;
-		      facet_list(m++) = 1;
-		      AtInf(j) = true;
-		    }
-		} 
-	      else 
-		{
-		  if (! neighbor->seen)
-		    {
-		      voronoi_vertex = neighbor->center;
-		      fidx = neighbor->id;
-		      i++;
-		      for (octave_idx_type d = 0; d < dim; d++)
-			{
-			  v(i,d) = *(voronoi_vertex++);
-			}
-		      neighbor->seen = true;
-		      neighbor->visitid = i;
-		    }
-		  facet_list(m++) = neighbor->visitid + 1;
-		}
-	    }
-	  F(r++) = facet_list;
-	  j++;
-	}
+          FOREACHneighbor_(vertex)
+            {
+              if (neighbor->upperdelaunay)
+                {
+                  if (! infinity_seen)
+                    {
+                      infinity_seen = true;
+                      facet_list(m++) = 1;
+                      AtInf(j) = true;
+                    }
+                } 
+              else 
+                {
+                  if (! neighbor->seen)
+                    {
+                      voronoi_vertex = neighbor->center;
+                      fidx = neighbor->id;
+                      i++;
+                      for (octave_idx_type d = 0; d < dim; d++)
+                        {
+                          v(i,d) = *(voronoi_vertex++);
+                        }
+                      neighbor->seen = true;
+                      neighbor->visitid = i;
+                    }
+                  facet_list(m++) = neighbor->visitid + 1;
+                }
+            }
+          F(r++) = facet_list;
+          j++;
+        }
 
       Cell C(r, 1);
       for (i = 0; i < r; i++)
-	C.elem (i) = F(i);
+        C.elem (i) = F(i);
 
       retval(0) = v;
       retval(1) = C;
       AtInf.resize (r, 1);
       retval(2) = AtInf;
 
       // free long memory
       qh_freeqhull (! qh_ALL);
 
       // free short memory and memory allocator
       int curlong, totlong;
       qh_memfreeshort (&curlong, &totlong);
 
       if (curlong || totlong)
-	warning ("__voronoi__: did not free %d bytes of long memory (%d pieces)", totlong, curlong);
+        warning ("__voronoi__: did not free %d bytes of long memory (%d pieces)", totlong, curlong);
     }
   else
     error ("__voronoi__: qhull failed");
 
 #else
   error ("__voronoi__: not available in this version of Octave");
 #endif
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -92,121 +92,121 @@ University of Florida (see @url{http://w
   else
     {
       octave_idx_type n_row, n_col, nnz;
       const octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      scm = args(0).sparse_complex_matrix_value ();
-	      n_row = scm.rows ();
-	      n_col = scm.cols ();
-	      nnz = scm.nzmax ();
-	      ridx = scm.xridx ();
-	      cidx = scm.xcidx ();
-	    }
-	  else
-	    {
-	      sm = args(0).sparse_matrix_value ();
-	      n_row = sm.rows ();
-	      n_col = sm.cols ();
-	      nnz = sm.nzmax ();
-	      ridx = sm.xridx ();
-	      cidx = sm.xcidx ();
-	    }
-	}
+        {
+          if (args(0).is_complex_type ())
+            {
+              scm = args(0).sparse_complex_matrix_value ();
+              n_row = scm.rows ();
+              n_col = scm.cols ();
+              nnz = scm.nzmax ();
+              ridx = scm.xridx ();
+              cidx = scm.xcidx ();
+            }
+          else
+            {
+              sm = args(0).sparse_matrix_value ();
+              n_row = sm.rows ();
+              n_col = sm.cols ();
+              nnz = sm.nzmax ();
+              ridx = sm.xridx ();
+              cidx = sm.xcidx ();
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type ())
-	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-	  else
-	    sm = SparseMatrix (args(0).matrix_value ());
-	  
-	  n_row = sm.rows ();
-	  n_col = sm.cols ();
-	  nnz = sm.nzmax ();
-	  ridx = sm.xridx ();
-	  cidx = sm.xcidx ();
-	}
+        {
+          if (args(0).is_complex_type ())
+            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+          else
+            sm = SparseMatrix (args(0).matrix_value ());
+          
+          n_row = sm.rows ();
+          n_col = sm.cols ();
+          nnz = sm.nzmax ();
+          ridx = sm.xridx ();
+          cidx = sm.xcidx ();
+        }
 
       if (!error_state && n_row != n_col)
-	error ("amd: input matrix must be square");
+        error ("amd: input matrix must be square");
 
       if (!error_state)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
-	  AMD_NAME (_defaults) (Control) ;
-	  if (nargin > 1)
-	    {
-	      Octave_map arg1 = args(1).map_value ();
-	  
-	      if (!error_state)
-		{
-		  if (arg1.contains ("dense"))
-		    {
-		      Cell c = arg1.contents ("dense");
-		      if (c.length() == 1)
-			Control[AMD_DENSE] = c.elem(0).double_value ();
-		      else
-			error ("amd: invalid options structure");
-		    }
-		  if (arg1.contains ("aggressive"))
-		    {
-		      Cell c = arg1.contents ("aggressive");
-		      if (c.length() == 1)
-			Control[AMD_AGGRESSIVE] = c.elem(0).double_value ();
-		      else
-			error ("amd: invalid options structure");
-		    }
-		}
-	    }
+        {
+          OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
+          AMD_NAME (_defaults) (Control) ;
+          if (nargin > 1)
+            {
+              Octave_map arg1 = args(1).map_value ();
+          
+              if (!error_state)
+                {
+                  if (arg1.contains ("dense"))
+                    {
+                      Cell c = arg1.contents ("dense");
+                      if (c.length() == 1)
+                        Control[AMD_DENSE] = c.elem(0).double_value ();
+                      else
+                        error ("amd: invalid options structure");
+                    }
+                  if (arg1.contains ("aggressive"))
+                    {
+                      Cell c = arg1.contents ("aggressive");
+                      if (c.length() == 1)
+                        Control[AMD_AGGRESSIVE] = c.elem(0).double_value ();
+                      else
+                        error ("amd: invalid options structure");
+                    }
+                }
+            }
 
-	  if (!error_state)
-	    {
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
-	      Matrix xinfo (AMD_INFO, 1);
-	      double *Info = xinfo.fortran_vec ();
+          if (!error_state)
+            {
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
+              Matrix xinfo (AMD_INFO, 1);
+              double *Info = xinfo.fortran_vec ();
 
-	      // FIXME -- how can we manage the memory allocation of
-	      // amd in a cleaner manner? 
-	      amd_malloc = malloc;
-	      amd_free = free;
-	      amd_calloc = calloc;
-	      amd_realloc = realloc;
-	      amd_printf = printf;
+              // FIXME -- how can we manage the memory allocation of
+              // amd in a cleaner manner? 
+              amd_malloc = malloc;
+              amd_free = free;
+              amd_calloc = calloc;
+              amd_realloc = realloc;
+              amd_printf = printf;
 
-	      octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
-							  Control, Info);
+              octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
+                                                          Control, Info);
 
-	      switch (result)
-		{
-		case AMD_OUT_OF_MEMORY:
-		  error ("amd: out of memory");
-		  break;
-		case AMD_INVALID:
-		  error ("amd: input matrix is corrupted");
-		  break;
-		default:
-		  {
-		    if (nargout > 1)
-		      retval(1) = xinfo;
+              switch (result)
+                {
+                case AMD_OUT_OF_MEMORY:
+                  error ("amd: out of memory");
+                  break;
+                case AMD_INVALID:
+                  error ("amd: input matrix is corrupted");
+                  break;
+                default:
+                  {
+                    if (nargout > 1)
+                      retval(1) = xinfo;
 
-		    Matrix Pout (1, n_col);
-		    for (octave_idx_type i = 0; i < n_col; i++)
-		      Pout.xelem (i) = P[i] + 1;
+                    Matrix Pout (1, n_col);
+                    for (octave_idx_type i = 0; i < n_col; i++)
+                      Pout.xelem (i) = P[i] + 1;
 
-		    retval (0) = Pout;
-		  }
-		}
-	    }
-	}
+                    retval (0) = Pout;
+                  }
+                }
+            }
+        }
     }
 #else
 
   error ("amd: not available in this version of Octave");
 
 #endif
 
   return retval;
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -109,37 +109,37 @@ Generalized eigenvalue problem balancing
       gripe_square_matrix_required ("balance");
       return retval;
     }
 
   bool isfloat = args(0).is_single_type () || 
     (! AEPcase && args(1).is_single_type()); 
 
   bool complex_case = (args(0).is_complex_type () || 
-		       (! AEPcase && args(1).is_complex_type ()));
+                       (! AEPcase && args(1).is_complex_type ()));
 
   // Extract argument 1 parameter for both AEP and GEP.
   Matrix aa;
   ComplexMatrix caa;
   FloatMatrix faa;
   FloatComplexMatrix fcaa;
 
   if (isfloat)
     {
       if (complex_case)
-	fcaa = args(0).float_complex_matrix_value ();
+        fcaa = args(0).float_complex_matrix_value ();
       else
-	faa = args(0).float_matrix_value ();
+        faa = args(0).float_matrix_value ();
     }
   else
     {
       if (complex_case)
-	caa = args(0).complex_matrix_value ();
+        caa = args(0).complex_matrix_value ();
       else
-	aa = args(0).matrix_value ();
+        aa = args(0).matrix_value ();
     }
 
   if (error_state)
     return retval;
 
   // Treat AEP/GEP cases.
   if (AEPcase)
     {  
@@ -149,245 +149,245 @@ Generalized eigenvalue problem balancing
         {
           std::string a1s = args(1).string_value ();
           noperm = a1s == "noperm" || a1s == "S";
           noscal = a1s == "noscal" || a1s == "P";
         }
 
       // balance the AEP
       if (isfloat)
-	{
-	  if (complex_case)
-	    {
-	      FloatComplexAEPBALANCE result (fcaa, noperm, noscal);
+        {
+          if (complex_case)
+            {
+              FloatComplexAEPBALANCE result (fcaa, noperm, noscal);
 
-	      if (nargout == 0 || nargout == 1)
-		retval(0) = result.balanced_matrix ();
-	      else if (nargout == 2)
-		{
-		  retval(1) = result.balanced_matrix ();
-		  retval(0) = result.balancing_matrix ();
-		}
+              if (nargout == 0 || nargout == 1)
+                retval(0) = result.balanced_matrix ();
+              else if (nargout == 2)
+                {
+                  retval(1) = result.balanced_matrix ();
+                  retval(0) = result.balancing_matrix ();
+                }
               else
                 {
                   retval(2) = result.balanced_matrix ();
                   retval(0) = result.scaling_vector ();
                   retval(1) = result.permuting_vector ();
                 }
 
-	    }
-	  else
-	    {
-	      FloatAEPBALANCE result (faa, noperm, noscal);
+            }
+          else
+            {
+              FloatAEPBALANCE result (faa, noperm, noscal);
 
-	      if (nargout == 0 || nargout == 1)
-		retval(0) = result.balanced_matrix ();
-	      else if (nargout == 2)
-		{
-		  retval(1) = result.balanced_matrix ();
-		  retval(0) = result.balancing_matrix ();
-		}
+              if (nargout == 0 || nargout == 1)
+                retval(0) = result.balanced_matrix ();
+              else if (nargout == 2)
+                {
+                  retval(1) = result.balanced_matrix ();
+                  retval(0) = result.balancing_matrix ();
+                }
               else
                 {
                   retval(2) = result.balanced_matrix ();
                   retval(0) = result.scaling_vector ();
                   retval(1) = result.permuting_vector ();
                 }
-	    }
-	}
+            }
+        }
       else
-	{
-	  if (complex_case)
-	    {
-	      ComplexAEPBALANCE result (caa, noperm, noscal);
+        {
+          if (complex_case)
+            {
+              ComplexAEPBALANCE result (caa, noperm, noscal);
 
-	      if (nargout == 0 || nargout == 1)
-		retval(0) = result.balanced_matrix ();
-	      else if (nargout == 2)
-		{
-		  retval(1) = result.balanced_matrix ();
-		  retval(0) = result.balancing_matrix ();
-		}
+              if (nargout == 0 || nargout == 1)
+                retval(0) = result.balanced_matrix ();
+              else if (nargout == 2)
+                {
+                  retval(1) = result.balanced_matrix ();
+                  retval(0) = result.balancing_matrix ();
+                }
               else
                 {
                   retval(2) = result.balanced_matrix ();
                   retval(0) = result.scaling_vector ();
                   retval(1) = result.permuting_vector ();
                 }
-	    }
-	  else
-	    {
-	      AEPBALANCE result (aa, noperm, noscal);
+            }
+          else
+            {
+              AEPBALANCE result (aa, noperm, noscal);
 
-	      if (nargout == 0 || nargout == 1)
-		retval(0) = result.balanced_matrix ();
-	      else if (nargout == 2)
-		{
-		  retval(1) = result.balanced_matrix ();
-		  retval(0) = result.balancing_matrix ();
-		}
+              if (nargout == 0 || nargout == 1)
+                retval(0) = result.balanced_matrix ();
+              else if (nargout == 2)
+                {
+                  retval(1) = result.balanced_matrix ();
+                  retval(0) = result.balancing_matrix ();
+                }
               else
                 {
                   retval(2) = result.balanced_matrix ();
                   retval(0) = result.scaling_vector ();
                   retval(1) = result.permuting_vector ();
                 }
-	    }
-	}
+            }
+        }
     }
   else
     {
       std::string bal_job;
       if (nargout == 1)
-	warning ("balance: used GEP, should have two output arguments");
+        warning ("balance: used GEP, should have two output arguments");
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
-	bal_job = "B";
+        bal_job = "B";
       else if (args(2).is_string ())
-	bal_job = args(2).string_value ();
+        bal_job = args(2).string_value ();
       else
-	{
-	  error ("balance: GEP argument 3 must be a string");
-	  return retval;
-	}
+        {
+          error ("balance: GEP argument 3 must be a string");
+          return retval;
+        }
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
-	{
-	  gripe_nonconformant ();
-	  return retval;
-	}
+        {
+          gripe_nonconformant ();
+          return retval;
+        }
 
       Matrix bb;
       ComplexMatrix cbb;
       FloatMatrix fbb;
       FloatComplexMatrix fcbb;
 
       if (isfloat)
-	{
-	  if (complex_case)
-	    fcbb = args(1).float_complex_matrix_value ();
-	  else
-	    fbb = args(1).float_matrix_value ();
-	}
+        {
+          if (complex_case)
+            fcbb = args(1).float_complex_matrix_value ();
+          else
+            fbb = args(1).float_matrix_value ();
+        }
       else
-	{
-	  if (complex_case)
-	    cbb = args(1).complex_matrix_value ();
-	  else
-	    bb = args(1).matrix_value ();
-	}
+        {
+          if (complex_case)
+            cbb = args(1).complex_matrix_value ();
+          else
+            bb = args(1).matrix_value ();
+        }
 
       // balance the GEP
       if (isfloat)
-	{
-	  if (complex_case)
-	    {
-	      FloatComplexGEPBALANCE result (fcaa, fcbb, bal_job);
+        {
+          if (complex_case)
+            {
+              FloatComplexGEPBALANCE result (fcaa, fcbb, bal_job);
 
-	      switch (nargout)
-		{
-		case 4:
-		  retval(3) = result.balanced_matrix2 ();
-		  // fall through
-		case 3:
-		  retval(2) = result.balanced_matrix ();
-		  retval(1) = result.balancing_matrix2 ();
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		case 2:
-		  retval(1) = result.balancing_matrix2 ();
-		  // fall through
-		case 1:
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		default:
-		  error ("balance: invalid number of output arguments");
-		  break;
-		}
-	    }
-	  else
-	    {
-	      FloatGEPBALANCE result (faa, fbb, bal_job);
+              switch (nargout)
+                {
+                case 4:
+                  retval(3) = result.balanced_matrix2 ();
+                  // fall through
+                case 3:
+                  retval(2) = result.balanced_matrix ();
+                  retval(1) = result.balancing_matrix2 ();
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                case 2:
+                  retval(1) = result.balancing_matrix2 ();
+                  // fall through
+                case 1:
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                default:
+                  error ("balance: invalid number of output arguments");
+                  break;
+                }
+            }
+          else
+            {
+              FloatGEPBALANCE result (faa, fbb, bal_job);
 
-	      switch (nargout)
-		{
-		case 4:
-		  retval(3) = result.balanced_matrix2 ();
-		  // fall through
-		case 3:
-		  retval(2) = result.balanced_matrix ();
-		  retval(1) = result.balancing_matrix2 ();
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		case 2:
-		  retval(1) = result.balancing_matrix2 ();
-		  // fall through
-		case 1:
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		default:
-		  error ("balance: invalid number of output arguments");
-		  break;
-		}
-	    }
-	}
+              switch (nargout)
+                {
+                case 4:
+                  retval(3) = result.balanced_matrix2 ();
+                  // fall through
+                case 3:
+                  retval(2) = result.balanced_matrix ();
+                  retval(1) = result.balancing_matrix2 ();
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                case 2:
+                  retval(1) = result.balancing_matrix2 ();
+                  // fall through
+                case 1:
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                default:
+                  error ("balance: invalid number of output arguments");
+                  break;
+                }
+            }
+        }
       else
-	{
-	  if (complex_case)
-	    {
-	      ComplexGEPBALANCE result (caa, cbb, bal_job);
+        {
+          if (complex_case)
+            {
+              ComplexGEPBALANCE result (caa, cbb, bal_job);
 
-	      switch (nargout)
-		{
-		case 4:
-		  retval(3) = result.balanced_matrix2 ();
-		  // fall through
-		case 3:
-		  retval(2) = result.balanced_matrix ();
-		  retval(1) = result.balancing_matrix2 ();
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		case 2:
-		  retval(1) = result.balancing_matrix2 ();
-		  // fall through
-		case 1:
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		default:
-		  error ("balance: invalid number of output arguments");
-		  break;
-		}
-	    }
-	  else
-	    {
-	      GEPBALANCE result (aa, bb, bal_job);
+              switch (nargout)
+                {
+                case 4:
+                  retval(3) = result.balanced_matrix2 ();
+                  // fall through
+                case 3:
+                  retval(2) = result.balanced_matrix ();
+                  retval(1) = result.balancing_matrix2 ();
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                case 2:
+                  retval(1) = result.balancing_matrix2 ();
+                  // fall through
+                case 1:
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                default:
+                  error ("balance: invalid number of output arguments");
+                  break;
+                }
+            }
+          else
+            {
+              GEPBALANCE result (aa, bb, bal_job);
 
-	      switch (nargout)
-		{
-		case 4:
-		  retval(3) = result.balanced_matrix2 ();
-		  // fall through
-		case 3:
-		  retval(2) = result.balanced_matrix ();
-		  retval(1) = result.balancing_matrix2 ();
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		case 2:
-		  retval(1) = result.balancing_matrix2 ();
-		  // fall through
-		case 1:
-		  retval(0) = result.balancing_matrix ();
-		  break;
-		default:
-		  error ("balance: invalid number of output arguments");
-		  break;
-		}
-	    }
-	}
+              switch (nargout)
+                {
+                case 4:
+                  retval(3) = result.balanced_matrix2 ();
+                  // fall through
+                case 3:
+                  retval(2) = result.balanced_matrix ();
+                  retval(1) = result.balancing_matrix2 ();
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                case 2:
+                  retval(1) = result.balancing_matrix2 ();
+                  // fall through
+                case 1:
+                  retval(0) = result.balancing_matrix ();
+                  break;
+                default:
+                  error ("balance: invalid number of output arguments");
+                  break;
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -43,338 +43,338 @@ enum bessel_type
   BESSEL_H1,
   BESSEL_H2
 };
 
 #define DO_BESSEL(type, alpha, x, scaled, ierr, result) \
   do \
     { \
       switch (type) \
-	{ \
-	  case BESSEL_J: \
-	    result = besselj (alpha, x, scaled, ierr); \
-	    break; \
+        { \
+          case BESSEL_J: \
+            result = besselj (alpha, x, scaled, ierr); \
+            break; \
  \
-	  case BESSEL_Y: \
-	    result = bessely (alpha, x, scaled, ierr); \
-	    break; \
+          case BESSEL_Y: \
+            result = bessely (alpha, x, scaled, ierr); \
+            break; \
  \
-	  case BESSEL_I: \
-	    result = besseli (alpha, x, scaled, ierr); \
-	    break; \
+          case BESSEL_I: \
+            result = besseli (alpha, x, scaled, ierr); \
+            break; \
  \
-	  case BESSEL_K: \
-	    result = besselk (alpha, x, scaled, ierr); \
-	    break; \
+          case BESSEL_K: \
+            result = besselk (alpha, x, scaled, ierr); \
+            break; \
  \
-	  case BESSEL_H1: \
-	    result = besselh1 (alpha, x, scaled, ierr); \
-	    break; \
+          case BESSEL_H1: \
+            result = besselh1 (alpha, x, scaled, ierr); \
+            break; \
  \
-	  case BESSEL_H2: \
-	    result = besselh2 (alpha, x, scaled, ierr); \
-	    break; \
+          case BESSEL_H2: \
+            result = besselh2 (alpha, x, scaled, ierr); \
+            break; \
  \
-	  default: \
-	    break; \
+          default: \
+            break; \
         } \
     } \
   while (0)
 
 static void
 gripe_bessel_arg (const char *fn, const char *arg)
 {
   error ("%s: expecting scalar or matrix as %s argument", fn, arg);
 }
 
 octave_value_list
 do_bessel (enum bessel_type type, const char *fn,
-	   const octave_value_list& args, int nargout)
+           const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       bool scaled = (nargin == 3);
 
       octave_value alpha_arg = args(0);
       octave_value x_arg = args(1);
 
       if (alpha_arg.is_single_type () || x_arg.is_single_type ())
-	{
-	  if (alpha_arg.is_scalar_type ())
-	    {
-	      float alpha = args(0).float_value ();
+        {
+          if (alpha_arg.is_scalar_type ())
+            {
+              float alpha = args(0).float_value ();
 
-	      if (! error_state)
-		{
-		  if (x_arg.is_scalar_type ())
-		    {
-		      FloatComplex x = x_arg.float_complex_value ();
+              if (! error_state)
+                {
+                  if (x_arg.is_scalar_type ())
+                    {
+                      FloatComplex x = x_arg.float_complex_value ();
 
-		      if (! error_state)
-			{
-			  octave_idx_type ierr;
-			  octave_value result;
+                      if (! error_state)
+                        {
+                          octave_idx_type ierr;
+                          octave_value result;
 
-			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-			  if (nargout > 1)
-			    retval(1) = static_cast<float> (ierr);
+                          if (nargout > 1)
+                            retval(1) = static_cast<float> (ierr);
 
-			  retval(0) = result;
-			}
-		      else
-			gripe_bessel_arg (fn, "second");
-		    }
-		  else
-		    {
-		      FloatComplexNDArray x = x_arg.float_complex_array_value ();
+                          retval(0) = result;
+                        }
+                      else
+                        gripe_bessel_arg (fn, "second");
+                    }
+                  else
+                    {
+                      FloatComplexNDArray x = x_arg.float_complex_array_value ();
 
-		      if (! error_state)
-			{
-			  Array<octave_idx_type> ierr;
-			  octave_value result;
+                      if (! error_state)
+                        {
+                          Array<octave_idx_type> ierr;
+                          octave_value result;
 
-			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-			  if (nargout > 1)
-			    retval(1) = NDArray (ierr);
+                          if (nargout > 1)
+                            retval(1) = NDArray (ierr);
 
-			  retval(0) = result;
-			}
-		      else
-			gripe_bessel_arg (fn, "second");
-		    }
-		}
-	      else
-		gripe_bessel_arg (fn, "first");
-	    }
-	  else
-	    {
-	      dim_vector dv0 = args(0).dims ();
-	      dim_vector dv1 = args(1).dims ();
+                          retval(0) = result;
+                        }
+                      else
+                        gripe_bessel_arg (fn, "second");
+                    }
+                }
+              else
+                gripe_bessel_arg (fn, "first");
+            }
+          else
+            {
+              dim_vector dv0 = args(0).dims ();
+              dim_vector dv1 = args(1).dims ();
 
-	      bool args0_is_row_vector = (dv0 (1) == dv0.numel ());
-	      bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
+              bool args0_is_row_vector = (dv0 (1) == dv0.numel ());
+              bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
 
-	      if (args0_is_row_vector && args1_is_col_vector)
-		{
-		  FloatRowVector ralpha = args(0).float_row_vector_value ();
+              if (args0_is_row_vector && args1_is_col_vector)
+                {
+                  FloatRowVector ralpha = args(0).float_row_vector_value ();
 
-		  if (! error_state)
-		    {
-		      FloatComplexColumnVector cx = 
-			x_arg.float_complex_column_vector_value ();
+                  if (! error_state)
+                    {
+                      FloatComplexColumnVector cx = 
+                        x_arg.float_complex_column_vector_value ();
 
-		      if (! error_state)
-			{
-			  Array2<octave_idx_type> ierr;
-			  octave_value result;
+                      if (! error_state)
+                        {
+                          Array2<octave_idx_type> ierr;
+                          octave_value result;
 
-			  DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
+                          DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
-			  if (nargout > 1)
-			    retval(1) = NDArray (ierr);
+                          if (nargout > 1)
+                            retval(1) = NDArray (ierr);
 
-			  retval(0) = result;
-			}
-		      else
-			gripe_bessel_arg (fn, "second");
-		    }
-		  else
-		    gripe_bessel_arg (fn, "first");
-		}
-	      else
-		{
-		  FloatNDArray alpha = args(0).float_array_value ();
+                          retval(0) = result;
+                        }
+                      else
+                        gripe_bessel_arg (fn, "second");
+                    }
+                  else
+                    gripe_bessel_arg (fn, "first");
+                }
+              else
+                {
+                  FloatNDArray alpha = args(0).float_array_value ();
 
-		  if (! error_state)
-		    {
-		      if (x_arg.is_scalar_type ())
-			{
-			  FloatComplex x = x_arg.float_complex_value ();
+                  if (! error_state)
+                    {
+                      if (x_arg.is_scalar_type ())
+                        {
+                          FloatComplex x = x_arg.float_complex_value ();
 
-			  if (! error_state)
-			    {
-			      Array<octave_idx_type> ierr;
-			      octave_value result;
+                          if (! error_state)
+                            {
+                              Array<octave_idx_type> ierr;
+                              octave_value result;
 
-			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-			      if (nargout > 1)
-				retval(1) = NDArray (ierr);
+                              if (nargout > 1)
+                                retval(1) = NDArray (ierr);
 
-			      retval(0) = result;
-			    }
-			  else
-			    gripe_bessel_arg (fn, "second");
-			}
-		      else
-			{
-			  FloatComplexNDArray x = x_arg.float_complex_array_value ();
+                              retval(0) = result;
+                            }
+                          else
+                            gripe_bessel_arg (fn, "second");
+                        }
+                      else
+                        {
+                          FloatComplexNDArray x = x_arg.float_complex_array_value ();
 
-			  if (! error_state)
-			    {
-			      Array<octave_idx_type> ierr;
-			      octave_value result;
-			  
-			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
-			  
-			      if (nargout > 1)
-				retval(1) = NDArray (ierr);
+                          if (! error_state)
+                            {
+                              Array<octave_idx_type> ierr;
+                              octave_value result;
+                          
+                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                          
+                              if (nargout > 1)
+                                retval(1) = NDArray (ierr);
 
-			      retval(0) = result;
-			    }
-			  else
-			    gripe_bessel_arg (fn, "second");
-			}
-		    }
-		  else
-		    gripe_bessel_arg (fn, "first");
-		}
-	    }
-	}
+                              retval(0) = result;
+                            }
+                          else
+                            gripe_bessel_arg (fn, "second");
+                        }
+                    }
+                  else
+                    gripe_bessel_arg (fn, "first");
+                }
+            }
+        }
       else
-	{
-	  if (alpha_arg.is_scalar_type ())
-	    {
-	      double alpha = args(0).double_value ();
+        {
+          if (alpha_arg.is_scalar_type ())
+            {
+              double alpha = args(0).double_value ();
 
-	      if (! error_state)
-		{
-		  if (x_arg.is_scalar_type ())
-		    {
-		      Complex x = x_arg.complex_value ();
+              if (! error_state)
+                {
+                  if (x_arg.is_scalar_type ())
+                    {
+                      Complex x = x_arg.complex_value ();
 
-		      if (! error_state)
-			{
-			  octave_idx_type ierr;
-			  octave_value result;
+                      if (! error_state)
+                        {
+                          octave_idx_type ierr;
+                          octave_value result;
 
-			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-			  if (nargout > 1)
-			    retval(1) = static_cast<double> (ierr);
+                          if (nargout > 1)
+                            retval(1) = static_cast<double> (ierr);
 
-			  retval(0) = result;
-			}
-		      else
-			gripe_bessel_arg (fn, "second");
-		    }
-		  else
-		    {
-		      ComplexNDArray x = x_arg.complex_array_value ();
+                          retval(0) = result;
+                        }
+                      else
+                        gripe_bessel_arg (fn, "second");
+                    }
+                  else
+                    {
+                      ComplexNDArray x = x_arg.complex_array_value ();
 
-		      if (! error_state)
-			{
-			  Array<octave_idx_type> ierr;
-			  octave_value result;
+                      if (! error_state)
+                        {
+                          Array<octave_idx_type> ierr;
+                          octave_value result;
 
-			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-			  if (nargout > 1)
-			    retval(1) = NDArray (ierr);
+                          if (nargout > 1)
+                            retval(1) = NDArray (ierr);
 
-			  retval(0) = result;
-			}
-		      else
-			gripe_bessel_arg (fn, "second");
-		    }
-		}
-	      else
-		gripe_bessel_arg (fn, "first");
-	    }
-	  else
-	    {
-	      dim_vector dv0 = args(0).dims ();
-	      dim_vector dv1 = args(1).dims ();
+                          retval(0) = result;
+                        }
+                      else
+                        gripe_bessel_arg (fn, "second");
+                    }
+                }
+              else
+                gripe_bessel_arg (fn, "first");
+            }
+          else
+            {
+              dim_vector dv0 = args(0).dims ();
+              dim_vector dv1 = args(1).dims ();
 
-	      bool args0_is_row_vector = (dv0 (1) == dv0.numel ());
-	      bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
+              bool args0_is_row_vector = (dv0 (1) == dv0.numel ());
+              bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
 
-	      if (args0_is_row_vector && args1_is_col_vector)
-		{
-		  RowVector ralpha = args(0).row_vector_value ();
+              if (args0_is_row_vector && args1_is_col_vector)
+                {
+                  RowVector ralpha = args(0).row_vector_value ();
 
-		  if (! error_state)
-		    {
-		      ComplexColumnVector cx = 
-			x_arg.complex_column_vector_value ();
+                  if (! error_state)
+                    {
+                      ComplexColumnVector cx = 
+                        x_arg.complex_column_vector_value ();
 
-		      if (! error_state)
-			{
-			  Array2<octave_idx_type> ierr;
-			  octave_value result;
+                      if (! error_state)
+                        {
+                          Array2<octave_idx_type> ierr;
+                          octave_value result;
 
-			  DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
+                          DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
-			  if (nargout > 1)
-			    retval(1) = NDArray (ierr);
+                          if (nargout > 1)
+                            retval(1) = NDArray (ierr);
 
-			  retval(0) = result;
-			}
-		      else
-			gripe_bessel_arg (fn, "second");
-		    }
-		  else
-		    gripe_bessel_arg (fn, "first");
-		}
-	      else
-		{
-		  NDArray alpha = args(0).array_value ();
+                          retval(0) = result;
+                        }
+                      else
+                        gripe_bessel_arg (fn, "second");
+                    }
+                  else
+                    gripe_bessel_arg (fn, "first");
+                }
+              else
+                {
+                  NDArray alpha = args(0).array_value ();
 
-		  if (! error_state)
-		    {
-		      if (x_arg.is_scalar_type ())
-			{
-			  Complex x = x_arg.complex_value ();
+                  if (! error_state)
+                    {
+                      if (x_arg.is_scalar_type ())
+                        {
+                          Complex x = x_arg.complex_value ();
 
-			  if (! error_state)
-			    {
-			      Array<octave_idx_type> ierr;
-			      octave_value result;
+                          if (! error_state)
+                            {
+                              Array<octave_idx_type> ierr;
+                              octave_value result;
 
-			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-			      if (nargout > 1)
-				retval(1) = NDArray (ierr);
+                              if (nargout > 1)
+                                retval(1) = NDArray (ierr);
 
-			      retval(0) = result;
-			    }
-			  else
-			    gripe_bessel_arg (fn, "second");
-			}
-		      else
-			{
-			  ComplexNDArray x = x_arg.complex_array_value ();
+                              retval(0) = result;
+                            }
+                          else
+                            gripe_bessel_arg (fn, "second");
+                        }
+                      else
+                        {
+                          ComplexNDArray x = x_arg.complex_array_value ();
 
-			  if (! error_state)
-			    {
-			      Array<octave_idx_type> ierr;
-			      octave_value result;
-			  
-			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
-			  
-			      if (nargout > 1)
-				retval(1) = NDArray (ierr);
+                          if (! error_state)
+                            {
+                              Array<octave_idx_type> ierr;
+                              octave_value result;
+                          
+                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                          
+                              if (nargout > 1)
+                                retval(1) = NDArray (ierr);
 
-			      retval(0) = result;
-			    }
-			  else
-			    gripe_bessel_arg (fn, "second");
-			}
-		    }
-		  else
-		    gripe_bessel_arg (fn, "first");
-		}
-	    }
-	}
+                              retval(0) = result;
+                            }
+                          else
+                            gripe_bessel_arg (fn, "second");
+                        }
+                    }
+                  else
+                    gripe_bessel_arg (fn, "first");
+                }
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (besselj, args, nargout,
@@ -481,34 +481,34 @@ See besselj.\n\
     {
       retval = do_bessel (BESSEL_H1, "besselh", args, nargout);
     }
   else if (nargin == 3 || nargin == 4)
     {
       octave_idx_type kind = args(1).int_value ();
 
       if (! error_state)
-	{
-	  octave_value_list tmp_args;
+        {
+          octave_value_list tmp_args;
 
-	  if (nargin == 4)
-	    tmp_args(2) = args(3);
+          if (nargin == 4)
+            tmp_args(2) = args(3);
 
-	  tmp_args(1) = args(2);
-	  tmp_args(0) = args(0);
+          tmp_args(1) = args(2);
+          tmp_args(0) = args(0);
 
-	  if (kind == 1)
-	    retval = do_bessel (BESSEL_H1, "besselh", tmp_args, nargout);
-	  else if (kind == 2)
-	    retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
-	  else
-	    error ("besselh: expecting K = 1 or 2");
-	}
+          if (kind == 1)
+            retval = do_bessel (BESSEL_H1, "besselh", tmp_args, nargout);
+          else if (kind == 2)
+            retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
+          else
+            error ("besselh: expecting K = 1 or 2");
+        }
       else
-	error ("besselh: invalid value of K");
+        error ("besselh: invalid value of K");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (airy, args, nargout,
@@ -560,77 +560,77 @@ return @code{NaN}.\n\
 
   if (nargin > 0 && nargin < 4)
     {
       bool scale = (nargin == 3);
 
       int kind = 0;
 
       if (nargin > 1)
-	{
-	  kind = args(0).int_value ();
+        {
+          kind = args(0).int_value ();
 
-	  if (! error_state)
-	    {
-	      if (kind < 0 || kind > 3)
-		error ("airy: expecting K = 0, 1, 2, or 3");
-	    }	      
-	  else
-	    error ("airy: expecting integer value for K");
-	}
+          if (! error_state)
+            {
+              if (kind < 0 || kind > 3)
+                error ("airy: expecting K = 0, 1, 2, or 3");
+            }         
+          else
+            error ("airy: expecting integer value for K");
+        }
 
       if (! error_state)
-	{
-	  int idx = nargin == 1 ? 0 : 1;
+        {
+          int idx = nargin == 1 ? 0 : 1;
 
-	  if (args (idx).is_single_type ())
-	    {
-	      FloatComplexNDArray z = args(idx).float_complex_array_value ();
+          if (args (idx).is_single_type ())
+            {
+              FloatComplexNDArray z = args(idx).float_complex_array_value ();
 
-	      if (! error_state)
-		{
-		  Array<octave_idx_type> ierr;
-		  octave_value result;
+              if (! error_state)
+                {
+                  Array<octave_idx_type> ierr;
+                  octave_value result;
 
-		  if (kind > 1)
-		    result = biry (z, kind == 3, scale, ierr);
-		  else
-		    result = airy (z, kind == 1, scale, ierr);
+                  if (kind > 1)
+                    result = biry (z, kind == 3, scale, ierr);
+                  else
+                    result = airy (z, kind == 1, scale, ierr);
 
-		  if (nargout > 1)
-		    retval(1) = NDArray (ierr);
+                  if (nargout > 1)
+                    retval(1) = NDArray (ierr);
 
-		  retval(0) = result;
-		}
-	      else
-		error ("airy: expecting complex matrix for Z");
-	    }
-	  else
-	    {
-	      ComplexNDArray z = args(idx).complex_array_value ();
+                  retval(0) = result;
+                }
+              else
+                error ("airy: expecting complex matrix for Z");
+            }
+          else
+            {
+              ComplexNDArray z = args(idx).complex_array_value ();
 
-	      if (! error_state)
-		{
-		  Array<octave_idx_type> ierr;
-		  octave_value result;
+              if (! error_state)
+                {
+                  Array<octave_idx_type> ierr;
+                  octave_value result;
 
-		  if (kind > 1)
-		    result = biry (z, kind == 3, scale, ierr);
-		  else
-		    result = airy (z, kind == 1, scale, ierr);
+                  if (kind > 1)
+                    result = biry (z, kind == 3, scale, ierr);
+                  else
+                    result = airy (z, kind == 1, scale, ierr);
 
-		  if (nargout > 1)
-		    retval(1) = NDArray (ierr);
+                  if (nargout > 1)
+                    retval(1) = NDArray (ierr);
 
-		  retval(0) = result;
-		}
-	      else
-		error ("airy: expecting complex matrix for Z");
-	    }
-	}
+                  retval(0) = result;
+                }
+              else
+                error ("airy: expecting complex matrix for Z");
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -66,218 +66,218 @@ compatible dimensions.\n\
   if (nargin == 3)
     {
       octave_value x_arg = args(0);
       octave_value a_arg = args(1);
       octave_value b_arg = args(2);
 
       // FIXME Can we make a template version of the duplicated code below
       if (x_arg.is_single_type () || a_arg.is_single_type () ||
-	  b_arg.is_single_type ())
-	{
-	  if (x_arg.is_scalar_type ())
-	    {
-	      float x = x_arg.float_value ();
+          b_arg.is_single_type ())
+        {
+          if (x_arg.is_scalar_type ())
+            {
+              float x = x_arg.float_value ();
 
-	      if (a_arg.is_scalar_type ())
-		{
-		  float a = a_arg.float_value ();
+              if (a_arg.is_scalar_type ())
+                {
+                  float a = a_arg.float_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  float b = b_arg.float_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          float b = b_arg.float_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  FloatNDArray b = b_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          FloatNDArray b = b_arg.float_array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	      else
-		{
-		  FloatNDArray a = a_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+              else
+                {
+                  FloatNDArray a = a_arg.float_array_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  float b = b_arg.float_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          float b = b_arg.float_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  FloatNDArray b = b_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          FloatNDArray b = b_arg.float_array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	    }
-	  else
-	    {
-	      FloatNDArray x = x_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+            }
+          else
+            {
+              FloatNDArray x = x_arg.float_array_value ();
 
-	      if (a_arg.is_scalar_type ())
-		{
-		  float a = a_arg.float_value ();
+              if (a_arg.is_scalar_type ())
+                {
+                  float a = a_arg.float_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  float b = b_arg.float_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          float b = b_arg.float_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  FloatNDArray b = b_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          FloatNDArray b = b_arg.float_array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	      else
-		{
-		  FloatNDArray a = a_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+              else
+                {
+                  FloatNDArray a = a_arg.float_array_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  float b = b_arg.float_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          float b = b_arg.float_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  FloatNDArray b = b_arg.float_array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          FloatNDArray b = b_arg.float_array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	    }
-	}
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+            }
+        }
       else
-	{
-	  if (x_arg.is_scalar_type ())
-	    {
-	      double x = x_arg.double_value ();
+        {
+          if (x_arg.is_scalar_type ())
+            {
+              double x = x_arg.double_value ();
 
-	      if (a_arg.is_scalar_type ())
-		{
-		  double a = a_arg.double_value ();
+              if (a_arg.is_scalar_type ())
+                {
+                  double a = a_arg.double_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  double b = b_arg.double_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          double b = b_arg.double_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  NDArray b = b_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          NDArray b = b_arg.array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	      else
-		{
-		  NDArray a = a_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+              else
+                {
+                  NDArray a = a_arg.array_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  double b = b_arg.double_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          double b = b_arg.double_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  NDArray b = b_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          NDArray b = b_arg.array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	    }
-	  else
-	    {
-	      NDArray x = x_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+            }
+          else
+            {
+              NDArray x = x_arg.array_value ();
 
-	      if (a_arg.is_scalar_type ())
-		{
-		  double a = a_arg.double_value ();
+              if (a_arg.is_scalar_type ())
+                {
+                  double a = a_arg.double_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  double b = b_arg.double_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          double b = b_arg.double_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  NDArray b = b_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          NDArray b = b_arg.array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	      else
-		{
-		  NDArray a = a_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+              else
+                {
+                  NDArray a = a_arg.array_value ();
 
-		  if (! error_state)
-		    {
-		      if (b_arg.is_scalar_type ())
-			{
-			  double b = b_arg.double_value ();
+                  if (! error_state)
+                    {
+                      if (b_arg.is_scalar_type ())
+                        {
+                          double b = b_arg.double_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		      else
-			{
-			  NDArray b = b_arg.array_value ();
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                      else
+                        {
+                          NDArray b = b_arg.array_value ();
 
-			  if (! error_state)
-			    retval = betainc (x, a, b);
-			}
-		    }
-		}
-	    }
-	}
+                          if (! error_state)
+                            retval = betainc (x, a, b);
+                        }
+                    }
+                }
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -217,86 +217,86 @@ maybe_optimized_builtin (const std::stri
         }
     }
 
   return retval;
 }
 
 static bool
 maybe_update_column (octave_value& Ac, const octave_value& A, 
-		     const dim_vector& dva, const dim_vector& dvc,
-		     octave_idx_type i, octave_value_list &idx)
+                     const dim_vector& dva, const dim_vector& dvc,
+                     octave_idx_type i, octave_value_list &idx)
 {
   octave_idx_type nd = dva.length ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
-	{
-	  if (dva (j) == 1)
-	    idx (j) = octave_value (1);
-	  else
-	    idx (j) = octave_value ((i % dvc(j)) + 1);
+        {
+          if (dva (j) == 1)
+            idx (j) = octave_value (1);
+          else
+            idx (j) = octave_value ((i % dvc(j)) + 1);
 
-	  i = i / dvc (j);
-	}
+          i = i / dvc (j);
+        }
 
       Ac = A;
       Ac = Ac.single_subsref ("(", idx);
       return true;
     }
   else
     {
       bool is_changed = false;
       octave_idx_type k = i;
       octave_idx_type k1 = i - 1;
       for (octave_idx_type j = 1; j < nd; j++)
-	{
-	  if (dva(j) != 1 && k % dvc (j) != k1 % dvc (j))
-	    {
-	      idx (j) = octave_value ((k % dvc(j)) + 1);
-	      is_changed = true;
-	    }
+        {
+          if (dva(j) != 1 && k % dvc (j) != k1 % dvc (j))
+            {
+              idx (j) = octave_value ((k % dvc(j)) + 1);
+              is_changed = true;
+            }
 
-	  k = k / dvc (j);
-	  k1 = k1 / dvc (j);
-	}
+          k = k / dvc (j);
+          k1 = k1 / dvc (j);
+        }
 
       if (is_changed)
-	{
-	  Ac = A;
-	  Ac = Ac.single_subsref ("(", idx);
-	  return true;
-	}
+        {
+          Ac = A;
+          Ac = Ac.single_subsref ("(", idx);
+          return true;
+        }
       else
-	return false;
+        return false;
     }
 }
 
 #if 0
 // FIXME -- this function is not used; is it OK to delete it?
 static void
 update_index (octave_value_list& idx, const dim_vector& dv, octave_idx_type i)
 {
   octave_idx_type nd = dv.length ();
 
   if (i == 0)
     {
       for (octave_idx_type j = nd - 1; j > 0; j--)
-	idx(j) = octave_value (static_cast<double>(1));
+        idx(j) = octave_value (static_cast<double>(1));
       idx(0) = octave_value (':');
     }
   else
     {
       for (octave_idx_type j = 1; j < nd; j++)
-	{
-	  idx (j) = octave_value (i % dv (j) + 1);
-	  i = i / dv (j);
-	}
+        {
+          idx (j) = octave_value (i % dv (j) + 1);
+          i = i / dv (j);
+        }
     }
 }
 #endif
 
 static void
 update_index (Array<int>& idx, const dim_vector& dv, octave_idx_type i)
 {
   octave_idx_type nd = dv.length ();
@@ -356,301 +356,301 @@ dimensionality as the other matrix.\n\
             {
               octave_value tmp = maybe_optimized_builtin (fcn_val->name (), A, B);
               if (tmp.is_defined ())
                 retval(0) = tmp;
             }
         }
 
       if (! error_state && retval.empty ())
-	{
-	  dim_vector dva = A.dims ();
-	  octave_idx_type nda = dva.length ();
-	  dim_vector dvb = B.dims ();
-	  octave_idx_type ndb = dvb.length ();
-	  octave_idx_type nd = nda;
+        {
+          dim_vector dva = A.dims ();
+          octave_idx_type nda = dva.length ();
+          dim_vector dvb = B.dims ();
+          octave_idx_type ndb = dvb.length ();
+          octave_idx_type nd = nda;
       
-	  if (nda > ndb)
-	      dvb.resize (nda, 1);
-	  else if (nda < ndb)
-	    {
-	      dva.resize (ndb, 1);
-	      nd = ndb;
-	    }
+          if (nda > ndb)
+              dvb.resize (nda, 1);
+          else if (nda < ndb)
+            {
+              dva.resize (ndb, 1);
+              nd = ndb;
+            }
 
-	  for (octave_idx_type i = 0; i < nd; i++)
-	    if (dva (i) != dvb (i) && dva (i) != 1 && dvb (i) != 1)
-	      {
-		error ("bsxfun: dimensions don't match");
-		break;
-	      }
+          for (octave_idx_type i = 0; i < nd; i++)
+            if (dva (i) != dvb (i) && dva (i) != 1 && dvb (i) != 1)
+              {
+                error ("bsxfun: dimensions don't match");
+                break;
+              }
 
-	  if (!error_state)
-	    {
-	      // Find the size of the output
-	      dim_vector dvc;
-	      dvc.resize (nd);
-	  
-	      for (octave_idx_type i = 0; i < nd; i++)
-		dvc (i) = (dva (i) < 1  ? dva (i) : (dvb (i) < 1 ? dvb (i) :
-		      (dva (i) > dvb (i) ? dva (i) : dvb (i))));
+          if (!error_state)
+            {
+              // Find the size of the output
+              dim_vector dvc;
+              dvc.resize (nd);
+          
+              for (octave_idx_type i = 0; i < nd; i++)
+                dvc (i) = (dva (i) < 1  ? dva (i) : (dvb (i) < 1 ? dvb (i) :
+                      (dva (i) > dvb (i) ? dva (i) : dvb (i))));
 
-	      if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
-		{
-		  octave_value_list inputs;
-		  inputs (0) = A;
-		  inputs (1) = B;
-		  retval = func.do_multi_index_op (1, inputs);  
-		}
-	      else if (dvc.numel () < 1)
-		{
-		  octave_value_list inputs;
-		  inputs (0) = A.resize (dvc);
-		  inputs (1) = B.resize (dvc);
-		  retval = func.do_multi_index_op (1, inputs);  
-		}
-	      else
-		{
-		  octave_idx_type ncount = 1;
-		  for (octave_idx_type i = 1; i < nd; i++)
-		    ncount *= dvc (i);
+              if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
+                {
+                  octave_value_list inputs;
+                  inputs (0) = A;
+                  inputs (1) = B;
+                  retval = func.do_multi_index_op (1, inputs);  
+                }
+              else if (dvc.numel () < 1)
+                {
+                  octave_value_list inputs;
+                  inputs (0) = A.resize (dvc);
+                  inputs (1) = B.resize (dvc);
+                  retval = func.do_multi_index_op (1, inputs);  
+                }
+              else
+                {
+                  octave_idx_type ncount = 1;
+                  for (octave_idx_type i = 1; i < nd; i++)
+                    ncount *= dvc (i);
 
 #define BSXDEF(T) \
-		  T result_ ## T; \
-		  bool have_ ## T = false;
+                  T result_ ## T; \
+                  bool have_ ## T = false;
 
-		  BSXDEF(NDArray);
-		  BSXDEF(ComplexNDArray);
-		  BSXDEF(FloatNDArray);
-		  BSXDEF(FloatComplexNDArray);
-		  BSXDEF(boolNDArray);
-		  BSXDEF(int8NDArray);
-		  BSXDEF(int16NDArray);
-		  BSXDEF(int32NDArray);
-		  BSXDEF(int64NDArray);
-		  BSXDEF(uint8NDArray);
-		  BSXDEF(uint16NDArray);
-		  BSXDEF(uint32NDArray);
-		  BSXDEF(uint64NDArray);
+                  BSXDEF(NDArray);
+                  BSXDEF(ComplexNDArray);
+                  BSXDEF(FloatNDArray);
+                  BSXDEF(FloatComplexNDArray);
+                  BSXDEF(boolNDArray);
+                  BSXDEF(int8NDArray);
+                  BSXDEF(int16NDArray);
+                  BSXDEF(int32NDArray);
+                  BSXDEF(int64NDArray);
+                  BSXDEF(uint8NDArray);
+                  BSXDEF(uint16NDArray);
+                  BSXDEF(uint32NDArray);
+                  BSXDEF(uint64NDArray);
 
-		  octave_value Ac ;
-		  octave_value_list idxA;
-		  octave_value Bc;
-		  octave_value_list idxB;
-		  octave_value C;
-		  octave_value_list inputs;
-		  Array<int> ra_idx (dvc.length(), 0);
+                  octave_value Ac ;
+                  octave_value_list idxA;
+                  octave_value Bc;
+                  octave_value_list idxB;
+                  octave_value C;
+                  octave_value_list inputs;
+                  Array<int> ra_idx (dvc.length(), 0);
 
 
-		  for (octave_idx_type i = 0; i < ncount; i++)
-		    {
-		      if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
-			inputs (0) = Ac;
+                  for (octave_idx_type i = 0; i < ncount; i++)
+                    {
+                      if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
+                        inputs (0) = Ac;
 
-		      if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
-			inputs (1) = Bc;
-			
-		      octave_value_list tmp = func.do_multi_index_op (1, inputs);  
+                      if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
+                        inputs (1) = Bc;
+                        
+                      octave_value_list tmp = func.do_multi_index_op (1, inputs);  
 
-		      if (error_state)
-			break;
+                      if (error_state)
+                        break;
 
 #define BSXINIT(T, CLS, EXTRACTOR) \
- 		      (result_type == CLS) \
-			{ \
-			    have_ ## T = true; \
-			    result_ ## T = \
-				tmp (0). EXTRACTOR ## _array_value (); \
-			    result_ ## T .resize (dvc); \
+                      (result_type == CLS) \
+                        { \
+                            have_ ## T = true; \
+                            result_ ## T = \
+                                tmp (0). EXTRACTOR ## _array_value (); \
+                            result_ ## T .resize (dvc); \
                         }
 
-		      if (i == 0)
-			{
-			  if (! tmp(0).is_sparse_type ())
-			    {
-			      std::string result_type = tmp(0).class_name ();
-			      if (result_type == "double")
-				{
-				  if (tmp(0).is_real_type ())
-				    {
-				      have_NDArray = true;
-				      result_NDArray = tmp(0).array_value ();
-				      result_NDArray.resize (dvc);
-				    }
-				  else
-				    {
-				      have_ComplexNDArray = true;
-				      result_ComplexNDArray = 
-					tmp(0).complex_array_value ();
-				      result_ComplexNDArray.resize (dvc);
-				    }
-				}
-			      else if (result_type == "single")
-				{
-				  if (tmp(0).is_real_type ())
-				    {
-				      have_FloatNDArray = true;
-				      result_FloatNDArray = tmp(0).float_array_value ();
-				      result_FloatNDArray.resize (dvc);
-				    }
-				  else
-				    {
-				      have_ComplexNDArray = true;
-				      result_ComplexNDArray = 
-					tmp(0).complex_array_value ();
-				      result_ComplexNDArray.resize (dvc);
-				    }
-				}
-			      else if BSXINIT(boolNDArray, "logical", bool)
-			      else if BSXINIT(int8NDArray, "int8", int8)
-			      else if BSXINIT(int16NDArray, "int16", int16)
-			      else if BSXINIT(int32NDArray, "int32", int32)
-			      else if BSXINIT(int64NDArray, "int64", int64)
-			      else if BSXINIT(uint8NDArray, "uint8", uint8)
-			      else if BSXINIT(uint16NDArray, "uint16", uint16)
-			      else if BSXINIT(uint32NDArray, "uint32", uint32)
-			      else if BSXINIT(uint64NDArray, "uint64", uint64)
-			      else
-				{
-				  C = tmp (0);
-				  C = C.resize (dvc);
-				}
-			    }
-			}
-		      else
-			{
-			  update_index (ra_idx, dvc, i);
-			  
-			  if (have_FloatNDArray ||
-			      have_FloatComplexNDArray)
-			    {
-			      if (! tmp(0).is_float_type ())
-				{
-				  if (have_FloatNDArray)
-				    {
-				      have_FloatNDArray = false;
-				      C = result_FloatNDArray;
-				    }
-				  else
-				    {
-				      have_FloatComplexNDArray = false;
-				      C = result_FloatComplexNDArray;
-				    }
-				  C = do_cat_op (C, tmp(0), ra_idx);
-				}
-			      else if (tmp(0).is_double_type ())
-				{
-				  if (tmp(0).is_complex_type () && 
-				      have_FloatNDArray)
-				    {
-				      result_ComplexNDArray = 
-					ComplexNDArray (result_FloatNDArray);
-				      result_ComplexNDArray.insert 
-					(tmp(0).complex_array_value(), ra_idx);
-				      have_FloatComplexNDArray = false;
-				      have_ComplexNDArray = true;
-				    }
-				  else
-				    {
-				      result_NDArray = 
-					NDArray (result_FloatNDArray);
-				      result_NDArray.insert 
-					(tmp(0).array_value(), ra_idx);
-				      have_FloatNDArray = false;
-				      have_NDArray = true;
-				    }
-				}
-			      else if (tmp(0).is_real_type ())
-				result_FloatNDArray.insert 
-				  (tmp(0).float_array_value(), ra_idx);
-			      else
-				{
-				  result_FloatComplexNDArray = 
-				    FloatComplexNDArray (result_FloatNDArray);
-				  result_FloatComplexNDArray.insert 
-				    (tmp(0).float_complex_array_value(), ra_idx);
-				  have_FloatNDArray = false;
-				  have_FloatComplexNDArray = true;
-				}
-			    }
-			  else if (have_NDArray)
-			    {
-			      if (! tmp(0).is_float_type ())
-				{
-				  have_NDArray = false;
-				  C = result_NDArray;
-				  C = do_cat_op (C, tmp(0), ra_idx);
-				}
-			      else if (tmp(0).is_real_type ())
-				result_NDArray.insert (tmp(0).array_value(), 
-						       ra_idx);
-			      else
-				{
-				  result_ComplexNDArray = 
-				    ComplexNDArray (result_NDArray);
-				  result_ComplexNDArray.insert 
-				    (tmp(0).complex_array_value(), ra_idx);
-				  have_NDArray = false;
-				  have_ComplexNDArray = true;
-				}
-			    }
+                      if (i == 0)
+                        {
+                          if (! tmp(0).is_sparse_type ())
+                            {
+                              std::string result_type = tmp(0).class_name ();
+                              if (result_type == "double")
+                                {
+                                  if (tmp(0).is_real_type ())
+                                    {
+                                      have_NDArray = true;
+                                      result_NDArray = tmp(0).array_value ();
+                                      result_NDArray.resize (dvc);
+                                    }
+                                  else
+                                    {
+                                      have_ComplexNDArray = true;
+                                      result_ComplexNDArray = 
+                                        tmp(0).complex_array_value ();
+                                      result_ComplexNDArray.resize (dvc);
+                                    }
+                                }
+                              else if (result_type == "single")
+                                {
+                                  if (tmp(0).is_real_type ())
+                                    {
+                                      have_FloatNDArray = true;
+                                      result_FloatNDArray = tmp(0).float_array_value ();
+                                      result_FloatNDArray.resize (dvc);
+                                    }
+                                  else
+                                    {
+                                      have_ComplexNDArray = true;
+                                      result_ComplexNDArray = 
+                                        tmp(0).complex_array_value ();
+                                      result_ComplexNDArray.resize (dvc);
+                                    }
+                                }
+                              else if BSXINIT(boolNDArray, "logical", bool)
+                              else if BSXINIT(int8NDArray, "int8", int8)
+                              else if BSXINIT(int16NDArray, "int16", int16)
+                              else if BSXINIT(int32NDArray, "int32", int32)
+                              else if BSXINIT(int64NDArray, "int64", int64)
+                              else if BSXINIT(uint8NDArray, "uint8", uint8)
+                              else if BSXINIT(uint16NDArray, "uint16", uint16)
+                              else if BSXINIT(uint32NDArray, "uint32", uint32)
+                              else if BSXINIT(uint64NDArray, "uint64", uint64)
+                              else
+                                {
+                                  C = tmp (0);
+                                  C = C.resize (dvc);
+                                }
+                            }
+                        }
+                      else
+                        {
+                          update_index (ra_idx, dvc, i);
+                          
+                          if (have_FloatNDArray ||
+                              have_FloatComplexNDArray)
+                            {
+                              if (! tmp(0).is_float_type ())
+                                {
+                                  if (have_FloatNDArray)
+                                    {
+                                      have_FloatNDArray = false;
+                                      C = result_FloatNDArray;
+                                    }
+                                  else
+                                    {
+                                      have_FloatComplexNDArray = false;
+                                      C = result_FloatComplexNDArray;
+                                    }
+                                  C = do_cat_op (C, tmp(0), ra_idx);
+                                }
+                              else if (tmp(0).is_double_type ())
+                                {
+                                  if (tmp(0).is_complex_type () && 
+                                      have_FloatNDArray)
+                                    {
+                                      result_ComplexNDArray = 
+                                        ComplexNDArray (result_FloatNDArray);
+                                      result_ComplexNDArray.insert 
+                                        (tmp(0).complex_array_value(), ra_idx);
+                                      have_FloatComplexNDArray = false;
+                                      have_ComplexNDArray = true;
+                                    }
+                                  else
+                                    {
+                                      result_NDArray = 
+                                        NDArray (result_FloatNDArray);
+                                      result_NDArray.insert 
+                                        (tmp(0).array_value(), ra_idx);
+                                      have_FloatNDArray = false;
+                                      have_NDArray = true;
+                                    }
+                                }
+                              else if (tmp(0).is_real_type ())
+                                result_FloatNDArray.insert 
+                                  (tmp(0).float_array_value(), ra_idx);
+                              else
+                                {
+                                  result_FloatComplexNDArray = 
+                                    FloatComplexNDArray (result_FloatNDArray);
+                                  result_FloatComplexNDArray.insert 
+                                    (tmp(0).float_complex_array_value(), ra_idx);
+                                  have_FloatNDArray = false;
+                                  have_FloatComplexNDArray = true;
+                                }
+                            }
+                          else if (have_NDArray)
+                            {
+                              if (! tmp(0).is_float_type ())
+                                {
+                                  have_NDArray = false;
+                                  C = result_NDArray;
+                                  C = do_cat_op (C, tmp(0), ra_idx);
+                                }
+                              else if (tmp(0).is_real_type ())
+                                result_NDArray.insert (tmp(0).array_value(), 
+                                                       ra_idx);
+                              else
+                                {
+                                  result_ComplexNDArray = 
+                                    ComplexNDArray (result_NDArray);
+                                  result_ComplexNDArray.insert 
+                                    (tmp(0).complex_array_value(), ra_idx);
+                                  have_NDArray = false;
+                                  have_ComplexNDArray = true;
+                                }
+                            }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
-			(have_ ## T) \
-			  { \
-			    if (tmp (0).class_name () != CLS) \
-			      { \
-				have_ ## T = false; \
-				C = result_ ## T; \
-				C = do_cat_op (C, tmp (0), ra_idx); \
-			      } \
-			    else \
-			      result_ ## T .insert \
-				(tmp(0). EXTRACTOR ## _array_value (), \
-				ra_idx); \
-			  }
+                        (have_ ## T) \
+                          { \
+                            if (tmp (0).class_name () != CLS) \
+                              { \
+                                have_ ## T = false; \
+                                C = result_ ## T; \
+                                C = do_cat_op (C, tmp (0), ra_idx); \
+                              } \
+                            else \
+                              result_ ## T .insert \
+                                (tmp(0). EXTRACTOR ## _array_value (), \
+                                ra_idx); \
+                          }
 
-			  else if BSXLOOP(ComplexNDArray, "double", complex)
-			  else if BSXLOOP(boolNDArray, "logical", bool)
-			  else if BSXLOOP(int8NDArray, "int8", int8)
-			  else if BSXLOOP(int16NDArray, "int16", int16)
-			  else if BSXLOOP(int32NDArray, "int32", int32)
-			  else if BSXLOOP(int64NDArray, "int64", int64)
-			  else if BSXLOOP(uint8NDArray, "uint8", uint8)
-			  else if BSXLOOP(uint16NDArray, "uint16", uint16)
-			  else if BSXLOOP(uint32NDArray, "uint32", uint32)
-			  else if BSXLOOP(uint64NDArray, "uint64", uint64)
-			  else
-			    C = do_cat_op (C, tmp(0), ra_idx);
-			}
-		    }
+                          else if BSXLOOP(ComplexNDArray, "double", complex)
+                          else if BSXLOOP(boolNDArray, "logical", bool)
+                          else if BSXLOOP(int8NDArray, "int8", int8)
+                          else if BSXLOOP(int16NDArray, "int16", int16)
+                          else if BSXLOOP(int32NDArray, "int32", int32)
+                          else if BSXLOOP(int64NDArray, "int64", int64)
+                          else if BSXLOOP(uint8NDArray, "uint8", uint8)
+                          else if BSXLOOP(uint16NDArray, "uint16", uint16)
+                          else if BSXLOOP(uint32NDArray, "uint32", uint32)
+                          else if BSXLOOP(uint64NDArray, "uint64", uint64)
+                          else
+                            C = do_cat_op (C, tmp(0), ra_idx);
+                        }
+                    }
 
 #define BSXEND(T) \
-		  (have_ ## T) \
-		    retval (0) = result_ ## T;
+                  (have_ ## T) \
+                    retval (0) = result_ ## T;
 
-		  if BSXEND(NDArray)
-		  else if BSXEND(ComplexNDArray)
-		  else if BSXEND(FloatNDArray)
-		  else if BSXEND(FloatComplexNDArray)
-		  else if BSXEND(boolNDArray)
-		  else if BSXEND(int8NDArray)
-		  else if BSXEND(int16NDArray)
-		  else if BSXEND(int32NDArray)
-		  else if BSXEND(int64NDArray)
-		  else if BSXEND(uint8NDArray)
-		  else if BSXEND(uint16NDArray)
-		  else if BSXEND(uint32NDArray)
-		  else if BSXEND(uint64NDArray)
-		  else
-		    retval(0) = C;
-		}
-	    }
-	}
-    }	
+                  if BSXEND(NDArray)
+                  else if BSXEND(ComplexNDArray)
+                  else if BSXEND(FloatNDArray)
+                  else if BSXEND(FloatComplexNDArray)
+                  else if BSXEND(boolNDArray)
+                  else if BSXEND(int8NDArray)
+                  else if BSXEND(int16NDArray)
+                  else if BSXEND(int32NDArray)
+                  else if BSXEND(int64NDArray)
+                  else if BSXEND(uint8NDArray)
+                  else if BSXEND(uint16NDArray)
+                  else if BSXEND(uint32NDArray)
+                  else if BSXEND(uint64NDArray)
+                  else
+                    retval(0) = C;
+                }
+            }
+        }
+    }   
 
   return retval;
 }
 
 /*
 
 %!shared a, b, c, f
 %! a = randn (4, 4);
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -150,181 +150,181 @@ colamd, symamd, and other related orderi
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);      
       CCOLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin > 1)
-	{
-	  NDArray User_knobs = args(1).array_value ();
-	  int nel_User_knobs = User_knobs.length ();
+        {
+          NDArray User_knobs = args(1).array_value ();
+          int nel_User_knobs = User_knobs.length ();
 
-	  if (nel_User_knobs > 0) 
-	    knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
-	  if (nel_User_knobs > 1) 
-	    knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
-	  if (nel_User_knobs > 2) 
-	    knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
-	  if (nel_User_knobs > 3) 
-	    knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
-	  if (nel_User_knobs > 4) 
-	    spumoni = (User_knobs (4) != 0);
+          if (nel_User_knobs > 0) 
+            knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
+          if (nel_User_knobs > 1) 
+            knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
+          if (nel_User_knobs > 2) 
+            knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
+          if (nel_User_knobs > 3) 
+            knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
+          if (nel_User_knobs > 4) 
+            spumoni = (User_knobs (4) != 0);
 
-	  // print knob settings if spumoni is set
-	  if (spumoni)
-	    {
-	      octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
-			    <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE 
-			    << ":\nknobs(1): " << User_knobs (0) << ", order for ";
-	      if ( knobs [CCOLAMD_LU] != 0)
-		octave_stdout << "lu(A)\n";
-	      else
-		octave_stdout << "chol(A'*A)\n";
+          // print knob settings if spumoni is set
+          if (spumoni)
+            {
+              octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
+                            <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE 
+                            << ":\nknobs(1): " << User_knobs (0) << ", order for ";
+              if ( knobs [CCOLAMD_LU] != 0)
+                octave_stdout << "lu(A)\n";
+              else
+                octave_stdout << "chol(A'*A)\n";
 
-	      if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-		octave_stdout << "knobs(2): " << User_knobs (1) 
-			      << ", rows with > max(16,"
-			      << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
-			      << " entries removed\n";
-	      else
-		octave_stdout << "knobs(2): " << User_knobs (1)
-			      << ", no dense rows removed\n";
+              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(2): " << User_knobs (1) 
+                              << ", rows with > max(16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << " entries removed\n";
+              else
+                octave_stdout << "knobs(2): " << User_knobs (1)
+                              << ", no dense rows removed\n";
 
-	      if (knobs [CCOLAMD_DENSE_COL] >= 0)
-		octave_stdout << "knobs(3): " << User_knobs (2) 
-			      << ", cols with > max(16,"
-			      << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
-			      << " entries removed\n";
-	      else
-		octave_stdout << "knobs(3): " << User_knobs (2)
-			      << ", no dense columns removed\n";
+              if (knobs [CCOLAMD_DENSE_COL] >= 0)
+                octave_stdout << "knobs(3): " << User_knobs (2) 
+                              << ", cols with > max(16,"
+                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << " entries removed\n";
+              else
+                octave_stdout << "knobs(3): " << User_knobs (2)
+                              << ", no dense columns removed\n";
 
-	      if (knobs [CCOLAMD_AGGRESSIVE] != 0)
-		octave_stdout << "knobs(4): " << User_knobs(3) 
-			      << ", aggressive absorption: yes";
-	      else
-		octave_stdout << "knobs(4): " << User_knobs(3) 
-			      << ", aggressive absorption: no";
+              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+                octave_stdout << "knobs(4): " << User_knobs(3) 
+                              << ", aggressive absorption: yes";
+              else
+                octave_stdout << "knobs(4): " << User_knobs(3) 
+                              << ", aggressive absorption: no";
  
-	      octave_stdout << "knobs(5): " << User_knobs (4) 
-			    << ", statistics and knobs printed\n";
-	    }
-	}
+              octave_stdout << "knobs(5): " << User_knobs (4) 
+                            << ", statistics and knobs printed\n";
+            }
+        }
       
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseComplexMatrix scm;
       SparseMatrix sm;
 
       if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      scm = args(0). sparse_complex_matrix_value ();
-	      n_row = scm.rows ();
-	      n_col = scm.cols ();
-	      nnz = scm.nzmax ();
-	      ridx = scm.xridx ();
-	      cidx = scm.xcidx ();
-	    }
-	  else
-	    {
-	      sm = args(0).sparse_matrix_value ();
+        {
+          if (args(0).is_complex_type ())
+            {
+              scm = args(0). sparse_complex_matrix_value ();
+              n_row = scm.rows ();
+              n_col = scm.cols ();
+              nnz = scm.nzmax ();
+              ridx = scm.xridx ();
+              cidx = scm.xcidx ();
+            }
+          else
+            {
+              sm = args(0).sparse_matrix_value ();
 
-	      n_row = sm.rows ();
-	      n_col = sm.cols ();
-	      nnz = sm.nzmax ();
-	      ridx = sm.xridx ();
-	      cidx = sm.xcidx ();
-	    }
-	}
+              n_row = sm.rows ();
+              n_col = sm.cols ();
+              nnz = sm.nzmax ();
+              ridx = sm.xridx ();
+              cidx = sm.xcidx ();
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type ())
-	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-	  else
-	    sm = SparseMatrix (args(0).matrix_value ());
+        {
+          if (args(0).is_complex_type ())
+            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+          else
+            sm = SparseMatrix (args(0).matrix_value ());
 
-	  n_row = sm.rows ();
-	  n_col = sm.cols ();
-	  nnz = sm.nzmax ();
-	  ridx = sm.xridx ();
-	  cidx = sm.xcidx ();
-	}
+          n_row = sm.rows ();
+          n_col = sm.cols ();
+          nnz = sm.nzmax ();
+          ridx = sm.xridx ();
+          cidx = sm.xcidx ();
+        }
 
       // Allocate workspace for ccolamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-	p[i] = cidx [i];
+        p[i] = cidx [i];
 
       octave_idx_type Alen = CCOLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-	A[i] = ridx [i];
+        A[i] = ridx [i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
-	{
-	  NDArray in_cmember = args(2).array_value();
-	  octave_idx_type cslen = in_cmember.length();
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
-	  for (octave_idx_type i = 0; i < cslen; i++)
-	    // convert cmember from 1-based to 0-based
-	    cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
-	  
-	  if (cslen != n_col)
-	    error ("ccolamd: cmember must be of length equal to #cols of A");
-	  else
-	    // Order the columns (destroys A)
-	    if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
-	      {
-		CCOLAMD_NAME (_report) (stats) ;
-		error ("ccolamd: internal error!");
-		return retval;
-	      }
-	}
+        {
+          NDArray in_cmember = args(2).array_value();
+          octave_idx_type cslen = in_cmember.length();
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
+          for (octave_idx_type i = 0; i < cslen; i++)
+            // convert cmember from 1-based to 0-based
+            cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
+          
+          if (cslen != n_col)
+            error ("ccolamd: cmember must be of length equal to #cols of A");
+          else
+            // Order the columns (destroys A)
+            if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
+              {
+                CCOLAMD_NAME (_report) (stats) ;
+                error ("ccolamd: internal error!");
+                return retval;
+              }
+        }
       else
-	{
-	  // Order the columns (destroys A)
-	  if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, 0))
-	    {
-	      CCOLAMD_NAME (_report) (stats) ;
-	      error ("ccolamd: internal error!");
-	      return retval;
-	    }
-	}
+        {
+          // Order the columns (destroys A)
+          if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, 0))
+            {
+              CCOLAMD_NAME (_report) (stats) ;
+              error ("ccolamd: internal error!");
+              return retval;
+            }
+        }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-	out_perm(i) = p [i] + 1;
+        out_perm(i) = p [i] + 1;
 
       retval (0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
-	CCOLAMD_NAME (_report) (stats) ;
+        CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
-	{
-	  NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
-	  for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-	    out_stats (i) = stats [i] ;
-	  retval(1) = out_stats;
+        {
+          NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
+          for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
+            out_stats (i) = stats [i] ;
+          retval(1) = out_stats;
 
-	  // fix stats (5) and (6), for 1-based information on 
-	  // jumbled matrix.  note that this correction doesn't 
-	  // occur if symamd returns FALSE
-	  out_stats (CCOLAMD_INFO1) ++ ; 
-	  out_stats (CCOLAMD_INFO2) ++ ; 
-	}
+          // fix stats (5) and (6), for 1-based information on 
+          // jumbled matrix.  note that this correction doesn't 
+          // occur if symamd returns FALSE
+          out_stats (CCOLAMD_INFO1) ++ ; 
+          out_stats (CCOLAMD_INFO2) ++ ; 
+        }
     }
 
 #else
 
   error ("ccolamd: not available in this version of Octave");
 
 #endif
 
@@ -405,176 +405,176 @@ colamd, symamd, and other related orderi
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
       CCOLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin > 1)
-	{
-	  NDArray User_knobs = args(1).array_value ();
-	  int nel_User_knobs = User_knobs.length ();
-	  
-	  if (nel_User_knobs > 0) 
-	    knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
-	  if (nel_User_knobs > 0) 
-	    knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
-	  if (nel_User_knobs > 1) 
-	    spumoni = static_cast<int> (User_knobs (2));
+        {
+          NDArray User_knobs = args(1).array_value ();
+          int nel_User_knobs = User_knobs.length ();
+          
+          if (nel_User_knobs > 0) 
+            knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
+          if (nel_User_knobs > 0) 
+            knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
+          if (nel_User_knobs > 1) 
+            spumoni = static_cast<int> (User_knobs (2));
 
-	  // print knob settings if spumoni is set
-	  if (spumoni)
-	    {
-	      octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
-			    <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
+          // print knob settings if spumoni is set
+          if (spumoni)
+            {
+              octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
+                            <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
-	      if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-		octave_stdout << "knobs(1): " << User_knobs (0) 
-			      << ", rows/cols with > max(16,"
-			      << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
-			      << " entries removed\n";
-	      else
-		octave_stdout << "knobs(1): " << User_knobs (0)
-			      << ", no dense rows/cols removed\n";
+              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(1): " << User_knobs (0) 
+                              << ", rows/cols with > max(16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << " entries removed\n";
+              else
+                octave_stdout << "knobs(1): " << User_knobs (0)
+                              << ", no dense rows/cols removed\n";
 
-	      if (knobs [CCOLAMD_AGGRESSIVE] != 0)
-		octave_stdout << "knobs(2): " << User_knobs(1) 
-			      << ", aggressive absorption: yes";
-	      else
-		octave_stdout << "knobs(2): " << User_knobs(1) 
-			      << ", aggressive absorption: no";
+              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+                octave_stdout << "knobs(2): " << User_knobs(1) 
+                              << ", aggressive absorption: yes";
+              else
+                octave_stdout << "knobs(2): " << User_knobs(1) 
+                              << ", aggressive absorption: no";
  
 
-	      octave_stdout << "knobs(3): " << User_knobs (2) 
-			    << ", statistics and knobs printed\n";
-	    }
-	}
+              octave_stdout << "knobs(3): " << User_knobs (2) 
+                            << ", statistics and knobs printed\n";
+            }
+        }
       
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      scm = args(0).sparse_complex_matrix_value ();
-	      n_row = scm.rows ();
-	      n_col = scm.cols ();
-	      nnz = scm.nzmax ();
-	      ridx = scm.xridx ();
-	      cidx = scm.xcidx ();
-	    }
-	  else
-	    {
-	      sm = args(0).sparse_matrix_value ();
-	      n_row = sm.rows ();
-	      n_col = sm.cols ();
-	      nnz = sm.nzmax ();
-	      ridx = sm.xridx ();
-	      cidx = sm.xcidx ();
-	    }
-	}
+        {
+          if (args(0).is_complex_type ())
+            {
+              scm = args(0).sparse_complex_matrix_value ();
+              n_row = scm.rows ();
+              n_col = scm.cols ();
+              nnz = scm.nzmax ();
+              ridx = scm.xridx ();
+              cidx = scm.xcidx ();
+            }
+          else
+            {
+              sm = args(0).sparse_matrix_value ();
+              n_row = sm.rows ();
+              n_col = sm.cols ();
+              nnz = sm.nzmax ();
+              ridx = sm.xridx ();
+              cidx = sm.xcidx ();
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type ())
-	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-	  else
-	    sm = SparseMatrix (args(0).matrix_value ());
-	  
-	  n_row = sm.rows ();
-	  n_col = sm.cols ();
-	  nnz = sm.nzmax ();
-	  ridx = sm.xridx ();
-	  cidx = sm.xcidx ();
-	}
+        {
+          if (args(0).is_complex_type ())
+            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+          else
+            sm = SparseMatrix (args(0).matrix_value ());
+          
+          n_row = sm.rows ();
+          n_col = sm.cols ();
+          nnz = sm.nzmax ();
+          ridx = sm.xridx ();
+          cidx = sm.xcidx ();
+        }
 
       if (n_row != n_col)
-	{
-	  error ("symamd: matrix must be square");
-	  return retval;
-	}
+        {
+          error ("symamd: matrix must be square");
+          return retval;
+        }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
-	{
-	  NDArray in_cmember = args(2).array_value();
-	  octave_idx_type cslen = in_cmember.length();
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
-	  for (octave_idx_type i = 0; i < cslen; i++)
-	    // convert cmember from 1-based to 0-based
-	    cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
-	  
-	  if (cslen != n_col)
-	    error ("ccolamd: cmember must be of length equal to #cols of A");
-	  else
-	    if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
-				  &calloc, &free, cmember, -1))
-	      {
-		CSYMAMD_NAME (_report) (stats) ;
-		error ("symamd: internal error!") ;
-		return retval;
-	      }
-	}
+        {
+          NDArray in_cmember = args(2).array_value();
+          octave_idx_type cslen = in_cmember.length();
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
+          for (octave_idx_type i = 0; i < cslen; i++)
+            // convert cmember from 1-based to 0-based
+            cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
+          
+          if (cslen != n_col)
+            error ("ccolamd: cmember must be of length equal to #cols of A");
+          else
+            if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
+                                  &calloc, &free, cmember, -1))
+              {
+                CSYMAMD_NAME (_report) (stats) ;
+                error ("symamd: internal error!") ;
+                return retval;
+              }
+        }
       else
-	{
-	  if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
-				&calloc, &free, 0, -1))
-	    {
-	      CSYMAMD_NAME (_report) (stats) ;
-	      error ("symamd: internal error!") ;
-	      return retval;
-	    }
-	}
+        {
+          if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
+                                &calloc, &free, 0, -1))
+            {
+              CSYMAMD_NAME (_report) (stats) ;
+              error ("symamd: internal error!") ;
+              return retval;
+            }
+        }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-	out_perm(i) = perm [i] + 1;
+        out_perm(i) = perm [i] + 1;
 
       retval (0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
-	{
-	  NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
-	  for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-	    out_stats (i) = stats [i] ;
-	  retval(1) = out_stats;
+        {
+          NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
+          for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
+            out_stats (i) = stats [i] ;
+          retval(1) = out_stats;
 
-	  // fix stats (5) and (6), for 1-based information on 
-	  // jumbled matrix.  note that this correction doesn't 
-	  // occur if symamd returns FALSE
-	  out_stats (CCOLAMD_INFO1) ++ ; 
-	  out_stats (CCOLAMD_INFO2) ++ ; 
-	}
+          // fix stats (5) and (6), for 1-based information on 
+          // jumbled matrix.  note that this correction doesn't 
+          // occur if symamd returns FALSE
+          out_stats (CCOLAMD_INFO1) ++ ; 
+          out_stats (CCOLAMD_INFO2) ++ ; 
+        }
 
       // print stats if spumoni > 0
       if (spumoni > 0)
-	CSYMAMD_NAME (_report) (stats) ;
+        CSYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
-	{
-	  NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
-	  for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-	    out_stats (i) = stats [i] ;
-	  retval(1) = out_stats;
+        {
+          NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
+          for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
+            out_stats (i) = stats [i] ;
+          retval(1) = out_stats;
 
-	  // fix stats (5) and (6), for 1-based information on 
-	  // jumbled matrix.  note that this correction doesn't 
-	  // occur if symamd returns FALSE
-	  out_stats (CCOLAMD_INFO1) ++ ; 
-	  out_stats (CCOLAMD_INFO2) ++ ; 
-	}
+          // fix stats (5) and (6), for 1-based information on 
+          // jumbled matrix.  note that this correction doesn't 
+          // occur if symamd returns FALSE
+          out_stats (CCOLAMD_INFO1) ++ ; 
+          out_stats (CCOLAMD_INFO2) ++ ; 
+        }
     }
 
 #else
 
   error ("csymamd: not available in this version of Octave");
 
 #endif
 
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1276,164 +1276,164 @@ mat2cell (reshape(1:16,4,4),[3,1],[3,1])
     print_usage ();
   else
     {
       dim_vector dv = args(0).dims();
       dim_vector new_dv;
       new_dv.resize(dv.length());
       
       if (nargin > 2)
-	{
-	  octave_idx_type nmax = -1;
+        {
+          octave_idx_type nmax = -1;
 
-	  if (nargin - 1 != dv.length())
-	    error ("mat2cell: Incorrect number of dimensions");
-	  else
-	    {
-	      for (octave_idx_type j = 0; j < dv.length(); j++)
-		{
-		  ColumnVector d = ColumnVector (args(j+1).vector_value 
-						 (false, true));
+          if (nargin - 1 != dv.length())
+            error ("mat2cell: Incorrect number of dimensions");
+          else
+            {
+              for (octave_idx_type j = 0; j < dv.length(); j++)
+                {
+                  ColumnVector d = ColumnVector (args(j+1).vector_value 
+                                                 (false, true));
 
-		  if (d.length() < 1)
-		    {
-		      error ("mat2cell: dimension can not be empty");
-		      break;
-		    }
-		  else
-		    {
-		      if (nmax < d.length())
-			nmax = d.length();
+                  if (d.length() < 1)
+                    {
+                      error ("mat2cell: dimension can not be empty");
+                      break;
+                    }
+                  else
+                    {
+                      if (nmax < d.length())
+                        nmax = d.length();
 
-		      for (octave_idx_type i = 1; i < d.length(); i++)
-			{
-			  OCTAVE_QUIT;
+                      for (octave_idx_type i = 1; i < d.length(); i++)
+                        {
+                          OCTAVE_QUIT;
 
-			  if (d(i) >= 0)
-			    d(i) += d(i-1);
-			  else
-			    {
-			      error ("mat2cell: invalid dimensional argument");
-			      break;
-			    }
-			}
+                          if (d(i) >= 0)
+                            d(i) += d(i-1);
+                          else
+                            {
+                              error ("mat2cell: invalid dimensional argument");
+                              break;
+                            }
+                        }
 
-		      if (d(0) < 0)
-			error ("mat2cell: invalid dimensional argument");
-		      
-		      if (d(d.length() - 1) != dv(j))
-			error ("mat2cell: inconsistent dimensions");
+                      if (d(0) < 0)
+                        error ("mat2cell: invalid dimensional argument");
+                      
+                      if (d(d.length() - 1) != dv(j))
+                        error ("mat2cell: inconsistent dimensions");
 
-		      if (error_state)
-			break;
+                      if (error_state)
+                        break;
 
-		      new_dv(j) = d.length();
-		    }
-		}
-	    }
+                      new_dv(j) = d.length();
+                    }
+                }
+            }
 
-	  if (! error_state)
-	    {
-	      // Construct a matrix with the index values
-	      Matrix dimargs(nmax, new_dv.length());
-	      for (octave_idx_type j = 0; j < new_dv.length(); j++)
-		{
-		  OCTAVE_QUIT;
+          if (! error_state)
+            {
+              // Construct a matrix with the index values
+              Matrix dimargs(nmax, new_dv.length());
+              for (octave_idx_type j = 0; j < new_dv.length(); j++)
+                {
+                  OCTAVE_QUIT;
 
-		  ColumnVector d = ColumnVector (args(j+1).vector_value 
-						 (false, true));
+                  ColumnVector d = ColumnVector (args(j+1).vector_value 
+                                                 (false, true));
 
-		  dimargs(0,j) = d(0);
-		  for (octave_idx_type i = 1; i < d.length(); i++)
-		    dimargs(i,j) = dimargs(i-1,j) + d(i);
-		}
+                  dimargs(0,j) = d(0);
+                  for (octave_idx_type i = 1; i < d.length(); i++)
+                    dimargs(i,j) = dimargs(i-1,j) + d(i);
+                }
 
 
-	      octave_value_list lst (new_dv.length(), octave_value());
-	      Cell ret (new_dv);
-	      octave_idx_type nel = new_dv.numel();
-	      octave_idx_type ntot = 1;
+              octave_value_list lst (new_dv.length(), octave_value());
+              Cell ret (new_dv);
+              octave_idx_type nel = new_dv.numel();
+              octave_idx_type ntot = 1;
 
-	      for (int j = 0; j < new_dv.length()-1; j++)
-		ntot *= new_dv(j);
+              for (int j = 0; j < new_dv.length()-1; j++)
+                ntot *= new_dv(j);
 
-	      for (octave_idx_type i = 0; i <  nel; i++)
-		{
-		  octave_idx_type n = ntot;
-		  octave_idx_type ii = i;
-		  for (octave_idx_type j =  new_dv.length() - 1;  j >= 0; j--)
-		    {
-		      OCTAVE_QUIT;
-		  
-		      octave_idx_type idx = ii / n;
-		      lst (j) = Range((idx == 0 ? 1. : dimargs(idx-1,j)+1.),
-				      dimargs(idx,j));
-		      ii = ii % n;
-		      if (j != 0)
-			n /= new_dv(j-1);
-		    }
-		  ret(i) = octave_value(args(0)).do_index_op(lst, 0);
-		  if (error_state)
-		    break;
-		}
-	  
-	      if (!error_state)
-		retval = ret;
-	    }
-	}
+              for (octave_idx_type i = 0; i <  nel; i++)
+                {
+                  octave_idx_type n = ntot;
+                  octave_idx_type ii = i;
+                  for (octave_idx_type j =  new_dv.length() - 1;  j >= 0; j--)
+                    {
+                      OCTAVE_QUIT;
+                  
+                      octave_idx_type idx = ii / n;
+                      lst (j) = Range((idx == 0 ? 1. : dimargs(idx-1,j)+1.),
+                                      dimargs(idx,j));
+                      ii = ii % n;
+                      if (j != 0)
+                        n /= new_dv(j-1);
+                    }
+                  ret(i) = octave_value(args(0)).do_index_op(lst, 0);
+                  if (error_state)
+                    break;
+                }
+          
+              if (!error_state)
+                retval = ret;
+            }
+        }
       else
-	{
-	  ColumnVector d = ColumnVector (args(1).vector_value 
-					 (false, true));
+        {
+          ColumnVector d = ColumnVector (args(1).vector_value 
+                                         (false, true));
 
-	  double sumd = 0.;
-	  for (octave_idx_type i = 0; i < d.length(); i++)
-	    {
-	      OCTAVE_QUIT;
+          double sumd = 0.;
+          for (octave_idx_type i = 0; i < d.length(); i++)
+            {
+              OCTAVE_QUIT;
 
-	      if (d(i) >= 0)
-		sumd += d(i);
-	      else
-		{
-		  error ("mat2cell: invalid dimensional argument");
-		  break;
-		}
-	    }
+              if (d(i) >= 0)
+                sumd += d(i);
+              else
+                {
+                  error ("mat2cell: invalid dimensional argument");
+                  break;
+                }
+            }
 
-	  if (sumd != dv(0))
-	    error ("mat2cell: inconsistent dimensions");
+          if (sumd != dv(0))
+            error ("mat2cell: inconsistent dimensions");
 
-	  new_dv(0) = d.length();
-	  for (octave_idx_type i = 1; i < dv.length(); i++)
-	    new_dv(i) = 1;
+          new_dv(0) = d.length();
+          for (octave_idx_type i = 1; i < dv.length(); i++)
+            new_dv(i) = 1;
 
-	  if (! error_state)
-	    {
-	      octave_value_list lst (new_dv.length(), octave_value());
-	      Cell ret (new_dv);
+          if (! error_state)
+            {
+              octave_value_list lst (new_dv.length(), octave_value());
+              Cell ret (new_dv);
 
-	      for (octave_idx_type i = 1; i < new_dv.length(); i++)
-		lst (i) = Range (1., static_cast<double>(dv(i)));
-	      
-	      double idx = 0.;
-	      for (octave_idx_type i = 0; i <  new_dv(0); i++)
-		{
-		  OCTAVE_QUIT;
+              for (octave_idx_type i = 1; i < new_dv.length(); i++)
+                lst (i) = Range (1., static_cast<double>(dv(i)));
+              
+              double idx = 0.;
+              for (octave_idx_type i = 0; i <  new_dv(0); i++)
+                {
+                  OCTAVE_QUIT;
 
-		  lst(0) = Range(idx + 1., idx + d(i));
-		  ret(i) = octave_value(args(0)).do_index_op(lst, 0);
-		  idx += d(i);
-		  if (error_state)
-		    break;
-		}
-	  
-	      if (!error_state)
-		retval = ret;
-	    }
-	}
+                  lst(0) = Range(idx + 1., idx + d(i));
+                  ret(i) = octave_value(args(0)).do_index_op(lst, 0);
+                  idx += d(i);
+                  if (error_state)
+                    break;
+                }
+          
+              if (!error_state)
+                retval = ret;
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!test
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -143,197 +143,197 @@ sparse matrices.\n\
     }
 
   int n = 1;
   while (n < nargin && ! error_state)
     {
       std::string tmp = args(n++).string_value ();
 
       if (! error_state )
-	{
-	  if (tmp.compare ("vector") == 0)
-	    vecout = true;
-	  else if (tmp.compare ("lower") == 0)
-	    LLt = true;
-	  else if (tmp.compare ("upper") == 0)
-	    LLt = false;
-	  else
-	    error ("chol: unexpected second or third input");
-	}
+        {
+          if (tmp.compare ("vector") == 0)
+            vecout = true;
+          else if (tmp.compare ("lower") == 0)
+            LLt = true;
+          else if (tmp.compare ("upper") == 0)
+            LLt = false;
+          else
+            error ("chol: unexpected second or third input");
+        }
       else
-	error ("chol: expecting trailing string arguments");
+        error ("chol: expecting trailing string arguments");
     }
 
   if (! error_state)
     {
       octave_value arg = args(0);
     
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
       bool natural = (nargout != 3);
 
       int arg_is_empty = empty_arg ("chol", nr, nc);
 
       if (arg_is_empty < 0)
-	return retval;
+        return retval;
       if (arg_is_empty > 0)
-	return octave_value (Matrix ());
+        return octave_value (Matrix ());
 
       if (arg.is_sparse_type ())
-	{
-	  if (arg.is_real_type ())
-	    {
-	      SparseMatrix m = arg.sparse_matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              SparseMatrix m = arg.sparse_matrix_value ();
 
-	      if (! error_state)
-		{
-		  octave_idx_type info;
-		  SparseCHOL fact (m, info, natural);
-		  if (nargout == 3)
-		    {
-		      if (vecout)
-			retval(2) = fact.perm ();
-		      else
-			retval(2) = fact.Q();
-		    }
+              if (! error_state)
+                {
+                  octave_idx_type info;
+                  SparseCHOL fact (m, info, natural);
+                  if (nargout == 3)
+                    {
+                      if (vecout)
+                        retval(2) = fact.perm ();
+                      else
+                        retval(2) = fact.Q();
+                    }
 
-		  if (nargout > 1 || info == 0)
-		    {
-		      retval(1) = fact.P();
-		      if (LLt)
-			retval(0) = fact.L();
-		      else
-			retval(0) = fact.R();
-		    }
-		  else
-		    error ("chol: matrix not positive definite");
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
+                  if (nargout > 1 || info == 0)
+                    {
+                      retval(1) = fact.P();
+                      if (LLt)
+                        retval(0) = fact.L();
+                      else
+                        retval(0) = fact.R();
+                    }
+                  else
+                    error ("chol: matrix not positive definite");
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  octave_idx_type info;
-		  SparseComplexCHOL fact (m, info, natural);
+              if (! error_state)
+                {
+                  octave_idx_type info;
+                  SparseComplexCHOL fact (m, info, natural);
 
-		  if (nargout == 3)
-		    {
-		      if (vecout)
-			retval(2) = fact.perm ();
-		      else
-			retval(2) = fact.Q();
-		    }
-	  
-		  if (nargout > 1 || info == 0)
-		    {
-		      retval(1) = fact.P();
-		      if (LLt)
-			retval(0) = fact.L();
-		      else
-			retval(0) = fact.R();
-		    }
-		  else
-		    error ("chol: matrix not positive definite");
-		}
-	    }
-	  else
-	    gripe_wrong_type_arg ("chol", arg);
-	}
+                  if (nargout == 3)
+                    {
+                      if (vecout)
+                        retval(2) = fact.perm ();
+                      else
+                        retval(2) = fact.Q();
+                    }
+          
+                  if (nargout > 1 || info == 0)
+                    {
+                      retval(1) = fact.P();
+                      if (LLt)
+                        retval(0) = fact.L();
+                      else
+                        retval(0) = fact.R();
+                    }
+                  else
+                    error ("chol: matrix not positive definite");
+                }
+            }
+          else
+            gripe_wrong_type_arg ("chol", arg);
+        }
       else if (arg.is_single_type ())
-	{
-	  if (arg.is_real_type ())
-	    {
-	      FloatMatrix m = arg.float_matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              FloatMatrix m = arg.float_matrix_value ();
 
-	      if (! error_state)
-		{
-		  octave_idx_type info;
-		  FloatCHOL fact (m, info);
-		  if (nargout == 2 || info == 0)
-		    {
-		      retval(1) = info;
-		      if (LLt)
-			retval(0) = get_chol_l (fact);
-		      else
-			retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    error ("chol: matrix not positive definite");
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      FloatComplexMatrix m = arg.float_complex_matrix_value ();
+              if (! error_state)
+                {
+                  octave_idx_type info;
+                  FloatCHOL fact (m, info);
+                  if (nargout == 2 || info == 0)
+                    {
+                      retval(1) = info;
+                      if (LLt)
+                        retval(0) = get_chol_l (fact);
+                      else
+                        retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    error ("chol: matrix not positive definite");
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  octave_idx_type info;
-		  FloatComplexCHOL fact (m, info);
-		  if (nargout == 2 || info == 0)
-		    {
-		      retval(1) = info;
-		      if (LLt)
-			retval(0) = get_chol_l (fact);
-		      else
-			retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    error ("chol: matrix not positive definite");
-		}
-	    }
-	  else
-	    gripe_wrong_type_arg ("chol", arg);
-	}
+              if (! error_state)
+                {
+                  octave_idx_type info;
+                  FloatComplexCHOL fact (m, info);
+                  if (nargout == 2 || info == 0)
+                    {
+                      retval(1) = info;
+                      if (LLt)
+                        retval(0) = get_chol_l (fact);
+                      else
+                        retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    error ("chol: matrix not positive definite");
+                }
+            }
+          else
+            gripe_wrong_type_arg ("chol", arg);
+        }
       else
-	{
-	  if (arg.is_real_type ())
-	    {
-	      Matrix m = arg.matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              Matrix m = arg.matrix_value ();
 
-	      if (! error_state)
-		{
-		  octave_idx_type info;
-		  CHOL fact (m, info);
-		  if (nargout == 2 || info == 0)
-		    {
-		      retval(1) = info;
-		      if (LLt)
-			retval(0) = get_chol_l (fact);
-		      else
-			retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    error ("chol: matrix not positive definite");
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      ComplexMatrix m = arg.complex_matrix_value ();
+              if (! error_state)
+                {
+                  octave_idx_type info;
+                  CHOL fact (m, info);
+                  if (nargout == 2 || info == 0)
+                    {
+                      retval(1) = info;
+                      if (LLt)
+                        retval(0) = get_chol_l (fact);
+                      else
+                        retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    error ("chol: matrix not positive definite");
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              ComplexMatrix m = arg.complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  octave_idx_type info;
-		  ComplexCHOL fact (m, info);
-		  if (nargout == 2 || info == 0)
-		    {
-		      retval(1) = info;
-		      if (LLt)
-			retval(0) = get_chol_l (fact);
-		      else
-			retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    error ("chol: matrix not positive definite");
-		}
-	    }
-	  else
-	    gripe_wrong_type_arg ("chol", arg);
-	}
+              if (! error_state)
+                {
+                  octave_idx_type info;
+                  ComplexCHOL fact (m, info);
+                  if (nargout == 2 || info == 0)
+                    {
+                      retval(1) = info;
+                      if (LLt)
+                        retval(0) = get_chol_l (fact);
+                      else
+                        retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    error ("chol: matrix not positive definite");
+                }
+            }
+          else
+            gripe_wrong_type_arg ("chol", arg);
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!assert(chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps));
@@ -361,119 +361,119 @@ symmetric positive definite matrix @var{
   if (nargin == 1)
     {
       octave_value arg = args(0);
     
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
 
       if (nr == 0 || nc == 0)
-	retval = Matrix ();
+        retval = Matrix ();
       else
-	{
-	  if (arg.is_sparse_type ())
-	    {
-	      if (arg.is_real_type ())
-		{
-		  SparseMatrix m = arg.sparse_matrix_value ();
+        {
+          if (arg.is_sparse_type ())
+            {
+              if (arg.is_real_type ())
+                {
+                  SparseMatrix m = arg.sparse_matrix_value ();
 
-		  if (! error_state)
-		    {
-		      octave_idx_type info;
-		      SparseCHOL chol (m, info);
-		      if (info == 0)
-			retval = chol.inverse ();
-		      else
-			error ("cholinv: matrix not positive definite");
-		    }
-		}
-	      else if (arg.is_complex_type ())
-		{
-		  SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
+                  if (! error_state)
+                    {
+                      octave_idx_type info;
+                      SparseCHOL chol (m, info);
+                      if (info == 0)
+                        retval = chol.inverse ();
+                      else
+                        error ("cholinv: matrix not positive definite");
+                    }
+                }
+              else if (arg.is_complex_type ())
+                {
+                  SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-		  if (! error_state)
-		    {
-		      octave_idx_type info;
-		      SparseComplexCHOL chol (m, info);
-		      if (info == 0)
-			retval = chol.inverse ();
-		      else
-			error ("cholinv: matrix not positive definite");
-		    }
-		}
-	      else
-		gripe_wrong_type_arg ("cholinv", arg);
-	    }
-	  else if (arg.is_single_type ())
-	    {
-	      if (arg.is_real_type ())
-		{
-		  FloatMatrix m = arg.float_matrix_value ();
+                  if (! error_state)
+                    {
+                      octave_idx_type info;
+                      SparseComplexCHOL chol (m, info);
+                      if (info == 0)
+                        retval = chol.inverse ();
+                      else
+                        error ("cholinv: matrix not positive definite");
+                    }
+                }
+              else
+                gripe_wrong_type_arg ("cholinv", arg);
+            }
+          else if (arg.is_single_type ())
+            {
+              if (arg.is_real_type ())
+                {
+                  FloatMatrix m = arg.float_matrix_value ();
 
-		  if (! error_state)
-		    {
-		      octave_idx_type info;
-		      FloatCHOL chol (m, info);
-		      if (info == 0)
-			retval = chol.inverse ();
-		      else
-			error ("cholinv: matrix not positive definite");
-		    }
-		}
-	      else if (arg.is_complex_type ())
-		{
-		  FloatComplexMatrix m = arg.float_complex_matrix_value ();
+                  if (! error_state)
+                    {
+                      octave_idx_type info;
+                      FloatCHOL chol (m, info);
+                      if (info == 0)
+                        retval = chol.inverse ();
+                      else
+                        error ("cholinv: matrix not positive definite");
+                    }
+                }
+              else if (arg.is_complex_type ())
+                {
+                  FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-		  if (! error_state)
-		    {
-		      octave_idx_type info;
-		      FloatComplexCHOL chol (m, info);
-		      if (info == 0)
-			retval = chol.inverse ();
-		      else
-			error ("cholinv: matrix not positive definite");
-		    }
-		}
-	      else
-		gripe_wrong_type_arg ("chol", arg);
-	    }
-	  else
-	    {
-	      if (arg.is_real_type ())
-		{
-		  Matrix m = arg.matrix_value ();
+                  if (! error_state)
+                    {
+                      octave_idx_type info;
+                      FloatComplexCHOL chol (m, info);
+                      if (info == 0)
+                        retval = chol.inverse ();
+                      else
+                        error ("cholinv: matrix not positive definite");
+                    }
+                }
+              else
+                gripe_wrong_type_arg ("chol", arg);
+            }
+          else
+            {
+              if (arg.is_real_type ())
+                {
+                  Matrix m = arg.matrix_value ();
 
-		  if (! error_state)
-		    {
-		      octave_idx_type info;
-		      CHOL chol (m, info);
-		      if (info == 0)
-			retval = chol.inverse ();
-		      else
-			error ("cholinv: matrix not positive definite");
-		    }
-		}
-	      else if (arg.is_complex_type ())
-		{
-		  ComplexMatrix m = arg.complex_matrix_value ();
+                  if (! error_state)
+                    {
+                      octave_idx_type info;
+                      CHOL chol (m, info);
+                      if (info == 0)
+                        retval = chol.inverse ();
+                      else
+                        error ("cholinv: matrix not positive definite");
+                    }
+                }
+              else if (arg.is_complex_type ())
+                {
+                  ComplexMatrix m = arg.complex_matrix_value ();
 
-		  if (! error_state)
-		    {
-		      octave_idx_type info;
-		      ComplexCHOL chol (m, info);
-		      if (info == 0)
-			retval = chol.inverse ();
-		      else
-			error ("cholinv: matrix not positive definite");
-		    }
-		}
-	      else
-		gripe_wrong_type_arg ("chol", arg);
-	    }
-	}
+                  if (! error_state)
+                    {
+                      octave_idx_type info;
+                      ComplexCHOL chol (m, info);
+                      if (info == 0)
+                        retval = chol.inverse ();
+                      else
+                        error ("cholinv: matrix not positive definite");
+                    }
+                }
+              else
+                gripe_wrong_type_arg ("chol", arg);
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -514,78 +514,78 @@ using @code{inv}.\n\
   if (nargin == 1)
     {
       octave_value arg = args(0);
     
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
 
       if (nr == 0 || nc == 0)
-	retval = Matrix ();
+        retval = Matrix ();
       else
-	{
-	  if (arg.is_sparse_type ())
-	    {
-	      if (arg.is_real_type ())
-		{
-		  SparseMatrix r = arg.sparse_matrix_value ();
+        {
+          if (arg.is_sparse_type ())
+            {
+              if (arg.is_real_type ())
+                {
+                  SparseMatrix r = arg.sparse_matrix_value ();
 
-		  if (! error_state)
-		    retval = chol2inv (r);
-		}
-	      else if (arg.is_complex_type ())
-		{
-		  SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
+                  if (! error_state)
+                    retval = chol2inv (r);
+                }
+              else if (arg.is_complex_type ())
+                {
+                  SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
-		  if (! error_state)
-		    retval = chol2inv (r);
-		}
-	      else
-		gripe_wrong_type_arg ("chol2inv", arg);
-	    }
-	  else if (arg.is_single_type ())
-	    {
-	      if (arg.is_real_type ())
-		{
-		  FloatMatrix r = arg.float_matrix_value ();
+                  if (! error_state)
+                    retval = chol2inv (r);
+                }
+              else
+                gripe_wrong_type_arg ("chol2inv", arg);
+            }
+          else if (arg.is_single_type ())
+            {
+              if (arg.is_real_type ())
+                {
+                  FloatMatrix r = arg.float_matrix_value ();
 
-		  if (! error_state)
-		    retval = chol2inv (r);
-		}
-	      else if (arg.is_complex_type ())
-		{
-		  FloatComplexMatrix r = arg.float_complex_matrix_value ();
+                  if (! error_state)
+                    retval = chol2inv (r);
+                }
+              else if (arg.is_complex_type ())
+                {
+                  FloatComplexMatrix r = arg.float_complex_matrix_value ();
 
-		  if (! error_state)
-		    retval = chol2inv (r);
-		}
-	      else
-		gripe_wrong_type_arg ("chol2inv", arg);
+                  if (! error_state)
+                    retval = chol2inv (r);
+                }
+              else
+                gripe_wrong_type_arg ("chol2inv", arg);
 
-	    }
-	  else
-	    {
-	      if (arg.is_real_type ())
-		{
-		  Matrix r = arg.matrix_value ();
+            }
+          else
+            {
+              if (arg.is_real_type ())
+                {
+                  Matrix r = arg.matrix_value ();
 
-		  if (! error_state)
-		    retval = chol2inv (r);
-		}
-	      else if (arg.is_complex_type ())
-		{
-		  ComplexMatrix r = arg.complex_matrix_value ();
+                  if (! error_state)
+                    retval = chol2inv (r);
+                }
+              else if (arg.is_complex_type ())
+                {
+                  ComplexMatrix r = arg.complex_matrix_value ();
 
-		  if (! error_state)
-		    retval = chol2inv (r);
-		}
-	      else
-		gripe_wrong_type_arg ("chol2inv", arg);
-	    }
-	}
+                  if (! error_state)
+                    retval = chol2inv (r);
+                }
+              else
+                gripe_wrong_type_arg ("chol2inv", arg);
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
@@ -635,86 +635,86 @@ If @var{info} is not present, an error m
       std::string op = (nargin < 3) ? "+" : args(2).string_value ();
 
       bool down = op == "-";
 
       if (down || op == "+")
         if (argr.columns () == n && argu.rows () == n && argu.columns () == 1)
           {
             int err = 0;
-	    if (argr.is_single_type () || argu.is_single_type ())
-	      {
-		if (argr.is_real_type () && argu.is_real_type ())
-		  {
-		    // real case
-		    FloatMatrix R = argr.float_matrix_value ();
-		    FloatColumnVector u = argu.float_column_vector_value ();
+            if (argr.is_single_type () || argu.is_single_type ())
+              {
+                if (argr.is_real_type () && argu.is_real_type ())
+                  {
+                    // real case
+                    FloatMatrix R = argr.float_matrix_value ();
+                    FloatColumnVector u = argu.float_column_vector_value ();
 
-		    FloatCHOL fact;
-		    fact.set (R);
+                    FloatCHOL fact;
+                    fact.set (R);
 
-		    if (down)
-		      err = fact.downdate (u);
-		    else
-		      fact.update (u);
+                    if (down)
+                      err = fact.downdate (u);
+                    else
+                      fact.update (u);
 
-		    retval(0) = get_chol_r (fact);
-		  }
-		else
-		  {
-		    // complex case
-		    FloatComplexMatrix R = argr.float_complex_matrix_value ();
-		    FloatComplexColumnVector u = argu.float_complex_column_vector_value ();
+                    retval(0) = get_chol_r (fact);
+                  }
+                else
+                  {
+                    // complex case
+                    FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                    FloatComplexColumnVector u = argu.float_complex_column_vector_value ();
 
-		    FloatComplexCHOL fact;
-		    fact.set (R);
+                    FloatComplexCHOL fact;
+                    fact.set (R);
 
-		    if (down)
-		      err = fact.downdate (u);
-		    else
-		      fact.update (u);
+                    if (down)
+                      err = fact.downdate (u);
+                    else
+                      fact.update (u);
 
-		    retval(0) = get_chol_r (fact);
-		  }
-	      }
-	    else
-	      {
-		if (argr.is_real_type () && argu.is_real_type ())
-		  {
-		    // real case
-		    Matrix R = argr.matrix_value ();
-		    ColumnVector u = argu.column_vector_value ();
+                    retval(0) = get_chol_r (fact);
+                  }
+              }
+            else
+              {
+                if (argr.is_real_type () && argu.is_real_type ())
+                  {
+                    // real case
+                    Matrix R = argr.matrix_value ();
+                    ColumnVector u = argu.column_vector_value ();
 
-		    CHOL fact;
-		    fact.set (R);
+                    CHOL fact;
+                    fact.set (R);
 
-		    if (down)
-		      err = fact.downdate (u);
-		    else
-		      fact.update (u);
+                    if (down)
+                      err = fact.downdate (u);
+                    else
+                      fact.update (u);
 
-		    retval(0) = get_chol_r (fact);
-		  }
-		else
-		  {
-		    // complex case
-		    ComplexMatrix R = argr.complex_matrix_value ();
-		    ComplexColumnVector u = argu.complex_column_vector_value ();
+                    retval(0) = get_chol_r (fact);
+                  }
+                else
+                  {
+                    // complex case
+                    ComplexMatrix R = argr.complex_matrix_value ();
+                    ComplexColumnVector u = argu.complex_column_vector_value ();
 
-		    ComplexCHOL fact;
-		    fact.set (R);
+                    ComplexCHOL fact;
+                    fact.set (R);
 
-		    if (down)
-		      err = fact.downdate (u);
-		    else
-		      fact.update (u);
+                    if (down)
+                      err = fact.downdate (u);
+                    else
+                      fact.update (u);
 
-		    retval(0) = get_chol_r (fact);
-		  }
-	      }
+                    retval(0) = get_chol_r (fact);
+                  }
+              }
 
             if (nargout > 1)
               retval(1) = err;
             else if (err == 1)
               error ("cholupdate: downdate violates positiveness");
             else if (err == 2)
               error ("cholupdate: singular matrix");
           }
@@ -844,70 +844,70 @@ If @var{info} is not present, an error m
       octave_idx_type n = argr.rows ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n && argu.rows () == n+1 && argu.columns () == 1)
         {
           if (j > 0 && j <= n+1)
             {
               int err = 0;
-	      if (argr.is_single_type () || argu.is_single_type ())
-		{
-		  if (argr.is_real_type () && argu.is_real_type ())
-		    {
-		      // real case
-		      FloatMatrix R = argr.float_matrix_value ();
-		      FloatColumnVector u = argu.float_column_vector_value ();
+              if (argr.is_single_type () || argu.is_single_type ())
+                {
+                  if (argr.is_real_type () && argu.is_real_type ())
+                    {
+                      // real case
+                      FloatMatrix R = argr.float_matrix_value ();
+                      FloatColumnVector u = argu.float_column_vector_value ();
 
-		      FloatCHOL fact;
-		      fact.set (R);
-		      err = fact.insert_sym (u, j-1);
+                      FloatCHOL fact;
+                      fact.set (R);
+                      err = fact.insert_sym (u, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    {
-		      // complex case
-		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
-		      FloatComplexColumnVector u = argu.float_complex_column_vector_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    {
+                      // complex case
+                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                      FloatComplexColumnVector u = argu.float_complex_column_vector_value ();
 
-		      FloatComplexCHOL fact;
-		      fact.set (R);
-		      err = fact.insert_sym (u, j-1);
+                      FloatComplexCHOL fact;
+                      fact.set (R);
+                      err = fact.insert_sym (u, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		}
-	      else
-		{
-		  if (argr.is_real_type () && argu.is_real_type ())
-		    {
-		      // real case
-		      Matrix R = argr.matrix_value ();
-		      ColumnVector u = argu.column_vector_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                }
+              else
+                {
+                  if (argr.is_real_type () && argu.is_real_type ())
+                    {
+                      // real case
+                      Matrix R = argr.matrix_value ();
+                      ColumnVector u = argu.column_vector_value ();
 
-		      CHOL fact;
-		      fact.set (R);
-		      err = fact.insert_sym (u, j-1);
+                      CHOL fact;
+                      fact.set (R);
+                      err = fact.insert_sym (u, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    {
-		      // complex case
-		      ComplexMatrix R = argr.complex_matrix_value ();
-		      ComplexColumnVector u = argu.complex_column_vector_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    {
+                      // complex case
+                      ComplexMatrix R = argr.complex_matrix_value ();
+                      ComplexColumnVector u = argu.complex_column_vector_value ();
 
-		      ComplexCHOL fact;
-		      fact.set (R);
-		      err = fact.insert_sym (u, j-1);
+                      ComplexCHOL fact;
+                      fact.set (R);
+                      err = fact.insert_sym (u, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		}
+                      retval(0) = get_chol_r (fact);
+                    }
+                }
 
               if (nargout > 1)
                 retval(1) = err;
               else if (err == 1)
                 error ("cholinsert: insertion violates positiveness");
               else if (err == 2)
                 error ("cholinsert: singular matrix");
               else if (err == 3)
@@ -1015,66 +1015,66 @@ return the Cholesky@tie{}factorization o
     {
       octave_idx_type n = argr.rows ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n)
             {
-	      if (argr.is_single_type ())
-		{
-		  if (argr.is_real_type ())
-		    {
-		      // real case
-		      FloatMatrix R = argr.float_matrix_value ();
+              if (argr.is_single_type ())
+                {
+                  if (argr.is_real_type ())
+                    {
+                      // real case
+                      FloatMatrix R = argr.float_matrix_value ();
 
-		      FloatCHOL fact;
-		      fact.set (R);
-		      fact.delete_sym (j-1);
+                      FloatCHOL fact;
+                      fact.set (R);
+                      fact.delete_sym (j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    {
-		      // complex case
-		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    {
+                      // complex case
+                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-		      FloatComplexCHOL fact;
-		      fact.set (R);
-		      fact.delete_sym (j-1);
+                      FloatComplexCHOL fact;
+                      fact.set (R);
+                      fact.delete_sym (j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		}
-	      else
-		{
-		  if (argr.is_real_type ())
-		    {
-		      // real case
-		      Matrix R = argr.matrix_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                }
+              else
+                {
+                  if (argr.is_real_type ())
+                    {
+                      // real case
+                      Matrix R = argr.matrix_value ();
 
-		      CHOL fact;
-		      fact.set (R);
-		      fact.delete_sym (j-1);
+                      CHOL fact;
+                      fact.set (R);
+                      fact.delete_sym (j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    {
-		      // complex case
-		      ComplexMatrix R = argr.complex_matrix_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    {
+                      // complex case
+                      ComplexMatrix R = argr.complex_matrix_value ();
 
-		      ComplexCHOL fact;
-		      fact.set (R);
-		      fact.delete_sym (j-1);
+                      ComplexCHOL fact;
+                      fact.set (R);
+                      fact.delete_sym (j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		}
+                      retval(0) = get_chol_r (fact);
+                    }
+                }
             }
           else
             error ("choldelete: index out of range");
         }
       else
         error ("choldelete: dimension mismatch");
     }
   else
@@ -1155,67 +1155,67 @@ return the Cholesky@tie{}factorization o
       octave_idx_type i = argi.scalar_value ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
             {
 
-	      if (argr.is_single_type () && argi.is_single_type () && 
-		  argj.is_single_type ())
-		{
-		  if (argr.is_real_type ())
-		    {
-		      // real case
-		      FloatMatrix R = argr.float_matrix_value ();
+              if (argr.is_single_type () && argi.is_single_type () && 
+                  argj.is_single_type ())
+                {
+                  if (argr.is_real_type ())
+                    {
+                      // real case
+                      FloatMatrix R = argr.float_matrix_value ();
 
-		      FloatCHOL fact;
-		      fact.set (R);
-		      fact.shift_sym (i-1, j-1);
+                      FloatCHOL fact;
+                      fact.set (R);
+                      fact.shift_sym (i-1, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    {
-		      // complex case
-		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    {
+                      // complex case
+                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-		      FloatComplexCHOL fact;
-		      fact.set (R);
-		      fact.shift_sym (i-1, j-1);
+                      FloatComplexCHOL fact;
+                      fact.set (R);
+                      fact.shift_sym (i-1, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		}
-	      else
-		{
-		  if (argr.is_real_type ())
-		    {
-		      // real case
-		      Matrix R = argr.matrix_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                }
+              else
+                {
+                  if (argr.is_real_type ())
+                    {
+                      // real case
+                      Matrix R = argr.matrix_value ();
 
-		      CHOL fact;
-		      fact.set (R);
-		      fact.shift_sym (i-1, j-1);
+                      CHOL fact;
+                      fact.set (R);
+                      fact.shift_sym (i-1, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		  else
-		    {
-		      // complex case
-		      ComplexMatrix R = argr.complex_matrix_value ();
+                      retval(0) = get_chol_r (fact);
+                    }
+                  else
+                    {
+                      // complex case
+                      ComplexMatrix R = argr.complex_matrix_value ();
 
-		      ComplexCHOL fact;
-		      fact.set (R);
-		      fact.shift_sym (i-1, j-1);
+                      ComplexCHOL fact;
+                      fact.set (R);
+                      fact.shift_sym (i-1, j-1);
 
-		      retval(0) = get_chol_r (fact);
-		    }
-		}
+                      retval(0) = get_chol_r (fact);
+                    }
+                }
             }
           else
             error ("cholshift: index out of range");
         }
       else
         error ("cholshift: dimension mismatch");
     }
   else
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -51,48 +51,48 @@ along with Octave; see the file COPYING.
 #define COLAMD_NAME(name) colamd ## name
 #define SYMAMD_NAME(name) symamd ## name
 #endif
 
 // The symmetric column elimination tree code take from the Davis LDL code. 
 // Copyright given elsewhere in this file.
 static void
 symetree (const octave_idx_type *ridx, const octave_idx_type *cidx, 
-	  octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
+          octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Flag, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Pinv, (P ? n : 0));
   if (P)
     // If P is present then compute Pinv, the inverse of P
     for (octave_idx_type k = 0 ; k < n ; k++)
       Pinv [P [k]] = k ;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
-      Parent [k] = n ;	              // parent of k is not yet known 
-      Flag [k] = k ;		      // mark node k as visited 
+      Parent [k] = n ;                // parent of k is not yet known 
+      Flag [k] = k ;                  // mark node k as visited 
       octave_idx_type kk = (P) ? (P [k]) : (k) ;  // kth original, or permuted, column
       octave_idx_type p2 = cidx [kk+1] ;
       for (octave_idx_type p = cidx [kk] ; p < p2 ; p++)
-	{
-	  // A (i,k) is nonzero (original or permuted A)
-	  octave_idx_type i = (Pinv) ? (Pinv [ridx [p]]) : (ridx [p]) ;
-	  if (i < k)
-	    {
-	      // follow path from i to root of etree, stop at flagged node 
-	      for ( ; Flag [i] != k ; i = Parent [i])
-		{
-		  // find parent of i if not yet determined
-		  if (Parent [i] == n)
-		    Parent [i] = k ;
-		  Flag [i] = k ;	// mark i as visited
-		}
-	    }
-	}
+        {
+          // A (i,k) is nonzero (original or permuted A)
+          octave_idx_type i = (Pinv) ? (Pinv [ridx [p]]) : (ridx [p]) ;
+          if (i < k)
+            {
+              // follow path from i to root of etree, stop at flagged node 
+              for ( ; Flag [i] != k ; i = Parent [i])
+                {
+                  // find parent of i if not yet determined
+                  if (Parent [i] == n)
+                    Parent [i] = k ;
+                  Flag [i] = k ;        // mark i as visited
+                }
+            }
+        }
     }
 }
 
 // The elimination tree post-ordering code below is taken from SuperLU
 static inline octave_idx_type
 make_set (octave_idx_type i, octave_idx_type *pp)
 {
   pp[i] = i;
@@ -135,17 +135,17 @@ etdfs (octave_idx_type v, octave_idx_typ
 
   post[postnum++] = v;
 
   return postnum;
 }
 
 static void
 tree_postorder (octave_idx_type n, octave_idx_type *parent,
-		octave_idx_type *post)
+                octave_idx_type *post)
 {
   // Allocate storage for working arrays and results
   OCTAVE_LOCAL_BUFFER (octave_idx_type, first_kid, n+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, next_kid, n+1);
 
   // Set up structure describing children
   for (octave_idx_type v = 0; v <= n; first_kid[v++] = -1)
     /* do nothing */;
@@ -158,58 +158,58 @@ tree_postorder (octave_idx_type n, octav
     }
 
   // Depth-first search from dummy root vertex #n
   etdfs (n, first_kid, next_kid, post, 0);
 }
 
 static void
 coletree (const octave_idx_type *ridx, const octave_idx_type *colbeg,
-	  octave_idx_type *colend, octave_idx_type *parent, 
-	  octave_idx_type nr, octave_idx_type nc)
+          octave_idx_type *colend, octave_idx_type *parent, 
+          octave_idx_type nr, octave_idx_type nc)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, root, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, pp, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, firstcol, nr);
 
   // Compute firstcol[row] = first nonzero column in row
   for (octave_idx_type row = 0; row < nr; firstcol[row++] = nc)
     /* do nothing */;
 
   for (octave_idx_type col = 0; col < nc; col++) 
     for (octave_idx_type p = colbeg[col]; p < colend[col]; p++) 
       {
-	octave_idx_type row = ridx[p];
-	if (firstcol[row] > col)
-	  firstcol[row] = col;
+        octave_idx_type row = ridx[p];
+        if (firstcol[row] > col)
+          firstcol[row] = col;
       }
 
   // Compute etree by Liu's algorithm for symmetric matrices,
   // except use (firstcol[r],c) in place of an edge (r,c) of A.
   // Thus each row clique in A'*A is replaced by a star
   // centered at its first vertex, which has the same fill.
   for (octave_idx_type col = 0; col < nc; col++) 
     {
       octave_idx_type cset = make_set (col, pp);
       root[cset] = col;
       parent[col] = nc; 
       for (octave_idx_type p = colbeg[col]; p < colend[col]; p++) 
-	{
-	  octave_idx_type row = firstcol[ridx[p]];
-	  if (row >= col) 
-	    continue;
-	  octave_idx_type rset = find (row, pp);
-	  octave_idx_type rroot = root[rset];
-	  if (rroot != col) 
-	    {
-	      parent[rroot] = col;
-	      cset = link (cset, rset, pp);
-	      root[cset] = col;
-	    }
-	}
+        {
+          octave_idx_type row = firstcol[ridx[p]];
+          if (row >= col) 
+            continue;
+          octave_idx_type rset = find (row, pp);
+          octave_idx_type rroot = root[rset];
+          if (rroot != col) 
+            {
+              parent[rroot] = col;
+              cset = link (cset, rset, pp);
+              root[cset] = col;
+            }
+        }
     }
 }
 
 DEFUN_DLD (colamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} colamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s})\n\
@@ -288,159 +288,159 @@ Ng, Oak Ridge National Laboratory.  (see
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);      
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
-	{
-	  NDArray User_knobs = args(1).array_value ();
-	  int nel_User_knobs = User_knobs.length ();
-	  
-	  if (nel_User_knobs > 0) 
-	    knobs [COLAMD_DENSE_ROW] = User_knobs (0);
-	  if (nel_User_knobs > 1) 
-	    knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
-	  if (nel_User_knobs > 2) 
-	    spumoni = static_cast<int> (User_knobs (2));
+        {
+          NDArray User_knobs = args(1).array_value ();
+          int nel_User_knobs = User_knobs.length ();
+          
+          if (nel_User_knobs > 0) 
+            knobs [COLAMD_DENSE_ROW] = User_knobs (0);
+          if (nel_User_knobs > 1) 
+            knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
+          if (nel_User_knobs > 2) 
+            spumoni = static_cast<int> (User_knobs (2));
 
-	  // print knob settings if spumoni is set
-	  if (spumoni)
-	    {
+          // print knob settings if spumoni is set
+          if (spumoni)
+            {
 
-	      octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
-			    <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
+              octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
+                            <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
-	      if (knobs [COLAMD_DENSE_ROW] >= 0)
-		octave_stdout << "knobs(1): " << User_knobs (0) 
-			      << ", rows with > max(16,"
-			      << knobs [COLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
-			      << " entries removed\n";
-	      else
-		octave_stdout << "knobs(1): " << User_knobs (0)
-			      << ", only completely dense rows removed\n";
+              if (knobs [COLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(1): " << User_knobs (0) 
+                              << ", rows with > max(16,"
+                              << knobs [COLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << " entries removed\n";
+              else
+                octave_stdout << "knobs(1): " << User_knobs (0)
+                              << ", only completely dense rows removed\n";
 
-	      if (knobs [COLAMD_DENSE_COL] >= 0)
-		octave_stdout << "knobs(2): " << User_knobs (1) 
-			      << ", cols with > max(16,"
-			      << knobs [COLAMD_DENSE_COL] << "*sqrt(size(A)))"
-			      << " entries removed\n";
-	      else
-		octave_stdout << "knobs(2): " << User_knobs (1)
-			      << ", only completely dense columns removed\n";
+              if (knobs [COLAMD_DENSE_COL] >= 0)
+                octave_stdout << "knobs(2): " << User_knobs (1) 
+                              << ", cols with > max(16,"
+                              << knobs [COLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << " entries removed\n";
+              else
+                octave_stdout << "knobs(2): " << User_knobs (1)
+                              << ", only completely dense columns removed\n";
 
-	      octave_stdout << "knobs(3): " << User_knobs (2) 
-			    << ", statistics and knobs printed\n";
+              octave_stdout << "knobs(3): " << User_knobs (2) 
+                            << ", statistics and knobs printed\n";
 
-	    }
-	}
+            }
+        }
       
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseComplexMatrix scm;
       SparseMatrix sm;
 
       if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      scm = args(0). sparse_complex_matrix_value ();
-	      n_row = scm.rows ();
-	      n_col = scm.cols ();
-	      nnz = scm.nzmax ();
-	      ridx = scm.xridx ();
-	      cidx = scm.xcidx ();
-	    }
-	  else
-	    {
-	      sm = args(0).sparse_matrix_value ();
+        {
+          if (args(0).is_complex_type ())
+            {
+              scm = args(0). sparse_complex_matrix_value ();
+              n_row = scm.rows ();
+              n_col = scm.cols ();
+              nnz = scm.nzmax ();
+              ridx = scm.xridx ();
+              cidx = scm.xcidx ();
+            }
+          else
+            {
+              sm = args(0).sparse_matrix_value ();
 
-	      n_row = sm.rows ();
-	      n_col = sm.cols ();
-	      nnz = sm.nzmax ();
-	      ridx = sm.xridx ();
-	      cidx = sm.xcidx ();
-	    }
-	}
+              n_row = sm.rows ();
+              n_col = sm.cols ();
+              nnz = sm.nzmax ();
+              ridx = sm.xridx ();
+              cidx = sm.xcidx ();
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type ())
-	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-	  else
-	    sm = SparseMatrix (args(0).matrix_value ());
+        {
+          if (args(0).is_complex_type ())
+            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+          else
+            sm = SparseMatrix (args(0).matrix_value ());
 
-	  n_row = sm.rows ();
-	  n_col = sm.cols ();
-	  nnz = sm.nzmax ();
-	  ridx = sm.xridx ();
-	  cidx = sm.xcidx ();
-	}
+          n_row = sm.rows ();
+          n_col = sm.cols ();
+          nnz = sm.nzmax ();
+          ridx = sm.xridx ();
+          cidx = sm.xcidx ();
+        }
 
       // Allocate workspace for colamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-	p[i] = cidx [i];
+        p[i] = cidx [i];
 
       octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-	A[i] = ridx [i];
+        A[i] = ridx [i];
 
       // Order the columns (destroys A)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
       if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
-	{
-	  COLAMD_NAME (_report) (stats) ;
-	  error ("colamd: internal error!");
-	  return retval;
-	}
+        {
+          COLAMD_NAME (_report) (stats) ;
+          error ("colamd: internal error!");
+          return retval;
+        }
 
       // column elimination tree post-ordering (reuse variables)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col + 1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col + 1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
       for (octave_idx_type i = 0; i < n_col; i++)
-	{
-	  colbeg[i] = cidx[p[i]];
-	  colend[i] = cidx[p[i]+1];
-	}
+        {
+          colbeg[i] = cidx[p[i]];
+          colend[i] = cidx[p[i]+1];
+        }
 
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-	out_perm(i) = p [colbeg [i]] + 1;
+        out_perm(i) = p [colbeg [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
-	COLAMD_NAME (_report) (stats) ;
+        COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
-	{
-	  NDArray out_stats (dim_vector (1, COLAMD_STATS));
-	  for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-	    out_stats (i) = stats [i] ;
-	  retval(1) = out_stats;
+        {
+          NDArray out_stats (dim_vector (1, COLAMD_STATS));
+          for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
+            out_stats (i) = stats [i] ;
+          retval(1) = out_stats;
 
-	  // fix stats (5) and (6), for 1-based information on 
-	  // jumbled matrix.  note that this correction doesn't 
-	  // occur if symamd returns FALSE
-	  out_stats (COLAMD_INFO1) ++ ; 
-	  out_stats (COLAMD_INFO2) ++ ; 
-	}
+          // fix stats (5) and (6), for 1-based information on 
+          // jumbled matrix.  note that this correction doesn't 
+          // occur if symamd returns FALSE
+          out_stats (COLAMD_INFO1) ++ ; 
+          out_stats (COLAMD_INFO2) ++ ; 
+        }
     }
 
 #else
 
   error ("colamd: not available in this version of Octave");
 
 #endif
 
@@ -524,120 +524,120 @@ Ng, Oak Ridge National Laboratory.  (see
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
-	{
-	  NDArray User_knobs = args(1).array_value ();
-	  int nel_User_knobs = User_knobs.length ();
-	  
-	  if (nel_User_knobs > 0) 
-	    knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
-	  if (nel_User_knobs > 1) 
-	    spumoni = static_cast<int> (User_knobs (1));
-	}
+        {
+          NDArray User_knobs = args(1).array_value ();
+          int nel_User_knobs = User_knobs.length ();
+          
+          if (nel_User_knobs > 0) 
+            knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
+          if (nel_User_knobs > 1) 
+            spumoni = static_cast<int> (User_knobs (1));
+        }
 
       // print knob settings if spumoni is set
       if (spumoni > 0)
-	octave_stdout << "symamd: dense row/col fraction: " 
-		      << knobs [COLAMD_DENSE_ROW] << std::endl;
+        octave_stdout << "symamd: dense row/col fraction: " 
+                      << knobs [COLAMD_DENSE_ROW] << std::endl;
       
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      scm = args(0).sparse_complex_matrix_value ();
-	      n_row = scm.rows ();
-	      n_col = scm.cols ();
-	      nnz = scm.nzmax ();
-	      ridx = scm.xridx ();
-	      cidx = scm.xcidx ();
-	    }
-	  else
-	    {
-	      sm = args(0).sparse_matrix_value ();
-	      n_row = sm.rows ();
-	      n_col = sm.cols ();
-	      nnz = sm.nzmax ();
-	      ridx = sm.xridx ();
-	      cidx = sm.xcidx ();
-	    }
-	}
+        {
+          if (args(0).is_complex_type ())
+            {
+              scm = args(0).sparse_complex_matrix_value ();
+              n_row = scm.rows ();
+              n_col = scm.cols ();
+              nnz = scm.nzmax ();
+              ridx = scm.xridx ();
+              cidx = scm.xcidx ();
+            }
+          else
+            {
+              sm = args(0).sparse_matrix_value ();
+              n_row = sm.rows ();
+              n_col = sm.cols ();
+              nnz = sm.nzmax ();
+              ridx = sm.xridx ();
+              cidx = sm.xcidx ();
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type ())
-	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
-	  else
-	    sm = SparseMatrix (args(0).matrix_value ());
-	  
-	  n_row = sm.rows ();
-	  n_col = sm.cols ();
-	  nnz = sm.nzmax ();
-	  ridx = sm.xridx ();
-	  cidx = sm.xcidx ();
-	}
+        {
+          if (args(0).is_complex_type ())
+            sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+          else
+            sm = SparseMatrix (args(0).matrix_value ());
+          
+          n_row = sm.rows ();
+          n_col = sm.cols ();
+          nnz = sm.nzmax ();
+          ridx = sm.xridx ();
+          cidx = sm.xcidx ();
+        }
 
       if (n_row != n_col)
-	{
-	  error ("symamd: matrix must be square");
-	  return retval;
-	}
+        {
+          error ("symamd: matrix must be square");
+          return retval;
+        }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
       if (!SYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, &calloc, &free))
-	{
-	  SYMAMD_NAME (_report) (stats) ;
-	  error ("symamd: internal error!") ;
-	  return retval;
-	}
+        {
+          SYMAMD_NAME (_report) (stats) ;
+          error ("symamd: internal error!") ;
+          return retval;
+        }
 
       // column elimination tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
       symetree (ridx, cidx, etree, perm, n_col);
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-	out_perm(i) = perm [post [i]] + 1;
+        out_perm(i) = perm [post [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
-	SYMAMD_NAME (_report) (stats) ;
+        SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
-	{
-	  NDArray out_stats (dim_vector (1, COLAMD_STATS));
-	  for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-	    out_stats (i) = stats [i] ;
-	  retval(1) = out_stats;
+        {
+          NDArray out_stats (dim_vector (1, COLAMD_STATS));
+          for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
+            out_stats (i) = stats [i] ;
+          retval(1) = out_stats;
 
-	  // fix stats (5) and (6), for 1-based information on 
-	  // jumbled matrix.  note that this correction doesn't 
-	  // occur if symamd returns FALSE
-	  out_stats (COLAMD_INFO1) ++ ; 
-	  out_stats (COLAMD_INFO2) ++ ; 
-	}
+          // fix stats (5) and (6), for 1-based information on 
+          // jumbled matrix.  note that this correction doesn't 
+          // occur if symamd returns FALSE
+          out_stats (COLAMD_INFO1) ++ ; 
+          out_stats (COLAMD_INFO2) ++ ; 
+        }
     }
 
 #else
 
   error ("symamd: not available in this version of Octave");
 
 #endif
 
@@ -670,108 +670,108 @@ permutations on the tree.\n\
     {
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       bool is_sym = true;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      scm = args(0).sparse_complex_matrix_value ();
-	      n_row = scm.rows ();
-	      n_col = scm.cols ();
-	      nnz = scm.nzmax ();
-	      ridx = scm.xridx ();
-	      cidx = scm.xcidx ();
-	    }
-	  else
-	    {
-	      sm = args(0).sparse_matrix_value ();
-	      n_row = sm.rows ();
-	      n_col = sm.cols ();
-	      nnz = sm.nzmax ();
-	      ridx = sm.xridx ();
-	      cidx = sm.xcidx ();
-	    }
+        {
+          if (args(0).is_complex_type ())
+            {
+              scm = args(0).sparse_complex_matrix_value ();
+              n_row = scm.rows ();
+              n_col = scm.cols ();
+              nnz = scm.nzmax ();
+              ridx = scm.xridx ();
+              cidx = scm.xcidx ();
+            }
+          else
+            {
+              sm = args(0).sparse_matrix_value ();
+              n_row = sm.rows ();
+              n_col = sm.cols ();
+              nnz = sm.nzmax ();
+              ridx = sm.xridx ();
+              cidx = sm.xcidx ();
+            }
 
-	}
+        }
       else
-	{
-	  error ("etree: must be called with a sparse matrix");
-	  return retval;
-	}
+        {
+          error ("etree: must be called with a sparse matrix");
+          return retval;
+        }
 
       if (nargin == 2)
-	{
-	  if (args(1).is_string ())
-	    {
-	      std::string str = args(1).string_value ();
-	      if (str.find ("C") == 0 || str.find ("c") == 0)
-		is_sym = false;
-	    }
-	  else
-	    {
-	      error ("etree: second argument must be a string");
-	      return retval;
-	    }
-	}
+        {
+          if (args(1).is_string ())
+            {
+              std::string str = args(1).string_value ();
+              if (str.find ("C") == 0 || str.find ("c") == 0)
+                is_sym = false;
+            }
+          else
+            {
+              error ("etree: second argument must be a string");
+              return retval;
+            }
+        }
 
       // column elimination tree post-ordering (reuse variables)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
       if (is_sym)
-	{
-	  if (n_row != n_col)
-	    {
-	      error ("etree: matrix is marked as symmetric, but not square");
-	      return retval;
-	    }
+        {
+          if (n_row != n_col)
+            {
+              error ("etree: matrix is marked as symmetric, but not square");
+              return retval;
+            }
 
-	  symetree (ridx, cidx, etree, 0, n_col);
-	}
+          symetree (ridx, cidx, etree, 0, n_col);
+        }
       else
-	{
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
+        {
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
 
-	  for (octave_idx_type i = 0; i < n_col; i++)
-	    {
-	      colbeg[i] = cidx[i];
-	      colend[i] = cidx[i+1];
-	    }
+          for (octave_idx_type i = 0; i < n_col; i++)
+            {
+              colbeg[i] = cidx[i];
+              colend[i] = cidx[i+1];
+            }
 
-	  coletree (ridx, colbeg, colend, etree, n_row, n_col);
-	}
+          coletree (ridx, colbeg, colend, etree, n_row, n_col);
+        }
 
       NDArray tree (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-	// We flag a root with n_col while Matlab does it with zero
-	// Convert for matlab compatiable output
-	if (etree[i] == n_col)
-	  tree(i) = 0;
-	else
-	  tree(i) = etree[i] + 1;
+        // We flag a root with n_col while Matlab does it with zero
+        // Convert for matlab compatiable output
+        if (etree[i] == n_col)
+          tree(i) = 0;
+        else
+          tree(i) = etree[i] + 1;
 
       retval(0) = tree;
 
       if (nargout == 2)
-	{
-	  // Calculate the tree post-ordering
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
-	  tree_postorder (n_col, etree, post);
+        {
+          // Calculate the tree post-ordering
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
+          tree_postorder (n_col, etree, post);
 
-	  NDArray postorder (dim_vector (1, n_col));
-	  for (octave_idx_type i = 0; i < n_col; i++)
-	    postorder(i) = post[i] + 1;
+          NDArray postorder (dim_vector (1, n_col));
+          for (octave_idx_type i = 0; i < n_col; i++)
+            postorder(i) = post[i] + 1;
 
-	  retval(1) = postorder;
-	}
+          retval(1) = postorder;
+        }
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -79,46 +79,46 @@ Polynomial Approximation}.\n\
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
       if (args(i).is_defined ())
-	{
-	  if (! args(i).is_string ())
-	    {
-	      error ("colloc: expecting string argument");
-	      return retval;
-	    }
+        {
+          if (! args(i).is_string ())
+            {
+              error ("colloc: expecting string argument");
+              return retval;
+            }
 
-	  std::string s = args(i).string_value ();
+          std::string s = args(i).string_value ();
 
-	  if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
-	      || s == "right")
-	    {
-	      right = 1;
-	    }
-	  else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
-		   || s == "left")
-	    {
-	      left = 1;
-	    }
-	  else
-	    {
-	      error ("colloc: unrecognized argument");
-	      return retval;
-	    }
-	}
+          if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
+              || s == "right")
+            {
+              right = 1;
+            }
+          else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
+                   || s == "left")
+            {
+              left = 1;
+            }
+          else
+            {
+              error ("colloc: unrecognized argument");
+              return retval;
+            }
+        }
       else
-	{
-	  error ("colloc: unexpected empty argument");
-	  return retval;
-	}
+        {
+          error ("colloc: unexpected empty argument");
+          return retval;
+        }
     }
 
   ntot += left + right;
   if (ntot < 1)
     {
       error ("colloc: the total number of roots must be positive");
       return retval;
     }
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -83,19 +83,19 @@ conv2 (MArray<T>& R, MArray<T>& C, MArra
         edgM = (Cm - 1) /2;
         edgN = (Rn - 1) /2;
         break;
 
       case SHAPE_VALID:
         outM = Am - Cm + 1;
         outN = An - Rn + 1;
         if (outM < 0)
-	  outM = 0;
+          outM = 0;
         if (outN < 0)
-	  outN = 0;
+          outN = 0;
         edgM = edgN = 0;
         break;
 
       default:
         error ("conv2: invalid value of parameter ishape");
     }
 
   MArray2<T> O (outM, outN);
@@ -106,39 +106,39 @@ conv2 (MArray<T>& R, MArray<T>& C, MArra
   //     first
 
   MArray<T> X (An);
 
   for (octave_idx_type oi = 0; oi < outM; oi++)
     {
       for (octave_idx_type oj = 0; oj < An; oj++)
         {
-	  T sum = 0;
+          T sum = 0;
 
-	  octave_idx_type ci = Cm - 1 - MAX(0, edgM-oi);
+          octave_idx_type ci = Cm - 1 - MAX(0, edgM-oi);
           octave_idx_type ai = MAX(0, oi-edgM);
-	  const T* Ad = A.data() + ai + Am*oj;
-	  const T* Cd = C.data() + ci;
-	  for ( ; ci >= 0 && ai < Am; ci--, Cd--, ai++, Ad++)
-	    sum += (*Ad) * (*Cd);
+          const T* Ad = A.data() + ai + Am*oj;
+          const T* Cd = C.data() + ci;
+          for ( ; ci >= 0 && ai < Am; ci--, Cd--, ai++, Ad++)
+            sum += (*Ad) * (*Cd);
 
-	  X(oj) = sum;
+          X(oj) = sum;
         }
 
       for (octave_idx_type oj = 0; oj < outN; oj++)
         {
           T sum = 0;
 
           octave_idx_type rj = Rn - 1 - MAX(0, edgN-oj);
           octave_idx_type aj = MAX(0, oj-edgN) ;
           const T* Xd = X.data() + aj;
           const T* Rd = R.data() + rj;
 
           for ( ; rj >= 0 && aj < An; rj--, Rd--, aj++, Xd++)
-	    sum += (*Xd) * (*Rd);
+            sum += (*Xd) * (*Rd);
 
           O(oi,oj)=  sum;
         }
     }
 
   return O;
 }
 
@@ -195,45 +195,45 @@ conv2 (MArray2<T>&A, MArray2<T>&B, Shape
         outN = An;
         edgM = (Bm - 1) /2;
         edgN = (Bn - 1) /2;
         break;
 
       case SHAPE_VALID:
         outM = Am - Bm + 1;
         outN = An - Bn + 1;
-	if (outM < 0)
-	  outM = 0;
-	if (outN < 0)
-	  outN = 0;
+        if (outM < 0)
+          outM = 0;
+        if (outN < 0)
+          outN = 0;
         edgM = edgN = 0;
         break;
     }
 
   MArray2<T> O (outM, outN);
 
   for (octave_idx_type oi = 0; oi < outM; oi++)
     {
       for (octave_idx_type oj = 0; oj < outN; oj++)
         {
           T sum = 0;
 
           for (octave_idx_type bj = Bn - 1 - MAX (0, edgN-oj), aj= MAX (0, oj-edgN);
-	       bj >= 0 && aj < An; bj--, aj++)
+               bj >= 0 && aj < An; bj--, aj++)
             {
               octave_idx_type bi = Bm - 1 - MAX (0, edgM-oi);
               octave_idx_type ai = MAX (0, oi-edgM);
               const T* Ad = A.data () + ai + Am*aj;
               const T* Bd = B.data () + bi + Bm*bj;
 
               for ( ; bi >= 0 && ai < Am; bi--, Bd--, ai++, Ad++)
                 {
                   sum += (*Ad) * (*Bd);
-		  // Comment: it seems to be 2.5 x faster than this:
-		  //        sum+= A(ai,aj) * B(bi,bj);
+                  // Comment: it seems to be 2.5 x faster than this:
+                  //        sum+= A(ai,aj) * B(bi,bj);
                 }
             }
 
           O(oi,oj) = sum;
         }
     }
 
   return O;
@@ -309,114 +309,114 @@ in the column direction and by vector @v
       return retval;
     }
 
    if (separable)
      {
       // If user requests separable, check first two params are vectors
 
        if (! (1 == args(0).rows () || 1 == args(0).columns ())
-	   || ! (1 == args(1).rows () || 1 == args(1).columns ()))
+           || ! (1 == args(1).rows () || 1 == args(1).columns ()))
          {
-	   print_usage ();
-	   return retval;
+           print_usage ();
+           return retval;
          }
 
        if (args(0).is_single_type () || 
-	   args(1).is_single_type () || 
-	   args(2).is_single_type ())
-	 {
-	   if (args(0).is_complex_type ()
-	       || args(1).is_complex_type ()
-	       || args(2).is_complex_type ())
-	     {
-	       FloatComplexColumnVector v1 (args(0).float_complex_vector_value ());
-	       FloatComplexColumnVector v2 (args(1).float_complex_vector_value ());
-	       FloatComplexMatrix a (args(2).float_complex_matrix_value ());
-	       FloatComplexMatrix c (conv2 (v1, v2, a, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	   else
-	     {
-	       FloatColumnVector v1 (args(0).float_vector_value ());
-	       FloatColumnVector v2 (args(1).float_vector_value ());
-	       FloatMatrix a (args(2).float_matrix_value ());
-	       FloatMatrix c (conv2 (v1, v2, a, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	 }
+           args(1).is_single_type () || 
+           args(2).is_single_type ())
+         {
+           if (args(0).is_complex_type ()
+               || args(1).is_complex_type ()
+               || args(2).is_complex_type ())
+             {
+               FloatComplexColumnVector v1 (args(0).float_complex_vector_value ());
+               FloatComplexColumnVector v2 (args(1).float_complex_vector_value ());
+               FloatComplexMatrix a (args(2).float_complex_matrix_value ());
+               FloatComplexMatrix c (conv2 (v1, v2, a, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+           else
+             {
+               FloatColumnVector v1 (args(0).float_vector_value ());
+               FloatColumnVector v2 (args(1).float_vector_value ());
+               FloatMatrix a (args(2).float_matrix_value ());
+               FloatMatrix c (conv2 (v1, v2, a, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+         }
        else
-	 {
-	   if (args(0).is_complex_type ()
-	       || args(1).is_complex_type ()
-	       || args(2).is_complex_type ())
-	     {
-	       ComplexColumnVector v1 (args(0).complex_vector_value ());
-	       ComplexColumnVector v2 (args(1).complex_vector_value ());
-	       ComplexMatrix a (args(2).complex_matrix_value ());
-	       ComplexMatrix c (conv2 (v1, v2, a, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	   else
-	     {
-	       ColumnVector v1 (args(0).vector_value ());
-	       ColumnVector v2 (args(1).vector_value ());
-	       Matrix a (args(2).matrix_value ());
-	       Matrix c (conv2 (v1, v2, a, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	 }
+         {
+           if (args(0).is_complex_type ()
+               || args(1).is_complex_type ()
+               || args(2).is_complex_type ())
+             {
+               ComplexColumnVector v1 (args(0).complex_vector_value ());
+               ComplexColumnVector v2 (args(1).complex_vector_value ());
+               ComplexMatrix a (args(2).complex_matrix_value ());
+               ComplexMatrix c (conv2 (v1, v2, a, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+           else
+             {
+               ColumnVector v1 (args(0).vector_value ());
+               ColumnVector v2 (args(1).vector_value ());
+               Matrix a (args(2).matrix_value ());
+               Matrix c (conv2 (v1, v2, a, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+         }
      } // if (separable)
    else
      {
        if (args(0).is_single_type () || 
-	   args(1).is_single_type ())
-	 {
-	   if (args(0).is_complex_type ()
-	       || args(1).is_complex_type ())
-	     {
-	       FloatComplexMatrix a (args(0).float_complex_matrix_value ());
-	       FloatComplexMatrix b (args(1).float_complex_matrix_value ());
-	       FloatComplexMatrix c (conv2 (a, b, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	   else
-	     {
-	       FloatMatrix a (args(0).float_matrix_value ());
-	       FloatMatrix b (args(1).float_matrix_value ());
-	       FloatMatrix c (conv2 (a, b, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	 }
+           args(1).is_single_type ())
+         {
+           if (args(0).is_complex_type ()
+               || args(1).is_complex_type ())
+             {
+               FloatComplexMatrix a (args(0).float_complex_matrix_value ());
+               FloatComplexMatrix b (args(1).float_complex_matrix_value ());
+               FloatComplexMatrix c (conv2 (a, b, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+           else
+             {
+               FloatMatrix a (args(0).float_matrix_value ());
+               FloatMatrix b (args(1).float_matrix_value ());
+               FloatMatrix c (conv2 (a, b, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+         }
        else
-	 {
-	   if (args(0).is_complex_type ()
-	       || args(1).is_complex_type ())
-	     {
-	       ComplexMatrix a (args(0).complex_matrix_value ());
-	       ComplexMatrix b (args(1).complex_matrix_value ());
-	       ComplexMatrix c (conv2 (a, b, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	   else
-	     {
-	       Matrix a (args(0).matrix_value ());
-	       Matrix b (args(1).matrix_value ());
-	       Matrix c (conv2 (a, b, ishape));
-	       if (! error_state)
-		 retval = c;
-	     }
-	 }
+         {
+           if (args(0).is_complex_type ()
+               || args(1).is_complex_type ())
+             {
+               ComplexMatrix a (args(0).complex_matrix_value ());
+               ComplexMatrix b (args(1).complex_matrix_value ());
+               ComplexMatrix c (conv2 (a, b, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+           else
+             {
+               Matrix a (args(0).matrix_value ());
+               Matrix b (args(1).matrix_value ());
+               Matrix c (conv2 (a, b, ishape));
+               if (! error_state)
+                 retval = c;
+             }
+         }
 
      } // if (separable)
 
    return retval;
 }
 
 template MArray2<double>
 conv2 (MArray<double>&, MArray<double>&, MArray2<double>&, Shape);
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -81,37 +81,37 @@ calculated.\n\n\
     {
       print_usage ();
       return retval;
     }
 
   if (nargin == 2) 
     {
       if (args (1).is_string ()) 
-	options = args(1).string_value ();
+        options = args(1).string_value ();
       else if (args(1).is_cell ())
-	{
-	  Cell c = args(1).cell_value ();
-	  options = "";
-	  for (octave_idx_type i = 0; i < c.numel (); i++)
-	    {
-	      if (! c.elem(i).is_string ())
-		{
-		  error ("convhulln: second argument must be a string or cell array of strings");
-		  return retval;
-		}
+        {
+          Cell c = args(1).cell_value ();
+          options = "";
+          for (octave_idx_type i = 0; i < c.numel (); i++)
+            {
+              if (! c.elem(i).is_string ())
+                {
+                  error ("convhulln: second argument must be a string or cell array of strings");
+                  return retval;
+                }
 
-	      options = options + c.elem(i).string_value() + " ";
-	    }
-	}
+              options = options + c.elem(i).string_value() + " ";
+            }
+        }
       else
-	{
-	  error ("convhulln: second argument must be a string or cell array of strings");
-	  return retval;
-	}
+        {
+          error ("convhulln: second argument must be a string or cell array of strings");
+          return retval;
+        }
     }
   else
     // turn on some consistency checks
     options = "s Qci Tcv";
 
   Matrix p (args(0).matrix_value ());
 
   const octave_idx_type dim = p.columns ();
@@ -137,95 +137,95 @@ calculated.\n\n\
       facetT *facet;
       setT *vertices;
       unsigned int nf = qh num_facets;
 
       Matrix idx (nf, dim);
 
       octave_idx_type j, i = 0;
       FORALLfacets 
-	{
-	  j = 0;
-	  if (! facet->simplicial)
-	    // should never happen with QJ
-	    error ("convhulln: non-simplicial facet");
+        {
+          j = 0;
+          if (! facet->simplicial)
+            // should never happen with QJ
+            error ("convhulln: non-simplicial facet");
 
-	  if (dim == 3) 
-	    {
-	      vertices = qh_facet3vertex (facet);
-	      FOREACHvertex_ (vertices)
-		idx(i, j++) = 1 + qh_pointid(vertex->point);
-	      qh_settempfree (&vertices);
-	    } 
-	  else 
-	    {
-	      if (facet->toporient ^ qh_ORIENTclock) 
-		{
-		  FOREACHvertex_ (facet->vertices)
-		    idx(i, j++) = 1 + qh_pointid(vertex->point);
-		} 
-	      else 
-		{
-		  FOREACHvertexreverse12_ (facet->vertices)
-		    idx(i, j++) = 1 + qh_pointid(vertex->point);
-		}
-	    }
-	  if (j < dim)
-	    // likewise but less fatal
-	    warning ("facet %d only has %d vertices", i, j);
-	  i++;
-	}
+          if (dim == 3) 
+            {
+              vertices = qh_facet3vertex (facet);
+              FOREACHvertex_ (vertices)
+                idx(i, j++) = 1 + qh_pointid(vertex->point);
+              qh_settempfree (&vertices);
+            } 
+          else 
+            {
+              if (facet->toporient ^ qh_ORIENTclock) 
+                {
+                  FOREACHvertex_ (facet->vertices)
+                    idx(i, j++) = 1 + qh_pointid(vertex->point);
+                } 
+              else 
+                {
+                  FOREACHvertexreverse12_ (facet->vertices)
+                    idx(i, j++) = 1 + qh_pointid(vertex->point);
+                }
+            }
+          if (j < dim)
+            // likewise but less fatal
+            warning ("facet %d only has %d vertices", i, j);
+          i++;
+        }
 
       if (nargout == 2)
         // calculate volume of convex hull
         // taken from qhull src/geom2.c
         {
           realT area;
           realT dist;
 
           FORALLfacets
-	    {
-	      if (! facet->normal)
-		continue;
+            {
+              if (! facet->normal)
+                continue;
 
-	      if (facet->upperdelaunay && qh ATinfinity)
-		continue;
+              if (facet->upperdelaunay && qh ATinfinity)
+                continue;
 
-	      facet->f.area = area = qh_facetarea (facet);
-	      facet->isarea = True;
+              facet->f.area = area = qh_facetarea (facet);
+              facet->isarea = True;
 
-	      if (qh DELAUNAY)
-		{
-		  if (facet->upperdelaunay == qh UPPERdelaunay)
-		    qh totarea += area;
-		}
-	      else
-		{
-		  qh totarea += area;
-		  qh_distplane (qh interior_point, facet, &dist);
-		  qh totvol += -dist * area/ qh hull_dim;
-		}
-	    }
+              if (qh DELAUNAY)
+                {
+                  if (facet->upperdelaunay == qh UPPERdelaunay)
+                    qh totarea += area;
+                }
+              else
+                {
+                  qh totarea += area;
+                  qh_distplane (qh interior_point, facet, &dist);
+                  qh totvol += -dist * area/ qh hull_dim;
+                }
+            }
 
           retval(1) = octave_value (qh totvol);
         }
 
       retval(0) = octave_value (idx);
     }
 
   // free long memory
   qh_freeqhull (! qh_ALL);
 
   // free short memory and memory allocator
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
 
   if (curlong || totlong) 
     warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
-	    totlong, curlong);
+            totlong, curlong);
 #else
   error ("convhulln: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -55,65 +55,65 @@ static octave_function *daspk_jac;
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
 daspk_user_function (const ColumnVector& x, const ColumnVector& xdot,
-		     double t, octave_idx_type& ires)
+                     double t, octave_idx_type& ires)
 {
   ColumnVector retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (daspk_fcn)
     {
       octave_value_list tmp = daspk_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("daspk");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("daspk");
+          return retval;
+        }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("daspk: ignoring imaginary part returned from user-supplied function");
-	      warned_fcn_imaginary = true;
-	    }
+        {
+          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("daspk: ignoring imaginary part returned from user-supplied function");
+              warned_fcn_imaginary = true;
+            }
 
-	  retval = ColumnVector (tmp(0).vector_value ());
+          retval = ColumnVector (tmp(0).vector_value ());
 
-	  if (tlen > 1)
-	    ires = tmp(1).int_value ();
+          if (tlen > 1)
+            ires = tmp(1).int_value ();
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("daspk");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("daspk");
+        }
       else
-	gripe_user_supplied_eval ("daspk");
+        gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 Matrix
 daspk_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
-		     double t, double cj)
+                     double t, double cj)
 {
   Matrix retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(3) = cj;
@@ -121,37 +121,37 @@ daspk_user_jacobian (const ColumnVector&
   args(1) = xdot;
   args(0) = x;
 
   if (daspk_jac)
     {
       octave_value_list tmp = daspk_jac->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("daspk");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("daspk");
+          return retval;
+        }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
-	      warned_jac_imaginary = true;
-	    }
+        {
+          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
+              warned_jac_imaginary = true;
+            }
 
-	  retval = tmp(0).matrix_value ();
+          retval = tmp(0).matrix_value ();
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("daspk");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("daspk");
+        }
       else
-	gripe_user_supplied_eval ("daspk");
+        gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 #define DASPK_ABORT() \
   return retval
 
@@ -289,193 +289,193 @@ parameters for @code{daspk}.\n\
     {
       std::string fcn_name, fname, jac_name, jname;
       daspk_fcn = 0;
       daspk_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
-  	{
-	  Cell c = f_arg.cell_value ();
-	  if (c.length() == 1)
-	    f_arg = c(0);
-	  else if (c.length() == 2)
-	    {
-	      if (c(0).is_function_handle () || c(0).is_inline_function ())
-		daspk_fcn = c(0).function_value ();
-	      else
-		{
-		  fcn_name = unique_symbol_name ("__daspk_fcn__");
-		  fname = "function y = ";
-		  fname.append (fcn_name);
-		  fname.append (" (x, xdot, t) y = ");
-		  daspk_fcn = extract_function
-		    (c(0), "daspk", fcn_name, fname, "; endfunction");
-		}
-	      
-	      if (daspk_fcn)
-		{
-		  if (c(1).is_function_handle () || c(1).is_inline_function ())
-		    daspk_jac = c(1).function_value ();
-		  else
-		    {
-		      jac_name = unique_symbol_name ("__daspk_jac__");
-		      jname = "function jac = ";
-		      jname.append(jac_name);
-		      jname.append (" (x, xdot, t, cj) jac = ");
-		      daspk_jac = extract_function
-			(c(1), "daspk", jac_name, jname, "; endfunction");
+        {
+          Cell c = f_arg.cell_value ();
+          if (c.length() == 1)
+            f_arg = c(0);
+          else if (c.length() == 2)
+            {
+              if (c(0).is_function_handle () || c(0).is_inline_function ())
+                daspk_fcn = c(0).function_value ();
+              else
+                {
+                  fcn_name = unique_symbol_name ("__daspk_fcn__");
+                  fname = "function y = ";
+                  fname.append (fcn_name);
+                  fname.append (" (x, xdot, t) y = ");
+                  daspk_fcn = extract_function
+                    (c(0), "daspk", fcn_name, fname, "; endfunction");
+                }
+              
+              if (daspk_fcn)
+                {
+                  if (c(1).is_function_handle () || c(1).is_inline_function ())
+                    daspk_jac = c(1).function_value ();
+                  else
+                    {
+                      jac_name = unique_symbol_name ("__daspk_jac__");
+                      jname = "function jac = ";
+                      jname.append(jac_name);
+                      jname.append (" (x, xdot, t, cj) jac = ");
+                      daspk_jac = extract_function
+                        (c(1), "daspk", jac_name, jname, "; endfunction");
 
-		      if (!daspk_jac)
-			{
-			  if (fcn_name.length())
-			    clear_function (fcn_name);
-			  daspk_fcn = 0;
-			}
-		    }
-		}
-	    }
-	  else
-	    DASPK_ABORT1 ("incorrect number of elements in cell array");
-	}
+                      if (!daspk_jac)
+                        {
+                          if (fcn_name.length())
+                            clear_function (fcn_name);
+                          daspk_fcn = 0;
+                        }
+                    }
+                }
+            }
+          else
+            DASPK_ABORT1 ("incorrect number of elements in cell array");
+        }
 
       if (!daspk_fcn && ! f_arg.is_cell())
-	{
-	  if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-	    daspk_fcn = f_arg.function_value ();
-	  else
-	    {
-	      switch (f_arg.rows ())
-		{
-		case 1:
-		  do
-		    {
-		      fcn_name = unique_symbol_name ("__daspk_fcn__");
-		      fname = "function y = ";
-		      fname.append (fcn_name);
-		      fname.append (" (x, xdot, t) y = ");
-		      daspk_fcn = extract_function
-			(f_arg, "daspk", fcn_name, fname, "; endfunction");
-		    }
-		  while (0);
-		  break;
+        {
+          if (f_arg.is_function_handle () || f_arg.is_inline_function ())
+            daspk_fcn = f_arg.function_value ();
+          else
+            {
+              switch (f_arg.rows ())
+                {
+                case 1:
+                  do
+                    {
+                      fcn_name = unique_symbol_name ("__daspk_fcn__");
+                      fname = "function y = ";
+                      fname.append (fcn_name);
+                      fname.append (" (x, xdot, t) y = ");
+                      daspk_fcn = extract_function
+                        (f_arg, "daspk", fcn_name, fname, "; endfunction");
+                    }
+                  while (0);
+                  break;
 
-		case 2:
-		  {
-		    string_vector tmp = f_arg.all_strings ();
+                case 2:
+                  {
+                    string_vector tmp = f_arg.all_strings ();
 
-		    if (! error_state)
-		      {
-			fcn_name = unique_symbol_name ("__daspk_fcn__");
-			fname = "function y = ";
-			fname.append (fcn_name);
-			fname.append (" (x, xdot, t) y = ");
-			daspk_fcn = extract_function
-			  (tmp(0), "daspk", fcn_name, fname, "; endfunction");
+                    if (! error_state)
+                      {
+                        fcn_name = unique_symbol_name ("__daspk_fcn__");
+                        fname = "function y = ";
+                        fname.append (fcn_name);
+                        fname.append (" (x, xdot, t) y = ");
+                        daspk_fcn = extract_function
+                          (tmp(0), "daspk", fcn_name, fname, "; endfunction");
 
-			if (daspk_fcn)
-			  {
-			    jac_name = unique_symbol_name ("__daspk_jac__");
-			    jname = "function jac = ";
-			    jname.append(jac_name);
-			    jname.append (" (x, xdot, t, cj) jac = ");
-			    daspk_jac = extract_function
-			      (tmp(1), "daspk", jac_name, jname,
-			       "; endfunction");
+                        if (daspk_fcn)
+                          {
+                            jac_name = unique_symbol_name ("__daspk_jac__");
+                            jname = "function jac = ";
+                            jname.append(jac_name);
+                            jname.append (" (x, xdot, t, cj) jac = ");
+                            daspk_jac = extract_function
+                              (tmp(1), "daspk", jac_name, jname,
+                               "; endfunction");
 
-			    if (!daspk_jac)
-			      {
-				if (fcn_name.length())
-				  clear_function (fcn_name);
-				daspk_fcn = 0;
-			      }
-			  }
-		      }
-		  }
-		}
-	    }
-	}
+                            if (!daspk_jac)
+                              {
+                                if (fcn_name.length())
+                                  clear_function (fcn_name);
+                                daspk_fcn = 0;
+                              }
+                          }
+                      }
+                  }
+                }
+            }
+        }
 
       if (error_state || ! daspk_fcn)
-	DASPK_ABORT ();
+        DASPK_ABORT ();
 
       ColumnVector state = ColumnVector (args(1).vector_value ());
 
       if (error_state)
-	DASPK_ABORT1 ("expecting state vector as second argument");
+        DASPK_ABORT1 ("expecting state vector as second argument");
 
       ColumnVector deriv (args(2).vector_value ());
 
       if (error_state)
-	DASPK_ABORT1 ("expecting derivative vector as third argument");
+        DASPK_ABORT1 ("expecting derivative vector as third argument");
 
       ColumnVector out_times (args(3).vector_value ());
 
       if (error_state)
-	DASPK_ABORT1 ("expecting output time vector as fourth argument");
+        DASPK_ABORT1 ("expecting output time vector as fourth argument");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
-	{
-	  crit_times = ColumnVector (args(4).vector_value ());
+        {
+          crit_times = ColumnVector (args(4).vector_value ());
 
-	  if (error_state)
-	    DASPK_ABORT1 ("expecting critical time vector as fifth argument");
+          if (error_state)
+            DASPK_ABORT1 ("expecting critical time vector as fifth argument");
 
-	  crit_times_set = 1;
-	}
+          crit_times_set = 1;
+        }
 
       if (state.capacity () != deriv.capacity ())
-	DASPK_ABORT1 ("x and xdot must have the same size");
+        DASPK_ABORT1 ("x and xdot must have the same size");
 
       double tzero = out_times (0);
 
       DAEFunc func (daspk_user_function);
       if (daspk_jac)
-	func.set_jacobian_function (daspk_user_jacobian);
+        func.set_jacobian_function (daspk_user_jacobian);
 
       DASPK dae (state, deriv, tzero, func);
       dae.set_options (daspk_opts);
 
       Matrix output;
       Matrix deriv_output;
 
       if (crit_times_set)
-	output = dae.integrate (out_times, deriv_output, crit_times);
+        output = dae.integrate (out_times, deriv_output, crit_times);
       else
-	output = dae.integrate (out_times, deriv_output);
+        output = dae.integrate (out_times, deriv_output);
 
       if (fcn_name.length())
-	clear_function (fcn_name);
+        clear_function (fcn_name);
       if (jac_name.length())
-	clear_function (jac_name);
+        clear_function (jac_name);
 
       if (! error_state)
-	{
-	  std::string msg = dae.error_message ();
+        {
+          std::string msg = dae.error_message ();
 
-	  retval(3) = msg;
-	  retval(2) = static_cast<double> (dae.integration_state ());
+          retval(3) = msg;
+          retval(2) = static_cast<double> (dae.integration_state ());
 
-	  if (dae.integration_ok ())
-	    {
-	      retval(1) = deriv_output;
-	      retval(0) = output;
-	    }
-	  else
-	    {
-	      retval(1) = Matrix ();
-	      retval(0) = Matrix ();
+          if (dae.integration_ok ())
+            {
+              retval(1) = deriv_output;
+              retval(0) = output;
+            }
+          else
+            {
+              retval(1) = Matrix ();
+              retval(0) = Matrix ();
 
-	      if (nargout < 3)
-		error ("daspk: %s", msg.c_str ());
-	    }
-	}
+              if (nargout < 3)
+                error ("daspk: %s", msg.c_str ());
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -54,53 +54,53 @@ static bool warned_fcn_imaginary = false
 static bool warned_jac_imaginary = false;
 static bool warned_cf_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 static ColumnVector
 dasrt_user_f (const ColumnVector& x, const ColumnVector& xdot,
-	      double t, octave_idx_type&)
+              double t, octave_idx_type&)
 {
   ColumnVector retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (dasrt_f)
     {
       octave_value_list tmp = dasrt_f->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("dasrt");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("dasrt");
+          return retval;
+        }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("dasrt: ignoring imaginary part returned from user-supplied function");
-	      warned_fcn_imaginary = true;
-	    }
+        {
+          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("dasrt: ignoring imaginary part returned from user-supplied function");
+              warned_fcn_imaginary = true;
+            }
 
-	  retval = ColumnVector (tmp(0).vector_value ());
+          retval = ColumnVector (tmp(0).vector_value ());
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("dasrt");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("dasrt");
+        }
       else
-	gripe_user_supplied_eval ("dasrt");
+        gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static ColumnVector
 dasrt_user_cf (const ColumnVector& x, double t)
 {
@@ -111,44 +111,44 @@ dasrt_user_cf (const ColumnVector& x, do
   args(1) = t;
   args(0) = x;
 
   if (dasrt_cf)
     {
       octave_value_list tmp = dasrt_cf->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("dasrt");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("dasrt");
+          return retval;
+        }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_cf_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
-	      warned_cf_imaginary = true;
-	    }
+        {
+          if (! warned_cf_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
+              warned_cf_imaginary = true;
+            }
 
-	  retval = ColumnVector (tmp(0).vector_value ());
+          retval = ColumnVector (tmp(0).vector_value ());
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("dasrt");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("dasrt");
+        }
       else
-	gripe_user_supplied_eval ("dasrt");
+        gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static Matrix
 dasrt_user_j (const ColumnVector& x, const ColumnVector& xdot,
-	      double t, double cj)
+              double t, double cj)
 {
   Matrix retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(3) = cj;
@@ -156,37 +156,37 @@ dasrt_user_j (const ColumnVector& x, con
   args(1) = xdot;
   args(0) = x;
 
   if (dasrt_j)
     {
       octave_value_list tmp = dasrt_j->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("dasrt");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("dasrt");
+          return retval;
+        }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
-	      warned_jac_imaginary = true;
-	    }
+        {
+          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
+              warned_jac_imaginary = true;
+            }
 
-	  retval = tmp(0).matrix_value ();
+          retval = tmp(0).matrix_value ();
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("dasrt");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("dasrt");
+        }
       else
-	gripe_user_supplied_eval ("dasrt");
+        gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 #define DASRT_ABORT \
   return retval
 
@@ -376,133 +376,133 @@ parameters for @code{dasrt}.\n\
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.length() == 1)
-	f_arg = c(0);
+        f_arg = c(0);
       else if (c.length() == 2)
-	{
-	  if (c(0).is_function_handle () || c(0).is_inline_function ())
-	    dasrt_f = c(0).function_value ();
-	  else
-	    {
-	      fcn_name = unique_symbol_name ("__dasrt_fcn__");
-	      fname = "function y = ";
-	      fname.append (fcn_name);
-	      fname.append (" (x, xdot, t) y = ");
-	      dasrt_f = extract_function
-		(c(0), "dasrt", fcn_name, fname, "; endfunction");
-	    }
+        {
+          if (c(0).is_function_handle () || c(0).is_inline_function ())
+            dasrt_f = c(0).function_value ();
+          else
+            {
+              fcn_name = unique_symbol_name ("__dasrt_fcn__");
+              fname = "function y = ";
+              fname.append (fcn_name);
+              fname.append (" (x, xdot, t) y = ");
+              dasrt_f = extract_function
+                (c(0), "dasrt", fcn_name, fname, "; endfunction");
+            }
 
-	  if (dasrt_f)
-	    {
-	      if (c(1).is_function_handle () || c(1).is_inline_function ())
-		dasrt_j = c(1).function_value ();
-	      else
-		{
-		  jac_name = unique_symbol_name ("__dasrt_jac__");
-		  jname = "function jac = ";
-		  jname.append(jac_name);
-		  jname.append (" (x, xdot, t, cj) jac = ");
-		  dasrt_j = extract_function
-		    (c(1), "dasrt", jac_name, jname, "; endfunction");
+          if (dasrt_f)
+            {
+              if (c(1).is_function_handle () || c(1).is_inline_function ())
+                dasrt_j = c(1).function_value ();
+              else
+                {
+                  jac_name = unique_symbol_name ("__dasrt_jac__");
+                  jname = "function jac = ";
+                  jname.append(jac_name);
+                  jname.append (" (x, xdot, t, cj) jac = ");
+                  dasrt_j = extract_function
+                    (c(1), "dasrt", jac_name, jname, "; endfunction");
 
-		  if (!dasrt_j)
-		    {
-		      if (fcn_name.length())
-			clear_function (fcn_name);
-		      dasrt_f = 0;
-		    }
-		}
-	    }
-	}
+                  if (!dasrt_j)
+                    {
+                      if (fcn_name.length())
+                        clear_function (fcn_name);
+                      dasrt_f = 0;
+                    }
+                }
+            }
+        }
       else
-	DASRT_ABORT1 ("incorrect number of elements in cell array");
+        DASRT_ABORT1 ("incorrect number of elements in cell array");
     }
 
   if (!dasrt_f && ! f_arg.is_cell())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-	dasrt_f = f_arg.function_value ();
+        dasrt_f = f_arg.function_value ();
       else
-	{
-	  switch (f_arg.rows ())
-	    {
-	    case 1:
-	      fcn_name = unique_symbol_name ("__dasrt_fcn__");
-	      fname = "function y = ";
-	      fname.append (fcn_name);
-	      fname.append (" (x, xdot, t) y = ");
-	      dasrt_f = extract_function
-		(f_arg, "dasrt", fcn_name, fname, "; endfunction");
-	      break;
+        {
+          switch (f_arg.rows ())
+            {
+            case 1:
+              fcn_name = unique_symbol_name ("__dasrt_fcn__");
+              fname = "function y = ";
+              fname.append (fcn_name);
+              fname.append (" (x, xdot, t) y = ");
+              dasrt_f = extract_function
+                (f_arg, "dasrt", fcn_name, fname, "; endfunction");
+              break;
       
-	    case 2:
-	      {
-		string_vector tmp = args(0).all_strings ();
-	
-		if (! error_state)
-		  {
-		    fcn_name = unique_symbol_name ("__dasrt_fcn__");
-		    fname = "function y = ";
-		    fname.append (fcn_name);
-		    fname.append (" (x, xdot, t) y = ");
-		    dasrt_f = extract_function
-		      (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
-	    
-		    if (dasrt_f)
-		      {
-			jac_name = unique_symbol_name ("__dasrt_jac__");
-			jname = "function jac = ";
-			jname.append(jac_name);
-			jname.append (" (x, xdot, t, cj) jac = ");
-			dasrt_j = extract_function
-			  (tmp(1), "dasrt", jac_name, jname, "; endfunction");
+            case 2:
+              {
+                string_vector tmp = args(0).all_strings ();
+        
+                if (! error_state)
+                  {
+                    fcn_name = unique_symbol_name ("__dasrt_fcn__");
+                    fname = "function y = ";
+                    fname.append (fcn_name);
+                    fname.append (" (x, xdot, t) y = ");
+                    dasrt_f = extract_function
+                      (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
+            
+                    if (dasrt_f)
+                      {
+                        jac_name = unique_symbol_name ("__dasrt_jac__");
+                        jname = "function jac = ";
+                        jname.append(jac_name);
+                        jname.append (" (x, xdot, t, cj) jac = ");
+                        dasrt_j = extract_function
+                          (tmp(1), "dasrt", jac_name, jname, "; endfunction");
 
-			if (! dasrt_j)
-			  dasrt_f = 0;
-		      }
-		  }
-	      }
-	      break;
+                        if (! dasrt_j)
+                          dasrt_f = 0;
+                      }
+                  }
+              }
+              break;
       
-	    default:
-	      DASRT_ABORT1
-		("first arg should be a string or 2-element string array");
-	    }
-	}
+            default:
+              DASRT_ABORT1
+                ("first arg should be a string or 2-element string array");
+            }
+        }
     }
   
   if (error_state || (! dasrt_f))
     DASRT_ABORT;
   
   DAERTFunc func (dasrt_user_f);
   
   argp++;
   
   if (args(1).is_function_handle() || args(1).is_inline_function())
     {
       dasrt_cf = args(1).function_value();
 
       if (! dasrt_cf)
-	DASRT_ABORT1 ("expecting function name as argument 2");
+        DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
   else if (args(1).is_string ())
     {
       dasrt_cf = is_valid_function (args(1), "dasrt", true);
       if (! dasrt_cf)
-	DASRT_ABORT1 ("expecting function name as argument 2");
+        DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
 
   ColumnVector state (args(argp++).vector_value ());
 
@@ -514,31 +514,31 @@ parameters for @code{dasrt}.\n\
   if (error_state)
     DASRT_ABORT2 
        ("expecting time derivative of state vector as argument %d", argp);
 
   ColumnVector out_times (args(argp++).vector_value ());
 
   if (error_state)
     DASRT_ABORT2
-	("expecting output time vector as %s argument %d", argp);
+        ("expecting output time vector as %s argument %d", argp);
 
   double tzero = out_times (0);
 
   ColumnVector crit_times;
 
   bool crit_times_set = false;
 
   if (argp < nargin)
     {
       crit_times = ColumnVector (args(argp++).vector_value ());
 
       if (error_state)
-	DASRT_ABORT2
-	  ("expecting critical time vector as argument %d", argp);
+        DASRT_ABORT2
+          ("expecting critical time vector as argument %d", argp);
 
       crit_times_set = true;
     }
 
   if (dasrt_j)
     func.set_jacobian_function (dasrt_user_j);
 
   DASRT_result output;
@@ -560,30 +560,30 @@ parameters for @code{dasrt}.\n\
   if (! error_state)
     {
       std::string msg = dae.error_message ();
 
       retval(4) = msg;
       retval(3) = static_cast<double> (dae.integration_state ());
 
       if (dae.integration_ok ())
-	{
-	  retval(2) = output.times ();
-	  retval(1) = output.deriv ();
-	  retval(0) = output.state ();
-	}
+        {
+          retval(2) = output.times ();
+          retval(1) = output.deriv ();
+          retval(0) = output.state ();
+        }
       else
-	{
-	  retval(2) = Matrix ();
-	  retval(1) = Matrix ();
-	  retval(0) = Matrix ();
+        {
+          retval(2) = Matrix ();
+          retval(1) = Matrix ();
+          retval(0) = Matrix ();
 
-	  if (nargout < 4)
-	    error ("dasrt: %s", msg.c_str ());
-	}
+          if (nargout < 4)
+            error ("dasrt: %s", msg.c_str ());
+        }
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -55,65 +55,65 @@ static octave_function *dassl_jac;
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
 dassl_user_function (const ColumnVector& x, const ColumnVector& xdot,
-		     double t, octave_idx_type& ires)
+                     double t, octave_idx_type& ires)
 {
   ColumnVector retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (dassl_fcn)
     {
       octave_value_list tmp = dassl_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("dassl");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("dassl");
+          return retval;
+        }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("dassl: ignoring imaginary part returned from user-supplied function");
-	      warned_fcn_imaginary = true;
-	    }
+        {
+          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("dassl: ignoring imaginary part returned from user-supplied function");
+              warned_fcn_imaginary = true;
+            }
 
-	  retval = ColumnVector (tmp(0).vector_value ());
+          retval = ColumnVector (tmp(0).vector_value ());
 
-	  if (tlen > 1)
-	    ires = tmp(1).int_value ();
+          if (tlen > 1)
+            ires = tmp(1).int_value ();
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("dassl");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("dassl");
+        }
       else
-	gripe_user_supplied_eval ("dassl");
+        gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 Matrix
 dassl_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
-		     double t, double cj)
+                     double t, double cj)
 {
   Matrix retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(3) = cj;
@@ -121,37 +121,37 @@ dassl_user_jacobian (const ColumnVector&
   args(1) = xdot;
   args(0) = x;
 
   if (dassl_jac)
     {
       octave_value_list tmp = dassl_jac->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("dassl");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("dassl");
+          return retval;
+        }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
-	      warned_jac_imaginary = true;
-	    }
+        {
+          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
+              warned_jac_imaginary = true;
+            }
 
-	  retval = tmp(0).matrix_value ();
+          retval = tmp(0).matrix_value ();
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("dassl");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("dassl");
+        }
       else
-	gripe_user_supplied_eval ("dassl");
+        gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 #define DASSL_ABORT() \
   return retval
 
@@ -290,194 +290,194 @@ parameters for @code{dassl}.\n\
     {
       std::string fcn_name, fname, jac_name, jname;
       dassl_fcn = 0;
       dassl_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
-  	{
-	  Cell c = f_arg.cell_value ();
-	  if (c.length() == 1)
-	    f_arg = c(0);
-	  else if (c.length() == 2)
-	    {
-	      if (c(0).is_function_handle () || c(0).is_inline_function ())
-		dassl_fcn = c(0).function_value ();
-	      else
-		{
-		  fcn_name = unique_symbol_name ("__dassl_fcn__");
-		  fname = "function y = ";
-		  fname.append (fcn_name);
-		  fname.append (" (x, xdot, t) y = ");
-		  dassl_fcn = extract_function
-		    (c(0), "dassl", fcn_name, fname, "; endfunction");
-		}
-	      
-	      if (dassl_fcn)
-		{
-		  if (c(1).is_function_handle () || c(1).is_inline_function ())
-		    dassl_jac = c(1).function_value ();
-		  else
-		    {
-			jac_name = unique_symbol_name ("__dassl_jac__");
-			jname = "function jac = ";
-			jname.append(jac_name);
-			jname.append (" (x, xdot, t, cj) jac = ");
-			dassl_jac = extract_function
-			  (c(1), "dassl", jac_name, jname, "; endfunction");
+        {
+          Cell c = f_arg.cell_value ();
+          if (c.length() == 1)
+            f_arg = c(0);
+          else if (c.length() == 2)
+            {
+              if (c(0).is_function_handle () || c(0).is_inline_function ())
+                dassl_fcn = c(0).function_value ();
+              else
+                {
+                  fcn_name = unique_symbol_name ("__dassl_fcn__");
+                  fname = "function y = ";
+                  fname.append (fcn_name);
+                  fname.append (" (x, xdot, t) y = ");
+                  dassl_fcn = extract_function
+                    (c(0), "dassl", fcn_name, fname, "; endfunction");
+                }
+              
+              if (dassl_fcn)
+                {
+                  if (c(1).is_function_handle () || c(1).is_inline_function ())
+                    dassl_jac = c(1).function_value ();
+                  else
+                    {
+                        jac_name = unique_symbol_name ("__dassl_jac__");
+                        jname = "function jac = ";
+                        jname.append(jac_name);
+                        jname.append (" (x, xdot, t, cj) jac = ");
+                        dassl_jac = extract_function
+                          (c(1), "dassl", jac_name, jname, "; endfunction");
 
-			if (!dassl_jac)
-			  {
-			    if (fcn_name.length())
-			      clear_function (fcn_name);
-			    dassl_fcn = 0;
-			  }
-		    }
-		}
-	    }
-	  else
-	    DASSL_ABORT1 ("incorrect number of elements in cell array");
-	}
+                        if (!dassl_jac)
+                          {
+                            if (fcn_name.length())
+                              clear_function (fcn_name);
+                            dassl_fcn = 0;
+                          }
+                    }
+                }
+            }
+          else
+            DASSL_ABORT1 ("incorrect number of elements in cell array");
+        }
 
       if (!dassl_fcn && ! f_arg.is_cell())
-	{
-	  if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-	    dassl_fcn = f_arg.function_value ();
-	  else
-	    {
-	      switch (f_arg.rows ())
-		{
-		case 1:
-		  do
-		    {
-		      fcn_name = unique_symbol_name ("__dassl_fcn__");
-		      fname = "function y = ";
-		      fname.append (fcn_name);
-		      fname.append (" (x, xdot, t) y = ");
-		      dassl_fcn = extract_function
-			(f_arg, "dassl", fcn_name, fname, "; endfunction");
-		    }
-		  while (0);
-		  break;
+        {
+          if (f_arg.is_function_handle () || f_arg.is_inline_function ())
+            dassl_fcn = f_arg.function_value ();
+          else
+            {
+              switch (f_arg.rows ())
+                {
+                case 1:
+                  do
+                    {
+                      fcn_name = unique_symbol_name ("__dassl_fcn__");
+                      fname = "function y = ";
+                      fname.append (fcn_name);
+                      fname.append (" (x, xdot, t) y = ");
+                      dassl_fcn = extract_function
+                        (f_arg, "dassl", fcn_name, fname, "; endfunction");
+                    }
+                  while (0);
+                  break;
 
-		case 2:
-		  {
-		    string_vector tmp = f_arg.all_strings ();
+                case 2:
+                  {
+                    string_vector tmp = f_arg.all_strings ();
 
-		    if (! error_state)
-		      {
-			fcn_name = unique_symbol_name ("__dassl_fcn__");
-			fname = "function y = ";
-			fname.append (fcn_name);
-			fname.append (" (x, xdot, t) y = ");
-			dassl_fcn = extract_function
-			  (tmp(0), "dassl", fcn_name, fname, "; endfunction");
+                    if (! error_state)
+                      {
+                        fcn_name = unique_symbol_name ("__dassl_fcn__");
+                        fname = "function y = ";
+                        fname.append (fcn_name);
+                        fname.append (" (x, xdot, t) y = ");
+                        dassl_fcn = extract_function
+                          (tmp(0), "dassl", fcn_name, fname, "; endfunction");
 
-			if (dassl_fcn)
-			  {
-			    jac_name = unique_symbol_name ("__dassl_jac__");
-			    jname = "function jac = ";
-			    jname.append(jac_name);
-			    jname.append (" (x, xdot, t, cj) jac = ");
-			    dassl_jac = extract_function
-			      (tmp(1), "dassl", jac_name, jname, 
-			       "; endfunction");
+                        if (dassl_fcn)
+                          {
+                            jac_name = unique_symbol_name ("__dassl_jac__");
+                            jname = "function jac = ";
+                            jname.append(jac_name);
+                            jname.append (" (x, xdot, t, cj) jac = ");
+                            dassl_jac = extract_function
+                              (tmp(1), "dassl", jac_name, jname, 
+                               "; endfunction");
 
-			    if (!dassl_jac)
-			      {
-				if (fcn_name.length())
-				  clear_function (fcn_name);
-				dassl_fcn = 0;
-			      }
-			  }
-		      }
-		  }
-		}
-	    }
-	}
+                            if (!dassl_jac)
+                              {
+                                if (fcn_name.length())
+                                  clear_function (fcn_name);
+                                dassl_fcn = 0;
+                              }
+                          }
+                      }
+                  }
+                }
+            }
+        }
 
       if (error_state || ! dassl_fcn)
-	DASSL_ABORT ();
+        DASSL_ABORT ();
 
       ColumnVector state = ColumnVector (args(1).vector_value ());
 
       if (error_state)
-	DASSL_ABORT1 ("expecting state vector as second argument");
+        DASSL_ABORT1 ("expecting state vector as second argument");
 
       ColumnVector deriv (args(2).vector_value ());
 
       if (error_state)
-	DASSL_ABORT1 ("expecting derivative vector as third argument");
+        DASSL_ABORT1 ("expecting derivative vector as third argument");
 
       ColumnVector out_times (args(3).vector_value ());
 
       if (error_state)
-	DASSL_ABORT1 ("expecting output time vector as fourth argument");
+        DASSL_ABORT1 ("expecting output time vector as fourth argument");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
-	{
-	  crit_times = ColumnVector (args(4).vector_value ());
+        {
+          crit_times = ColumnVector (args(4).vector_value ());
 
-	  if (error_state)
-	    DASSL_ABORT1 ("expecting critical time vector as fifth argument");
+          if (error_state)
+            DASSL_ABORT1 ("expecting critical time vector as fifth argument");
 
-	  crit_times_set = 1;
-	}
+          crit_times_set = 1;
+        }
 
       if (state.capacity () != deriv.capacity ())
-	DASSL_ABORT1 ("x and xdot must have the same size");
+        DASSL_ABORT1 ("x and xdot must have the same size");
 
       double tzero = out_times (0);
 
       DAEFunc func (dassl_user_function);
       if (dassl_jac)
-	func.set_jacobian_function (dassl_user_jacobian);
+        func.set_jacobian_function (dassl_user_jacobian);
 
       DASSL dae (state, deriv, tzero, func);
 
       dae.set_options (dassl_opts);
 
       Matrix output;
       Matrix deriv_output;
 
       if (crit_times_set)
-	output = dae.integrate (out_times, deriv_output, crit_times);
+        output = dae.integrate (out_times, deriv_output, crit_times);
       else
-	output = dae.integrate (out_times, deriv_output);
+        output = dae.integrate (out_times, deriv_output);
 
       if (fcn_name.length())
-	clear_function (fcn_name);
+        clear_function (fcn_name);
       if (jac_name.length())
-	clear_function (jac_name);
+        clear_function (jac_name);
 
       if (! error_state)
-	{
-	  std::string msg = dae.error_message ();
+        {
+          std::string msg = dae.error_message ();
 
-	  retval(3) = msg;
-	  retval(2) = static_cast<double> (dae.integration_state ());
+          retval(3) = msg;
+          retval(2) = static_cast<double> (dae.integration_state ());
 
-	  if (dae.integration_ok ())
-	    {
-	      retval(1) = deriv_output;
-	      retval(0) = output;
-	    }
-	  else
-	    {
-	      retval(1) = Matrix ();
-	      retval(0) = Matrix ();
+          if (dae.integration_ok ())
+            {
+              retval(1) = deriv_output;
+              retval(0) = output;
+            }
+          else
+            {
+              retval(1) = Matrix ();
+              retval(0) = Matrix ();
 
-	      if (nargout < 3)
-		error ("dassl: %s", msg.c_str ());
-	    }
-	}
+              if (nargout < 3)
+                error ("dassl: %s", msg.c_str ());
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -129,114 +129,114 @@ if requested.\n\
     {
       retval(0) = static_cast<double> (arg.perm_matrix_value ().determinant ());
       if (nargout > 1)
         retval(1) = 1.0;
     }
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
-	{
-	  octave_idx_type info;
-	  float rcond = 0.0;
-	  // Always compute rcond, so we can detect numerically
-	  // singular matrices.
-	  FloatMatrix m = arg.float_matrix_value ();
-	  if (! error_state)
-	    {
+        {
+          octave_idx_type info;
+          float rcond = 0.0;
+          // Always compute rcond, so we can detect numerically
+          // singular matrices.
+          FloatMatrix m = arg.float_matrix_value ();
+          if (! error_state)
+            {
               MAYBE_CAST (rep, octave_float_matrix);
               MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
-	      FloatDET det = m.determinant (mtype, info, rcond);
-	      retval(1) = rcond;
-	      retval(0) = info == -1 ? static_cast<float>(0.0) : det.value ();
+              FloatDET det = m.determinant (mtype, info, rcond);
+              retval(1) = rcond;
+              retval(0) = info == -1 ? static_cast<float>(0.0) : det.value ();
               if (rep) rep->matrix_type (mtype);
-	    }
-	}
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  octave_idx_type info;
-	  float rcond = 0.0;
-	  // Always compute rcond, so we can detect numerically
-	  // singular matrices.
-	  FloatComplexMatrix m = arg.float_complex_matrix_value ();
-	  if (! error_state)
-	    {
+        {
+          octave_idx_type info;
+          float rcond = 0.0;
+          // Always compute rcond, so we can detect numerically
+          // singular matrices.
+          FloatComplexMatrix m = arg.float_complex_matrix_value ();
+          if (! error_state)
+            {
               MAYBE_CAST (rep, octave_float_complex_matrix);
               MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
-	      FloatComplexDET det = m.determinant (mtype, info, rcond);
-	      retval(1) = rcond;
-	      retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
+              FloatComplexDET det = m.determinant (mtype, info, rcond);
+              retval(1) = rcond;
+              retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
               if (rep) rep->matrix_type (mtype);
-	    }
-	}
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  octave_idx_type info;
-	  double rcond = 0.0;
-	  // Always compute rcond, so we can detect numerically
-	  // singular matrices.
-	  if (arg.is_sparse_type ())
-	    {
-	      SparseMatrix m = arg.sparse_matrix_value ();
-	      if (! error_state)
-		{
-		  DET det = m.determinant (info, rcond);
-		  retval(1) = rcond;
-		  retval(0) = info == -1 ? 0.0 : det.value ();
-		}
-	    }
-	  else
-	    {
-	      Matrix m = arg.matrix_value ();
-	      if (! error_state)
-		{
+        {
+          octave_idx_type info;
+          double rcond = 0.0;
+          // Always compute rcond, so we can detect numerically
+          // singular matrices.
+          if (arg.is_sparse_type ())
+            {
+              SparseMatrix m = arg.sparse_matrix_value ();
+              if (! error_state)
+                {
+                  DET det = m.determinant (info, rcond);
+                  retval(1) = rcond;
+                  retval(0) = info == -1 ? 0.0 : det.value ();
+                }
+            }
+          else
+            {
+              Matrix m = arg.matrix_value ();
+              if (! error_state)
+                {
                   MAYBE_CAST (rep, octave_matrix);
                   MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
-		  DET det = m.determinant (mtype, info, rcond);
-		  retval(1) = rcond;
-		  retval(0) = info == -1 ? 0.0 : det.value ();
+                  DET det = m.determinant (mtype, info, rcond);
+                  retval(1) = rcond;
+                  retval(0) = info == -1 ? 0.0 : det.value ();
                   if (rep) rep->matrix_type (mtype);
-		}
-	    }
-	}
+                }
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  octave_idx_type info;
-	  double rcond = 0.0;
-	  // Always compute rcond, so we can detect numerically
-	  // singular matrices.
-	  if (arg.is_sparse_type ())
-	    {
-	      SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
-	      if (! error_state)
-		{
-		  ComplexDET det = m.determinant (info, rcond);
-		  retval(1) = rcond;
-		  retval(0) = info == -1 ? Complex (0.0) : det.value ();
-		}
-	    }
-	  else
-	    {
-	      ComplexMatrix m = arg.complex_matrix_value ();
-	      if (! error_state)
-		{
+        {
+          octave_idx_type info;
+          double rcond = 0.0;
+          // Always compute rcond, so we can detect numerically
+          // singular matrices.
+          if (arg.is_sparse_type ())
+            {
+              SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
+              if (! error_state)
+                {
+                  ComplexDET det = m.determinant (info, rcond);
+                  retval(1) = rcond;
+                  retval(0) = info == -1 ? Complex (0.0) : det.value ();
+                }
+            }
+          else
+            {
+              ComplexMatrix m = arg.complex_matrix_value ();
+              if (! error_state)
+                {
                   MAYBE_CAST (rep, octave_complex_matrix);
                   MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
-		  ComplexDET det = m.determinant (mtype, info, rcond);
-		  retval(1) = rcond;
-		  retval(0) = info == -1 ? Complex (0.0) : det.value ();
+                  ComplexDET det = m.determinant (mtype, info, rcond);
+                  retval(1) = rcond;
+                  retval(0) = info == -1 ? Complex (0.0) : det.value ();
                   if (rep) rep->matrix_type (mtype);
-		}
-	    }
-	}
+                }
+            }
+        }
       else
-	gripe_wrong_type_arg ("det", arg);
+        gripe_wrong_type_arg ("det", arg);
     }
   return retval;
 }
 
 /*
 
 %!assert(det ([1, 2; 3, 4]), -2, 10 * eps);
 %!assert(det (single([1, 2; 3, 4])), single(-2), 10 * eps ('single'));
diff --git a/src/DLD-FUNCTIONS/dispatch.cc b/src/DLD-FUNCTIONS/dispatch.cc
--- a/src/DLD-FUNCTIONS/dispatch.cc
+++ b/src/DLD-FUNCTIONS/dispatch.cc
@@ -52,27 +52,27 @@ some other function for the given type s
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       const std::string name (args(0).string_value ());
  
       if (! error_state)
-	{
-	  octave_value fcn = symbol_table::builtin_find (name);
+        {
+          octave_value fcn = symbol_table::builtin_find (name);
 
-	  if (fcn.is_defined ())
-	    retval = feval (fcn.function_value (), args.splice (0, 1),
-			    nargout);
-	  else
-	    error ("builtin: lookup for symbol `%s' failed", name.c_str ());
-	}
+          if (fcn.is_defined ())
+            retval = feval (fcn.function_value (), args.splice (0, 1),
+                            nargout);
+          else
+            error ("builtin: lookup for symbol `%s' failed", name.c_str ());
+        }
       else
-	error ("builtin: expecting function name as first argument");
+        error ("builtin: expecting function name as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (dispatch, args, nargout,
@@ -96,88 +96,88 @@ for @var{f}.\n\
 
   int nargin = args.length ();
 
   std::string f, r, t;
 
   if (nargin > 0 && nargin < 4)
     {
       if (nargin > 0)
-	{
-	  f = args(0).string_value ();
+        {
+          f = args(0).string_value ();
 
-	  if (error_state)
-	    {
-	      error ("dispatch: expecting first argument to be function name");
-	      return retval;
-	    }
-	}
+          if (error_state)
+            {
+              error ("dispatch: expecting first argument to be function name");
+              return retval;
+            }
+        }
 
       if (nargin > 1)
-	{
-	  r = args(1).string_value ();
+        {
+          r = args(1).string_value ();
 
-	  if (error_state)
-	    {
-	      error ("dispatch: expecting second argument to be function name");
-	      return retval;
-	    }
-	}
+          if (error_state)
+            {
+              error ("dispatch: expecting second argument to be function name");
+              return retval;
+            }
+        }
 
       if (nargin > 2)
-	{
-	  t = args(2).string_value ();
+        {
+          t = args(2).string_value ();
 
-	  if (error_state)
-	    {
-	      error ("dispatch: expecting third argument to be type name");
-	      return retval;
-	    }
-	}
+          if (error_state)
+            {
+              error ("dispatch: expecting third argument to be type name");
+              return retval;
+            }
+        }
 
       if (nargin == 1)
-	{
-	  if (nargout > 0)
-	    {
-	      symbol_table::fcn_info::dispatch_map_type dm
-		= symbol_table::get_dispatch (f);
+        {
+          if (nargout > 0)
+            {
+              symbol_table::fcn_info::dispatch_map_type dm
+                = symbol_table::get_dispatch (f);
 
-	      size_t len = dm.size ();
+              size_t len = dm.size ();
 
-	      Cell type_field (len, 1);
-	      Cell name_field (len, 1);
+              Cell type_field (len, 1);
+              Cell name_field (len, 1);
 
-	      symbol_table::fcn_info::dispatch_map_type::const_iterator p
-		= dm.begin ();
+              symbol_table::fcn_info::dispatch_map_type::const_iterator p
+                = dm.begin ();
 
-	      for (size_t i = 0; i < len; i++)
-		{
-		  type_field(i) = p->first;
-		  name_field(i) = p->second;
+              for (size_t i = 0; i < len; i++)
+                {
+                  type_field(i) = p->first;
+                  name_field(i) = p->second;
 
-		  p++;
-		}
+                  p++;
+                }
 
-	      Octave_map m;
+              Octave_map m;
 
-	      m.assign ("type", type_field);
-	      m.assign ("name", name_field);
+              m.assign ("type", type_field);
+              m.assign ("name", name_field);
 
-	      retval = m;
-	    }
-	  else
-	    symbol_table::print_dispatch (octave_stdout, f);
-	}
+              retval = m;
+            }
+          else
+            symbol_table::print_dispatch (octave_stdout, f);
+        }
       else if (nargin == 2)
-	{
-	  t = r;
-	  symbol_table::clear_dispatch (f, t);
-	}
+        {
+          t = r;
+          symbol_table::clear_dispatch (f, t);
+        }
       else
-	symbol_table::add_dispatch (f, t, r);
+        symbol_table::add_dispatch (f, t, r);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -43,101 +43,101 @@ read_cell_spec (std::istream& is, unsign
 {
   bool stat = false;
 
   if (is.peek () == std::istream::traits_type::eof ())
     stat = true;
   else
     {
       if (::isalpha (is.peek ()))
-	{
-	  col = 0;
-	  while (is && ::isalpha (is.peek ()))
-	    {
-	      char ch = is.get ();
-	      col *= 26;
-	      if (ch >= 'a')
-		col += ch - 'a';
-	      else
-		col += ch - 'A';
-	    }
+        {
+          col = 0;
+          while (is && ::isalpha (is.peek ()))
+            {
+              char ch = is.get ();
+              col *= 26;
+              if (ch >= 'a')
+                col += ch - 'a';
+              else
+                col += ch - 'A';
+            }
 
-	  if (is)
-	    {
-	      is >> row;
-	      row --;
-	      if (is)
-		stat = true;
-	    }
-	}
+          if (is)
+            {
+              is >> row;
+              row --;
+              if (is)
+                stat = true;
+            }
+        }
     }
 
   return stat;
 }
 
 static bool
 parse_range_spec (const octave_value& range_spec,
-		  unsigned long& rlo, unsigned long& clo,
-		  unsigned long& rup, unsigned long& cup)
+                  unsigned long& rlo, unsigned long& clo,
+                  unsigned long& rup, unsigned long& cup)
 {
   bool stat = true;
 
   if (range_spec.is_string ())
     {
       std::istringstream is (range_spec.string_value ());
       char ch = is.peek ();
 
       if (ch == '.' || ch == ':')
-	{
-	  rlo = 0;
-	  clo = 0;
-	  ch = is.get ();
-	  if (ch == '.')
-	    {
-	      ch = is.get ();
-	      if (ch != '.')
-		stat = false;
-	    }
-	}
+        {
+          rlo = 0;
+          clo = 0;
+          ch = is.get ();
+          if (ch == '.')
+            {
+              ch = is.get ();
+              if (ch != '.')
+                stat = false;
+            }
+        }
       else
-	{
-	  stat = read_cell_spec (is, rlo, clo);
+        {
+          stat = read_cell_spec (is, rlo, clo);
 
-	  if (stat)
-	    {
-	      ch = is.peek ();
-	  
-	      if (ch == '.' || ch == ':')
-		{
-		  ch = is.get ();
-		  if (ch == '.')
-		    {
-		      ch = is.get ();
-		      if (!is || ch != '.')
-			stat = false;
-		    }
+          if (stat)
+            {
+              ch = is.peek ();
+          
+              if (ch == '.' || ch == ':')
+                {
+                  ch = is.get ();
+                  if (ch == '.')
+                    {
+                      ch = is.get ();
+                      if (!is || ch != '.')
+                        stat = false;
+                    }
 
-		  rup = ULONG_MAX - 1;
-		  cup = ULONG_MAX - 1;
-		}
-	      else
-		{
-		  rup = rlo;
-		  cup = clo;
-		  if (!is || !is.eof ())
-		    stat = false;
-		}
-	    }
-	}
+                  rup = ULONG_MAX - 1;
+                  cup = ULONG_MAX - 1;
+                }
+              else
+                {
+                  rup = rlo;
+                  cup = clo;
+                  if (!is || !is.eof ())
+                    stat = false;
+                }
+            }
+        }
 
       if (stat && is && !is.eof ())
-	stat = read_cell_spec (is, rup, cup);
+        stat = read_cell_spec (is, rup, cup);
 
       if (!is || !is.eof ())
-	stat = false;
+        stat = false;
     }
   else if (range_spec.is_real_matrix () && range_spec.numel () == 4)
     {
       ColumnVector range(range_spec.vector_value ());
       // double --> unsigned int     
       rlo = static_cast<unsigned long> (range(0));
       clo = static_cast<unsigned long> (range(1));
       rup = static_cast<unsigned long> (range(2));
@@ -197,41 +197,41 @@ a spreadsheet style range such as 'A2..Q
       return retval;
     }
   
   // Set default separator.
   std::string sep;
   if (nargin > 1)
     {
       if (args(1).is_sq_string ())
-	sep = do_string_escapes (args(1).string_value ());
+        sep = do_string_escapes (args(1).string_value ());
       else
-	sep = args(1).string_value ();
+        sep = args(1).string_value ();
 
       if (error_state)
-	return retval;
+        return retval;
     }
   
   // Take a subset if a range was given.
   unsigned long r0 = 0, c0 = 0, r1 = ULONG_MAX-1, c1 = ULONG_MAX-1;
   if (nargin > 2)
     {
       if (nargin == 3)
-	{
-	  if (!parse_range_spec (args (2), r0, c0, r1, c1))
-	    error ("dlmread: error parsing range");
-	} 
+        {
+          if (!parse_range_spec (args (2), r0, c0, r1, c1))
+            error ("dlmread: error parsing range");
+        } 
       else if (nargin == 4) 
-	{
-	  r0 = args(2).ulong_value ();
-	  c0 = args(3).ulong_value ();
+        {
+          r0 = args(2).ulong_value ();
+          c0 = args(3).ulong_value ();
 
-	  if (error_state)
-	    return retval;
-	}
+          if (error_state)
+            return retval;
+        }
     }
 
   if (!error_state)
     {
       unsigned long i = 0, j = 0, r = 1, c = 1, rmax = 0, cmax = 0;
 
       Matrix rdata;
       ComplexMatrix cdata;
@@ -240,160 +240,160 @@ a spreadsheet style range such as 'A2..Q
       bool sepflag = false;
 
       unsigned long maxrows = r1 - r0;
 
       std::string line;
 
       // Skip the r0 leading lines as these might be a header.
       for (unsigned long m = 0; m < r0; m++)
-	getline (file, line);
+        getline (file, line);
       r1 -= r0;
 
       // Read in the data one field at a time, growing the data matrix
       // as needed.
       while (getline (file, line))
-	{
-	  // Skip blank lines for compatibility.
-	  if (line.find_first_not_of (" \t") == std::string::npos)
-	    continue;
+        {
+          // Skip blank lines for compatibility.
+          if (line.find_first_not_of (" \t") == std::string::npos)
+            continue;
 
-	  // To be compatible with matlab, blank separator should
-	  // correspond to whitespace as delimter.
-	  if (!sep.length ())
-	    {
-	      size_t n = line.find_first_of (",:; \t", 
-					     line.find_first_of ("0123456789"));
-	      if (n == std::string::npos)
-		{
-		  sep = " \t";
-		  sepflag = true;
-		}
-	      else
-		{
-		  char ch = line.at (n);
+          // To be compatible with matlab, blank separator should
+          // correspond to whitespace as delimter.
+          if (!sep.length ())
+            {
+              size_t n = line.find_first_of (",:; \t", 
+                                             line.find_first_of ("0123456789"));
+              if (n == std::string::npos)
+                {
+                  sep = " \t";
+                  sepflag = true;
+                }
+              else
+                {
+                  char ch = line.at (n);
 
-		  switch (line.at (n))
-		    {
-		    case ' ':
-		    case '\t':
-		      sepflag = true;
-		      sep = " \t";
-		      break;
+                  switch (line.at (n))
+                    {
+                    case ' ':
+                    case '\t':
+                      sepflag = true;
+                      sep = " \t";
+                      break;
 
-		    default:
-		      sep = ch;
-		      break;
-		    }
-		}
-	    }
+                    default:
+                      sep = ch;
+                      break;
+                    }
+                }
+            }
 
-	  r = (r > i + 1 ? r : i + 1);
-	  j = 0;
-	  size_t pos1 = 0;
-	  do
-	    {
-	      size_t pos2 = line.find_first_of (sep, pos1);
-	      std::string str = line.substr (pos1, pos2 - pos1);
+          r = (r > i + 1 ? r : i + 1);
+          j = 0;
+          size_t pos1 = 0;
+          do
+            {
+              size_t pos2 = line.find_first_of (sep, pos1);
+              std::string str = line.substr (pos1, pos2 - pos1);
 
-	      if (sepflag && pos2 != std::string::npos)
-		// Treat consecutive separators as one.
-		pos2 = line.find_first_not_of (sep, pos2) - 1;
+              if (sepflag && pos2 != std::string::npos)
+                // Treat consecutive separators as one.
+                pos2 = line.find_first_not_of (sep, pos2) - 1;
 
-	      c = (c > j + 1 ? c : j + 1);
-	      if (r > rmax || c > cmax)
-		{ 
-		  // Use resize_and_fill for the case of not-equal
-		  // length rows.
-		  if (iscmplx)
-		    cdata.resize_fill (r, c, 0);
-		  else
-		    rdata.resize_fill (r, c, 0);
-		  rmax = r;
-		  cmax = c;
-		}
+              c = (c > j + 1 ? c : j + 1);
+              if (r > rmax || c > cmax)
+                { 
+                  // Use resize_and_fill for the case of not-equal
+                  // length rows.
+                  if (iscmplx)
+                    cdata.resize_fill (r, c, 0);
+                  else
+                    rdata.resize_fill (r, c, 0);
+                  rmax = r;
+                  cmax = c;
+                }
 
-	      std::istringstream tmp_stream (str);
-	      double x = octave_read_double (tmp_stream);
-	      if (tmp_stream)
-		{
-		  if (tmp_stream.eof ())
-		    if (iscmplx)
-		      cdata(i,j++) = x;
-		    else
-		      rdata(i,j++) = x;
-		  else
-		    {
-		      double y = octave_read_double (tmp_stream);
+              std::istringstream tmp_stream (str);
+              double x = octave_read_double (tmp_stream);
+              if (tmp_stream)
+                {
+                  if (tmp_stream.eof ())
+                    if (iscmplx)
+                      cdata(i,j++) = x;
+                    else
+                      rdata(i,j++) = x;
+                  else
+                    {
+                      double y = octave_read_double (tmp_stream);
 
-		      if (!iscmplx && y != 0.)
-			{
-			  iscmplx = true;
-			  cdata = ComplexMatrix (rdata);
-			}
+                      if (!iscmplx && y != 0.)
+                        {
+                          iscmplx = true;
+                          cdata = ComplexMatrix (rdata);
+                        }
 
-		      if (iscmplx)
-			cdata(i,j++) = Complex (x, y);
-		      else
-			rdata(i,j++) = x;
-		    }
-		}
-	      else if (iscmplx)
-		cdata(i,j++) = 0.;
-	      else
-		rdata(i,j++) = 0.;
+                      if (iscmplx)
+                        cdata(i,j++) = Complex (x, y);
+                      else
+                        rdata(i,j++) = x;
+                    }
+                }
+              else if (iscmplx)
+                cdata(i,j++) = 0.;
+              else
+                rdata(i,j++) = 0.;
 
-	      if (pos2 != std::string::npos)
-		pos1 = pos2 + 1;
-	      else
-		pos1 = std::string::npos;
+              if (pos2 != std::string::npos)
+                pos1 = pos2 + 1;
+              else
+                pos1 = std::string::npos;
 
-	    }
-	  while (pos1 != std::string::npos);
+            }
+          while (pos1 != std::string::npos);
 
-	  if (nargin == 3 && i == maxrows)
-	    break;
+          if (nargin == 3 && i == maxrows)
+            break;
 
-	  i++;
-	}
+          i++;
+        }
  
       if (nargin > 2)
-	{
-	  if (nargin == 3)
-	    {
-	      if (r1 >= r)
-		r1 = r - 1;
-	      if (c1 >= c)
-		c1 = c - 1;
-	    }
-	  else if (nargin == 4) 
-	    {
-	      // If r1 and c1 are not given, use what was found to be
-	      // the maximum.
-	      r1 = r - 1;
-	      c1 = c - 1;
-	    }
+        {
+          if (nargin == 3)
+            {
+              if (r1 >= r)
+                r1 = r - 1;
+              if (c1 >= c)
+                c1 = c - 1;
+            }
+          else if (nargin == 4) 
+            {
+              // If r1 and c1 are not given, use what was found to be
+              // the maximum.
+              r1 = r - 1;
+              c1 = c - 1;
+            }
 
-	  // Now take the subset of the matrix.
-	  if (iscmplx)
-	    {
-	      cdata = cdata.extract (0, c0, r1, c1);
-	      cdata.resize (r1 + 1, c1 - c0 + 1);
-	    }
-	  else
-	    {
-	      rdata = rdata.extract (0, c0, r1, c1);
-	      rdata.resize (r1 + 1, c1 - c0 + 1);
-	    }
-	}
+          // Now take the subset of the matrix.
+          if (iscmplx)
+            {
+              cdata = cdata.extract (0, c0, r1, c1);
+              cdata.resize (r1 + 1, c1 - c0 + 1);
+            }
+          else
+            {
+              rdata = rdata.extract (0, c0, r1, c1);
+              rdata.resize (r1 + 1, c1 - c0 + 1);
+            }
+        }
   
       if (iscmplx)
-	retval(0) = cdata;
+        retval(0) = cdata;
       else
-	retval(0) = rdata;
+        retval(0) = rdata;
     }
 
   return retval;
 }
 
 /*
 
 %!shared file
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -80,57 +80,57 @@ dmperm_internal (bool rank, const octave
       csm.nzmax = cm.nnz();
       csm.p = cm.xcidx ();
       csm.i = cm.xridx ();
     }
 
   if (!error_state)
     {
       if (nargout <= 1 || rank)
-	{
+        {
 #if defined(CS_VER) && (CS_VER >= 2)
-	  octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
+          octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
 #else
-	  octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm);
+          octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm);
 #endif
-	  if (rank)
-	    {
-	      octave_idx_type r = 0;
-	      for (octave_idx_type i = 0; i < nc; i++)
-		if (jmatch[nr+i] >= 0)
-		  r++;
-	      retval(0) = static_cast<double>(r);
-	    }
-	  else
-	    retval(0) = put_int (jmatch + nr, nc);
-	  CXSPARSE_NAME (_free) (jmatch);
-	}
+          if (rank)
+            {
+              octave_idx_type r = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (jmatch[nr+i] >= 0)
+                  r++;
+              retval(0) = static_cast<double>(r);
+            }
+          else
+            retval(0) = put_int (jmatch + nr, nc);
+          CXSPARSE_NAME (_free) (jmatch);
+        }
       else
-	{
+        {
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm, 0);
+          CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm, 0);
 #else
-	  CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm);
+          CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm);
 #endif
 
-	  //retval(5) = put_int (dm->rr, 5);
-	  //retval(4) = put_int (dm->cc, 5);
+          //retval(5) = put_int (dm->rr, 5);
+          //retval(4) = put_int (dm->cc, 5);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  retval(3) = put_int (dm->s, dm->nb+1);
-	  retval(2) = put_int (dm->r, dm->nb+1);
-	  retval(1) = put_int (dm->q, nc);
-	  retval(0) = put_int (dm->p, nr);
+          retval(3) = put_int (dm->s, dm->nb+1);
+          retval(2) = put_int (dm->r, dm->nb+1);
+          retval(1) = put_int (dm->q, nc);
+          retval(0) = put_int (dm->p, nr);
 #else
-	  retval(3) = put_int (dm->S, dm->nb+1);
-	  retval(2) = put_int (dm->R, dm->nb+1);
-	  retval(1) = put_int (dm->Q, nc);
-	  retval(0) = put_int (dm->P, nr);
+          retval(3) = put_int (dm->S, dm->nb+1);
+          retval(2) = put_int (dm->R, dm->nb+1);
+          retval(1) = put_int (dm->Q, nc);
+          retval(0) = put_int (dm->P, nr);
 #endif
-	  CXSPARSE_NAME (_dfree) (dm);
-	}
+          CXSPARSE_NAME (_dfree) (dm);
+        }
     }
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} dmperm (@var{s})\n\
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -89,20 +89,20 @@ The eigenvalues returned by @code{eig} a
 
       arg_is_empty = empty_arg ("eig", nr_b, nc_b);
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
         return octave_value_list (2, Matrix ());
 
       if (!(arg_b.is_single_type() || arg_b.is_double_type ()))
-	{
-	  gripe_wrong_type_arg ("eig", arg_b);
-	  return retval;
-	}
+        {
+          gripe_wrong_type_arg ("eig", arg_b);
+          return retval;
+        }
     }
 
   if (nr_a != nc_a)
     {
       gripe_square_matrix_required ("eig");
       return retval;
     }
 
@@ -117,142 +117,142 @@ The eigenvalues returned by @code{eig} a
   FloatMatrix ftmp_a, ftmp_b;
   FloatComplexMatrix fctmp_a, fctmp_b;
 
   if (arg_a.is_single_type ())
     {
       FloatEIG result;
 
       if (nargin == 1)
-	{
-	  if (arg_a.is_real_type ())
-	    {
-	      ftmp_a = arg_a.float_matrix_value ();
+        {
+          if (arg_a.is_real_type ())
+            {
+              ftmp_a = arg_a.float_matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = FloatEIG (ftmp_a, nargout > 1);
-	    }
-	  else
-	    {
-	      fctmp_a = arg_a.float_complex_matrix_value ();
+              if (error_state)
+                return retval;
+              else
+                result = FloatEIG (ftmp_a, nargout > 1);
+            }
+          else
+            {
+              fctmp_a = arg_a.float_complex_matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = FloatEIG (fctmp_a, nargout > 1);
-	    }
-	}
+              if (error_state)
+                return retval;
+              else
+                result = FloatEIG (fctmp_a, nargout > 1);
+            }
+        }
       else if (nargin == 2)
-	{
-	  if (arg_a.is_real_type () && arg_b.is_real_type ())
-	    {
-	      ftmp_a = arg_a.float_matrix_value ();
-	      ftmp_b = arg_b.float_matrix_value ();
+        {
+          if (arg_a.is_real_type () && arg_b.is_real_type ())
+            {
+              ftmp_a = arg_a.float_matrix_value ();
+              ftmp_b = arg_b.float_matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = FloatEIG (ftmp_a, ftmp_b, nargout > 1);
-	    }
-	  else
-	    {
-	      fctmp_a = arg_a.float_complex_matrix_value ();
-	      fctmp_b = arg_b.float_complex_matrix_value ();
+              if (error_state)
+                return retval;
+              else
+                result = FloatEIG (ftmp_a, ftmp_b, nargout > 1);
+            }
+          else
+            {
+              fctmp_a = arg_a.float_complex_matrix_value ();
+              fctmp_b = arg_b.float_complex_matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = FloatEIG (fctmp_a, fctmp_b, nargout > 1);
-	    }
-	}
+              if (error_state)
+                return retval;
+              else
+                result = FloatEIG (fctmp_a, fctmp_b, nargout > 1);
+            }
+        }
 
       if (! error_state)
-	{
-	  if (nargout == 0 || nargout == 1)
-	    {
-	      retval(0) = result.eigenvalues ();
-	    }
-	  else
-	    {
-	      // Blame it on Matlab.
+        {
+          if (nargout == 0 || nargout == 1)
+            {
+              retval(0) = result.eigenvalues ();
+            }
+          else
+            {
+              // Blame it on Matlab.
 
-	      FloatComplexDiagMatrix d (result.eigenvalues ());
+              FloatComplexDiagMatrix d (result.eigenvalues ());
 
-	      retval(1) = d;
-	      retval(0) = result.eigenvectors ();
-	    }
-	}
+              retval(1) = d;
+              retval(0) = result.eigenvectors ();
+            }
+        }
     }
   else
     {
       EIG result;
 
       if (nargin == 1)
-	{
-	  if (arg_a.is_real_type ())
-	    {
-	      tmp_a = arg_a.matrix_value ();
+        {
+          if (arg_a.is_real_type ())
+            {
+              tmp_a = arg_a.matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = EIG (tmp_a, nargout > 1);
-	    }
-	  else
-	    {
-	      ctmp_a = arg_a.complex_matrix_value ();
+              if (error_state)
+                return retval;
+              else
+                result = EIG (tmp_a, nargout > 1);
+            }
+          else
+            {
+              ctmp_a = arg_a.complex_matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = EIG (ctmp_a, nargout > 1);
-	    }
-	}
+              if (error_state)
+                return retval;
+              else
+                result = EIG (ctmp_a, nargout > 1);
+            }
+        }
       else if (nargin == 2)
-	{
-	  if (arg_a.is_real_type () && arg_b.is_real_type ())
-	    {
-	      tmp_a = arg_a.matrix_value ();
-	      tmp_b = arg_b.matrix_value ();
+        {
+          if (arg_a.is_real_type () && arg_b.is_real_type ())
+            {
+              tmp_a = arg_a.matrix_value ();
+              tmp_b = arg_b.matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = EIG (tmp_a, tmp_b, nargout > 1);
-	    }
-	  else 
-	    {
-	      ctmp_a = arg_a.complex_matrix_value ();
-	      ctmp_b = arg_b.complex_matrix_value ();
+              if (error_state)
+                return retval;
+              else
+                result = EIG (tmp_a, tmp_b, nargout > 1);
+            }
+          else 
+            {
+              ctmp_a = arg_a.complex_matrix_value ();
+              ctmp_b = arg_b.complex_matrix_value ();
 
-	      if (error_state)
-	        return retval;
-	      else
-	        result = EIG (ctmp_a, ctmp_b, nargout > 1);
-	    }
-	}
+              if (error_state)
+                return retval;
+              else
+                result = EIG (ctmp_a, ctmp_b, nargout > 1);
+            }
+        }
 
       if (! error_state)
-	{
-	  if (nargout == 0 || nargout == 1)
-	    {
-	      retval(0) = result.eigenvalues ();
-	    }
-	  else
-	    {
-	      // Blame it on Matlab.
+        {
+          if (nargout == 0 || nargout == 1)
+            {
+              retval(0) = result.eigenvalues ();
+            }
+          else
+            {
+              // Blame it on Matlab.
 
-	      ComplexDiagMatrix d (result.eigenvalues ());
+              ComplexDiagMatrix d (result.eigenvalues ());
 
-	      retval(1) = d;
-	      retval(0) = result.eigenvectors ();
-	    }
-	}
+              retval(1) = d;
+              retval(0) = result.eigenvectors ();
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!assert(eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps));
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -54,43 +54,43 @@ eigs_func (const ColumnVector &x, int &e
   octave_value_list args;
   args(0) = x;
 
   if (eigs_fcn)
     {
       octave_value_list tmp = eigs_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  eigs_error = 1;
-	  gripe_user_supplied_eval ("eigs");
-	  return retval;
-	}
+        {
+          eigs_error = 1;
+          gripe_user_supplied_eval ("eigs");
+          return retval;
+        }
 
       if (tmp.length () && tmp(0).is_defined ())
-	{
-	  if (! warned_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("eigs: ignoring imaginary part returned from user-supplied function");
-	      warned_imaginary = true;
-	    }
+        {
+          if (! warned_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("eigs: ignoring imaginary part returned from user-supplied function");
+              warned_imaginary = true;
+            }
 
-	  retval = ColumnVector (tmp(0).vector_value ());
+          retval = ColumnVector (tmp(0).vector_value ());
 
-	  if (error_state)
-	    {
-	      eigs_error = 1;
-	      gripe_user_supplied_eval ("eigs");
-	    }
-	}
+          if (error_state)
+            {
+              eigs_error = 1;
+              gripe_user_supplied_eval ("eigs");
+            }
+        }
       else
-	{
-	  eigs_error = 1;
-	  gripe_user_supplied_eval ("eigs");
-	}
+        {
+          eigs_error = 1;
+          gripe_user_supplied_eval ("eigs");
+        }
     }
 
   return retval;
 }
 
 ComplexColumnVector
 eigs_complex_func (const ComplexColumnVector &x, int &eigs_error)
 {
@@ -98,37 +98,37 @@ eigs_complex_func (const ComplexColumnVe
   octave_value_list args;
   args(0) = x;
 
   if (eigs_fcn)
     {
       octave_value_list tmp = eigs_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  eigs_error = 1;
-	  gripe_user_supplied_eval ("eigs");
-	  return retval;
-	}
+        {
+          eigs_error = 1;
+          gripe_user_supplied_eval ("eigs");
+          return retval;
+        }
 
       if (tmp.length () && tmp(0).is_defined ())
-	{
-	  retval = ComplexColumnVector (tmp(0).complex_vector_value ());
+        {
+          retval = ComplexColumnVector (tmp(0).complex_vector_value ());
 
-	  if (error_state)
-	    {
-	      eigs_error = 1;
-	      gripe_user_supplied_eval ("eigs");
-	    }
-	}
+          if (error_state)
+            {
+              eigs_error = 1;
+              gripe_user_supplied_eval ("eigs");
+            }
+        }
       else
-	{
-	  eigs_error = 1;
-	  gripe_user_supplied_eval ("eigs");
-	}
+        {
+          eigs_error = 1;
+          gripe_user_supplied_eval ("eigs");
+        }
     }
 
   return retval;
 }
 
 DEFUN_DLD (eigs, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{d} =} eigs (@var{a})\n\
@@ -344,398 +344,398 @@ K Maschhoff, D Sorensen and C Yang.  For
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     {
       error ("eigs: invalid recursive call");
       if (fcn_name.length())
-	clear_function (fcn_name);
+        clear_function (fcn_name);
       return retval;
     }
 
   if (nargin == 0)
     print_usage ();
   else if (args(0).is_function_handle () || args(0).is_inline_function ()
-	   || args(0).is_string ())
+           || args(0).is_string ())
     {
       if (args(0).is_string ())
-	{
-	  std::string name = args(0).string_value ();
-	  std::string fname = "function y = ";
-	  fcn_name = unique_symbol_name ("__eigs_fcn_");
-	  fname.append (fcn_name);
-	  fname.append ("(x) y = ");
-	  eigs_fcn = extract_function (args(0), "eigs", fcn_name, fname,
-				       "; endfunction");
-	}
+        {
+          std::string name = args(0).string_value ();
+          std::string fname = "function y = ";
+          fcn_name = unique_symbol_name ("__eigs_fcn_");
+          fname.append (fcn_name);
+          fname.append ("(x) y = ");
+          eigs_fcn = extract_function (args(0), "eigs", fcn_name, fname,
+                                       "; endfunction");
+        }
       else
-	eigs_fcn = args(0).function_value ();
+        eigs_fcn = args(0).function_value ();
 
       if (!eigs_fcn)
-	{
-	  error ("eigs: unknown function");
-	  return retval;
-	}
+        {
+          error ("eigs: unknown function");
+          return retval;
+        }
 
       if (nargin < 2)
-	{
-	  error ("eigs: incorrect number of arguments");
-	  return retval;
-	}
+        {
+          error ("eigs: incorrect number of arguments");
+          return retval;
+        }
       else
-	{
-	  n = args(1).nint_value ();
-	  arg_offset = 1;
-	  have_a_fun = true;
-	}
+        {
+          n = args(1).nint_value ();
+          arg_offset = 1;
+          have_a_fun = true;
+        }
     }
   else
     {
       if (args(0).is_complex_type ())
-	{
-	  if (args(0).is_sparse_type ())
-	    {
-	      ascm = (args(0).sparse_complex_matrix_value());
-	      a_is_sparse = true;
-	    }
-	  else
-	    acm = (args(0).complex_matrix_value());
-	  a_is_complex = true;
-	  symmetric = false; // ARAPACK doesn't special case complex symmetric
-	}
+        {
+          if (args(0).is_sparse_type ())
+            {
+              ascm = (args(0).sparse_complex_matrix_value());
+              a_is_sparse = true;
+            }
+          else
+            acm = (args(0).complex_matrix_value());
+          a_is_complex = true;
+          symmetric = false; // ARAPACK doesn't special case complex symmetric
+        }
       else
-	{
-	  if (args(0).is_sparse_type ())
-	    {
-	      asmm = (args(0).sparse_matrix_value());
-	      a_is_sparse = true;
-	      symmetric = asmm.is_symmetric();
-	    }
-	  else
-	    {
-	      amm = (args(0).matrix_value());
-	      symmetric = amm.is_symmetric();
-	    }
-	}
+        {
+          if (args(0).is_sparse_type ())
+            {
+              asmm = (args(0).sparse_matrix_value());
+              a_is_sparse = true;
+              symmetric = asmm.is_symmetric();
+            }
+          else
+            {
+              amm = (args(0).matrix_value());
+              symmetric = amm.is_symmetric();
+            }
+        }
 
     }
 
   // Note hold off reading B till later to avoid issues of double 
   // copies of the matrix if B is full/real while A is complex..
   if (!error_state && nargin > 1 + arg_offset && 
       !(args(1 + arg_offset).is_real_scalar ()))
     {
       if (args(1+arg_offset).is_complex_type ())
-	{
-	  b_arg = 1+arg_offset;
-	  have_b = true;
-	  bmat = 'G';
-	  b_is_complex = true;
-	  arg_offset++;
-	}
+        {
+          b_arg = 1+arg_offset;
+          have_b = true;
+          bmat = 'G';
+          b_is_complex = true;
+          arg_offset++;
+        }
       else
-	{
-	  b_arg = 1+arg_offset;
-	  have_b = true;
-	  bmat = 'G';
-	  arg_offset++;
-	}
+        {
+          b_arg = 1+arg_offset;
+          have_b = true;
+          bmat = 'G';
+          arg_offset++;
+        }
     }
 
   if (!error_state && nargin > (1+arg_offset))
     k = args(1+arg_offset).nint_value ();
 
   if (!error_state && nargin > (2+arg_offset))
     {
       if (args(2+arg_offset).is_string ())
-	{
-	  typ = args(2+arg_offset).string_value ();
+        {
+          typ = args(2+arg_offset).string_value ();
 
-	  // Use STL function to convert to upper case
-	  transform (typ.begin (), typ.end (), typ.begin (), toupper);
+          // Use STL function to convert to upper case
+          transform (typ.begin (), typ.end (), typ.begin (), toupper);
 
-	  sigma = 0.;
-	}
+          sigma = 0.;
+        }
       else
-	{
-	  sigma = args(2+arg_offset).complex_value ();
+        {
+          sigma = args(2+arg_offset).complex_value ();
 
-	  if (! error_state)
-	    have_sigma = true;
-	  else
-	    {
-	      error ("eigs: sigma must be a scalar or a string");
-	      return retval;
-	    }
-	}
+          if (! error_state)
+            have_sigma = true;
+          else
+            {
+              error ("eigs: sigma must be a scalar or a string");
+              return retval;
+            }
+        }
     }
 
   sigmar = std::real (sigma);
   sigmai = std::imag (sigma);
 
   if (!error_state && nargin > (3+arg_offset))
     {
       if (args(3+arg_offset).is_map ())
-	{
-	  Octave_map map = args(3+arg_offset).map_value ();
+        {
+          Octave_map map = args(3+arg_offset).map_value ();
 
-	  // issym is ignored if A is not a function
-	  if (map.contains ("issym") && have_a_fun)
-	      symmetric = map.contents ("issym")(0).double_value () != 0.;
+          // issym is ignored if A is not a function
+          if (map.contains ("issym") && have_a_fun)
+              symmetric = map.contents ("issym")(0).double_value () != 0.;
 
-	  // isreal is ignored if A is not a function
-	  if (map.contains ("isreal") && have_a_fun)
-	      a_is_complex = ! (map.contents ("isreal")(0).double_value () != 0.);
+          // isreal is ignored if A is not a function
+          if (map.contains ("isreal") && have_a_fun)
+              a_is_complex = ! (map.contents ("isreal")(0).double_value () != 0.);
 
-	  if (map.contains ("tol"))
-	    tol = map.contents ("tol")(0).double_value ();
+          if (map.contains ("tol"))
+            tol = map.contents ("tol")(0).double_value ();
 
-	  if (map.contains ("maxit"))
-	    maxit = map.contents ("maxit")(0).nint_value ();
+          if (map.contains ("maxit"))
+            maxit = map.contents ("maxit")(0).nint_value ();
 
-	  if (map.contains ("p"))
-	    p = map.contents ("p")(0).nint_value ();
+          if (map.contains ("p"))
+            p = map.contents ("p")(0).nint_value ();
 
-	  if (map.contains ("v0"))
-	    {
-	      if (a_is_complex || b_is_complex)
-		cresid = ComplexColumnVector 
-		  (map.contents ("v0")(0).complex_vector_value());
-	      else
-		resid = ColumnVector (map.contents ("v0")(0).vector_value());
-	    }
+          if (map.contains ("v0"))
+            {
+              if (a_is_complex || b_is_complex)
+                cresid = ComplexColumnVector 
+                  (map.contents ("v0")(0).complex_vector_value());
+              else
+                resid = ColumnVector (map.contents ("v0")(0).vector_value());
+            }
 
-	  if (map.contains ("disp"))
-	    disp = map.contents ("disp")(0).nint_value ();
+          if (map.contains ("disp"))
+            disp = map.contents ("disp")(0).nint_value ();
 
-	  if (map.contains ("cholB"))
-	    cholB = map.contents ("cholB")(0).double_value () != 0.;
+          if (map.contains ("cholB"))
+            cholB = map.contents ("cholB")(0).double_value () != 0.;
 
-	  if (map.contains ("permB"))
-	    permB = ColumnVector (map.contents ("permB")(0).vector_value ()) 
-	      - 1.0;
-	}
+          if (map.contains ("permB"))
+            permB = ColumnVector (map.contents ("permB")(0).vector_value ()) 
+              - 1.0;
+        }
       else
-	{
-	  error ("eigs: options argument must be a structure");
-	  return retval;
-	}
+        {
+          error ("eigs: options argument must be a structure");
+          return retval;
+        }
     }
 
   if (nargin > (4+arg_offset))
     {
       error ("eigs: incorrect number of arguments");
       return retval;
     }
 
   if (have_b)
     {
       if (a_is_complex || b_is_complex)
-	{
-	  if (a_is_sparse)
-	    bscm = args(b_arg).sparse_complex_matrix_value ();
-	  else
-	    bcm = args(b_arg).complex_matrix_value ();
-	}
+        {
+          if (a_is_sparse)
+            bscm = args(b_arg).sparse_complex_matrix_value ();
+          else
+            bcm = args(b_arg).complex_matrix_value ();
+        }
       else
-	{
-	  if (a_is_sparse)
-	    bsmm = args(b_arg).sparse_matrix_value ();
-	  else
-	    bmm = args(b_arg).matrix_value ();
-	}
+        {
+          if (a_is_sparse)
+            bsmm = args(b_arg).sparse_matrix_value ();
+          else
+            bmm = args(b_arg).matrix_value ();
+        }
     }
 
   // Mode 1 for SM mode seems unstable for some reason. 
   // Use Mode 3 instead, with sigma = 0.
   if (!error_state && !have_sigma && typ == "SM")
     have_sigma = true;
 
   if (!error_state)
     {
       octave_idx_type nconv;
       if (a_is_complex || b_is_complex)
-	{
-	  ComplexMatrix eig_vec;
-	  ComplexColumnVector eig_val;
+        {
+          ComplexMatrix eig_vec;
+          ComplexColumnVector eig_val;
 
 
-	  if (have_a_fun)
-	    nconv = EigsComplexNonSymmetricFunc 
-	      (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec, eig_val,
-	       cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	  else if (have_sigma)
-	    {
-	      if (a_is_sparse)
-		nconv = EigsComplexNonSymmetricMatrixShift
-		  (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
-		   cresid, octave_stdout, tol, (nargout > 1), cholB, disp, 
-		   maxit);
-	      else
-		nconv = EigsComplexNonSymmetricMatrixShift
-		  (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
-		   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	    }
-	  else
-	    {
-	      if (a_is_sparse)
-		nconv = EigsComplexNonSymmetricMatrix
-		  (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB, cresid,
-		   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	      else
-		nconv = EigsComplexNonSymmetricMatrix
-		  (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
-		   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	    }
+          if (have_a_fun)
+            nconv = EigsComplexNonSymmetricFunc 
+              (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec, eig_val,
+               cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+          else if (have_sigma)
+            {
+              if (a_is_sparse)
+                nconv = EigsComplexNonSymmetricMatrixShift
+                  (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
+                   cresid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                   maxit);
+              else
+                nconv = EigsComplexNonSymmetricMatrixShift
+                  (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
+                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+            }
+          else
+            {
+              if (a_is_sparse)
+                nconv = EigsComplexNonSymmetricMatrix
+                  (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB, cresid,
+                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+              else
+                nconv = EigsComplexNonSymmetricMatrix
+                  (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
+                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+            }
 
-	  if (nargout < 2)
-	    retval (0) = eig_val;
-	  else
-	    {
-	      retval(2) = double (info);
-	      retval(1) = ComplexDiagMatrix (eig_val);
-	      retval(0) = eig_vec;
-	    }
-	}
+          if (nargout < 2)
+            retval (0) = eig_val;
+          else
+            {
+              retval(2) = double (info);
+              retval(1) = ComplexDiagMatrix (eig_val);
+              retval(0) = eig_vec;
+            }
+        }
       else if (sigmai != 0.)
-	{
-	  // Promote real problem to a complex one.
-	  ComplexMatrix eig_vec;
-	  ComplexColumnVector eig_val;
+        {
+          // Promote real problem to a complex one.
+          ComplexMatrix eig_vec;
+          ComplexColumnVector eig_val;
 
-	  if (have_a_fun)
-	    nconv = EigsComplexNonSymmetricFunc 
-	      (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec, eig_val,
-	       cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	  else
-	    {
-	      if (a_is_sparse)
-		nconv = EigsComplexNonSymmetricMatrixShift 
-		  (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
-		   eig_val, SparseComplexMatrix (bsmm), permB, cresid,
-		   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	      else
-		nconv = EigsComplexNonSymmetricMatrixShift 
-		  (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
-		   eig_val, ComplexMatrix (bmm), permB, cresid,
-		   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
-	    }
+          if (have_a_fun)
+            nconv = EigsComplexNonSymmetricFunc 
+              (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec, eig_val,
+               cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+          else
+            {
+              if (a_is_sparse)
+                nconv = EigsComplexNonSymmetricMatrixShift 
+                  (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
+                   eig_val, SparseComplexMatrix (bsmm), permB, cresid,
+                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+              else
+                nconv = EigsComplexNonSymmetricMatrixShift 
+                  (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
+                   eig_val, ComplexMatrix (bmm), permB, cresid,
+                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+            }
 
-	  if (nargout < 2)
-	    retval (0) = eig_val;
-	  else
-	    {
-	      retval(2) = double (info);
-	      retval(1) = ComplexDiagMatrix (eig_val);
-	      retval(0) = eig_vec;
-	    }
-	}
+          if (nargout < 2)
+            retval (0) = eig_val;
+          else
+            {
+              retval(2) = double (info);
+              retval(1) = ComplexDiagMatrix (eig_val);
+              retval(0) = eig_vec;
+            }
+        }
       else
-	{
-	  if (symmetric)
-	    {
-	      Matrix eig_vec;
-	      ColumnVector eig_val;
+        {
+          if (symmetric)
+            {
+              Matrix eig_vec;
+              ColumnVector eig_val;
 
-	      if (have_a_fun)
-		nconv = EigsRealSymmetricFunc 
-		  (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
-		   resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
-		   maxit);
-	      else if (have_sigma)
-		{
-		  if (a_is_sparse)
-		    nconv = EigsRealSymmetricMatrixShift 
-		      (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
-		       maxit);
-		  else
-		    nconv = EigsRealSymmetricMatrixShift 
-		      (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-		       maxit);
-		}
-	      else
-		{
-		  if (a_is_sparse)
-		    nconv = EigsRealSymmetricMatrix 
-		      (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-		       maxit);
-		  else
-		    nconv = EigsRealSymmetricMatrix 
-		      (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-		       maxit);
-		}
+              if (have_a_fun)
+                nconv = EigsRealSymmetricFunc 
+                  (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
+                   resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                   maxit);
+              else if (have_sigma)
+                {
+                  if (a_is_sparse)
+                    nconv = EigsRealSymmetricMatrixShift 
+                      (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                       maxit);
+                  else
+                    nconv = EigsRealSymmetricMatrixShift 
+                      (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                       maxit);
+                }
+              else
+                {
+                  if (a_is_sparse)
+                    nconv = EigsRealSymmetricMatrix 
+                      (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                       maxit);
+                  else
+                    nconv = EigsRealSymmetricMatrix 
+                      (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                       maxit);
+                }
 
-	      if (nargout < 2)
-		retval (0) = eig_val;
-	      else
-		{
-		  retval(2) = double (info);
-		  retval(1) = DiagMatrix (eig_val);
-		  retval(0) = eig_vec;
-		}
-	    }
-	  else
-	    {
-	      ComplexMatrix eig_vec;
-	      ComplexColumnVector eig_val;
+              if (nargout < 2)
+                retval (0) = eig_val;
+              else
+                {
+                  retval(2) = double (info);
+                  retval(1) = DiagMatrix (eig_val);
+                  retval(0) = eig_vec;
+                }
+            }
+          else
+            {
+              ComplexMatrix eig_vec;
+              ComplexColumnVector eig_val;
 
-	      if (have_a_fun)
-		nconv = EigsRealNonSymmetricFunc 
-		  (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
-		   resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
-		   maxit);
-	      else if (have_sigma)
-		{
-		  if (a_is_sparse)
-		    nconv = EigsRealNonSymmetricMatrixShift 
-		      (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
-		       maxit);
-		  else
-		    nconv = EigsRealNonSymmetricMatrixShift 
-		      (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-		       maxit);
-		}
-	      else
-		{
-		  if (a_is_sparse)
-		    nconv = EigsRealNonSymmetricMatrix 
-		      (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-		       maxit);
-		  else
-		    nconv = EigsRealNonSymmetricMatrix 
-		      (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-		       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-		       maxit);
-		}
+              if (have_a_fun)
+                nconv = EigsRealNonSymmetricFunc 
+                  (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
+                   resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                   maxit);
+              else if (have_sigma)
+                {
+                  if (a_is_sparse)
+                    nconv = EigsRealNonSymmetricMatrixShift 
+                      (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                       maxit);
+                  else
+                    nconv = EigsRealNonSymmetricMatrixShift 
+                      (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                       maxit);
+                }
+              else
+                {
+                  if (a_is_sparse)
+                    nconv = EigsRealNonSymmetricMatrix 
+                      (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                       maxit);
+                  else
+                    nconv = EigsRealNonSymmetricMatrix 
+                      (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                       maxit);
+                }
 
-	      if (nargout < 2)
-		retval (0) = eig_val;
-	      else
-		{
-		  retval(2) = double (info);
-		  retval(1) = ComplexDiagMatrix (eig_val);
-		  retval(0) = eig_vec;
-		}
-	    }
-	}
+              if (nargout < 2)
+                retval (0) = eig_val;
+              else
+                {
+                  retval(2) = double (info);
+                  retval(1) = ComplexDiagMatrix (eig_val);
+                  retval(0) = eig_vec;
+                }
+            }
+        }
 
       if (nconv <= 0)
-	warning ("eigs: None of the %d requested eigenvalues converged", k);
+        warning ("eigs: None of the %d requested eigenvalues converged", k);
       else if (nconv < k)
-	warning ("eigs: Only %d of the %d requested eigenvalues converged", 
-		 nconv, k);
+        warning ("eigs: Only %d of the %d requested eigenvalues converged", 
+                 nconv, k);
     }
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 #else
   error ("eigs: not available in this version of Octave");
 #endif
 
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -55,127 +55,127 @@ do_fft (const octave_value_list &args, c
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_points = -1;
   int dim = -1;
   
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
-	{
-	  double dval = args(1).double_value ();
-	  if (xisnan (dval))
-	    error ("%s: NaN is invalid as the N_POINTS", fcn);
-	  else
-	    {
-	      n_points = NINTbig (dval);
-	      if (n_points < 0)
-		error ("%s: number of points must be greater than zero", fcn);
-	    }
-	}
+        {
+          double dval = args(1).double_value ();
+          if (xisnan (dval))
+            error ("%s: NaN is invalid as the N_POINTS", fcn);
+          else
+            {
+              n_points = NINTbig (dval);
+              if (n_points < 0)
+                error ("%s: number of points must be greater than zero", fcn);
+            }
+        }
     }
 
   if (error_state)
     return retval;
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
-	error ("%s: NaN is invalid as the N_POINTS", fcn);
+        error ("%s: NaN is invalid as the N_POINTS", fcn);
       else if (dval < 1 || dval > dims.length ())
-	error ("%s: invalid dimension along which to perform fft", fcn);
+        error ("%s: invalid dimension along which to perform fft", fcn);
       else
-	// to be safe, cast it back to int since dim is an int
-	dim = NINT (dval) - 1;
+        // to be safe, cast it back to int since dim is an int
+        dim = NINT (dval) - 1;
     }
 
   if (error_state)
     return retval;
 
   for (octave_idx_type i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (dim < 0)
     {
       for (octave_idx_type i = 0; i < dims.length (); i++)
-	if (dims(i) > 1)
-	  {
-	    dim = i;
-	    break;
-	  }
+        if (dims(i) > 1)
+          {
+            dim = i;
+            break;
+          }
 
       // And if the first argument is scalar?
       if (dim < 0)
-	dim = 1;
+        dim = 1;
     }
 
   if (n_points < 0)
     n_points = dims (dim);
   else
     dims (dim) = n_points;
 
   if (dims.any_zero () || n_points == 0)
     {
       if (arg.is_single_type ())
-	return octave_value (FloatNDArray (dims));
+        return octave_value (FloatNDArray (dims));
       else
-	return octave_value (NDArray (dims));
+        return octave_value (NDArray (dims));
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
-	{
-	  FloatNDArray nda = arg.float_array_value ();
+        {
+          FloatNDArray nda = arg.float_array_value ();
 
-	  if (! error_state)
-	    {
-	      nda.resize (dims, 0.0);
-	      retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
-	    }
-	}
+          if (! error_state)
+            {
+              nda.resize (dims, 0.0);
+              retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
+            }
+        }
       else
-	{
-	  FloatComplexNDArray cnda = arg.float_complex_array_value ();
+        {
+          FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-	  if (! error_state)
-	    {
-	      cnda.resize (dims, 0.0);
-	      retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
-	    }
-	}
+          if (! error_state)
+            {
+              cnda.resize (dims, 0.0);
+              retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  NDArray nda = arg.array_value ();
+        {
+          NDArray nda = arg.array_value ();
 
-	  if (! error_state)
-	    {
-	      nda.resize (dims, 0.0);
-	      retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
-	    }
-	}
+          if (! error_state)
+            {
+              nda.resize (dims, 0.0);
+              retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  ComplexNDArray cnda = arg.complex_array_value ();
+        {
+          ComplexNDArray cnda = arg.complex_array_value ();
 
-	  if (! error_state)
-	    {
-	      cnda.resize (dims, 0.0);
-	      retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
-	    }
-	}
+          if (! error_state)
+            {
+              cnda.resize (dims, 0.0);
+              retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
+            }
+        }
       else
-	{
-	  gripe_wrong_type_arg (fcn, arg);
-	}
+        {
+          gripe_wrong_type_arg (fcn, arg);
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!error(fft())
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -58,40 +58,40 @@ do_fft2 (const octave_value_list &args, 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
   
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
-	error ("%s: NaN is invalid as the N_ROWS", fcn);
+        error ("%s: NaN is invalid as the N_ROWS", fcn);
       else
-	{
-	  n_rows = NINTbig (dval);
-	  if (n_rows < 0)
-	    error ("%s: number of rows must be greater than zero", fcn);
-	}
+        {
+          n_rows = NINTbig (dval);
+          if (n_rows < 0)
+            error ("%s: number of rows must be greater than zero", fcn);
+        }
     }
 
   if (error_state)
     return retval;
 
   octave_idx_type n_cols = -1;
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
-	error ("%s: NaN is invalid as the N_COLS", fcn);
+        error ("%s: NaN is invalid as the N_COLS", fcn);
       else
-	{
-	  n_cols = NINTbig (dval);
-	  if (n_cols < 0)
-	    error ("%s: number of columns must be greater than zero", fcn);
-	}
+        {
+          n_cols = NINTbig (dval);
+          if (n_cols < 0)
+            error ("%s: number of columns must be greater than zero", fcn);
+        }
     }
 
   if (error_state)
     return retval;
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
@@ -104,70 +104,70 @@ do_fft2 (const octave_value_list &args, 
   if (n_cols < 0)
     n_cols = dims (1);
   else
     dims (1) = n_cols;
 
   if (dims.all_zero () || n_rows == 0 || n_cols == 0)
     {
       if (arg.is_single_type ())
-	return octave_value (FloatMatrix ());
+        return octave_value (FloatMatrix ());
       else
-	return octave_value (Matrix ());
+        return octave_value (Matrix ());
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
-	{
-	  FloatNDArray nda = arg.float_array_value ();
+        {
+          FloatNDArray nda = arg.float_array_value ();
 
-	  if (! error_state)
-	    {
-	      nda.resize (dims, 0.0);
-	      retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
-	    }
-	}
+          if (! error_state)
+            {
+              nda.resize (dims, 0.0);
+              retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
+            }
+        }
       else
-	{
-	  FloatComplexNDArray cnda = arg.float_complex_array_value ();
+        {
+          FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-	  if (! error_state)
-	    {
-	      cnda.resize (dims, 0.0);
-	      retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
-	    }
-	}
+          if (! error_state)
+            {
+              cnda.resize (dims, 0.0);
+              retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  NDArray nda = arg.array_value ();
+        {
+          NDArray nda = arg.array_value ();
 
-	  if (! error_state)
-	    {
-	      nda.resize (dims, 0.0);
-	      retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
-	    }
-	}
+          if (! error_state)
+            {
+              nda.resize (dims, 0.0);
+              retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  ComplexNDArray cnda = arg.complex_array_value ();
+        {
+          ComplexNDArray cnda = arg.complex_array_value ();
 
-	  if (! error_state)
-	    {
-	      cnda.resize (dims, 0.0);
-	      retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
-	    }
-	}
+          if (! error_state)
+            {
+              cnda.resize (dims, 0.0);
+              retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
+            }
+        }
       else
-	{
-	  gripe_wrong_type_arg (fcn, arg);
-	}
+        {
+          gripe_wrong_type_arg (fcn, arg);
+        }
     }
 
   return retval;
 }
 
 DEFUN_DLD (fft2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fft2 (@var{a}, @var{n}, @var{m})\n\
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -59,96 +59,96 @@ do_fftn (const octave_value_list &args, 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (nargin > 1)
     {
       Matrix val = args(1).matrix_value ();
       if (val.rows () > val.columns ())
-	val = val.transpose ();
+        val = val.transpose ();
 
       if (error_state || val.columns () != dims.length () || val.rows () != 1)
-	error ("%s: second argument must be a vector of length dim", fcn);
+        error ("%s: second argument must be a vector of length dim", fcn);
       else
-	{
-	  for (int i = 0; i < dims.length (); i++)
-	    {
-	      if (xisnan (val(i,0)))
-		error ("%s: NaN is invalid as a dimension", fcn);
-	      else if (NINTbig (val(i,0)) < 0)
-		error ("%s: all dimension must be greater than zero", fcn);
-	      else
-		{
-		  dims(i) = NINTbig(val(i,0));
-		}
-	    }
-	}
+        {
+          for (int i = 0; i < dims.length (); i++)
+            {
+              if (xisnan (val(i,0)))
+                error ("%s: NaN is invalid as a dimension", fcn);
+              else if (NINTbig (val(i,0)) < 0)
+                error ("%s: all dimension must be greater than zero", fcn);
+              else
+                {
+                  dims(i) = NINTbig(val(i,0));
+                }
+            }
+        }
     }
 
   if (error_state)
     return retval;
 
   if (dims.all_zero ())
     {
       if (arg.is_single_type ())
-	return octave_value (FloatMatrix ());
+        return octave_value (FloatMatrix ());
       else
-	return octave_value (Matrix ());
+        return octave_value (Matrix ());
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
-	{
-	  FloatNDArray nda = arg.float_array_value ();
+        {
+          FloatNDArray nda = arg.float_array_value ();
 
-	  if (! error_state)
-	    {
-	      nda.resize (dims, 0.0);
-	      retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
-	    }
-	}
+          if (! error_state)
+            {
+              nda.resize (dims, 0.0);
+              retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
+            }
+        }
       else
-	{
-	  FloatComplexNDArray cnda = arg.float_complex_array_value ();
+        {
+          FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-	  if (! error_state)
-	    {
-	      cnda.resize (dims, 0.0);
-	      retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
-	    }
-	}
+          if (! error_state)
+            {
+              cnda.resize (dims, 0.0);
+              retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  NDArray nda = arg.array_value ();
+        {
+          NDArray nda = arg.array_value ();
 
-	  if (! error_state)
-	    {
-	      nda.resize (dims, 0.0);
-	      retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
-	    }
-	}
+          if (! error_state)
+            {
+              nda.resize (dims, 0.0);
+              retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  ComplexNDArray cnda = arg.complex_array_value ();
+        {
+          ComplexNDArray cnda = arg.complex_array_value ();
 
-	  if (! error_state)
-	    {
-	      cnda.resize (dims, 0.0);
-	      retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
-	    }
-	}
+          if (! error_state)
+            {
+              cnda.resize (dims, 0.0);
+              retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
+            }
+        }
       else
-	{
-	  gripe_wrong_type_arg (fcn, arg);
-	}
+        {
+          gripe_wrong_type_arg (fcn, arg);
+        }
     }
 
   return retval;
 }
 
 DEFUN_DLD (fftn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fftn (@var{a}, @var{size})\n\
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -122,145 +122,145 @@ they will not be efficient and the point
     }
 
 #if defined (HAVE_FFTW)
   if (args(0).is_string ())
     {
       std::string arg0 = args(0).string_value ();
 
       if (!error_state)
-	{
-	  // Use STL function to convert to lower case
-	  std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
-	  
-	  if (nargin == 2)
-	    {
-	      std::string arg1 = args(1).string_value ();
-	      if (!error_state)
-		{
-		  if (arg0 == "planner")
-		    {
-		      std::transform (arg1.begin (), arg1.end (), 
-				      arg1.begin (), tolower);
-		      octave_fftw_planner::FftwMethod meth
-			= octave_fftw_planner::UNKNOWN;
-		      octave_float_fftw_planner::FftwMethod methf
-			= octave_float_fftw_planner::UNKNOWN;
+        {
+          // Use STL function to convert to lower case
+          std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+          
+          if (nargin == 2)
+            {
+              std::string arg1 = args(1).string_value ();
+              if (!error_state)
+                {
+                  if (arg0 == "planner")
+                    {
+                      std::transform (arg1.begin (), arg1.end (), 
+                                      arg1.begin (), tolower);
+                      octave_fftw_planner::FftwMethod meth
+                        = octave_fftw_planner::UNKNOWN;
+                      octave_float_fftw_planner::FftwMethod methf
+                        = octave_float_fftw_planner::UNKNOWN;
 
-		      if (arg1 == "estimate")
-			{
-			  meth = octave_fftw_planner::ESTIMATE;
-			  methf = octave_float_fftw_planner::ESTIMATE;
-			}
-		      else if (arg1 == "measure")
-			{
-			  meth = octave_fftw_planner::MEASURE;
-			  methf = octave_float_fftw_planner::MEASURE;
-			}
-		      else if (arg1 == "patient")
-			{
-			  meth = octave_fftw_planner::PATIENT;
-			  methf = octave_float_fftw_planner::PATIENT;
-			}
-		      else if (arg1 == "exhaustive")
-			{
-			  meth = octave_fftw_planner::EXHAUSTIVE;
-			  methf = octave_float_fftw_planner::EXHAUSTIVE;
-			}
-		      else if (arg1 == "hybrid")
-			{
-			  meth = octave_fftw_planner::HYBRID;
-			  methf = octave_float_fftw_planner::HYBRID;
-			}
-		      else
-			error ("unrecognized planner method");
+                      if (arg1 == "estimate")
+                        {
+                          meth = octave_fftw_planner::ESTIMATE;
+                          methf = octave_float_fftw_planner::ESTIMATE;
+                        }
+                      else if (arg1 == "measure")
+                        {
+                          meth = octave_fftw_planner::MEASURE;
+                          methf = octave_float_fftw_planner::MEASURE;
+                        }
+                      else if (arg1 == "patient")
+                        {
+                          meth = octave_fftw_planner::PATIENT;
+                          methf = octave_float_fftw_planner::PATIENT;
+                        }
+                      else if (arg1 == "exhaustive")
+                        {
+                          meth = octave_fftw_planner::EXHAUSTIVE;
+                          methf = octave_float_fftw_planner::EXHAUSTIVE;
+                        }
+                      else if (arg1 == "hybrid")
+                        {
+                          meth = octave_fftw_planner::HYBRID;
+                          methf = octave_float_fftw_planner::HYBRID;
+                        }
+                      else
+                        error ("unrecognized planner method");
 
-		      if (!error_state)
-			{
-			  meth = octave_fftw_planner::method (meth);
-			  octave_float_fftw_planner::method (methf);
+                      if (!error_state)
+                        {
+                          meth = octave_fftw_planner::method (meth);
+                          octave_float_fftw_planner::method (methf);
 
-			  if (meth == octave_fftw_planner::MEASURE)
-			    retval = octave_value ("measure");
-			  else if (meth == octave_fftw_planner::PATIENT)
-			    retval = octave_value ("patient");
-			  else if (meth == octave_fftw_planner::EXHAUSTIVE)
-			    retval = octave_value ("exhaustive");
-			  else if (meth == octave_fftw_planner::HYBRID)
-			    retval = octave_value ("hybrid");
-			  else
-			    retval = octave_value ("estimate");
-			}
-		    }
-		  else if (arg0 == "dwisdom")
-		    {
-		      char *str = fftw_export_wisdom_to_string ();
+                          if (meth == octave_fftw_planner::MEASURE)
+                            retval = octave_value ("measure");
+                          else if (meth == octave_fftw_planner::PATIENT)
+                            retval = octave_value ("patient");
+                          else if (meth == octave_fftw_planner::EXHAUSTIVE)
+                            retval = octave_value ("exhaustive");
+                          else if (meth == octave_fftw_planner::HYBRID)
+                            retval = octave_value ("hybrid");
+                          else
+                            retval = octave_value ("estimate");
+                        }
+                    }
+                  else if (arg0 == "dwisdom")
+                    {
+                      char *str = fftw_export_wisdom_to_string ();
 
-		      if (arg1.length() < 1)
-			fftw_forget_wisdom ();
-		      else if (! fftw_import_wisdom_from_string (arg1.c_str()))
-			error ("could not import supplied wisdom");
+                      if (arg1.length() < 1)
+                        fftw_forget_wisdom ();
+                      else if (! fftw_import_wisdom_from_string (arg1.c_str()))
+                        error ("could not import supplied wisdom");
 
-		      if (!error_state)
-			retval = octave_value (std::string (str));
+                      if (!error_state)
+                        retval = octave_value (std::string (str));
 
-		      free (str);
-		    }
-		  else if (arg0 == "swisdom")
-		    {
-		      char *str = fftwf_export_wisdom_to_string ();
+                      free (str);
+                    }
+                  else if (arg0 == "swisdom")
+                    {
+                      char *str = fftwf_export_wisdom_to_string ();
 
-		      if (arg1.length() < 1)
-			fftwf_forget_wisdom ();
-		      else if (! fftwf_import_wisdom_from_string (arg1.c_str()))
-			error ("could not import supplied wisdom");
+                      if (arg1.length() < 1)
+                        fftwf_forget_wisdom ();
+                      else if (! fftwf_import_wisdom_from_string (arg1.c_str()))
+                        error ("could not import supplied wisdom");
 
-		      if (!error_state)
-			retval = octave_value (std::string (str));
+                      if (!error_state)
+                        retval = octave_value (std::string (str));
 
-		      free (str);
-		    }
-		  else
-		    error ("unrecognized argument");
-		}
-	    }
-	  else
-	    {
-	      if (arg0 == "planner")
-		{
-		  octave_fftw_planner::FftwMethod meth = 
-		    octave_fftw_planner::method ();
+                      free (str);
+                    }
+                  else
+                    error ("unrecognized argument");
+                }
+            }
+          else
+            {
+              if (arg0 == "planner")
+                {
+                  octave_fftw_planner::FftwMethod meth = 
+                    octave_fftw_planner::method ();
 
-		  if (meth == octave_fftw_planner::MEASURE)
-		    retval = octave_value ("measure");
-		  else if (meth == octave_fftw_planner::PATIENT)
-		    retval = octave_value ("patient");
-		  else if (meth == octave_fftw_planner::EXHAUSTIVE)
-		    retval = octave_value ("exhaustive");
-		  else if (meth == octave_fftw_planner::HYBRID)
-		    retval = octave_value ("hybrid");
-		  else
-		    retval = octave_value ("estimate");
-		}
-	      else if (arg0 == "dwisdom")
-		{
-		  char *str = fftw_export_wisdom_to_string ();
-		  retval = octave_value (std::string (str));
-		  free (str);
-		}
-	      else if (arg0 == "swisdom")
-		{
-		  char *str = fftwf_export_wisdom_to_string ();
-		  retval = octave_value (std::string (str));
-		  free (str);
-		}
-	      else
-		error ("unrecognized argument");
-	    }
-	}
+                  if (meth == octave_fftw_planner::MEASURE)
+                    retval = octave_value ("measure");
+                  else if (meth == octave_fftw_planner::PATIENT)
+                    retval = octave_value ("patient");
+                  else if (meth == octave_fftw_planner::EXHAUSTIVE)
+                    retval = octave_value ("exhaustive");
+                  else if (meth == octave_fftw_planner::HYBRID)
+                    retval = octave_value ("hybrid");
+                  else
+                    retval = octave_value ("estimate");
+                }
+              else if (arg0 == "dwisdom")
+                {
+                  char *str = fftw_export_wisdom_to_string ();
+                  retval = octave_value (std::string (str));
+                  free (str);
+                }
+              else if (arg0 == "swisdom")
+                {
+                  char *str = fftwf_export_wisdom_to_string ();
+                  retval = octave_value (std::string (str));
+                  free (str);
+                }
+              else
+                error ("unrecognized argument");
+            }
+        }
     }
 #else
 
   warning ("fftw: this copy of Octave was not configured to use the FFTW3 planner");
 
 #endif
 
   return retval;
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -51,17 +51,17 @@ filter (MArray<float>&, MArray<float>&, 
 
 extern MArrayN<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&, int dim);
 #endif
 
 template <class T>
 MArrayN<T>
 filter (MArray<T>& b, MArray<T>& a, MArrayN<T>& x, MArrayN<T>& si, 
-	int dim = 0)
+        int dim = 0)
 {
   MArrayN<T> y;
 
   octave_idx_type a_len  = a.length ();
   octave_idx_type b_len  = b.length ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
@@ -100,26 +100,26 @@ filter (MArray<T>& b, MArray<T>& a, MArr
       error ("filter: dimensionality of si and x must agree");
       return y;
     }
 
   octave_idx_type si_dim = 0;
   for (octave_idx_type i = 0; i < x_dims.length (); i++)
     {
       if (i == dim)
-	continue;
+        continue;
      
       if (x_dims(i) == 1)
-	continue;
+        continue;
  
       if (si_dims(++si_dim) != x_dims(i))
-	{
-	  error ("filter: dimensionality of si and x must agree");
-	  return y;
-	}
+        {
+          error ("filter: dimensionality of si and x must agree");
+          return y;
+        }
     }
 
   if (norm != static_cast<T>(1.0))
     {
       a = a / norm;
       b = b / norm;
     }
 
@@ -132,141 +132,141 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   for (int i = 0; i < dim; i++)
     x_stride *= x_dims(i);
 
   octave_idx_type x_num = x_dims.numel () / x_len;
   for (octave_idx_type num = 0; num < x_num; num++)
     {
       octave_idx_type x_offset;
       if (x_stride == 1)
-	x_offset = num * x_len;
+        x_offset = num * x_len;
       else
-	{
-	  octave_idx_type x_offset2 = 0;
-	  x_offset = num;
-	  while (x_offset >= x_stride)
-	    {
-	      x_offset -= x_stride;
-	      x_offset2++;
-	    }
-	  x_offset += x_offset2 * x_stride * x_len;
-	}
+        {
+          octave_idx_type x_offset2 = 0;
+          x_offset = num;
+          while (x_offset >= x_stride)
+            {
+              x_offset -= x_stride;
+              x_offset2++;
+            }
+          x_offset += x_offset2 * x_stride * x_len;
+        }
       octave_idx_type si_offset = num * si_len;
 
       if (a_len > 1)
-	{
-	  T *py = y.fortran_vec ();
-	  T *psi = si.fortran_vec ();
+        {
+          T *py = y.fortran_vec ();
+          T *psi = si.fortran_vec ();
 
-	  const T *pa = a.data ();
-	  const T *pb = b.data ();
-	  const T *px = x.data ();
+          const T *pa = a.data ();
+          const T *pb = b.data ();
+          const T *px = x.data ();
 
-	  psi += si_offset;
+          psi += si_offset;
 
-	  for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
-	    {
-	      py[idx] = psi[0] + pb[0] * px[idx];
+          for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
+            {
+              py[idx] = psi[0] + pb[0] * px[idx];
 
-	      if (si_len > 0)
-		{
-		  for (octave_idx_type j = 0; j < si_len - 1; j++)
-		    {
-		      OCTAVE_QUIT;
+              if (si_len > 0)
+                {
+                  for (octave_idx_type j = 0; j < si_len - 1; j++)
+                    {
+                      OCTAVE_QUIT;
 
-		      psi[j] = psi[j+1] - pa[j+1] * py[idx] + pb[j+1] * px[idx];
-		    }
+                      psi[j] = psi[j+1] - pa[j+1] * py[idx] + pb[j+1] * px[idx];
+                    }
 
-		  psi[si_len-1] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
-		}
-	      else
-		{
-		  OCTAVE_QUIT;
+                  psi[si_len-1] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
+                }
+              else
+                {
+                  OCTAVE_QUIT;
 
-		  psi[0] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
-		}
-	    }
-	}
+                  psi[0] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
+                }
+            }
+        }
       else if (si_len > 0)
-	{
-	  T *py = y.fortran_vec ();
-	  T *psi = si.fortran_vec ();
+        {
+          T *py = y.fortran_vec ();
+          T *psi = si.fortran_vec ();
 
-	  const T *pb = b.data ();
-	  const T *px = x.data ();
+          const T *pb = b.data ();
+          const T *px = x.data ();
 
-	  psi += si_offset;
+          psi += si_offset;
 
-	  for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
-	    {
-	      py[idx] = psi[0] + pb[0] * px[idx];
+          for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
+            {
+              py[idx] = psi[0] + pb[0] * px[idx];
 
-	      if (si_len > 1)
-		{
-		  for (octave_idx_type j = 0; j < si_len - 1; j++)
-		    {
-		      OCTAVE_QUIT;
+              if (si_len > 1)
+                {
+                  for (octave_idx_type j = 0; j < si_len - 1; j++)
+                    {
+                      OCTAVE_QUIT;
 
-		      psi[j] = psi[j+1] + pb[j+1] * px[idx];
-		    }
+                      psi[j] = psi[j+1] + pb[j+1] * px[idx];
+                    }
 
-		  psi[si_len-1] = pb[si_len] * px[idx];
-		}
-	      else
-		{
-		  OCTAVE_QUIT;
+                  psi[si_len-1] = pb[si_len] * px[idx];
+                }
+              else
+                {
+                  OCTAVE_QUIT;
 
-		  psi[0] = pb[1] * px[idx];
-		}
-	    }
-	}
+                  psi[0] = pb[1] * px[idx];
+                }
+            }
+        }
     }
   
   return y;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern MArrayN<double>
 filter (MArray<double>&, MArray<double>&, MArrayN<double>&,
-	MArrayN<double>&, int dim);
+        MArrayN<double>&, int dim);
 
 extern MArrayN<Complex>
 filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&,
-	MArrayN<Complex>&, int dim);
+        MArrayN<Complex>&, int dim);
 
 extern MArrayN<float>
 filter (MArray<float>&, MArray<float>&, MArrayN<float>&,
-	MArrayN<float>&, int dim);
+        MArrayN<float>&, int dim);
 
 extern MArrayN<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&,
-	MArrayN<FloatComplex>&, int dim);
+        MArrayN<FloatComplex>&, int dim);
 #endif
 
 template <class T>
 MArrayN<T>
 filter (MArray<T>& b, MArray<T>& a, MArrayN<T>& x, int dim = -1)
 {
   dim_vector x_dims = x.dims();
 
   if (dim < 0)
     {
       // Find first non-singleton dimension
       while (dim < x_dims.length () && x_dims(dim) <= 1)
-	dim++;
+        dim++;
   
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
-	dim = 0;
+        dim = 0;
     }
   else
     if (dim < 0 || dim > x_dims.length ())
       {
-	error ("filter: filtering over invalid dimension");
-	return MArrayN<T> ();
+        error ("filter: filtering over invalid dimension");
+        return MArrayN<T> ();
       }
 
   octave_idx_type a_len = a.length ();
   octave_idx_type b_len = b.length ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
@@ -383,303 +383,303 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
       dim = args(4).nint_value() - 1;
       if (dim < 0 || dim >= x_dims.length ())
-	{
-	  error ("filter: filtering over invalid dimension");
-	  return retval;
-	}
+        {
+          error ("filter: filtering over invalid dimension");
+          return retval;
+        }
     }
   else
     {
       // Find first non-singleton dimension
       dim = 0;
       while (dim < x_dims.length () && x_dims(dim) <= 1)
-	dim++;
+        dim++;
   
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
-	dim = 0;
+        dim = 0;
     }
 
   bool isfloat = (args(0).is_single_type ()
-		  || args(1).is_single_type ()
-		  || args(2).is_single_type ()
-		  || (nargin >= 4 && args(3).is_single_type ()));
+                  || args(1).is_single_type ()
+                  || args(2).is_single_type ()
+                  || (nargin >= 4 && args(3).is_single_type ()));
     
   if (args(0).is_complex_type ()
       || args(1).is_complex_type ()
       || args(2).is_complex_type ()
       || (nargin >= 4 && args(3).is_complex_type ()))
     {
       if (isfloat)
-	{
-	  FloatComplexColumnVector b (args(0).float_complex_vector_value ());
-	  FloatComplexColumnVector a (args(1).float_complex_vector_value ());
+        {
+          FloatComplexColumnVector b (args(0).float_complex_vector_value ());
+          FloatComplexColumnVector a (args(1).float_complex_vector_value ());
 
-	  FloatComplexNDArray x (args(2).float_complex_array_value ());
+          FloatComplexNDArray x (args(2).float_complex_array_value ());
 
-	  if (! error_state)
-	    {
-	      FloatComplexNDArray si;
+          if (! error_state)
+            {
+              FloatComplexNDArray si;
 
-	      if (nargin == 3 || args(3).is_empty ())
-		{
-		  octave_idx_type a_len = a.length ();
-		  octave_idx_type b_len = b.length ();
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.length ();
+                  octave_idx_type b_len = b.length ();
 
-		  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-		  dim_vector si_dims = x.dims ();
-		  for (int i = dim; i > 0; i--)
-		    si_dims(i) = si_dims(i-1);
-		  si_dims(0) = si_len;
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-		  si.resize (si_dims, 0.0);
-		}
-	      else
-		{
-		  dim_vector si_dims = args (3).dims ();
-		  bool si_is_vector = true;
-		  for (int i = 0; i < si_dims.length (); i++)
-		    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-		      {
-			si_is_vector = false;
-			break;
-		      }
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  dim_vector si_dims = args (3).dims ();
+                  bool si_is_vector = true;
+                  for (int i = 0; i < si_dims.length (); i++)
+                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
+                      {
+                        si_is_vector = false;
+                        break;
+                      }
 
-		  si = args(3).float_complex_array_value ();
+                  si = args(3).float_complex_array_value ();
 
-		  if (si_is_vector)
-		    si = si.reshape (dim_vector (si.numel (), 1));
-		}
+                  if (si_is_vector)
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-	      if (! error_state)
-		{
-		  FloatComplexNDArray y (filter (b, a, x, si, dim));
+              if (! error_state)
+                {
+                  FloatComplexNDArray y (filter (b, a, x, si, dim));
 
-		  if (nargout == 2)
-		    retval(1) = si;
+                  if (nargout == 2)
+                    retval(1) = si;
 
-		  retval(0) = y;
-		}
-	      else
-		error (errmsg);
-	    }
-	  else
-	    error (errmsg);
-	}
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
+            }
+          else
+            error (errmsg);
+        }
       else
-	{
-	  ComplexColumnVector b (args(0).complex_vector_value ());
-	  ComplexColumnVector a (args(1).complex_vector_value ());
+        {
+          ComplexColumnVector b (args(0).complex_vector_value ());
+          ComplexColumnVector a (args(1).complex_vector_value ());
 
-	  ComplexNDArray x (args(2).complex_array_value ());
+          ComplexNDArray x (args(2).complex_array_value ());
 
-	  if (! error_state)
-	    {
-	      ComplexNDArray si;
+          if (! error_state)
+            {
+              ComplexNDArray si;
 
-	      if (nargin == 3 || args(3).is_empty ())
-		{
-		  octave_idx_type a_len = a.length ();
-		  octave_idx_type b_len = b.length ();
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.length ();
+                  octave_idx_type b_len = b.length ();
 
-		  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-		  dim_vector si_dims = x.dims ();
-		  for (int i = dim; i > 0; i--)
-		    si_dims(i) = si_dims(i-1);
-		  si_dims(0) = si_len;
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-		  si.resize (si_dims, 0.0);
-		}
-	      else
-		{
-		  dim_vector si_dims = args (3).dims ();
-		  bool si_is_vector = true;
-		  for (int i = 0; i < si_dims.length (); i++)
-		    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-		      {
-			si_is_vector = false;
-			break;
-		      }
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  dim_vector si_dims = args (3).dims ();
+                  bool si_is_vector = true;
+                  for (int i = 0; i < si_dims.length (); i++)
+                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
+                      {
+                        si_is_vector = false;
+                        break;
+                      }
 
-		  si = args(3).complex_array_value ();
+                  si = args(3).complex_array_value ();
 
-		  if (si_is_vector)
-		    si = si.reshape (dim_vector (si.numel (), 1));
-		}
+                  if (si_is_vector)
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-	      if (! error_state)
-		{
-		  ComplexNDArray y (filter (b, a, x, si, dim));
+              if (! error_state)
+                {
+                  ComplexNDArray y (filter (b, a, x, si, dim));
 
-		  if (nargout == 2)
-		    retval(1) = si;
+                  if (nargout == 2)
+                    retval(1) = si;
 
-		  retval(0) = y;
-		}
-	      else
-		error (errmsg);
-	    }
-	  else
-	    error (errmsg);
-	}
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
+            }
+          else
+            error (errmsg);
+        }
     }
   else
     {
       if (isfloat)
-	{
-	  FloatColumnVector b (args(0).float_vector_value ());
-	  FloatColumnVector a (args(1).float_vector_value ());
+        {
+          FloatColumnVector b (args(0).float_vector_value ());
+          FloatColumnVector a (args(1).float_vector_value ());
 
-	  FloatNDArray x (args(2).float_array_value ());
+          FloatNDArray x (args(2).float_array_value ());
 
-	  if (! error_state)
-	    {
-	      FloatNDArray si;
+          if (! error_state)
+            {
+              FloatNDArray si;
 
-	      if (nargin == 3 || args(3).is_empty ())
-		{
-		  octave_idx_type a_len = a.length ();
-		  octave_idx_type b_len = b.length ();
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.length ();
+                  octave_idx_type b_len = b.length ();
 
-		  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-		  dim_vector si_dims = x.dims ();
-		  for (int i = dim; i > 0; i--)
-		    si_dims(i) = si_dims(i-1);
-		  si_dims(0) = si_len;
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-		  si.resize (si_dims, 0.0);
-		}
-	      else
-		{
-		  dim_vector si_dims = args (3).dims ();
-		  bool si_is_vector = true;
-		  for (int i = 0; i < si_dims.length (); i++)
-		    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-		      {
-			si_is_vector = false;
-			break;
-		      }
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  dim_vector si_dims = args (3).dims ();
+                  bool si_is_vector = true;
+                  for (int i = 0; i < si_dims.length (); i++)
+                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
+                      {
+                        si_is_vector = false;
+                        break;
+                      }
 
-		  si = args(3).float_array_value ();
+                  si = args(3).float_array_value ();
 
-		  if (si_is_vector)
-		    si = si.reshape (dim_vector (si.numel (), 1));
-		}
+                  if (si_is_vector)
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-	      if (! error_state)
-		{
-		  FloatNDArray y (filter (b, a, x, si, dim));
+              if (! error_state)
+                {
+                  FloatNDArray y (filter (b, a, x, si, dim));
 
-		  if (nargout == 2)
-		    retval(1) = si;
+                  if (nargout == 2)
+                    retval(1) = si;
 
-		  retval(0) = y;
-		}
-	      else
-		error (errmsg);
-	    }
-	  else
-	    error (errmsg);
-	}
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
+            }
+          else
+            error (errmsg);
+        }
       else
-	{
-	  ColumnVector b (args(0).vector_value ());
-	  ColumnVector a (args(1).vector_value ());
+        {
+          ColumnVector b (args(0).vector_value ());
+          ColumnVector a (args(1).vector_value ());
 
-	  NDArray x (args(2).array_value ());
+          NDArray x (args(2).array_value ());
 
-	  if (! error_state)
-	    {
-	      NDArray si;
+          if (! error_state)
+            {
+              NDArray si;
 
-	      if (nargin == 3 || args(3).is_empty ())
-		{
-		  octave_idx_type a_len = a.length ();
-		  octave_idx_type b_len = b.length ();
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.length ();
+                  octave_idx_type b_len = b.length ();
 
-		  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
-		  dim_vector si_dims = x.dims ();
-		  for (int i = dim; i > 0; i--)
-		    si_dims(i) = si_dims(i-1);
-		  si_dims(0) = si_len;
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-		  si.resize (si_dims, 0.0);
-		}
-	      else
-		{
-		  dim_vector si_dims = args (3).dims ();
-		  bool si_is_vector = true;
-		  for (int i = 0; i < si_dims.length (); i++)
-		    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-		      {
-			si_is_vector = false;
-			break;
-		      }
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  dim_vector si_dims = args (3).dims ();
+                  bool si_is_vector = true;
+                  for (int i = 0; i < si_dims.length (); i++)
+                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
+                      {
+                        si_is_vector = false;
+                        break;
+                      }
 
-		  si = args(3).array_value ();
+                  si = args(3).array_value ();
 
-		  if (si_is_vector)
-		    si = si.reshape (dim_vector (si.numel (), 1));
-		}
+                  if (si_is_vector)
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-	      if (! error_state)
-		{
-		  NDArray y (filter (b, a, x, si, dim));
+              if (! error_state)
+                {
+                  NDArray y (filter (b, a, x, si, dim));
 
-		  if (nargout == 2)
-		    retval(1) = si;
+                  if (nargout == 2)
+                    retval(1) = si;
 
-		  retval(0) = y;
-		}
-	      else
-		error (errmsg);
-	    }
-	  else
-	    error (errmsg);
-	}
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
+            }
+          else
+            error (errmsg);
+        }
     }
 
   return retval;
 }
 
 template MArrayN<double>
 filter (MArray<double>&, MArray<double>&, MArrayN<double>&,
-	MArrayN<double>&, int dim);
+        MArrayN<double>&, int dim);
 
 template MArrayN<double>
 filter (MArray<double>&, MArray<double>&, MArrayN<double>&, int dim);
 
 template MArrayN<Complex>
 filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&,
-	MArrayN<Complex>&, int dim);
+        MArrayN<Complex>&, int dim);
 
 template MArrayN<Complex>
 filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&, int dim);
 
 template MArrayN<float>
 filter (MArray<float>&, MArray<float>&, MArrayN<float>&,
-	MArrayN<float>&, int dim);
+        MArrayN<float>&, int dim);
 
 template MArrayN<float>
 filter (MArray<float>&, MArray<float>&, MArrayN<float>&, int dim);
 
 template MArrayN<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&,
-	MArrayN<FloatComplex>&, int dim);
+        MArrayN<FloatComplex>&, int dim);
 
 template MArrayN<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&, int dim);
 
 /*
 %!shared a, b, x, r
 %!test
 %!  a = [1 1];
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 
 // Find at most N_TO_FIND nonzero elements in NDA.  Search forward if
 // DIRECTION is 1, backward if it is -1.  NARGOUT is the number of
 // output arguments.  If N_TO_FIND is -1, find all nonzero elements.
 
 template <typename T>
 octave_value_list
 find_nonzero_elem_idx (const Array<T>& nda, int nargout, 
-		       octave_idx_type n_to_find, int direction)
+                       octave_idx_type n_to_find, int direction)
 {
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
   Array<octave_idx_type> idx;
   if (n_to_find >= 0)
     idx = nda.find (n_to_find, direction == -1);
   else
     idx = nda.find ();
@@ -75,17 +75,17 @@ find_nonzero_elem_idx (const Array<T>& n
       break;
     }
 
   return retval;
 }
 
 #define INSTANTIATE_FIND_ARRAY(T) \
 template octave_value_list find_nonzero_elem_idx (const Array<T>&, int, \
-						  octave_idx_type, int)
+                                                  octave_idx_type, int)
 
 INSTANTIATE_FIND_ARRAY(double);
 INSTANTIATE_FIND_ARRAY(float);
 INSTANTIATE_FIND_ARRAY(Complex);
 INSTANTIATE_FIND_ARRAY(FloatComplex);
 INSTANTIATE_FIND_ARRAY(bool);
 INSTANTIATE_FIND_ARRAY(octave_int8);
 INSTANTIATE_FIND_ARRAY(octave_int16);
@@ -94,17 +94,17 @@ INSTANTIATE_FIND_ARRAY(octave_int64);
 INSTANTIATE_FIND_ARRAY(octave_uint8);
 INSTANTIATE_FIND_ARRAY(octave_uint16);
 INSTANTIATE_FIND_ARRAY(octave_uint32);
 INSTANTIATE_FIND_ARRAY(octave_uint64);
 
 template <typename T>
 octave_value_list
 find_nonzero_elem_idx (const Sparse<T>& v, int nargout, 
-		       octave_idx_type n_to_find, int direction)
+                       octave_idx_type n_to_find, int direction)
 {
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
 
   octave_idx_type nc = v.cols();
   octave_idx_type nr = v.rows();
   octave_idx_type nz = v.nnz();
 
@@ -119,44 +119,44 @@ find_nonzero_elem_idx (const Sparse<T>& 
       start_nc = 0;
       end_nc = nc;
       n_to_find = nz;
       count = nz;
     }
   else if (direction > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  OCTAVE_QUIT;
-	  if (v.cidx(j) == 0 && v.cidx(j+1) != 0)
-	    start_nc = j;
-	  if (v.cidx(j+1) >= n_to_find)
-	    {
-	      end_nc = j + 1;
-	      break;
-	    }
-	}
+        {
+          OCTAVE_QUIT;
+          if (v.cidx(j) == 0 && v.cidx(j+1) != 0)
+            start_nc = j;
+          if (v.cidx(j+1) >= n_to_find)
+            {
+              end_nc = j + 1;
+              break;
+            }
+        }
     }
   else
     {
       for (octave_idx_type j = nc; j > 0; j--)
-	{
-	  OCTAVE_QUIT;
-	  if (v.cidx(j) == nz && v.cidx(j-1) != nz)
-	    end_nc = j;
-	  if (nz - v.cidx(j-1) >= n_to_find)
-	    {
-	      start_nc = j - 1;
-	      break;
-	    }
-	}
+        {
+          OCTAVE_QUIT;
+          if (v.cidx(j) == nz && v.cidx(j-1) != nz)
+            end_nc = j;
+          if (nz - v.cidx(j-1) >= n_to_find)
+            {
+              start_nc = j - 1;
+              break;
+            }
+        }
     }
 
   count = (n_to_find > v.cidx(end_nc) - v.cidx(start_nc) ? 
-	   v.cidx(end_nc) - v.cidx(start_nc) : n_to_find);
+           v.cidx(end_nc) - v.cidx(start_nc) : n_to_find);
 
   // If the original argument was a row vector, force a row vector of
   // the overall indices to be returned.  But see below for scalar
   // case...
 
   octave_idx_type result_nr = count;
   octave_idx_type result_nc = 1;
 
@@ -178,29 +178,29 @@ find_nonzero_elem_idx (const Sparse<T>& 
   Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++) 
-	for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ ) 
-	  {
-	    OCTAVE_QUIT;
-	    if (direction < 0 && i < nz - count)
-	      continue;
-	    i_idx(cx) = static_cast<double> (v.ridx(i) + 1);
-	    j_idx(cx) = static_cast<double> (j + 1);
-	    idx(cx) = j * nr + v.ridx(i) + 1; 
-	    val(cx) = v.data(i);
-	    cx++;
-	    if (cx == count)
-	      break;
-	  }
+        for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ ) 
+          {
+            OCTAVE_QUIT;
+            if (direction < 0 && i < nz - count)
+              continue;
+            i_idx(cx) = static_cast<double> (v.ridx(i) + 1);
+            j_idx(cx) = static_cast<double> (j + 1);
+            idx(cx) = j * nr + v.ridx(i) + 1; 
+            val(cx) = v.data(i);
+            cx++;
+            if (cx == count)
+              break;
+          }
     }
   else if (scalar_arg)
     {
       idx.resize (0, 0);
 
       i_idx.resize (0, 0);
       j_idx.resize (0, 0);
 
@@ -235,27 +235,27 @@ find_nonzero_elem_idx (const Sparse<T>& 
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 template octave_value_list find_nonzero_elem_idx (const Sparse<double>&, int,
-						  octave_idx_type, int);
+                                                  octave_idx_type, int);
 
 template octave_value_list find_nonzero_elem_idx (const Sparse<Complex>&, int,
-						  octave_idx_type, int);
+                                                  octave_idx_type, int);
 
 template octave_value_list find_nonzero_elem_idx (const Sparse<bool>&, int,
-						  octave_idx_type, int);
+                                                  octave_idx_type, int);
 
 octave_value_list
 find_nonzero_elem_idx (const PermMatrix& v, int nargout, 
-		       octave_idx_type n_to_find, int direction)
+                       octave_idx_type n_to_find, int direction)
 {
   // There are far fewer special cases to handle for a PermMatrix.
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
   octave_idx_type nc = v.cols();
   octave_idx_type start_nc, end_nc, count;
  
   // Determine the range to search.
@@ -432,84 +432,84 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).scalar_value ();
 
       if (error_state || (! xisinf (val) && (val < 0 || val != xround (val))))
-	{
-	  error ("find: expecting second argument to be a nonnegative integer");
-	  return retval;
-	}
+        {
+          error ("find: expecting second argument to be a nonnegative integer");
+          return retval;
+        }
       else
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
   if (nargin > 2)
     {
       direction = 0;
 
       std::string s_arg = args(2).string_value ();
 
       if (! error_state)
-	{
-	  if (s_arg == "first")
-	    direction = 1;
-	  else if (s_arg == "last")
-	    direction = -1;
-	}
+        {
+          if (s_arg == "first")
+            direction = 1;
+          else if (s_arg == "last")
+            direction = -1;
+        }
 
       if (direction == 0)
-	{
-	  error ("find: expecting third argument to be \"first\" or \"last\"");
-	  return retval;
-	}
+        {
+          error ("find: expecting third argument to be \"first\" or \"last\"");
+          return retval;
+        }
     }
 
   octave_value arg = args(0);
 
   if (arg.is_bool_type ())
     {
       if (arg.is_sparse_type ())
         {
-	  SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
+          SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
 
-	  if (! error_state)
-	    retval = find_nonzero_elem_idx (v, nargout, 
-					    n_to_find, direction);
+          if (! error_state)
+            retval = find_nonzero_elem_idx (v, nargout, 
+                                            n_to_find, direction);
         }
       else if (nargout <= 1 && n_to_find == -1 && direction == 1)
         {
           // This case is equivalent to extracting indices from a logical
           // matrix. Try to reuse the possibly cached index vector. 
           retval(0) = arg.index_vector ().unmask ();
         }
       else
         {
           boolNDArray v = arg.bool_array_value ();
 
-	  if (! error_state)
-	    retval = find_nonzero_elem_idx (v, nargout, 
-					    n_to_find, direction);
+          if (! error_state)
+            retval = find_nonzero_elem_idx (v, nargout, 
+                                            n_to_find, direction);
         }
     }
   else if (arg.is_integer_type ())
     {
 #define DO_INT_BRANCH(INTT) \
       else if (arg.is_ ## INTT ## _type ()) \
         { \
           INTT ## NDArray v = arg.INTT ## _array_value (); \
           \
-	  if (! error_state) \
-	    retval = find_nonzero_elem_idx (v, nargout, \
-					    n_to_find, direction);\
+          if (! error_state) \
+            retval = find_nonzero_elem_idx (v, nargout, \
+                                            n_to_find, direction);\
         }
 
       if (false)
         ;
       DO_INT_BRANCH (int8)
       DO_INT_BRANCH (int16)
       DO_INT_BRANCH (int32)
       DO_INT_BRANCH (int64)
@@ -518,92 +518,92 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
       DO_INT_BRANCH (uint32)
       DO_INT_BRANCH (uint64)
       else
         panic_impossible ();
     }
   else if (arg.is_sparse_type ())
     {
       if (arg.is_real_type ())
-	{
-	  SparseMatrix v = arg.sparse_matrix_value ();
+        {
+          SparseMatrix v = arg.sparse_matrix_value ();
 
-	  if (! error_state)
-	    retval = find_nonzero_elem_idx (v, nargout, 
-					    n_to_find, direction);
-	}
+          if (! error_state)
+            retval = find_nonzero_elem_idx (v, nargout, 
+                                            n_to_find, direction);
+        }
       else if (arg.is_complex_type ())
-	{
-	  SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
+        {
+          SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
 
-	  if (! error_state)
-	    retval = find_nonzero_elem_idx (v, nargout, 
-					    n_to_find, direction);
-	}
+          if (! error_state)
+            retval = find_nonzero_elem_idx (v, nargout, 
+                                            n_to_find, direction);
+        }
       else 
-	gripe_wrong_type_arg ("find", arg);
+        gripe_wrong_type_arg ("find", arg);
     }
   else if (arg.is_perm_matrix ()) {
     PermMatrix P = arg.perm_matrix_value ();
 
     if (! error_state)
       retval = find_nonzero_elem_idx (P, nargout, n_to_find, direction);
   }
   else
     {
       if (arg.is_single_type ())
-	{
-	  if (arg.is_real_type ())
-	    {
-	      FloatNDArray nda = arg.float_array_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              FloatNDArray nda = arg.float_array_value ();
 
-	      if (! error_state)
-		retval = find_nonzero_elem_idx (nda, nargout, 
-						n_to_find, direction);
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      FloatComplexNDArray cnda = arg.float_complex_array_value ();
+              if (! error_state)
+                retval = find_nonzero_elem_idx (nda, nargout, 
+                                                n_to_find, direction);
+            }
+          else if (arg.is_complex_type ())
+            {
+              FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-	      if (! error_state)
-		retval = find_nonzero_elem_idx (cnda, nargout, 
-						n_to_find, direction);
-	    }
-	}
+              if (! error_state)
+                retval = find_nonzero_elem_idx (cnda, nargout, 
+                                                n_to_find, direction);
+            }
+        }
       else
-	{
-	  if (arg.is_real_type ())
-	    {
-	      NDArray nda = arg.array_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              NDArray nda = arg.array_value ();
 
-	      if (! error_state)
-		retval = find_nonzero_elem_idx (nda, nargout, 
-						n_to_find, direction);
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      ComplexNDArray cnda = arg.complex_array_value ();
+              if (! error_state)
+                retval = find_nonzero_elem_idx (nda, nargout, 
+                                                n_to_find, direction);
+            }
+          else if (arg.is_complex_type ())
+            {
+              ComplexNDArray cnda = arg.complex_array_value ();
 
-	      if (! error_state)
-		retval = find_nonzero_elem_idx (cnda, nargout, 
-						n_to_find, direction);
-	    }
-	  else if (arg.is_string ())
-	    {
-	      charNDArray cnda = arg.char_array_value ();
+              if (! error_state)
+                retval = find_nonzero_elem_idx (cnda, nargout, 
+                                                n_to_find, direction);
+            }
+          else if (arg.is_string ())
+            {
+              charNDArray cnda = arg.char_array_value ();
 
-	      if (! error_state)
-		retval = find_nonzero_elem_idx (cnda, nargout, 
-						n_to_find, direction);
-	    }
-	  else
-	    {
-	      gripe_wrong_type_arg ("find", arg);
-	    }
-	}
+              if (! error_state)
+                retval = find_nonzero_elem_idx (cnda, nargout, 
+                                                n_to_find, direction);
+            }
+          else
+            {
+              gripe_wrong_type_arg ("find", arg);
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 %!assert(find ([1, 0, 1, 0, 1]), [1, 3, 5]);
 %!assert(find ([1; 0; 3; 0; 1]), [1; 3; 5]);
diff --git a/src/DLD-FUNCTIONS/fltk_backend.cc b/src/DLD-FUNCTIONS/fltk_backend.cc
--- a/src/DLD-FUNCTIONS/fltk_backend.cc
+++ b/src/DLD-FUNCTIONS/fltk_backend.cc
@@ -127,33 +127,33 @@ private:
     glLoadIdentity ();
     glViewport (0, 0, _w, _h);
   }
 
   void draw (void)
   {
     if (! valid ())
       {
-	valid (1);
-	setup_viewport (w (), h ());
+        valid (1);
+        setup_viewport (w (), h ());
       }
 
     if (! print_filename.empty ())
       {
-	opengl_renderer *rend = new glps_renderer (print_filename);
-	rend->draw (gh_manager::lookup (number));
-	print_filename = "";
-	delete rend;
+        opengl_renderer *rend = new glps_renderer (print_filename);
+        rend->draw (gh_manager::lookup (number));
+        print_filename = "";
+        delete rend;
       }
     else
       {
-	renderer.draw (gh_manager::lookup (number));
+        renderer.draw (gh_manager::lookup (number));
 
-	if (zoom ())
-	  overlay ();
+        if (zoom ())
+          overlay ();
       }
   }
 
   void resize (int _x, int _y, int _w, int _h)
   {
     Fl_Gl_Window::resize (_x, _y, _w, _h);
     setup_viewport (_w, _h);
     redraw ();
@@ -199,22 +199,22 @@ private:
 
   int handle (int event)
   {
     int retval = Fl_Gl_Window::handle (event);
 
     switch (event)
       {
       case FL_ENTER:
-	window ()->cursor (FL_CURSOR_CROSS);
-	return 1;
+        window ()->cursor (FL_CURSOR_CROSS);
+        return 1;
 
       case FL_LEAVE:
-	window ()->cursor (FL_CURSOR_DEFAULT);
-	return 1;
+        window ()->cursor (FL_CURSOR_DEFAULT);
+        return 1;
       }
 
     return retval;
   }
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
 static double wheel_zoom_speed = 0.05;
@@ -225,47 +225,47 @@ public:
   plot_window (int _x, int _y, int _w, int _h, figure::properties& _fp)
     : Fl_Window (_x, _y, _w, _h, "octave"), fp (_fp)
   {
     callback (window_close, static_cast<void*> (this));
 
     begin ();
     {
       canvas = new
-	OpenGL_fltk (0, 0, _w , _h - status_h, number ());
+        OpenGL_fltk (0, 0, _w , _h - status_h, number ());
 
       autoscale = new
-	Fl_Button (0,
-		   _h - status_h,
-		   status_h,
-		   status_h,
-		   "A");
+        Fl_Button (0,
+                   _h - status_h,
+                   status_h,
+                   status_h,
+                   "A");
       autoscale->callback (button_callback, static_cast<void*> (this));
 
       togglegrid = new
-	Fl_Button (status_h,
-		   _h - status_h,
-		   status_h,
-		   status_h,
-		   "G");
+        Fl_Button (status_h,
+                   _h - status_h,
+                   status_h,
+                   status_h,
+                   "G");
       togglegrid->callback (button_callback, static_cast<void*> (this));
 
       help = new
-	Fl_Button (2*status_h,
-		   _h - status_h,
-		   status_h,
-		   status_h,
-		   "?");
+        Fl_Button (2*status_h,
+                   _h - status_h,
+                   status_h,
+                   status_h,
+                   "?");
       help->callback (button_callback, static_cast<void*> (this));
 
       status = new
-	Fl_Output (3*status_h,
-		   _h - status_h,
-		   _w > 2*status_h ? _w - status_h : 0,
-		   status_h, "");
+        Fl_Output (3*status_h,
+                   _h - status_h,
+                   _w > 2*status_h ? _w - status_h : 0,
+                   status_h, "");
 
       status->textcolor (FL_BLACK);
       status->color (FL_GRAY);
       status->textfont (FL_COURIER);
       status->textsize (10);
       status->box (FL_ENGRAVED_BOX);
 
       // This allows us to have a valid OpenGL context right away.
@@ -389,70 +389,70 @@ private:
     pixel2pos ( gh_manager::get_object (ax), px, py, xx, yy);
   }
 
   void pixel2pos 
   (graphics_object ax, int px, int py, double& xx, double& yy) const
   {
     if (ax && ax.isa ("axes"))
       {
-	axes::properties& ap =
-	  dynamic_cast<axes::properties&> (ax.get_properties ());
-	ColumnVector pp = ap.pixel2coord (px, py);
-	xx = pp(0);
-	yy = pp(1);
+        axes::properties& ap =
+          dynamic_cast<axes::properties&> (ax.get_properties ());
+        ColumnVector pp = ap.pixel2coord (px, py);
+        xx = pp(0);
+        yy = pp(1);
       }
   }
 
   graphics_handle pixel2axes_or_ca (int px, int py )
   {
     Matrix kids = fp.get_children ();
     int len = kids.length ();
 
     for (int k = 0; k < len; k++)
       {
-	graphics_handle hnd = gh_manager::lookup (kids(k));
+        graphics_handle hnd = gh_manager::lookup (kids(k));
 
-	if (hnd.ok ())
-	  {
-	    graphics_object kid = gh_manager::get_object (hnd);
+        if (hnd.ok ())
+          {
+            graphics_object kid = gh_manager::get_object (hnd);
 
-	    if (kid.valid_object () && kid.isa ("axes"))
-	      {
-		Matrix bb = kid.get_properties ().get_boundingbox (true);
+            if (kid.valid_object () && kid.isa ("axes"))
+              {
+                Matrix bb = kid.get_properties ().get_boundingbox (true);
 
-		if (bb(0) <= px && px < (bb(0)+bb(2))
-		    && bb(1) <= py && py < (bb(1)+bb(3)))
-		  {
-		    return hnd;
-		  }
-	      }
-	  }
+                if (bb(0) <= px && px < (bb(0)+bb(2))
+                    && bb(1) <= py && py < (bb(1)+bb(3)))
+                  {
+                    return hnd;
+                  }
+              }
+          }
       }
     return fp.get_currentaxes ();
   }
   
   void pixel2status (graphics_handle ax, int px0, int py0,
-		     int px1 = -1, int py1 = -1)
+                     int px1 = -1, int py1 = -1)
   {
     pixel2status (gh_manager::get_object (ax), px0, py0, px1, py1);
   }
 
   void pixel2status (graphics_object ax, int px0, int py0,
-		     int px1 = -1, int py1 = -1)
+                     int px1 = -1, int py1 = -1)
   {
     double x0, y0, x1, y1;
     std::stringstream cbuf;
 
     pixel2pos (ax, px0, py0, x0, y0);
     cbuf << "[" << x0 << ", " << y0 << "]";
     if (px1 >= 0)
       {
-	pixel2pos (ax, px1, py1, x1, y1);
-	cbuf << " -> ["<< x1 << ", " << y1 << "]";
+        pixel2pos (ax, px1, py1, x1, y1);
+        cbuf << " -> ["<< x1 << ", " << y1 << "]";
       }
 
     status->value (cbuf.str ().c_str ());
     status->redraw ();
   }
 
   void resize (int _x,int _y,int _w,int _h)
   {
@@ -485,160 +485,160 @@ private:
 
     // We only handle events which are in the canvas area.
     if (Fl::event_y () >= h() - status_h)
       return retval;
 
     switch (event)
       {
       case FL_KEYDOWN:
-	switch(Fl::event_key ())
-	  {
-	  case 'a':
-	  case 'A':
-	    axis_auto ();
-	    break;
+        switch(Fl::event_key ())
+          {
+          case 'a':
+          case 'A':
+            axis_auto ();
+            break;
 
-	  case 'g':
-	  case 'G':
-	    toggle_grid ();
-	    break;
-	  }
-	break;
+          case 'g':
+          case 'G':
+            toggle_grid ();
+            break;
+          }
+        break;
 
       case FL_MOVE:
-	pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y ()),
-		      Fl::event_x (), Fl::event_y ());
-	break;
+        pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y ()),
+                      Fl::event_x (), Fl::event_y ());
+        break;
 
       case FL_PUSH:
-	if (Fl::event_button () == 1 || Fl::event_button () == 3)
-	  {
-	    px0 = Fl::event_x ();
-	    py0 = Fl::event_y ();
-	    ax0 = gh_manager::get_object (pixel2axes_or_ca (px0, py0));
-	    return 1;
-	  }
-	break;
+        if (Fl::event_button () == 1 || Fl::event_button () == 3)
+          {
+            px0 = Fl::event_x ();
+            py0 = Fl::event_y ();
+            ax0 = gh_manager::get_object (pixel2axes_or_ca (px0, py0));
+            return 1;
+          }
+        break;
 
       case FL_DRAG:
-	pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
-	if (Fl::event_button () == 1)
-	  {
+        pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
+        if (Fl::event_button () == 1)
+          {
             if (ax0 && ax0.isa ("axes"))
               {
                 axes::properties& ap = 
-		  dynamic_cast<axes::properties&> (ax0.get_properties ());
+                  dynamic_cast<axes::properties&> (ax0.get_properties ());
               
                 double x0, y0, x1, y1;
                 pixel2pos (ax0, px0, py0, x0, y0);
                 pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
                 px0 = Fl::event_x ();
                 py0 = Fl::event_y ();
 
                 ap.translate_view (x0 - x1, y0 - y1);
                 mark_modified ();
               }
-	    return 1;
-	  }
-	else if (Fl::event_button () == 3)
-	  {
-	    Matrix zoom_box (1,4,0);
-	    zoom_box (0) = px0;
-	    zoom_box (1) = py0;
-	    zoom_box (2) =  Fl::event_x ();
-	    zoom_box (3) =  Fl::event_y ();
-	    canvas->set_zoom_box (zoom_box);
-	    canvas->zoom (true);
-	    canvas->redraw ();
-	  }
+            return 1;
+          }
+        else if (Fl::event_button () == 3)
+          {
+            Matrix zoom_box (1,4,0);
+            zoom_box (0) = px0;
+            zoom_box (1) = py0;
+            zoom_box (2) =  Fl::event_x ();
+            zoom_box (3) =  Fl::event_y ();
+            canvas->set_zoom_box (zoom_box);
+            canvas->zoom (true);
+            canvas->redraw ();
+          }
 
-	break;
+        break;
 
       case FL_MOUSEWHEEL:
         {
-	  graphics_object ax = 
-	    gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (), 
-						      Fl::event_y ()));                                                                      
+          graphics_object ax = 
+            gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (), 
+                                                      Fl::event_y ()));                                                                      
           if (ax && ax.isa ("axes"))
             {
               axes::properties& ap = 
-		dynamic_cast<axes::properties&> (ax.get_properties ());
+                dynamic_cast<axes::properties&> (ax.get_properties ());
               
               // Determine if we're zooming in or out.
               const double factor = 
-		(Fl::event_dy () > 0) ? 1.0 + wheel_zoom_speed : 1.0 - wheel_zoom_speed;
+                (Fl::event_dy () > 0) ? 1.0 + wheel_zoom_speed : 1.0 - wheel_zoom_speed;
               
               // Get the point we're zooming about.
               double x1, y1;
               pixel2pos (ax, Fl::event_x (), Fl::event_y (), x1, y1);
               
               ap.zoom_about_point (x1, y1, factor, false);
               mark_modified ();
             }
-	}
+        }
       return 1;
 
       case FL_RELEASE:
-	if (Fl::event_button () == 1)
-	  {
-	    if ( Fl::event_clicks () == 1)
-	      {
-		if (ax0 && ax0.isa ("axes"))
-		  {
-		    axes::properties& ap =
-		      dynamic_cast<axes::properties&> (ax0.get_properties ());
-		    ap.set_xlimmode("auto");
-		    ap.set_ylimmode("auto");
-		    ap.set_zlimmode("auto");
-		    mark_modified ();
-		  }
-	      }
-	  }
-	if (Fl::event_button () == 3)
-	  {
-	    // End of drag -- zoom.
-	    if (canvas->zoom ())
-	      {
-		canvas->zoom (false);
-		double x0,y0,x1,y1;
-		if (ax0 && ax0.isa ("axes"))
-		  {
-		    axes::properties& ap =
-		      dynamic_cast<axes::properties&> (ax0.get_properties ());
-		    pixel2pos (ax0, px0, py0, x0, y0);
-		    pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
-		    Matrix xl (1,2,0);
-		    Matrix yl (1,2,0);
-		    if (x0 < x1)
-		      {
-			xl(0) = x0;
-			xl(1) = x1;
-		      }
-		    else
-		      {
-			xl(0) = x1;
-			xl(1) = x0;
-		      }
-		    if (y0 < y1)
-		      {
-			yl(0) = y0;
-			yl(1) = y1;
-		      }
-		    else
-		      {
-			yl(0) = y1;
-			yl(1) = y0;
-		      }
-		    ap.zoom (xl, yl);
-		    mark_modified ();
-		  }
-	      }
-	  }
-	break;
+        if (Fl::event_button () == 1)
+          {
+            if ( Fl::event_clicks () == 1)
+              {
+                if (ax0 && ax0.isa ("axes"))
+                  {
+                    axes::properties& ap =
+                      dynamic_cast<axes::properties&> (ax0.get_properties ());
+                    ap.set_xlimmode("auto");
+                    ap.set_ylimmode("auto");
+                    ap.set_zlimmode("auto");
+                    mark_modified ();
+                  }
+              }
+          }
+        if (Fl::event_button () == 3)
+          {
+            // End of drag -- zoom.
+            if (canvas->zoom ())
+              {
+                canvas->zoom (false);
+                double x0,y0,x1,y1;
+                if (ax0 && ax0.isa ("axes"))
+                  {
+                    axes::properties& ap =
+                      dynamic_cast<axes::properties&> (ax0.get_properties ());
+                    pixel2pos (ax0, px0, py0, x0, y0);
+                    pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
+                    Matrix xl (1,2,0);
+                    Matrix yl (1,2,0);
+                    if (x0 < x1)
+                      {
+                        xl(0) = x0;
+                        xl(1) = x1;
+                      }
+                    else
+                      {
+                        xl(0) = x1;
+                        xl(1) = x0;
+                      }
+                    if (y0 < y1)
+                      {
+                        yl(0) = y0;
+                        yl(1) = y1;
+                      }
+                    else
+                      {
+                        yl(0) = y1;
+                        yl(1) = y0;
+                      }
+                    ap.zoom (xl, yl);
+                    mark_modified ();
+                  }
+              }
+          }
+        break;
       }
 
     return retval;
   }
 };
 
 class figure_manager
 {
@@ -648,19 +648,19 @@ public:
   {
     bool retval = true;
 
     if (! instance)
       instance = new figure_manager ();
 
     if (! instance)
       {
-	::error ("unable to create figure_manager object!");
+        ::error ("unable to create figure_manager object!");
 
-	retval = false;
+        retval = false;
       }
 
     return retval;
   }
 
   ~figure_manager (void)
   {
     close_all ();
@@ -767,29 +767,29 @@ private:
 
   void do_new_window (figure::properties& fp)
   {
     int x, y, w, h;
 
     int idx = figprops2idx (fp);
     if (idx >= 0 && windows.find (idx) == windows.end ())
       {
-	default_size (x, y, w, h);
-	idx2figprops (curr_index , fp);
-	windows[curr_index++] = new plot_window (x, y, w, h, fp);
+        default_size (x, y, w, h);
+        idx2figprops (curr_index , fp);
+        windows[curr_index++] = new plot_window (x, y, w, h, fp);
       }
   }
 
   void do_delete_window (int idx)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
-	delete win->second;
-	windows.erase (win);
+        delete win->second;
+        windows.erase (win);
       }
   }
 
   void do_toggle_window_visibility (int idx, bool is_visible)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
@@ -802,49 +802,49 @@ private:
       }
   }
 
   void do_mark_modified (int idx)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
-	win->second->mark_modified ();
+        win->second->mark_modified ();
       }
   }
 
   void do_set_name (int idx)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
-	win->second->set_name ();
+        win->second->set_name ();
       }
   }
 
   Matrix do_get_size (int idx)
   {
     Matrix sz (1, 2, 0.0);
 
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
-	sz(0) = win->second->w ();
-	sz(1) = win->second->h ();
+        sz(0) = win->second->w ();
+        sz(1) = win->second->h ();
       }
 
     return sz;
   }
 
   void do_print (int idx, const std::string& filename)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
-	win->second->print (filename);
+        win->second->print (filename);
       }
   }
 
   // FIXME -- default size should be configurable.
   void default_size (int& x, int& y, int& w, int& h)
   {
     x = 0;
     y = 0;
@@ -852,53 +852,53 @@ private:
     h = 480;
   }
 
   static int str2idx (const caseless_str clstr)
   {
     int ind;
     if (clstr.find (fltk_idx_header,0) == 0)
       {
-	std::istringstream istr (clstr.substr (fltk_idx_header.size ()));
-	if (istr >> ind)
-	  return ind;
+        std::istringstream istr (clstr.substr (fltk_idx_header.size ()));
+        if (istr >> ind)
+          return ind;
       }
     error ("fltk_backend: could not recognize fltk index");
     return -1;
   }
 
   void idx2figprops (int idx, figure::properties& fp)
   {
     std::ostringstream ind_str;
     ind_str << fltk_idx_header << idx;
     fp.set___plot_stream__ (ind_str.str ());
   }
 
   static int figprops2idx (const figure::properties& fp)
   {
     if (fp.get___backend__ () == FLTK_BACKEND_NAME)
       {
-	octave_value ps = fp.get___plot_stream__ ();
-	if (ps.is_string ())
-	  return str2idx (ps.string_value ());
-	else
-	  return 0;
+        octave_value ps = fp.get___plot_stream__ ();
+        if (ps.is_string ())
+          return str2idx (ps.string_value ());
+        else
+          return 0;
       }
     error ("fltk_backend:: figure is not fltk");
     return -1;
   }
 
   static int hnd2idx (const double h)
   {
     graphics_object fobj = gh_manager::get_object (h);
     if (fobj &&  fobj.isa ("figure"))
       {
-	figure::properties& fp =
-	  dynamic_cast<figure::properties&> (fobj.get_properties ());
-	return figprops2idx (fp);
+        figure::properties& fp =
+          dynamic_cast<figure::properties&> (fobj.get_properties ());
+        return figprops2idx (fp);
       }
     error ("fltk_backend:: not a figure");
     return -1;
   }
 
   static int hnd2idx (const graphics_handle& fh)
   {
     return hnd2idx (fh.value ());
@@ -915,32 +915,32 @@ static bool backend_registered = false;
 static int
 __fltk_redraw__ (void)
 {
   if (backend_registered)
     {
       // we scan all figures and add those which use FLTK as a backend
       graphics_object obj = gh_manager::get_object (0);
       if (obj && obj.isa ("root"))
-	{
-	  base_properties& props = obj.get_properties ();
-	  Matrix children = props.get_children ();
+        {
+          base_properties& props = obj.get_properties ();
+          Matrix children = props.get_children ();
 
-	  for (octave_idx_type n = 0; n < children.numel (); n++)
-	    {
-	      graphics_object fobj = gh_manager::get_object (children (n));
-	      if (fobj && fobj.isa ("figure"))
-		{
-		  figure::properties& fp =
-		      dynamic_cast<figure::properties&> (fobj.get_properties ());
-		  if (fp.get___backend__ () == FLTK_BACKEND_NAME)
-		    figure_manager::new_window (fp);
-		}
-	    }
-	}
+          for (octave_idx_type n = 0; n < children.numel (); n++)
+            {
+              graphics_object fobj = gh_manager::get_object (children (n));
+              if (fobj && fobj.isa ("figure"))
+                {
+                  figure::properties& fp =
+                      dynamic_cast<figure::properties&> (fobj.get_properties ());
+                  if (fp.get___backend__ () == FLTK_BACKEND_NAME)
+                    figure_manager::new_window (fp);
+                }
+            }
+        }
 
       Fl::wait (fltk_maxtime);
     }
 
   return 0;
 }
 
 class fltk_backend : public base_graphics_backend
@@ -952,58 +952,58 @@ public:
   ~fltk_backend (void) { }
 
   bool is_valid (void) const { return true; }
 
   void object_destroyed (const graphics_object& go)
   {
     if (go.isa ("figure"))
       {
-	octave_value ov = go.get (caseless_str ("__plot_stream__"));
-	figure_manager::delete_window (ov.string_value ());
+        octave_value ov = go.get (caseless_str ("__plot_stream__"));
+        figure_manager::delete_window (ov.string_value ());
       }
   }
 
   void property_changed (const graphics_object& go, int id)
   {
     if (go.isa ("figure"))
       {
-	octave_value ov = go.get (caseless_str ("__plot_stream__"));
-	
-	if (! ov.is_empty ())
-	  {
+        octave_value ov = go.get (caseless_str ("__plot_stream__"));
+        
+        if (! ov.is_empty ())
+          {
             const figure::properties& fp =
               dynamic_cast<const figure::properties&> (go.get_properties ());
             
-	    switch (id)
-	      {
-	      case base_properties::VISIBLE:
+            switch (id)
+              {
+              case base_properties::VISIBLE:
                 figure_manager::toggle_window_visibility (ov.string_value (), fp.is_visible ());
-		break;
+                break;
 
               case figure::properties::NAME:
               case figure::properties::NUMBERTITLE:
                 figure_manager::set_name (ov.string_value ());
                 break;
-	      }
-	  }
+              }
+          }
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     figure_manager::mark_modified (go.get_handle ());
 
     __fltk_redraw__ ();
   }
 
   void print_figure (const graphics_object& go,
-		     const std::string& /*term*/,
-		     const std::string& file, bool /*mono*/,
-		     const std::string& /*debug_file*/) const 
+                     const std::string& /*term*/,
+                     const std::string& file, bool /*mono*/,
+                     const std::string& /*debug_file*/) const 
   { 
     figure_manager::print (go.get_handle (), file);
   }
 
   Matrix get_canvas_size (const graphics_handle& fh) const
   {
     return figure_manager::get_size (fh);
   }
@@ -1076,17 +1076,17 @@ DEFUN_DLD (__remove_fltk__, , , "")
       args(0) = "__fltk_redraw__";
       feval ("remove_input_event_hook", args, 0);
 
       // FIXME ???
       Fl::wait (fltk_maxtime);
     }
 
   octave_value retval;
-  return retval;	
+  return retval;        
 }
 
 DEFUN_DLD (__fltk_maxtime__, args, ,"")
 {
   octave_value retval = fltk_maxtime;
 
   if (args.length () == 1)
     {
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -70,109 +70,109 @@ If neither @var{x} nor @var{a} is scalar
 
   if (nargin == 2)
     {
       octave_value x_arg = args(0);
       octave_value a_arg = args(1);
 
       // FIXME Can we make a template version of the duplicated code below
       if (x_arg.is_single_type () || a_arg.is_single_type ())
-	{
-	  if (x_arg.is_scalar_type ())
-	    {
-	      float x = x_arg.float_value ();
+        {
+          if (x_arg.is_scalar_type ())
+            {
+              float x = x_arg.float_value ();
 
-	      if (! error_state)
-		{
-		  if (a_arg.is_scalar_type ())
-		    {
-		      float a = a_arg.float_value ();
+              if (! error_state)
+                {
+                  if (a_arg.is_scalar_type ())
+                    {
+                      float a = a_arg.float_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		  else
-		    {
-		      FloatNDArray a = a_arg.float_array_value ();
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                  else
+                    {
+                      FloatNDArray a = a_arg.float_array_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		}
-	    }
-	  else
-	    {
-	      FloatNDArray x = x_arg.float_array_value ();
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                }
+            }
+          else
+            {
+              FloatNDArray x = x_arg.float_array_value ();
 
-	      if (! error_state)
-		{
-		  if (a_arg.is_scalar_type ())
-		    {
-		      float a = a_arg.float_value ();
+              if (! error_state)
+                {
+                  if (a_arg.is_scalar_type ())
+                    {
+                      float a = a_arg.float_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		  else
-		    {
-		      FloatNDArray a = a_arg.float_array_value ();
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                  else
+                    {
+                      FloatNDArray a = a_arg.float_array_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		}
-	    }
-	}
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                }
+            }
+        }
       else
-	{
-	  if (x_arg.is_scalar_type ())
-	    {
-	      double x = x_arg.double_value ();
+        {
+          if (x_arg.is_scalar_type ())
+            {
+              double x = x_arg.double_value ();
 
-	      if (! error_state)
-		{
-		  if (a_arg.is_scalar_type ())
-		    {
-		      double a = a_arg.double_value ();
+              if (! error_state)
+                {
+                  if (a_arg.is_scalar_type ())
+                    {
+                      double a = a_arg.double_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		  else
-		    {
-		      NDArray a = a_arg.array_value ();
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                  else
+                    {
+                      NDArray a = a_arg.array_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		}
-	    }
-	  else
-	    {
-	      NDArray x = x_arg.array_value ();
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                }
+            }
+          else
+            {
+              NDArray x = x_arg.array_value ();
 
-	      if (! error_state)
-		{
-		  if (a_arg.is_scalar_type ())
-		    {
-		      double a = a_arg.double_value ();
+              if (! error_state)
+                {
+                  if (a_arg.is_scalar_type ())
+                    {
+                      double a = a_arg.double_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		  else
-		    {
-		      NDArray a = a_arg.array_value ();
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                  else
+                    {
+                      NDArray a = a_arg.array_value ();
 
-		      if (! error_state)
-			retval = gammainc (x, a);
-		    }
-		}
-	    }
-	}
+                      if (! error_state)
+                        retval = gammainc (x, a);
+                    }
+                }
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -108,333 +108,333 @@ all of the values of @var{v1}, @dots{} i
   bool all_args_scalar = true;
   bool any_single = false;
 
   dim_vector dv(1);
 
   for (int i = 0; i < nargin; i++)
     {
       if (! args(i).is_scalar_type ())
-	{
-	  if (! args(i).is_matrix_type ())
-	    {
-	      error ("gcd: invalid argument type");
-	      return retval;
-	    }
+        {
+          if (! args(i).is_matrix_type ())
+            {
+              error ("gcd: invalid argument type");
+              return retval;
+            }
 
-	  if (all_args_scalar)
-	    {
-	      all_args_scalar = false;
-	      dv = args(i).dims ();
-	    }
-	  else
-	    {
-	      if (dv != args(i).dims ())
-		{
-		  error ("gcd: all arguments must be the same size or scalar");
-		  return retval;
-		}
-	    }
-	}
+          if (all_args_scalar)
+            {
+              all_args_scalar = false;
+              dv = args(i).dims ();
+            }
+          else
+            {
+              if (dv != args(i).dims ())
+                {
+                  error ("gcd: all arguments must be the same size or scalar");
+                  return retval;
+                }
+            }
+        }
       if (!any_single && args(i).is_single_type ())
-	any_single = true;
+        any_single = true;
     }
 
   if (any_single)
     {
       if (nargin == 1)
-	{
-	  FloatNDArray gg = args(0).float_array_value ();
+        {
+          FloatNDArray gg = args(0).float_array_value ();
 
-	  int nel = dv.numel ();
+          int nel = dv.numel ();
 
-	  FloatNDArray v (dv);
+          FloatNDArray v (dv);
 
-	  FloatRowVector x (3);
-	  FloatRowVector y (3);
+          FloatRowVector x (3);
+          FloatRowVector y (3);
 
-	  float g = std::abs (gg(0));
+          float g = std::abs (gg(0));
 
-	  if (! is_integer_value (g))
-	    {
-	      error ("gcd: all arguments must be integer");
-	      return retval;
-	    }
+          if (! is_integer_value (g))
+            {
+              error ("gcd: all arguments must be integer");
+              return retval;
+            }
 
-	  v(0) = signum (gg(0));
+          v(0) = signum (gg(0));
       
-	  for (int k = 1; k < nel; k++)
-	    {
-	      x(0) = g;
-	      x(1) = 1;
-	      x(2) = 0;
+          for (int k = 1; k < nel; k++)
+            {
+              x(0) = g;
+              x(1) = 1;
+              x(2) = 0;
 
-	      y(0) = std::abs (gg(k));
-	      y(1) = 0;
-	      y(2) = 1;
+              y(0) = std::abs (gg(k));
+              y(1) = 0;
+              y(2) = 1;
 
-	      if (! is_integer_value (y(0)))
-		{
-		  error ("gcd: all arguments must be integer");
-		  return retval;
-		}
+              if (! is_integer_value (y(0)))
+                {
+                  error ("gcd: all arguments must be integer");
+                  return retval;
+                }
 
-	      while (y(0) > 0)
-		{
-		  FloatRowVector r = x - y * std::floor (x(0) / y(0));
-		  x = y;
-		  y = r;
-		}
+              while (y(0) > 0)
+                {
+                  FloatRowVector r = x - y * std::floor (x(0) / y(0));
+                  x = y;
+                  y = r;
+                }
 
-	      g = x(0);
+              g = x(0);
 
-	      for (int i = 0; i < k; i++) 
-		v(i) *= x(1);
+              for (int i = 0; i < k; i++) 
+                v(i) *= x(1);
 
-	      v(k) = x(2) * signum (gg(k));
-	    }
+              v(k) = x(2) * signum (gg(k));
+            }
 
-	  retval (1) = v;
-	  retval (0) = g;
-	}
+          retval (1) = v;
+          retval (0) = g;
+        }
       else if (all_args_scalar && nargout < 3)
-	{
-	  float g = args(0).float_value ();
+        {
+          float g = args(0).float_value ();
 
-	  if (error_state || ! is_integer_value (g))
-	    {
-	      error ("gcd: all arguments must be integer");
-	      return retval;
-	    }
+          if (error_state || ! is_integer_value (g))
+            {
+              error ("gcd: all arguments must be integer");
+              return retval;
+            }
 
-	  FloatRowVector v (nargin, 0);
-	  FloatRowVector x (3);
-	  FloatRowVector y (3);
+          FloatRowVector v (nargin, 0);
+          FloatRowVector x (3);
+          FloatRowVector y (3);
 
-	  v(0) = signum (g);
+          v(0) = signum (g);
 
-	  g = std::abs(g);
+          g = std::abs(g);
       
-	  for (int k = 1; k < nargin; k++)
-	    {
-	      x(0) = g;
-	      x(1) = 1;
-	      x(2) = 0;
+          for (int k = 1; k < nargin; k++)
+            {
+              x(0) = g;
+              x(1) = 1;
+              x(2) = 0;
 
-	      y(0) = args(k).float_value ();
-	      y(1) = 0;
-	      y(2) = 1;
+              y(0) = args(k).float_value ();
+              y(1) = 0;
+              y(2) = 1;
 
-	      float sgn = signum (y(0));
+              float sgn = signum (y(0));
 
-	      y(0) = std::abs (y(0));
+              y(0) = std::abs (y(0));
 
-	      if (error_state || ! is_integer_value (g))
-		{
-		  error ("gcd: all arguments must be integer");
-		  return retval;
-		}
+              if (error_state || ! is_integer_value (g))
+                {
+                  error ("gcd: all arguments must be integer");
+                  return retval;
+                }
 
-	      while (y(0) > 0)
-		{
-		  FloatRowVector r = x - y * std::floor (x(0) / y(0));
-		  x = y;
-		  y = r;
-		}
+              while (y(0) > 0)
+                {
+                  FloatRowVector r = x - y * std::floor (x(0) / y(0));
+                  x = y;
+                  y = r;
+                }
 
-	      g = x(0);
+              g = x(0);
 
-	      for (int i = 0; i < k; i++) 
-		v(i) *= x(1);
+              for (int i = 0; i < k; i++) 
+                v(i) *= x(1);
 
-	      v(k) = x(2) * sgn;
-	    }
+              v(k) = x(2) * sgn;
+            }
 
-	  retval (1) = v;
-	  retval (0) = g;
-	}
+          retval (1) = v;
+          retval (0) = g;
+        }
       else
-	{
-	  // FIXME -- we need to handle a possible mixture of scalar and
-	  // array values here.
+        {
+          // FIXME -- we need to handle a possible mixture of scalar and
+          // array values here.
 
-	  FloatNDArray g = args(0).float_array_value ();
+          FloatNDArray g = args(0).float_array_value ();
 
-	  OCTAVE_LOCAL_BUFFER (FloatNDArray, v, nargin);
+          OCTAVE_LOCAL_BUFFER (FloatNDArray, v, nargin);
 
-	  int nel = dv.numel ();
+          int nel = dv.numel ();
 
-	  v[0].resize(dv);
+          v[0].resize(dv);
 
-	  for (int i = 0; i < nel; i++)
-	    {
-	      v[0](i) = signum (g(i));
-	      g(i) = std::abs (g(i));
+          for (int i = 0; i < nel; i++)
+            {
+              v[0](i) = signum (g(i));
+              g(i) = std::abs (g(i));
 
-	      if (! is_integer_value (g(i)))
-		{
-		  error ("gcd: all arguments must be integer");
-		  return retval;
-		}
-	    }
+              if (! is_integer_value (g(i)))
+                {
+                  error ("gcd: all arguments must be integer");
+                  return retval;
+                }
+            }
 
-	  FloatRowVector x (3);
-	  FloatRowVector y (3);
+          FloatRowVector x (3);
+          FloatRowVector y (3);
 
-	  for (int k = 1; k < nargin; k++)
-	    {
-	      FloatNDArray gnew = args(k).float_array_value ();
+          for (int k = 1; k < nargin; k++)
+            {
+              FloatNDArray gnew = args(k).float_array_value ();
 
-	      v[k].resize(dv);
+              v[k].resize(dv);
 
-	      for (int n = 0; n < nel; n++)
-		{
-		  x(0) = g(n);
-		  x(1) = 1;
-		  x(2) = 0;
+              for (int n = 0; n < nel; n++)
+                {
+                  x(0) = g(n);
+                  x(1) = 1;
+                  x(2) = 0;
 
-		  y(0) = std::abs (gnew(n));
-		  y(1) = 0;
-		  y(2) = 1; 
+                  y(0) = std::abs (gnew(n));
+                  y(1) = 0;
+                  y(2) = 1; 
 
-		  if (! is_integer_value (y(0)))
-		    {
-		      error ("gcd: all arguments must be integer");
-		      return retval;
-		    }
+                  if (! is_integer_value (y(0)))
+                    {
+                      error ("gcd: all arguments must be integer");
+                      return retval;
+                    }
 
-		  while (y(0) > 0)
-		    {
-		      FloatRowVector r = x - y * std::floor (x(0) / y(0));
-		      x = y;
-		      y = r;
-		    }
+                  while (y(0) > 0)
+                    {
+                      FloatRowVector r = x - y * std::floor (x(0) / y(0));
+                      x = y;
+                      y = r;
+                    }
 
-		  g(n) = x(0);
+                  g(n) = x(0);
 
-		  for (int i = 0; i < k; i++) 
-		    v[i](n) *= x(1);
+                  for (int i = 0; i < k; i++) 
+                    v[i](n) *= x(1);
 
-		  v[k](n) = x(2) * signum (gnew(n));
-		}
-	    }
+                  v[k](n) = x(2) * signum (gnew(n));
+                }
+            }
 
-	  for (int k = 0; k < nargin; k++)
-	    retval(1+k) = v[k];
+          for (int k = 0; k < nargin; k++)
+            retval(1+k) = v[k];
 
-	  retval (0) = g;
-	}
+          retval (0) = g;
+        }
     }
   else if (nargin == 1)
     {
       NDArray gg = args(0).array_value ();
 
       int nel = dv.numel ();
 
       NDArray v (dv);
 
       RowVector x (3);
       RowVector y (3);
 
       double g = std::abs (gg(0));
 
       if (! is_integer_value (g))
-	{
-	  error ("gcd: all arguments must be integer");
-	  return retval;
-	}
+        {
+          error ("gcd: all arguments must be integer");
+          return retval;
+        }
 
       v(0) = signum (gg(0));
       
       for (int k = 1; k < nel; k++)
-	{
-	  x(0) = g;
-	  x(1) = 1;
-	  x(2) = 0;
+        {
+          x(0) = g;
+          x(1) = 1;
+          x(2) = 0;
 
-	  y(0) = std::abs (gg(k));
-	  y(1) = 0;
-	  y(2) = 1;
+          y(0) = std::abs (gg(k));
+          y(1) = 0;
+          y(2) = 1;
 
-	  if (! is_integer_value (y(0)))
-	    {
-	      error ("gcd: all arguments must be integer");
-	      return retval;
-	    }
+          if (! is_integer_value (y(0)))
+            {
+              error ("gcd: all arguments must be integer");
+              return retval;
+            }
 
-	  while (y(0) > 0)
-	    {
-	      RowVector r = x - y * std::floor (x(0) / y(0));
-	      x = y;
-	      y = r;
-	    }
+          while (y(0) > 0)
+            {
+              RowVector r = x - y * std::floor (x(0) / y(0));
+              x = y;
+              y = r;
+            }
 
-	  g = x(0);
+          g = x(0);
 
-	  for (int i = 0; i < k; i++) 
-	    v(i) *= x(1);
+          for (int i = 0; i < k; i++) 
+            v(i) *= x(1);
 
-	  v(k) = x(2) * signum (gg(k));
-	}
+          v(k) = x(2) * signum (gg(k));
+        }
 
       retval (1) = v;
       retval (0) = g;
     }
   else if (all_args_scalar && nargout < 3)
     {
       double g = args(0).double_value ();
 
       if (error_state || ! is_integer_value (g))
-	{
-	  error ("gcd: all arguments must be integer");
-	  return retval;
-	}
+        {
+          error ("gcd: all arguments must be integer");
+          return retval;
+        }
 
       RowVector v (nargin, 0);
       RowVector x (3);
       RowVector y (3);
 
       v(0) = signum (g);
 
       g = std::abs(g);
       
       for (int k = 1; k < nargin; k++)
-	{
-	  x(0) = g;
-	  x(1) = 1;
-	  x(2) = 0;
+        {
+          x(0) = g;
+          x(1) = 1;
+          x(2) = 0;
 
-	  y(0) = args(k).double_value ();
-	  y(1) = 0;
-	  y(2) = 1;
+          y(0) = args(k).double_value ();
+          y(1) = 0;
+          y(2) = 1;
 
-	  double sgn = signum (y(0));
+          double sgn = signum (y(0));
 
-	  y(0) = std::abs (y(0));
+          y(0) = std::abs (y(0));
 
-	  if (error_state || ! is_integer_value (g))
-	    {
-	      error ("gcd: all arguments must be integer");
-	      return retval;
-	    }
+          if (error_state || ! is_integer_value (g))
+            {
+              error ("gcd: all arguments must be integer");
+              return retval;
+            }
 
-	  while (y(0) > 0)
-	    {
-	      RowVector r = x - y * std::floor (x(0) / y(0));
-	      x = y;
-	      y = r;
-	    }
+          while (y(0) > 0)
+            {
+              RowVector r = x - y * std::floor (x(0) / y(0));
+              x = y;
+              y = r;
+            }
 
-	  g = x(0);
+          g = x(0);
 
-	  for (int i = 0; i < k; i++) 
-	    v(i) *= x(1);
+          for (int i = 0; i < k; i++) 
+            v(i) *= x(1);
 
-	  v(k) = x(2) * sgn;
-	}
+          v(k) = x(2) * sgn;
+        }
 
       retval (1) = v;
       retval (0) = g;
     }
   else
     {
       // FIXME -- we need to handle a possible mixture of scalar and
       // array values here.
@@ -443,70 +443,70 @@ all of the values of @var{v1}, @dots{} i
 
       OCTAVE_LOCAL_BUFFER (NDArray, v, nargin);
 
       int nel = dv.numel ();
 
       v[0].resize(dv);
 
       for (int i = 0; i < nel; i++)
-	{
-	  v[0](i) = signum (g(i));
-	  g(i) = std::abs (g(i));
+        {
+          v[0](i) = signum (g(i));
+          g(i) = std::abs (g(i));
 
-	  if (! is_integer_value (g(i)))
-	    {
-	      error ("gcd: all arguments must be integer");
-	      return retval;
-	    }
-	}
+          if (! is_integer_value (g(i)))
+            {
+              error ("gcd: all arguments must be integer");
+              return retval;
+            }
+        }
 
       RowVector x (3);
       RowVector y (3);
 
       for (int k = 1; k < nargin; k++)
-	{
-	  NDArray gnew = args(k).array_value ();
+        {
+          NDArray gnew = args(k).array_value ();
 
-	  v[k].resize(dv);
+          v[k].resize(dv);
 
-	  for (int n = 0; n < nel; n++)
-	    {
-	      x(0) = g(n);
-	      x(1) = 1;
-	      x(2) = 0;
+          for (int n = 0; n < nel; n++)
+            {
+              x(0) = g(n);
+              x(1) = 1;
+              x(2) = 0;
 
-	      y(0) = std::abs (gnew(n));
-	      y(1) = 0;
-	      y(2) = 1; 
+              y(0) = std::abs (gnew(n));
+              y(1) = 0;
+              y(2) = 1; 
 
-	      if (! is_integer_value (y(0)))
-		{
-		  error ("gcd: all arguments must be integer");
-		  return retval;
-		}
+              if (! is_integer_value (y(0)))
+                {
+                  error ("gcd: all arguments must be integer");
+                  return retval;
+                }
 
-	      while (y(0) > 0)
-		{
-		  RowVector r = x - y * std::floor (x(0) / y(0));
-		  x = y;
-		  y = r;
-		}
+              while (y(0) > 0)
+                {
+                  RowVector r = x - y * std::floor (x(0) / y(0));
+                  x = y;
+                  y = r;
+                }
 
-	      g(n) = x(0);
+              g(n) = x(0);
 
-	      for (int i = 0; i < k; i++) 
-		v[i](n) *= x(1);
+              for (int i = 0; i < k; i++) 
+                v[i](n) *= x(1);
 
-	      v[k](n) = x(2) * signum (gnew(n));
-	    }
-	}
+              v[k](n) = x(2) * signum (gnew(n));
+            }
+        }
 
       for (int k = 0; k < nargin; k++)
-	retval(1+k) = v[k];
+        retval(1+k) = v[k];
 
       retval (0) = g;
     }
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -107,29 +107,29 @@ Return the first entry from the group da
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
-	{
-	  if (D_NINT (dval) == dval)
-	    {
-	      gid_t gid = static_cast<gid_t> (dval);
+        {
+          if (D_NINT (dval) == dval)
+            {
+              gid_t gid = static_cast<gid_t> (dval);
 
-	      std::string msg;
+              std::string msg;
 
-	      retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
-	      retval(1) = msg;
-	    }
-	  else
-	    error ("getgrgid: argument must be an integer");
-	}
+              retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
+              retval(1) = msg;
+            }
+          else
+            error ("getgrgid: argument must be an integer");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getgrnam, args, ,
@@ -147,22 +147,22 @@ Return the first entry from the group da
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string msg;
+        {
+          std::string msg;
 
-	  retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
-	  retval(1) = msg;
-	}
+          retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
+          retval(1) = msg;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (setgrent, args, ,
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -111,29 +111,29 @@ database, @code{getpwuid} returns 0.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
-	{
-	  if (D_NINT (dval) == dval)
-	    {
-	      uid_t uid = static_cast<uid_t> (dval);
+        {
+          if (D_NINT (dval) == dval)
+            {
+              uid_t uid = static_cast<uid_t> (dval);
 
-	      std::string msg;
+              std::string msg;
 
-	      retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
-	      retval(1) = msg;
-	    }
-	  else
-	    error ("getpwuid: argument must be an integer");
-	}
+              retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
+              retval(1) = msg;
+            }
+          else
+            error ("getpwuid: argument must be an integer");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getpwnam, args, ,
@@ -151,22 +151,22 @@ database, @code{getpwname} returns 0.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string msg;
+        {
+          std::string msg;
 
-	  retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
-	  retval(1) = msg;
-	}
+          retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
+          retval(1) = msg;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (setpwent, args, ,
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -70,141 +70,141 @@ givens (1, 1)\n\
   if (nargin != 2 || nargout > 2)
     {
       print_usage ();
       return retval;
     }
   else
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
-	{
-	  if (args(0).is_complex_type () || args(1).is_complex_type ())
-	    {
-	      FloatComplex cx = args(0).float_complex_value ();
-	      FloatComplex cy = args(1).float_complex_value ();
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ())
+            {
+              FloatComplex cx = args(0).float_complex_value ();
+              FloatComplex cy = args(1).float_complex_value ();
 
-	      if (! error_state)
-		{
-		  FloatComplexMatrix result = Givens (cx, cy);
+              if (! error_state)
+                {
+                  FloatComplexMatrix result = Givens (cx, cy);
 
-		  if (! error_state)
-		    {
-		      switch (nargout)
-			{
-			case 0:
-			case 1:
-			  retval(0) = result;
-			  break;
+                  if (! error_state)
+                    {
+                      switch (nargout)
+                        {
+                        case 0:
+                        case 1:
+                          retval(0) = result;
+                          break;
    
-			case 2:
-			  retval(1) = result (0, 1);
-			  retval(0) = result (0, 0);
-			  break;
+                        case 2:
+                          retval(1) = result (0, 1);
+                          retval(0) = result (0, 0);
+                          break;
 
-			default:
-			  error ("givens: invalid number of output arguments");
-			  break;
-			}
-		    }
-		}
-	    }
-	  else
-	    {
-	      float x = args(0).float_value ();
-	      float y = args(1).float_value ();
+                        default:
+                          error ("givens: invalid number of output arguments");
+                          break;
+                        }
+                    }
+                }
+            }
+          else
+            {
+              float x = args(0).float_value ();
+              float y = args(1).float_value ();
 
-	      if (! error_state)
-		{
-		  FloatMatrix result = Givens (x, y);
+              if (! error_state)
+                {
+                  FloatMatrix result = Givens (x, y);
 
-		  if (! error_state)
-		    {
-		      switch (nargout)
-			{
-			case 0:
-			case 1:
-			  retval(0) = result;
-			  break;
+                  if (! error_state)
+                    {
+                      switch (nargout)
+                        {
+                        case 0:
+                        case 1:
+                          retval(0) = result;
+                          break;
    
-			case 2:
-			  retval(1) = result (0, 1);
-			  retval(0) = result (0, 0);
-			  break;
+                        case 2:
+                          retval(1) = result (0, 1);
+                          retval(0) = result (0, 0);
+                          break;
 
-			default:
-			  error ("givens: invalid number of output arguments");
-			  break;
-			}
-		    }
-		}
-	    }
-	}
+                        default:
+                          error ("givens: invalid number of output arguments");
+                          break;
+                        }
+                    }
+                }
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type () || args(1).is_complex_type ())
-	    {
-	      Complex cx = args(0).complex_value ();
-	      Complex cy = args(1).complex_value ();
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ())
+            {
+              Complex cx = args(0).complex_value ();
+              Complex cy = args(1).complex_value ();
 
-	      if (! error_state)
-		{
-		  ComplexMatrix result = Givens (cx, cy);
+              if (! error_state)
+                {
+                  ComplexMatrix result = Givens (cx, cy);
 
-		  if (! error_state)
-		    {
-		      switch (nargout)
-			{
-			case 0:
-			case 1:
-			  retval(0) = result;
-			  break;
+                  if (! error_state)
+                    {
+                      switch (nargout)
+                        {
+                        case 0:
+                        case 1:
+                          retval(0) = result;
+                          break;
    
-			case 2:
-			  retval(1) = result (0, 1);
-			  retval(0) = result (0, 0);
-			  break;
+                        case 2:
+                          retval(1) = result (0, 1);
+                          retval(0) = result (0, 0);
+                          break;
 
-			default:
-			  error ("givens: invalid number of output arguments");
-			  break;
-			}
-		    }
-		}
-	    }
-	  else
-	    {
-	      double x = args(0).double_value ();
-	      double y = args(1).double_value ();
+                        default:
+                          error ("givens: invalid number of output arguments");
+                          break;
+                        }
+                    }
+                }
+            }
+          else
+            {
+              double x = args(0).double_value ();
+              double y = args(1).double_value ();
 
-	      if (! error_state)
-		{
-		  Matrix result = Givens (x, y);
+              if (! error_state)
+                {
+                  Matrix result = Givens (x, y);
 
-		  if (! error_state)
-		    {
-		      switch (nargout)
-			{
-			case 0:
-			case 1:
-			  retval(0) = result;
-			  break;
+                  if (! error_state)
+                    {
+                      switch (nargout)
+                        {
+                        case 0:
+                        case 1:
+                          retval(0) = result;
+                          break;
    
-			case 2:
-			  retval(1) = result (0, 1);
-			  retval(0) = result (0, 0);
-			  break;
+                        case 2:
+                          retval(1) = result (0, 1);
+                          retval(0) = result (0, 0);
+                          break;
 
-			default:
-			  error ("givens: invalid number of output arguments");
-			  break;
-			}
-		    }
-		}
-	    }
-	}
+                        default:
+                          error ("givens: invalid number of output arguments");
+                          break;
+                        }
+                    }
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -87,70 +87,70 @@ is upper Hessenberg (@code{i >= j+1 => h
     {
       gripe_square_matrix_required ("hess");
       return retval;
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
-	{
-	 FloatMatrix tmp = arg.float_matrix_value ();
+        {
+         FloatMatrix tmp = arg.float_matrix_value ();
 
-	  if (! error_state)
-	    {
-	      FloatHESS result (tmp);
+          if (! error_state)
+            {
+              FloatHESS result (tmp);
 
-	      retval(1) = result.hess_matrix ();
-	      retval(0) = result.unitary_hess_matrix ();
-	    }
-	}
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
+        {
+          FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-	  if (! error_state)
-	    {
-	      FloatComplexHESS result (ctmp);
+          if (! error_state)
+            {
+              FloatComplexHESS result (ctmp);
 
-	      retval(1) = result.hess_matrix ();
-	      retval(0) = result.unitary_hess_matrix ();
-	    }
-	}
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  Matrix tmp = arg.matrix_value ();
+        {
+          Matrix tmp = arg.matrix_value ();
 
-	  if (! error_state)
-	    {
-	      HESS result (tmp);
+          if (! error_state)
+            {
+              HESS result (tmp);
 
-	      retval(1) = result.hess_matrix ();
-	      retval(0) = result.unitary_hess_matrix ();
-	    }
-	}
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  ComplexMatrix ctmp = arg.complex_matrix_value ();
+        {
+          ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-	  if (! error_state)
-	    {
-	      ComplexHESS result (ctmp);
+          if (! error_state)
+            {
+              ComplexHESS result (ctmp);
 
-	      retval(1) = result.hess_matrix ();
-	      retval(0) = result.unitary_hess_matrix ();
-	    }
-	}
+              retval(1) = result.hess_matrix ();
+              retval(0) = result.unitary_hess_matrix ();
+            }
+        }
       else
-	{
-	  gripe_wrong_type_arg ("hess", arg);
-	}
+        {
+          gripe_wrong_type_arg ("hess", arg);
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!test
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -56,66 +56,66 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 
   if (nargin != 1)
     print_usage ();
   else
     {
       const charMatrix cmat = args(0).char_matrix_value ();
 
       if (cmat.columns () > 16)
-	error ("hex2num: expecting no more than a 16 character string");
+        error ("hex2num: expecting no more than a 16 character string");
       else if (! error_state)
-	{
-	  octave_idx_type nr = cmat.rows ();
-	  octave_idx_type nc = cmat.columns ();
-	  ColumnVector m (nr);
+        {
+          octave_idx_type nr = cmat.rows ();
+          octave_idx_type nc = cmat.columns ();
+          ColumnVector m (nr);
 
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      union
-	      {
-		uint64_t ival;
-		double dval;
-	      } num;
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              union
+              {
+                uint64_t ival;
+                double dval;
+              } num;
 
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  unsigned char ch = cmat.elem (i, j);
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  unsigned char ch = cmat.elem (i, j);
 
-		  if (isxdigit (ch))
-		    {
-		      num.ival <<= 4;
-		      if (ch >= 'a')
-			num.ival += static_cast<uint64_t> (ch - 'a' + 10);
-		      else if (ch >= 'A')
-			num.ival += static_cast<uint64_t> (ch - 'A' + 10);
-		      else
-			num.ival += static_cast<uint64_t> (ch - '0');
-		    }
-		  else
-		    {
-		      error ("hex2num: illegal character found in string");
-		      break;
-		    }
-		}
+                  if (isxdigit (ch))
+                    {
+                      num.ival <<= 4;
+                      if (ch >= 'a')
+                        num.ival += static_cast<uint64_t> (ch - 'a' + 10);
+                      else if (ch >= 'A')
+                        num.ival += static_cast<uint64_t> (ch - 'A' + 10);
+                      else
+                        num.ival += static_cast<uint64_t> (ch - '0');
+                    }
+                  else
+                    {
+                      error ("hex2num: illegal character found in string");
+                      break;
+                    }
+                }
 
-	      if (error_state)
-		break;
-	      else
-		{
-		  if (nc < 16)
-		    num.ival <<= (16 - nc) * 4;
+              if (error_state)
+                break;
+              else
+                {
+                  if (nc < 16)
+                    num.ival <<= (16 - nc) * 4;
 
-		  m(i) = num.dval;
-		}
-	    }
+                  m(i) = num.dval;
+                }
+            }
 
-	  if (! error_state)
-	    retval =  m;
-	}
+          if (! error_state)
+            retval =  m;
+        }
     }
 
   return retval;
 }
 
 /*
 %!assert (hex2num(['c00';'bff';'000';'3ff';'400']),[-2:2]')
 */
@@ -145,46 +145,46 @@ num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
 
   if (nargin != 1)
     print_usage ();
   else
     {
       const ColumnVector v (args(0).vector_value ());
 
       if (! error_state)
-	{
-	  octave_idx_type nr = v.length ();
-	  charMatrix m (nr, 16);
-	  const double *pv = v.fortran_vec ();
+        {
+          octave_idx_type nr = v.length ();
+          charMatrix m (nr, 16);
+          const double *pv = v.fortran_vec ();
 
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      union
-	      {
-		uint64_t ival;
-		double dval;
-	      } num;
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              union
+              {
+                uint64_t ival;
+                double dval;
+              } num;
 
-	      num.dval = *pv++;
+              num.dval = *pv++;
 
-	      for (octave_idx_type j = 0; j < 16; j++)
-		{
-		  unsigned char ch = 
-		    static_cast<char> (num.ival >> ((15 - j) * 4) & 0xF);
-		  if (ch >= 10)
-		    ch += 'a' - 10;
-		  else
-		    ch += '0';
+              for (octave_idx_type j = 0; j < 16; j++)
+                {
+                  unsigned char ch = 
+                    static_cast<char> (num.ival >> ((15 - j) * 4) & 0xF);
+                  if (ch >= 10)
+                    ch += 'a' - 10;
+                  else
+                    ch += '0';
 
-		  m.elem (i, j) = ch;
-		}
-	    }
+                  m.elem (i, j) = ch;
+                }
+            }
 
-	  retval = m;
-	}
+          retval = m;
+        }
     }
 
   return retval;
 }
 
 /*
 %!assert (num2hex (-2:2),['c000000000000000';'bff0000000000000';'0000000000000000';'3ff0000000000000';'4000000000000000'])
 */
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -125,100 +125,100 @@ be avoided.  It is significantly more ac
     {
       rcond = 1.0;
       info = 0;
       result = arg.perm_matrix_value ().inverse ();
     }
   else if (isfloat)
     {
       if (arg.is_real_type ())
-	{
-	  FloatMatrix m = arg.float_matrix_value ();
-	  if (! error_state)
-	    {
-	      MatrixType mattyp = args(0).matrix_type ();
-	      result = m.inverse (mattyp, info, frcond, 1);
-	      args(0).matrix_type (mattyp);
-	    }
-	}
+        {
+          FloatMatrix m = arg.float_matrix_value ();
+          if (! error_state)
+            {
+              MatrixType mattyp = args(0).matrix_type ();
+              result = m.inverse (mattyp, info, frcond, 1);
+              args(0).matrix_type (mattyp);
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  FloatComplexMatrix m = arg.float_complex_matrix_value ();
-	  if (! error_state)
-	    {
-	      MatrixType mattyp = args(0).matrix_type ();
-	      result = m.inverse (mattyp, info, frcond, 1);
-	      args(0).matrix_type (mattyp);
-	    }
-	}
+        {
+          FloatComplexMatrix m = arg.float_complex_matrix_value ();
+          if (! error_state)
+            {
+              MatrixType mattyp = args(0).matrix_type ();
+              result = m.inverse (mattyp, info, frcond, 1);
+              args(0).matrix_type (mattyp);
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  if (arg.is_sparse_type ())
-	    {
-	      SparseMatrix m = arg.sparse_matrix_value ();
-	      if (! error_state)
-		{
-		  MatrixType mattyp = args(0).matrix_type ();
-		  result = m.inverse (mattyp, info, rcond, 1);
-		  args(0).matrix_type (mattyp);
-		}
-	    }
-	  else
-	    {
-	      Matrix m = arg.matrix_value ();
-	      if (! error_state)
-		{
-		  MatrixType mattyp = args(0).matrix_type ();
-		  result = m.inverse (mattyp, info, rcond, 1);
-		  args(0).matrix_type (mattyp);
-		}
-	    }
-	}
+        {
+          if (arg.is_sparse_type ())
+            {
+              SparseMatrix m = arg.sparse_matrix_value ();
+              if (! error_state)
+                {
+                  MatrixType mattyp = args(0).matrix_type ();
+                  result = m.inverse (mattyp, info, rcond, 1);
+                  args(0).matrix_type (mattyp);
+                }
+            }
+          else
+            {
+              Matrix m = arg.matrix_value ();
+              if (! error_state)
+                {
+                  MatrixType mattyp = args(0).matrix_type ();
+                  result = m.inverse (mattyp, info, rcond, 1);
+                  args(0).matrix_type (mattyp);
+                }
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  if (arg.is_sparse_type ())
-	    {
-	      SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
-	      if (! error_state)
-		{
-		  MatrixType mattyp = args(0).matrix_type ();
-		  result = m.inverse (mattyp, info, rcond, 1);
-		  args(0).matrix_type (mattyp);
-		}
-	    }
-	  else
-	    {
-	      ComplexMatrix m = arg.complex_matrix_value ();
-	      if (! error_state)
-		{
-		  MatrixType mattyp = args(0).matrix_type ();
-		  result = m.inverse (mattyp, info, rcond, 1);
-		  args(0).matrix_type (mattyp);
-		}
-	    }
-	}
+        {
+          if (arg.is_sparse_type ())
+            {
+              SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
+              if (! error_state)
+                {
+                  MatrixType mattyp = args(0).matrix_type ();
+                  result = m.inverse (mattyp, info, rcond, 1);
+                  args(0).matrix_type (mattyp);
+                }
+            }
+          else
+            {
+              ComplexMatrix m = arg.complex_matrix_value ();
+              if (! error_state)
+                {
+                  MatrixType mattyp = args(0).matrix_type ();
+                  result = m.inverse (mattyp, info, rcond, 1);
+                  args(0).matrix_type (mattyp);
+                }
+            }
+        }
       else
-	gripe_wrong_type_arg ("inv", arg);
+        gripe_wrong_type_arg ("inv", arg);
     }
 
   if (! error_state)
     {
       if (nargout > 1)
-	retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
+        retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
 
       retval(0) = result;
 
       volatile double xrcond = rcond;
       xrcond += 1.0;
       if (nargout < 2 && (info == -1 || xrcond == 1.0))
-	warning ("inverse: matrix singular to machine precision, rcond = %g", 
-		 rcond);
+        warning ("inverse: matrix singular to machine precision, rcond = %g", 
+                 rcond);
     }
 
   return retval;
 }
 
 /*
 
 %!assert(inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -55,23 +55,23 @@ kron (const Array2<T>& A, const Array2<T
 {
   C.resize (A.rows () * B.rows (), A.columns () * B.columns ());
 
   octave_idx_type Ac, Ar, Cc, Cr;
 
   for (Ac = Cc = 0; Ac < A.columns (); Ac++, Cc += B.columns ())
     for (Ar = Cr = 0; Ar < A.rows (); Ar++, Cr += B.rows ())
       {
-	const T v = A (Ar, Ac);
-	for (octave_idx_type Bc = 0; Bc < B.columns (); Bc++)
-	  for (octave_idx_type Br = 0; Br < B.rows (); Br++)
-	    {
-	      OCTAVE_QUIT;
-	      C.xelem (Cr+Br, Cc+Bc) = v * B.elem (Br, Bc);
-	    }
+        const T v = A (Ar, Ac);
+        for (octave_idx_type Bc = 0; Bc < B.columns (); Bc++)
+          for (octave_idx_type Br = 0; Br < B.rows (); Br++)
+            {
+              OCTAVE_QUIT;
+              C.xelem (Cr+Br, Cc+Bc) = v * B.elem (Br, Bc);
+            }
       }
 }
 
 template void
 kron (const Array2<double>&, const Array2<double>&, Array2<double>&);
 
 template void
 kron (const Array2<Complex>&, const Array2<Complex>&, Array2<Complex>&);
@@ -92,36 +92,36 @@ kron (const Sparse<Complex>&, const Spar
 #endif
 
 template <class T>
 void
 kron (const Sparse<T>& A, const Sparse<T>& B, Sparse<T>& C)
 {
   octave_idx_type idx = 0;
   C = Sparse<T> (A.rows () * B.rows (), A.columns () * B.columns (), 
-		 A.nzmax () * B.nzmax ());
+                 A.nzmax () * B.nzmax ());
 
   C.cidx (0) = 0;
 
   for (octave_idx_type Aj = 0; Aj < A.columns (); Aj++)
     for (octave_idx_type Bj = 0; Bj < B.columns (); Bj++)
       {
-	for (octave_idx_type Ai = A.cidx (Aj); Ai < A.cidx (Aj+1); Ai++)
-	  {
-	    octave_idx_type Ci = A.ridx(Ai) * B.rows ();
-	    const T v = A.data (Ai);
+        for (octave_idx_type Ai = A.cidx (Aj); Ai < A.cidx (Aj+1); Ai++)
+          {
+            octave_idx_type Ci = A.ridx(Ai) * B.rows ();
+            const T v = A.data (Ai);
 
-	    for (octave_idx_type Bi = B.cidx (Bj); Bi < B.cidx (Bj+1); Bi++)
-	      {
-		OCTAVE_QUIT;
-		C.data (idx) = v * B.data (Bi);
-		C.ridx (idx++) = Ci + B.ridx (Bi);
-	      }
-	  }
-	C.cidx (Aj * B.columns () + Bj + 1) = idx;
+            for (octave_idx_type Bi = B.cidx (Bj); Bi < B.cidx (Bj+1); Bi++)
+              {
+                OCTAVE_QUIT;
+                C.data (idx) = v * B.data (Bi);
+                C.ridx (idx++) = Ci + B.ridx (Bi);
+              }
+          }
+        C.cidx (Aj * B.columns () + Bj + 1) = idx;
       }
 }
 
 template void
 kron (const Sparse<double>&, const Sparse<double>&, Sparse<double>&);
 
 template void
 kron (const Sparse<Complex>&, const Sparse<Complex>&, Sparse<Complex>&);
@@ -153,92 +153,92 @@ kron (1:4, ones (3, 1))\n\
 
   if (nargin != 2 || nargout > 1)
     {
       print_usage ();
     }
   else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
-	{
-	  SparseComplexMatrix a (args(0).sparse_complex_matrix_value());
-	  SparseComplexMatrix b (args(1).sparse_complex_matrix_value());
+        {
+          SparseComplexMatrix a (args(0).sparse_complex_matrix_value());
+          SparseComplexMatrix b (args(1).sparse_complex_matrix_value());
 
-	  if (! error_state)
-	    {
-	      SparseComplexMatrix c;
-	      kron (a, b, c);
-	      retval(0) = c;
-	    }
-	}
+          if (! error_state)
+            {
+              SparseComplexMatrix c;
+              kron (a, b, c);
+              retval(0) = c;
+            }
+        }
       else
-	{
-	  SparseMatrix a (args(0).sparse_matrix_value ());
-	  SparseMatrix b (args(1).sparse_matrix_value ());
+        {
+          SparseMatrix a (args(0).sparse_matrix_value ());
+          SparseMatrix b (args(1).sparse_matrix_value ());
 
-	  if (! error_state)
-	    {
-	      SparseMatrix c;
-	      kron (a, b, c);
-	      retval (0) = c;
-	    }
-	}
+          if (! error_state)
+            {
+              SparseMatrix c;
+              kron (a, b, c);
+              retval (0) = c;
+            }
+        }
     }
   else 
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
-	{
-	  if (args(0).is_complex_type () || args(1).is_complex_type ())
-	    {
-	      FloatComplexMatrix a (args(0).float_complex_matrix_value());
-	      FloatComplexMatrix b (args(1).float_complex_matrix_value());
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ())
+            {
+              FloatComplexMatrix a (args(0).float_complex_matrix_value());
+              FloatComplexMatrix b (args(1).float_complex_matrix_value());
 
-	      if (! error_state)
-		{
-		  FloatComplexMatrix c;
-		  kron (a, b, c);
-		  retval(0) = c;
-		}
-	    }
-	  else
-	    {
-	      FloatMatrix a (args(0).float_matrix_value ());
-	      FloatMatrix b (args(1).float_matrix_value ());
+              if (! error_state)
+                {
+                  FloatComplexMatrix c;
+                  kron (a, b, c);
+                  retval(0) = c;
+                }
+            }
+          else
+            {
+              FloatMatrix a (args(0).float_matrix_value ());
+              FloatMatrix b (args(1).float_matrix_value ());
 
-	      if (! error_state)
-		{
-		  FloatMatrix c;
-		  kron (a, b, c);
-		  retval (0) = c;
-		}
-	    }
-	}
+              if (! error_state)
+                {
+                  FloatMatrix c;
+                  kron (a, b, c);
+                  retval (0) = c;
+                }
+            }
+        }
       else
-	{
-	  if (args(0).is_complex_type () || args(1).is_complex_type ())
-	    {
-	      ComplexMatrix a (args(0).complex_matrix_value());
-	      ComplexMatrix b (args(1).complex_matrix_value());
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ())
+            {
+              ComplexMatrix a (args(0).complex_matrix_value());
+              ComplexMatrix b (args(1).complex_matrix_value());
 
-	      if (! error_state)
-		{
-		  ComplexMatrix c;
-		  kron (a, b, c);
-		  retval(0) = c;
-		}
-	    }
-	  else
-	    {
-	      Matrix a (args(0).matrix_value ());
-	      Matrix b (args(1).matrix_value ());
+              if (! error_state)
+                {
+                  ComplexMatrix c;
+                  kron (a, b, c);
+                  retval(0) = c;
+                }
+            }
+          else
+            {
+              Matrix a (args(0).matrix_value ());
+              Matrix b (args(1).matrix_value ());
 
-	      if (! error_state)
-		{
-		  Matrix c;
-		  kron (a, b, c);
-		  retval (0) = c;
-		}
-	    }
-	}
+              if (! error_state)
+                {
+                  Matrix c;
+                  kron (a, b, c);
+                  retval (0) = c;
+                }
+            }
+        }
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "ov.h"
 
 static
 bool
 contains_char (const std::string& str, char c)
 {
   return (str.find (c) != std::string::npos 
-	  || str.find (std::toupper (c)) != std::string::npos);
+          || str.find (std::toupper (c)) != std::string::npos);
 }
 
 // case-insensitive character comparison functors
 struct icmp_char_lt : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
     { return std::toupper (x) < std::toupper (y); }
 };
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -69,36 +69,36 @@ lsode_user_function (const ColumnVector&
   args(1) = t;
   args(0) = x;
 
   if (lsode_fcn)
     {
       octave_value_list tmp = lsode_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("lsode");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("lsode");
+          return retval;
+        }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("lsode: ignoring imaginary part returned from user-supplied function");
-	      warned_fcn_imaginary = true;
-	    }
+        {
+          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("lsode: ignoring imaginary part returned from user-supplied function");
+              warned_fcn_imaginary = true;
+            }
 
-	  retval = ColumnVector (tmp(0).vector_value ());
+          retval = ColumnVector (tmp(0).vector_value ());
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("lsode");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("lsode");
+        }
       else
-	gripe_user_supplied_eval ("lsode");
+        gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 Matrix
 lsode_user_jacobian (const ColumnVector& x, double t)
 {
@@ -108,36 +108,36 @@ lsode_user_jacobian (const ColumnVector&
   args(1) = t;
   args(0) = x;
 
   if (lsode_jac)
     {
       octave_value_list tmp = lsode_jac->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  gripe_user_supplied_eval ("lsode");
-	  return retval;
-	}
+        {
+          gripe_user_supplied_eval ("lsode");
+          return retval;
+        }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
-	{
-	  if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
-	      warned_jac_imaginary = true;
-	    }
+        {
+          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
+              warned_jac_imaginary = true;
+            }
 
-	  retval = tmp(0).matrix_value ();
+          retval = tmp(0).matrix_value ();
 
-	  if (error_state || retval.length () == 0)
-	    gripe_user_supplied_eval ("lsode");
-	}
+          if (error_state || retval.length () == 0)
+            gripe_user_supplied_eval ("lsode");
+        }
       else
-	gripe_user_supplied_eval ("lsode");
+        gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 #define LSODE_ABORT() \
   return retval
  
@@ -289,186 +289,186 @@ parameters for @code{lsode}.\n\
     {
       std::string fcn_name, fname, jac_name, jname;
       lsode_fcn = 0;
       lsode_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
-  	{
-	  Cell c = f_arg.cell_value ();
-	  if (c.length() == 1)
-	    f_arg = c(0);
-	  else if (c.length() == 2)
-	    {
-	      if (c(0).is_function_handle () || c(0).is_inline_function ())
-		lsode_fcn = c(0).function_value ();
-	      else
-		{
-		  fcn_name = unique_symbol_name ("__lsode_fcn__");
-		  fname = "function y = ";
-		  fname.append (fcn_name);
-		  fname.append (" (x, t) y = ");
-		  lsode_fcn = extract_function
-		    (c(0), "lsode", fcn_name, fname, "; endfunction");
-		}
-	      
-	      if (lsode_fcn)
-		{
-		  if (c(1).is_function_handle () || c(1).is_inline_function ())
-		    lsode_jac = c(1).function_value ();
-		  else
-		    {
-			jac_name = unique_symbol_name ("__lsode_jac__");
-			jname = "function jac = ";
-			jname.append(jac_name);
-			jname.append (" (x, t) jac = ");
-			lsode_jac = extract_function
-			  (c(1), "lsode", jac_name, jname, "; endfunction");
+        {
+          Cell c = f_arg.cell_value ();
+          if (c.length() == 1)
+            f_arg = c(0);
+          else if (c.length() == 2)
+            {
+              if (c(0).is_function_handle () || c(0).is_inline_function ())
+                lsode_fcn = c(0).function_value ();
+              else
+                {
+                  fcn_name = unique_symbol_name ("__lsode_fcn__");
+                  fname = "function y = ";
+                  fname.append (fcn_name);
+                  fname.append (" (x, t) y = ");
+                  lsode_fcn = extract_function
+                    (c(0), "lsode", fcn_name, fname, "; endfunction");
+                }
+              
+              if (lsode_fcn)
+                {
+                  if (c(1).is_function_handle () || c(1).is_inline_function ())
+                    lsode_jac = c(1).function_value ();
+                  else
+                    {
+                        jac_name = unique_symbol_name ("__lsode_jac__");
+                        jname = "function jac = ";
+                        jname.append(jac_name);
+                        jname.append (" (x, t) jac = ");
+                        lsode_jac = extract_function
+                          (c(1), "lsode", jac_name, jname, "; endfunction");
 
-		      if (!lsode_jac)
-			{
-			  if (fcn_name.length())
-			    clear_function (fcn_name);
-			  lsode_fcn = 0;
-			}
-		    }
-		}
-	    }
-	  else
-	    LSODE_ABORT1 ("incorrect number of elements in cell array");
-	}
+                      if (!lsode_jac)
+                        {
+                          if (fcn_name.length())
+                            clear_function (fcn_name);
+                          lsode_fcn = 0;
+                        }
+                    }
+                }
+            }
+          else
+            LSODE_ABORT1 ("incorrect number of elements in cell array");
+        }
 
       if (!lsode_fcn && ! f_arg.is_cell())
-	{
-	  if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-	    lsode_fcn = f_arg.function_value ();
-	  else
-	    {
-	      switch (f_arg.rows ())
-		{
-		case 1:
-		  do
-		    {
-		      fcn_name = unique_symbol_name ("__lsode_fcn__");
-		      fname = "function y = ";
-		      fname.append (fcn_name);
-		      fname.append (" (x, t) y = ");
-		      lsode_fcn = extract_function
-			(f_arg, "lsode", fcn_name, fname, "; endfunction");
-		    }
-		  while (0);
-		  break;
+        {
+          if (f_arg.is_function_handle () || f_arg.is_inline_function ())
+            lsode_fcn = f_arg.function_value ();
+          else
+            {
+              switch (f_arg.rows ())
+                {
+                case 1:
+                  do
+                    {
+                      fcn_name = unique_symbol_name ("__lsode_fcn__");
+                      fname = "function y = ";
+                      fname.append (fcn_name);
+                      fname.append (" (x, t) y = ");
+                      lsode_fcn = extract_function
+                        (f_arg, "lsode", fcn_name, fname, "; endfunction");
+                    }
+                  while (0);
+                  break;
 
-		case 2:
-		  {
-		    string_vector tmp = f_arg.all_strings ();
+                case 2:
+                  {
+                    string_vector tmp = f_arg.all_strings ();
 
-		    if (! error_state)
-		      {
-			fcn_name = unique_symbol_name ("__lsode_fcn__");
-			fname = "function y = ";
-			fname.append (fcn_name);
-			fname.append (" (x, t) y = ");
-			lsode_fcn = extract_function
-			  (tmp(0), "lsode", fcn_name, fname, "; endfunction");
+                    if (! error_state)
+                      {
+                        fcn_name = unique_symbol_name ("__lsode_fcn__");
+                        fname = "function y = ";
+                        fname.append (fcn_name);
+                        fname.append (" (x, t) y = ");
+                        lsode_fcn = extract_function
+                          (tmp(0), "lsode", fcn_name, fname, "; endfunction");
 
-			if (lsode_fcn)
-			  {
-			    jac_name = unique_symbol_name ("__lsode_jac__");
-			    jname = "function jac = ";
-			    jname.append(jac_name);
-			    jname.append (" (x, t) jac = ");
-			    lsode_jac = extract_function
-			      (tmp(1), "lsode", jac_name, jname,
-			      "; endfunction");
+                        if (lsode_fcn)
+                          {
+                            jac_name = unique_symbol_name ("__lsode_jac__");
+                            jname = "function jac = ";
+                            jname.append(jac_name);
+                            jname.append (" (x, t) jac = ");
+                            lsode_jac = extract_function
+                              (tmp(1), "lsode", jac_name, jname,
+                              "; endfunction");
 
-			    if (!lsode_jac)
-			      {
-				if (fcn_name.length())
-				  clear_function (fcn_name);
-				lsode_fcn = 0;
-			      }
-			  }
-		      }
-		  }
-		  break;
+                            if (!lsode_jac)
+                              {
+                                if (fcn_name.length())
+                                  clear_function (fcn_name);
+                                lsode_fcn = 0;
+                              }
+                          }
+                      }
+                  }
+                  break;
 
-		default:
-		  LSODE_ABORT1
-		    ("first arg should be a string or 2-element string array");
-		}
-	    }
-	}
+                default:
+                  LSODE_ABORT1
+                    ("first arg should be a string or 2-element string array");
+                }
+            }
+        }
 
       if (error_state || ! lsode_fcn)
-	LSODE_ABORT ();
+        LSODE_ABORT ();
 
       ColumnVector state (args(1).vector_value ());
 
       if (error_state)
-	LSODE_ABORT1 ("expecting state vector as second argument");
+        LSODE_ABORT1 ("expecting state vector as second argument");
 
       ColumnVector out_times (args(2).vector_value ());
 
       if (error_state)
-	LSODE_ABORT1 ("expecting output time vector as third argument");
+        LSODE_ABORT1 ("expecting output time vector as third argument");
 
       ColumnVector crit_times;
 
       int crit_times_set = 0;
       if (nargin > 3)
-	{
-	  crit_times = ColumnVector (args(3).vector_value ());
+        {
+          crit_times = ColumnVector (args(3).vector_value ());
 
-	  if (error_state)
-	    LSODE_ABORT1 ("expecting critical time vector as fourth argument");
+          if (error_state)
+            LSODE_ABORT1 ("expecting critical time vector as fourth argument");
 
-	  crit_times_set = 1;
-	}
+          crit_times_set = 1;
+        }
 
       double tzero = out_times (0);
 
       ODEFunc func (lsode_user_function);
       if (lsode_jac)
-	func.set_jacobian_function (lsode_user_jacobian);
+        func.set_jacobian_function (lsode_user_jacobian);
 
       LSODE ode (state, tzero, func);
 
       ode.set_options (lsode_opts);
 
       Matrix output;
       if (crit_times_set)
-	output = ode.integrate (out_times, crit_times);
+        output = ode.integrate (out_times, crit_times);
       else
-	output = ode.integrate (out_times);
+        output = ode.integrate (out_times);
 
       if (fcn_name.length())
-	clear_function (fcn_name);
+        clear_function (fcn_name);
       if (jac_name.length())
-	clear_function (jac_name);
+        clear_function (jac_name);
 
       if (! error_state)
-	{
-	  std::string msg = ode.error_message ();
+        {
+          std::string msg = ode.error_message ();
 
-	  retval(2) = msg;
-	  retval(1) = static_cast<double> (ode.integration_state ());
+          retval(2) = msg;
+          retval(1) = static_cast<double> (ode.integration_state ());
 
-	  if (ode.integration_ok ())
-	    retval(0) = output;
-	  else
-	    {
-	      retval(0) = Matrix ();
+          if (ode.integration_ok ())
+            retval(0) = output;
+          else
+            {
+              retval(0) = Matrix ();
 
-	      if (nargout < 2)
-		error ("lsode: %s", msg.c_str ());
-	    }
-	}
+              if (nargout < 2)
+                error ("lsode: %s", msg.c_str ());
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -151,381 +151,381 @@ information.\n\
 
   bool vecout = false;
   Matrix thres;
 
   int n = 1;
   while (n < nargin && ! error_state)
     {
       if (args (n).is_string ())
-	{
-	  std::string tmp = args(n++).string_value ();
+        {
+          std::string tmp = args(n++).string_value ();
 
-	  if (! error_state )
-	    {
-	      if (tmp.compare ("vector") == 0)
-		vecout = true;
-	      else
-		error ("lu: unrecognized string argument");
-	    }
-	}
+          if (! error_state )
+            {
+              if (tmp.compare ("vector") == 0)
+                vecout = true;
+              else
+                error ("lu: unrecognized string argument");
+            }
+        }
       else
-	{
-	  Matrix tmp = args(n++).matrix_value ();
+        {
+          Matrix tmp = args(n++).matrix_value ();
 
-	  if (! error_state )
-	    {
-	      if (!issparse)
-		error ("lu: can not define pivoting threshold for full matrices");
-	      else if (tmp.nelem () == 1)
-		{
-		  thres.resize(1,2);
-		  thres(0) = tmp(0);
-		  thres(1) = tmp(0);
-		}
-	      else if (tmp.nelem () == 2)
-		thres = tmp;
-	      else
-		error ("lu: expecting 2 element vector for thres");
-	    }
-	}
+          if (! error_state )
+            {
+              if (!issparse)
+                error ("lu: can not define pivoting threshold for full matrices");
+              else if (tmp.nelem () == 1)
+                {
+                  thres.resize(1,2);
+                  thres(0) = tmp(0);
+                  thres(1) = tmp(0);
+                }
+              else if (tmp.nelem () == 2)
+                thres = tmp;
+              else
+                error ("lu: expecting 2 element vector for thres");
+            }
+        }
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("lu", nr, nc);
 
   if (issparse)
     {
       if (arg_is_empty < 0)
-	return retval;
+        return retval;
       else if (arg_is_empty > 0)
-	return octave_value_list (5, SparseMatrix ());
+        return octave_value_list (5, SparseMatrix ());
 
       ColumnVector Qinit;
       if (nargout < 4)
-	{
-	  Qinit.resize (nc);
-	  for (octave_idx_type i = 0; i < nc; i++)
-	    Qinit (i) = i;
-	}
+        {
+          Qinit.resize (nc);
+          for (octave_idx_type i = 0; i < nc; i++)
+            Qinit (i) = i;
+        }
 
       if (arg.is_real_type ())
-	{
-	  SparseMatrix m = arg.sparse_matrix_value ();
+        {
+          SparseMatrix m = arg.sparse_matrix_value ();
 
-	  switch (nargout)
-	    {
-	    case 0:
-	    case 1:
-	    case 2:
-	      {
-		SparseLU fact (m, Qinit, thres, false, true);
+          switch (nargout)
+            {
+            case 0:
+            case 1:
+            case 2:
+              {
+                SparseLU fact (m, Qinit, thres, false, true);
 
-		if (nargout < 2)
-		  retval (0) = fact.Y ();
-		else
-		  {
-		    PermMatrix P = fact.Pr_mat ();
-		    SparseMatrix L = P.transpose () * fact.L ();
-		    retval(1) = octave_value (fact.U (), 
-					      MatrixType (MatrixType::Upper));
+                if (nargout < 2)
+                  retval (0) = fact.Y ();
+                else
+                  {
+                    PermMatrix P = fact.Pr_mat ();
+                    SparseMatrix L = P.transpose () * fact.L ();
+                    retval(1) = octave_value (fact.U (), 
+                                              MatrixType (MatrixType::Upper));
 
-		    retval(0) = octave_value (L, 
-			MatrixType (MatrixType::Permuted_Lower, 
-				    nr, fact.row_perm ()));
-		  }
-	      }
-	      break;
+                    retval(0) = octave_value (L, 
+                        MatrixType (MatrixType::Permuted_Lower, 
+                                    nr, fact.row_perm ()));
+                  }
+              }
+              break;
 
-	    case 3:
-	      {
-		SparseLU fact (m, Qinit, thres, false, true);
+            case 3:
+              {
+                SparseLU fact (m, Qinit, thres, false, true);
 
-		if (vecout)
-		  retval (2) = fact.Pr_vec ();
-		else
-		  retval(2) = fact.Pr_mat ();
+                if (vecout)
+                  retval (2) = fact.Pr_vec ();
+                else
+                  retval(2) = fact.Pr_mat ();
 
-		retval(1) = octave_value (fact.U (), 
-					  MatrixType (MatrixType::Upper));
-		retval(0) = octave_value (fact.L (), 
-					  MatrixType (MatrixType::Lower));
-	      }
-	      break;
+                retval(1) = octave_value (fact.U (), 
+                                          MatrixType (MatrixType::Upper));
+                retval(0) = octave_value (fact.L (), 
+                                          MatrixType (MatrixType::Lower));
+              }
+              break;
 
-	    case 4:
-	    default:
-	      {
-		SparseLU fact (m, thres, scale);
+            case 4:
+            default:
+              {
+                SparseLU fact (m, thres, scale);
 
-		if (scale)
-		  retval(4) = fact.R ();
+                if (scale)
+                  retval(4) = fact.R ();
 
-		if (vecout)
-		  {
-		    retval(3) = fact.Pc_vec ();
-		    retval(2) = fact.Pr_vec ();
-		  }
-		else
-		  {
-		    retval(3) = fact.Pc_mat ();
-		    retval(2) = fact.Pr_mat ();
-		  }
-		retval(1) = octave_value (fact.U (), 
-					  MatrixType (MatrixType::Upper));
-		retval(0) = octave_value (fact.L (), 
-					  MatrixType (MatrixType::Lower));
-	      }
-	      break;
-	    }
-	}
+                if (vecout)
+                  {
+                    retval(3) = fact.Pc_vec ();
+                    retval(2) = fact.Pr_vec ();
+                  }
+                else
+                  {
+                    retval(3) = fact.Pc_mat ();
+                    retval(2) = fact.Pr_mat ();
+                  }
+                retval(1) = octave_value (fact.U (), 
+                                          MatrixType (MatrixType::Upper));
+                retval(0) = octave_value (fact.L (), 
+                                          MatrixType (MatrixType::Lower));
+              }
+              break;
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
+        {
+          SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-	  switch (nargout)
-	    {
-	    case 0:
-	    case 1:
-	    case 2:
-	      {
-		SparseComplexLU fact (m, Qinit, thres, false, true);
+          switch (nargout)
+            {
+            case 0:
+            case 1:
+            case 2:
+              {
+                SparseComplexLU fact (m, Qinit, thres, false, true);
 
-		if (nargout < 2)
-		  retval (0) = fact.Y ();
-		else
-		  {
-		    PermMatrix P = fact.Pr_mat ();
-		    SparseComplexMatrix L = P.transpose () * fact.L ();
-		    retval(1) = octave_value (fact.U (), 
-					      MatrixType (MatrixType::Upper));
+                if (nargout < 2)
+                  retval (0) = fact.Y ();
+                else
+                  {
+                    PermMatrix P = fact.Pr_mat ();
+                    SparseComplexMatrix L = P.transpose () * fact.L ();
+                    retval(1) = octave_value (fact.U (), 
+                                              MatrixType (MatrixType::Upper));
 
-		    retval(0) = octave_value (L, 
-			MatrixType (MatrixType::Permuted_Lower, 
-				    nr, fact.row_perm ()));
-		  }
-	      }
-	      break;
+                    retval(0) = octave_value (L, 
+                        MatrixType (MatrixType::Permuted_Lower, 
+                                    nr, fact.row_perm ()));
+                  }
+              }
+              break;
 
-	    case 3:
-	      {
-		SparseComplexLU fact (m, Qinit, thres, false, true);
+            case 3:
+              {
+                SparseComplexLU fact (m, Qinit, thres, false, true);
 
-		if (vecout)
-		  retval (2) = fact.Pr_vec ();
-		else
-		  retval(2) = fact.Pr_mat ();
+                if (vecout)
+                  retval (2) = fact.Pr_vec ();
+                else
+                  retval(2) = fact.Pr_mat ();
 
-		retval(1) = octave_value (fact.U (), 
-					  MatrixType (MatrixType::Upper));
-		retval(0) = octave_value (fact.L (), 
-					  MatrixType (MatrixType::Lower));
-	      }
-	      break;
+                retval(1) = octave_value (fact.U (), 
+                                          MatrixType (MatrixType::Upper));
+                retval(0) = octave_value (fact.L (), 
+                                          MatrixType (MatrixType::Lower));
+              }
+              break;
 
-	    case 4:
-	    default:
-	      {
-		SparseComplexLU fact (m, thres, scale);
+            case 4:
+            default:
+              {
+                SparseComplexLU fact (m, thres, scale);
 
-		if (scale)
-		  retval(4) = fact.R ();
+                if (scale)
+                  retval(4) = fact.R ();
 
-		if (vecout)
-		  {
-		    retval(3) = fact.Pc_vec ();
-		    retval(2) = fact.Pr_vec ();
-		  }
-		else
-		  {
-		    retval(3) = fact.Pc_mat ();
-		    retval(2) = fact.Pr_mat ();
-		  }
-		retval(1) = octave_value (fact.U (), 
-					  MatrixType (MatrixType::Upper));
-		retval(0) = octave_value (fact.L (), 
-					  MatrixType (MatrixType::Lower));
-	      }
-	      break;
-	    }
-	}
+                if (vecout)
+                  {
+                    retval(3) = fact.Pc_vec ();
+                    retval(2) = fact.Pr_vec ();
+                  }
+                else
+                  {
+                    retval(3) = fact.Pc_mat ();
+                    retval(2) = fact.Pr_mat ();
+                  }
+                retval(1) = octave_value (fact.U (), 
+                                          MatrixType (MatrixType::Upper));
+                retval(0) = octave_value (fact.L (), 
+                                          MatrixType (MatrixType::Lower));
+              }
+              break;
+            }
+        }
       else
-	gripe_wrong_type_arg ("lu", arg);
+        gripe_wrong_type_arg ("lu", arg);
     }
   else
     {
       if (arg_is_empty < 0)
-	return retval;
+        return retval;
       else if (arg_is_empty > 0)
-	return octave_value_list (3, Matrix ());
+        return octave_value_list (3, Matrix ());
 
       if (arg.is_real_type ())
-	{
-	  if (arg.is_single_type ())
-	    {
-	      FloatMatrix m = arg.float_matrix_value ();
+        {
+          if (arg.is_single_type ())
+            {
+              FloatMatrix m = arg.float_matrix_value ();
 
-	      if (! error_state)
-		{
-		  FloatLU fact (m);
+              if (! error_state)
+                {
+                  FloatLU fact (m);
 
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      retval(0) = fact.Y ();
-		      break;
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      retval(0) = fact.Y ();
+                      break;
 
-		    case 2:
-		      {
-			PermMatrix P = fact.P ();
-			FloatMatrix L = P.transpose () * fact.L ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = L;
-		      }
-		      break;
+                    case 2:
+                      {
+                        PermMatrix P = fact.P ();
+                        FloatMatrix L = P.transpose () * fact.L ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = L;
+                      }
+                      break;
 
-		    case 3:
-		    default:
-		      {
-			if (vecout)
-			  retval(2) = fact.P_vec ();
-			else
-			  retval(2) = fact.P ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = get_lu_l (fact);
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else
-	    {
-	      Matrix m = arg.matrix_value ();
+                    case 3:
+                    default:
+                      {
+                        if (vecout)
+                          retval(2) = fact.P_vec ();
+                        else
+                          retval(2) = fact.P ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = get_lu_l (fact);
+                      }
+                      break;
+                    }
+                }
+            }
+          else
+            {
+              Matrix m = arg.matrix_value ();
 
-	      if (! error_state)
-		{
-		  LU fact (m);
+              if (! error_state)
+                {
+                  LU fact (m);
 
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      retval(0) = fact.Y ();
-		      break;
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      retval(0) = fact.Y ();
+                      break;
 
-		    case 2:
-		      {
-			PermMatrix P = fact.P ();
-			Matrix L = P.transpose () * fact.L ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = L;
-		      }
-		      break;
+                    case 2:
+                      {
+                        PermMatrix P = fact.P ();
+                        Matrix L = P.transpose () * fact.L ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = L;
+                      }
+                      break;
 
-		    case 3:
-		    default:
-		      {
-			if (vecout)
-			  retval(2) = fact.P_vec ();
-			else
-			  retval(2) = fact.P ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = get_lu_l (fact);
-		      }
-		      break;
-		    }
-		}
-	    }
-	}
+                    case 3:
+                    default:
+                      {
+                        if (vecout)
+                          retval(2) = fact.P_vec ();
+                        else
+                          retval(2) = fact.P ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = get_lu_l (fact);
+                      }
+                      break;
+                    }
+                }
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  if (arg.is_single_type ())
-	    {
-	      FloatComplexMatrix m = arg.float_complex_matrix_value ();
+        {
+          if (arg.is_single_type ())
+            {
+              FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  FloatComplexLU fact (m);
+              if (! error_state)
+                {
+                  FloatComplexLU fact (m);
 
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      retval(0) = fact.Y ();
-		      break;
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      retval(0) = fact.Y ();
+                      break;
 
-		    case 2:
-		      {
-			PermMatrix P = fact.P ();
-			FloatComplexMatrix L = P.transpose () * fact.L ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = L;
-		      }
-		      break;
+                    case 2:
+                      {
+                        PermMatrix P = fact.P ();
+                        FloatComplexMatrix L = P.transpose () * fact.L ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = L;
+                      }
+                      break;
 
-		    case 3:
-		    default:
-		      {
-			if (vecout)
-			  retval(2) = fact.P_vec ();
-			else
-			  retval(2) = fact.P ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = get_lu_l (fact);
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else
-	    {
-	      ComplexMatrix m = arg.complex_matrix_value ();
+                    case 3:
+                    default:
+                      {
+                        if (vecout)
+                          retval(2) = fact.P_vec ();
+                        else
+                          retval(2) = fact.P ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = get_lu_l (fact);
+                      }
+                      break;
+                    }
+                }
+            }
+          else
+            {
+              ComplexMatrix m = arg.complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  ComplexLU fact (m);
+              if (! error_state)
+                {
+                  ComplexLU fact (m);
 
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      retval(0) = fact.Y ();
-		      break;
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      retval(0) = fact.Y ();
+                      break;
 
-		    case 2:
-		      {
-			PermMatrix P = fact.P ();
-			ComplexMatrix L = P.transpose () * fact.L ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = L;
-		      }
-		      break;
+                    case 2:
+                      {
+                        PermMatrix P = fact.P ();
+                        ComplexMatrix L = P.transpose () * fact.L ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = L;
+                      }
+                      break;
 
-		    case 3:
-		    default:
-		      {
-			if (vecout)
-			  retval(2) = fact.P_vec ();
-			else
-			  retval(2) = fact.P ();
-			retval(1) = get_lu_u (fact);
-			retval(0) = get_lu_l (fact);
-		      }
-		      break;
-		    }
-		}
-	    }
-	}
+                    case 3:
+                    default:
+                      {
+                        if (vecout)
+                          retval(2) = fact.P_vec ();
+                        else
+                          retval(2) = fact.P ();
+                        retval(1) = get_lu_u (fact);
+                        retval(0) = get_lu_l (fact);
+                      }
+                      break;
+                    }
+                }
+            }
+        }
       else
-	gripe_wrong_type_arg ("lu", arg);
+        gripe_wrong_type_arg ("lu", arg);
     }
 
   return retval;
 }
 
 /*
 
 %!assert(lu ([1, 2; 3, 4]), [3, 4; 1/3, 2/3], eps);
@@ -657,107 +657,107 @@ the factorization from scratch.\n\
     {
       if (check_lu_dims (argl, argu, argp))
         {
           PermMatrix P = (pivoted 
                           ? argp.perm_matrix_value () 
                           : PermMatrix::eye (argl.rows ()));
 
           if (argl.is_real_type () 
-	      && argu.is_real_type () 
-	      && argx.is_real_type () 
-	      && argy.is_real_type ())
+              && argu.is_real_type () 
+              && argx.is_real_type () 
+              && argy.is_real_type ())
             {
-	      // all real case
-	      if (argl.is_single_type () 
-		  || argu.is_single_type () 
-		  || argx.is_single_type () 
-		  || argy.is_single_type ())
-		{
-		  FloatMatrix L = argl.float_matrix_value ();
-		  FloatMatrix U = argu.float_matrix_value ();
-		  FloatMatrix x = argx.float_matrix_value ();
-		  FloatMatrix y = argy.float_matrix_value ();
+              // all real case
+              if (argl.is_single_type () 
+                  || argu.is_single_type () 
+                  || argx.is_single_type () 
+                  || argy.is_single_type ())
+                {
+                  FloatMatrix L = argl.float_matrix_value ();
+                  FloatMatrix U = argu.float_matrix_value ();
+                  FloatMatrix x = argx.float_matrix_value ();
+                  FloatMatrix y = argy.float_matrix_value ();
 
-		  FloatLU fact (L, U, P);
+                  FloatLU fact (L, U, P);
                   if (pivoted)
                     fact.update_piv (x, y);
                   else
                     fact.update (x, y);
 
                   if (pivoted)
                     retval(2) = fact.P ();
-		  retval(1) = get_lu_u (fact);
-		  retval(0) = get_lu_l (fact);
-		}
-	      else
-		{
-		  Matrix L = argl.matrix_value ();
-		  Matrix U = argu.matrix_value ();
-		  Matrix x = argx.matrix_value ();
-		  Matrix y = argy.matrix_value ();
+                  retval(1) = get_lu_u (fact);
+                  retval(0) = get_lu_l (fact);
+                }
+              else
+                {
+                  Matrix L = argl.matrix_value ();
+                  Matrix U = argu.matrix_value ();
+                  Matrix x = argx.matrix_value ();
+                  Matrix y = argy.matrix_value ();
 
-		  LU fact (L, U, P);
+                  LU fact (L, U, P);
                   if (pivoted)
                     fact.update_piv (x, y);
                   else
                     fact.update (x, y);
 
                   if (pivoted)
                     retval(2) = fact.P ();
-		  retval(1) = get_lu_u (fact);
-		  retval(0) = get_lu_l (fact);
-		}
+                  retval(1) = get_lu_u (fact);
+                  retval(0) = get_lu_l (fact);
+                }
             }
           else
             {
               // complex case
-	      if (argl.is_single_type () 
-		  || argu.is_single_type () 
-		  || argx.is_single_type () 
-		  || argy.is_single_type ())
-		{
-		  FloatComplexMatrix L = argl.float_complex_matrix_value ();
-		  FloatComplexMatrix U = argu.float_complex_matrix_value ();
-		  FloatComplexMatrix x = argx.float_complex_matrix_value ();
-		  FloatComplexMatrix y = argy.float_complex_matrix_value ();
+              if (argl.is_single_type () 
+                  || argu.is_single_type () 
+                  || argx.is_single_type () 
+                  || argy.is_single_type ())
+                {
+                  FloatComplexMatrix L = argl.float_complex_matrix_value ();
+                  FloatComplexMatrix U = argu.float_complex_matrix_value ();
+                  FloatComplexMatrix x = argx.float_complex_matrix_value ();
+                  FloatComplexMatrix y = argy.float_complex_matrix_value ();
 
-		  FloatComplexLU fact (L, U, P);
+                  FloatComplexLU fact (L, U, P);
                   if (pivoted)
                     fact.update_piv (x, y);
                   else
                     fact.update (x, y);
               
                   if (pivoted)
                     retval(2) = fact.P ();
-		  retval(1) = get_lu_u (fact);
-		  retval(0) = get_lu_l (fact);
-		}
-	      else
-		{
-		  ComplexMatrix L = argl.complex_matrix_value ();
-		  ComplexMatrix U = argu.complex_matrix_value ();
-		  ComplexMatrix x = argx.complex_matrix_value ();
-		  ComplexMatrix y = argy.complex_matrix_value ();
+                  retval(1) = get_lu_u (fact);
+                  retval(0) = get_lu_l (fact);
+                }
+              else
+                {
+                  ComplexMatrix L = argl.complex_matrix_value ();
+                  ComplexMatrix U = argu.complex_matrix_value ();
+                  ComplexMatrix x = argx.complex_matrix_value ();
+                  ComplexMatrix y = argy.complex_matrix_value ();
 
-		  ComplexLU fact (L, U, P);
+                  ComplexLU fact (L, U, P);
                   if (pivoted)
                     fact.update_piv (x, y);
                   else
                     fact.update (x, y);
               
                   if (pivoted)
                     retval(2) = fact.P ();
-		  retval(1) = get_lu_u (fact);
-		  retval(0) = get_lu_l (fact);
-		}
+                  retval(1) = get_lu_u (fact);
+                  retval(0) = get_lu_l (fact);
+                }
             }
         }
       else
-	error ("luupdate: dimensions mismatch");
+        error ("luupdate: dimensions mismatch");
     }
   else
     error ("luupdate: expecting numeric arguments");
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -108,245 +108,245 @@ Given the string argument 'vector', @dfn
       bool zero_level = false;
       bool milu = false;
       bool udiag = false;
       Matrix thresh;
       double droptol = -1.;
       bool vecout;
 
       if (args(1).is_string ())
-	{
-	  if (args(1).string_value () == "0")
-	    zero_level = true;
-	  else
-	    error ("luinc: unrecognized string argument");
-	}
+        {
+          if (args(1).string_value () == "0")
+            zero_level = true;
+          else
+            error ("luinc: unrecognized string argument");
+        }
       else if (args(1).is_map ())
-	{
-	  Octave_map map = args(1).map_value ();
+        {
+          Octave_map map = args(1).map_value ();
 
-	  if (map.contains ("droptol"))
-	    droptol = map.contents ("droptol")(0).double_value ();
+          if (map.contains ("droptol"))
+            droptol = map.contents ("droptol")(0).double_value ();
 
-	  if (map.contains ("milu"))
-	    {
-	      double tmp = map.contents ("milu")(0).double_value ();
+          if (map.contains ("milu"))
+            {
+              double tmp = map.contents ("milu")(0).double_value ();
 
-	      milu = (tmp == 0. ? false : true);
-	    }
+              milu = (tmp == 0. ? false : true);
+            }
 
-	  if (map.contains ("udiag"))
-	    {
-	      double tmp = map.contents ("udiag")(0).double_value ();
+          if (map.contains ("udiag"))
+            {
+              double tmp = map.contents ("udiag")(0).double_value ();
 
-	      udiag = (tmp == 0. ? false : true);
-	    }
+              udiag = (tmp == 0. ? false : true);
+            }
 
-	  if (map.contains ("thresh"))
-	    {
-	      thresh = map.contents ("thresh")(0).matrix_value ();
+          if (map.contains ("thresh"))
+            {
+              thresh = map.contents ("thresh")(0).matrix_value ();
 
-	      if (thresh.nelem () == 1)
-		{
-		  thresh.resize(1,2);
-		  thresh(1) = thresh(0);
-		}
-	      else if (thresh.nelem () != 2)
-		error ("chol: expecting 2 element vector for thresh");
-	    }
-	}
+              if (thresh.nelem () == 1)
+                {
+                  thresh.resize(1,2);
+                  thresh(1) = thresh(0);
+                }
+              else if (thresh.nelem () != 2)
+                error ("chol: expecting 2 element vector for thresh");
+            }
+        }
       else
-	droptol = args(1).double_value ();
+        droptol = args(1).double_value ();
 
       if (nargin == 3)
-	{
-	  std::string tmp = args(2).string_value ();
+        {
+          std::string tmp = args(2).string_value ();
 
-	  if (! error_state )
-	    {
-	      if (tmp.compare ("vector") == 0)
-		vecout = true;
-	      else
-		error ("luinc: unrecognized string argument");
-	    }
-	}
+          if (! error_state )
+            {
+              if (tmp.compare ("vector") == 0)
+                vecout = true;
+              else
+                error ("luinc: unrecognized string argument");
+            }
+        }
 
       // FIXME Add code for zero-level factorization
       if (zero_level)
-	error ("luinc: zero-level factorization not implemented");
+        error ("luinc: zero-level factorization not implemented");
 
       if (!error_state)
-	{
-	  if (args(0).type_name () == "sparse matrix") 
-	    {
-	      SparseMatrix sm = args(0).sparse_matrix_value ();
-	      octave_idx_type sm_nr = sm.rows ();
-	      octave_idx_type sm_nc = sm.cols ();
-	      ColumnVector Qinit (sm_nc);
+        {
+          if (args(0).type_name () == "sparse matrix") 
+            {
+              SparseMatrix sm = args(0).sparse_matrix_value ();
+              octave_idx_type sm_nr = sm.rows ();
+              octave_idx_type sm_nc = sm.cols ();
+              ColumnVector Qinit (sm_nc);
 
-	      for (octave_idx_type i = 0; i < sm_nc; i++)
-		Qinit (i) = i;
+              for (octave_idx_type i = 0; i < sm_nc; i++)
+                Qinit (i) = i;
 
-	      if (! error_state)
-		{
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		    case 2:
-		      {
-			SparseLU fact (sm, Qinit, thresh, false, true, droptol,
-				       milu, udiag);
+              if (! error_state)
+                {
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                    case 2:
+                      {
+                        SparseLU fact (sm, Qinit, thresh, false, true, droptol,
+                                       milu, udiag);
 
-			if (! error_state)
-			  {
-			    SparseMatrix P = fact.Pr ();
-			    SparseMatrix L = P.transpose () * fact.L ();
-			    retval(1) = octave_value (fact.U (),
-						      MatrixType (MatrixType::Upper));
-			    retval(0) = octave_value (L, MatrixType 
-						      (MatrixType::Permuted_Lower, 
-						       sm_nr, fact.row_perm ()));
-			  }
-		      }
-		      break;
+                        if (! error_state)
+                          {
+                            SparseMatrix P = fact.Pr ();
+                            SparseMatrix L = P.transpose () * fact.L ();
+                            retval(1) = octave_value (fact.U (),
+                                                      MatrixType (MatrixType::Upper));
+                            retval(0) = octave_value (L, MatrixType 
+                                                      (MatrixType::Permuted_Lower, 
+                                                       sm_nr, fact.row_perm ()));
+                          }
+                      }
+                      break;
 
-		    case 3:
-		      {
-			SparseLU fact (sm, Qinit, thresh, false, true, droptol,
-				       milu, udiag);
+                    case 3:
+                      {
+                        SparseLU fact (sm, Qinit, thresh, false, true, droptol,
+                                       milu, udiag);
 
-			if (! error_state)
-			  {
-			    if (vecout)
-			      retval(2) = fact.Pr_vec ();
-			    else
-			      retval(2) = fact.Pr ();
-			    retval(1) = octave_value (fact.U (),
-						      MatrixType (MatrixType::Upper));
-			    retval(0) = octave_value (fact.L (),
-						      MatrixType (MatrixType::Lower));
-			  }
-		      }
-		      break;
+                        if (! error_state)
+                          {
+                            if (vecout)
+                              retval(2) = fact.Pr_vec ();
+                            else
+                              retval(2) = fact.Pr ();
+                            retval(1) = octave_value (fact.U (),
+                                                      MatrixType (MatrixType::Upper));
+                            retval(0) = octave_value (fact.L (),
+                                                      MatrixType (MatrixType::Lower));
+                          }
+                      }
+                      break;
 
-		    case 4:
-		    default:
-		      {
-			SparseLU fact (sm, Qinit, thresh, false, false, droptol,
-				       milu, udiag);
+                    case 4:
+                    default:
+                      {
+                        SparseLU fact (sm, Qinit, thresh, false, false, droptol,
+                                       milu, udiag);
 
-			if (! error_state)
-			  {
-			    if (vecout)
-			      {
-				retval(3) = fact.Pc_vec ();
-				retval(2) = fact.Pr_vec ();
-			      }
-			    else
-			      {
-				retval(3) = fact.Pc ();
-				retval(2) = fact.Pr ();
-			      }
-			    retval(1) = octave_value (fact.U (),
-						      MatrixType (MatrixType::Upper));
-			    retval(0) = octave_value (fact.L (),
-						      MatrixType (MatrixType::Lower));
-			  }
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else if (args(0).type_name () == "sparse complex matrix") 
-	    {
-	      SparseComplexMatrix sm = 
-		args(0).sparse_complex_matrix_value ();
-	      octave_idx_type sm_nr = sm.rows ();
-	      octave_idx_type sm_nc = sm.cols ();
-	      ColumnVector Qinit (sm_nc);
+                        if (! error_state)
+                          {
+                            if (vecout)
+                              {
+                                retval(3) = fact.Pc_vec ();
+                                retval(2) = fact.Pr_vec ();
+                              }
+                            else
+                              {
+                                retval(3) = fact.Pc ();
+                                retval(2) = fact.Pr ();
+                              }
+                            retval(1) = octave_value (fact.U (),
+                                                      MatrixType (MatrixType::Upper));
+                            retval(0) = octave_value (fact.L (),
+                                                      MatrixType (MatrixType::Lower));
+                          }
+                      }
+                      break;
+                    }
+                }
+            }
+          else if (args(0).type_name () == "sparse complex matrix") 
+            {
+              SparseComplexMatrix sm = 
+                args(0).sparse_complex_matrix_value ();
+              octave_idx_type sm_nr = sm.rows ();
+              octave_idx_type sm_nc = sm.cols ();
+              ColumnVector Qinit (sm_nc);
 
-	      for (octave_idx_type i = 0; i < sm_nc; i++)
-		Qinit (i) = i;
+              for (octave_idx_type i = 0; i < sm_nc; i++)
+                Qinit (i) = i;
 
-	      if (! error_state)
-		{
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		    case 2:
-		      {
-			SparseComplexLU fact (sm, Qinit, thresh, false, true, 
-					      droptol, milu, udiag);
+              if (! error_state)
+                {
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                    case 2:
+                      {
+                        SparseComplexLU fact (sm, Qinit, thresh, false, true, 
+                                              droptol, milu, udiag);
 
 
-			if (! error_state)
-			  {
-			    SparseMatrix P = fact.Pr ();
-			    SparseComplexMatrix L = P.transpose () * fact.L ();
-			    retval(1) = octave_value (fact.U (),
-						      MatrixType (MatrixType::Upper));
-			    retval(0) = octave_value (L, MatrixType 
-						      (MatrixType::Permuted_Lower, 
-						       sm_nr, fact.row_perm ()));
-			  }
-		      }
-		      break;
+                        if (! error_state)
+                          {
+                            SparseMatrix P = fact.Pr ();
+                            SparseComplexMatrix L = P.transpose () * fact.L ();
+                            retval(1) = octave_value (fact.U (),
+                                                      MatrixType (MatrixType::Upper));
+                            retval(0) = octave_value (L, MatrixType 
+                                                      (MatrixType::Permuted_Lower, 
+                                                       sm_nr, fact.row_perm ()));
+                          }
+                      }
+                      break;
 
-		    case 3:
-		      {
-			SparseComplexLU fact (sm, Qinit, thresh, false, true,
-					      droptol, milu, udiag);
+                    case 3:
+                      {
+                        SparseComplexLU fact (sm, Qinit, thresh, false, true,
+                                              droptol, milu, udiag);
 
-			if (! error_state)
-			  {
-			    if (vecout)
-			      retval(2) = fact.Pr_vec ();
-			    else
-			      retval(2) = fact.Pr ();
-			    retval(1) = octave_value (fact.U (),
-						      MatrixType (MatrixType::Upper));
-			    retval(0) = octave_value (fact.L (),
-						      MatrixType (MatrixType::Lower));
-			  }
-		      }
-		      break;
+                        if (! error_state)
+                          {
+                            if (vecout)
+                              retval(2) = fact.Pr_vec ();
+                            else
+                              retval(2) = fact.Pr ();
+                            retval(1) = octave_value (fact.U (),
+                                                      MatrixType (MatrixType::Upper));
+                            retval(0) = octave_value (fact.L (),
+                                                      MatrixType (MatrixType::Lower));
+                          }
+                      }
+                      break;
 
-		    case 4:
-		    default:
-		      {
-			SparseComplexLU fact (sm, Qinit, thresh, false, false,
-					      droptol, milu, udiag);
+                    case 4:
+                    default:
+                      {
+                        SparseComplexLU fact (sm, Qinit, thresh, false, false,
+                                              droptol, milu, udiag);
 
-			if (! error_state)
-			  {
-			    if (vecout)
-			      {
-				retval(3) = fact.Pc_vec ();
-				retval(2) = fact.Pr_vec ();
-			      }
-			    else
-			      {
-				retval(3) = fact.Pc ();
-				retval(2) = fact.Pr ();
-			      }
-			    retval(1) = octave_value (fact.U (),
-						      MatrixType (MatrixType::Upper));
-			    retval(0) = octave_value (fact.L (),
-						      MatrixType (MatrixType::Lower));
-			  }
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else
-	    error ("luinc: first argument must be sparse");
-	}
+                        if (! error_state)
+                          {
+                            if (vecout)
+                              {
+                                retval(3) = fact.Pc_vec ();
+                                retval(2) = fact.Pr_vec ();
+                              }
+                            else
+                              {
+                                retval(3) = fact.Pc ();
+                                retval(2) = fact.Pr ();
+                              }
+                            retval(1) = octave_value (fact.U (),
+                                                      MatrixType (MatrixType::Upper));
+                            retval(0) = octave_value (fact.L (),
+                                                      MatrixType (MatrixType::Lower));
+                          }
+                      }
+                      break;
+                    }
+                }
+            }
+          else
+            error ("luinc: first argument must be sparse");
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!testif HAVE_UMFPACK
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -124,388 +124,388 @@ classification of the matrix.\n\
       bool autocomp = true;
       if (nargin == 2 && args(1).is_string () && args(1).string_value () == "nocompute")
         {
           nargin = 1;
           autocomp = false;
         }
 
       if (args(0).is_scalar_type())
-	{
-	  if (nargin == 1)
-	    retval = octave_value ("Diagonal");
-	  else
-	    retval = args(0);
-	}
+        {
+          if (nargin == 1)
+            retval = octave_value ("Diagonal");
+          else
+            retval = args(0);
+        }
       else if (args(0).is_sparse_type ())
-	{
-	  if (nargin == 1)
-	    {
-	      MatrixType mattyp;
+        {
+          if (nargin == 1)
+            {
+              MatrixType mattyp;
 
-	      if (args(0).is_complex_type ()) 
-		{
-		  mattyp = args(0).matrix_type ();
+              if (args(0).is_complex_type ()) 
+                {
+                  mattyp = args(0).matrix_type ();
 
-		  if (mattyp.is_unknown () && autocomp )
-		    {
-		      SparseComplexMatrix m = 
-			args(0).sparse_complex_matrix_value ();
-		      if (!error_state)
-			{
-			  mattyp = MatrixType (m);
-			  args(0).matrix_type (mattyp);
-			}
-		    }
-		}
-	      else
-		{
-		  mattyp = args(0).matrix_type ();
+                  if (mattyp.is_unknown () && autocomp )
+                    {
+                      SparseComplexMatrix m = 
+                        args(0).sparse_complex_matrix_value ();
+                      if (!error_state)
+                        {
+                          mattyp = MatrixType (m);
+                          args(0).matrix_type (mattyp);
+                        }
+                    }
+                }
+              else
+                {
+                  mattyp = args(0).matrix_type ();
 
-		  if (mattyp.is_unknown () && autocomp)
-		    {
-		      SparseMatrix m = args(0).sparse_matrix_value ();
-		      if (!error_state)
-			{
-			  mattyp = MatrixType (m);
-			  args(0).matrix_type (mattyp);
-			}
-		    }
-		}
+                  if (mattyp.is_unknown () && autocomp)
+                    {
+                      SparseMatrix m = args(0).sparse_matrix_value ();
+                      if (!error_state)
+                        {
+                          mattyp = MatrixType (m);
+                          args(0).matrix_type (mattyp);
+                        }
+                    }
+                }
 
-	      int typ = mattyp.type ();
+              int typ = mattyp.type ();
 
-	      if (typ == MatrixType::Diagonal)
-		retval = octave_value ("Diagonal");
-	      else if (typ == MatrixType::Permuted_Diagonal)
-		retval = octave_value ("Permuted Diagonal");
-	      else if (typ == MatrixType::Upper)
-		retval = octave_value ("Upper");
-	      else if (typ == MatrixType::Permuted_Upper)
-		retval = octave_value ("Permuted Upper");
-	      else if (typ == MatrixType::Lower)
-		retval = octave_value ("Lower");
-	      else if (typ == MatrixType::Permuted_Lower)
-		retval = octave_value ("Permuted Lower");
-	      else if (typ == MatrixType::Banded)
-		retval = octave_value ("Banded");
-	      else if (typ == MatrixType::Banded_Hermitian)
-		retval = octave_value ("Banded Positive Definite");
-	      else if (typ == MatrixType::Tridiagonal)
-		retval = octave_value ("Tridiagonal");
-	      else if (typ == MatrixType::Tridiagonal_Hermitian)
-		retval = octave_value ("Tridiagonal Positive Definite");
-	      else if (typ == MatrixType::Hermitian)
-		retval = octave_value ("Positive Definite");
-	      else if (typ == MatrixType::Rectangular)
-		{
-		  if (args(0).rows() == args(0).columns())
-		    retval = octave_value ("Singular");
-		  else
-		    retval = octave_value ("Rectangular");
-		}
-	      else if (typ == MatrixType::Full)
-		retval = octave_value ("Full");
-	      else
-		retval = octave_value ("Unknown");
-	    }
-	  else
-	    {
-	      // Ok, we're changing the matrix type
-	      std::string str_typ = args(1).string_value ();
+              if (typ == MatrixType::Diagonal)
+                retval = octave_value ("Diagonal");
+              else if (typ == MatrixType::Permuted_Diagonal)
+                retval = octave_value ("Permuted Diagonal");
+              else if (typ == MatrixType::Upper)
+                retval = octave_value ("Upper");
+              else if (typ == MatrixType::Permuted_Upper)
+                retval = octave_value ("Permuted Upper");
+              else if (typ == MatrixType::Lower)
+                retval = octave_value ("Lower");
+              else if (typ == MatrixType::Permuted_Lower)
+                retval = octave_value ("Permuted Lower");
+              else if (typ == MatrixType::Banded)
+                retval = octave_value ("Banded");
+              else if (typ == MatrixType::Banded_Hermitian)
+                retval = octave_value ("Banded Positive Definite");
+              else if (typ == MatrixType::Tridiagonal)
+                retval = octave_value ("Tridiagonal");
+              else if (typ == MatrixType::Tridiagonal_Hermitian)
+                retval = octave_value ("Tridiagonal Positive Definite");
+              else if (typ == MatrixType::Hermitian)
+                retval = octave_value ("Positive Definite");
+              else if (typ == MatrixType::Rectangular)
+                {
+                  if (args(0).rows() == args(0).columns())
+                    retval = octave_value ("Singular");
+                  else
+                    retval = octave_value ("Rectangular");
+                }
+              else if (typ == MatrixType::Full)
+                retval = octave_value ("Full");
+              else
+                retval = octave_value ("Unknown");
+            }
+          else
+            {
+              // Ok, we're changing the matrix type
+              std::string str_typ = args(1).string_value ();
 
-	      // FIXME -- why do I have to explicitly call the constructor?
-	      MatrixType mattyp = MatrixType ();
+              // FIXME -- why do I have to explicitly call the constructor?
+              MatrixType mattyp = MatrixType ();
 
-	      octave_idx_type nl = 0;
-	      octave_idx_type nu = 0;
-	      
-	      if (error_state)
-		error ("Matrix type must be a string");
-	      else
-		{
-		  // Use STL function to convert to lower case
-		  std::transform (str_typ.begin (), str_typ.end (),
-				  str_typ.begin (), tolower);
+              octave_idx_type nl = 0;
+              octave_idx_type nu = 0;
+              
+              if (error_state)
+                error ("Matrix type must be a string");
+              else
+                {
+                  // Use STL function to convert to lower case
+                  std::transform (str_typ.begin (), str_typ.end (),
+                                  str_typ.begin (), tolower);
 
-		  if (str_typ == "diagonal")
-		    mattyp.mark_as_diagonal ();
-		  if (str_typ == "permuted diagonal")
-		    mattyp.mark_as_permuted_diagonal ();
-		  else if (str_typ == "upper")
-		    mattyp.mark_as_upper_triangular ();
-		  else if (str_typ == "lower")
-		    mattyp.mark_as_lower_triangular ();
-		  else if (str_typ == "banded" || str_typ == "banded positive definite")
-		    {
-		      if (nargin != 4)
-			error ("matrix_type: banded matrix type requires 4 arguments");
-		      else
-			{
-			  nl = args(2).nint_value ();
-			  nu = args(3).nint_value ();
+                  if (str_typ == "diagonal")
+                    mattyp.mark_as_diagonal ();
+                  if (str_typ == "permuted diagonal")
+                    mattyp.mark_as_permuted_diagonal ();
+                  else if (str_typ == "upper")
+                    mattyp.mark_as_upper_triangular ();
+                  else if (str_typ == "lower")
+                    mattyp.mark_as_lower_triangular ();
+                  else if (str_typ == "banded" || str_typ == "banded positive definite")
+                    {
+                      if (nargin != 4)
+                        error ("matrix_type: banded matrix type requires 4 arguments");
+                      else
+                        {
+                          nl = args(2).nint_value ();
+                          nu = args(3).nint_value ();
 
-			  if (error_state)
-			    error ("matrix_type: band size must be integer");
-			  else
-			    {
-			      if (nl == 1 && nu == 1)
-				mattyp.mark_as_tridiagonal ();
-			      else
-				mattyp.mark_as_banded (nu, nl);
-			      
-			      if (str_typ == "banded positive definite")
-				mattyp.mark_as_symmetric ();
-			    }
-			}
-		    }
-		  else if (str_typ == "positive definite")
-		    {
-		      mattyp.mark_as_full ();
-		      mattyp.mark_as_symmetric ();
-		    }
-		  else if (str_typ == "singular")
-		    mattyp.mark_as_rectangular ();
-		  else if (str_typ == "full")
-		    mattyp.mark_as_full ();
-		  else if (str_typ == "unknown")
-		    mattyp.invalidate_type ();
-		  else
-		    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+                          if (error_state)
+                            error ("matrix_type: band size must be integer");
+                          else
+                            {
+                              if (nl == 1 && nu == 1)
+                                mattyp.mark_as_tridiagonal ();
+                              else
+                                mattyp.mark_as_banded (nu, nl);
+                              
+                              if (str_typ == "banded positive definite")
+                                mattyp.mark_as_symmetric ();
+                            }
+                        }
+                    }
+                  else if (str_typ == "positive definite")
+                    {
+                      mattyp.mark_as_full ();
+                      mattyp.mark_as_symmetric ();
+                    }
+                  else if (str_typ == "singular")
+                    mattyp.mark_as_rectangular ();
+                  else if (str_typ == "full")
+                    mattyp.mark_as_full ();
+                  else if (str_typ == "unknown")
+                    mattyp.invalidate_type ();
+                  else
+                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
 
-		  if (! error_state)
-		    {
-		      if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
-			{
-			  const ColumnVector perm = 
-			    ColumnVector (args (2).vector_value ());
+                  if (! error_state)
+                    {
+                      if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
+                        {
+                          const ColumnVector perm = 
+                            ColumnVector (args (2).vector_value ());
 
-			  if (error_state)
-			    error ("matrix_type: Invalid permutation vector");
-			  else
-			    {
-			      octave_idx_type len = perm.length ();
-			      dim_vector dv = args(0).dims ();
-			      
-			      if (len != dv(0))
-				error ("matrix_type: Invalid permutation vector");
-			      else
-				{
-				  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                          if (error_state)
+                            error ("matrix_type: Invalid permutation vector");
+                          else
+                            {
+                              octave_idx_type len = perm.length ();
+                              dim_vector dv = args(0).dims ();
+                              
+                              if (len != dv(0))
+                                error ("matrix_type: Invalid permutation vector");
+                              else
+                                {
+                                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-				  for (octave_idx_type i = 0; i < len; i++)
-				    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
+                                  for (octave_idx_type i = 0; i < len; i++)
+                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
 
-				  if (str_typ == "upper")
-				    mattyp.mark_as_permuted (len, p);
-				  else
-				    mattyp.mark_as_permuted (len, p);
-				}
-			    }
-			}
-		      else if (nargin != 2 && str_typ != "banded positive definite" &&
-			       str_typ != "banded")
-			error ("matrix_type: Invalid number of arguments");
+                                  if (str_typ == "upper")
+                                    mattyp.mark_as_permuted (len, p);
+                                  else
+                                    mattyp.mark_as_permuted (len, p);
+                                }
+                            }
+                        }
+                      else if (nargin != 2 && str_typ != "banded positive definite" &&
+                               str_typ != "banded")
+                        error ("matrix_type: Invalid number of arguments");
 
-		      if (! error_state)
-			{
-			  // Set the matrix type
-			  if (args(0).is_complex_type ())
-			    retval = 
-			      octave_value (args(0).sparse_complex_matrix_value (), 
-					    mattyp);
-			  else
-			    retval = octave_value (args(0).sparse_matrix_value (), 
-						   mattyp);
-			}
-		    }
-		}
-	    }
-	}
+                      if (! error_state)
+                        {
+                          // Set the matrix type
+                          if (args(0).is_complex_type ())
+                            retval = 
+                              octave_value (args(0).sparse_complex_matrix_value (), 
+                                            mattyp);
+                          else
+                            retval = octave_value (args(0).sparse_matrix_value (), 
+                                                   mattyp);
+                        }
+                    }
+                }
+            }
+        }
       else
-	{
-	  if (nargin == 1)
-	    {
-	      MatrixType mattyp;
+        {
+          if (nargin == 1)
+            {
+              MatrixType mattyp;
 
-	      if (args(0).is_complex_type ())
-		{
-		  mattyp = args(0).matrix_type ();
+              if (args(0).is_complex_type ())
+                {
+                  mattyp = args(0).matrix_type ();
 
-		  if (mattyp.is_unknown () && autocomp)
-		    {
-		      if (args(0).is_single_type ())
-			{
-			  FloatComplexMatrix m = args(0).float_complex_matrix_value ();
-			  if (!error_state)
-			    {
-			      mattyp = MatrixType (m);
-			      args(0).matrix_type (mattyp);
-			    }
-			}
-		      else
-			{
-			  ComplexMatrix m = args(0).complex_matrix_value ();
-			  if (!error_state)
-			    {
-			      mattyp = MatrixType (m);
-			      args(0).matrix_type (mattyp);
-			    }
-			}
-		    }
-		}
-	      else
-		{
-		  mattyp = args(0).matrix_type ();
+                  if (mattyp.is_unknown () && autocomp)
+                    {
+                      if (args(0).is_single_type ())
+                        {
+                          FloatComplexMatrix m = args(0).float_complex_matrix_value ();
+                          if (!error_state)
+                            {
+                              mattyp = MatrixType (m);
+                              args(0).matrix_type (mattyp);
+                            }
+                        }
+                      else
+                        {
+                          ComplexMatrix m = args(0).complex_matrix_value ();
+                          if (!error_state)
+                            {
+                              mattyp = MatrixType (m);
+                              args(0).matrix_type (mattyp);
+                            }
+                        }
+                    }
+                }
+              else
+                {
+                  mattyp = args(0).matrix_type ();
 
-		  if (mattyp.is_unknown () && autocomp)
-		    {
-		      if (args(0).is_single_type ())
-			{
-			  FloatMatrix m = args(0).float_matrix_value ();
-			  if (!error_state)
-			    {
-			      mattyp = MatrixType (m);
-			      args(0).matrix_type (mattyp);
-			    }
-			}
-		      else
-			{
-			  Matrix m = args(0).matrix_value ();
-			  if (!error_state)
-			    {
-			      mattyp = MatrixType (m);
-			      args(0).matrix_type (mattyp);
-			    }
-			}
-		    }
-		}
+                  if (mattyp.is_unknown () && autocomp)
+                    {
+                      if (args(0).is_single_type ())
+                        {
+                          FloatMatrix m = args(0).float_matrix_value ();
+                          if (!error_state)
+                            {
+                              mattyp = MatrixType (m);
+                              args(0).matrix_type (mattyp);
+                            }
+                        }
+                      else
+                        {
+                          Matrix m = args(0).matrix_value ();
+                          if (!error_state)
+                            {
+                              mattyp = MatrixType (m);
+                              args(0).matrix_type (mattyp);
+                            }
+                        }
+                    }
+                }
 
-	      int typ = mattyp.type ();
+              int typ = mattyp.type ();
 
-	      if (typ == MatrixType::Upper)
-		retval = octave_value ("Upper");
-	      else if (typ == MatrixType::Permuted_Upper)
-		retval = octave_value ("Permuted Upper");
-	      else if (typ == MatrixType::Lower)
-		retval = octave_value ("Lower");
-	      else if (typ == MatrixType::Permuted_Lower)
-		retval = octave_value ("Permuted Lower");
-	      else if (typ == MatrixType::Hermitian)
-		retval = octave_value ("Positive Definite");
-	      else if (typ == MatrixType::Rectangular)
-		{
-		  if (args(0).rows() == args(0).columns())
-		    retval = octave_value ("Singular");
-		  else
-		    retval = octave_value ("Rectangular");
-		}
-	      else if (typ == MatrixType::Full)
-		retval = octave_value ("Full");
-	      else
-		retval = octave_value ("Unknown");
-	    }
-	  else
-	    {
-	      // Ok, we're changing the matrix type
-	      std::string str_typ = args(1).string_value ();
+              if (typ == MatrixType::Upper)
+                retval = octave_value ("Upper");
+              else if (typ == MatrixType::Permuted_Upper)
+                retval = octave_value ("Permuted Upper");
+              else if (typ == MatrixType::Lower)
+                retval = octave_value ("Lower");
+              else if (typ == MatrixType::Permuted_Lower)
+                retval = octave_value ("Permuted Lower");
+              else if (typ == MatrixType::Hermitian)
+                retval = octave_value ("Positive Definite");
+              else if (typ == MatrixType::Rectangular)
+                {
+                  if (args(0).rows() == args(0).columns())
+                    retval = octave_value ("Singular");
+                  else
+                    retval = octave_value ("Rectangular");
+                }
+              else if (typ == MatrixType::Full)
+                retval = octave_value ("Full");
+              else
+                retval = octave_value ("Unknown");
+            }
+          else
+            {
+              // Ok, we're changing the matrix type
+              std::string str_typ = args(1).string_value ();
 
-	      // FIXME -- why do I have to explicitly call the constructor?
-	      MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
+              // FIXME -- why do I have to explicitly call the constructor?
+              MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
 
-	      if (error_state)
-		error ("Matrix type must be a string");
-	      else
-		{
-		  // Use STL function to convert to lower case
-		  std::transform (str_typ.begin (), str_typ.end (),
-				  str_typ.begin (), tolower);
+              if (error_state)
+                error ("Matrix type must be a string");
+              else
+                {
+                  // Use STL function to convert to lower case
+                  std::transform (str_typ.begin (), str_typ.end (),
+                                  str_typ.begin (), tolower);
 
-		  if (str_typ == "upper")
-		    mattyp.mark_as_upper_triangular ();
-		  else if (str_typ == "lower")
-		    mattyp.mark_as_lower_triangular ();
-		  else if (str_typ == "positive definite")
-		    {
-		      mattyp.mark_as_full ();
-		      mattyp.mark_as_symmetric ();
-		    }
-		  else if (str_typ == "singular")
-		    mattyp.mark_as_rectangular ();
-		  else if (str_typ == "full")
-		    mattyp.mark_as_full ();
-		  else if (str_typ == "unknown")
-		    mattyp.invalidate_type ();
-		  else
-		    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+                  if (str_typ == "upper")
+                    mattyp.mark_as_upper_triangular ();
+                  else if (str_typ == "lower")
+                    mattyp.mark_as_lower_triangular ();
+                  else if (str_typ == "positive definite")
+                    {
+                      mattyp.mark_as_full ();
+                      mattyp.mark_as_symmetric ();
+                    }
+                  else if (str_typ == "singular")
+                    mattyp.mark_as_rectangular ();
+                  else if (str_typ == "full")
+                    mattyp.mark_as_full ();
+                  else if (str_typ == "unknown")
+                    mattyp.invalidate_type ();
+                  else
+                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
 
-		  if (! error_state)
-		    {
-		      if (nargin == 3 && (str_typ == "upper" 
-					  || str_typ == "lower"))
-			{
-			  const ColumnVector perm = 
-			    ColumnVector (args (2).vector_value ());
+                  if (! error_state)
+                    {
+                      if (nargin == 3 && (str_typ == "upper" 
+                                          || str_typ == "lower"))
+                        {
+                          const ColumnVector perm = 
+                            ColumnVector (args (2).vector_value ());
 
-			  if (error_state)
-			    error ("matrix_type: Invalid permutation vector");
-			  else
-			    {
-			      octave_idx_type len = perm.length ();
-			      dim_vector dv = args(0).dims ();
-			      
-			      if (len != dv(0))
-				error ("matrix_type: Invalid permutation vector");
-			      else
-				{
-				  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                          if (error_state)
+                            error ("matrix_type: Invalid permutation vector");
+                          else
+                            {
+                              octave_idx_type len = perm.length ();
+                              dim_vector dv = args(0).dims ();
+                              
+                              if (len != dv(0))
+                                error ("matrix_type: Invalid permutation vector");
+                              else
+                                {
+                                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-				  for (octave_idx_type i = 0; i < len; i++)
-				    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
+                                  for (octave_idx_type i = 0; i < len; i++)
+                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
 
-				  if (str_typ == "upper")
-				    mattyp.mark_as_permuted (len, p);
-				  else
-				    mattyp.mark_as_permuted (len, p);
-				}
-			    }
-			}
-		      else if (nargin != 2)
-			error ("matrix_type: Invalid number of arguments");
+                                  if (str_typ == "upper")
+                                    mattyp.mark_as_permuted (len, p);
+                                  else
+                                    mattyp.mark_as_permuted (len, p);
+                                }
+                            }
+                        }
+                      else if (nargin != 2)
+                        error ("matrix_type: Invalid number of arguments");
 
-		      if (! error_state)
-			{
-			  // Set the matrix type
-			  if (args(0).is_single_type ())
-			    {
-			      if (args(0).is_complex_type())
-				retval = octave_value 
-				  (args(0).float_complex_matrix_value (), 
-				   mattyp);
-			      else
-				retval = octave_value 
-				  (args(0).float_matrix_value (), 
-				   mattyp);
-			    }
-			  else
-			    {
-			      if (args(0).is_complex_type())
-				retval = octave_value 
-				  (args(0).complex_matrix_value (), 
-				   mattyp);
-			      else
-				retval = octave_value 
-				  (args(0).matrix_value (), 
-				   mattyp);
-			    }
-			}
-		    }
-		}
-	    }
-	}
+                      if (! error_state)
+                        {
+                          // Set the matrix type
+                          if (args(0).is_single_type ())
+                            {
+                              if (args(0).is_complex_type())
+                                retval = octave_value 
+                                  (args(0).float_complex_matrix_value (), 
+                                   mattyp);
+                              else
+                                retval = octave_value 
+                                  (args(0).float_matrix_value (), 
+                                   mattyp);
+                            }
+                          else
+                            {
+                              if (args(0).is_complex_type())
+                                retval = octave_value 
+                                  (args(0).complex_matrix_value (), 
+                                   mattyp);
+                              else
+                                retval = octave_value 
+                                  (args(0).matrix_value (), 
+                                   mattyp);
+                            }
+                        }
+                    }
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 
 ## FIXME
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -51,38 +51,38 @@ string @var{str}.\n\
   if (nargin != 1 && nargin != 2)
     print_usage();
   else
     {
       bool have_str = false;
       std::string str = args(0).string_value();
 
       if (nargin == 2)
-	have_str = args(1).bool_value();
-	
+        have_str = args(1).bool_value();
+        
       if (!error_state)
-	{
-	  if (have_str)
-	    retval = oct_md5 (str);
-	  else
-	    {
-	      file_stat fs (str);
+        {
+          if (have_str)
+            retval = oct_md5 (str);
+          else
+            {
+              file_stat fs (str);
 
-	      if (! fs.exists ())
-		{
-		  std::string tmp = octave_env::make_absolute
-		    (load_path::find_file (str), octave_env::getcwd ());
+              if (! fs.exists ())
+                {
+                  std::string tmp = octave_env::make_absolute
+                    (load_path::find_file (str), octave_env::getcwd ());
 
-		  if (! tmp.empty ())
-		    {
-		      warning_with_id ("Octave:md5sum-file-in-path",
-				       "md5sum: file found in load path");
-		      str = tmp;
-		    }
-		}
+                  if (! tmp.empty ())
+                    {
+                      warning_with_id ("Octave:md5sum-file-in-path",
+                                       "md5sum: file found in load path");
+                      str = tmp;
+                    }
+                }
 
-	      retval = oct_md5_file (str);
-	    }
-	}
+              retval = oct_md5_file (str);
+            }
+        }
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -97,79 +97,79 @@ where @code{sigma_max (@var{x})} is the 
   else if (arg.is_perm_matrix ())
     {
       retval = arg.perm_matrix_value ().inverse ();
     }
   else if (isfloat)
     {
       float tol = 0.0;
       if (nargin == 2)
-	tol = args(1).float_value ();
+        tol = args(1).float_value ();
 
       if (error_state)
-	return retval;
+        return retval;
 
       if (tol < 0.0)
-	{
-	  error ("pinv: tol must be greater than zero");
-	  return retval;
-	}
+        {
+          error ("pinv: tol must be greater than zero");
+          return retval;
+        }
 
       if (arg.is_real_type ())
-	{
-	  FloatMatrix m = arg.float_matrix_value ();
+        {
+          FloatMatrix m = arg.float_matrix_value ();
 
-	  if (! error_state)
-	    retval = m.pseudo_inverse (tol);
-	}
+          if (! error_state)
+            retval = m.pseudo_inverse (tol);
+        }
       else if (arg.is_complex_type ())
-	{
-	  FloatComplexMatrix m = arg.float_complex_matrix_value ();
+        {
+          FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-	  if (! error_state)
-	    retval = m.pseudo_inverse (tol);
-	}
+          if (! error_state)
+            retval = m.pseudo_inverse (tol);
+        }
       else
-	{
-	  gripe_wrong_type_arg ("pinv", arg);
-	}
+        {
+          gripe_wrong_type_arg ("pinv", arg);
+        }
     }
   else
     {
       double tol = 0.0;
       if (nargin == 2)
-	tol = args(1).double_value ();
+        tol = args(1).double_value ();
 
       if (error_state)
-	return retval;
+        return retval;
 
       if (tol < 0.0)
-	{
-	  error ("pinv: tol must be greater than zero");
-	  return retval;
-	}
+        {
+          error ("pinv: tol must be greater than zero");
+          return retval;
+        }
 
       if (arg.is_real_type ())
-	{
-	  Matrix m = arg.matrix_value ();
+        {
+          Matrix m = arg.matrix_value ();
 
-	  if (! error_state)
-	    retval = m.pseudo_inverse (tol);
-	}
+          if (! error_state)
+            retval = m.pseudo_inverse (tol);
+        }
       else if (arg.is_complex_type ())
-	{
-	  ComplexMatrix m = arg.complex_matrix_value ();
+        {
+          ComplexMatrix m = arg.complex_matrix_value ();
 
-	  if (! error_state)
-	    retval = m.pseudo_inverse (tol);
-	}
+          if (! error_state)
+            retval = m.pseudo_inverse (tol);
+        }
       else
-	{
-	  gripe_wrong_type_arg ("pinv", arg);
-	}
+        {
+          gripe_wrong_type_arg ("pinv", arg);
+        }
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -211,246 +211,246 @@ as\n\
 
   if (arg.is_sparse_type ())
     {
       bool economy = false;
       bool is_cmplx = false;
       int have_b = 0;
 
       if (arg.is_complex_type ())
-	is_cmplx = true;
+        is_cmplx = true;
       if (nargin > 1)
-	{
-	  have_b = 1;
-	  if (args(nargin-1).is_scalar_type ())
-	    {
-	      int val = args(nargin-1).int_value ();
-	      if (val == 0)
-		{
-		  economy = true;
-		  have_b = (nargin > 2 ? 2 : 0);
-		}
-	    }
-	  if (have_b > 0 && args(have_b).is_complex_type ())
-	    is_cmplx = true;
-	}
-	
+        {
+          have_b = 1;
+          if (args(nargin-1).is_scalar_type ())
+            {
+              int val = args(nargin-1).int_value ();
+              if (val == 0)
+                {
+                  economy = true;
+                  have_b = (nargin > 2 ? 2 : 0);
+                }
+            }
+          if (have_b > 0 && args(have_b).is_complex_type ())
+            is_cmplx = true;
+        }
+        
       if (!error_state)
-	{
-	  if (have_b && nargout < 2)
-	    error ("qr: incorrect number of output arguments");
-	  else if (is_cmplx)
-	    {
-	      SparseComplexQR q (arg.sparse_complex_matrix_value ());
-	      if (!error_state)
-		{
-		  if (have_b > 0)
-		    {
-		      retval(1) = q.R (economy);
-		      retval(0) = q.C (args(have_b).complex_matrix_value ());
-		      if (arg.rows() < arg.columns())
-			warning ("qr: non minimum norm solution for under-determined problem");
-		    }
-		  else if (nargout > 1)
-		    {
-		      retval(1) = q.R (economy);
-		      retval(0) = q.Q ();
-		    }
-		  else
-		    retval(0) = q.R (economy);
-		}
-	    }
-	  else
-	    {
-	      SparseQR q (arg.sparse_matrix_value ());
-	      if (!error_state)
-		{
-		  if (have_b > 0)
-		    {
-		      retval(1) = q.R (economy);
-		      retval(0) = q.C (args(have_b).matrix_value ());
-		      if (args(0).rows() < args(0).columns())
-			warning ("qr: non minimum norm solution for under-determined problem");
-		    }
-		  else if (nargout > 1)
-		    {
-		      retval(1) = q.R (economy);
-		      retval(0) = q.Q ();
-		    }
-		  else
-		    retval(0) = q.R (economy);
-		}
-	    }
-	}
+        {
+          if (have_b && nargout < 2)
+            error ("qr: incorrect number of output arguments");
+          else if (is_cmplx)
+            {
+              SparseComplexQR q (arg.sparse_complex_matrix_value ());
+              if (!error_state)
+                {
+                  if (have_b > 0)
+                    {
+                      retval(1) = q.R (economy);
+                      retval(0) = q.C (args(have_b).complex_matrix_value ());
+                      if (arg.rows() < arg.columns())
+                        warning ("qr: non minimum norm solution for under-determined problem");
+                    }
+                  else if (nargout > 1)
+                    {
+                      retval(1) = q.R (economy);
+                      retval(0) = q.Q ();
+                    }
+                  else
+                    retval(0) = q.R (economy);
+                }
+            }
+          else
+            {
+              SparseQR q (arg.sparse_matrix_value ());
+              if (!error_state)
+                {
+                  if (have_b > 0)
+                    {
+                      retval(1) = q.R (economy);
+                      retval(0) = q.C (args(have_b).matrix_value ());
+                      if (args(0).rows() < args(0).columns())
+                        warning ("qr: non minimum norm solution for under-determined problem");
+                    }
+                  else if (nargout > 1)
+                    {
+                      retval(1) = q.R (economy);
+                      retval(0) = q.Q ();
+                    }
+                  else
+                    retval(0) = q.R (economy);
+                }
+            }
+        }
     }
   else
     {
       QR::type type = (nargout == 0 || nargout == 1) ? QR::raw
-	: (nargin == 2 ? QR::economy : QR::std);
+        : (nargin == 2 ? QR::economy : QR::std);
 
       if (arg.is_single_type ())
-	{
-	  if (arg.is_real_type ())
-	    {
-	      FloatMatrix m = arg.float_matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              FloatMatrix m = arg.float_matrix_value ();
 
-	      if (! error_state)
-		{
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      {
-			FloatQR fact (m, type);
-			retval(0) = fact.R ();
-		      }
-		      break;
+              if (! error_state)
+                {
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      {
+                        FloatQR fact (m, type);
+                        retval(0) = fact.R ();
+                      }
+                      break;
 
-		    case 2:
-		      {
-			FloatQR fact (m, type);
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
+                    case 2:
+                      {
+                        FloatQR fact (m, type);
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
 
-		    default:
-		      {
-			FloatQRP fact (m, type);
+                    default:
+                      {
+                        FloatQRP fact (m, type);
                         if (type == QR::economy)
                           retval(2) = fact.Pvec ();
                         else
                           retval(2) = fact.P ();
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      FloatComplexMatrix m = arg.float_complex_matrix_value ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
+                    }
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      {
-			FloatComplexQR fact (m, type);
-			retval(0) = fact.R ();
-		      }
-		      break;
+              if (! error_state)
+                {
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      {
+                        FloatComplexQR fact (m, type);
+                        retval(0) = fact.R ();
+                      }
+                      break;
 
-		    case 2:
-		      {
-			FloatComplexQR fact (m, type);
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
+                    case 2:
+                      {
+                        FloatComplexQR fact (m, type);
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
 
-		    default:
-		      {
-			FloatComplexQRP fact (m, type);
+                    default:
+                      {
+                        FloatComplexQRP fact (m, type);
                         if (type == QR::economy)
                           retval(2) = fact.Pvec ();
                         else
                           retval(2) = fact.P ();
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
-		    }
-		}
-	    }
-	}
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
+                    }
+                }
+            }
+        }
       else
-	{
-	  if (arg.is_real_type ())
-	    {
-	      Matrix m = arg.matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              Matrix m = arg.matrix_value ();
 
-	      if (! error_state)
-		{
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      {
-			QR fact (m, type);
-			retval(0) = fact.R ();
-		      }
-		      break;
+              if (! error_state)
+                {
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      {
+                        QR fact (m, type);
+                        retval(0) = fact.R ();
+                      }
+                      break;
 
-		    case 2:
-		      {
-			QR fact (m, type);
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
+                    case 2:
+                      {
+                        QR fact (m, type);
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
 
-		    default:
-		      {
-			QRP fact (m, type);
+                    default:
+                      {
+                        QRP fact (m, type);
                         if (type == QR::economy)
                           retval(2) = fact.Pvec ();
                         else
                           retval(2) = fact.P ();
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      ComplexMatrix m = arg.complex_matrix_value ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
+                    }
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              ComplexMatrix m = arg.complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  switch (nargout)
-		    {
-		    case 0:
-		    case 1:
-		      {
-			ComplexQR fact (m, type);
-			retval(0) = fact.R ();
-		      }
-		      break;
+              if (! error_state)
+                {
+                  switch (nargout)
+                    {
+                    case 0:
+                    case 1:
+                      {
+                        ComplexQR fact (m, type);
+                        retval(0) = fact.R ();
+                      }
+                      break;
 
-		    case 2:
-		      {
-			ComplexQR fact (m, type);
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
+                    case 2:
+                      {
+                        ComplexQR fact (m, type);
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
 
-		    default:
-		      {
-			ComplexQRP fact (m, type);
+                    default:
+                      {
+                        ComplexQRP fact (m, type);
                         if (type == QR::economy)
                           retval(2) = fact.Pvec ();
                         else
                           retval(2) = fact.P ();
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		      break;
-		    }
-		}
-	    }
-	  else
-	    gripe_wrong_type_arg ("qr", arg);
-	}
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                      break;
+                    }
+                }
+            }
+          else
+            gripe_wrong_type_arg ("qr", arg);
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!test
@@ -797,87 +797,87 @@ The QR factorization supplied may be eit
   octave_value argv = args(3);
 
   if (argq.is_numeric_type () && argr.is_numeric_type () 
       && argu.is_numeric_type () && argv.is_numeric_type ())
     {
       if (check_qr_dims (argq, argr, true))
         {
           if (argq.is_real_type () 
-	      && argr.is_real_type () 
-	      && argu.is_real_type () 
-	      && argv.is_real_type ())
+              && argr.is_real_type () 
+              && argu.is_real_type () 
+              && argv.is_real_type ())
             {
-	      // all real case
-	      if (argq.is_single_type () 
-		  || argr.is_single_type () 
-		  || argu.is_single_type () 
-		  || argv.is_single_type ())
-		{
-		  FloatMatrix Q = argq.float_matrix_value ();
-		  FloatMatrix R = argr.float_matrix_value ();
-		  FloatMatrix u = argu.float_matrix_value ();
-		  FloatMatrix v = argv.float_matrix_value ();
+              // all real case
+              if (argq.is_single_type () 
+                  || argr.is_single_type () 
+                  || argu.is_single_type () 
+                  || argv.is_single_type ())
+                {
+                  FloatMatrix Q = argq.float_matrix_value ();
+                  FloatMatrix R = argr.float_matrix_value ();
+                  FloatMatrix u = argu.float_matrix_value ();
+                  FloatMatrix v = argv.float_matrix_value ();
 
-		  FloatQR fact (Q, R);
-		  fact.update (u, v);
+                  FloatQR fact (Q, R);
+                  fact.update (u, v);
 
-		  retval(1) = get_qr_r (fact);
-		  retval(0) = fact.Q ();
-		}
-	      else
-		{
-		  Matrix Q = argq.matrix_value ();
-		  Matrix R = argr.matrix_value ();
-		  Matrix u = argu.matrix_value ();
-		  Matrix v = argv.matrix_value ();
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
+                }
+              else
+                {
+                  Matrix Q = argq.matrix_value ();
+                  Matrix R = argr.matrix_value ();
+                  Matrix u = argu.matrix_value ();
+                  Matrix v = argv.matrix_value ();
 
-		  QR fact (Q, R);
-		  fact.update (u, v);
+                  QR fact (Q, R);
+                  fact.update (u, v);
 
-		  retval(1) = get_qr_r (fact);
-		  retval(0) = fact.Q ();
-		}
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
+                }
             }
           else
             {
               // complex case
-	      if (argq.is_single_type () 
-		  || argr.is_single_type () 
-		  || argu.is_single_type () 
-		  || argv.is_single_type ())
-		{
-		  FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-		  FloatComplexMatrix R = argr.float_complex_matrix_value ();
-		  FloatComplexMatrix u = argu.float_complex_matrix_value ();
-		  FloatComplexMatrix v = argv.float_complex_matrix_value ();
+              if (argq.is_single_type () 
+                  || argr.is_single_type () 
+                  || argu.is_single_type () 
+                  || argv.is_single_type ())
+                {
+                  FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                  FloatComplexMatrix u = argu.float_complex_matrix_value ();
+                  FloatComplexMatrix v = argv.float_complex_matrix_value ();
 
-		  FloatComplexQR fact (Q, R);
-		  fact.update (u, v);
+                  FloatComplexQR fact (Q, R);
+                  fact.update (u, v);
               
-		  retval(1) = get_qr_r (fact);
-		  retval(0) = fact.Q ();
-		}
-	      else
-		{
-		  ComplexMatrix Q = argq.complex_matrix_value ();
-		  ComplexMatrix R = argr.complex_matrix_value ();
-		  ComplexMatrix u = argu.complex_matrix_value ();
-		  ComplexMatrix v = argv.complex_matrix_value ();
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
+                }
+              else
+                {
+                  ComplexMatrix Q = argq.complex_matrix_value ();
+                  ComplexMatrix R = argr.complex_matrix_value ();
+                  ComplexMatrix u = argu.complex_matrix_value ();
+                  ComplexMatrix v = argv.complex_matrix_value ();
 
-		  ComplexQR fact (Q, R);
-		  fact.update (u, v);
+                  ComplexQR fact (Q, R);
+                  fact.update (u, v);
               
-		  retval(1) = get_qr_r (fact);
-		  retval(0) = fact.Q ();
-		}
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
+                }
             }
         }
       else
-	error ("qrupdate: dimensions mismatch");
+        error ("qrupdate: dimensions mismatch");
     }
   else
     error ("qrupdate: expecting numeric arguments");
 
   return retval;
 }
 /*
 %!shared A, u, v, Ac, uc, vc
@@ -996,97 +996,97 @@ If @var{orient} is @code{\"row\"}, full 
 
       if (col || orient == "row")
         if (check_qr_dims (argq, argr, col) 
             && (col || argx.rows () == 1))
           {
             if (check_index (argj, col))
               {
                 MArray<octave_idx_type> j
-		  = argj.octave_idx_type_vector_value ();
+                  = argj.octave_idx_type_vector_value ();
 
                 if (argq.is_real_type () 
-		    && argr.is_real_type () 
-		    && argx.is_real_type ())
+                    && argr.is_real_type () 
+                    && argx.is_real_type ())
                   {
                     // real case
-		    if (argq.is_single_type () 
-			|| argr.is_single_type () 
-			|| argx.is_single_type ())
-		      {
-			FloatMatrix Q = argq.float_matrix_value ();
-			FloatMatrix R = argr.float_matrix_value ();
-			FloatMatrix x = argx.float_matrix_value ();
+                    if (argq.is_single_type () 
+                        || argr.is_single_type () 
+                        || argx.is_single_type ())
+                      {
+                        FloatMatrix Q = argq.float_matrix_value ();
+                        FloatMatrix R = argr.float_matrix_value ();
+                        FloatMatrix x = argx.float_matrix_value ();
 
-			FloatQR fact (Q, R);
+                        FloatQR fact (Q, R);
 
-			if (col) 
-			  fact.insert_col (x, j-1);
-			else 
-			  fact.insert_row (x.row (0), j(0)-1);
+                        if (col) 
+                          fact.insert_col (x, j-1);
+                        else 
+                          fact.insert_row (x.row (0), j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
 
-		      }
-		    else
-		      {
-			Matrix Q = argq.matrix_value ();
-			Matrix R = argr.matrix_value ();
-			Matrix x = argx.matrix_value ();
+                      }
+                    else
+                      {
+                        Matrix Q = argq.matrix_value ();
+                        Matrix R = argr.matrix_value ();
+                        Matrix x = argx.matrix_value ();
 
-			QR fact (Q, R);
+                        QR fact (Q, R);
 
-			if (col) 
-			  fact.insert_col (x, j-1);
-			else 
-			  fact.insert_row (x.row (0), j(0)-1);
+                        if (col) 
+                          fact.insert_col (x, j-1);
+                        else 
+                          fact.insert_row (x.row (0), j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
 
-		      }
+                      }
                   }
                 else
                   {
                     // complex case
-		    if (argq.is_single_type () 
-			|| argr.is_single_type () 
-			|| argx.is_single_type ())
-		      {
-			FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-			FloatComplexMatrix R = argr.float_complex_matrix_value ();
-			FloatComplexMatrix x = argx.float_complex_matrix_value ();
+                    if (argq.is_single_type () 
+                        || argr.is_single_type () 
+                        || argx.is_single_type ())
+                      {
+                        FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+                        FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                        FloatComplexMatrix x = argx.float_complex_matrix_value ();
 
-			FloatComplexQR fact (Q, R);
+                        FloatComplexQR fact (Q, R);
 
-			if (col) 
-			  fact.insert_col (x, j-1);
-			else 
-			  fact.insert_row (x.row (0), j(0)-1);
+                        if (col) 
+                          fact.insert_col (x, j-1);
+                        else 
+                          fact.insert_row (x.row (0), j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		    else
-		      {
-			ComplexMatrix Q = argq.complex_matrix_value ();
-			ComplexMatrix R = argr.complex_matrix_value ();
-			ComplexMatrix x = argx.complex_matrix_value ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                    else
+                      {
+                        ComplexMatrix Q = argq.complex_matrix_value ();
+                        ComplexMatrix R = argr.complex_matrix_value ();
+                        ComplexMatrix x = argx.complex_matrix_value ();
 
-			ComplexQR fact (Q, R);
+                        ComplexQR fact (Q, R);
 
-			if (col) 
-			  fact.insert_col (x, j-1);
-			else 
-			  fact.insert_row (x.row (0), j(0)-1);
+                        if (col) 
+                          fact.insert_col (x, j-1);
+                        else 
+                          fact.insert_row (x.row (0), j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
                   }
 
               }
             else
               error ("qrinsert: invalid index");
           }
         else
           error ("qrinsert: dimension mismatch");
@@ -1210,88 +1210,88 @@ If @var{orient} is @code{\"row\"}, full 
       bool col = orient == "col";
 
       if (col || orient == "row")
         if (check_qr_dims (argq, argr, col))
           {
             if (check_index (argj, col))
               {
                 MArray<octave_idx_type> j
-		  = argj.octave_idx_type_vector_value ();
+                  = argj.octave_idx_type_vector_value ();
 
                 if (argq.is_real_type ()
-		    && argr.is_real_type ())
+                    && argr.is_real_type ())
                   {
                     // real case
-		    if (argq.is_single_type ()
-			|| argr.is_single_type ())
-		      {
-			FloatMatrix Q = argq.float_matrix_value ();
-			FloatMatrix R = argr.float_matrix_value ();
+                    if (argq.is_single_type ()
+                        || argr.is_single_type ())
+                      {
+                        FloatMatrix Q = argq.float_matrix_value ();
+                        FloatMatrix R = argr.float_matrix_value ();
 
-			FloatQR fact (Q, R);
+                        FloatQR fact (Q, R);
 
-			if (col) 
+                        if (col) 
                           fact.delete_col (j-1);
-			else 
-			  fact.delete_row (j(0)-1);
+                        else 
+                          fact.delete_row (j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		    else
-		      {
-			Matrix Q = argq.matrix_value ();
-			Matrix R = argr.matrix_value ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                    else
+                      {
+                        Matrix Q = argq.matrix_value ();
+                        Matrix R = argr.matrix_value ();
 
-			QR fact (Q, R);
+                        QR fact (Q, R);
 
-			if (col) 
+                        if (col) 
                           fact.delete_col (j-1);
-			else 
-			  fact.delete_row (j(0)-1);
+                        else 
+                          fact.delete_row (j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
                   }
                 else
                   {
                     // complex case
-		    if (argq.is_single_type ()
-			|| argr.is_single_type ())
-		      {
-			FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-			FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                    if (argq.is_single_type ()
+                        || argr.is_single_type ())
+                      {
+                        FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+                        FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-			FloatComplexQR fact (Q, R);
+                        FloatComplexQR fact (Q, R);
 
-			if (col) 
+                        if (col) 
                           fact.delete_col (j-1);
-			else 
-			  fact.delete_row (j(0)-1);
+                        else 
+                          fact.delete_row (j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
-		    else
-		      {
-			ComplexMatrix Q = argq.complex_matrix_value ();
-			ComplexMatrix R = argr.complex_matrix_value ();
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
+                    else
+                      {
+                        ComplexMatrix Q = argq.complex_matrix_value ();
+                        ComplexMatrix R = argr.complex_matrix_value ();
 
-			ComplexQR fact (Q, R);
+                        ComplexQR fact (Q, R);
 
-			if (col) 
+                        if (col) 
                           fact.delete_col (j-1);
-			else 
-			  fact.delete_row (j(0)-1);
+                        else 
+                          fact.delete_row (j(0)-1);
 
-			retval(1) = get_qr_r (fact);
-			retval(0) = fact.Q ();
-		      }
+                        retval(1) = get_qr_r (fact);
+                        retval(0) = fact.Q ();
+                      }
                   }
               }
             else
               error ("qrdelete: invalid index");
           }
         else
           error ("qrdelete: dimension mismatch");
 
@@ -1446,73 +1446,73 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
             {
               octave_idx_type i = argi.int_value ();
               octave_idx_type j = argj.int_value ();
 
               if (argq.is_real_type () 
                   && argr.is_real_type ())
                 {
                   // all real case
-		  if (argq.is_single_type () 
-		      && argr.is_single_type ())
-		    {
-		      FloatMatrix Q = argq.float_matrix_value ();
-		      FloatMatrix R = argr.float_matrix_value ();
+                  if (argq.is_single_type () 
+                      && argr.is_single_type ())
+                    {
+                      FloatMatrix Q = argq.float_matrix_value ();
+                      FloatMatrix R = argr.float_matrix_value ();
 
-		      FloatQR fact (Q, R);
-		      fact.shift_cols (i-1, j-1);
+                      FloatQR fact (Q, R);
+                      fact.shift_cols (i-1, j-1);
 
-		      retval(1) = get_qr_r (fact);
-		      retval(0) = fact.Q ();
-		    }
-		  else
-		    {
-		      Matrix Q = argq.matrix_value ();
-		      Matrix R = argr.matrix_value ();
+                      retval(1) = get_qr_r (fact);
+                      retval(0) = fact.Q ();
+                    }
+                  else
+                    {
+                      Matrix Q = argq.matrix_value ();
+                      Matrix R = argr.matrix_value ();
 
-		      QR fact (Q, R);
-		      fact.shift_cols (i-1, j-1);
+                      QR fact (Q, R);
+                      fact.shift_cols (i-1, j-1);
 
-		      retval(1) = get_qr_r (fact);
-		      retval(0) = fact.Q ();
-		    }
+                      retval(1) = get_qr_r (fact);
+                      retval(0) = fact.Q ();
+                    }
                 }
               else
                 {
                   // complex case
-		  if (argq.is_single_type () 
-		      && argr.is_single_type ())
-		    {
-		      FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-		      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                  if (argq.is_single_type () 
+                      && argr.is_single_type ())
+                    {
+                      FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-		      FloatComplexQR fact (Q, R);
-		      fact.shift_cols (i-1, j-1);
+                      FloatComplexQR fact (Q, R);
+                      fact.shift_cols (i-1, j-1);
                   
-		      retval(1) = get_qr_r (fact);
-		      retval(0) = fact.Q ();
-		    }
-		  else
-		    {
-		      ComplexMatrix Q = argq.complex_matrix_value ();
-		      ComplexMatrix R = argr.complex_matrix_value ();
+                      retval(1) = get_qr_r (fact);
+                      retval(0) = fact.Q ();
+                    }
+                  else
+                    {
+                      ComplexMatrix Q = argq.complex_matrix_value ();
+                      ComplexMatrix R = argr.complex_matrix_value ();
 
-		      ComplexQR fact (Q, R);
-		      fact.shift_cols (i-1, j-1);
+                      ComplexQR fact (Q, R);
+                      fact.shift_cols (i-1, j-1);
                   
-		      retval(1) = get_qr_r (fact);
-		      retval(0) = fact.Q ();
-		    }
+                      retval(1) = get_qr_r (fact);
+                      retval(0) = fact.Q ();
+                    }
                 }
             }
           else
             error ("qrshift: invalid index");
         }
       else
-	error ("qrshift: dimensions mismatch");
+        error ("qrshift: dimensions mismatch");
     }
   else
     error ("qrshift: expecting numeric arguments");
 
   return retval;
 }
 /*
 %!test
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -66,43 +66,43 @@ quad_user_function (double x)
   octave_value_list args;
   args(0) = x;
 
   if (quad_fcn)
     {
       octave_value_list tmp = quad_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  quad_integration_error = 1;  // FIXME
-	  gripe_user_supplied_eval ("quad");
-	  return retval;
-	}
+        {
+          quad_integration_error = 1;  // FIXME
+          gripe_user_supplied_eval ("quad");
+          return retval;
+        }
 
       if (tmp.length () && tmp(0).is_defined ())
-	{
-	  if (! warned_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("quad: ignoring imaginary part returned from user-supplied function");
-	      warned_imaginary = true;
-	    }
+        {
+          if (! warned_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("quad: ignoring imaginary part returned from user-supplied function");
+              warned_imaginary = true;
+            }
 
-	  retval = tmp(0).double_value ();
+          retval = tmp(0).double_value ();
 
-	  if (error_state)
-	    {
-	      quad_integration_error = 1;  // FIXME
-	      gripe_user_supplied_eval ("quad");
-	    }
-	}
+          if (error_state)
+            {
+              quad_integration_error = 1;  // FIXME
+              gripe_user_supplied_eval ("quad");
+            }
+        }
       else
-	{
-	  quad_integration_error = 1;  // FIXME
-	  gripe_user_supplied_eval ("quad");
-	}
+        {
+          quad_integration_error = 1;  // FIXME
+          gripe_user_supplied_eval ("quad");
+        }
     }
 
   return retval;
 }
 
 float
 quad_float_user_function (float x)
 {
@@ -111,53 +111,53 @@ quad_float_user_function (float x)
   octave_value_list args;
   args(0) = x;
 
   if (quad_fcn)
     {
       octave_value_list tmp = quad_fcn->do_multi_index_op (1, args);
 
       if (error_state)
-	{
-	  quad_integration_error = 1;  // FIXME
-	  gripe_user_supplied_eval ("quad");
-	  return retval;
-	}
+        {
+          quad_integration_error = 1;  // FIXME
+          gripe_user_supplied_eval ("quad");
+          return retval;
+        }
 
       if (tmp.length () && tmp(0).is_defined ())
-	{
-	  if (! warned_imaginary && tmp(0).is_complex_type ())
-	    {
-	      warning ("quad: ignoring imaginary part returned from user-supplied function");
-	      warned_imaginary = true;
-	    }
+        {
+          if (! warned_imaginary && tmp(0).is_complex_type ())
+            {
+              warning ("quad: ignoring imaginary part returned from user-supplied function");
+              warned_imaginary = true;
+            }
 
-	  retval = tmp(0).float_value ();
+          retval = tmp(0).float_value ();
 
-	  if (error_state)
-	    {
-	      quad_integration_error = 1;  // FIXME
-	      gripe_user_supplied_eval ("quad");
-	    }
-	}
+          if (error_state)
+            {
+              quad_integration_error = 1;  // FIXME
+              gripe_user_supplied_eval ("quad");
+            }
+        }
       else
-	{
-	  quad_integration_error = 1;  // FIXME
-	  gripe_user_supplied_eval ("quad");
-	}
+        {
+          quad_integration_error = 1;  // FIXME
+          gripe_user_supplied_eval ("quad");
+        }
     }
 
   return retval;
 }
 
 #define QUAD_ABORT() \
   do \
     { \
       if (fcn_name.length()) \
-	clear_function (fcn_name); \
+        clear_function (fcn_name); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
       ::error ("quad: " msg); \
@@ -228,249 +228,249 @@ cannot be called recursively.\n\
   if (call_depth > 1)
     QUAD_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 2 && nargin < 6 && nargout < 5)
     {
       if (args(0).is_function_handle () || args(0).is_inline_function ())
-	quad_fcn = args(0).function_value ();
+        quad_fcn = args(0).function_value ();
       else
-	{
-	  fcn_name = unique_symbol_name ("__quad_fcn_");
-	  std::string fname = "function y = ";
-	  fname.append (fcn_name);
-	  fname.append ("(x) y = ");
-	  quad_fcn = extract_function (args(0), "quad", fcn_name, fname,
-				       "; endfunction");
-	}
+        {
+          fcn_name = unique_symbol_name ("__quad_fcn_");
+          std::string fname = "function y = ";
+          fname.append (fcn_name);
+          fname.append ("(x) y = ");
+          quad_fcn = extract_function (args(0), "quad", fcn_name, fname,
+                                       "; endfunction");
+        }
 
       if (! quad_fcn)
-	QUAD_ABORT ();
+        QUAD_ABORT ();
 
       if (args(1).is_single_type () || args(2).is_single_type ())
-	{
-	  float a = args(1).float_value ();
+        {
+          float a = args(1).float_value ();
 
-	  if (error_state)
-	    QUAD_ABORT1 ("expecting second argument to be a scalar");
+          if (error_state)
+            QUAD_ABORT1 ("expecting second argument to be a scalar");
 
-	  float b = args(2).float_value ();
+          float b = args(2).float_value ();
 
-	  if (error_state)
-	    QUAD_ABORT1 ("expecting third argument to be a scalar");
+          if (error_state)
+            QUAD_ABORT1 ("expecting third argument to be a scalar");
 
-	  int indefinite = 0;
-	  FloatIndefQuad::IntegralType indef_type = FloatIndefQuad::doubly_infinite;
-	  float bound = 0.0;
-	  if (xisinf (a) && xisinf (b))
-	    {
-	      indefinite = 1;
-	      indef_type = FloatIndefQuad::doubly_infinite;
-	    }
-	  else if (xisinf (a))
-	    {
-	      indefinite = 1;
-	      bound = b;
-	      indef_type = FloatIndefQuad::neg_inf_to_bound;
-	    }
-	  else if (xisinf (b))
-	    {
-	      indefinite = 1;
-	      bound = a;
-	      indef_type = FloatIndefQuad::bound_to_inf;
-	    }
+          int indefinite = 0;
+          FloatIndefQuad::IntegralType indef_type = FloatIndefQuad::doubly_infinite;
+          float bound = 0.0;
+          if (xisinf (a) && xisinf (b))
+            {
+              indefinite = 1;
+              indef_type = FloatIndefQuad::doubly_infinite;
+            }
+          else if (xisinf (a))
+            {
+              indefinite = 1;
+              bound = b;
+              indef_type = FloatIndefQuad::neg_inf_to_bound;
+            }
+          else if (xisinf (b))
+            {
+              indefinite = 1;
+              bound = a;
+              indef_type = FloatIndefQuad::bound_to_inf;
+            }
 
-	  octave_idx_type ier = 0;
-	  octave_idx_type nfun = 0;
-	  float abserr = 0.0;
-	  float val = 0.0;
-	  bool have_sing = false;
-	  FloatColumnVector sing;
-	  FloatColumnVector tol;
+          octave_idx_type ier = 0;
+          octave_idx_type nfun = 0;
+          float abserr = 0.0;
+          float val = 0.0;
+          bool have_sing = false;
+          FloatColumnVector sing;
+          FloatColumnVector tol;
 
-	  switch (nargin)
-	    {
-	    case 5:
-	      if (indefinite)
-		QUAD_ABORT1 ("singularities not allowed on infinite intervals");
+          switch (nargin)
+            {
+            case 5:
+              if (indefinite)
+                QUAD_ABORT1 ("singularities not allowed on infinite intervals");
 
-	      have_sing = true;
+              have_sing = true;
 
-	      sing = FloatColumnVector (args(4).float_vector_value ());
+              sing = FloatColumnVector (args(4).float_vector_value ());
 
-	      if (error_state)
-		QUAD_ABORT1 ("expecting vector of singularities as fourth argument");
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of singularities as fourth argument");
 
-	    case 4:
-	      tol = FloatColumnVector (args(3).float_vector_value ());
+            case 4:
+              tol = FloatColumnVector (args(3).float_vector_value ());
 
-	      if (error_state)
-		QUAD_ABORT1 ("expecting vector of tolerances as fifth argument");
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of tolerances as fifth argument");
 
-	      switch (tol.capacity ())
-		{
-		case 2:
-		  quad_opts.set_single_precision_relative_tolerance (tol (1));
+              switch (tol.capacity ())
+                {
+                case 2:
+                  quad_opts.set_single_precision_relative_tolerance (tol (1));
 
-		case 1:
-		  quad_opts.set_single_precision_absolute_tolerance (tol (0));
-		  break;
+                case 1:
+                  quad_opts.set_single_precision_absolute_tolerance (tol (0));
+                  break;
 
-		default:
-		  QUAD_ABORT1 ("expecting tol to contain no more than two values");
-		}
+                default:
+                  QUAD_ABORT1 ("expecting tol to contain no more than two values");
+                }
 
-	    case 3:
-	      if (indefinite)
-		{
-		  FloatIndefQuad iq (quad_float_user_function, bound, 
-				     indef_type);
-		  iq.set_options (quad_opts);
-		  val = iq.float_integrate (ier, nfun, abserr);
-		}
-	      else
-		{
-		  if (have_sing)
-		    {
-		      FloatDefQuad dq (quad_float_user_function, a, b, sing);
-		      dq.set_options (quad_opts);
-		      val = dq.float_integrate (ier, nfun, abserr);
-		    }
-		  else
-		    {
-		      FloatDefQuad dq (quad_float_user_function, a, b);
-		      dq.set_options (quad_opts);
-		      val = dq.float_integrate (ier, nfun, abserr);
-		    }
-		}
-	      break;
+            case 3:
+              if (indefinite)
+                {
+                  FloatIndefQuad iq (quad_float_user_function, bound, 
+                                     indef_type);
+                  iq.set_options (quad_opts);
+                  val = iq.float_integrate (ier, nfun, abserr);
+                }
+              else
+                {
+                  if (have_sing)
+                    {
+                      FloatDefQuad dq (quad_float_user_function, a, b, sing);
+                      dq.set_options (quad_opts);
+                      val = dq.float_integrate (ier, nfun, abserr);
+                    }
+                  else
+                    {
+                      FloatDefQuad dq (quad_float_user_function, a, b);
+                      dq.set_options (quad_opts);
+                      val = dq.float_integrate (ier, nfun, abserr);
+                    }
+                }
+              break;
 
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
+            default:
+              panic_impossible ();
+              break;
+            }
 
-	  retval(3) = abserr;
-	  retval(2) = nfun;
-	  retval(1) = ier;
-	  retval(0) = val;
+          retval(3) = abserr;
+          retval(2) = nfun;
+          retval(1) = ier;
+          retval(0) = val;
 
-	}
+        }
       else
-	{
-	  double a = args(1).double_value ();
+        {
+          double a = args(1).double_value ();
 
-	  if (error_state)
-	    QUAD_ABORT1 ("expecting second argument to be a scalar");
+          if (error_state)
+            QUAD_ABORT1 ("expecting second argument to be a scalar");
 
-	  double b = args(2).double_value ();
+          double b = args(2).double_value ();
 
-	  if (error_state)
-	    QUAD_ABORT1 ("expecting third argument to be a scalar");
+          if (error_state)
+            QUAD_ABORT1 ("expecting third argument to be a scalar");
 
-	  int indefinite = 0;
-	  IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
-	  double bound = 0.0;
-	  if (xisinf (a) && xisinf (b))
-	    {
-	      indefinite = 1;
-	      indef_type = IndefQuad::doubly_infinite;
-	    }
-	  else if (xisinf (a))
-	    {
-	      indefinite = 1;
-	      bound = b;
-	      indef_type = IndefQuad::neg_inf_to_bound;
-	    }
-	  else if (xisinf (b))
-	    {
-	      indefinite = 1;
-	      bound = a;
-	      indef_type = IndefQuad::bound_to_inf;
-	    }
+          int indefinite = 0;
+          IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
+          double bound = 0.0;
+          if (xisinf (a) && xisinf (b))
+            {
+              indefinite = 1;
+              indef_type = IndefQuad::doubly_infinite;
+            }
+          else if (xisinf (a))
+            {
+              indefinite = 1;
+              bound = b;
+              indef_type = IndefQuad::neg_inf_to_bound;
+            }
+          else if (xisinf (b))
+            {
+              indefinite = 1;
+              bound = a;
+              indef_type = IndefQuad::bound_to_inf;
+            }
 
-	  octave_idx_type ier = 0;
-	  octave_idx_type nfun = 0;
-	  double abserr = 0.0;
-	  double val = 0.0;
-	  bool have_sing = false;
-	  ColumnVector sing;
-	  ColumnVector tol;
+          octave_idx_type ier = 0;
+          octave_idx_type nfun = 0;
+          double abserr = 0.0;
+          double val = 0.0;
+          bool have_sing = false;
+          ColumnVector sing;
+          ColumnVector tol;
 
-	  switch (nargin)
-	    {
-	    case 5:
-	      if (indefinite)
-		QUAD_ABORT1 ("singularities not allowed on infinite intervals");
+          switch (nargin)
+            {
+            case 5:
+              if (indefinite)
+                QUAD_ABORT1 ("singularities not allowed on infinite intervals");
 
-	      have_sing = true;
+              have_sing = true;
 
-	      sing = ColumnVector (args(4).vector_value ());
+              sing = ColumnVector (args(4).vector_value ());
 
-	      if (error_state)
-		QUAD_ABORT1 ("expecting vector of singularities as fourth argument");
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of singularities as fourth argument");
 
-	    case 4:
-	      tol = ColumnVector (args(3).vector_value ());
+            case 4:
+              tol = ColumnVector (args(3).vector_value ());
 
-	      if (error_state)
-		QUAD_ABORT1 ("expecting vector of tolerances as fifth argument");
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of tolerances as fifth argument");
 
-	      switch (tol.capacity ())
-		{
-		case 2:
-		  quad_opts.set_relative_tolerance (tol (1));
+              switch (tol.capacity ())
+                {
+                case 2:
+                  quad_opts.set_relative_tolerance (tol (1));
 
-		case 1:
-		  quad_opts.set_absolute_tolerance (tol (0));
-		  break;
+                case 1:
+                  quad_opts.set_absolute_tolerance (tol (0));
+                  break;
 
-		default:
-		  QUAD_ABORT1 ("expecting tol to contain no more than two values");
-		}
+                default:
+                  QUAD_ABORT1 ("expecting tol to contain no more than two values");
+                }
 
-	    case 3:
-	      if (indefinite)
-		{
-		  IndefQuad iq (quad_user_function, bound, indef_type);
-		  iq.set_options (quad_opts);
-		  val = iq.integrate (ier, nfun, abserr);
-		}
-	      else
-		{
-		  if (have_sing)
-		    {
-		      DefQuad dq (quad_user_function, a, b, sing);
-		      dq.set_options (quad_opts);
-		      val = dq.integrate (ier, nfun, abserr);
-		    }
-		  else
-		    {
-		      DefQuad dq (quad_user_function, a, b);
-		      dq.set_options (quad_opts);
-		      val = dq.integrate (ier, nfun, abserr);
-		    }
-		}
-	      break;
+            case 3:
+              if (indefinite)
+                {
+                  IndefQuad iq (quad_user_function, bound, indef_type);
+                  iq.set_options (quad_opts);
+                  val = iq.integrate (ier, nfun, abserr);
+                }
+              else
+                {
+                  if (have_sing)
+                    {
+                      DefQuad dq (quad_user_function, a, b, sing);
+                      dq.set_options (quad_opts);
+                      val = dq.integrate (ier, nfun, abserr);
+                    }
+                  else
+                    {
+                      DefQuad dq (quad_user_function, a, b);
+                      dq.set_options (quad_opts);
+                      val = dq.integrate (ier, nfun, abserr);
+                    }
+                }
+              break;
 
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
+            default:
+              panic_impossible ();
+              break;
+            }
 
-	  retval(3) = abserr;
-	  retval(2) = nfun;
-	  retval(1) = ier;
-	  retval(0) = val;
-	}
+          retval(3) = abserr;
+          retval(2) = nfun;
+          retval(1) = ier;
+          retval(0) = val;
+        }
 
       if (fcn_name.length())
-	clear_function (fcn_name);
+        clear_function (fcn_name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -54,105 +54,105 @@ along with Octave; see the file COPYING.
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
 #endif
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 typedef octave_idx_type (*sort_function) (const octave_idx_type& LSIZE, const double& ALPHA,
-			      const double& BETA, const double& S,
-			      const double& P);
+                              const double& BETA, const double& S,
+                              const double& P);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, double* A, const octave_idx_type& LDA,
-			     double* B, const octave_idx_type& LDB, octave_idx_type& ILO,
-			     octave_idx_type& IHI, double* LSCALE, double* RSCALE,
-			     double* WORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type& N, double* A, const octave_idx_type& LDA,
+                             double* B, const octave_idx_type& LDB, octave_idx_type& ILO,
+                             octave_idx_type& IHI, double* LSCALE, double* RSCALE,
+                             double* WORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO,
-			     const octave_idx_type& IHI, const double* LSCALE,
-			     const double* RSCALE, octave_idx_type& M, double* V,
-			     const octave_idx_type& LDV, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO,
+                             const octave_idx_type& IHI, const double* LSCALE,
+                             const double* RSCALE, octave_idx_type& M, double* V,
+                             const octave_idx_type& LDV, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgghrd, DGGHRD) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO,
-			     const octave_idx_type& IHI, double* A,
-			     const octave_idx_type& LDA, double* B,
-			     const octave_idx_type& LDB, double* Q,
-			     const octave_idx_type& LDQ, double* Z,
-			     const octave_idx_type& LDZ, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO,
+                             const octave_idx_type& IHI, double* A,
+                             const octave_idx_type& LDA, double* B,
+                             const octave_idx_type& LDB, double* Q,
+                             const octave_idx_type& LDQ, double* Z,
+                             const octave_idx_type& LDZ, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dhgeqz, DHGEQZ) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO, const octave_idx_type& IHI,
-			     double* A, const octave_idx_type& LDA, double* B,
-			     const octave_idx_type& LDB, double* ALPHAR,
-			     double* ALPHAI, double* BETA, double* Q,
-			     const octave_idx_type& LDQ, double* Z,
-			     const octave_idx_type& LDZ, double* WORK,
-			     const octave_idx_type& LWORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO, const octave_idx_type& IHI,
+                             double* A, const octave_idx_type& LDA, double* B,
+                             const octave_idx_type& LDB, double* ALPHAR,
+                             double* ALPHAI, double* BETA, double* Q,
+                             const octave_idx_type& LDQ, double* Z,
+                             const octave_idx_type& LDZ, double* WORK,
+                             const octave_idx_type& LWORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dlag2, DLAG2) (const double* A, const octave_idx_type& LDA, const double* B,
-			   const octave_idx_type& LDB, const double& SAFMIN,
-			   double& SCALE1, double& SCALE2,
-			   double& WR1, double& WR2, double& WI);
+                           const octave_idx_type& LDB, const double& SAFMIN,
+                           double& SCALE1, double& SCALE2,
+                           double& WR1, double& WR2, double& WI);
 
   // Van Dooren's code (netlib.org: toms/590) for reordering
   // GEP.  Only processes Z, not Q.
   F77_RET_T
   F77_FUNC (dsubsp, DSUBSP) (const octave_idx_type& NMAX, const octave_idx_type& N, double* A,
-			     double* B, double* Z, sort_function,
-			     const double& EPS, octave_idx_type& NDIM, octave_idx_type& FAIL,
-			     octave_idx_type* IND);
+                             double* B, double* Z, sort_function,
+                             const double& EPS, octave_idx_type& NDIM, octave_idx_type& FAIL,
+                             octave_idx_type* IND);
 
   // documentation for DTGEVC incorrectly states that VR, VL are
   // complex*16; they are declared in DTGEVC as double precision
   // (probably a cut and paste problem fro ZTGEVC)
   F77_RET_T
   F77_FUNC (dtgevc, DTGEVC) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     octave_idx_type* SELECT, const octave_idx_type& N, double* A,
-			     const octave_idx_type& LDA, double* B,
-			     const octave_idx_type& LDB, double* VL,
-			     const octave_idx_type& LDVL, double* VR,
-			     const octave_idx_type& LDVR, const octave_idx_type& MM,
-			     octave_idx_type& M, double* WORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             octave_idx_type* SELECT, const octave_idx_type& N, double* A,
+                             const octave_idx_type& LDA, double* B,
+                             const octave_idx_type& LDB, double* VL,
+                             const octave_idx_type& LDVL, double* VR,
+                             const octave_idx_type& LDVR, const octave_idx_type& MM,
+                             octave_idx_type& M, double* WORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG_DECL,
-			       double& retval
-			       F77_CHAR_ARG_LEN_DECL);
+                               double& retval
+                               F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&, const double*,
-			       const octave_idx_type&, double*, double&
-			       F77_CHAR_ARG_LEN_DECL);
+                               const octave_idx_type&, const octave_idx_type&, const double*,
+                               const octave_idx_type&, double*, double&
+                               F77_CHAR_ARG_LEN_DECL);
 }
 
 // fcrhp, fin, fout, folhp:
 // routines for ordering of generalized eigenvalues
 // return 1 if  test is passed, 0 otherwise
 //    fin: |lambda| < 1
 //    fout: |lambda| >= 1
 //    fcrhp: real(lambda) >= 0
@@ -314,54 +314,54 @@ Order of output arguments was selected f
       error ("qz: argument 3 must be a string");
       return retval;
     }
   else
     {
       std::string tmp = args(2).string_value ();
 
       if (! tmp.empty ())
-	ord_job = tmp[0];
+        ord_job = tmp[0];
 
       if (! (ord_job == 'N' || ord_job == 'n'
-	     || ord_job == 'S' || ord_job == 's'
-	     || ord_job == 'B' || ord_job == 'b'
-	     || ord_job == '+' || ord_job == '-'))
-	{
-	  error ("qz: invalid order option");
-	  return retval;
-	}
+             || ord_job == 'S' || ord_job == 's'
+             || ord_job == 'B' || ord_job == 'b'
+             || ord_job == '+' || ord_job == '-'))
+        {
+          error ("qz: invalid order option");
+          return retval;
+        }
 
       // overflow constant required by dlag2
       F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("S", 1),
-				   safmin
-				   F77_CHAR_ARG_LEN (1));
+                                   safmin
+                                   F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
       std::cout << "qz: initial value of safmin=" << setiosflags (std::ios::scientific)
-	   << safmin << std::endl;
+           << safmin << std::endl;
 #endif
 
       // some machines (e.g., DEC alpha) get safmin = 0;
       // for these, use eps instead to avoid problems in dlag2
       if (safmin == 0)
-	{
+        {
 #ifdef DEBUG_EIG
-	  std::cout << "qz: DANGER WILL ROBINSON: safmin is 0!" << std::endl;
+          std::cout << "qz: DANGER WILL ROBINSON: safmin is 0!" << std::endl;
 #endif
 
-	  F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("E", 1),
-				       safmin
-				       F77_CHAR_ARG_LEN (1));
+          F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("E", 1),
+                                       safmin
+                                       F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
-	  std::cout << "qz: safmin set to " << setiosflags (std::ios::scientific)
-	       << safmin << std::endl;
+          std::cout << "qz: safmin set to " << setiosflags (std::ios::scientific)
+               << safmin << std::endl;
 #endif
-	}
+        }
     }
 
 #ifdef DEBUG
   std::cout << "qz: check argument 1" << std::endl;
 #endif
 
   // Argument 1: check if it's o.k. dimensioned
   octave_idx_type nn = args(0).rows ();
@@ -443,104 +443,104 @@ Order of output arguments was selected f
   octave_idx_type ilo, ihi, info;
   char compq = (nargout >= 3 ? 'V' : 'N');
   char compz = (nargout >= 4 ? 'V' : 'N');
 
   // initialize Q, Z to identity if we need either of them
   if (compq == 'V' || compz == 'V')
     for (octave_idx_type ii = 0; ii < nn; ii++)
       for (octave_idx_type jj = 0; jj < nn; jj++)
-	{
-	  OCTAVE_QUIT;
-	  QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
-	}
+        {
+          OCTAVE_QUIT;
+          QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
+        }
 
   // always perform permutation balancing
   const char bal_job = 'P';
   RowVector lscale(nn), rscale(nn), work(6*nn);
 
   if (complex_case)
     {
       error ("Complex case not implemented yet");
       return retval;
     }
   else
     {
 #ifdef DEBUG
       if (compq == 'V')
-	std::cout << "qz: performing balancing; QQ=" << std::endl << QQ << std::endl;
+        std::cout << "qz: performing balancing; QQ=" << std::endl << QQ << std::endl;
 #endif
 
       F77_XFCN (dggbal, DGGBAL,
-		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
-		 nn, aa.fortran_vec (), nn, bb.fortran_vec (),
-		 nn, ilo, ihi, lscale.fortran_vec (),
-		 rscale.fortran_vec (), work.fortran_vec (), info
-		 F77_CHAR_ARG_LEN (1)));
+                (F77_CONST_CHAR_ARG2 (&bal_job, 1),
+                 nn, aa.fortran_vec (), nn, bb.fortran_vec (),
+                 nn, ilo, ihi, lscale.fortran_vec (),
+                 rscale.fortran_vec (), work.fortran_vec (), info
+                 F77_CHAR_ARG_LEN (1)));
     }
 
   // Since we just want the balancing matrices, we can use dggbal
   // for both the real and complex cases;
   // left first
 
   if (compq == 'V')
     {
       F77_XFCN (dggbak, DGGBAK,
-		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
-		 F77_CONST_CHAR_ARG2 ("L", 1),
-		 nn, ilo, ihi, lscale.data (), rscale.data (),
-		 nn, QQ.fortran_vec (), nn, info
-		 F77_CHAR_ARG_LEN (1)
-		 F77_CHAR_ARG_LEN (1)));
+                (F77_CONST_CHAR_ARG2 (&bal_job, 1),
+                 F77_CONST_CHAR_ARG2 ("L", 1),
+                 nn, ilo, ihi, lscale.data (), rscale.data (),
+                 nn, QQ.fortran_vec (), nn, info
+                 F77_CHAR_ARG_LEN (1)
+                 F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
       if (compq == 'V')
-	std::cout << "qz: balancing done; QQ=" << std::endl << QQ << std::endl;
+        std::cout << "qz: balancing done; QQ=" << std::endl << QQ << std::endl;
 #endif
   }
 
   // then right
   if (compz == 'V')
     {
       F77_XFCN (dggbak, DGGBAK,
-		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
-		 F77_CONST_CHAR_ARG2 ("R", 1),
-		 nn, ilo, ihi, lscale.data (), rscale.data (),
-		 nn, ZZ.fortran_vec (), nn, info
-		 F77_CHAR_ARG_LEN (1)
-		 F77_CHAR_ARG_LEN (1)));
+                (F77_CONST_CHAR_ARG2 (&bal_job, 1),
+                 F77_CONST_CHAR_ARG2 ("R", 1),
+                 nn, ilo, ihi, lscale.data (), rscale.data (),
+                 nn, ZZ.fortran_vec (), nn, info
+                 F77_CHAR_ARG_LEN (1)
+                 F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
       if (compz == 'V')
-	std::cout << "qz: balancing done; ZZ=" << std::endl << ZZ << std::endl;
+        std::cout << "qz: balancing done; ZZ=" << std::endl << ZZ << std::endl;
 #endif
     }
 
   static char qz_job;
-  qz_job = (nargout < 2 ? 'E' : 'S');	
+  qz_job = (nargout < 2 ? 'E' : 'S');   
 
   if (complex_case)
     {
       // complex case
       if (args(0).is_real_type ())
-	caa = ComplexMatrix (aa);
+        caa = ComplexMatrix (aa);
 
       if (args(1).is_real_type ())
-	cbb = ComplexMatrix (bb);
+        cbb = ComplexMatrix (bb);
 
       if (compq == 'V')
-	CQ = ComplexMatrix (QQ);
+        CQ = ComplexMatrix (QQ);
 
       if (compz == 'V')
-	CZ = ComplexMatrix (ZZ);
+        CZ = ComplexMatrix (ZZ);
 
       error ("complex case not done yet");
       return retval;
     }
-  else  	// real matrices case
+  else          // real matrices case
     {
 #ifdef DEBUG
       std::cout << "qz: peforming qr decomposition of bb" << std::endl;
 #endif
 
       // compute the QR factorization of bb
       QR bqr (bb);
 
@@ -556,410 +556,410 @@ Order of output arguments was selected f
 
       aa = (bqr.Q ()).transpose ()*aa;
 
 #ifdef DEBUG
       std::cout << "qz: updated aa " << std::endl;
       std::cout << "bqr.Q () = " << std::endl << bqr.Q () << std::endl;
 
       if (compq == 'V')
-	std::cout << "QQ =" << QQ << std::endl;
+        std::cout << "QQ =" << QQ << std::endl;
 #endif
 
       if (compq == 'V')
-	QQ = QQ*bqr.Q ();
+        QQ = QQ*bqr.Q ();
 
 #ifdef DEBUG
       std::cout << "qz: precursors done..." << std::endl;
 #endif
 
 #ifdef DEBUG
       std::cout << "qz: compq = " << compq << ", compz = " << compz << std::endl;
 #endif
 
       // reduce  to generalized hessenberg form
       F77_XFCN (dgghrd, DGGHRD,
-		(F77_CONST_CHAR_ARG2 (&compq, 1),
-		 F77_CONST_CHAR_ARG2 (&compz, 1),
-		 nn, ilo, ihi, aa.fortran_vec (),
-		 nn, bb.fortran_vec (), nn, QQ.fortran_vec (), nn,
-		 ZZ.fortran_vec (), nn, info
-		 F77_CHAR_ARG_LEN (1)
-		 F77_CHAR_ARG_LEN (1)));
+                (F77_CONST_CHAR_ARG2 (&compq, 1),
+                 F77_CONST_CHAR_ARG2 (&compz, 1),
+                 nn, ilo, ihi, aa.fortran_vec (),
+                 nn, bb.fortran_vec (), nn, QQ.fortran_vec (), nn,
+                 ZZ.fortran_vec (), nn, info
+                 F77_CHAR_ARG_LEN (1)
+                 F77_CHAR_ARG_LEN (1)));
 
       // check if just computing generalized eigenvalues or if we're
       // actually computing the decomposition
 
       // reduce to generalized Schur form
       F77_XFCN (dhgeqz, DHGEQZ,
-		(F77_CONST_CHAR_ARG2 (&qz_job, 1),
-		 F77_CONST_CHAR_ARG2 (&compq, 1),
-		 F77_CONST_CHAR_ARG2 (&compz, 1),
-		 nn, ilo, ihi, aa.fortran_vec (), nn, bb.fortran_vec (),
-		 nn, alphar.fortran_vec (), alphai.fortran_vec (),
-		 betar.fortran_vec (), QQ.fortran_vec (), nn,
-		 ZZ.fortran_vec (), nn, work.fortran_vec (), nn, info
-		 F77_CHAR_ARG_LEN (1)
-		 F77_CHAR_ARG_LEN (1)
-		 F77_CHAR_ARG_LEN (1)));
+                (F77_CONST_CHAR_ARG2 (&qz_job, 1),
+                 F77_CONST_CHAR_ARG2 (&compq, 1),
+                 F77_CONST_CHAR_ARG2 (&compz, 1),
+                 nn, ilo, ihi, aa.fortran_vec (), nn, bb.fortran_vec (),
+                 nn, alphar.fortran_vec (), alphai.fortran_vec (),
+                 betar.fortran_vec (), QQ.fortran_vec (), nn,
+                 ZZ.fortran_vec (), nn, work.fortran_vec (), nn, info
+                 F77_CHAR_ARG_LEN (1)
+                 F77_CHAR_ARG_LEN (1)
+                 F77_CHAR_ARG_LEN (1)));
     }
 
   // order the QZ decomposition?
   if (! (ord_job == 'N' || ord_job == 'n'))
     {
       if (complex_case)
-	{
-	  // probably not needed, but better be safe
-	  error ("qz: cannot re-order complex qz decomposition.");
-	  return retval;
-	}
+        {
+          // probably not needed, but better be safe
+          error ("qz: cannot re-order complex qz decomposition.");
+          return retval;
+        }
       else
-	{
+        {
 #ifdef DEBUG_SORT
-	  std::cout << "qz: ordering eigenvalues: ord_job = "
-		    << ord_job << std::endl;
+          std::cout << "qz: ordering eigenvalues: ord_job = "
+                    << ord_job << std::endl;
 #endif
 
-	  // declared static to avoid vfork/long jump compiler complaints
-	  static sort_function sort_test;
-	  sort_test = 0;
+          // declared static to avoid vfork/long jump compiler complaints
+          static sort_function sort_test;
+          sort_test = 0;
 
-	  switch (ord_job)
-	    {
-	    case 'S':
-	    case 's':
-	      sort_test = &fin;
-	      break;
+          switch (ord_job)
+            {
+            case 'S':
+            case 's':
+              sort_test = &fin;
+              break;
 
-	    case 'B':
-	    case 'b':
-	      sort_test = &fout;
-	      break;
+            case 'B':
+            case 'b':
+              sort_test = &fout;
+              break;
 
-	    case '+':
-	      sort_test = &fcrhp;
-	      break;
+            case '+':
+              sort_test = &fcrhp;
+              break;
 
-	    case '-':
-	      sort_test = &folhp;
-	      break;
+            case '-':
+              sort_test = &folhp;
+              break;
 
-	    default:
-	      // invalid order option (should never happen, since we
-	      // checked the options at the top).
-	      panic_impossible ();
-	      break;
-	    }
+            default:
+              // invalid order option (should never happen, since we
+              // checked the options at the top).
+              panic_impossible ();
+              break;
+            }
 
-	  octave_idx_type ndim, fail;
-	  double inf_norm;
+          octave_idx_type ndim, fail;
+          double inf_norm;
 
-	  F77_XFCN (xdlange, XDLANGE,
-		    (F77_CONST_CHAR_ARG2 ("I", 1),
-		     nn, nn, aa.data (), nn, work.fortran_vec (), inf_norm
-		     F77_CHAR_ARG_LEN (1)));
+          F77_XFCN (xdlange, XDLANGE,
+                    (F77_CONST_CHAR_ARG2 ("I", 1),
+                     nn, nn, aa.data (), nn, work.fortran_vec (), inf_norm
+                     F77_CHAR_ARG_LEN (1)));
 
-	  double eps = DBL_EPSILON*inf_norm*nn;
+          double eps = DBL_EPSILON*inf_norm*nn;
 
 #ifdef DEBUG_SORT
-	  std::cout << "qz: calling dsubsp: aa=" << std::endl;
-	  octave_print_internal (std::cout, aa, 0);
-	  std::cout << std::endl << "bb="  << std::endl;
-	  octave_print_internal (std::cout, bb, 0);
-	  if (compz == 'V')
-	    {
-	      std::cout << std::endl << "ZZ="  << std::endl;
-	      octave_print_internal (std::cout, ZZ, 0);
-	    }
-	  std::cout << std::endl;
-	  std::cout << "alphar = " << std::endl;
-	  octave_print_internal (std::cout, (Matrix) alphar, 0);
-	  std::cout << std::endl << "alphai = " << std::endl;
-	  octave_print_internal (std::cout, (Matrix) alphai, 0);
-	  std::cout << std::endl << "beta = " << std::endl;
-	  octave_print_internal (std::cout, (Matrix) betar, 0);
-	  std::cout << std::endl;
+          std::cout << "qz: calling dsubsp: aa=" << std::endl;
+          octave_print_internal (std::cout, aa, 0);
+          std::cout << std::endl << "bb="  << std::endl;
+          octave_print_internal (std::cout, bb, 0);
+          if (compz == 'V')
+            {
+              std::cout << std::endl << "ZZ="  << std::endl;
+              octave_print_internal (std::cout, ZZ, 0);
+            }
+          std::cout << std::endl;
+          std::cout << "alphar = " << std::endl;
+          octave_print_internal (std::cout, (Matrix) alphar, 0);
+          std::cout << std::endl << "alphai = " << std::endl;
+          octave_print_internal (std::cout, (Matrix) alphai, 0);
+          std::cout << std::endl << "beta = " << std::endl;
+          octave_print_internal (std::cout, (Matrix) betar, 0);
+          std::cout << std::endl;
 #endif
 
-	  Array<octave_idx_type> ind (nn);
+          Array<octave_idx_type> ind (nn);
 
-	  F77_XFCN (dsubsp, DSUBSP,
-		    (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
-		     ZZ.fortran_vec (), sort_test, eps, ndim, fail,
-		     ind.fortran_vec ()));
+          F77_XFCN (dsubsp, DSUBSP,
+                    (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
+                     ZZ.fortran_vec (), sort_test, eps, ndim, fail,
+                     ind.fortran_vec ()));
 
 #ifdef DEBUG
-	  std::cout << "qz: back from dsubsp: aa=" << std::endl;
-	  octave_print_internal (std::cout, aa, 0);
-	  std::cout << std::endl << "bb="  << std::endl;
-	  octave_print_internal (std::cout, bb, 0);
-	  if (compz == 'V')
-	    {
-	      std::cout << std::endl << "ZZ="  << std::endl;
-	      octave_print_internal (std::cout, ZZ, 0);
-	    }
-	  std::cout << std::endl;
+          std::cout << "qz: back from dsubsp: aa=" << std::endl;
+          octave_print_internal (std::cout, aa, 0);
+          std::cout << std::endl << "bb="  << std::endl;
+          octave_print_internal (std::cout, bb, 0);
+          if (compz == 'V')
+            {
+              std::cout << std::endl << "ZZ="  << std::endl;
+              octave_print_internal (std::cout, ZZ, 0);
+            }
+          std::cout << std::endl;
 #endif
 
-	  // manually update alphar, alphai, betar
-	  static int jj;
+          // manually update alphar, alphai, betar
+          static int jj;
 
-	  jj=0;
-	  while (jj < nn)
-	    {
+          jj=0;
+          while (jj < nn)
+            {
 #ifdef DEBUG_EIG
-	      std::cout << "computing gen eig #" << jj << std::endl;
+              std::cout << "computing gen eig #" << jj << std::endl;
 #endif
 
-	      static int zcnt;	// number of zeros in this block
+              static int zcnt;  // number of zeros in this block
 
-	      if (jj == (nn-1))
-		zcnt = 1;
-	      else if (aa(jj+1,jj) == 0)
-		zcnt = 1;
-	      else zcnt = 2;
+              if (jj == (nn-1))
+                zcnt = 1;
+              else if (aa(jj+1,jj) == 0)
+                zcnt = 1;
+              else zcnt = 2;
 
-	      if (zcnt == 1)  // real zero
-		{
+              if (zcnt == 1)  // real zero
+                {
 #ifdef DEBUG_EIG
-		  std::cout << "  single gen eig:" << std::endl;
-		  std::cout << "  alphar(" << jj << ") = " << aa(jj,jj) << std::endl;
-		  std::cout << "  betar( " << jj << ") = " << bb(jj,jj) << std::endl;
-		  std::cout << "  alphai(" << jj << ") = 0" << std::endl;
+                  std::cout << "  single gen eig:" << std::endl;
+                  std::cout << "  alphar(" << jj << ") = " << aa(jj,jj) << std::endl;
+                  std::cout << "  betar( " << jj << ") = " << bb(jj,jj) << std::endl;
+                  std::cout << "  alphai(" << jj << ") = 0" << std::endl;
 #endif
 
-		  alphar(jj) = aa(jj,jj);
-		  alphai(jj) = 0;
-		  betar(jj) = bb(jj,jj);
-		}
-	      else
-		{
-		  // complex conjugate pair
+                  alphar(jj) = aa(jj,jj);
+                  alphai(jj) = 0;
+                  betar(jj) = bb(jj,jj);
+                }
+              else
+                {
+                  // complex conjugate pair
 #ifdef DEBUG_EIG
-		  std::cout << "qz: calling dlag2:" << std::endl;
-		  std::cout << "safmin="
-		       << setiosflags (std::ios::scientific) << safmin << std::endl;
+                  std::cout << "qz: calling dlag2:" << std::endl;
+                  std::cout << "safmin="
+                       << setiosflags (std::ios::scientific) << safmin << std::endl;
 
-		  for (int idr = jj; idr <= jj+1; idr++)
-		    {
-		      for (int idc = jj; idc <= jj+1; idc++)
-			{
-			  std::cout << "aa(" << idr << "," << idc << ")="
-			       << aa(idr,idc) << std::endl;
-			  std::cout << "bb(" << idr << "," << idc << ")="
-			       << bb(idr,idc) << std::endl;
-			}
-		    }
+                  for (int idr = jj; idr <= jj+1; idr++)
+                    {
+                      for (int idc = jj; idc <= jj+1; idc++)
+                        {
+                          std::cout << "aa(" << idr << "," << idc << ")="
+                               << aa(idr,idc) << std::endl;
+                          std::cout << "bb(" << idr << "," << idc << ")="
+                               << bb(idr,idc) << std::endl;
+                        }
+                    }
 #endif
 
-		  // FIXME -- probably should be using
-		  // fortran_vec instead of &aa(jj,jj) here.
+                  // FIXME -- probably should be using
+                  // fortran_vec instead of &aa(jj,jj) here.
 
-		  double scale1, scale2, wr1, wr2, wi;
-		  const double *aa_ptr = aa.data () + jj*nn+jj;
-		  const double *bb_ptr = bb.data () + jj*nn+jj;
-		  F77_XFCN (dlag2, DLAG2,
-			    (aa_ptr, nn, bb_ptr, nn, safmin,
-			     scale1, scale2, wr1, wr2, wi));
+                  double scale1, scale2, wr1, wr2, wi;
+                  const double *aa_ptr = aa.data () + jj*nn+jj;
+                  const double *bb_ptr = bb.data () + jj*nn+jj;
+                  F77_XFCN (dlag2, DLAG2,
+                            (aa_ptr, nn, bb_ptr, nn, safmin,
+                             scale1, scale2, wr1, wr2, wi));
 
 #ifdef DEBUG_EIG
-		  std::cout << "dlag2 returns: scale1=" << scale1
-		       << "\tscale2=" << scale2 << std::endl
-		       << "\twr1=" << wr1 << "\twr2=" << wr2
-		       << "\twi=" << wi << std::endl;
+                  std::cout << "dlag2 returns: scale1=" << scale1
+                       << "\tscale2=" << scale2 << std::endl
+                       << "\twr1=" << wr1 << "\twr2=" << wr2
+                       << "\twi=" << wi << std::endl;
 #endif
 
-		  // just to be safe, check if it's a real pair
-		  if (wi == 0)
-		    {
-		      alphar(jj) = wr1;
-		      alphai(jj) = 0;
-		      betar(jj) = scale1;
-		      alphar(jj+1) = wr2;
-		      alphai(jj+1) = 0;
-		      betar(jj+1) = scale2;
-		    }
-		  else
-		    {
-		      alphar(jj) = alphar(jj+1)=wr1;
-		      alphai(jj) = -(alphai(jj+1) = wi);
-		      betar(jj)  = betar(jj+1) = scale1;
-		    }
-		}
+                  // just to be safe, check if it's a real pair
+                  if (wi == 0)
+                    {
+                      alphar(jj) = wr1;
+                      alphai(jj) = 0;
+                      betar(jj) = scale1;
+                      alphar(jj+1) = wr2;
+                      alphai(jj+1) = 0;
+                      betar(jj+1) = scale2;
+                    }
+                  else
+                    {
+                      alphar(jj) = alphar(jj+1)=wr1;
+                      alphai(jj) = -(alphai(jj+1) = wi);
+                      betar(jj)  = betar(jj+1) = scale1;
+                    }
+                }
 
-	      // advance past this block
-	      jj += zcnt;
-	    }
+              // advance past this block
+              jj += zcnt;
+            }
 
 #ifdef DEBUG_SORT
-	  std::cout << "qz: back from dsubsp: aa=" << std::endl;
-	  octave_print_internal (std::cout, aa, 0);
-	  std::cout << std::endl << "bb="  << std::endl;
-	  octave_print_internal (std::cout, bb, 0);
+          std::cout << "qz: back from dsubsp: aa=" << std::endl;
+          octave_print_internal (std::cout, aa, 0);
+          std::cout << std::endl << "bb="  << std::endl;
+          octave_print_internal (std::cout, bb, 0);
 
-	  if (compz == 'V')
-	    {
-	      std::cout << std::endl << "ZZ="  << std::endl;
-	      octave_print_internal (std::cout, ZZ, 0);
-	    }
-	  std::cout << std::endl << "qz: ndim=" << ndim << std::endl
-	       << "fail=" << fail << std::endl;
-	  std::cout << "alphar = " << std::endl;
-	  octave_print_internal (std::cout, (Matrix) alphar, 0);
-	  std::cout << std::endl << "alphai = " << std::endl;
-	  octave_print_internal (std::cout, (Matrix) alphai, 0);
-	  std::cout << std::endl << "beta = " << std::endl;
-	  octave_print_internal (std::cout, (Matrix) betar, 0);
-	  std::cout << std::endl;
+          if (compz == 'V')
+            {
+              std::cout << std::endl << "ZZ="  << std::endl;
+              octave_print_internal (std::cout, ZZ, 0);
+            }
+          std::cout << std::endl << "qz: ndim=" << ndim << std::endl
+               << "fail=" << fail << std::endl;
+          std::cout << "alphar = " << std::endl;
+          octave_print_internal (std::cout, (Matrix) alphar, 0);
+          std::cout << std::endl << "alphai = " << std::endl;
+          octave_print_internal (std::cout, (Matrix) alphai, 0);
+          std::cout << std::endl << "beta = " << std::endl;
+          octave_print_internal (std::cout, (Matrix) betar, 0);
+          std::cout << std::endl;
 #endif
-	}
+        }
     }
 
   // compute  generalized eigenvalues?
   ComplexColumnVector gev;
 
   if (nargout < 2 || nargout == 7 || (nargin == 3 && nargout == 4))
     {
       if (complex_case)
-	{
-	  error ("complex case not yet implemented");
-	  return retval;
-	}
+        {
+          error ("complex case not yet implemented");
+          return retval;
+        }
       else
-	{
+        {
 #ifdef DEBUG
-	  std::cout << "qz: computing generalized eigenvalues" << std::endl;
+          std::cout << "qz: computing generalized eigenvalues" << std::endl;
 #endif
 
-	  // return finite generalized eigenvalues
-	  int cnt = 0;
+          // return finite generalized eigenvalues
+          int cnt = 0;
 
-	  for (int ii = 0; ii < nn; ii++)
-	    if (betar(ii) != 0)
-	      cnt++;
+          for (int ii = 0; ii < nn; ii++)
+            if (betar(ii) != 0)
+              cnt++;
 
-	  ComplexColumnVector tmp(cnt);
+          ComplexColumnVector tmp(cnt);
 
-	  cnt = 0;
-	  for (int ii = 0; ii < nn; ii++)
-	    if (betar(ii) != 0)
-	      tmp(cnt++) = Complex(alphar(ii), alphai(ii))/betar(ii);
-	  gev = tmp;
-	}
+          cnt = 0;
+          for (int ii = 0; ii < nn; ii++)
+            if (betar(ii) != 0)
+              tmp(cnt++) = Complex(alphar(ii), alphai(ii))/betar(ii);
+          gev = tmp;
+        }
     }
 
   // right, left eigenvector matrices
   if (nargout >= 5)
     {
-      char side = (nargout == 5 ? 'R' : 'B');	// which side to compute?
+      char side = (nargout == 5 ? 'R' : 'B');   // which side to compute?
       char howmny = 'B';  // compute all of them and backtransform
       octave_idx_type *select = 0; // dummy pointer; select is not used.
       octave_idx_type m;
 
       if (complex_case)
-	{
-	  error ("complex type not yet implemented");
-	  return retval;
-	}
+        {
+          error ("complex type not yet implemented");
+          return retval;
+        }
       else
-	{
+        {
 #ifdef DEBUG
-	  std::cout << "qz: computing  generalized eigenvectors" << std::endl;
+          std::cout << "qz: computing  generalized eigenvectors" << std::endl;
 #endif
 
-	  VL = QQ;
-	  VR = ZZ;
+          VL = QQ;
+          VR = ZZ;
 
-	  F77_XFCN (dtgevc, DTGEVC,
-		    (F77_CONST_CHAR_ARG2 (&side, 1),
-		     F77_CONST_CHAR_ARG2 (&howmny, 1),
-		     select, nn, aa.fortran_vec (), nn, bb.fortran_vec (),
-		     nn, VL.fortran_vec (), nn, VR.fortran_vec (), nn, nn,
-		     m, work.fortran_vec (), info
-		     F77_CHAR_ARG_LEN (1)
-		     F77_CHAR_ARG_LEN (1)));
+          F77_XFCN (dtgevc, DTGEVC,
+                    (F77_CONST_CHAR_ARG2 (&side, 1),
+                     F77_CONST_CHAR_ARG2 (&howmny, 1),
+                     select, nn, aa.fortran_vec (), nn, bb.fortran_vec (),
+                     nn, VL.fortran_vec (), nn, VR.fortran_vec (), nn, nn,
+                     m, work.fortran_vec (), info
+                     F77_CHAR_ARG_LEN (1)
+                     F77_CHAR_ARG_LEN (1)));
 
-	  // now construct the complex form of VV, WW
-	  int jj = 0;
+          // now construct the complex form of VV, WW
+          int jj = 0;
 
-	  while (jj < nn)
-	    {
-	      OCTAVE_QUIT;
+          while (jj < nn)
+            {
+              OCTAVE_QUIT;
 
-	      // see if real or complex eigenvalue
-	      int cinc = 2;	// column increment; assume complex eigenvalue
+              // see if real or complex eigenvalue
+              int cinc = 2;     // column increment; assume complex eigenvalue
 
-	      if (jj == (nn-1))
-		cinc = 1;	// single column
-	      else if (aa(jj+1,jj) == 0)
-		cinc = 1;
+              if (jj == (nn-1))
+                cinc = 1;       // single column
+              else if (aa(jj+1,jj) == 0)
+                cinc = 1;
 
-	      // now copy the eigenvector (s) to CVR, CVL
-	      if (cinc == 1)
-		{
-		  for (int ii = 0; ii < nn; ii++)
-		    CVR(ii,jj) = VR(ii,jj);
+              // now copy the eigenvector (s) to CVR, CVL
+              if (cinc == 1)
+                {
+                  for (int ii = 0; ii < nn; ii++)
+                    CVR(ii,jj) = VR(ii,jj);
 
-		  if (side == 'B')
-		    for (int ii = 0; ii < nn; ii++)
-		      CVL(ii,jj) = VL(ii,jj);
-		}
-	      else
-		{
-		  // double column; complex vector
+                  if (side == 'B')
+                    for (int ii = 0; ii < nn; ii++)
+                      CVL(ii,jj) = VL(ii,jj);
+                }
+              else
+                {
+                  // double column; complex vector
 
-		  for (int ii = 0; ii < nn; ii++)
-		    {
-		      CVR(ii,jj) = Complex (VR(ii,jj), VR(ii,jj+1));
-		      CVR(ii,jj+1) = Complex (VR(ii,jj), -VR(ii,jj+1));
-		    }
+                  for (int ii = 0; ii < nn; ii++)
+                    {
+                      CVR(ii,jj) = Complex (VR(ii,jj), VR(ii,jj+1));
+                      CVR(ii,jj+1) = Complex (VR(ii,jj), -VR(ii,jj+1));
+                    }
 
-		  if (side == 'B')
-		    for (int ii = 0; ii < nn; ii++)
-		      {
-			CVL(ii,jj) = Complex (VL(ii,jj), VL(ii,jj+1));
-			CVL(ii,jj+1) = Complex (VL(ii,jj), -VL(ii,jj+1));
-		      }
-		}
+                  if (side == 'B')
+                    for (int ii = 0; ii < nn; ii++)
+                      {
+                        CVL(ii,jj) = Complex (VL(ii,jj), VL(ii,jj+1));
+                        CVL(ii,jj+1) = Complex (VL(ii,jj), -VL(ii,jj+1));
+                      }
+                }
 
-	      // advance to next eigenvectors (if any)
-	      jj += cinc;
-	    }
-	}
+              // advance to next eigenvectors (if any)
+              jj += cinc;
+            }
+        }
     }
 
   switch (nargout)
     {
     case 7:
       retval(6) = gev;
 
-    case 6:	// return eigenvectors
+    case 6:     // return eigenvectors
       retval(5) = CVL;
 
-    case 5:	// return eigenvectors
+    case 5:     // return eigenvectors
       retval(4) = CVR;
 
     case 4:
       if (nargin == 3)
-	{
+        {
 #ifdef DEBUG
-	  std::cout << "qz: sort: retval(3) = gev = " << std::endl;
-	  octave_print_internal (std::cout, gev);
-	  std::cout << std::endl;
+          std::cout << "qz: sort: retval(3) = gev = " << std::endl;
+          octave_print_internal (std::cout, gev);
+          std::cout << std::endl;
 #endif
-	  retval(3) = gev;
-	}
+          retval(3) = gev;
+        }
       else
-	retval(3) = ZZ;
+        retval(3) = ZZ;
 
     case 3:
       if (nargin == 3)
-	retval(2) = ZZ;
+        retval(2) = ZZ;
       else
-	retval(2) = QQ;
+        retval(2) = QQ;
 
     case 2:
 #ifdef DEBUG
       std::cout << "qz: retval (1) = bb = " << std::endl;
       octave_print_internal (std::cout, bb, 0);
       std::cout << std::endl << "qz: retval(0) = aa = " <<std::endl;
       octave_print_internal (std::cout, aa, 0);
       std::cout << std::endl;
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -46,269 +46,269 @@ along with Octave; see the file COPYING.
 /*
 %!shared __random_statistical_tests__
 %! % Flag whether the statistical tests should be run in "make check" or not
 %! __random_statistical_tests__ = 0;
 */
 
 static octave_value
 do_rand (const octave_value_list& args, int nargin, const char *fcn,
-	 bool additional_arg = false)
+         bool additional_arg = false)
 {
   octave_value retval;
   NDArray a;
   int idx = 0;
   dim_vector dims;
 
   if (additional_arg)
     {
       if (nargin == 0)
-	{
-	  error ("%s: expecting at least one argument", fcn);
-	  goto done;
-	}
+        {
+          error ("%s: expecting at least one argument", fcn);
+          goto done;
+        }
       else if (args(0).is_string())
-	additional_arg = false;
+        additional_arg = false;
       else
-	{
-	  a = args(0).array_value ();
-	  if (error_state)
-	    {
-	      error ("%s: expecting scalar or matrix arguments", fcn);
-	      goto done;
-	    }
-	  idx++;
-	  nargin--;
-	}
+        {
+          a = args(0).array_value ();
+          if (error_state)
+            {
+              error ("%s: expecting scalar or matrix arguments", fcn);
+              goto done;
+            }
+          idx++;
+          nargin--;
+        }
     }
 
   switch (nargin)
     {
     case 0:
       {
-	if (additional_arg)
-	  dims = a.dims ();
-	else
-	  {
-	    dims.resize (2);
+        if (additional_arg)
+          dims = a.dims ();
+        else
+          {
+            dims.resize (2);
 
-	    dims(0) = 1;
-	    dims(1) = 1;
-	  }
-	goto gen_matrix;
+            dims(0) = 1;
+            dims(1) = 1;
+          }
+        goto gen_matrix;
       }
       break;
 
     case 1:
       {
-	octave_value tmp = args(idx);
+        octave_value tmp = args(idx);
 
-	if (tmp.is_string ())
-	  {
-	    std::string s_arg = tmp.string_value ();
+        if (tmp.is_string ())
+          {
+            std::string s_arg = tmp.string_value ();
 
-	    if (s_arg == "dist")
-	      {
-		retval = octave_rand::distribution ();
-	      }
-	    else if (s_arg == "seed")
-	      {
-		retval = octave_rand::seed ();
-	      }
-	    else if (s_arg == "state" || s_arg == "twister")
-	      {
-		retval = octave_rand::state (fcn);
-	      }
-	    else if (s_arg == "uniform")
-	      {
-		octave_rand::uniform_distribution ();
-	      }
-	    else if (s_arg == "normal")
-	      {
-		octave_rand::normal_distribution ();
-	      }
-	    else if (s_arg == "exponential")
-	      {
-		octave_rand::exponential_distribution ();
-	      }
-	    else if (s_arg == "poisson")
-	      {
-		octave_rand::poisson_distribution ();
-	      }
-	    else if (s_arg == "gamma")
-	      {
-		octave_rand::gamma_distribution ();
-	      }
-	    else
-	      error ("%s: unrecognized string argument", fcn);
-	  }
-	else if (tmp.is_scalar_type ())
-	  {
-	    double dval = tmp.double_value ();
+            if (s_arg == "dist")
+              {
+                retval = octave_rand::distribution ();
+              }
+            else if (s_arg == "seed")
+              {
+                retval = octave_rand::seed ();
+              }
+            else if (s_arg == "state" || s_arg == "twister")
+              {
+                retval = octave_rand::state (fcn);
+              }
+            else if (s_arg == "uniform")
+              {
+                octave_rand::uniform_distribution ();
+              }
+            else if (s_arg == "normal")
+              {
+                octave_rand::normal_distribution ();
+              }
+            else if (s_arg == "exponential")
+              {
+                octave_rand::exponential_distribution ();
+              }
+            else if (s_arg == "poisson")
+              {
+                octave_rand::poisson_distribution ();
+              }
+            else if (s_arg == "gamma")
+              {
+                octave_rand::gamma_distribution ();
+              }
+            else
+              error ("%s: unrecognized string argument", fcn);
+          }
+        else if (tmp.is_scalar_type ())
+          {
+            double dval = tmp.double_value ();
 
-	    if (xisnan (dval))
-	      {
-		error ("%s: NaN is invalid a matrix dimension", fcn);
-	      }
-	    else
-	      {
-		dims.resize (2);
+            if (xisnan (dval))
+              {
+                error ("%s: NaN is invalid a matrix dimension", fcn);
+              }
+            else
+              {
+                dims.resize (2);
 
-		dims(0) = NINTbig (tmp.double_value ());
-		dims(1) = NINTbig (tmp.double_value ());
+                dims(0) = NINTbig (tmp.double_value ());
+                dims(1) = NINTbig (tmp.double_value ());
 
-		if (! error_state)
-		  goto gen_matrix;
-	      }
-	  }
-	else if (tmp.is_range ())
-	  {
-	    Range r = tmp.range_value ();
+                if (! error_state)
+                  goto gen_matrix;
+              }
+          }
+        else if (tmp.is_range ())
+          {
+            Range r = tmp.range_value ();
 
-	    if (r.all_elements_are_ints ())
-	      {
-		octave_idx_type n = r.nelem ();
+            if (r.all_elements_are_ints ())
+              {
+                octave_idx_type n = r.nelem ();
 
-		dims.resize (n);
+                dims.resize (n);
 
-		octave_idx_type base = NINTbig (r.base ());
-		octave_idx_type incr = NINTbig (r.inc ());
-		octave_idx_type lim = NINTbig (r.limit ());
+                octave_idx_type base = NINTbig (r.base ());
+                octave_idx_type incr = NINTbig (r.inc ());
+                octave_idx_type lim = NINTbig (r.limit ());
 
-		if (base < 0 || lim < 0)
-		  error ("%s: all dimensions must be nonnegative", fcn);
-		else
-		  {
-		    for (octave_idx_type i = 0; i < n; i++)
-		      {
-			dims(i) = base;
-			base += incr;
-		      }
+                if (base < 0 || lim < 0)
+                  error ("%s: all dimensions must be nonnegative", fcn);
+                else
+                  {
+                    for (octave_idx_type i = 0; i < n; i++)
+                      {
+                        dims(i) = base;
+                        base += incr;
+                      }
 
-		    goto gen_matrix;
-		  }
-	      }
-	    else
-	      error ("%s: expecting all elements of range to be integers",
-		     fcn);
-	  }
-	else if (tmp.is_matrix_type ())
-	  {
-	    Array<int> iv = tmp.int_vector_value (true);
+                    goto gen_matrix;
+                  }
+              }
+            else
+              error ("%s: expecting all elements of range to be integers",
+                     fcn);
+          }
+        else if (tmp.is_matrix_type ())
+          {
+            Array<int> iv = tmp.int_vector_value (true);
 
-	    if (! error_state)
-	      {
-		octave_idx_type len = iv.length ();
+            if (! error_state)
+              {
+                octave_idx_type len = iv.length ();
 
-		dims.resize (len);
+                dims.resize (len);
 
-		for (octave_idx_type i = 0; i < len; i++)
-		  {
-		    octave_idx_type elt = iv(i);
+                for (octave_idx_type i = 0; i < len; i++)
+                  {
+                    octave_idx_type elt = iv(i);
 
-		    if (elt < 0)
-		      {
-			error ("%s: all dimensions must be nonnegative", fcn);
-			goto done;
-		      }
+                    if (elt < 0)
+                      {
+                        error ("%s: all dimensions must be nonnegative", fcn);
+                        goto done;
+                      }
 
-		    dims(i) = iv(i);
-		  }
+                    dims(i) = iv(i);
+                  }
 
-		goto gen_matrix;
-	      }
-	    else
-	      error ("%s: expecting integer vector", fcn);
-	  }
-	else
-	  {
-	    gripe_wrong_type_arg ("rand", tmp);
-	    return retval;
-	  }
+                goto gen_matrix;
+              }
+            else
+              error ("%s: expecting integer vector", fcn);
+          }
+        else
+          {
+            gripe_wrong_type_arg ("rand", tmp);
+            return retval;
+          }
       }
       break;
 
     default:
       {
-	octave_value tmp = args(idx);
+        octave_value tmp = args(idx);
 
-	if (nargin == 2 && tmp.is_string ())
-	  {
-	    std::string ts = tmp.string_value ();
+        if (nargin == 2 && tmp.is_string ())
+          {
+            std::string ts = tmp.string_value ();
 
-	    if (ts == "seed")
-	      {
-		if (args(idx+1).is_real_scalar ())
-		  {
-		    double d = args(idx+1).double_value ();
+            if (ts == "seed")
+              {
+                if (args(idx+1).is_real_scalar ())
+                  {
+                    double d = args(idx+1).double_value ();
 
-		    if (! error_state)
-		      octave_rand::seed (d);
-		  }
-		else
-		  error ("%s: seed must be a real scalar", fcn);
-	      }
-	    else if (ts == "state" || ts == "twister")
-	      {
-		ColumnVector s = 
-		  ColumnVector (args(idx+1).vector_value(false, true));
+                    if (! error_state)
+                      octave_rand::seed (d);
+                  }
+                else
+                  error ("%s: seed must be a real scalar", fcn);
+              }
+            else if (ts == "state" || ts == "twister")
+              {
+                ColumnVector s = 
+                  ColumnVector (args(idx+1).vector_value(false, true));
 
-		if (! error_state)
-		  octave_rand::state (s, fcn);
-	      }
-	    else
-	      error ("%s: unrecognized string argument", fcn);
-	  }
-	else
-	  {
-	    dims.resize (nargin);
+                if (! error_state)
+                  octave_rand::state (s, fcn);
+              }
+            else
+              error ("%s: unrecognized string argument", fcn);
+          }
+        else
+          {
+            dims.resize (nargin);
 
-	    for (int i = 0; i < nargin; i++)
-	      {
-		dims(i) = args(idx+i).int_value ();
+            for (int i = 0; i < nargin; i++)
+              {
+                dims(i) = args(idx+i).int_value ();
 
-		if (error_state)
-		  {
-		    error ("%s: expecting integer arguments", fcn);
-		    goto done;
-		  }
-	      }
+                if (error_state)
+                  {
+                    error ("%s: expecting integer arguments", fcn);
+                    goto done;
+                  }
+              }
 
-	    goto gen_matrix;
-	  }
+            goto gen_matrix;
+          }
       }
       break;
     }
 
  done:
 
   return retval;
 
  gen_matrix:
 
   dims.chop_trailing_singletons ();
 
   if (additional_arg)
     {
       if (a.length() == 1)
-	return octave_rand::nd_array (dims, a(0));
+        return octave_rand::nd_array (dims, a(0));
       else
-	{
-	  if (a.dims() != dims)
-	    {
-	      error ("%s: mismatch in argument size", fcn);
-	      return retval;
-	    }
-	  octave_idx_type len = a.length ();
-	  NDArray m (dims);
-	  double *v = m.fortran_vec ();
-	  for (octave_idx_type i = 0; i < len; i++)
-	    v[i] = octave_rand::scalar (a(i));
-	  return m;
-	}
+        {
+          if (a.dims() != dims)
+            {
+              error ("%s: mismatch in argument size", fcn);
+              return retval;
+            }
+          octave_idx_type len = a.length ();
+          NDArray m (dims);
+          double *v = m.fortran_vec ();
+          for (octave_idx_type i = 0; i < len; i++)
+            v[i] = octave_rand::scalar (a(i));
+          return m;
+        }
     }
   else
     return octave_rand::nd_array (dims);
 }
 
 DEFUN_DLD (rand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} rand (@var{x})\n\
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -49,29 +49,29 @@ instead.\n\
 
   if (nargin != 1)
     print_usage ();
   else if (args(0).is_sparse_type ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
   else if (args(0).is_single_type ())
     {
       if (args(0).is_complex_type ())
-	{
-	  FloatComplexMatrix m = args(0).float_complex_matrix_value ();
-	  MatrixType mattyp;
-	  retval = m.rcond (mattyp);
-	  args(0).matrix_type (mattyp);
-	}
+        {
+          FloatComplexMatrix m = args(0).float_complex_matrix_value ();
+          MatrixType mattyp;
+          retval = m.rcond (mattyp);
+          args(0).matrix_type (mattyp);
+        }
       else
-	{
-	  FloatMatrix m = args(0).float_matrix_value ();
-	  MatrixType mattyp;
-	  retval = m.rcond (mattyp);
-	  args(0).matrix_type (mattyp);
-	}
+        {
+          FloatMatrix m = args(0).float_matrix_value ();
+          MatrixType mattyp;
+          retval = m.rcond (mattyp);
+          args(0).matrix_type (mattyp);
+        }
     }
   else if (args(0).is_complex_type ())
     {
       ComplexMatrix m = args(0).complex_matrix_value ();
       MatrixType mattyp;
       retval = m.rcond (mattyp);
       args(0).matrix_type (mattyp);
     }
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -62,55 +62,55 @@ along with Octave; see the file COPYING.
 
 // FIXME don't bother collecting and composing return values the user
 // doesn't want.
 
 class regexp_elem
 {
 public:
   regexp_elem (const string_vector& _named_token, const Cell& _t, 
-	       const std::string& _m, const Matrix& _te, double _s, 
-	       double _e) :
+               const std::string& _m, const Matrix& _te, double _s, 
+               double _e) :
     named_token (_named_token), t (_t), m (_m), te (_te), s (_s), e (_e) { }
 
   regexp_elem (const regexp_elem &a) : named_token (a.named_token), t (a.t), 
-				       m (a.m), te (a.te), s (a.s), e (a.e)
-				       { }
+                                       m (a.m), te (a.te), s (a.s), e (a.e)
+                                       { }
 
   string_vector named_token;
   Cell t;
   std::string m;
   Matrix te;
   double s;
   double e;
 };
 
 typedef std::list<regexp_elem>::const_iterator const_iterator;
 
 #define MAXLOOKBEHIND 10
 static bool lookbehind_warned = false;
 
 static int
 octregexp_list (const octave_value_list &args, const std::string &nm, 
-		bool case_insensitive, std::list<regexp_elem> &lst, 
-		string_vector &named, int &nopts, bool &once)
+                bool case_insensitive, std::list<regexp_elem> &lst, 
+                string_vector &named, int &nopts, bool &once)
 {
   int sz = 0;
 #if defined (HAVE_REGEX) || defined (HAVE_PCRE) 
   int nargin = args.length();
   bool lineanchors = false;
   bool dotexceptnewline = false;
   bool freespacing = false;
 
   nopts = nargin - 2;
   once = false;
 
   std::string buffer = args(0).string_value ();
   size_t max_length = (buffer.length () > MAXLOOKBEHIND ? 
-		       MAXLOOKBEHIND: buffer.length ());
+                       MAXLOOKBEHIND: buffer.length ());
 
   if (error_state)
     {
       gripe_wrong_type_arg (nm.c_str(), args(0));
       return 0;
     }
 
   std::string pattern = args(1).string_value ();
@@ -119,82 +119,82 @@ octregexp_list (const octave_value_list 
       gripe_wrong_type_arg (nm.c_str(), args(1));
       return 0;
     }
 
   for (int i = 2; i < nargin; i++)
     {
       std::string str = args(i).string_value();
       if (error_state)
-	{
-	  error ("%s: optional arguments must be strings", nm.c_str());
-	  break;
-	}
+        {
+          error ("%s: optional arguments must be strings", nm.c_str());
+          break;
+        }
       std::transform (str.begin (), str.end (), str.begin (), tolower);
       if (str.find("once", 0) == 0)
-	{
-	  once = true;
-	  nopts--;
-	}
+        {
+          once = true;
+          nopts--;
+        }
       else if (str.find("matchcase", 0) == 0)
-	{
-	  case_insensitive = false;
-	  nopts--;
-	}
+        {
+          case_insensitive = false;
+          nopts--;
+        }
       else if (str.find("ignorecase", 0) == 0)
-	{
-	  case_insensitive = true;
-	  nopts--;
-	}
+        {
+          case_insensitive = true;
+          nopts--;
+        }
       else if (str.find("dotall", 0) == 0)
-	{
-	  dotexceptnewline = false;
-	  nopts--;
-	}
+        {
+          dotexceptnewline = false;
+          nopts--;
+        }
       else if (str.find("stringanchors", 0) == 0)
-	{
-	  lineanchors = false;
-	  nopts--;
-	}
+        {
+          lineanchors = false;
+          nopts--;
+        }
       else if (str.find("literalspacing", 0) == 0)
-	{
-	  freespacing = false;
-	  nopts--;
-	}
+        {
+          freespacing = false;
+          nopts--;
+        }
 #if HAVE_PCRE
       // Only accept these options with pcre
       else if (str.find("dotexceptnewline", 0) == 0)
-	{
-	  dotexceptnewline = true;
-	  nopts--;
-	}
+        {
+          dotexceptnewline = true;
+          nopts--;
+        }
       else if (str.find("lineanchors", 0) == 0)
-	{
-	  lineanchors = true;
-	  nopts--;
-	}
+        {
+          lineanchors = true;
+          nopts--;
+        }
       else if (str.find("freespacing", 0) == 0)
-	{
-	  freespacing = true;
-	  nopts--;
-	}
+        {
+          freespacing = true;
+          nopts--;
+        }
       else if (str.find("start", 0) && str.find("end", 0) &&
-	       str.find("tokenextents", 0) && str.find("match", 0) &&
-	       str.find("tokens", 0) && str.find("names", 0))
-	error ("%s: unrecognized option", nm.c_str());
+               str.find("tokenextents", 0) && str.find("match", 0) &&
+               str.find("tokens", 0) && str.find("names", 0))
+        error ("%s: unrecognized option", nm.c_str());
 #else
       else if (str.find("names", 0) == 0 ||
-	       str.find("dotexceptnewline", 0) == 0 ||
-	       str.find("lineanchors", 0) == 0 ||
-	       str.find("freespacing", 0) == 0)
+               str.find("dotexceptnewline", 0) == 0 ||
+               str.find("lineanchors", 0) == 0 ||
+               str.find("freespacing", 0) == 0)
        error ("%s: %s not implemented in this version", str.c_str(), nm.c_str());
       else if (str.find("start", 0) && str.find("end", 0) &&
-	       str.find("tokenextents", 0) && str.find("match", 0) &&
-	       str.find("tokens", 0))
-	error ("%s: unrecognized option", nm.c_str());
+               str.find("tokenextents", 0) && str.find("match", 0) &&
+               str.find("tokens", 0))
+        error ("%s: unrecognized option", nm.c_str());
 #endif
     }
 
   if (!error_state)
     {
       Cell t;
       std::string m;
       double s, e;
@@ -205,163 +205,163 @@ octregexp_list (const octave_value_list 
       size_t pos = 0;
       size_t new_pos;
       int nnames = 0;
       int inames = 0;
       std::ostringstream buf;
       Array<int> named_idx;
 
       while ((new_pos = pattern.find ("(?",pos)) != std::string::npos)
-	{
-	  if (pattern.at (new_pos + 2) == '<' &&  
-	      !(pattern.at (new_pos + 3) == '=' ||
-		pattern.at (new_pos + 3) == '!'))
-	    {
-	      // The syntax of named tokens in pcre is "(?P<name>...)" while
-	      // we need a syntax "(?<name>...)", so fix that here. Also an 
-	      // expression like 
-	      // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)" 
-	      // should be perfectly legal, while pcre does not allow the same
-	      // named token name on both sides of the alternative. Also fix
-	      // that here by replacing name tokens by dummy names, and dealing
-	      // with the dummy names later.
+        {
+          if (pattern.at (new_pos + 2) == '<' &&  
+              !(pattern.at (new_pos + 3) == '=' ||
+                pattern.at (new_pos + 3) == '!'))
+            {
+              // The syntax of named tokens in pcre is "(?P<name>...)" while
+              // we need a syntax "(?<name>...)", so fix that here. Also an 
+              // expression like 
+              // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)" 
+              // should be perfectly legal, while pcre does not allow the same
+              // named token name on both sides of the alternative. Also fix
+              // that here by replacing name tokens by dummy names, and dealing
+              // with the dummy names later.
 
-	      size_t tmp_pos = pattern.find_first_of ('>',new_pos);
+              size_t tmp_pos = pattern.find_first_of ('>',new_pos);
 
-	      if (tmp_pos == std::string::npos)
-		{
-		  error ("syntax error in pattern");
-		  break;
-		}
+              if (tmp_pos == std::string::npos)
+                {
+                  error ("syntax error in pattern");
+                  break;
+                }
 
-	      std::string tmp_name = 
-		pattern.substr(new_pos+3,tmp_pos-new_pos-3);
-	      bool found = false;
+              std::string tmp_name = 
+                pattern.substr(new_pos+3,tmp_pos-new_pos-3);
+              bool found = false;
 
-	      for (int i = 0; i < nnames; i++)
-		if (named(i) == tmp_name)
-		  {
-		    named_idx.resize(inames+1);
-		    named_idx(inames) = i;
-		    found = true;
-		    break;
-		  }
-	      if (! found)
-		{
-		  named_idx.resize(inames+1);
-		  named_idx(inames) = nnames;
-		  named.append(tmp_name);
-		  nnames++;
-		}
+              for (int i = 0; i < nnames; i++)
+                if (named(i) == tmp_name)
+                  {
+                    named_idx.resize(inames+1);
+                    named_idx(inames) = i;
+                    found = true;
+                    break;
+                  }
+              if (! found)
+                {
+                  named_idx.resize(inames+1);
+                  named_idx(inames) = nnames;
+                  named.append(tmp_name);
+                  nnames++;
+                }
 
-	      if (new_pos - pos > 0)
-		buf << pattern.substr(pos,new_pos-pos);
-	      if (inames < 10)
-		buf << "(?P<n00" << inames++;
-	      else if (inames < 100)
-		buf << "(?P<n0" << inames++;
-	      else
-		buf << "(?P<n" << inames++;
-	      pos = tmp_pos;
-	    }
-	  else if (pattern.at (new_pos + 2) == '<')
-	    {
-	      // Find lookbehind operators of arbitrary length (ie like 
-	      // "(?<=[a-z]*)") and replace with a maximum length operator 
-	      // as PCRE can not yet handle arbitrary length lookahead 
-	      // operators. Use the string length as the maximum length to 
-	      // avoid issues.
+              if (new_pos - pos > 0)
+                buf << pattern.substr(pos,new_pos-pos);
+              if (inames < 10)
+                buf << "(?P<n00" << inames++;
+              else if (inames < 100)
+                buf << "(?P<n0" << inames++;
+              else
+                buf << "(?P<n" << inames++;
+              pos = tmp_pos;
+            }
+          else if (pattern.at (new_pos + 2) == '<')
+            {
+              // Find lookbehind operators of arbitrary length (ie like 
+              // "(?<=[a-z]*)") and replace with a maximum length operator 
+              // as PCRE can not yet handle arbitrary length lookahead 
+              // operators. Use the string length as the maximum length to 
+              // avoid issues.
 
-	      int brackets = 1;
-	      size_t tmp_pos1 = new_pos + 2;
-	      size_t tmp_pos2 = tmp_pos1;
-	      while (tmp_pos1 <= pattern.length () && brackets > 0)
-		{
-		  char ch = pattern.at (tmp_pos1);
-		  if (ch == '(')
-		    brackets++;
-		  else if (ch == ')')
-		    {
-		      if (brackets > 1)
-			tmp_pos2 = tmp_pos1;
+              int brackets = 1;
+              size_t tmp_pos1 = new_pos + 2;
+              size_t tmp_pos2 = tmp_pos1;
+              while (tmp_pos1 <= pattern.length () && brackets > 0)
+                {
+                  char ch = pattern.at (tmp_pos1);
+                  if (ch == '(')
+                    brackets++;
+                  else if (ch == ')')
+                    {
+                      if (brackets > 1)
+                        tmp_pos2 = tmp_pos1;
 
-		      brackets--;
-		    }
-		  tmp_pos1++;
-		}
+                      brackets--;
+                    }
+                  tmp_pos1++;
+                }
 
-	      if (brackets != 0)
-		{
-		  buf << pattern.substr (pos, new_pos - pos) << "(?";
-		  pos = new_pos + 2;
-		}
-	      else
-		{
-		  size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
-		  if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
-		    {
-		      if (!lookbehind_warned)
-			{
-			  lookbehind_warned = true;
-			  warning ("%s: arbitrary length lookbehind patterns are only support up to length %d", nm.c_str(), MAXLOOKBEHIND);
-			}
+              if (brackets != 0)
+                {
+                  buf << pattern.substr (pos, new_pos - pos) << "(?";
+                  pos = new_pos + 2;
+                }
+              else
+                {
+                  size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
+                  if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
+                    {
+                      if (!lookbehind_warned)
+                        {
+                          lookbehind_warned = true;
+                          warning ("%s: arbitrary length lookbehind patterns are only support up to length %d", nm.c_str(), MAXLOOKBEHIND);
+                        }
 
-		      buf << pattern.substr (pos, new_pos - pos) << "(";
+                      buf << pattern.substr (pos, new_pos - pos) << "(";
 
-		      size_t i;
-		      if (pattern.at (tmp_pos3) == '*')
-			i = 0;
-		      else
-			i = 1;
+                      size_t i;
+                      if (pattern.at (tmp_pos3) == '*')
+                        i = 0;
+                      else
+                        i = 1;
 
-		      for (; i < max_length + 1; i++)
-			{
-			  buf << pattern.substr(new_pos, tmp_pos3 - new_pos)
-			      << "{" << i << "}";
-			  buf << pattern.substr(tmp_pos3 + 1, 
-						tmp_pos1 - tmp_pos3 - 1);
-			  if (i != max_length)
-			    buf << "|";
-			}
-		      buf << ")";
-		    }
-		  else
-		    buf << pattern.substr (pos, tmp_pos1 - pos);
-		  pos = tmp_pos1;
-		}
-	    }
-	  else
-	    {
-	      buf << pattern.substr (pos, new_pos - pos) << "(?";
-	      pos = new_pos + 2;
-	    }
+                      for (; i < max_length + 1; i++)
+                        {
+                          buf << pattern.substr(new_pos, tmp_pos3 - new_pos)
+                              << "{" << i << "}";
+                          buf << pattern.substr(tmp_pos3 + 1, 
+                                                tmp_pos1 - tmp_pos3 - 1);
+                          if (i != max_length)
+                            buf << "|";
+                        }
+                      buf << ")";
+                    }
+                  else
+                    buf << pattern.substr (pos, tmp_pos1 - pos);
+                  pos = tmp_pos1;
+                }
+            }
+          else
+            {
+              buf << pattern.substr (pos, new_pos - pos) << "(?";
+              pos = new_pos + 2;
+            }
 
-	}
+        }
 
       buf << pattern.substr(pos);
 
       if (error_state)
-	return 0;
+        return 0;
 
       // Compile expression
       pcre *re;
       const char *err;
       int erroffset;
       std::string buf_str = buf.str ();
       re = pcre_compile (buf_str.c_str (),
-			 (case_insensitive ? PCRE_CASELESS : 0) |
-			 (dotexceptnewline ? 0 : PCRE_DOTALL) |
-			 (lineanchors ? PCRE_MULTILINE : 0) |
-			 (freespacing ? PCRE_EXTENDED : 0),
-			 &err, &erroffset, 0);
+                         (case_insensitive ? PCRE_CASELESS : 0) |
+                         (dotexceptnewline ? 0 : PCRE_DOTALL) |
+                         (lineanchors ? PCRE_MULTILINE : 0) |
+                         (freespacing ? PCRE_EXTENDED : 0),
+                         &err, &erroffset, 0);
     
       if (re == 0) {
-	error("%s: %s at position %d of expression", nm.c_str(), 
-	      err, erroffset);
-	return 0;
+        error("%s: %s at position %d of expression", nm.c_str(), 
+              err, erroffset);
+        return 0;
       }
 
       int subpatterns;
       int namecount;
       int nameentrysize;
       char *nametable;
       int idx = 0;
 
@@ -369,208 +369,208 @@ octregexp_list (const octave_value_list 
       pcre_fullinfo(re, 0, PCRE_INFO_NAMECOUNT, &namecount);
       pcre_fullinfo(re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
       pcre_fullinfo(re, 0, PCRE_INFO_NAMETABLE, &nametable);
 
       OCTAVE_LOCAL_BUFFER(int, ovector, (subpatterns+1)*3);
       OCTAVE_LOCAL_BUFFER(int, nidx, namecount);
 
       for (int i = 0; i < namecount; i++)
-	{
-	  // Index of subpattern in first two bytes MSB first of name.
-	  // Extract index.
-	  nidx[i] = (static_cast<int>(nametable[i*nameentrysize])) << 8 |
-	    static_cast<int>(nametable[i*nameentrysize+1]);
-	}
+        {
+          // Index of subpattern in first two bytes MSB first of name.
+          // Extract index.
+          nidx[i] = (static_cast<int>(nametable[i*nameentrysize])) << 8 |
+            static_cast<int>(nametable[i*nameentrysize+1]);
+        }
 
       while(true)
-	{
-	  OCTAVE_QUIT;
+        {
+          OCTAVE_QUIT;
 
-	  int matches = pcre_exec(re, 0, buffer.c_str(), 
-				  buffer.length(), idx, 
-				  (idx ? PCRE_NOTBOL : 0),
-				  ovector, (subpatterns+1)*3);
+          int matches = pcre_exec(re, 0, buffer.c_str(), 
+                                  buffer.length(), idx, 
+                                  (idx ? PCRE_NOTBOL : 0),
+                                  ovector, (subpatterns+1)*3);
 
-	  if (matches == PCRE_ERROR_MATCHLIMIT)
-	    {
-	      // try harder; start with default value for MATCH_LIMIT and increase it
-	      warning("Your pattern caused PCRE to hit its MATCH_LIMIT.\nTrying harder now, but this will be slow.");
-	      pcre_extra pe;
-	      pcre_config(PCRE_CONFIG_MATCH_LIMIT, static_cast <void *> (&pe.match_limit));
-	      pe.flags = PCRE_EXTRA_MATCH_LIMIT;
+          if (matches == PCRE_ERROR_MATCHLIMIT)
+            {
+              // try harder; start with default value for MATCH_LIMIT and increase it
+              warning("Your pattern caused PCRE to hit its MATCH_LIMIT.\nTrying harder now, but this will be slow.");
+              pcre_extra pe;
+              pcre_config(PCRE_CONFIG_MATCH_LIMIT, static_cast <void *> (&pe.match_limit));
+              pe.flags = PCRE_EXTRA_MATCH_LIMIT;
 
-	      int i = 0;
-	      while (matches == PCRE_ERROR_MATCHLIMIT &&
-		     i++ < PCRE_MATCHLIMIT_MAX)
-		{
-		  OCTAVE_QUIT;
+              int i = 0;
+              while (matches == PCRE_ERROR_MATCHLIMIT &&
+                     i++ < PCRE_MATCHLIMIT_MAX)
+                {
+                  OCTAVE_QUIT;
 
-		  pe.match_limit *= 10;
-		  matches = pcre_exec(re, &pe, buffer.c_str(), 
-				      buffer.length(), idx, 
-				      (idx ? PCRE_NOTBOL : 0),
-				      ovector, (subpatterns+1)*3);
-		}
-	    }
+                  pe.match_limit *= 10;
+                  matches = pcre_exec(re, &pe, buffer.c_str(), 
+                                      buffer.length(), idx, 
+                                      (idx ? PCRE_NOTBOL : 0),
+                                      ovector, (subpatterns+1)*3);
+                }
+            }
 
-	  if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
-	    {
-	      error ("%s: internal error calling pcre_exec\nError code from pcre_exec is %i", nm.c_str(), matches);
-	      pcre_free(re);
-	      return 0;
-	    }
-	  else if (matches == PCRE_ERROR_NOMATCH)
-	    break;
-	  else if (ovector[1] <= ovector[0])
-	    {
-	      // FIXME: Zero sized match!! Is this the right thing to do?
-	      idx = ovector[0] + 1;
-	      continue;
-	    }
-	  else
-	    {
-	      int pos_match = 0;
-	      Matrix te(matches-1,2);
-	      for (int i = 1; i < matches; i++)
-		{
-		  if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
-		    {
-		      te(pos_match,0) = double (ovector[2*i]+1);
-		      te(pos_match++,1) = double (ovector[2*i+1]);
-		    }
-		}
-	      te.resize(pos_match,2);
-	      s = double (ovector[0]+1);
-	      e = double (ovector[1]);
+          if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
+            {
+              error ("%s: internal error calling pcre_exec\nError code from pcre_exec is %i", nm.c_str(), matches);
+              pcre_free(re);
+              return 0;
+            }
+          else if (matches == PCRE_ERROR_NOMATCH)
+            break;
+          else if (ovector[1] <= ovector[0])
+            {
+              // FIXME: Zero sized match!! Is this the right thing to do?
+              idx = ovector[0] + 1;
+              continue;
+            }
+          else
+            {
+              int pos_match = 0;
+              Matrix te(matches-1,2);
+              for (int i = 1; i < matches; i++)
+                {
+                  if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
+                    {
+                      te(pos_match,0) = double (ovector[2*i]+1);
+                      te(pos_match++,1) = double (ovector[2*i+1]);
+                    }
+                }
+              te.resize(pos_match,2);
+              s = double (ovector[0]+1);
+              e = double (ovector[1]);
 
-	      const char **listptr;
-	      int status = pcre_get_substring_list(buffer.c_str(), ovector, 
-						   matches, &listptr);
+              const char **listptr;
+              int status = pcre_get_substring_list(buffer.c_str(), ovector, 
+                                                   matches, &listptr);
 
-	      if (status == PCRE_ERROR_NOMEMORY) {
-		error("%s: cannot allocate memory in pcre_get_substring_list",
-		      nm.c_str());
-		pcre_free(re);
-		return 0;
-	      }
+              if (status == PCRE_ERROR_NOMEMORY) {
+                error("%s: cannot allocate memory in pcre_get_substring_list",
+                      nm.c_str());
+                pcre_free(re);
+                return 0;
+              }
 
-	      Cell cell_t (dim_vector(1,pos_match));
-	      pos_match = 0;
-	      for (int i = 1; i < matches; i++)
-		if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
-		  cell_t(pos_match++) = std::string(*(listptr+i));
+              Cell cell_t (dim_vector(1,pos_match));
+              pos_match = 0;
+              for (int i = 1; i < matches; i++)
+                if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
+                  cell_t(pos_match++) = std::string(*(listptr+i));
 
-	      m =  std::string(*listptr);
-	      t = cell_t;
+              m =  std::string(*listptr);
+              t = cell_t;
 
-	      string_vector named_tokens(nnames);
-	      if (namecount > 0)
-		for (int i = 1; i < matches; i++)
-		  {
-		    if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)	
-		      {
-			named_tokens(named_idx(i-1)) = 
-			  std::string(*(listptr+nidx[i-1]));
-		      }
-		  }
+              string_vector named_tokens(nnames);
+              if (namecount > 0)
+                for (int i = 1; i < matches; i++)
+                  {
+                    if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)        
+                      {
+                        named_tokens(named_idx(i-1)) = 
+                          std::string(*(listptr+nidx[i-1]));
+                      }
+                  }
 
-	      pcre_free_substring_list(listptr);
+              pcre_free_substring_list(listptr);
 
-	      regexp_elem new_elem (named_tokens, t, m, te, s, e);
-	      lst.push_back (new_elem);
-	      idx = ovector[1];
-	      sz++;
+              regexp_elem new_elem (named_tokens, t, m, te, s, e);
+              lst.push_back (new_elem);
+              idx = ovector[1];
+              sz++;
 
-	      if (once)
-		break;
+              if (once)
+                break;
 
-	    }
-	}
+            }
+        }
 
       pcre_free(re);
 #else
       regex_t compiled;
       int err=regcomp(&compiled, pattern.c_str(), REG_EXTENDED | 
-		      (case_insensitive ? REG_ICASE : 0));
+                      (case_insensitive ? REG_ICASE : 0));
       if (err)
-	{
-	  int len = regerror(err, &compiled, 0, 0);
-	  OCTAVE_LOCAL_BUFFER (char, errmsg, len);
-	  regerror(err, &compiled, errmsg, len);
-	  error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
-		pattern.c_str());
-	  regfree(&compiled);
-	  return 0;
-	}
+        {
+          int len = regerror(err, &compiled, 0, 0);
+          OCTAVE_LOCAL_BUFFER (char, errmsg, len);
+          regerror(err, &compiled, errmsg, len);
+          error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
+                pattern.c_str());
+          regfree(&compiled);
+          return 0;
+        }
 
       int subexpr = 1;
       int idx = 0;
       for (unsigned int i=0; i < pattern.length(); i++)
-	  subexpr += ( pattern[i] == '(' ? 1 : 0 );
+          subexpr += ( pattern[i] == '(' ? 1 : 0 );
       OCTAVE_LOCAL_BUFFER (regmatch_t, match, subexpr );
 
       while(true)
-	{
-	  OCTAVE_QUIT; 
+        {
+          OCTAVE_QUIT; 
 
-	  if (regexec(&compiled, buffer.c_str() + idx, subexpr, 
-		      match, (idx ? REG_NOTBOL : 0)) == 0) 
-	    {
-	      // Count actual matches
-	      int matches = 0;
-	      while (matches < subexpr && match[matches].rm_so >= 0) 
-		matches++;
+          if (regexec(&compiled, buffer.c_str() + idx, subexpr, 
+                      match, (idx ? REG_NOTBOL : 0)) == 0) 
+            {
+              // Count actual matches
+              int matches = 0;
+              while (matches < subexpr && match[matches].rm_so >= 0) 
+                matches++;
 
-	      if (matches == 0 || match[0].rm_eo == 0)
-		break;
+              if (matches == 0 || match[0].rm_eo == 0)
+                break;
 
-	      s = double (match[0].rm_so+1+idx);
-	      e = double (match[0].rm_eo+idx);
-	      Matrix te(matches-1,2);
-	      for (int i = 1; i < matches; i++)
-		{
-		  te(i-1,0) = double (match[i].rm_so+1+idx);
-		  te(i-1,1) = double (match[i].rm_eo+idx);
-		}
+              s = double (match[0].rm_so+1+idx);
+              e = double (match[0].rm_eo+idx);
+              Matrix te(matches-1,2);
+              for (int i = 1; i < matches; i++)
+                {
+                  te(i-1,0) = double (match[i].rm_so+1+idx);
+                  te(i-1,1) = double (match[i].rm_eo+idx);
+                }
 
-	      m =  buffer.substr (match[0].rm_so+idx, 
-					 match[0].rm_eo-match[0].rm_so);
+              m =  buffer.substr (match[0].rm_so+idx, 
+                                         match[0].rm_eo-match[0].rm_so);
 
-	      Cell cell_t (dim_vector(1,matches-1));
-	      for (int i = 1; i < matches; i++)
-		cell_t(i-1) = buffer.substr (match[i].rm_so+idx, 
-					     match[i].rm_eo-match[i].rm_so);
-	      t = cell_t;
+              Cell cell_t (dim_vector(1,matches-1));
+              for (int i = 1; i < matches; i++)
+                cell_t(i-1) = buffer.substr (match[i].rm_so+idx, 
+                                             match[i].rm_eo-match[i].rm_so);
+              t = cell_t;
 
-	      idx += match[0].rm_eo;
+              idx += match[0].rm_eo;
 
-	      string_vector sv;
-	      regexp_elem new_elem (sv, t, m, te, s, e);
-	      lst.push_back (new_elem);
-	      sz++;
+              string_vector sv;
+              regexp_elem new_elem (sv, t, m, te, s, e);
+              lst.push_back (new_elem);
+              sz++;
 
-	      if (once)
-		break;
-	    }
-	  else
-	    break;
-	}
+              if (once)
+                break;
+            }
+          else
+            break;
+        }
       regfree(&compiled);
 #endif
     }
 #else
   error ("%s: not available in this version of Octave", nm.c_str());
 #endif
   return sz;
 }
 
 static octave_value_list
 octregexp (const octave_value_list &args, int nargout, const std::string &nm,
-	   bool case_insensitive)
+           bool case_insensitive)
 {
   octave_value_list retval;
   int nargin = args.length();
   std::list<regexp_elem> lst;
   string_vector named;
   int nopts;
   bool once;
   int sz = octregexp_list (args, nm, case_insensitive, lst, named, nopts, once);
@@ -578,33 +578,33 @@ octregexp (const octave_value_list &args
   if (! error_state)
     {
       // Converted the linked list in the correct form for the return values
 
       octave_idx_type i = 0;
 #ifdef HAVE_PCRE
       Octave_map nmap;
       if (sz == 1)
-	{
-	  for (int j = 0; j < named.length(); j++)
-	    nmap.assign (named(j), lst.begin()->named_token(j));
-	  retval(5) = nmap;
-	}
+        {
+          for (int j = 0; j < named.length(); j++)
+            nmap.assign (named(j), lst.begin()->named_token(j));
+          retval(5) = nmap;
+        }
       else
-	{
-	  for (int j = 0; j < named.length (); j++)
-	    {
-	      i = 0;
-	      Cell tmp(dim_vector (1, sz));
-	      for (const_iterator p = lst.begin(); p != lst.end(); p++)
-		tmp(i++) = p->named_token(j);
-	      nmap.assign (named(j), octave_value (tmp));
-	    }
-	  retval(5) = nmap;
-	}
+        {
+          for (int j = 0; j < named.length (); j++)
+            {
+              i = 0;
+              Cell tmp(dim_vector (1, sz));
+              for (const_iterator p = lst.begin(); p != lst.end(); p++)
+                tmp(i++) = p->named_token(j);
+              nmap.assign (named(j), octave_value (tmp));
+            }
+          retval(5) = nmap;
+        }
 #else
       retval(5) = Octave_map();
 #endif
 
       if (once)
         retval(4) = sz ? lst.front ().t : Cell();
       else
         {
@@ -660,214 +660,214 @@ octregexp (const octave_value_list &args
           else
             retval(0) = Matrix();
         }
       else
         {
       NDArray s (dim_vector(1, sz));
       i = 0;
       for (const_iterator p = lst.begin(); p != lst.end(); p++)
-	s(i++) = p->s;
+        s(i++) = p->s;
       retval(0) = s;
         }
 
       // Alter the order of the output arguments
       if (nopts > 0)
-	{
-	  int n = 0;
-	  octave_value_list new_retval;
-	  new_retval.resize(nargout);
+        {
+          int n = 0;
+          octave_value_list new_retval;
+          new_retval.resize(nargout);
 
-	  OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
-	  for (int j = 0; j < 6; j++)
-	    arg_used[j] = false;
-	  
-	  for (int j = 2; j < nargin; j++)
-	    {
-	      int k = 0;
-	      std::string str = args(j).string_value();
-	      std::transform (str.begin (), str.end (), str.begin (), tolower);
-	      if (str.find("once", 0) == 0
-		  || str.find("stringanchors", 0) == 0
-		  || str.find("lineanchors", 0) == 0
-		  || str.find("matchcase", 0) == 0
-		  || str.find("ignorecase", 0) == 0
-		  || str.find("dotall", 0) == 0
-		  || str.find("dotexceptnewline", 0) == 0
-		  || str.find("literalspacing", 0) == 0
-		  || str.find("freespacing", 0) == 0
-	      )
-		continue;
-	      else if (str.find("start", 0) == 0)
-		k = 0;
-	      else if (str.find("end", 0) == 0)
-		k = 1;
-	      else if (str.find("tokenextents", 0) == 0)
-		k = 2;
-	      else if (str.find("match", 0) == 0)
-		k = 3;
-	      else if (str.find("tokens", 0) == 0)
-		k = 4;
-	      else if (str.find("names", 0) == 0)
-		k = 5;
+          OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
+          for (int j = 0; j < 6; j++)
+            arg_used[j] = false;
+          
+          for (int j = 2; j < nargin; j++)
+            {
+              int k = 0;
+              std::string str = args(j).string_value();
+              std::transform (str.begin (), str.end (), str.begin (), tolower);
+              if (str.find("once", 0) == 0
+                  || str.find("stringanchors", 0) == 0
+                  || str.find("lineanchors", 0) == 0
+                  || str.find("matchcase", 0) == 0
+                  || str.find("ignorecase", 0) == 0
+                  || str.find("dotall", 0) == 0
+                  || str.find("dotexceptnewline", 0) == 0
+                  || str.find("literalspacing", 0) == 0
+                  || str.find("freespacing", 0) == 0
+              )
+                continue;
+              else if (str.find("start", 0) == 0)
+                k = 0;
+              else if (str.find("end", 0) == 0)
+                k = 1;
+              else if (str.find("tokenextents", 0) == 0)
+                k = 2;
+              else if (str.find("match", 0) == 0)
+                k = 3;
+              else if (str.find("tokens", 0) == 0)
+                k = 4;
+              else if (str.find("names", 0) == 0)
+                k = 5;
 
-	      new_retval(n++) = retval(k);
-	      arg_used[k] = true;
+              new_retval(n++) = retval(k);
+              arg_used[k] = true;
 
-	      if (n == nargout)
-		break;
-	    }
+              if (n == nargout)
+                break;
+            }
 
-	  // Fill in the rest of the arguments
-	  if (n < nargout)
-	    {
-	      for (int j = 0; j < 6; j++)
-		{
-		  if (! arg_used[j])
-		    new_retval(n++) = retval(j);
-		}
-	    }
+          // Fill in the rest of the arguments
+          if (n < nargout)
+            {
+              for (int j = 0; j < 6; j++)
+                {
+                  if (! arg_used[j])
+                    new_retval(n++) = retval(j);
+                }
+            }
 
-	  retval = new_retval;
-	}
+          retval = new_retval;
+        }
     }
 
   return retval;
 }
 
 static octave_value_list
 octcellregexp (const octave_value_list &args, int nargout, const std::string &nm,
-	       bool case_insensitive)
+               bool case_insensitive)
 {
   octave_value_list retval;
 
   if (args(0).is_cell())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellstr = args(0).cell_value();
       if (args(1).is_cell())
-	{
-	  Cell cellpat = args(1).cell_value();
+        {
+          Cell cellpat = args(1).cell_value();
 
-	  if (cellpat.numel() == 1)
-	    {
-	      for (int j = 0; j < nargout; j++)
-		newretval[j].resize(cellstr.dims());
+          if (cellpat.numel() == 1)
+            {
+              for (int j = 0; j < nargout; j++)
+                newretval[j].resize(cellstr.dims());
 
-	      new_args(1) = cellpat(0);
+              new_args(1) = cellpat(0);
 
-	      for (octave_idx_type i = 0; i < cellstr.numel (); i++)
-		{
-		  new_args(0) = cellstr(i);
-		  octave_value_list tmp = octregexp (new_args, nargout, nm, 
-						     case_insensitive);
+              for (octave_idx_type i = 0; i < cellstr.numel (); i++)
+                {
+                  new_args(0) = cellstr(i);
+                  octave_value_list tmp = octregexp (new_args, nargout, nm, 
+                                                     case_insensitive);
 
-		  if (error_state)
-		    break;
+                  if (error_state)
+                    break;
 
-		  for (int j = 0; j < nargout; j++)
-		    newretval[j](i) = tmp(j);
-		}
-	    }
-	  else if (cellstr.numel() == 1)
-	    {
-	      for (int j = 0; j < nargout; j++)
-		newretval[j].resize(cellpat.dims());
+                  for (int j = 0; j < nargout; j++)
+                    newretval[j](i) = tmp(j);
+                }
+            }
+          else if (cellstr.numel() == 1)
+            {
+              for (int j = 0; j < nargout; j++)
+                newretval[j].resize(cellpat.dims());
 
-	      new_args(0) = cellstr(0);
+              new_args(0) = cellstr(0);
 
-	      for (octave_idx_type i = 0; i < cellpat.numel (); i++)
-		{
-		  new_args(1) = cellpat(i);
-		  octave_value_list tmp = octregexp (new_args, nargout, nm, 
-						     case_insensitive);
+              for (octave_idx_type i = 0; i < cellpat.numel (); i++)
+                {
+                  new_args(1) = cellpat(i);
+                  octave_value_list tmp = octregexp (new_args, nargout, nm, 
+                                                     case_insensitive);
 
-		  if (error_state)
-		    break;
+                  if (error_state)
+                    break;
 
-		  for (int j = 0; j < nargout; j++)
-		    newretval[j](i) = tmp(j);
-		}
-	    }
-	  else if (cellstr.numel() == cellpat.numel())
-	    {
+                  for (int j = 0; j < nargout; j++)
+                    newretval[j](i) = tmp(j);
+                }
+            }
+          else if (cellstr.numel() == cellpat.numel())
+            {
 
-	      if (cellstr.dims() != cellpat.dims())
-		error ("%s: Inconsistent cell array dimensions", nm.c_str());
-	      else
-		{
-		  for (int j = 0; j < nargout; j++)
-		    newretval[j].resize(cellstr.dims());
+              if (cellstr.dims() != cellpat.dims())
+                error ("%s: Inconsistent cell array dimensions", nm.c_str());
+              else
+                {
+                  for (int j = 0; j < nargout; j++)
+                    newretval[j].resize(cellstr.dims());
 
-		  for (octave_idx_type i = 0; i < cellstr.numel (); i++)
-		    {
-		      new_args(0) = cellstr(i);
-		      new_args(1) = cellpat(i);
+                  for (octave_idx_type i = 0; i < cellstr.numel (); i++)
+                    {
+                      new_args(0) = cellstr(i);
+                      new_args(1) = cellpat(i);
 
-		      octave_value_list tmp = octregexp (new_args, nargout, nm, 
-							 case_insensitive);
+                      octave_value_list tmp = octregexp (new_args, nargout, nm, 
+                                                         case_insensitive);
 
-		      if (error_state)
-			break;
+                      if (error_state)
+                        break;
 
-		      for (int j = 0; j < nargout; j++)
-			newretval[j](i) = tmp(j);
-		    }
-		}
-	    }
-	  else
-	    error ("regexp: cell array arguments must be scalar or equal size");
-	}
+                      for (int j = 0; j < nargout; j++)
+                        newretval[j](i) = tmp(j);
+                    }
+                }
+            }
+          else
+            error ("regexp: cell array arguments must be scalar or equal size");
+        }
       else
-	{
-	  for (int j = 0; j < nargout; j++)
-	    newretval[j].resize(cellstr.dims());
+        {
+          for (int j = 0; j < nargout; j++)
+            newretval[j].resize(cellstr.dims());
 
-	  for (octave_idx_type i = 0; i < cellstr.numel (); i++)
-	    {
-	      new_args(0) = cellstr(i);
-	      octave_value_list tmp = octregexp (new_args, nargout, nm, case_insensitive);
+          for (octave_idx_type i = 0; i < cellstr.numel (); i++)
+            {
+              new_args(0) = cellstr(i);
+              octave_value_list tmp = octregexp (new_args, nargout, nm, case_insensitive);
 
-	      if (error_state)
-		break;
+              if (error_state)
+                break;
 
-	      for (int j = 0; j < nargout; j++)
-		newretval[j](i) = tmp(j);
-	    }
-	}
+              for (int j = 0; j < nargout; j++)
+                newretval[j](i) = tmp(j);
+            }
+        }
 
       if (!error_state)
-	for (int j = 0; j < nargout; j++)
-	  retval(j) = octave_value (newretval[j]);
+        for (int j = 0; j < nargout; j++)
+          retval(j) = octave_value (newretval[j]);
     }
   else if (args(1).is_cell())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellpat = args(1).cell_value();
 
       for (int j = 0; j < nargout; j++)
-	newretval[j].resize(cellpat.dims());
+        newretval[j].resize(cellpat.dims());
 
       for (octave_idx_type i = 0; i < cellpat.numel (); i++)
-	{
-	  new_args(1) = cellpat(i);
-	  octave_value_list tmp = octregexp (new_args, nargout, nm, case_insensitive);
+        {
+          new_args(1) = cellpat(i);
+          octave_value_list tmp = octregexp (new_args, nargout, nm, case_insensitive);
 
-	  if (error_state)
-	    break;
+          if (error_state)
+            break;
 
-	  for (int j = 0; j < nargout; j++)
-	    newretval[j](i) = tmp(j);
-	}
+          for (int j = 0; j < nargout; j++)
+            newretval[j](i) = tmp(j);
+        }
 
       if (!error_state)
-	for (int j = 0; j < nargout; j++)
-	  retval(j) = octave_value (newretval[j]);
+        for (int j = 0; j < nargout; j++)
+          retval(j) = octave_value (newretval[j]);
     }
   else
     retval = octregexp (args, nargout, nm, case_insensitive);
 
   return retval;
 
 }
 
@@ -1365,175 +1365,175 @@ octregexprep (const octave_value_list &a
   octave_value_list regexpargs(nargin-1,octave_value());
   regexpargs(0) = args(0);
   regexpargs(1) = args(1);
   int len=2;
   for (int i = 3; i < nargin; i++) 
     {
       const std::string opt = args(i).string_value();
       if (opt != "tokenize" && opt != "start" && opt != "end"
-	  && opt != "tokenextents" && opt != "match" && opt != "tokens"
-	  && opt != "names"  && opt != "warnings") 
-	{
-	  regexpargs(len++) = args(i);
-	}
+          && opt != "tokenextents" && opt != "match" && opt != "tokens"
+          && opt != "names"  && opt != "warnings") 
+        {
+          regexpargs(len++) = args(i);
+        }
     }
   regexpargs.resize(len);
   
   // Identify replacement tokens; build a vector of group numbers in
   // the replacement string so that we can quickly calculate the size 
   // of the replacement.
   int tokens = 0;
   for (size_t i=1; i < replacement.size(); i++) 
     {
       if (replacement[i-1]=='$' && isdigit(replacement[i])) 
-	{
-	  tokens++, i++;
-	}
+        {
+          tokens++, i++;
+        }
     }
   std::vector<int> token(tokens);
   int kk = 0;
   for (size_t i = 1; i < replacement.size(); i++) 
     {
       if (replacement[i-1]=='$' && isdigit(replacement[i])) 
-	{
-	  token[kk++] = replacement[i]-'0';
-	  i++;
-	}
+        {
+          token[kk++] = replacement[i]-'0';
+          i++;
+        }
     }
 
   // Perform replacement
   std::string rep;
   if (tokens > 0) 
     {
       std::list<regexp_elem> lst;
       string_vector named;
       int nopts;
       bool once;
       int sz = octregexp_list (regexpargs, nm , false, lst, named, nopts, once);
 
       if (error_state)
-	return retval;
+        return retval;
       if (sz == 0)
-	{
-	  retval = args(0);
-	  return retval;
-	}
+        {
+          retval = args(0);
+          return retval;
+        }
 
       // Determine replacement length
       const size_t replen = replacement.size() - 2*tokens;
       int delta = 0;
       const_iterator p = lst.begin();
       for (int i = 0; i < sz; i++) 
-	{
-	  OCTAVE_QUIT;
+        {
+          OCTAVE_QUIT;
 
-	  const Matrix pairs(p->te);
-	  size_t pairlen = 0;
-	  for (int j = 0; j < tokens; j++) 
-	    {
-	      if (token[j] == 0) 
-		pairlen += static_cast<size_t>(p->e - p->s) + 1;
-	      else if (token[j] <= pairs.rows()) 
-		pairlen += static_cast<size_t>(pairs(token[j]-1,1) - 
-					       pairs(token[j]-1,0)) + 1;
-	    }
-	  delta += static_cast<int>(replen + pairlen) - 
-	    static_cast<int>(p->e - p->s + 1);
-	  p++;
-	}
+          const Matrix pairs(p->te);
+          size_t pairlen = 0;
+          for (int j = 0; j < tokens; j++) 
+            {
+              if (token[j] == 0) 
+                pairlen += static_cast<size_t>(p->e - p->s) + 1;
+              else if (token[j] <= pairs.rows()) 
+                pairlen += static_cast<size_t>(pairs(token[j]-1,1) - 
+                                               pairs(token[j]-1,0)) + 1;
+            }
+          delta += static_cast<int>(replen + pairlen) - 
+            static_cast<int>(p->e - p->s + 1);
+          p++;
+        }
       
       // Build replacement string
       rep.reserve(buffer.size()+delta);
       size_t from = 0;
       p = lst.begin();
       for (int i=0; i < sz; i++) 
-	{
-	  OCTAVE_QUIT;
+        {
+          OCTAVE_QUIT;
 
-	  const Matrix pairs(p->te);
-	  rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
-	  from = static_cast<size_t>(p->e - 1) + 1;
-	  for (size_t j = 1; j < replacement.size(); j++) 
-	    {
-	      if (replacement[j-1]=='$' && isdigit(replacement[j])) 
-		{
-		  int k = replacement[j]-'0';
-		  if (k == 0) 
-		    { 
-		      // replace with entire match
-		      rep.append(&buffer[static_cast<size_t>(p->e - 1)],
-				 static_cast<size_t>(p->e - p->s) + 1);
-		    } 
-		  else if (k <= pairs.rows()) 
-		    {
-		      // replace with group capture
-		      rep.append(&buffer[static_cast<size_t>(pairs(k-1,0)-1)],
-				 static_cast<size_t>(pairs(k-1,1) - 
-						     pairs(k-1,0))+1);
-		    }
-		  else 
-		    {
-		      // replace with nothing
-		    }
-		  j++;
-		} 
-	      else 
-		{
-		  rep.append(1,replacement[j-1]);
-		}
-	      if (j+1 == replacement.size()) 
-		{
-		  rep.append(1,replacement[j]);
-		}
-	    }
-	  p++;
-	}
+          const Matrix pairs(p->te);
+          rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
+          from = static_cast<size_t>(p->e - 1) + 1;
+          for (size_t j = 1; j < replacement.size(); j++) 
+            {
+              if (replacement[j-1]=='$' && isdigit(replacement[j])) 
+                {
+                  int k = replacement[j]-'0';
+                  if (k == 0) 
+                    { 
+                      // replace with entire match
+                      rep.append(&buffer[static_cast<size_t>(p->e - 1)],
+                                 static_cast<size_t>(p->e - p->s) + 1);
+                    } 
+                  else if (k <= pairs.rows()) 
+                    {
+                      // replace with group capture
+                      rep.append(&buffer[static_cast<size_t>(pairs(k-1,0)-1)],
+                                 static_cast<size_t>(pairs(k-1,1) - 
+                                                     pairs(k-1,0))+1);
+                    }
+                  else 
+                    {
+                      // replace with nothing
+                    }
+                  j++;
+                } 
+              else 
+                {
+                  rep.append(1,replacement[j-1]);
+                }
+              if (j+1 == replacement.size()) 
+                {
+                  rep.append(1,replacement[j]);
+                }
+            }
+          p++;
+        }
       rep.append(&buffer[from],buffer.size()-from);
     } 
   else 
     {
       std::list<regexp_elem> lst;
       string_vector named;
       int nopts;
       bool once;
       int sz = octregexp_list (regexpargs, nm, false, lst, named, nopts, once);
 
       if (error_state)
-	return retval;
+        return retval;
       if (sz == 0)
-	{
-	  retval = args(0);
-	  return retval;
-	}
+        {
+          retval = args(0);
+          return retval;
+        }
 
       // Determine replacement length
       const size_t replen = replacement.size();
       int delta = 0;
       const_iterator p = lst.begin();
       for (int i = 0; i < sz; i++) 
-	{
+        {
           OCTAVE_QUIT;
-	  delta += static_cast<int>(replen) - 
-	    static_cast<int>(p->e - p->s + 1);
-	  p++;
-	}
+          delta += static_cast<int>(replen) - 
+            static_cast<int>(p->e - p->s + 1);
+          p++;
+        }
 
       // Build replacement string
       rep.reserve(buffer.size()+delta);
       size_t from = 0;
       p = lst.begin();
       for (int i=0; i < sz; i++) 
-	{
+        {
           OCTAVE_QUIT;
-	  rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
-	  from = static_cast<size_t>(p->e - 1) + 1;
-	  rep.append(replacement);
-	  p++;
-	}
+          rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
+          from = static_cast<size_t>(p->e - 1) + 1;
+          rep.append(replacement);
+          p++;
+        }
       rep.append(&buffer[from],buffer.size()-from);
     }
   
   retval = rep;
   return retval;
 }
 
 DEFUN_DLD (regexprep, args, ,
@@ -1595,73 +1595,73 @@ Alternatively, use (?x) or (?-x) in the 
     {
       Cell str;
       Cell pat;
       Cell rep;
       dim_vector dv0;
       dim_vector dv1(1,1);
 
       if (args(0).is_cell())
-	str = args(0).cell_value();
+        str = args(0).cell_value();
       else
-	str = Cell (args(0));
+        str = Cell (args(0));
 
       if (args(1).is_cell())
-	pat = args(1).cell_value();
+        pat = args(1).cell_value();
       else
-	pat = Cell (args(1));
+        pat = Cell (args(1));
 
       if (args(2).is_cell())
-	rep = args(2).cell_value();
+        rep = args(2).cell_value();
       else
-	rep = Cell (args(2));
+        rep = Cell (args(2));
 
       dv0 = str.dims();
       if (pat.numel() != 1)
-	{
-	  dv1 = pat.dims();
-	  if (rep.numel() != 1 && dv1 != rep.dims())
-	    error ("regexprep: Inconsistent cell array dimensions");
-	}
+        {
+          dv1 = pat.dims();
+          if (rep.numel() != 1 && dv1 != rep.dims())
+            error ("regexprep: Inconsistent cell array dimensions");
+        }
       else if (rep.numel() != 1)
-	dv1 = rep.dims();
+        dv1 = rep.dims();
 
       if (!error_state)
-	{
-	  Cell ret (dv0);
-	  octave_value_list new_args = args;
+        {
+          Cell ret (dv0);
+          octave_value_list new_args = args;
 
-	  for (octave_idx_type i = 0; i < dv0.numel(); i++)
-	    {
-	      new_args(0) = str(i);
-	      if (pat.numel() == 1)
-		new_args(1) = pat(0);
-	      if (rep.numel() == 1)
-		new_args(2) = rep(0);
-	      for (octave_idx_type j = 0; j < dv1.numel(); j++)
-		{
-		  if (pat.numel() != 1)
-		    new_args(1) = pat(j);
-		  if (rep.numel() != 1)
-		    new_args(2) = rep(j);
-		  new_args(0) = octregexprep (new_args, "regexprep");
+          for (octave_idx_type i = 0; i < dv0.numel(); i++)
+            {
+              new_args(0) = str(i);
+              if (pat.numel() == 1)
+                new_args(1) = pat(0);
+              if (rep.numel() == 1)
+                new_args(2) = rep(0);
+              for (octave_idx_type j = 0; j < dv1.numel(); j++)
+                {
+                  if (pat.numel() != 1)
+                    new_args(1) = pat(j);
+                  if (rep.numel() != 1)
+                    new_args(2) = rep(j);
+                  new_args(0) = octregexprep (new_args, "regexprep");
 
-		  if (error_state)
-		    break;
-		}
+                  if (error_state)
+                    break;
+                }
 
-	      if (error_state)
-		break;
+              if (error_state)
+                break;
 
-	      ret(i) = new_args(0);
-	    }
+              ret(i) = new_args(0);
+            }
 
-	  if (!error_state)
-	    retval = octave_value (ret);
-	}
+          if (!error_state)
+            retval = octave_value (ret);
+        }
     }
   else
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -218,29 +218,29 @@ leading eigenvalues of\n\
 
   std::string ord;
 
   if (nargin == 2)
     {
       ord = args(1).string_value (); 
 
       if (error_state)
-	{
-	  error ("schur: expecting string as second argument");
-	  return retval;
-	}
+        {
+          error ("schur: expecting string as second argument");
+          return retval;
+        }
     }
 
   char ord_char = ord.empty () ? 'U' : ord[0];
 
   if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
       && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
     {
       warning ("schur: incorrect ordered schur argument `%c'",
-	       ord.c_str ());
+               ord.c_str ());
       return retval;
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("schur", nr, nc);
 
@@ -253,100 +253,100 @@ leading eigenvalues of\n\
     {
       gripe_square_matrix_required ("schur");
       return retval;
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
-	{
-	  FloatMatrix tmp = arg.float_matrix_value ();
+        {
+          FloatMatrix tmp = arg.float_matrix_value ();
 
-	  if (! error_state)
-	    {
-	      if (nargout == 0 || nargout == 1)
-		{
-		  FloatSCHUR result (tmp, ord, false);
-		  retval(0) = result.schur_matrix ();
-		}
-	      else
-		{
-		  FloatSCHUR result (tmp, ord, true);
-		  retval(1) = result.schur_matrix ();
-		  retval(0) = result.unitary_matrix ();
-		}
-	    }
-	}
+          if (! error_state)
+            {
+              if (nargout == 0 || nargout == 1)
+                {
+                  FloatSCHUR result (tmp, ord, false);
+                  retval(0) = result.schur_matrix ();
+                }
+              else
+                {
+                  FloatSCHUR result (tmp, ord, true);
+                  retval(1) = result.schur_matrix ();
+                  retval(0) = result.unitary_matrix ();
+                }
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
+        {
+          FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-	  if (! error_state)
-	    {
+          if (! error_state)
+            {
  
-	      if (nargout == 0 || nargout == 1)
-		{
-		  FloatComplexSCHUR result (ctmp, ord, false);
-		  retval(0) = result.schur_matrix ();
-		}
-	      else
-		{
-		  FloatComplexSCHUR result (ctmp, ord, true);
-		  retval(1) = result.schur_matrix ();
-		  retval(0) = result.unitary_matrix ();
-		}
-	    }
-	}
+              if (nargout == 0 || nargout == 1)
+                {
+                  FloatComplexSCHUR result (ctmp, ord, false);
+                  retval(0) = result.schur_matrix ();
+                }
+              else
+                {
+                  FloatComplexSCHUR result (ctmp, ord, true);
+                  retval(1) = result.schur_matrix ();
+                  retval(0) = result.unitary_matrix ();
+                }
+            }
+        }
     }
   else
     {
       if (arg.is_real_type ())
-	{
-	  Matrix tmp = arg.matrix_value ();
+        {
+          Matrix tmp = arg.matrix_value ();
 
-	  if (! error_state)
-	    {
-	      if (nargout == 0 || nargout == 1)
-		{
-		  SCHUR result (tmp, ord, false);
-		  retval(0) = result.schur_matrix ();
-		}
-	      else
-		{
-		  SCHUR result (tmp, ord, true);
-		  retval(1) = result.schur_matrix ();
-		  retval(0) = result.unitary_matrix ();
-		}
-	    }
-	}
+          if (! error_state)
+            {
+              if (nargout == 0 || nargout == 1)
+                {
+                  SCHUR result (tmp, ord, false);
+                  retval(0) = result.schur_matrix ();
+                }
+              else
+                {
+                  SCHUR result (tmp, ord, true);
+                  retval(1) = result.schur_matrix ();
+                  retval(0) = result.unitary_matrix ();
+                }
+            }
+        }
       else if (arg.is_complex_type ())
-	{
-	  ComplexMatrix ctmp = arg.complex_matrix_value ();
+        {
+          ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-	  if (! error_state)
-	    {
+          if (! error_state)
+            {
  
-	      if (nargout == 0 || nargout == 1)
-		{
-		  ComplexSCHUR result (ctmp, ord, false);
-		  retval(0) = result.schur_matrix ();
-		}
-	      else
-		{
-		  ComplexSCHUR result (ctmp, ord, true);
-		  retval(1) = result.schur_matrix ();
-		  retval(0) = result.unitary_matrix ();
-		}
-	    }
-	}
+              if (nargout == 0 || nargout == 1)
+                {
+                  ComplexSCHUR result (ctmp, ord, false);
+                  retval(0) = result.schur_matrix ();
+                }
+              else
+                {
+                  ComplexSCHUR result (ctmp, ord, true);
+                  retval(1) = result.schur_matrix ();
+                  retval(0) = result.unitary_matrix ();
+                }
+            }
+        }
       else
-	{
-	  gripe_wrong_type_arg ("schur", arg);
-	}
+        {
+          gripe_wrong_type_arg ("schur", arg);
+        }
     }
  
   return retval; 
 }
 
 /*
 
 %!test
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -124,249 +124,249 @@ to have a common size.\n\
        use_bool = args(0).is_bool_type ();
      }
 
    if (nargin == 1)
      {
        octave_value arg = args (0);
 
        if (arg.is_sparse_type ())
-	 {
-	   if (use_complex) 
-	     {
-	       SparseComplexMatrix sm = arg.sparse_complex_matrix_value ();
-	       retval = new octave_sparse_complex_matrix (sm);
-	     }
-	   else if (use_bool) 
-	     {
-	       SparseBoolMatrix sm = arg.sparse_bool_matrix_value ();
-	       retval = new octave_sparse_bool_matrix (sm);
-	     }
-	   else
-	     {
-	       SparseMatrix sm = arg.sparse_matrix_value ();
-	       retval = new octave_sparse_matrix (sm);
-	     }
-	 }
+         {
+           if (use_complex) 
+             {
+               SparseComplexMatrix sm = arg.sparse_complex_matrix_value ();
+               retval = new octave_sparse_complex_matrix (sm);
+             }
+           else if (use_bool) 
+             {
+               SparseBoolMatrix sm = arg.sparse_bool_matrix_value ();
+               retval = new octave_sparse_bool_matrix (sm);
+             }
+           else
+             {
+               SparseMatrix sm = arg.sparse_matrix_value ();
+               retval = new octave_sparse_matrix (sm);
+             }
+         }
        else if (arg.is_diag_matrix ())
          {
            if (arg.is_complex_type ())
              {
-	       SparseComplexMatrix sm = arg.sparse_complex_matrix_value ();
-	       retval = new octave_sparse_complex_matrix (sm);
+               SparseComplexMatrix sm = arg.sparse_complex_matrix_value ();
+               retval = new octave_sparse_complex_matrix (sm);
              }
            else
              {
-	       SparseMatrix sm = arg.sparse_matrix_value ();
-	       retval = new octave_sparse_matrix (sm);
+               SparseMatrix sm = arg.sparse_matrix_value ();
+               retval = new octave_sparse_matrix (sm);
              }
          }
        else if (arg.is_perm_matrix ())
          {
            SparseMatrix sm = arg.sparse_matrix_value ();
            retval = new octave_sparse_matrix (sm);
          }
        else
-	 {
-	   if (use_complex) 
-	     {
-	       SparseComplexMatrix sm (args (0).complex_matrix_value ());
-	       if (error_state) 
-		 return retval;
-	       retval = new octave_sparse_complex_matrix (sm);
-	     } 
-	   else if (use_bool) 
-	     {
-	       SparseBoolMatrix sm (args (0).bool_matrix_value ());
-	       if (error_state) 
-		 return retval;
-	       retval = new octave_sparse_bool_matrix (sm);
-	     } 
-	   else 
-	     {
-	       SparseMatrix sm (args (0).matrix_value ());
-	       if (error_state) 
-		 return retval;
-	       retval = new octave_sparse_matrix (sm);
-	     }
-	 }
+         {
+           if (use_complex) 
+             {
+               SparseComplexMatrix sm (args (0).complex_matrix_value ());
+               if (error_state) 
+                 return retval;
+               retval = new octave_sparse_complex_matrix (sm);
+             } 
+           else if (use_bool) 
+             {
+               SparseBoolMatrix sm (args (0).bool_matrix_value ());
+               if (error_state) 
+                 return retval;
+               retval = new octave_sparse_bool_matrix (sm);
+             } 
+           else 
+             {
+               SparseMatrix sm (args (0).matrix_value ());
+               if (error_state) 
+                 return retval;
+               retval = new octave_sparse_matrix (sm);
+             }
+         }
      }
    else 
      {
        octave_idx_type m = 1, n = 1;
        if (nargin == 2) 
-	 {
-	   if (args(0).numel () == 1 && args(1).numel () == 1)
-	     {
-	       m = args(0).int_value();
-	       n = args(1).int_value();
-	       if (error_state) return retval;
+         {
+           if (args(0).numel () == 1 && args(1).numel () == 1)
+             {
+               m = args(0).int_value();
+               n = args(1).int_value();
+               if (error_state) return retval;
 
-	       if (use_complex) 
-		 retval = new octave_sparse_complex_matrix 
-		   (SparseComplexMatrix (m, n));
-	       else if (use_bool) 
-		 retval = new octave_sparse_bool_matrix 
-		   (SparseBoolMatrix (m, n));
-	       else
-		 retval = new octave_sparse_matrix 
-		   (SparseMatrix (m, n));
-	     }
-	   else
-	     error ("sparse: expecting scalar values");
-	 }
+               if (use_complex) 
+                 retval = new octave_sparse_complex_matrix 
+                   (SparseComplexMatrix (m, n));
+               else if (use_bool) 
+                 retval = new octave_sparse_bool_matrix 
+                   (SparseBoolMatrix (m, n));
+               else
+                 retval = new octave_sparse_matrix 
+                   (SparseMatrix (m, n));
+             }
+           else
+             error ("sparse: expecting scalar values");
+         }
        else 
-	 {
-	   if (args(0).is_empty () || args (1).is_empty () 
-	       || args(2).is_empty ())
-	     {
-	       if (nargin > 4)
-		 {
-		   m = args(3).int_value();
-		   n = args(4).int_value();
-		 }
+         {
+           if (args(0).is_empty () || args (1).is_empty () 
+               || args(2).is_empty ())
+             {
+               if (nargin > 4)
+                 {
+                   m = args(3).int_value();
+                   n = args(4).int_value();
+                 }
 
-	       if (use_bool)
-		 retval = new octave_sparse_bool_matrix 
-		   (SparseBoolMatrix (m, n));
-	       else
-		 retval = new octave_sparse_matrix (SparseMatrix (m, n));
-	     }
-	   else
-	     {
+               if (use_bool)
+                 retval = new octave_sparse_bool_matrix 
+                   (SparseBoolMatrix (m, n));
+               else
+                 retval = new octave_sparse_matrix (SparseMatrix (m, n));
+             }
+           else
+             {
 // 
 //  I use this clumsy construction so that we can use
 //  any orientation of args
-	       ColumnVector ridxA = ColumnVector (args(0).vector_value 
-					      (false, true));
-	       ColumnVector cidxA = ColumnVector (args(1).vector_value 
-						  (false, true));
-	       ColumnVector coefA;
-	       boolNDArray coefAB;
-	       ComplexColumnVector coefAC;
-	       bool assemble_do_sum = true; // this is the default in matlab6
+               ColumnVector ridxA = ColumnVector (args(0).vector_value 
+                                              (false, true));
+               ColumnVector cidxA = ColumnVector (args(1).vector_value 
+                                                  (false, true));
+               ColumnVector coefA;
+               boolNDArray coefAB;
+               ComplexColumnVector coefAC;
+               bool assemble_do_sum = true; // this is the default in matlab6
 
-	       if (use_complex) 
-		 {
-		   if (args(2).is_empty ())
-		     coefAC = ComplexColumnVector (0);
-		   else
-		     coefAC = ComplexColumnVector 
-		       (args(2).complex_vector_value (false, true));
-		 }
-	       else if (use_bool)
-		 {
-		   if (args(2).is_empty ())
-		     coefAB = boolNDArray (dim_vector (1, 0));
-		   else
-		     coefAB = args(2).bool_array_value ();
-		   dim_vector AB_dims = coefAB.dims ();
-		   if (AB_dims.length() > 2 || (AB_dims(0) != 1 && 
-						AB_dims(1) != 1))
-		     error ("sparse: vector arguments required");
-		 }
-	       else 
-		 if (args(2).is_empty ())
-		   coefA = ColumnVector (0);
-		 else
-		   coefA = ColumnVector (args(2).vector_value (false, true));
+               if (use_complex) 
+                 {
+                   if (args(2).is_empty ())
+                     coefAC = ComplexColumnVector (0);
+                   else
+                     coefAC = ComplexColumnVector 
+                       (args(2).complex_vector_value (false, true));
+                 }
+               else if (use_bool)
+                 {
+                   if (args(2).is_empty ())
+                     coefAB = boolNDArray (dim_vector (1, 0));
+                   else
+                     coefAB = args(2).bool_array_value ();
+                   dim_vector AB_dims = coefAB.dims ();
+                   if (AB_dims.length() > 2 || (AB_dims(0) != 1 && 
+                                                AB_dims(1) != 1))
+                     error ("sparse: vector arguments required");
+                 }
+               else 
+                 if (args(2).is_empty ())
+                   coefA = ColumnVector (0);
+                 else
+                   coefA = ColumnVector (args(2).vector_value (false, true));
 
-	       if (error_state)
-		 return retval;
+               if (error_state)
+                 return retval;
 
-	       // Confirm that i,j,s all have the same number of elements
-	       octave_idx_type ns;
-	       if (use_complex) 
-		 ns = coefAC.length();
-	       else if (use_bool) 
-		 ns = coefAB.length();
-	       else 
-		 ns = coefA.length();
+               // Confirm that i,j,s all have the same number of elements
+               octave_idx_type ns;
+               if (use_complex) 
+                 ns = coefAC.length();
+               else if (use_bool) 
+                 ns = coefAB.length();
+               else 
+                 ns = coefA.length();
 
-	       octave_idx_type ni = ridxA.length();
-	       octave_idx_type nj = cidxA.length();
-	       octave_idx_type nnz = (ni > nj ? ni : nj);
-	       if ((ns != 1 && ns != nnz) ||
-		   (ni != 1 && ni != nnz) ||
-		   (nj != 1 && nj != nnz)) 
-		 {
-		   error ("sparse i, j and s must have the same length");
-		   return retval;
-		 }
+               octave_idx_type ni = ridxA.length();
+               octave_idx_type nj = cidxA.length();
+               octave_idx_type nnz = (ni > nj ? ni : nj);
+               if ((ns != 1 && ns != nnz) ||
+                   (ni != 1 && ni != nnz) ||
+                   (nj != 1 && nj != nnz)) 
+                 {
+                   error ("sparse i, j and s must have the same length");
+                   return retval;
+                 }
 
-	       if (nargin == 3 || nargin == 4) 
-		 {
-		   m = static_cast<octave_idx_type> (ridxA.max());
-		   n = static_cast<octave_idx_type> (cidxA.max());
+               if (nargin == 3 || nargin == 4) 
+                 {
+                   m = static_cast<octave_idx_type> (ridxA.max());
+                   n = static_cast<octave_idx_type> (cidxA.max());
 
-		   // if args(3) is not string, then ignore the value
-		   // otherwise check for summation or unique
-		   if (nargin == 4 && args(3).is_string())
-		     {
-		       std::string vv= args(3).string_value();
-		       if (error_state) return retval;
-		       
-		       if ( vv == "summation" ||
-			    vv == "sum" ) 
-			 assemble_do_sum = true;
-		       else
-			 if ( vv == "unique" )
-			   assemble_do_sum = false;
-			 else {
-			   error("sparse repeat flag must be 'sum' or 'unique'");
-			   return retval;
-			 }
-		     }
-		 } 
-	       else 
-		 {
-		   m = args(3).int_value();
-		   n = args(4).int_value();
-		   if (error_state) 
-		     return retval;
+                   // if args(3) is not string, then ignore the value
+                   // otherwise check for summation or unique
+                   if (nargin == 4 && args(3).is_string())
+                     {
+                       std::string vv= args(3).string_value();
+                       if (error_state) return retval;
+                       
+                       if ( vv == "summation" ||
+                            vv == "sum" ) 
+                         assemble_do_sum = true;
+                       else
+                         if ( vv == "unique" )
+                           assemble_do_sum = false;
+                         else {
+                           error("sparse repeat flag must be 'sum' or 'unique'");
+                           return retval;
+                         }
+                     }
+                 } 
+               else 
+                 {
+                   m = args(3).int_value();
+                   n = args(4).int_value();
+                   if (error_state) 
+                     return retval;
 
-		   // if args(5) is not string, then ignore the value
-		   // otherwise check for summation or unique
-		   if (nargin >= 6 && args(5).is_string())
-		     {
-		       std::string vv= args(5).string_value();
-		       if (error_state) return retval;
-		       
-		       if ( vv == "summation" ||
-			    vv == "sum" ) 
-			 assemble_do_sum = true;
-		       else
-			 if ( vv == "unique" )
-			   assemble_do_sum = false;
-			 else {
-			   error("sparse repeat flag must be 'sum' or 'unique'");
-			   return retval;
-			 }
-		     }
-		   
-		 }
+                   // if args(5) is not string, then ignore the value
+                   // otherwise check for summation or unique
+                   if (nargin >= 6 && args(5).is_string())
+                     {
+                       std::string vv= args(5).string_value();
+                       if (error_state) return retval;
+                       
+                       if ( vv == "summation" ||
+                            vv == "sum" ) 
+                         assemble_do_sum = true;
+                       else
+                         if ( vv == "unique" )
+                           assemble_do_sum = false;
+                         else {
+                           error("sparse repeat flag must be 'sum' or 'unique'");
+                           return retval;
+                         }
+                     }
+                   
+                 }
 
-	       // Convert indexing to zero-indexing used internally
-	       ridxA -= 1.;
-	       cidxA -= 1.;
+               // Convert indexing to zero-indexing used internally
+               ridxA -= 1.;
+               cidxA -= 1.;
 
-	       if (use_complex) 
-		 retval = new octave_sparse_complex_matrix 
-		   (SparseComplexMatrix (coefAC, ridxA, cidxA, m, n, 
-					 assemble_do_sum));
-	       else if (use_bool) 
-		 retval = new octave_sparse_bool_matrix 
-		   (SparseBoolMatrix (coefAB, ridxA, cidxA, m, n, 
-				      assemble_do_sum));
-	       else
-		 retval = new octave_sparse_matrix 
-		   (SparseMatrix (coefA, ridxA, cidxA, m, n, 
-				  assemble_do_sum));
-	     }
-	 }
+               if (use_complex) 
+                 retval = new octave_sparse_complex_matrix 
+                   (SparseComplexMatrix (coefAC, ridxA, cidxA, m, n, 
+                                         assemble_do_sum));
+               else if (use_bool) 
+                 retval = new octave_sparse_bool_matrix 
+                   (SparseBoolMatrix (coefAB, ridxA, cidxA, m, n, 
+                                      assemble_do_sum));
+               else
+                 retval = new octave_sparse_matrix 
+                   (SparseMatrix (coefA, ridxA, cidxA, m, n, 
+                                  assemble_do_sum));
+             }
+         }
      }
 
    return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -90,78 +90,78 @@ time.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       if (nargout == 0)
-	octave_sparse_params::print_info (octave_stdout, "");
+        octave_sparse_params::print_info (octave_stdout, "");
       else if (nargout == 1)
-	retval(0) =  octave_sparse_params::get_vals ();
+        retval(0) =  octave_sparse_params::get_vals ();
       else if (nargout == 2)
-	{
-	  retval (0) = octave_sparse_params::get_keys ();
-	  retval (1) = octave_sparse_params::get_vals ();
-	}
+        {
+          retval (0) = octave_sparse_params::get_keys ();
+          retval (1) = octave_sparse_params::get_vals ();
+        }
       else
-	error ("spparms: too many output arguments"); 
+        error ("spparms: too many output arguments"); 
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
-	{
-	  std::string str = args(0).string_value ();
-	  int len = str.length ();
-	  for (int i = 0; i < len; i++)
-	    str [i] = tolower (str [i]);
+        {
+          std::string str = args(0).string_value ();
+          int len = str.length ();
+          for (int i = 0; i < len; i++)
+            str [i] = tolower (str [i]);
 
-	  if (str == "defaults")
-	    octave_sparse_params::defaults ();
-	  else if (str == "tight")
-	    octave_sparse_params::tight ();
-	  else
-	    {
-	      double val = octave_sparse_params::get_key (str);
-	      if (xisnan (val))
-		error ("spparams: unrecognized key");
-	      else
-		retval (0) = val;
-	    }
-	}
+          if (str == "defaults")
+            octave_sparse_params::defaults ();
+          else if (str == "tight")
+            octave_sparse_params::tight ();
+          else
+            {
+              double val = octave_sparse_params::get_key (str);
+              if (xisnan (val))
+                error ("spparams: unrecognized key");
+              else
+                retval (0) = val;
+            }
+        }
       else
-	{
-	  NDArray vals = args(0).array_value ();
+        {
+          NDArray vals = args(0).array_value ();
 
-	  if (error_state)
-	    error ("spparms: input must be a string or a vector");
-	  else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
-	    error ("spparams: too many elements in values vector");
-	  else
-	    octave_sparse_params::set_vals (vals);
-	}
+          if (error_state)
+            error ("spparms: input must be a string or a vector");
+          else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
+            error ("spparams: too many elements in values vector");
+          else
+            octave_sparse_params::set_vals (vals);
+        }
     }
   else if (nargin == 2)
     {
       if (args(0).is_string ())
-	{
-	  std::string str = args(0).string_value ();
-	  
-	  double val = args(1).double_value ();
+        {
+          std::string str = args(0).string_value ();
+          
+          double val = args(1).double_value ();
 
-	  if (error_state)
-	    error ("spparms: second argument must be a real scalar");
+          if (error_state)
+            error ("spparms: second argument must be a real scalar");
           else if (str == "umfpack")
-	    warning ("spparms: request to disable umfpack solvers ignored");
-	  else if (!octave_sparse_params::set_key (str, val))
-	    error ("spparms: key not found");
-	}
+            warning ("spparms: request to disable umfpack solvers ignored");
+          else if (!octave_sparse_params::set_key (str, val))
+            error ("spparms: key not found");
+        }
       else
-	error ("spparms: first argument must be a string");
+        error ("spparms: first argument must be a string");
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -106,33 +106,33 @@ sqrtm_from_schur (const ComplexMatrix& U
   for (octave_idx_type j = 0; j < n; j++)
     R(j,j) = sqrt (T(j,j));
 
   const double fudge = sqrt (DBL_MIN);
 
   for (octave_idx_type p = 0; p < n-1; p++)
     {
       for (octave_idx_type i = 0; i < n-(p+1); i++)
-	{
-	  const octave_idx_type j = i + p + 1;
+        {
+          const octave_idx_type j = i + p + 1;
 
-	  Complex s = T(i,j);
+          Complex s = T(i,j);
 
-	  for (octave_idx_type k = i+1; k < j; k++)
-	    s -= R(i,k) * R(k,j);
+          for (octave_idx_type k = i+1; k < j; k++)
+            s -= R(i,k) * R(k,j);
 
-	  // dividing
-	  //     R(i,j) = s/(R(i,i)+R(j,j));
-	  // screwing around to not / 0
+          // dividing
+          //     R(i,j) = s/(R(i,i)+R(j,j));
+          // screwing around to not / 0
 
-	  const Complex d = R(i,i) + R(j,j) + fudge;
-	  const Complex conjd = conj (d);
+          const Complex d = R(i,i) + R(j,j) + fudge;
+          const Complex conjd = conj (d);
 
-	  R(i,j) =  (s*conjd)/(d*conjd);
-	}
+          R(i,j) =  (s*conjd)/(d*conjd);
+        }
     }
 
   return U * R * U.hermitian ();
 }
 
 static FloatComplexMatrix
 sqrtm_from_schur (const FloatComplexMatrix& U, const FloatComplexMatrix& T)
 {
@@ -143,33 +143,33 @@ sqrtm_from_schur (const FloatComplexMatr
   for (octave_idx_type j = 0; j < n; j++)
     R(j,j) = sqrt (T(j,j));
 
   const float fudge = sqrt (FLT_MIN);
 
   for (octave_idx_type p = 0; p < n-1; p++)
     {
       for (octave_idx_type i = 0; i < n-(p+1); i++)
-	{
-	  const octave_idx_type j = i + p + 1;
+        {
+          const octave_idx_type j = i + p + 1;
 
-	  FloatComplex s = T(i,j);
+          FloatComplex s = T(i,j);
 
-	  for (octave_idx_type k = i+1; k < j; k++)
-	    s -= R(i,k) * R(k,j);
+          for (octave_idx_type k = i+1; k < j; k++)
+            s -= R(i,k) * R(k,j);
 
-	  // dividing
-	  //     R(i,j) = s/(R(i,i)+R(j,j));
-	  // screwing around to not / 0
+          // dividing
+          //     R(i,j) = s/(R(i,i)+R(j,j));
+          // screwing around to not / 0
 
-	  const FloatComplex d = R(i,i) + R(j,j) + fudge;
-	  const FloatComplex conjd = conj (d);
+          const FloatComplex d = R(i,i) + R(j,j) + fudge;
+          const FloatComplex conjd = conj (d);
 
-	  R(i,j) =  (s*conjd)/(d*conjd);
-	}
+          R(i,j) =  (s*conjd)/(d*conjd);
+        }
     }
 
   return U * R * U.hermitian ();
 }
 
 DEFUN_DLD (sqrtm, args, nargout,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{result}, @var{error_estimate}] =} sqrtm (@var{a})\n\
@@ -211,254 +211,254 @@ Manchester, England, January 1999.\n\
 
   retval(1) = lo_ieee_inf_value ();
   retval(0) = lo_ieee_nan_value ();
 
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_scalar ())
-	{
-	  float d = arg.float_value ();
-	  if (d > 0.0)
-	    {
-	      retval(0) = sqrt (d);
-	      retval(1) = 0.0;
-	    }
-	  else
-	    {
-	      retval(0) = FloatComplex (0.0, sqrt (d));
-	      retval(1) = 0.0;
-	    }
-	}
+        {
+          float d = arg.float_value ();
+          if (d > 0.0)
+            {
+              retval(0) = sqrt (d);
+              retval(1) = 0.0;
+            }
+          else
+            {
+              retval(0) = FloatComplex (0.0, sqrt (d));
+              retval(1) = 0.0;
+            }
+        }
       else if (arg.is_complex_scalar ())
-	{
-	  FloatComplex c = arg.float_complex_value ();
-	  retval(0) = sqrt (c);
-	  retval(1) = 0.0;
-	}
+        {
+          FloatComplex c = arg.float_complex_value ();
+          retval(0) = sqrt (c);
+          retval(1) = 0.0;
+        }
       else if (arg.is_matrix_type ())
-	{
-	  float err, minT;
+        {
+          float err, minT;
 
-	  if (arg.is_real_matrix ())
-	    {
-	      FloatMatrix A = arg.float_matrix_value();
+          if (arg.is_real_matrix ())
+            {
+              FloatMatrix A = arg.float_matrix_value();
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      // FIXME -- eventually, FloatComplexSCHUR will accept a
-	      // real matrix arg.
+              // FIXME -- eventually, FloatComplexSCHUR will accept a
+              // real matrix arg.
 
-	      FloatComplexMatrix Ac (A);
+              FloatComplexMatrix Ac (A);
 
-	      const FloatComplexSCHUR schur (Ac, std::string ());
+              const FloatComplexSCHUR schur (Ac, std::string ());
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      const FloatComplexMatrix U (schur.unitary_matrix ());
-	      const FloatComplexMatrix T (schur.schur_matrix ());
-	      const FloatComplexMatrix X (sqrtm_from_schur (U, T));
+              const FloatComplexMatrix U (schur.unitary_matrix ());
+              const FloatComplexMatrix T (schur.schur_matrix ());
+              const FloatComplexMatrix X (sqrtm_from_schur (U, T));
 
-	      // Check for minimal imaginary part
-	      float normX = 0.0;
-	      float imagX = 0.0;
-	      for (octave_idx_type i = 0; i < n; i++)
-		for (octave_idx_type j = 0; j < n; j++)
-		  {
-		    imagX = getmax (imagX, imag (X(i,j)));
-		    normX = getmax (normX, abs (X(i,j)));
-		  }
+              // Check for minimal imaginary part
+              float normX = 0.0;
+              float imagX = 0.0;
+              for (octave_idx_type i = 0; i < n; i++)
+                for (octave_idx_type j = 0; j < n; j++)
+                  {
+                    imagX = getmax (imagX, imag (X(i,j)));
+                    normX = getmax (normX, abs (X(i,j)));
+                  }
 
-	      if (imagX < normX * 100 * FLT_EPSILON)
-		retval(0) = real (X);
-	      else
-		retval(0) = X;
+              if (imagX < normX * 100 * FLT_EPSILON)
+                retval(0) = real (X);
+              else
+                retval(0) = X;
 
-	      // Compute error
-	      // FIXME can we estimate the error without doing the
-	      // matrix multiply?
+              // Compute error
+              // FIXME can we estimate the error without doing the
+              // matrix multiply?
 
-	      err = frobnorm (X*X - FloatComplexMatrix (A)) / frobnorm (A);
+              err = frobnorm (X*X - FloatComplexMatrix (A)) / frobnorm (A);
 
-	      if (xisnan (err))
-		err = lo_ieee_float_inf_value ();
+              if (xisnan (err))
+                err = lo_ieee_float_inf_value ();
 
-	      // Find min diagonal
-	      minT = lo_ieee_float_inf_value ();
-	      for (octave_idx_type i=0; i < n; i++)
-		minT = getmin(minT, abs(T(i,i)));
-	    }
-	  else
-	    {
-	      FloatComplexMatrix A = arg.float_complex_matrix_value ();
+              // Find min diagonal
+              minT = lo_ieee_float_inf_value ();
+              for (octave_idx_type i=0; i < n; i++)
+                minT = getmin(minT, abs(T(i,i)));
+            }
+          else
+            {
+              FloatComplexMatrix A = arg.float_complex_matrix_value ();
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      const FloatComplexSCHUR schur (A, std::string ());
+              const FloatComplexSCHUR schur (A, std::string ());
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      const FloatComplexMatrix U (schur.unitary_matrix ());
-	      const FloatComplexMatrix T (schur.schur_matrix ());
-	      const FloatComplexMatrix X (sqrtm_from_schur (U, T));
+              const FloatComplexMatrix U (schur.unitary_matrix ());
+              const FloatComplexMatrix T (schur.schur_matrix ());
+              const FloatComplexMatrix X (sqrtm_from_schur (U, T));
 
-	      retval(0) = X;
+              retval(0) = X;
 
-	      err = frobnorm (X*X - A) / frobnorm (A);
+              err = frobnorm (X*X - A) / frobnorm (A);
 
-	      if (xisnan (err))
-		err = lo_ieee_float_inf_value ();
+              if (xisnan (err))
+                err = lo_ieee_float_inf_value ();
 
-	      minT = lo_ieee_float_inf_value ();
-	      for (octave_idx_type i = 0; i < n; i++)
-		minT = getmin (minT, abs (T(i,i)));
-	    }
+              minT = lo_ieee_float_inf_value ();
+              for (octave_idx_type i = 0; i < n; i++)
+                minT = getmin (minT, abs (T(i,i)));
+            }
 
-	  retval(1) = err;
+          retval(1) = err;
 
-	  if (nargout < 2)
-	    {
-	      if (err > 100*(minT+FLT_EPSILON)*n)
-		{
-		  if (minT == 0.0)
-		    error ("sqrtm: A is singular, sqrt may not exist");
-		  else if (minT <= sqrt (FLT_MIN))
-		    error ("sqrtm: A is nearly singular, failed to find sqrt");
-		  else
-		    error ("sqrtm: failed to find sqrt");
-		}
-	    }
-	}
+          if (nargout < 2)
+            {
+              if (err > 100*(minT+FLT_EPSILON)*n)
+                {
+                  if (minT == 0.0)
+                    error ("sqrtm: A is singular, sqrt may not exist");
+                  else if (minT <= sqrt (FLT_MIN))
+                    error ("sqrtm: A is nearly singular, failed to find sqrt");
+                  else
+                    error ("sqrtm: failed to find sqrt");
+                }
+            }
+        }
     }
   else
     {
       if (arg.is_real_scalar ())
-	{
-	  double d = arg.double_value ();
-	  if (d > 0.0)
-	    {
-	      retval(0) = sqrt (d);
-	      retval(1) = 0.0;
-	    }
-	  else
-	    {
-	      retval(0) = Complex (0.0, sqrt (d));
-	      retval(1) = 0.0;
-	    }
-	}
+        {
+          double d = arg.double_value ();
+          if (d > 0.0)
+            {
+              retval(0) = sqrt (d);
+              retval(1) = 0.0;
+            }
+          else
+            {
+              retval(0) = Complex (0.0, sqrt (d));
+              retval(1) = 0.0;
+            }
+        }
       else if (arg.is_complex_scalar ())
-	{
-	  Complex c = arg.complex_value ();
-	  retval(0) = sqrt (c);
-	  retval(1) = 0.0;
-	}
+        {
+          Complex c = arg.complex_value ();
+          retval(0) = sqrt (c);
+          retval(1) = 0.0;
+        }
       else if (arg.is_matrix_type ())
-	{
-	  double err, minT;
+        {
+          double err, minT;
 
-	  if (arg.is_real_matrix ())
-	    {
-	      Matrix A = arg.matrix_value();
+          if (arg.is_real_matrix ())
+            {
+              Matrix A = arg.matrix_value();
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      // FIXME -- eventually, ComplexSCHUR will accept a
-	      // real matrix arg.
+              // FIXME -- eventually, ComplexSCHUR will accept a
+              // real matrix arg.
 
-	      ComplexMatrix Ac (A);
+              ComplexMatrix Ac (A);
 
-	      const ComplexSCHUR schur (Ac, std::string ());
+              const ComplexSCHUR schur (Ac, std::string ());
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      const ComplexMatrix U (schur.unitary_matrix ());
-	      const ComplexMatrix T (schur.schur_matrix ());
-	      const ComplexMatrix X (sqrtm_from_schur (U, T));
+              const ComplexMatrix U (schur.unitary_matrix ());
+              const ComplexMatrix T (schur.schur_matrix ());
+              const ComplexMatrix X (sqrtm_from_schur (U, T));
 
-	      // Check for minimal imaginary part
-	      double normX = 0.0;
-	      double imagX = 0.0;
-	      for (octave_idx_type i = 0; i < n; i++)
-		for (octave_idx_type j = 0; j < n; j++)
-		  {
-		    imagX = getmax (imagX, imag (X(i,j)));
-		    normX = getmax (normX, abs (X(i,j)));
-		  }
+              // Check for minimal imaginary part
+              double normX = 0.0;
+              double imagX = 0.0;
+              for (octave_idx_type i = 0; i < n; i++)
+                for (octave_idx_type j = 0; j < n; j++)
+                  {
+                    imagX = getmax (imagX, imag (X(i,j)));
+                    normX = getmax (normX, abs (X(i,j)));
+                  }
 
-	      if (imagX < normX * 100 * DBL_EPSILON)
-		retval(0) = real (X);
-	      else
-		retval(0) = X;
+              if (imagX < normX * 100 * DBL_EPSILON)
+                retval(0) = real (X);
+              else
+                retval(0) = X;
 
-	      // Compute error
-	      // FIXME can we estimate the error without doing the
-	      // matrix multiply?
+              // Compute error
+              // FIXME can we estimate the error without doing the
+              // matrix multiply?
 
-	      err = frobnorm (X*X - ComplexMatrix (A)) / frobnorm (A);
+              err = frobnorm (X*X - ComplexMatrix (A)) / frobnorm (A);
 
-	      if (xisnan (err))
-		err = lo_ieee_inf_value ();
+              if (xisnan (err))
+                err = lo_ieee_inf_value ();
 
-	      // Find min diagonal
-	      minT = lo_ieee_inf_value ();
-	      for (octave_idx_type i=0; i < n; i++)
-		minT = getmin(minT, abs(T(i,i)));
-	    }
-	  else
-	    {
-	      ComplexMatrix A = arg.complex_matrix_value ();
+              // Find min diagonal
+              minT = lo_ieee_inf_value ();
+              for (octave_idx_type i=0; i < n; i++)
+                minT = getmin(minT, abs(T(i,i)));
+            }
+          else
+            {
+              ComplexMatrix A = arg.complex_matrix_value ();
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      const ComplexSCHUR schur (A, std::string ());
+              const ComplexSCHUR schur (A, std::string ());
 
-	      if (error_state)
-		return retval;
+              if (error_state)
+                return retval;
 
-	      const ComplexMatrix U (schur.unitary_matrix ());
-	      const ComplexMatrix T (schur.schur_matrix ());
-	      const ComplexMatrix X (sqrtm_from_schur (U, T));
+              const ComplexMatrix U (schur.unitary_matrix ());
+              const ComplexMatrix T (schur.schur_matrix ());
+              const ComplexMatrix X (sqrtm_from_schur (U, T));
 
-	      retval(0) = X;
+              retval(0) = X;
 
-	      err = frobnorm (X*X - A) / frobnorm (A);
+              err = frobnorm (X*X - A) / frobnorm (A);
 
-	      if (xisnan (err))
-		err = lo_ieee_inf_value ();
+              if (xisnan (err))
+                err = lo_ieee_inf_value ();
 
-	      minT = lo_ieee_inf_value ();
-	      for (octave_idx_type i = 0; i < n; i++)
-		minT = getmin (minT, abs (T(i,i)));
-	    }
+              minT = lo_ieee_inf_value ();
+              for (octave_idx_type i = 0; i < n; i++)
+                minT = getmin (minT, abs (T(i,i)));
+            }
 
-	  retval(1) = err;
+          retval(1) = err;
 
-	  if (nargout < 2)
-	    {
-	      if (err > 100*(minT+DBL_EPSILON)*n)
-		{
-		  if (minT == 0.0)
-		    error ("sqrtm: A is singular, sqrt may not exist");
-		  else if (minT <= sqrt (DBL_MIN))
-		    error ("sqrtm: A is nearly singular, failed to find sqrt");
-		  else
-		    error ("sqrtm: failed to find sqrt");
-		}
-	    }
-	}
+          if (nargout < 2)
+            {
+              if (err > 100*(minT+DBL_EPSILON)*n)
+                {
+                  if (minT == 0.0)
+                    error ("sqrtm: A is singular, sqrt may not exist");
+                  else if (minT <= sqrt (DBL_MIN))
+                    error ("sqrtm: A is nearly singular, failed to find sqrt");
+                  else
+                    error ("sqrtm: failed to find sqrt");
+                }
+            }
+        }
       else
-	gripe_wrong_type_arg ("sqrtm", arg);
+        gripe_wrong_type_arg ("sqrtm", arg);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -134,167 +134,167 @@ decomposition, eliminating the unnecessa
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   bool isfloat = arg.is_single_type ();
 
   if (nr == 0 || nc == 0)
     {
       if (isfloat)
-	{
-	  if (nargout == 3)
-	    {
-	      retval(3) = float_identity_matrix (nr, nr);
-	      retval(2) = FloatMatrix (nr, nc);
-	      retval(1) = float_identity_matrix (nc, nc);
-	    }
-	  else
-	    retval(0) = FloatMatrix (0, 1);
-	}
+        {
+          if (nargout == 3)
+            {
+              retval(3) = float_identity_matrix (nr, nr);
+              retval(2) = FloatMatrix (nr, nc);
+              retval(1) = float_identity_matrix (nc, nc);
+            }
+          else
+            retval(0) = FloatMatrix (0, 1);
+        }
       else
-	{
-	  if (nargout == 3)
-	    {
-	      retval(3) = identity_matrix (nr, nr);
-	      retval(2) = Matrix (nr, nc);
-	      retval(1) = identity_matrix (nc, nc);
-	    }
-	  else
-	    retval(0) = Matrix (0, 1);
-	}
+        {
+          if (nargout == 3)
+            {
+              retval(3) = identity_matrix (nr, nr);
+              retval(2) = Matrix (nr, nc);
+              retval(1) = identity_matrix (nc, nc);
+            }
+          else
+            retval(0) = Matrix (0, 1);
+        }
     }
   else
     {
       SVD::type type = ((nargout == 0 || nargout == 1)
-			? SVD::sigma_only
-			: (nargin == 2) ? SVD::economy : SVD::std);
+                        ? SVD::sigma_only
+                        : (nargin == 2) ? SVD::economy : SVD::std);
 
       if (isfloat)
-	{
-	  if (arg.is_real_type ())
-	    {
-	      FloatMatrix tmp = arg.float_matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              FloatMatrix tmp = arg.float_matrix_value ();
 
-	      if (! error_state)
-		{
-		  if (tmp.any_element_is_inf_or_nan ())
-		    {
-		      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
-		      return retval;
-		    }
+              if (! error_state)
+                {
+                  if (tmp.any_element_is_inf_or_nan ())
+                    {
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      return retval;
+                    }
 
-		  FloatSVD result (tmp, type);
+                  FloatSVD result (tmp, type);
 
-		  FloatDiagMatrix sigma = result.singular_values ();
+                  FloatDiagMatrix sigma = result.singular_values ();
 
-		  if (nargout == 0 || nargout == 1)
-		    {
-		      retval(0) = sigma.diag ();
-		    }
-		  else
-		    {
-		      retval(2) = result.right_singular_matrix ();
-		      retval(1) = sigma;
-		      retval(0) = result.left_singular_matrix ();
-		    }
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
+                  if (nargout == 0 || nargout == 1)
+                    {
+                      retval(0) = sigma.diag ();
+                    }
+                  else
+                    {
+                      retval(2) = result.right_singular_matrix ();
+                      retval(1) = sigma;
+                      retval(0) = result.left_singular_matrix ();
+                    }
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  if (ctmp.any_element_is_inf_or_nan ())
-		    {
-		      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
-		      return retval;
-		    }
+              if (! error_state)
+                {
+                  if (ctmp.any_element_is_inf_or_nan ())
+                    {
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      return retval;
+                    }
 
-		  FloatComplexSVD result (ctmp, type);
+                  FloatComplexSVD result (ctmp, type);
 
-		  FloatDiagMatrix sigma = result.singular_values ();
+                  FloatDiagMatrix sigma = result.singular_values ();
 
-		  if (nargout == 0 || nargout == 1)
-		    {
-		      retval(0) = sigma.diag ();
-		    }
-		  else
-		    {
-		      retval(2) = result.right_singular_matrix ();
-		      retval(1) = sigma;
-		      retval(0) = result.left_singular_matrix ();
-		    }
-		}
-	    }
-	}
+                  if (nargout == 0 || nargout == 1)
+                    {
+                      retval(0) = sigma.diag ();
+                    }
+                  else
+                    {
+                      retval(2) = result.right_singular_matrix ();
+                      retval(1) = sigma;
+                      retval(0) = result.left_singular_matrix ();
+                    }
+                }
+            }
+        }
       else
-	{
-	  if (arg.is_real_type ())
-	    {
-	      Matrix tmp = arg.matrix_value ();
+        {
+          if (arg.is_real_type ())
+            {
+              Matrix tmp = arg.matrix_value ();
 
-	      if (! error_state)
-		{
-		  if (tmp.any_element_is_inf_or_nan ())
-		    {
-		      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
-		      return retval;
-		    }
+              if (! error_state)
+                {
+                  if (tmp.any_element_is_inf_or_nan ())
+                    {
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      return retval;
+                    }
 
-		  SVD result (tmp, type);
+                  SVD result (tmp, type);
 
-		  DiagMatrix sigma = result.singular_values ();
+                  DiagMatrix sigma = result.singular_values ();
 
-		  if (nargout == 0 || nargout == 1)
-		    {
-		      retval(0) = sigma.diag ();
-		    }
-		  else
-		    {
-		      retval(2) = result.right_singular_matrix ();
-		      retval(1) = sigma;
-		      retval(0) = result.left_singular_matrix ();
-		    }
-		}
-	    }
-	  else if (arg.is_complex_type ())
-	    {
-	      ComplexMatrix ctmp = arg.complex_matrix_value ();
+                  if (nargout == 0 || nargout == 1)
+                    {
+                      retval(0) = sigma.diag ();
+                    }
+                  else
+                    {
+                      retval(2) = result.right_singular_matrix ();
+                      retval(1) = sigma;
+                      retval(0) = result.left_singular_matrix ();
+                    }
+                }
+            }
+          else if (arg.is_complex_type ())
+            {
+              ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-	      if (! error_state)
-		{
-		  if (ctmp.any_element_is_inf_or_nan ())
-		    {
-		      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
-		      return retval;
-		    }
+              if (! error_state)
+                {
+                  if (ctmp.any_element_is_inf_or_nan ())
+                    {
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      return retval;
+                    }
 
-		  ComplexSVD result (ctmp, type);
+                  ComplexSVD result (ctmp, type);
 
-		  DiagMatrix sigma = result.singular_values ();
+                  DiagMatrix sigma = result.singular_values ();
 
-		  if (nargout == 0 || nargout == 1)
-		    {
-		      retval(0) = sigma.diag ();
-		    }
-		  else
-		    {
-		      retval(2) = result.right_singular_matrix ();
-		      retval(1) = sigma;
-		      retval(0) = result.left_singular_matrix ();
-		    }
-		}
-	    }
-	  else
-	    {
-	      gripe_wrong_type_arg ("svd", arg);
-	      return retval;
-	    }
-	}
+                  if (nargout == 0 || nargout == 1)
+                    {
+                      retval(0) = sigma.diag ();
+                    }
+                  else
+                    {
+                      retval(2) = result.right_singular_matrix ();
+                      retval(1) = sigma;
+                      retval(0) = result.left_singular_matrix ();
+                    }
+                }
+            }
+          else
+            {
+              gripe_wrong_type_arg ("svd", arg);
+              return retval;
+            }
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!assert(svd ([1, 2; 2, 1]), [3; 1], sqrt (eps));
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -108,106 +108,106 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
       gripe_nonconformant ();
       return retval;
     }
   
   // Dimensions look o.k., let's solve the problem.
   if (isfloat)
     {
       if (arg_a.is_complex_type ()
-	  || arg_b.is_complex_type ()
-	  || arg_c.is_complex_type ())
-	{
-	  // Do everything in complex arithmetic;
+          || arg_b.is_complex_type ()
+          || arg_c.is_complex_type ())
+        {
+          // Do everything in complex arithmetic;
 
-	  FloatComplexMatrix ca = arg_a.float_complex_matrix_value ();
+          FloatComplexMatrix ca = arg_a.float_complex_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  FloatComplexMatrix cb = arg_b.float_complex_matrix_value ();
+          FloatComplexMatrix cb = arg_b.float_complex_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  FloatComplexMatrix cc = arg_c.float_complex_matrix_value ();
+          FloatComplexMatrix cc = arg_c.float_complex_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  retval = Sylvester (ca, cb, cc);
-	}
+          retval = Sylvester (ca, cb, cc);
+        }
       else
-	{
-	  // Do everything in real arithmetic.
+        {
+          // Do everything in real arithmetic.
 
-	  FloatMatrix ca = arg_a.float_matrix_value ();
+          FloatMatrix ca = arg_a.float_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  FloatMatrix cb = arg_b.float_matrix_value ();
+          FloatMatrix cb = arg_b.float_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  FloatMatrix cc = arg_c.float_matrix_value ();
+          FloatMatrix cc = arg_c.float_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  retval = Sylvester (ca, cb, cc);
-	}
+          retval = Sylvester (ca, cb, cc);
+        }
     }
   else
     {
       if (arg_a.is_complex_type ()
-	  || arg_b.is_complex_type ()
-	  || arg_c.is_complex_type ())
-	{
-	  // Do everything in complex arithmetic;
+          || arg_b.is_complex_type ()
+          || arg_c.is_complex_type ())
+        {
+          // Do everything in complex arithmetic;
 
-	  ComplexMatrix ca = arg_a.complex_matrix_value ();
+          ComplexMatrix ca = arg_a.complex_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  ComplexMatrix cb = arg_b.complex_matrix_value ();
+          ComplexMatrix cb = arg_b.complex_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  ComplexMatrix cc = arg_c.complex_matrix_value ();
+          ComplexMatrix cc = arg_c.complex_matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  retval = Sylvester (ca, cb, cc);
-	}
+          retval = Sylvester (ca, cb, cc);
+        }
       else
-	{
-	  // Do everything in real arithmetic.
+        {
+          // Do everything in real arithmetic.
 
-	  Matrix ca = arg_a.matrix_value ();
+          Matrix ca = arg_a.matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  Matrix cb = arg_b.matrix_value ();
+          Matrix cb = arg_b.matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  Matrix cc = arg_c.matrix_value ();
+          Matrix cc = arg_c.matrix_value ();
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  retval = Sylvester (ca, cb, cc);
-	}
+          retval = Sylvester (ca, cb, cc);
+        }
     }
 
   return retval;
 }
 
 /*
 
 %!assert(syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12]), [-1/2, -2/3; -2/3, -1/2], sqrt (eps));
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -143,56 +143,56 @@ factorization as determined by @var{typ}
       A->nrow = a.rows();
       A->ncol = a.cols();
       A->p = a.cidx();
       A->i = a.ridx();
       A->nzmax = a.nnz();
       A->xtype = CHOLMOD_REAL;
 
       if (a.rows() > 0 && a.cols() > 0)
-	A->x = a.data();
+        A->x = a.data();
     }
   else if (args(0).is_complex_type ())
     {
       const SparseComplexMatrix a = args(0).sparse_complex_matrix_value();
       A->nrow = a.rows();
       A->ncol = a.cols();
       A->p = a.cidx();
       A->i = a.ridx();
       A->nzmax = a.nnz();
       A->xtype = CHOLMOD_COMPLEX;
 
       if (a.rows() > 0 && a.cols() > 0)
-	A->x = a.data();
+        A->x = a.data();
     }
   else
     gripe_wrong_type_arg ("symbfact", args(0));
 
   octave_idx_type coletree = false;
   octave_idx_type n = A->nrow;
 
   if (nargin > 1)
     {
       char ch;
       std::string str = args(1).string_value();
       ch = tolower (str.c_str()[0]);
       if (ch == 'r')
-	A->stype = 0;
+        A->stype = 0;
       else if (ch == 'c')
-	{
-	  n = A->ncol;
-	  coletree = true;
-	  A->stype = 0;
-	}
+        {
+          n = A->ncol;
+          coletree = true;
+          A->stype = 0;
+        }
       else if (ch == 's')
-	A->stype = 1;
+        A->stype = 1;
       else if (ch == 's')
-	A->stype = -1;
+        A->stype = -1;
       else
-	error ("Unrecognized typ in symbolic factorization");
+        error ("Unrecognized typ in symbolic factorization");
     }
 
   if (A->stype && A->nrow != A->ncol)
     error ("Matrix must be square");
 
   if (!error_state)
     {
       OCTAVE_LOCAL_BUFFER (octave_idx_type, Parent, n);
@@ -200,158 +200,158 @@ factorization as determined by @var{typ}
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ColCount, n);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, First, n);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, Level, n);
 
       cholmod_sparse *F = CHOLMOD_NAME(transpose) (A, 0, cm);
       cholmod_sparse *Aup, *Alo;
 
       if (A->stype == 1 || coletree)
-	{
-	  Aup = A ;
-	  Alo = F ;
-	}
+        {
+          Aup = A ;
+          Alo = F ;
+        }
       else
-	{
-	  Aup = F ;
-	  Alo = A ;
-	}
+        {
+          Aup = F ;
+          Alo = A ;
+        }
 
       CHOLMOD_NAME(etree) (Aup, Parent, cm);
 
       if (cm->status < CHOLMOD_OK)
-	{
-	  error("matrix corrupted");
-	  goto symbfact_error;
-	}
+        {
+          error("matrix corrupted");
+          goto symbfact_error;
+        }
 
       if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
-	{
-	  error("postorder failed");
-	  goto symbfact_error;
-	}
+        {
+          error("postorder failed");
+          goto symbfact_error;
+        }
 
       CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
-				  ColCount, First, Level, cm);
+                                  ColCount, First, Level, cm);
 
       if (cm->status < CHOLMOD_OK)
-	{
-	  error("matrix corrupted");
-	  goto symbfact_error;
-	}
+        {
+          error("matrix corrupted");
+          goto symbfact_error;
+        }
 
       if (nargout > 4)
-	{
-	  cholmod_sparse *A1, *A2;
+        {
+          cholmod_sparse *A1, *A2;
 
-	  if (A->stype == 1)
-	    {
-	      A1 = A;
-	      A2 = 0;
-	    }
-	  else if (A->stype == -1)
-	    {
-	      A1 = F;
-	      A2 = 0;
-	    }
-	  else if (coletree)
-	    {
-	      A1 = F;
-	      A2 = A;
-	    }
-	  else
-	    {
-	      A1 = A;
-	      A2 = F;
-	    }
+          if (A->stype == 1)
+            {
+              A1 = A;
+              A2 = 0;
+            }
+          else if (A->stype == -1)
+            {
+              A1 = F;
+              A2 = 0;
+            }
+          else if (coletree)
+            {
+              A1 = F;
+              A2 = A;
+            }
+          else
+            {
+              A1 = A;
+              A2 = F;
+            }
 
-	  // count the total number of entries in L
-	  octave_idx_type lnz = 0 ;
-	  for (octave_idx_type j = 0 ; j < n ; j++)
-	    lnz += ColCount [j] ;
-	
+          // count the total number of entries in L
+          octave_idx_type lnz = 0 ;
+          for (octave_idx_type j = 0 ; j < n ; j++)
+            lnz += ColCount [j] ;
+        
 
-	  // allocate the output matrix L (pattern-only)
-	  SparseBoolMatrix L (n, n, lnz);
+          // allocate the output matrix L (pattern-only)
+          SparseBoolMatrix L (n, n, lnz);
 
-	  // initialize column pointers
-	  lnz = 0;
-	  for (octave_idx_type j = 0 ; j < n ; j++)
-	    {
-	      L.xcidx(j) = lnz;
-	      lnz += ColCount [j];
-	    }
-	  L.xcidx(n) = lnz;
+          // initialize column pointers
+          lnz = 0;
+          for (octave_idx_type j = 0 ; j < n ; j++)
+            {
+              L.xcidx(j) = lnz;
+              lnz += ColCount [j];
+            }
+          L.xcidx(n) = lnz;
 
 
-	  /* create a copy of the column pointers */
-	  octave_idx_type *W = First;
-	  for (octave_idx_type j = 0 ; j < n ; j++)
-	    W [j] = L.xcidx(j);
+          /* create a copy of the column pointers */
+          octave_idx_type *W = First;
+          for (octave_idx_type j = 0 ; j < n ; j++)
+            W [j] = L.xcidx(j);
 
-	  // get workspace for computing one row of L
-	  cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true, 
-						       0, CHOLMOD_PATTERN, cm);
-	  octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
-	  octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
+          // get workspace for computing one row of L
+          cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true, 
+                                                       0, CHOLMOD_PATTERN, cm);
+          octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
+          octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
-	  // compute L one row at a time
-	  for (octave_idx_type k = 0 ; k < n ; k++)
-	    {
-	      // get the kth row of L and store in the columns of L
-	      CHOLMOD_NAME (row_subtree) (A1, A2, k, Parent, R, cm) ;
-	      for (octave_idx_type p = 0 ; p < Rp [1] ; p++)
-		L.xridx (W [Ri [p]]++) = k ;
+          // compute L one row at a time
+          for (octave_idx_type k = 0 ; k < n ; k++)
+            {
+              // get the kth row of L and store in the columns of L
+              CHOLMOD_NAME (row_subtree) (A1, A2, k, Parent, R, cm) ;
+              for (octave_idx_type p = 0 ; p < Rp [1] ; p++)
+                L.xridx (W [Ri [p]]++) = k ;
 
-	      // add the diagonal entry
-	      L.xridx (W [k]++) = k ;
-	    }
+              // add the diagonal entry
+              L.xridx (W [k]++) = k ;
+            }
 
-	  // free workspace
-	  cholmod_free_sparse (&R, cm) ;
+          // free workspace
+          cholmod_free_sparse (&R, cm) ;
 
 
-	  // transpose L to get R, or leave as is
-	  if (nargin < 3)
-	    L = L.transpose ();
+          // transpose L to get R, or leave as is
+          if (nargin < 3)
+            L = L.transpose ();
 
-	  // fill numerical values of L with one's
-	  for (octave_idx_type p = 0 ; p < lnz ; p++)
-	    L.xdata(p) = true;
+          // fill numerical values of L with one's
+          for (octave_idx_type p = 0 ; p < lnz ; p++)
+            L.xdata(p) = true;
 
-	  retval(4) = L;
-	}
+          retval(4) = L;
+        }
 
       ColumnVector tmp (n);
       if (nargout > 3)
-	{
-	  for (octave_idx_type i = 0; i < n; i++)
-	    tmp(i) = Post[i] + 1;
-	  retval(3) = tmp;
-	}
+        {
+          for (octave_idx_type i = 0; i < n; i++)
+            tmp(i) = Post[i] + 1;
+          retval(3) = tmp;
+        }
 
       if (nargout > 2)
-	{
-	  for (octave_idx_type i = 0; i < n; i++)
-	    tmp(i) = Parent[i] + 1;
-	  retval(2) = tmp;
-	}
+        {
+          for (octave_idx_type i = 0; i < n; i++)
+            tmp(i) = Parent[i] + 1;
+          retval(2) = tmp;
+        }
 
       if (nargout > 1)
-	{
-	  /* compute the elimination tree height */
-	  octave_idx_type height = 0 ;
-	  for (int i = 0 ; i < n ; i++)
-	    height = (height > Level[i] ? height : Level[i]);
-	  height++ ;
-	  retval(1) = static_cast<double> (height);
-	}
+        {
+          /* compute the elimination tree height */
+          octave_idx_type height = 0 ;
+          for (int i = 0 ; i < n ; i++)
+            height = (height > Level[i] ? height : Level[i]);
+          height++ ;
+          retval(1) = static_cast<double> (height);
+        }
 
       for (octave_idx_type i = 0; i < n; i++)
-	tmp(i) = ColCount[i];
+        tmp(i) = ColCount[i];
       retval(0) = tmp;
     }
 
  symbfact_error:
 #else
   error ("symbfact: not available in this version of Octave");
 #endif
 
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -21,31 +21,31 @@ along with Octave; see the file COPYING.
 */
 
 /*
 An implementation of the Reverse Cuthill-McKee algorithm (symrcm)
 
 The implementation of this algorithm is based in the descriptions found in
 
 @INPROCEEDINGS{,
-	author = {E. Cuthill and J. McKee},
-	title = {Reducing the Bandwidth of Sparse Symmetric Matrices},
-	booktitle = {Proceedings of the 24th ACM National Conference},
-	publisher = {Brandon Press},
-	pages = {157 -- 172},
-	location = {New Jersey},
-	year = {1969}
+        author = {E. Cuthill and J. McKee},
+        title = {Reducing the Bandwidth of Sparse Symmetric Matrices},
+        booktitle = {Proceedings of the 24th ACM National Conference},
+        publisher = {Brandon Press},
+        pages = {157 -- 172},
+        location = {New Jersey},
+        year = {1969}
 }
 
 @BOOK{,
-	author = {Alan George and Joseph W. H. Liu},
-	title = {Computer Solution of Large Sparse Positive Definite Systems},
-	publisher = {Prentice Hall Series in Computational Mathematics},
-	ISBN = {0-13-165274-5},
-	year = {1981}
+        author = {Alan George and Joseph W. H. Liu},
+        title = {Computer Solution of Large Sparse Positive Definite Systems},
+        publisher = {Prentice Hall Series in Computational Mathematics},
+        ISBN = {0-13-165274-5},
+        year = {1981}
 }
 
 The algorithm represents a heuristic approach to the NP-complete minimum
 bandwidth problem.
 
 Written by Michael Weitzel <michael.weitzel@@uni-siegen.de>
                            <weitzel@@ldknet.org>
 */
@@ -80,73 +80,73 @@ struct CMK_Node
 // A simple queue.
 // Queues Q have a fixed maximum size N (rows,cols of the matrix) and are
 // stored in an array. qh and qt point to queue head and tail.
 
 // Enqueue operation (adds a node "o" at the tail)
 
 inline static void 
 Q_enq (CMK_Node *Q, octave_idx_type N, octave_idx_type& qt, const CMK_Node& o)
-{	
+{       
   Q[qt] = o;
   qt = (qt + 1) % (N + 1);
 }
 
 // Dequeue operation (removes a node from the head)
 
 inline static CMK_Node 
 Q_deq (CMK_Node * Q, octave_idx_type N, octave_idx_type& qh)
 {
   CMK_Node r = Q[qh];
   qh = (qh + 1) % (N + 1);
   return r;
 }
 
 // Predicate (queue empty)
-#define Q_empty(Q, N, qh, qt)	((qh) == (qt))
+#define Q_empty(Q, N, qh, qt)   ((qh) == (qt))
 
 // A simple, array-based binary heap (used as a priority queue for nodes)
 
 // the left descendant of entry i
-#define LEFT(i)		(((i) << 1) + 1)	// = (2*(i)+1)
+#define LEFT(i)         (((i) << 1) + 1)        // = (2*(i)+1)
 // the right descendant of entry i
-#define RIGHT(i)	(((i) << 1) + 2)	// = (2*(i)+2)
+#define RIGHT(i)        (((i) << 1) + 2)        // = (2*(i)+2)
 // the parent of entry i
-#define PARENT(i)	(((i) - 1) >> 1)	// = floor(((i)-1)/2)
+#define PARENT(i)       (((i) - 1) >> 1)        // = floor(((i)-1)/2)
 
 // Builds a min-heap (the root contains the smallest element). A is an array
 // with the graph's nodes, i is a starting position, size is the length of A.
 
 static void 
 H_heapify_min (CMK_Node *A, octave_idx_type i, octave_idx_type size)
 {
   octave_idx_type j = i;
   for (;;)
     {
       octave_idx_type l = LEFT(j);
       octave_idx_type r = RIGHT(j);
 
       octave_idx_type smallest;
       if (l < size && A[l].deg < A[j].deg)
-	smallest = l;
+        smallest = l;
       else
-	smallest = j;
+        smallest = j;
 
       if (r < size && A[r].deg < A[smallest].deg)
-	smallest = r;
+        smallest = r;
 
       if (smallest != j)
-	{
-	  CMK_Node tmp = A[j];
-	  A[j] = A[smallest];
-	  A[smallest] = tmp;
-	  j = smallest;
-	}
+        {
+          CMK_Node tmp = A[j];
+          A[j] = A[smallest];
+          A[smallest] = tmp;
+          j = smallest;
+        }
       else 
-	break;
+        break;
     }
 }
 
 // Heap operation insert. Running time is O(log(n))
 
 static void 
 H_insert (CMK_Node *H, octave_idx_type& h, const CMK_Node& o)
 {
@@ -155,25 +155,25 @@ H_insert (CMK_Node *H, octave_idx_type& 
   H[i] = o;
 
   if (i == 0) 
     return;
   do
     {
       octave_idx_type p = PARENT(i);
       if (H[i].deg < H[p].deg)
-	{
-	  CMK_Node tmp = H[i];
-	  H[i] = H[p];
-	  H[p] = tmp;
+        {
+          CMK_Node tmp = H[i];
+          H[i] = H[p];
+          H[p] = tmp;
 
-	  i = p;
-	}
+          i = p;
+        }
       else 
-	break;
+        break;
     }
   while (i > 0);
 }
 
 // Heap operation remove-min. Removes the smalles element in O(1) and
 // reorganizes the heap optionally in O(log(n))
 
 inline static CMK_Node 
@@ -182,26 +182,26 @@ H_remove_min (CMK_Node *H, octave_idx_ty
   CMK_Node r = H[0];
   H[0] = H[--h];
   if (reorg) 
     H_heapify_min(H, 0, h);
   return r;
 }
 
 // Predicate (heap empty)
-#define H_empty(H, h)	((h) == 0)
+#define H_empty(H, h)   ((h) == 0)
 
 // Helper function for the Cuthill-McKee algorithm. Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
 
 static octave_idx_type 
 find_starting_node (octave_idx_type N, const octave_idx_type *ridx, 
-		    const octave_idx_type *cidx, const octave_idx_type *ridx2, 
-		    const octave_idx_type *cidx2, octave_idx_type *D, 
-		    octave_idx_type start)
+                    const octave_idx_type *cidx, const octave_idx_type *ridx2, 
+                    const octave_idx_type *cidx2, octave_idx_type *D, 
+                    octave_idx_type start)
 {
   CMK_Node w;
 
   OCTAVE_LOCAL_BUFFER (CMK_Node, Q, N+1);
   boolNDArray btmp (dim_vector (1, N), false);
   bool *visit = btmp.fortran_vec ();
 
   octave_idx_type qh = 0;
@@ -216,181 +216,181 @@ find_starting_node (octave_idx_type N, c
   // distance level
   octave_idx_type level = 0;
   // current largest "eccentricity"
   octave_idx_type max_dist = 0;
 
   for (;;)
     {
       while (! Q_empty (Q, N, qh, qt))
-	{
-	  CMK_Node v = Q_deq (Q, N, qh);
+        {
+          CMK_Node v = Q_deq (Q, N, qh);
 
-	  if (v.dist > x.dist || (v.id != x.id && v.deg > x.deg))
-	    x = v;
+          if (v.dist > x.dist || (v.id != x.id && v.deg > x.deg))
+            x = v;
 
-	  octave_idx_type i = v.id;
+          octave_idx_type i = v.id;
 
-	  // add all unvisited neighbors to the queue
-	  octave_idx_type j1 = cidx[i];
-	  octave_idx_type j2 = cidx2[i];
-	  while (j1 < cidx[i+1] || j2 < cidx2[i+1])
-	    {
-	      OCTAVE_QUIT;
+          // add all unvisited neighbors to the queue
+          octave_idx_type j1 = cidx[i];
+          octave_idx_type j2 = cidx2[i];
+          while (j1 < cidx[i+1] || j2 < cidx2[i+1])
+            {
+              OCTAVE_QUIT;
 
-	      if (j1 == cidx[i+1])
-		{
-		  octave_idx_type r2 = ridx2[j2++];
-		  if (! visit[r2])
-		    {
-		      // the distance of node j is dist(i)+1
-		      w.id = r2;
-		      w.deg = D[r2];
-		      w.dist = v.dist+1;
-		      Q_enq (Q, N, qt, w);
-		      visit[r2] = true;
+              if (j1 == cidx[i+1])
+                {
+                  octave_idx_type r2 = ridx2[j2++];
+                  if (! visit[r2])
+                    {
+                      // the distance of node j is dist(i)+1
+                      w.id = r2;
+                      w.deg = D[r2];
+                      w.dist = v.dist+1;
+                      Q_enq (Q, N, qt, w);
+                      visit[r2] = true;
 
-		      if (w.dist > level)
-			level = w.dist;
-		    }
-		}
-	      else if (j2 == cidx2[i+1])
-		{
-		  octave_idx_type r1 = ridx[j1++];
-		  if (! visit[r1])
-		    {
-		      // the distance of node j is dist(i)+1
-		      w.id = r1;
-		      w.deg = D[r1];
-		      w.dist = v.dist+1;
-		      Q_enq (Q, N, qt, w);
-		      visit[r1] = true;
+                      if (w.dist > level)
+                        level = w.dist;
+                    }
+                }
+              else if (j2 == cidx2[i+1])
+                {
+                  octave_idx_type r1 = ridx[j1++];
+                  if (! visit[r1])
+                    {
+                      // the distance of node j is dist(i)+1
+                      w.id = r1;
+                      w.deg = D[r1];
+                      w.dist = v.dist+1;
+                      Q_enq (Q, N, qt, w);
+                      visit[r1] = true;
 
-		      if (w.dist > level)
-			level = w.dist;
-		    }
-		}
-	      else
-		{
-		  octave_idx_type r1 = ridx[j1];
-		  octave_idx_type r2 = ridx2[j2];
-		  if (r1 <= r2)
-		    {
-		      if (! visit[r1])
-			{
-			  w.id = r1;
-			  w.deg = D[r1];
-			  w.dist = v.dist+1;
-			  Q_enq (Q, N, qt, w);
-			  visit[r1] = true;
+                      if (w.dist > level)
+                        level = w.dist;
+                    }
+                }
+              else
+                {
+                  octave_idx_type r1 = ridx[j1];
+                  octave_idx_type r2 = ridx2[j2];
+                  if (r1 <= r2)
+                    {
+                      if (! visit[r1])
+                        {
+                          w.id = r1;
+                          w.deg = D[r1];
+                          w.dist = v.dist+1;
+                          Q_enq (Q, N, qt, w);
+                          visit[r1] = true;
 
-			  if (w.dist > level)
-			    level = w.dist;
-			}
-		      j1++;
-		      if (r1 == r2)
-			j2++;
-		    }
-		  else
-		    {
-		      if (! visit[r2])
-			{
-			  w.id = r2;
-			  w.deg = D[r2];
-			  w.dist = v.dist+1;
-			  Q_enq (Q, N, qt, w);
-			  visit[r2] = true;
+                          if (w.dist > level)
+                            level = w.dist;
+                        }
+                      j1++;
+                      if (r1 == r2)
+                        j2++;
+                    }
+                  else
+                    {
+                      if (! visit[r2])
+                        {
+                          w.id = r2;
+                          w.deg = D[r2];
+                          w.dist = v.dist+1;
+                          Q_enq (Q, N, qt, w);
+                          visit[r2] = true;
 
-			  if (w.dist > level)
-			    level = w.dist;
-			}
-		      j2++;
-		    }
-		}
-	    }
-	} // finish of BFS
+                          if (w.dist > level)
+                            level = w.dist;
+                        }
+                      j2++;
+                    }
+                }
+            }
+        } // finish of BFS
 
       if (max_dist < x.dist)
-	{
-	  max_dist = x.dist;
+        {
+          max_dist = x.dist;
 
-	  for (octave_idx_type i = 0; i < N; i++)
-	    visit[i] = false;
+          for (octave_idx_type i = 0; i < N; i++)
+            visit[i] = false;
 
-	  visit[x.id] = true;
-	  x.dist = 0;
-	  qt = qh = 0;
-	  Q_enq (Q, N, qt, x);
-	}
+          visit[x.id] = true;
+          x.dist = 0;
+          qt = qh = 0;
+          Q_enq (Q, N, qt, x);
+        }
       else
-	break;
+        break;
     }
   return x.id;
 }
 
 // Calculates the node's degrees. This means counting the non-zero elements
 // in the symmetric matrix' rows. This works for non-symmetric matrices 
 // as well.
 
 static octave_idx_type 
 calc_degrees (octave_idx_type N, const octave_idx_type *ridx, 
-	      const octave_idx_type *cidx, octave_idx_type *D)
+              const octave_idx_type *cidx, octave_idx_type *D)
 {
   octave_idx_type max_deg = 0;
 
   for (octave_idx_type i = 0; i < N; i++) 
     D[i] = 0;
 
   for (octave_idx_type j = 0; j < N; j++)
     {
       for (octave_idx_type i = cidx[j]; i < cidx[j+1]; i++)
-	{
-	  OCTAVE_QUIT;
-	  octave_idx_type k = ridx[i];
-	  // there is a non-zero element (k,j)
-	  D[k]++;
-	  if (D[k] > max_deg) 
-	    max_deg = D[k];
-	  // if there is no element (j,k) there is one in
-	  // the symmetric matrix:
-	  if (k != j)
-	    {
-	      bool found = false;
-	      for (octave_idx_type l = cidx[k]; l < cidx[k + 1]; l++)
-		{
-		  OCTAVE_QUIT;
+        {
+          OCTAVE_QUIT;
+          octave_idx_type k = ridx[i];
+          // there is a non-zero element (k,j)
+          D[k]++;
+          if (D[k] > max_deg) 
+            max_deg = D[k];
+          // if there is no element (j,k) there is one in
+          // the symmetric matrix:
+          if (k != j)
+            {
+              bool found = false;
+              for (octave_idx_type l = cidx[k]; l < cidx[k + 1]; l++)
+                {
+                  OCTAVE_QUIT;
 
-		  if (ridx[l] == j)
-		    {
-		      found = true;
-		      break;
-		    }
-		  else if (ridx[l] > j)
-		    break;
-		}
+                  if (ridx[l] == j)
+                    {
+                      found = true;
+                      break;
+                    }
+                  else if (ridx[l] > j)
+                    break;
+                }
 
-	      if (! found)
-		{
-		  // A(j,k) == 0
-		  D[j]++;
-		  if (D[j] > max_deg) 
-		    max_deg = D[j];
-		}
-	    }
-	}
+              if (! found)
+                {
+                  // A(j,k) == 0
+                  D[j]++;
+                  if (D[j] > max_deg) 
+                    max_deg = D[j];
+                }
+            }
+        }
     }
   return max_deg;
 }
 
 // Transpose of the structure of a square sparse matrix
 
 static void
 transpose (octave_idx_type N, const octave_idx_type *ridx, 
-	   const octave_idx_type *cidx, octave_idx_type *ridx2, 
-	   octave_idx_type *cidx2)
+           const octave_idx_type *cidx, octave_idx_type *ridx2, 
+           octave_idx_type *cidx2)
 {
   octave_idx_type nz = cidx[N];
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, w, N + 1);
   for (octave_idx_type i = 0; i < N; i++)
     w[i] = 0;
   for (octave_idx_type i = 0; i < nz; i++)
     w[ridx[i]]++;
@@ -403,19 +403,19 @@ transpose (octave_idx_type N, const octa
       w[i] = cidx2[i];
     }
   cidx2[N] = nz;
   w[N] = nz;
 
   for (octave_idx_type j = 0; j < N; j++)
     for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
       {
-	OCTAVE_QUIT;
-	octave_idx_type q = w [ridx[k]]++;
-	ridx2[q] = j;
+        OCTAVE_QUIT;
+        octave_idx_type q = w [ridx[k]]++;
+        ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
 Symmetric reverse Cuthill-McKee permutation of @var{S}.\n\
@@ -507,17 +507,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   OCTAVE_LOCAL_BUFFER (octave_idx_type, D, N);
   octave_idx_type max_deg = calc_degrees (N, ridx, cidx, D);
 
   // if none of the nodes has a degree > 0 (a matrix of zeros)
   // the return value corresponds to the identity permutation
   if (max_deg == 0)
     {
       for (octave_idx_type i = 0; i < N; i++) 
-	P(i) = i;
+        P(i) = i;
       return octave_value (P);
     }
 
   // a heap for the a node's neighbors. The number of neighbors is
   // limited by the maximum degree max_deg:
   OCTAVE_LOCAL_BUFFER (CMK_Node, S, max_deg);
 
   // a queue for the BFS. The array is always one element larger than
@@ -530,31 +530,31 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   // upper bound for the bandwidth (=quality of solution)
   // initialize the bandwidth of the graph with 0. B contains the
   // the maximum of the theoretical lower limits of the subgraphs
   // bandwidths.
   octave_idx_type B = 0;
 
   // mark all nodes as unvisited; with the exception of the nodes
   // that have degree==0 and build a CC of the graph.
-	
+        
   boolNDArray btmp (dim_vector (1, N), false);
   bool *visit = btmp.fortran_vec ();
 
   do
     {
       // locate an unvisited starting node of the graph
       octave_idx_type i;
       for (i = 0; i < N; i++)
-	if (! visit[i]) 
-	  break;
+        if (! visit[i]) 
+          break;
 
       // locate a probably better starting node
       v.id = find_starting_node (N, ridx, cidx, ridx2, cidx2, D, i);
-		
+                
       // mark the node as visited and enqueue it (a starting node
       // for the BFS). Since the node will be a root of a spanning
       // tree, its dist is 0.
       v.deg = D[v.id];
       v.dist = 0;
       visit[v.id] = true;
       Q_enq (Q, N, qt, v);
 
@@ -562,141 +562,141 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
       // keep a "level" in the spanning tree (= min. distance to the
       // root) for determining the bandwidth of the computed
       // permutation P
       octave_idx_type Bsub = 0;
       // min. dist. to the root is 0
       octave_idx_type level = 0;
       // the root is the first/only node on level 0
       octave_idx_type level_N = 1;
-	
+        
       while (! Q_empty (Q, N, qh, qt))
-	{
-	  v = Q_deq (Q, N, qh);
-	  i = v.id;
+        {
+          v = Q_deq (Q, N, qh);
+          i = v.id;
 
-	  c++;
+          c++;
 
-	  // for computing the inverse permutation P where
-	  // A(inv(P),inv(P)) or P'*A*P is banded
-	  //	     P(i) = c;
-			
-	  // for computing permutation P where
-	  // A(P(i),P(j)) or P*A*P' is banded
-	  P(c) = i;
+          // for computing the inverse permutation P where
+          // A(inv(P),inv(P)) or P'*A*P is banded
+          //         P(i) = c;
+                        
+          // for computing permutation P where
+          // A(P(i),P(j)) or P*A*P' is banded
+          P(c) = i;
 
-	  // put all unvisited neighbors j of node i on the heap
-	  s = 0;
-	  octave_idx_type j1 = cidx[i];
-	  octave_idx_type j2 = cidx2[i];
+          // put all unvisited neighbors j of node i on the heap
+          s = 0;
+          octave_idx_type j1 = cidx[i];
+          octave_idx_type j2 = cidx2[i];
 
-	  OCTAVE_QUIT;
-	  while (j1 < cidx[i+1] || j2 < cidx2[i+1])
-	    {
-	      OCTAVE_QUIT;
-	      if (j1 == cidx[i+1])
-		{
-		  octave_idx_type r2 = ridx2[j2++];
-		  if (! visit[r2])
-		    {
-		      // the distance of node j is dist(i)+1
-		      w.id = r2;
-		      w.deg = D[r2];
-		      w.dist = v.dist+1;
-		      H_insert(S, s, w);
-		      visit[r2] = true;
-		    }
-		}
-	      else if (j2 == cidx2[i+1])
-		{
-		  octave_idx_type r1 = ridx[j1++];
-		  if (! visit[r1])
-		    {
-		      w.id = r1;
-		      w.deg = D[r1];
-		      w.dist = v.dist+1;
-		      H_insert(S, s, w);
-		      visit[r1] = true;
-		    }
-		}
-	      else
-		{
-		  octave_idx_type r1 = ridx[j1];
-		  octave_idx_type r2 = ridx2[j2];
-		  if (r1 <= r2)
-		    {
-		      if (! visit[r1])
-			{
-			  w.id = r1;
-			  w.deg = D[r1];
-			  w.dist = v.dist+1;
-			  H_insert(S, s, w);
-			  visit[r1] = true;
-			}
-		      j1++;
-		      if (r1 == r2)
-			j2++;
-		    }
-		  else
-		    {
-		      if (! visit[r2])
-			{
-			  w.id = r2;
-			  w.deg = D[r2];
-			  w.dist = v.dist+1;
-			  H_insert(S, s, w);
-			  visit[r2] = true;
-			}
-		      j2++;
-		    }
-		}
-	    }
+          OCTAVE_QUIT;
+          while (j1 < cidx[i+1] || j2 < cidx2[i+1])
+            {
+              OCTAVE_QUIT;
+              if (j1 == cidx[i+1])
+                {
+                  octave_idx_type r2 = ridx2[j2++];
+                  if (! visit[r2])
+                    {
+                      // the distance of node j is dist(i)+1
+                      w.id = r2;
+                      w.deg = D[r2];
+                      w.dist = v.dist+1;
+                      H_insert(S, s, w);
+                      visit[r2] = true;
+                    }
+                }
+              else if (j2 == cidx2[i+1])
+                {
+                  octave_idx_type r1 = ridx[j1++];
+                  if (! visit[r1])
+                    {
+                      w.id = r1;
+                      w.deg = D[r1];
+                      w.dist = v.dist+1;
+                      H_insert(S, s, w);
+                      visit[r1] = true;
+                    }
+                }
+              else
+                {
+                  octave_idx_type r1 = ridx[j1];
+                  octave_idx_type r2 = ridx2[j2];
+                  if (r1 <= r2)
+                    {
+                      if (! visit[r1])
+                        {
+                          w.id = r1;
+                          w.deg = D[r1];
+                          w.dist = v.dist+1;
+                          H_insert(S, s, w);
+                          visit[r1] = true;
+                        }
+                      j1++;
+                      if (r1 == r2)
+                        j2++;
+                    }
+                  else
+                    {
+                      if (! visit[r2])
+                        {
+                          w.id = r2;
+                          w.deg = D[r2];
+                          w.dist = v.dist+1;
+                          H_insert(S, s, w);
+                          visit[r2] = true;
+                        }
+                      j2++;
+                    }
+                }
+            }
 
-	  // add the neighbors to the queue (sorted by node degree)
-	  while (! H_empty (S, s))
-	    {
-	      OCTAVE_QUIT;
+          // add the neighbors to the queue (sorted by node degree)
+          while (! H_empty (S, s))
+            {
+              OCTAVE_QUIT;
 
-	      // locate a neighbor of i with minimal degree in O(log(N))
-	      v = H_remove_min(S, s, 1);
-	
-	      // entered the BFS a new level?
-	      if (v.dist > level)
-		{
-		  // adjustment of bandwith:
-		  // "[...] the minimum bandwidth that
-		  // can be obtained [...] is the
-		  //  maximum number of nodes per level"
-		  if (Bsub < level_N)
-		    Bsub = level_N;
-	
-		  level = v.dist;
-		  // v is the first node on the new level
-		  level_N = 1;
-		}
-	      else
-		{
-		  // there is no new level but another node on
-		  // this level:
-		  level_N++;
-		}
-	
-	      // enqueue v in O(1)
-	      Q_enq (Q, N, qt, v);
-	    }
-	
-	  // synchronize the bandwidth with level_N once again:
-	  if (Bsub < level_N)
-	    Bsub = level_N;
-	}
+              // locate a neighbor of i with minimal degree in O(log(N))
+              v = H_remove_min(S, s, 1);
+        
+              // entered the BFS a new level?
+              if (v.dist > level)
+                {
+                  // adjustment of bandwith:
+                  // "[...] the minimum bandwidth that
+                  // can be obtained [...] is the
+                  //  maximum number of nodes per level"
+                  if (Bsub < level_N)
+                    Bsub = level_N;
+        
+                  level = v.dist;
+                  // v is the first node on the new level
+                  level_N = 1;
+                }
+              else
+                {
+                  // there is no new level but another node on
+                  // this level:
+                  level_N++;
+                }
+        
+              // enqueue v in O(1)
+              Q_enq (Q, N, qt, v);
+            }
+        
+          // synchronize the bandwidth with level_N once again:
+          if (Bsub < level_N)
+            Bsub = level_N;
+        }
       // finish of BFS. If there are still unvisited nodes in the graph
       // then it is split into CCs. The computed bandwidth is the maximum
       // of all subgraphs. Update:
       if (Bsub > B)
-	B = Bsub;
+        B = Bsub;
     }
   // are there any nodes left?
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
   for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
     {
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -131,17 +131,17 @@ gmtime (time ())\n\
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
-	retval = octave_value (mk_tm_map (octave_gmtime (tmp)));
+        retval = octave_value (mk_tm_map (octave_gmtime (tmp)));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -195,17 +195,17 @@ localtime (time ())\n\
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
-	retval = octave_value (mk_tm_map (octave_localtime (tmp)));
+        retval = octave_value (mk_tm_map (octave_localtime (tmp)));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -247,26 +247,26 @@ mktime (localtime (time ()))\n\
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       Octave_map map = args(0).map_value ();
 
       if (! error_state)
-	{
-	  octave_base_tm tm = extract_tm (map);
+        {
+          octave_base_tm tm = extract_tm (map);
 
-	  if (! error_state)
-	    retval = octave_time (tm);
-	  else
-	    error ("mktime: invalid TMSTRUCT argument");
-	}
+          if (! error_state)
+            retval = octave_time (tm);
+          else
+            error ("mktime: invalid TMSTRUCT argument");
+        }
       else
-	error ("mktime: expecting structure argument");
+        error ("mktime: expecting structure argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -436,33 +436,33 @@ Year (1970-).\n\
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       std::string fmt = args(0).string_value ();
 
       if (! error_state)
-	{
-	  Octave_map map = args(1).map_value ();
+        {
+          Octave_map map = args(1).map_value ();
 
-	  if (! error_state)
-	    {
-	      octave_base_tm tm = extract_tm (map);
+          if (! error_state)
+            {
+              octave_base_tm tm = extract_tm (map);
 
-	      if (! error_state)
-		retval = tm.strftime (fmt);
-	      else
-		error ("strftime: invalid TMSTRUCT argument");
-	    }
-	  else
-	    error ("strftime: expecting structure as second argument");
-	}
+              if (! error_state)
+                retval = tm.strftime (fmt);
+              else
+                error ("strftime: invalid TMSTRUCT argument");
+            }
+          else
+            error ("strftime: expecting structure as second argument");
+        }
       else
-	error ("strftime: expecting format string as first argument");
+        error ("strftime: expecting format string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -493,31 +493,31 @@ you're absolutely sure the date string w
 {
   octave_value_list retval;
 
   if (args.length () == 2)
     {
       std::string str = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string fmt = args(1).string_value ();
+        {
+          std::string fmt = args(1).string_value ();
 
-	  if (! error_state)
-	    {
-	      octave_strptime t (str, fmt);
+          if (! error_state)
+            {
+              octave_strptime t (str, fmt);
 
-	      retval(1) = t.characters_converted ();
-	      retval(0) = octave_value (mk_tm_map (t));
-	    }
-	  else
-	    error ("strptime: expecting format string as second argument");
-	}
+              retval(1) = t.characters_converted ();
+              retval(0) = octave_value (mk_tm_map (t));
+            }
+          else
+            error ("strptime: expecting format string as second argument");
+        }
       else
-	error ("strptime: expecting string as first argument");
+        error ("strptime: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -194,17 +194,17 @@ do_trilu (const std::string& name,
       nargin--;
     }
 
   if (nargin == 2)
     {
       k = args(1).int_value (true);
       
       if (error_state)
-	return retval;
+        return retval;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       octave_value arg = args (0);
 
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -60,17 +60,17 @@ inline double min(double a, double b, do
 // one should presort (how?) either the elements of the points of evaluation
 // to cut down the time needed to decide which triangle contains the 
 // given point 
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
 
 DEFUN_DLD (tsearch, args, ,
-	"-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
 Searches for the enclosing Delaunay convex hull.  For @code{@var{t} =\n\
 delaunay (@var{x}, @var{y})}, finds the index in @var{t} containing the\n\
 points @code{(@var{xi}, @var{yi})}.  For points outside the convex hull,\n\
 @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
@@ -114,59 +114,59 @@ points @code{(@var{xi}, @var{yi})}.  For
   octave_idx_type k = nelem; // k is a counter of elements
   for(octave_idx_type kp = 0; kp < np; kp++) 
     {
       const double xt = xi(kp); 
       const double yt = yi(kp);
     
       // check if last triangle contains the next point
       if (k < nelem) 
-	{ 
-	  const double dx1 = xt - x0;
-	  const double dx2 = yt - y0;
-	  const double c1 = (a22 * dx1 - a21 * dx2) / det;
-	  const double c2 = (-a12 * dx1 + a11 * dx2) / det;
-	  if ( c1 >= -eps && c2 >= -eps && (c1 + c2) <= (1 + eps)) 
-	    {
-	      values(kp) = double(k+1);
-	      continue;
-	    }
-	}
+        { 
+          const double dx1 = xt - x0;
+          const double dx2 = yt - y0;
+          const double c1 = (a22 * dx1 - a21 * dx2) / det;
+          const double c2 = (-a12 * dx1 + a11 * dx2) / det;
+          if ( c1 >= -eps && c2 >= -eps && (c1 + c2) <= (1 + eps)) 
+            {
+              values(kp) = double(k+1);
+              continue;
+            }
+        }
     
       // it doesn't, so go through all elements
       for (k = 0; k < nelem; k++) 
-	{ 
-	  OCTAVE_QUIT;
-	  if (xt >= minx(k) && xt <= maxx(k) && 
-	      yt >= miny(k) && yt <= maxy(k) )
-	    {
-	      // element inside the minimum rectangle: examine it closely
-	      x0  = REF(x,k,0);
-	      y0  = REF(y,k,0);
-	      a11 = REF(x,k,1)-x0;
-	      a12 = REF(y,k,1)-y0;
-	      a21 = REF(x,k,2)-x0;
-	      a22 = REF(y,k,2)-y0;
-	      det = a11 * a22 - a21 * a12;
-	
-	      // solve the system
-	      const double dx1 = xt - x0;
-	      const double dx2 = yt - y0;
-	      const double c1 = (a22 * dx1 - a21 * dx2) / det;
-	      const double c2 = (-a12 * dx1 + a11 * dx2) / det;
-	      if ((c1 >= -eps) && (c2 >= -eps) && ((c1 + c2) <= (1 + eps))) 
-		{
-		  values(kp) = double(k+1);
-		  break;
-		}
-	    } //endif # examine this element closely
-	} //endfor # each element
+        { 
+          OCTAVE_QUIT;
+          if (xt >= minx(k) && xt <= maxx(k) && 
+              yt >= miny(k) && yt <= maxy(k) )
+            {
+              // element inside the minimum rectangle: examine it closely
+              x0  = REF(x,k,0);
+              y0  = REF(y,k,0);
+              a11 = REF(x,k,1)-x0;
+              a12 = REF(y,k,1)-y0;
+              a21 = REF(x,k,2)-x0;
+              a22 = REF(y,k,2)-y0;
+              det = a11 * a22 - a21 * a12;
+        
+              // solve the system
+              const double dx1 = xt - x0;
+              const double dx2 = yt - y0;
+              const double c1 = (a22 * dx1 - a21 * dx2) / det;
+              const double c2 = (-a12 * dx1 + a11 * dx2) / det;
+              if ((c1 >= -eps) && (c2 >= -eps) && ((c1 + c2) <= (1 + eps))) 
+                {
+                  values(kp) = double(k+1);
+                  break;
+                }
+            } //endif # examine this element closely
+        } //endfor # each element
 
       if (k == nelem) 
-	values(kp) = lo_ieee_nan_value ();
+        values(kp) = lo_ieee_nan_value ();
     
     } //endfor # kp
   
   retval(0) = values;
   
   return retval;
 }
 
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -86,65 +86,65 @@ curl_handle
 private:
   class
   curl_handle_rep
   {
   public:
     curl_handle_rep (void) : count (1), valid (true), ascii (false)
       {
         curl = curl_easy_init ();
-	if (!curl)
-	  error ("can not create curl handle");
+        if (!curl)
+          error ("can not create curl handle");
       }
 
     ~curl_handle_rep (void)
       {
-	if (curl)
-	  curl_easy_cleanup (curl);
+        if (curl)
+          curl_easy_cleanup (curl);
       }
 
     bool is_valid (void) const
       {
-	return valid;
+        return valid;
       }
 
     bool perform (bool curlerror) const
       {
-	bool retval = false;
-	if (!error_state)
-	  {
-	    BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        bool retval = false;
+        if (!error_state)
+          {
+            BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	    CURLcode res = curl_easy_perform (curl);
-	    if (res != CURLE_OK)
-	      {
-		if (curlerror)
-		  error ("%s", curl_easy_strerror (res));
-	      }
-	    else
-	      retval = true;
+            CURLcode res = curl_easy_perform (curl);
+            if (res != CURLE_OK)
+              {
+                if (curlerror)
+                  error ("%s", curl_easy_strerror (res));
+              }
+            else
+              retval = true;
 
-	    END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  }
-	return retval;
+            END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          }
+        return retval;
       }
 
     CURL* handle (void) const
       {
-	return curl;
+        return curl;
       }
 
     bool is_ascii (void) const
       {
-	return ascii;
+        return ascii;
       }
 
     bool is_binary (void) const
       {
-	return !ascii;
+        return !ascii;
       }
 
     size_t count;
     std::string host;
     bool valid;
     bool ascii;
 
   private:
@@ -170,82 +170,82 @@ public:
   }
 
   curl_handle (void) : rep (new curl_handle_rep ()) 
     { 
       rep->valid = false;
     }
 
   curl_handle (const std::string& _host, const std::string& user, 
-	       const std::string& passwd) :
+               const std::string& passwd) :
     rep (new curl_handle_rep ())
     {
       rep->host = _host;
       init (user, passwd, std::cin, octave_stdout);
 
       std::string url = "ftp://" + _host;
       setopt (CURLOPT_URL, url.c_str());
 
       // Setup the link, with no transfer
       if (!error_state)
-	perform ();
+        perform ();
     }
 
   curl_handle (const std::string& url, const std::string& method, 
-	       const Cell& param, std::ostream& os, bool& retval) :
+               const Cell& param, std::ostream& os, bool& retval) :
     rep (new curl_handle_rep ())
     {
       retval = false;
 
       init ("", "", std::cin, os);
 
       setopt (CURLOPT_NOBODY, 0);
 
       // Don't need to store the parameters here as we can't change
       // the URL after the handle is created 
       std::string query_string = form_query_string (param);
 
       if (method == "get")
-	{
-	  query_string = url + "?" + query_string;
-	  setopt (CURLOPT_URL, query_string.c_str ());
-	}
+        {
+          query_string = url + "?" + query_string;
+          setopt (CURLOPT_URL, query_string.c_str ());
+        }
       else if (method == "post")
-	{
-	  setopt (CURLOPT_URL, url.c_str ());
-	  setopt (CURLOPT_POSTFIELDS, query_string.c_str ());
-	}
+        {
+          setopt (CURLOPT_URL, url.c_str ());
+          setopt (CURLOPT_POSTFIELDS, query_string.c_str ());
+        }
       else
-	setopt (CURLOPT_URL, url.c_str());
+        setopt (CURLOPT_URL, url.c_str());
 
       if (!error_state)
-	retval = perform (false);
+        retval = perform (false);
     }
 
   curl_handle (const curl_handle& h) : rep (h.rep)
     {
       rep->count++;
     }
 
   ~curl_handle (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
   curl_handle& operator = (const curl_handle& h)
     {
       if (this != &h)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-	  rep = h.rep;
-	  rep->count++;
-	}
+          rep = h.rep;
+          rep->count++;
+        }
       return *this;
     }
 
   bool is_valid (void) const
     {
       return rep->is_valid ();
     }
 
@@ -292,192 +292,192 @@ public:
 
   void cwd (const std::string& path) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "cwd " + path;
       slist = curl_slist_append (slist, cmd.c_str());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
-	perform ();
+        perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void del (const std::string& file) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "dele " + file;
       slist = curl_slist_append (slist, cmd.c_str());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
-	perform ();
+        perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void rmdir (const std::string& path) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "rmd " + path;
       slist = curl_slist_append (slist, cmd.c_str());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
-	perform ();
+        perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   bool mkdir (const std::string& path, bool curlerror = true) const
     {
       bool retval = false;
       struct curl_slist *slist = 0;
       std::string cmd = "mkd " + path;
       slist = curl_slist_append (slist, cmd.c_str());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
-	retval = perform (curlerror);
+        retval = perform (curlerror);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
       return retval;
     }
 
   void rename (const std::string& oldname, const std::string& newname) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "rnfr " + oldname;
       slist = curl_slist_append (slist, cmd.c_str());
       cmd = "rnto " + newname;
       slist = curl_slist_append (slist, cmd.c_str());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
-	perform ();
+        perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void put (const std::string& file, std::istream& is) const
     {
       std::string url = "ftp://" + rep->host + "/" + file;
       setopt (CURLOPT_URL, url.c_str());
       setopt (CURLOPT_UPLOAD, 1);
       setopt (CURLOPT_NOBODY, 0);
       set_istream (is);
       if (! error_state)
-	perform ();
+        perform ();
       set_istream (std::cin);
       setopt (CURLOPT_NOBODY, 1);
       setopt (CURLOPT_UPLOAD, 0);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_URL, url.c_str());
     }
 
   void get (const std::string& file, std::ostream& os) const
     {
       std::string url = "ftp://" + rep->host + "/" + file;
       setopt (CURLOPT_URL, url.c_str());
       setopt (CURLOPT_NOBODY, 0);
       set_ostream (os);
       if (! error_state)
-	perform ();
+        perform ();
       set_ostream (octave_stdout);
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_URL, url.c_str());
     }
 
   void dir (void) const
     {
       std::string url = "ftp://" + rep->host + "/";
       setopt (CURLOPT_URL, url.c_str());
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
-	perform ();
+        perform ();
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_URL, url.c_str());
     }
 
   string_vector list (void) const
     {
       std::ostringstream buf;
       std::string url = "ftp://" + rep->host + "/";
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
       setopt (CURLOPT_URL, url.c_str());
       setopt (CURLOPT_DIRLISTONLY, 1);
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
-	perform ();
+        perform ();
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&octave_stdout));
       setopt (CURLOPT_DIRLISTONLY, 0);
       setopt (CURLOPT_URL, url.c_str());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
-	{
-	  pos = str.find_first_of('\n', pos);
-	  if (pos == std::string::npos)
-	    break;
-	  pos++;
-	  n++;
-	}
+        {
+          pos = str.find_first_of('\n', pos);
+          if (pos == std::string::npos)
+            break;
+          pos++;
+          n++;
+        }
       string_vector retval (n);
       pos = 0;
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  size_t newpos = str.find_first_of('\n', pos);
-	  if (newpos == std::string::npos)
-	    break;
+        {
+          size_t newpos = str.find_first_of('\n', pos);
+          if (newpos == std::string::npos)
+            break;
 
-	  retval(i) = str.substr(pos, newpos - pos);
-	  pos = newpos + 1;
-	}
+          retval(i) = str.substr(pos, newpos - pos);
+          pos = newpos + 1;
+        }
       return retval;
     }
 
   void get_fileinfo (const std::string& filename, double& filesize, 
-		     time_t& filetime, bool& fileisdir) const
+                     time_t& filetime, bool& fileisdir) const
     {
       std::string path = pwd();
 
       std::string url = "ftp://" + rep->host + "/" + path + "/" + filename;
       setopt (CURLOPT_URL, url.c_str());
       setopt (CURLOPT_FILETIME, 1); 
       setopt (CURLOPT_HEADERFUNCTION, throw_away);
       setopt (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
       // so this is a means of testing for directories. It also means
       // I can't get the date of directories!
       if (! error_state)
-	{
-	  if (! perform (false))
-	    {
-	      fileisdir = true;
-	      filetime = -1;
-	      filesize = 0;
-	    }
-	  else
-	    {
-	      fileisdir = false;
-	      time_t ft;
-	      curl_easy_getinfo(rep->handle (), CURLINFO_FILETIME, &ft);
-	      filetime = ft;
-	      double fs;
-	      curl_easy_getinfo(rep->handle (), 
-				CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
-	      filesize = fs;
-	    }
-	}
+        {
+          if (! perform (false))
+            {
+              fileisdir = true;
+              filetime = -1;
+              filesize = 0;
+            }
+          else
+            {
+              fileisdir = false;
+              time_t ft;
+              curl_easy_getinfo(rep->handle (), CURLINFO_FILETIME, &ft);
+              filetime = ft;
+              double fs;
+              curl_easy_getinfo(rep->handle (), 
+                                CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
+              filesize = fs;
+            }
+        }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_FILETIME, 0); 
       url = "ftp://" + rep->host;
       setopt (CURLOPT_URL, url.c_str());
 
       // The MDTM command seems to reset the path to the root with the
@@ -494,25 +494,25 @@ public:
       std::ostringstream buf;
 
       slist = curl_slist_append (slist, "pwd");
       setopt (CURLOPT_POSTQUOTE, slist);
       setopt (CURLOPT_HEADERFUNCTION, write_data);
       setopt (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
 
       if (! error_state)
-	{
-	  perform ();
-	  retval = buf.str();
+        {
+          perform ();
+          retval = buf.str();
 
-	  // Can I assume that the path is alway in "" on the last line
-	  size_t pos2 = retval.rfind ('"');
-	  size_t pos1 = retval.rfind ('"', pos2 - 1);
-	  retval = retval.substr(pos1 + 1, pos2 - pos1 - 1);
-	}
+          // Can I assume that the path is alway in "" on the last line
+          size_t pos2 = retval.rfind ('"');
+          size_t pos1 = retval.rfind ('"', pos2 - 1);
+          retval = retval.substr(pos1 + 1, pos2 - pos1 - 1);
+        }
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_WRITEHEADER, 0);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
 
       return retval;
     }
 
@@ -524,50 +524,50 @@ public:
 private:
   curl_handle_rep *rep;
 
   std::string form_query_string (const Cell& param)
     {
       std::ostringstream query;
 
       for (int i = 0; i < param.numel (); i += 2)
-	{
-	  std::string name = param(i).string_value ();
-	  std::string text = param(i+1).string_value ();
+        {
+          std::string name = param(i).string_value ();
+          std::string text = param(i+1).string_value ();
 
-	  // Encode strings.
-	  char *enc_name = curl_easy_escape (rep->handle(), name.c_str (), 
-					     name.length ());
-	  char *enc_text = curl_easy_escape (rep->handle(), text.c_str (), 
-					     text.length ());
+          // Encode strings.
+          char *enc_name = curl_easy_escape (rep->handle(), name.c_str (), 
+                                             name.length ());
+          char *enc_text = curl_easy_escape (rep->handle(), text.c_str (), 
+                                             text.length ());
 
-	  query << enc_name << "=" << enc_text;
+          query << enc_name << "=" << enc_text;
 
-	  curl_free (enc_name);
-	  curl_free (enc_text);
+          curl_free (enc_name);
+          curl_free (enc_text);
 
-	  if (i < param.numel()-1)
-	    query << "&";
-	}
+          if (i < param.numel()-1)
+            query << "&";
+        }
 
       query.flush ();
 
       return query.str ();
     }
 
   void init (const std::string& user, const std::string& passwd, 
-	     std::istream& is, std::ostream& os) 
+             std::istream& is, std::ostream& os) 
     {
       // No data transfer by default
       setopt (CURLOPT_NOBODY, 1);
 
       // Set the username and password
       std::string userpwd = user;
       if (! passwd.empty ())
-	userpwd += ":" + passwd;
+        userpwd += ":" + passwd;
       setopt (CURLOPT_USERPWD, userpwd.c_str ());
 
       // Define our callback to get called when there's data to be written.
       setopt (CURLOPT_WRITEFUNCTION, write_data);
 
       // Set a pointer to our struct to pass to the callback.
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&os));
 
@@ -608,17 +608,17 @@ public:
      curl_global_init(CURL_GLOBAL_DEFAULT);
    }
   
   ~curl_handles (void) 
     {
       // Remove the elements of the map explicitly as they should
       // be deleted before the call to curl_global_cleanup
       for (iterator pa = begin (); pa != end (); pa++)
-	map.erase (pa);
+        map.erase (pa);
 
       curl_global_cleanup ();
     }
 
   iterator begin (void) { return iterator (map.begin ()); }
   const_iterator begin (void) const { return const_iterator (map.begin ()); }
 
   iterator end (void) { return iterator (map.end ()); }
@@ -646,17 +646,17 @@ public:
   curl_handle contents (const_iterator p) const
     { return p->second; }
 
   void del (const std::string& k)
     {
       iterator p = map.find (k);
 
       if (p != map.end ())
-	map.erase (p);
+        map.erase (p);
     }
 
 private:
   std::map<std::string, curl_handle> map;
 };
 
 static curl_handles handles;
 
@@ -764,35 +764,35 @@ urlwrite (\"http://www.google.com/search
 
       if (error_state)
         {
           error ("urlwrite: method can only be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
-	{
-	  error ("urlwrite: method can only be \"get\" or \"post\"");
-	  return retval;
-	}
+        {
+          error ("urlwrite: method can only be \"get\" or \"post\"");
+          return retval;
+        }
 
       param = args(3).cell_value();
 
       if (error_state)
-	{
-	  error ("urlwrite: parameters for get and post requests must be given as a cell");
-	  return retval;
-	}
+        {
+          error ("urlwrite: parameters for get and post requests must be given as a cell");
+          return retval;
+        }
 
 
       if (param.numel () % 2 == 1 )
-	{
-	  error ("urlwrite: number of elements in param must be even");
-	  return retval;
-	}
+        {
+          error ("urlwrite: number of elements in param must be even");
+          return retval;
+        }
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
   // it so that the deletion happens no matter how we exit the function.
 
   file_stat fs (filename);
 
@@ -816,27 +816,27 @@ urlwrite (\"http://www.google.com/search
   if (!error_state)
     frame.discard ();
   else
     frame.run ();
 
   if (nargout > 0)
     {
       if (res)
-	{
-	  retval(2) = std::string ();
-	  retval(1) = true;
-	  retval(0) = octave_env::make_absolute (filename, octave_env::getcwd ());
-	}
+        {
+          retval(2) = std::string ();
+          retval(1) = true;
+          retval(0) = octave_env::make_absolute (filename, octave_env::getcwd ());
+        }
       else
-	{
-	  retval(2) = curl.lasterror ();
-	  retval(1) = false;
-	  retval(0) = std::string ();
-	}
+        {
+          retval(2) = curl.lasterror ();
+          retval(1) = false;
+          retval(0) = std::string ();
+        }
     }
 
   if (nargout < 2 && res)
     error ("urlwrite: curl: %s", curl.lasterror ().c_str ());
 
 #else
   error ("urlwrite: not available in this version of Octave");
 #endif
@@ -909,40 +909,40 @@ s = urlread (\"http://www.google.com/sea
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 3)
     {
       method = args(1).string_value();
 
       if (error_state)
-	{
-	  error ("urlread: method can only be \"get\" or \"post\"");
-	  return retval;
-	}
+        {
+          error ("urlread: method can only be \"get\" or \"post\"");
+          return retval;
+        }
 
       if (method != "get" && method != "post")
-	{
-	  error ("urlread: method can only be \"get\" or \"post\"");
-	  return retval;
-	}
+        {
+          error ("urlread: method can only be \"get\" or \"post\"");
+          return retval;
+        }
 
       param = args(2).cell_value();
 
       if (error_state)
-	{
-	  error ("urlread: parameters for get and post requests must be given as a cell");
-	  return retval;
-	}
+        {
+          error ("urlread: parameters for get and post requests must be given as a cell");
+          return retval;
+        }
 
       if (param.numel () % 2 == 1 )
-	{
-	  error ("urlread: number of elements in param must be even");
-	  return retval;
-	}
+        {
+          error ("urlread: number of elements in param must be even");
+          return retval;
+        }
     }
 
   std::ostringstream buf;
 
   bool res;
   curl_handle curl = curl_handle (url, method, param, buf, res);
 
   if (nargout > 0)
@@ -980,28 +980,28 @@ Undocumented internal function\n\
   if (nargin < 2 || nargin > 4)
     error ("incorrect number of arguments");
   else
     {
       handle = args(0).string_value ();
       host = args(1).string_value ();
   
       if (nargin > 1)
-	user = args(2).string_value ();
+        user = args(2).string_value ();
 
       if (nargin > 2)
-	passwd = args(3).string_value ();
+        passwd = args(3).string_value ();
   
       if (!error_state)
-	{
-	  handles.contents (handle) = curl_handle (host, user, passwd);
-	  
-	  if (error_state)
-	    handles.del (handle);
-	}
+        {
+          handles.contents (handle) = curl_handle (host, user, passwd);
+          
+          if (error_state)
+            handles.del (handle);
+        }
     }
 #else
   error ("__ftp__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1017,24 +1017,24 @@ Undocumented internal function\n\
 
   if (nargin != 1)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    retval = curl.pwd ();
-	  else
-	    error ("__ftp_pwd__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            retval = curl.pwd ();
+          else
+            error ("__ftp_pwd__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_pwd__: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1050,27 +1050,27 @@ Undocumented internal function\n\
   if (nargin != 1 && nargin != 2)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string path = "";
 
       if (nargin > 1)
-	path  = args(1).string_value ();
+        path  = args(1).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.cwd (path);
-	  else
-	    error ("__ftp_cwd__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.cwd (path);
+          else
+            error ("__ftp_cwd__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_cwd__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1086,71 +1086,71 @@ Undocumented internal function\n\
 
   if (nargin != 1)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    {
-	      if (nargout == 0)
-		curl.dir ();
-	      else
-		{
-		  string_vector sv = curl.list ();
-		  octave_idx_type n = sv.length ();
-		  if (n == 0)
-		    {
-		      string_vector flds (5);
-		      flds(0) = "name";
-		      flds(1) = "date";
-		      flds(2) = "bytes";
-		      flds(3) = "isdir";
-		      flds(4) = "datenum";
-		      retval = Octave_map (flds); 
-		    }
-		  else
-		    {
-		      Octave_map st;
-		      Cell filectime (dim_vector (n, 1));
-		      Cell filesize (dim_vector (n, 1));
-		      Cell fileisdir (dim_vector (n, 1));
-		      Cell filedatenum (dim_vector (n, 1));
-		    
-		      st.assign ("name", Cell (sv));
+          if (curl.is_valid ())
+            {
+              if (nargout == 0)
+                curl.dir ();
+              else
+                {
+                  string_vector sv = curl.list ();
+                  octave_idx_type n = sv.length ();
+                  if (n == 0)
+                    {
+                      string_vector flds (5);
+                      flds(0) = "name";
+                      flds(1) = "date";
+                      flds(2) = "bytes";
+                      flds(3) = "isdir";
+                      flds(4) = "datenum";
+                      retval = Octave_map (flds); 
+                    }
+                  else
+                    {
+                      Octave_map st;
+                      Cell filectime (dim_vector (n, 1));
+                      Cell filesize (dim_vector (n, 1));
+                      Cell fileisdir (dim_vector (n, 1));
+                      Cell filedatenum (dim_vector (n, 1));
+                    
+                      st.assign ("name", Cell (sv));
 
-		      for (octave_idx_type i = 0; i < n; i++)
-			{
-			  time_t ftime;
-			  bool fisdir;
-			  double fsize;
-		      
-			  curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+                      for (octave_idx_type i = 0; i < n; i++)
+                        {
+                          time_t ftime;
+                          bool fisdir;
+                          double fsize;
+                      
+                          curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
-			  fileisdir (i) = fisdir;
-			  filectime (i) = ctime (&ftime);
-			  filesize (i) = fsize;
-			  filedatenum (i) = double (ftime);
-			}
-		      st.assign ("date", filectime);
-		      st.assign ("bytes", filesize);
-		      st.assign ("isdir", fileisdir);
-		      st.assign ("datenum", filedatenum);
-		      retval = st;
-		    }
-		}
-	    }
-	  else
-	    error ("__ftp_dir__: invalid ftp handle");
-	}
+                          fileisdir (i) = fisdir;
+                          filectime (i) = ctime (&ftime);
+                          filesize (i) = fsize;
+                          filedatenum (i) = double (ftime);
+                        }
+                      st.assign ("date", filectime);
+                      st.assign ("bytes", filesize);
+                      st.assign ("isdir", fileisdir);
+                      st.assign ("datenum", filedatenum);
+                      retval = st;
+                    }
+                }
+            }
+          else
+            error ("__ftp_dir__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_dir__: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1165,24 +1165,24 @@ Undocumented internal function\n\
 
   if (nargin != 1)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.ascii ();
-	  else
-	    error ("__ftp_ascii__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.ascii ();
+          else
+            error ("__ftp_ascii__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_ascii__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1197,24 +1197,24 @@ Undocumented internal function\n\
 
   if (nargin != 1)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.binary ();
-	  else
-	    error ("__ftp_binary__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.binary ();
+          else
+            error ("__ftp_binary__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_binary__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1229,17 +1229,17 @@ DEFUN_DLD (__ftp_close__, args, ,
 
    if (nargin != 1)
      error ("incorrect number of arguments");
    else
      {
        std::string handle = args(0).string_value ();
 
        if (!error_state)
-	 handles.del (handle);
+         handles.del (handle);
      }
  #else
    error ("__ftp_close__: not available in this version of Octave");
  #endif
 
    return octave_value ();
  }
 
@@ -1256,24 +1256,24 @@ DEFUN_DLD (__ftp_mode__, args, ,
    if (nargin != 1)
      error ("incorrect number of arguments");
    else
      {
        std::string handle = args(0).string_value ();
 
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    retval = (curl.is_ascii() ? "ascii" : "binary");
-	  else
-	    error ("__ftp_binary__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            retval = (curl.is_ascii() ? "ascii" : "binary");
+          else
+            error ("__ftp_binary__: invalid ftp handle");
+        }
      }
  #else
    error ("__ftp_mode__: not available in this version of Octave");
  #endif
 
    return retval;
  }
 
@@ -1289,24 +1289,24 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string file = args(1).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.del (file);
-	  else
-	    error ("__ftp_delete__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.del (file);
+          else
+            error ("__ftp_delete__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_delete__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1322,24 +1322,24 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string dir = args(1).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.rmdir (dir);
-	  else
-	    error ("__ftp_rmdir__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.rmdir (dir);
+          else
+            error ("__ftp_rmdir__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_rmdir__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1355,24 +1355,24 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string dir = args(1).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.mkdir (dir);
-	  else
-	    error ("__ftp_mkdir__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.mkdir (dir);
+          else
+            error ("__ftp_mkdir__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_mkdir__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
@@ -1389,112 +1389,112 @@ Undocumented internal function\n\
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string oldname = args(1).string_value ();
       std::string newname = args(2).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    curl.rename (oldname, newname);
-	  else
-	    error ("__ftp_rename__: invalid ftp handle");
-	}
+          if (curl.is_valid ())
+            curl.rename (oldname, newname);
+          else
+            error ("__ftp_rename__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_rename__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
 
 #ifdef HAVE_CURL
 static string_vector
 mput_directory (const curl_handle& curl, const std::string& base,
-		const std::string& dir)
+                const std::string& dir)
 {
   string_vector retval;
 
   if (! curl.mkdir (dir, false))
     warning ("__ftp_mput__: can not create the remote directory ""%s""",
-	     (base.length() == 0 ? dir : base + 
-	      file_ops::dir_sep_str () + dir).c_str ());
+             (base.length() == 0 ? dir : base + 
+              file_ops::dir_sep_str () + dir).c_str ());
 
   curl.cwd (dir);
 
   if (! error_state)
     {
       unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, curl);
 
       std::string realdir = base.length() == 0 ? dir : base + 
-			 file_ops::dir_sep_str () + dir;
+                         file_ops::dir_sep_str () + dir;
 
       dir_entry dirlist (realdir);
 
       if (dirlist)
-	{
-	  string_vector files = dirlist.read ();
+        {
+          string_vector files = dirlist.read ();
 
-	  for (octave_idx_type i = 0; i < files.length (); i++)
-	    {
-	      std::string file = files (i);
+          for (octave_idx_type i = 0; i < files.length (); i++)
+            {
+              std::string file = files (i);
 
-	      if (file == "." || file == "..")
-		continue;
+              if (file == "." || file == "..")
+                continue;
 
-	      std::string realfile = realdir + file_ops::dir_sep_str () + file;
-	      file_stat fs (realfile);
+              std::string realfile = realdir + file_ops::dir_sep_str () + file;
+              file_stat fs (realfile);
 
-	      if (! fs.exists ())
-		{
-		  error ("__ftp__mput: file ""%s"" does not exist", 
-			 realfile.c_str ());
-		  break;
-		}
+              if (! fs.exists ())
+                {
+                  error ("__ftp__mput: file ""%s"" does not exist", 
+                         realfile.c_str ());
+                  break;
+                }
 
-	      if (fs.is_dir ())
-		{
-		  retval.append (mput_directory (curl, realdir, file));
+              if (fs.is_dir ())
+                {
+                  retval.append (mput_directory (curl, realdir, file));
 
-		  if (error_state)
-		    break;
-		}
-	      else
-		{
-		  // FIXME Does ascii mode need to be flagged here?
-		  std::ifstream ifile (realfile.c_str(), std::ios::in | 
-				       std::ios::binary);
+                  if (error_state)
+                    break;
+                }
+              else
+                {
+                  // FIXME Does ascii mode need to be flagged here?
+                  std::ifstream ifile (realfile.c_str(), std::ios::in | 
+                                       std::ios::binary);
 
-		  if (! ifile.is_open ())
-		    {
-		      error ("__ftp_mput__: unable to open file ""%s""", 
-			     realfile.c_str ());
-		      break;
-		    }
+                  if (! ifile.is_open ())
+                    {
+                      error ("__ftp_mput__: unable to open file ""%s""", 
+                             realfile.c_str ());
+                      break;
+                    }
 
-		  curl.put (file, ifile);
+                  curl.put (file, ifile);
 
-		  ifile.close ();
+                  ifile.close ();
 
-		  if (error_state)
-		    break;
+                  if (error_state)
+                    break;
 
-		  retval.append (realfile);
-		}
-	    }
-	}
+                  retval.append (realfile);
+                }
+            }
+        }
       else
-	error ("__ftp_mput__: can not read the directory ""%s""", 
-	       realdir.c_str());
+        error ("__ftp_mput__: can not read the directory ""%s""", 
+               realdir.c_str());
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (__ftp_mput__, args, nargout,
   "-*- texinfo -*-\n\
@@ -1510,147 +1510,147 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string pat = args(1).string_value ();
 
       if (!error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    {
-	      glob_match pattern (file_ops::tilde_expand (pat));
-	      string_vector files = pattern.glob ();
+          if (curl.is_valid ())
+            {
+              glob_match pattern (file_ops::tilde_expand (pat));
+              string_vector files = pattern.glob ();
 
-	      for (octave_idx_type i = 0; i < files.length (); i++)
-		{
-		  std::string file = files (i);
+              for (octave_idx_type i = 0; i < files.length (); i++)
+                {
+                  std::string file = files (i);
 
-		  file_stat fs (file);
+                  file_stat fs (file);
 
-		  if (! fs.exists ())
-		    {
-		      error ("__ftp__mput: file does not exist");
-		      break;
-		    }
+                  if (! fs.exists ())
+                    {
+                      error ("__ftp__mput: file does not exist");
+                      break;
+                    }
 
-		  if (fs.is_dir ())
-		    {
-		      retval.append (mput_directory (curl, "", file));
-		      if (error_state)
-			break;
-		    }
-		  else
-		    {
-		      // FIXME Does ascii mode need to be flagged here?
-		      std::ifstream ifile (file.c_str(), std::ios::in | 
-					   std::ios::binary);
+                  if (fs.is_dir ())
+                    {
+                      retval.append (mput_directory (curl, "", file));
+                      if (error_state)
+                        break;
+                    }
+                  else
+                    {
+                      // FIXME Does ascii mode need to be flagged here?
+                      std::ifstream ifile (file.c_str(), std::ios::in | 
+                                           std::ios::binary);
 
-		      if (! ifile.is_open ())
-			{
-			  error ("__ftp_mput__: unable to open file");
-			  break;
-			}
+                      if (! ifile.is_open ())
+                        {
+                          error ("__ftp_mput__: unable to open file");
+                          break;
+                        }
 
-		      curl.put (file, ifile);
+                      curl.put (file, ifile);
 
-		      ifile.close ();
+                      ifile.close ();
 
-		      if (error_state)
-			break;
+                      if (error_state)
+                        break;
 
-		      retval.append (file);
-		    }
-		}
-	    }
-	  else
-	    error ("__ftp_mput__: invalid ftp handle");
-	}
+                      retval.append (file);
+                    }
+                }
+            }
+          else
+            error ("__ftp_mput__: invalid ftp handle");
+        }
     }
 #else
   error ("__ftp_mput__: not available in this version of Octave");
 #endif
 
   return (nargout > 0 ? octave_value (retval) : octave_value ());
 }
 
 #ifdef HAVE_CURL
 static void
 getallfiles (const curl_handle& curl, const std::string& dir, 
-	     const std::string& target)
+             const std::string& target)
 {
   std::string sep = file_ops::dir_sep_str ();
   file_stat fs (dir);
 
   if (!fs || !fs.is_dir ())
     { 
       std::string msg;
       int status = file_ops::mkdir (dir, 0777, msg);
 
       if (status < 0)
-	error ("__ftp_mget__: can't create directory %s%s%s. %s", 
-	       target.c_str(), sep.c_str(), dir.c_str(), msg.c_str());
+        error ("__ftp_mget__: can't create directory %s%s%s. %s", 
+               target.c_str(), sep.c_str(), dir.c_str(), msg.c_str());
     }
 
   if (! error_state)
     {
       curl.cwd (dir);
 
       if (! error_state)
-	{
+        {
           unwind_protect_safe frame;
 
-	  frame.add_fcn (reset_path, curl);
+          frame.add_fcn (reset_path, curl);
 
           string_vector sv = curl.list ();
 
-	  for (octave_idx_type i = 0; i < sv.length (); i++)
-	    {
-	      time_t ftime;
-	      bool fisdir;
-	      double fsize;
-		      
-	      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+          for (octave_idx_type i = 0; i < sv.length (); i++)
+            {
+              time_t ftime;
+              bool fisdir;
+              double fsize;
+                      
+              curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
-	      if (fisdir)
-		getallfiles (curl, sv(i), target + dir + sep);
-	      else
-		{
-		  std::string realfile = target + dir + sep + sv(i);
-		  std::ofstream ofile (realfile.c_str(), 
-				       std::ios::out | 
-				       std::ios::binary);
+              if (fisdir)
+                getallfiles (curl, sv(i), target + dir + sep);
+              else
+                {
+                  std::string realfile = target + dir + sep + sv(i);
+                  std::ofstream ofile (realfile.c_str(), 
+                                       std::ios::out | 
+                                       std::ios::binary);
 
-		  if (! ofile.is_open ())
-		    {
-		      error ("__ftp_mget__: unable to open file");
-		      break;
-		    }
+                  if (! ofile.is_open ())
+                    {
+                      error ("__ftp_mget__: unable to open file");
+                      break;
+                    }
 
                   unwind_protect_safe frame2;
 
-		  frame2.add_fcn (delete_file, realfile);
+                  frame2.add_fcn (delete_file, realfile);
 
-		  curl.get (sv(i), ofile);
+                  curl.get (sv(i), ofile);
 
-		  ofile.close ();
+                  ofile.close ();
 
-		  if (!error_state)
-		    frame2.discard ();
-		  else
-		    frame2.run ();
-		}
+                  if (!error_state)
+                    frame2.discard ();
+                  else
+                    frame2.run ();
+                }
 
-	      if (error_state)
-		break;
-	    }
-	}
+              if (error_state)
+                break;
+            }
+        }
     }
 }
 #endif
 
 DEFUN_DLD (__ftp_mget__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
@@ -1663,75 +1663,75 @@ Undocumented internal function\n\
     error ("incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string file = args(1).string_value ();
       std::string target;
 
       if (nargin == 3)
-	target = args(2).string_value () + file_ops::dir_sep_str ();
+        target = args(2).string_value () + file_ops::dir_sep_str ();
 
       if (! error_state)
-	{
-	  const curl_handle curl = handles.contents (handle);
+        {
+          const curl_handle curl = handles.contents (handle);
 
-	  if (curl.is_valid ())
-	    {
-	      string_vector sv = curl.list ();
-	      octave_idx_type n = 0;
-	      glob_match pattern (file);
+          if (curl.is_valid ())
+            {
+              string_vector sv = curl.list ();
+              octave_idx_type n = 0;
+              glob_match pattern (file);
 
-	      for (octave_idx_type i = 0; i < sv.length (); i++)
-		{
-		  if (pattern.match (sv(i)))
-		    {
-		      n++;
+              for (octave_idx_type i = 0; i < sv.length (); i++)
+                {
+                  if (pattern.match (sv(i)))
+                    {
+                      n++;
 
-		      time_t ftime;
-		      bool fisdir;
-		      double fsize;
-		      
-		      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+                      time_t ftime;
+                      bool fisdir;
+                      double fsize;
+                      
+                      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
-		      if (fisdir)
-			getallfiles (curl, sv(i), target);
-		      else
-			{
-			  std::ofstream ofile ((target + sv(i)).c_str(),
-					       std::ios::out | 
-					       std::ios::binary);
+                      if (fisdir)
+                        getallfiles (curl, sv(i), target);
+                      else
+                        {
+                          std::ofstream ofile ((target + sv(i)).c_str(),
+                                               std::ios::out | 
+                                               std::ios::binary);
 
-			  if (! ofile.is_open ())
-			    {
-			      error ("__ftp_mget__: unable to open file");
-			      break;
-			    }
+                          if (! ofile.is_open ())
+                            {
+                              error ("__ftp_mget__: unable to open file");
+                              break;
+                            }
 
                           unwind_protect_safe frame;
 
-			  frame.add_fcn (delete_file, target + sv(i));
+                          frame.add_fcn (delete_file, target + sv(i));
 
-			  curl.get (sv(i), ofile);
+                          curl.get (sv(i), ofile);
 
-			  ofile.close ();
+                          ofile.close ();
 
-			  if (!error_state)
-			    frame.discard ();
-			  else
-			    frame.run ();
-			}
+                          if (!error_state)
+                            frame.discard ();
+                          else
+                            frame.run ();
+                        }
 
-		      if (error_state)
-			break;
-		    }
-		}
-	      if (n == 0)
-		error ("__ftp_mget__: file not found");
-	    }
-	}
+                      if (error_state)
+                        break;
+                    }
+                }
+              if (n == 0)
+                error ("__ftp_mget__: file not found");
+            }
+        }
     }
 #else
   error ("__ftp_mget__: not available in this version of Octave");
 #endif
 
   return octave_value ();
 }
