# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1426782474 14400
#      Thu Mar 19 12:27:54 2015 -0400
# Node ID 3cc0734283dca7dd5d290480a8b47b5c93398125
# Parent  40b2c4323c1696c4fd4bb2881741cd7e682483d9
style fixes in Qt graphics code

* Backend.cc, BaseControl.cc, ButtonControl.cc, Canvas.cc,
CheckBoxControl.cc, Container.cc, ContextMenu.cc, EditControl.cc,
Figure.cc, FigureWindow.cc, GLCanvas.cc, KeyMap.cc, ListBoxControl.cc,
Logger.cc, Menu.cc, MouseModeActionGroup.cc, Object.cc,
ObjectFactory.cc, ObjectProxy.cc, Panel.cc, PopupMenuControl.cc,
PushButtonControl.cc, PushTool.cc, QtHandlesUtils.cc,
RadioButtonControl.cc, SliderControl.cc, TextControl.cc, TextEdit.cc,
ToggleButtonControl.cc, ToggleTool.cc, ToolBar.cc, ToolBarButton.cc,
__init_qt__.cc: Follow a few more Octave coding conventions.

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -43,17 +43,18 @@ along with Octave; see the file COPYING.
 # define OCTAVE_PTR_TYPE octave_uint64
 # define OCTAVE_INTPTR_TYPE uint64_t
 # define OCTAVE_PTR_SCALAR uint64_scalar_value
 //#endif
 
 namespace QtHandles
 {
 
-static std::string toolkitObjectProperty (const graphics_object& go)
+static std::string
+toolkitObjectProperty (const graphics_object& go)
 {
   if (go.isa ("figure"))
     return std::string ("__plot_stream__");
   else if (go.isa ("uicontrol")
            || go.isa ("uipanel")
            || go.isa ("uimenu")
            || go.isa ("uicontextmenu")
            || go.isa ("uitoolbar")
@@ -75,17 +76,18 @@ Backend::Backend (void)
   connect (this, SIGNAL (createObject (double)),
            factory, SLOT (createObject (double)));
 }
 
 Backend::~Backend (void)
 {
 }
 
-bool Backend::initialize (const graphics_object& go)
+bool
+Backend::initialize (const graphics_object& go)
 {
   if (go.isa ("figure")
       || go.isa ("uicontrol")
       || go.isa ("uipanel")
       || go.isa ("uimenu")
       || go.isa ("uicontextmenu")
       || go.isa ("uitoolbar")
       || go.isa ("uipushtool")
@@ -103,17 +105,18 @@ bool Backend::initialize (const graphics
       emit createObject (go.get_handle ().value ());
 
       return true;
     }
 
   return false;
 }
 
-void Backend::update (const graphics_object& go, int pId)
+void
+Backend::update (const graphics_object& go, int pId)
 {
   // Rule out obvious properties we want to ignore.
   if (pId == figure::properties::ID___PLOT_STREAM__
       || pId == uicontrol::properties::ID___OBJECT__
       || pId == uipanel::properties::ID___OBJECT__
       || pId == uimenu::properties::ID___OBJECT__
       || pId == uicontextmenu::properties::ID___OBJECT__
       || pId == uitoolbar::properties::ID___OBJECT__
@@ -138,17 +141,18 @@ void Backend::update (const graphics_obj
           finalize (go);
           initialize (go);
         }
       else
         proxy->update (pId);
     }
 }
 
-void Backend::finalize (const graphics_object& go)
+void
+Backend::finalize (const graphics_object& go)
 {
   Logger::debug ("Backend::finalize %s from thread %08x",
                  go.type ().c_str (), QThread::currentThreadId ());
 
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
     {
@@ -156,53 +160,57 @@ void Backend::finalize (const graphics_o
       delete proxy;
 
       graphics_object gObj (go);
 
       gObj.get_properties ().set (toolkitObjectProperty (go), Matrix ());
     }
 }
 
-void Backend::redraw_figure (const graphics_object& go) const
+void
+Backend::redraw_figure (const graphics_object& go) const
 {
   if (go.get_properties ().is_visible ())
     {
       ObjectProxy* proxy = toolkitObjectProxy (go);
 
       if (proxy)
         proxy->redraw ();
     }
 }
 
-void Backend::print_figure (const graphics_object& go,
+void
+Backend::print_figure (const graphics_object& go,
                             const std::string& term,
                             const std::string& file_cmd, bool /*mono*/,
                             const std::string& /*debug_file*/) const
 {
   if (go.get_properties ().is_visible ())
     {
       ObjectProxy* proxy = toolkitObjectProxy (go);
 
       if (proxy)
         proxy->print (QString::fromStdString (file_cmd),
                       QString::fromStdString (term));
     }
 }
 
-Object* Backend::toolkitObject (const graphics_object& go)
+Object*
+Backend::toolkitObject (const graphics_object& go)
 {
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
     return proxy->object ();
 
   return 0;
 }
 
-ObjectProxy* Backend::toolkitObjectProxy (const graphics_object& go)
+ObjectProxy*
+Backend::toolkitObjectProxy (const graphics_object& go)
 {
   if (go)
     {
       octave_value ov = go.get (toolkitObjectProperty (go));
 
       if (ov.is_defined () && ! ov.is_empty ())
         {
           OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -31,17 +31,18 @@ along with Octave; see the file COPYING.
 
 #include "BaseControl.h"
 #include "ContextMenu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static void updatePalette (const uicontrol::properties& props, QWidget* w)
+static void
+updatePalette (const uicontrol::properties& props, QWidget* w)
 {
   QPalette p = w->palette ();
 
   if (props.style_is ("edit")
       || props.style_is ("listbox")
       || props.style_is ("popupmenu"))
     {
       p.setColor (QPalette::Base,
@@ -69,17 +70,18 @@ static void updatePalette (const uicontr
 }
 
 BaseControl::BaseControl (const graphics_object& go, QWidget* w)
   : Object (go, w), m_normalizedFont (false), m_keyPressHandlerDefined (false)
 {
   init (w);
 }
 
-void BaseControl::init (QWidget* w, bool callBase)
+void
+BaseControl::init (QWidget* w, bool callBase)
 {
   if (callBase)
     Object::init (w, callBase);
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   Matrix bb = up.get_boundingbox (false);
   w->setGeometry (xround (bb(0)), xround (bb(1)),
@@ -95,138 +97,153 @@ void BaseControl::init (QWidget* w, bool
 
   m_normalizedFont = up.fontunits_is ("normalized");
 }
 
 BaseControl::~BaseControl (void)
 {
 }
 
-void BaseControl::update (int pId)
+void
+BaseControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QWidget* w = qWidget<QWidget> ();
 
    switch (pId)
     {
     case uicontrol::properties::ID_POSITION:
         {
           Matrix bb = up.get_boundingbox (false);
           w->setGeometry (xround (bb(0)), xround (bb(1)),
                           xround (bb(2)), xround (bb(3)));
         }
       break;
+
     case uicontrol::properties::ID_FONTNAME:
     case uicontrol::properties::ID_FONTSIZE:
     case uicontrol::properties::ID_FONTWEIGHT:
     case uicontrol::properties::ID_FONTANGLE:
       w->setFont (Utils::computeFont<uicontrol> (up));
       break;
+
     case uicontrol::properties::ID_FONTUNITS:
       // FIXME: We shouldn't have to do anything, octave should update
       //        the "fontsize" property automatically to the new units.
       //        Hence the actual font used shouldn't change.
       m_normalizedFont = up.fontunits_is ("normalized");
       break;
+
     case uicontrol::properties::ID_BACKGROUNDCOLOR:
     case uicontrol::properties::ID_FOREGROUNDCOLOR:
       updatePalette (up, w);
       break;
+
     case uicontrol::properties::ID_ENABLE:
       w->setEnabled (up.enable_is ("on"));
       break;
+
     case uicontrol::properties::ID_TOOLTIPSTRING:
       w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
       break;
+
     case base_properties::ID_VISIBLE:
       w->setVisible (up.is_visible ());
       break;
+
     case uicontrol::properties::ID_KEYPRESSFCN:
       m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
       break;
+
     default:
       break;
     }
 }
 
-bool BaseControl::eventFilter (QObject* watched, QEvent* xevent)
+bool
+BaseControl::eventFilter (QObject* watched, QEvent* xevent)
 {
   switch (xevent->type ())
     {
     case QEvent::Resize:
       if (m_normalizedFont)
         {
           gh_manager::auto_lock lock;
 
           qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
                                         (properties<uicontrol> ()));
         }
       break;
+
     case QEvent::MouseButtonPress:
-        {
-          gh_manager::auto_lock lock;
+      {
+        gh_manager::auto_lock lock;
+
+        QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+        graphics_object go = object ();
+        uicontrol::properties& up = Utils::properties<uicontrol> (go);
+        graphics_object fig = go.get_ancestor ("figure");
 
-          QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
-          graphics_object go = object ();
-          uicontrol::properties& up = Utils::properties<uicontrol> (go);
-          graphics_object fig = go.get_ancestor ("figure");
+        if (m->button () != Qt::LeftButton
+            || ! up.enable_is ("on"))
+          {
+            gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                  Utils::figureSelectionType (m), false);
+            gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                  Utils::figureCurrentPoint (fig, m),
+                                  false);
+            gh_manager::post_callback (fig.get_handle (),
+                                       "windowbuttondownfcn");
+            gh_manager::post_callback (m_handle, "buttondownfcn");
 
-          if (m->button () != Qt::LeftButton
-              || ! up.enable_is ("on"))
-            {
+            if (m->button () == Qt::RightButton)
+              ContextMenu::executeAt (up, m->globalPos ());
+          }
+        else
+          {
+            if (up.style_is ("listbox"))
               gh_manager::post_set (fig.get_handle (), "selectiontype",
                                     Utils::figureSelectionType (m), false);
-              gh_manager::post_set (fig.get_handle (), "currentpoint",
-                                    Utils::figureCurrentPoint (fig, m),
-                                    false);
-              gh_manager::post_callback (fig.get_handle (),
-                                         "windowbuttondownfcn");
-              gh_manager::post_callback (m_handle, "buttondownfcn");
+            else
+              gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                    octave_value ("normal"), false);
+          }
+      }
+      break;
 
-              if (m->button () == Qt::RightButton)
-                ContextMenu::executeAt (up, m->globalPos ());
-            }
-          else
-            {
-              if (up.style_is ("listbox"))
-                gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                      Utils::figureSelectionType (m), false);
-              else
-                gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                      octave_value ("normal"), false);
-            }
-        }
-      break;
     case QEvent::MouseMove:
       if (qWidget<QWidget> ()->hasMouseTracking ())
         {
           gh_manager::auto_lock lock;
 
           QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
           graphics_object go = object ();
           graphics_object fig = go.get_ancestor ("figure");
 
           gh_manager::post_set (fig.get_handle (), "currentpoint",
                                 Utils::figureCurrentPoint (fig, m), false);
           gh_manager::post_callback (fig.get_handle (), "windowbuttonmotionfcn");
         }
       break;
+
     case QEvent::KeyPress:
       if (m_keyPressHandlerDefined)
         {
           gh_manager::auto_lock lock;
 
           octave_scalar_map keyData =
             Utils::makeKeyEventStruct (dynamic_cast<QKeyEvent*> (xevent));
           graphics_object fig = object ().get_ancestor ("figure");
 
           gh_manager::post_set (fig.get_handle (), "currentcharacter",
                                 keyData.getfield ("Character"), false);
           gh_manager::post_callback (m_handle, "keypressfcn", keyData);
         }
       break;
-    default: break;
+
+    default:
+      break;
     }
 
   return Object::eventFilter (watched, xevent);
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "ButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 ButtonControl::ButtonControl (const graphics_object& go, QAbstractButton* btn)
-    : BaseControl (go, btn), m_blockCallback (false)
+  : BaseControl (go, btn), m_blockCallback (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   btn->setText (Utils::fromStdString (up.get_string_string ()));
   if (btn->isCheckable () || up.style_is ("togglebutton"))
     {
       btn->setCheckable (true);
 
@@ -52,26 +52,28 @@ ButtonControl::ButtonControl (const grap
   connect (btn, SIGNAL (clicked (void)), SLOT (clicked (void)));
   connect (btn, SIGNAL (toggled (bool)), SLOT (toggled (bool)));
 }
 
 ButtonControl::~ButtonControl (void)
 {
 }
 
-void ButtonControl::update (int pId)
+void
+ButtonControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QAbstractButton* btn = qWidget<QAbstractButton> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       btn->setText (Utils::fromStdString (up.get_string_string ()));
       break;
+
     case uicontrol::properties::ID_VALUE:
       m_blockCallback = true;
       if (btn->isCheckable ())
         {
           Matrix value = up.get_value ().matrix_value ();
 
           if (value.numel () > 0)
             {
@@ -80,23 +82,25 @@ void ButtonControl::update (int pId)
               if (dValue == up.get_min () && btn->isChecked ())
                 btn->setChecked (false);
               else if (dValue == up.get_max () && ! btn->isChecked ())
                 btn->setChecked (true);
             }
         }
       m_blockCallback = false;
       break;
+
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
-void ButtonControl::toggled (bool checked)
+void
+ButtonControl::toggled (bool checked)
 {
   QAbstractButton* btn = qWidget<QAbstractButton> ();
 
   if (! m_blockCallback && btn->isCheckable ())
     {
       gh_manager::auto_lock lock;
 
       uicontrol::properties& up = properties<uicontrol> ();
@@ -106,17 +110,18 @@ void ButtonControl::toggled (bool checke
 
       if (oldValue.numel() != 1
           || (newValue != oldValue(0)))
         gh_manager::post_set (m_handle, "value", newValue, false);
       gh_manager::post_callback (m_handle, "callback");
     }
 }
 
-void ButtonControl::clicked (void)
+void
+ButtonControl::clicked (void)
 {
   QAbstractButton* btn = qWidget<QAbstractButton> ();
 
   if (! btn->isCheckable ())
     gh_manager::post_callback (m_handle, "callback");
 }
 
 };
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -38,35 +38,38 @@ along with Octave; see the file COPYING.
 #include "GLCanvas.h"
 #include "QtHandlesUtils.h"
 
 #include "gl2ps-renderer.h"
 
 namespace QtHandles
 {
 
-void Canvas::redraw (bool sync)
+void
+Canvas::redraw (bool sync)
 {
   QWidget *w = qWidget ();
 
   if (w)
     {
       if (sync)
         w->repaint ();
       else
         w->update ();
     }
 }
 
-void Canvas::blockRedraw (bool block)
+void
+Canvas::blockRedraw (bool block)
 {
   m_redrawBlocked = block;
 }
 
-void Canvas::setCursor (MouseMode mode)
+void
+Canvas::setCursor (MouseMode mode)
 {
   QWidget *w = qWidget ();
 
   if (w)
     {
       static QCursor origCursor = w->cursor ();
 
       switch (mode)
@@ -86,31 +89,33 @@ void Canvas::setCursor (MouseMode mode)
 
         default:
           w->setCursor (origCursor);
           break;
         }
     }
 }
 
-void Canvas::print (const QString& file_cmd, const QString& term)
+void
+Canvas::print (const QString& file_cmd, const QString& term)
 {
   gh_manager::auto_lock lock;
   graphics_object obj = gh_manager::get_object (m_handle);
 
   if (obj.valid_object ())
     {
       graphics_object figObj (obj.get_ancestor ("figure"));
 
       gl2ps_print (figObj, file_cmd.toStdString (), term.toStdString ());
     }
 }
 
-void Canvas::updateCurrentPoint(const graphics_object& fig,
-                                const graphics_object& obj, QMouseEvent* event)
+void
+Canvas::updateCurrentPoint(const graphics_object& fig,
+                           const graphics_object& obj, QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
 
   gh_manager::post_set (fig.get_handle (), "currentpoint",
                         Utils::figureCurrentPoint (fig, event), false);
 
   Matrix children = obj.get_properties ().get_children ();
   octave_idx_type num_children = children.numel ();
@@ -136,17 +141,18 @@ void Canvas::updateCurrentPoint(const gr
           cp(1,0) = p2(0); cp(1,1) = p2(1); cp(1,2) = p2(2);
 
           gh_manager::post_set (childObj.get_handle (), "currentpoint", cp,
                                 false);
         }
     }
 }
 
-void Canvas::canvasToggleAxes (const graphics_handle& handle)
+void
+Canvas::canvasToggleAxes (const graphics_handle& handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go = gh_manager::get_object (handle);
 
   if (go.valid_object ())
     {
       figure::properties& fp = Utils::properties<figure> (go);
@@ -164,17 +170,18 @@ void Canvas::canvasToggleAxes (const gra
               ap.set_visible (! ap.is_visible ());
 
               redraw (true);
             }
         }
     }
 }
 
-void Canvas::canvasToggleGrid (const graphics_handle& handle)
+void
+Canvas::canvasToggleGrid (const graphics_handle& handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go = gh_manager::get_object (handle);
 
   if (go.valid_object ())
     {
       figure::properties& fp = Utils::properties<figure> (go);
@@ -214,17 +221,18 @@ autoscale_axes (axes::properties& ap)
 {
   ap.clear_zoom_stack ();
 
   ap.set_xlimmode ("auto");
   ap.set_ylimmode ("auto");
   ap.set_zlimmode ("auto");
 }
 
-void Canvas::canvasAutoAxes (const graphics_handle& handle)
+void
+Canvas::canvasAutoAxes (const graphics_handle& handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go = gh_manager::get_object (handle);
 
   if (go.valid_object ())
     {
       figure::properties& fp = Utils::properties<figure> (go);
@@ -242,17 +250,18 @@ void Canvas::canvasAutoAxes (const graph
               autoscale_axes (ap);
 
               redraw (true);
             }
         }
     }
 }
 
-void Canvas::canvasPaintEvent (void)
+void
+Canvas::canvasPaintEvent (void)
 {
   if (! m_redrawBlocked)
     {
       gh_manager::auto_lock lock;
 
       draw (m_handle);
 
       if (m_mouseMode == ZoomInMode && m_mouseAxes.ok ())
@@ -327,17 +336,18 @@ zoom_direction (const graphics_object fi
   octave_value ov_zm
     = Utils::properties<figure> (figObj).get___zoom_mode__ ();
 
   octave_scalar_map zm = ov_zm.scalar_map_value ();
 
   return zm.contents ("Direction").string_value ();
 }
 
-void Canvas::canvasMouseMoveEvent (QMouseEvent* event)
+void
+Canvas::canvasMouseMoveEvent (QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
   if (m_mouseMode != NoMode && ax.valid_object ())
     {
       axes::properties& ap = Utils::properties<axes> (ax);
 
@@ -396,17 +406,18 @@ void Canvas::canvasMouseMoveEvent (QMous
 
           updateCurrentPoint (figObj, obj, event);
           gh_manager::post_callback (figObj.get_handle (),
                                      "windowbuttonmotionfcn");
         }
     }
 }
 
-void Canvas::canvasMouseDoubleClickEvent (QMouseEvent* event)
+void
+Canvas::canvasMouseDoubleClickEvent (QMouseEvent* event)
 {
   if (event->buttons () != Qt::LeftButton)
     return;
 
   gh_manager::auto_lock lock;
   graphics_object obj = gh_manager::get_object (m_handle);
 
   if (obj.valid_object ())
@@ -480,17 +491,18 @@ button_number (QMouseEvent *event)
 
     default:
       break;
     }
 
   return retval;
 }
 
-void Canvas::canvasMousePressEvent (QMouseEvent* event)
+void
+Canvas::canvasMousePressEvent (QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object obj = gh_manager::get_object (m_handle);
 
   if (obj.valid_object ())
     {
       graphics_object figObj (obj.get_ancestor ("figure"));
       graphics_object currentObj, axesObj;
@@ -651,17 +663,18 @@ void Canvas::canvasMousePressEvent (QMou
           break;
 
         default:
           break;
         }
     }
 }
 
-void Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
+void
+Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
 {
   if ((m_mouseMode == ZoomInMode || m_mouseMode == ZoomOutMode)
       && m_mouseAxes.ok ())
     {
       gh_manager::auto_lock lock;
       graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
       if (ax.valid_object ())
@@ -717,17 +730,18 @@ void Canvas::canvasMouseReleaseEvent (QM
                                      "windowbuttonupfcn");
         }
     }
 
   m_mouseAxes = graphics_handle ();
   m_mouseMode = NoMode;
 }
 
-void Canvas::canvasWheelEvent (QWheelEvent* event)
+void
+Canvas::canvasWheelEvent (QWheelEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object obj = gh_manager::get_object (m_handle);
 
   if (obj.valid_object ())
     {
       std::string mode;
 
@@ -824,45 +838,48 @@ void Canvas::canvasWheelEvent (QWheelEve
             }
 
           if (redrawFigure)
             redraw (false);
         }
     }
 }
 
-bool Canvas::canvasKeyPressEvent (QKeyEvent* event)
+bool
+Canvas::canvasKeyPressEvent (QKeyEvent* event)
 {
   if (m_eventMask & KeyPress)
     {
       octave_scalar_map eventData = Utils::makeKeyEventStruct (event);
 
       gh_manager::post_set (m_handle, "currentcharacter",
                             eventData.getfield ("Character"), false);
       gh_manager::post_callback (m_handle, "keypressfcn", eventData);
 
       return true;
     }
 
   return false;
 }
 
-bool Canvas::canvasKeyReleaseEvent (QKeyEvent* event)
+bool
+Canvas::canvasKeyReleaseEvent (QKeyEvent* event)
 {
   if (! event->isAutoRepeat () && (m_eventMask & KeyRelease))
     {
       gh_manager::post_callback (m_handle, "keyreleasefcn",
                                  Utils::makeKeyEventStruct (event));
 
       return true;
     }
 
   return false;
 }
 
-Canvas* Canvas::create (const std::string& /* name */, QWidget* parent,
-                        const graphics_handle& handle)
+Canvas*
+Canvas::create (const std::string& /* name */, QWidget* parent,
+                const graphics_handle& handle)
 {
   // Only OpenGL
   return new GLCanvas (parent, handle);
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/CheckBoxControl.cc b/libgui/graphics/CheckBoxControl.cc
--- a/libgui/graphics/CheckBoxControl.cc
+++ b/libgui/graphics/CheckBoxControl.cc
@@ -27,17 +27,18 @@ along with Octave; see the file COPYING.
 #include <QCheckBox>
 
 #include "CheckBoxControl.h"
 #include "Container.h"
 
 namespace QtHandles
 {
 
-CheckBoxControl* CheckBoxControl::create (const graphics_object& go)
+CheckBoxControl*
+CheckBoxControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -42,17 +42,18 @@ Container::Container (QWidget* xparent)
 {
   setFocusPolicy (Qt::ClickFocus);
 }
 
 Container::~Container (void)
 {
 }
 
-Canvas* Container::canvas (const graphics_handle& gh, bool xcreate)
+Canvas*
+Container::canvas (const graphics_handle& gh, bool xcreate)
 {
   if (! m_canvas && xcreate)
     {
       gh_manager::auto_lock lock;
       graphics_object go = gh_manager::get_object (gh);
 
       if (go)
         {
@@ -67,17 +68,18 @@ Canvas* Container::canvas (const graphic
           canvasWidget->show ();
           canvasWidget->setGeometry (0, 0, width (), height ());
         }
     }
 
   return m_canvas;
 }
 
-void Container::resizeEvent (QResizeEvent* /* event */)
+void
+Container::resizeEvent (QResizeEvent* /* event */)
 {
   if (m_canvas)
     m_canvas->qWidget ()->setGeometry (0, 0, width (), height ());
 
   gh_manager::auto_lock lock;
 
   foreach (QObject* qObj, children ())
     {
@@ -92,17 +94,16 @@ void Container::resizeEvent (QResizeEven
               obj->qWidget<QWidget> ()
                 ->setGeometry (xround (bb(0)), xround (bb(1)),
                                xround (bb(2)), xround (bb(3)));
             }
         }
     }
 }
 
-void Container::childEvent (QChildEvent* xevent)
+void
+Container::childEvent (QChildEvent* xevent)
 {
   if (xevent->child ()->isWidgetType ())
-    {
-      qobject_cast<QWidget*> (xevent->child ())->setMouseTracking (hasMouseTracking ());
-    }
+    qobject_cast<QWidget*> (xevent->child ())->setMouseTracking (hasMouseTracking ());
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -28,17 +28,18 @@ along with Octave; see the file COPYING.
 
 #include "Backend.h"
 #include "ContextMenu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ContextMenu* ContextMenu::create (const graphics_object& go)
+ContextMenu*
+ContextMenu::create (const graphics_object& go)
 {
   Object* xparent = Object::parentObject (go);
 
   if (xparent)
     {
       QWidget* w = xparent->qWidget<QWidget> ();
 
       return new ContextMenu (go, new QMenu (w));
@@ -55,17 +56,18 @@ ContextMenu::ContextMenu (const graphics
   connect (xmenu, SIGNAL (aboutToShow (void)), SLOT (aboutToShow (void)));
   connect (xmenu, SIGNAL (aboutToHide (void)), SLOT (aboutToHide (void)));
 }
 
 ContextMenu::~ContextMenu (void)
 {
 }
 
-void ContextMenu::update (int pId)
+void
+ContextMenu::update (int pId)
 {
   uicontextmenu::properties& up = properties<uicontextmenu> ();
   QMenu* xmenu = qWidget<QMenu> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       if (up.is_visible ())
@@ -84,33 +86,37 @@ void ContextMenu::update (int pId)
         xmenu->hide ();
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
-void ContextMenu::aboutToShow (void)
+void
+ContextMenu::aboutToShow (void)
 {
   gh_manager::post_callback (m_handle, "callback");
   gh_manager::post_set (m_handle, "visible", "on", false);
 }
 
-void ContextMenu::aboutToHide (void)
+void
+ContextMenu::aboutToHide (void)
 {
   gh_manager::post_set (m_handle, "visible", "off", false);
 }
 
-QWidget* ContextMenu::menu (void)
+QWidget*
+ContextMenu::menu (void)
 {
   return qWidget<QWidget> ();
 }
 
-void ContextMenu::executeAt (const base_properties& props, const QPoint& pt)
+void
+ContextMenu::executeAt (const base_properties& props, const QPoint& pt)
 {
   graphics_handle h = props.get_uicontextmenu ();
 
   if (h.ok ())
     {
       gh_manager::auto_lock lock;
       graphics_object go = gh_manager::get_object (h);
 
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -29,17 +29,18 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 #include "EditControl.h"
 #include "TextEdit.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-EditControl* EditControl::create (const graphics_object& go)
+EditControl*
+EditControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
@@ -57,17 +58,18 @@ EditControl* EditControl::create (const 
 }
 
 EditControl::EditControl (const graphics_object& go, QLineEdit* edit)
      : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
 {
   init (edit);
 }
 
-void EditControl::init (QLineEdit* edit, bool callBase)
+void
+EditControl::init (QLineEdit* edit, bool callBase)
 {
   if (callBase)
     BaseControl::init (edit, callBase);
 
   m_multiLine = false;
   initCommon (edit);
 
   uicontrol::properties& up = properties<uicontrol> ();
@@ -78,22 +80,23 @@ void EditControl::init (QLineEdit* edit,
 
   connect (edit, SIGNAL (textEdited (const QString&)),
            SLOT (textChanged (void)));
   connect (edit, SIGNAL (editingFinished (void)),
            SLOT (editingFinished (void)));
 }
 
 EditControl::EditControl (const graphics_object& go, TextEdit* edit)
-     : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
+  : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
 {
   init (edit);
 }
 
-void EditControl::init (TextEdit* edit, bool callBase)
+void
+EditControl::init (TextEdit* edit, bool callBase)
 {
   if (callBase)
     BaseControl::init (edit, callBase);
 
   m_multiLine = true;
   initCommon (edit);
 
   uicontrol::properties& up = properties<uicontrol> ();
@@ -107,22 +110,24 @@ void EditControl::init (TextEdit* edit, 
   connect (edit, SIGNAL (editingFinished (void)),
            SLOT (editingFinished (void)));
 }
 
 EditControl::~EditControl (void)
 {
 }
 
-void EditControl::initCommon (QWidget*)
+void
+EditControl::initCommon (QWidget*)
 {
   m_textChanged = false;
 }
 
-void EditControl::update (int pId)
+void
+EditControl::update (int pId)
 {
   bool handled = false;
 
   if (m_multiLine)
     handled = updateMultiLine (pId);
   else
     handled = updateSingleLine (pId);
 
@@ -132,81 +137,90 @@ void EditControl::update (int pId)
         {
         default:
           BaseControl::update (pId);
           break;
         }
     }
 }
 
-bool EditControl::updateSingleLine (int pId)
+bool
+EditControl::updateSingleLine (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QLineEdit* edit = qWidget<QLineEdit> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       edit->setText (Utils::fromStdString (up.get_string_string ()));
       return true;
+
     case uicontrol::properties::ID_HORIZONTALALIGNMENT:
     case uicontrol::properties::ID_VERTICALALIGNMENT:
       edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
                                               up.get_verticalalignment ()));
       return true;
+
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) > 1)
         {
           QWidget* container = edit->parentWidget ();
 
           delete edit;
           init (new TextEdit (container), true);
         }
       return true;
+
     default:
       break;
     }
 
   return false;
 }
 
-bool EditControl::updateMultiLine (int pId)
+bool
+EditControl::updateMultiLine (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   TextEdit* edit = qWidget<TextEdit> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       edit->setPlainText (Utils::fromStdString (up.get_string_string ()));
       return true;
+
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) <= 1)
         {
           QWidget* container = edit->parentWidget ();
 
           delete edit;
           init (new QLineEdit (container), true);
         }
       return true;
+
     default:
       break;
     }
 
   return false;
 }
 
-void EditControl::textChanged (void)
+void
+EditControl::textChanged (void)
 {
   m_textChanged = true;
 }
 
-void EditControl::editingFinished (void)
+void
+EditControl::editingFinished (void)
 {
   if (m_textChanged)
     {
       QString txt = (m_multiLine
                      ? qWidget<TextEdit> ()->toPlainText ()
                      : qWidget<QLineEdit> ()->text ());
 
       gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -53,17 +53,18 @@ along with Octave; see the file COPYING.
 
 namespace QtHandles
 {
 
 #define ABOUT_TEXT "<b>QtHandles</b> - a Qt-based toolkit for <a href=\"http://www.octave.org\">Octave</a>.<br><br>Copyright (C) 2011-2014 Michael Goffioul"
 
 DECLARE_GENERICEVENTNOTIFY_SENDER(MenuBar, QMenuBar);
 
-static bool hasUiControlChildren (const figure::properties& fp)
+static bool
+hasUiControlChildren (const figure::properties& fp)
 {
   gh_manager::auto_lock lock;
 
   Matrix kids = fp.get_all_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go (gh_manager::get_object (kids(i)));
@@ -71,57 +72,59 @@ static bool hasUiControlChildren (const 
       if (go && (go.isa ("uicontrol") || go.isa ("uipanel")
                  || go.isa ("uibuttongroup")))
         return true;
     }
 
   return false;
 }
 
-static bool hasUiMenuChildren (const figure::properties& fp)
+static bool
+hasUiMenuChildren (const figure::properties& fp)
 {
   gh_manager::auto_lock lock;
 
   Matrix kids = fp.get_all_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go (gh_manager::get_object (kids(i)));
 
       if (go && go.isa ("uimenu"))
         return true;
     }
 
   return false;
 }
 
-static QRect boundingBoxToRect (const Matrix& bb)
+static QRect
+boundingBoxToRect (const Matrix& bb)
 {
   QRect r;
 
   if (bb.numel () == 4)
     {
       r = QRect (xround (bb(0)), xround (bb(1)),
                  xround (bb(2)), xround (bb(3)));
       if (! r.isValid ())
         r = QRect ();
     }
 
   return r;
 }
 
-Figure* Figure::create (const graphics_object& go)
+Figure*
+Figure::create (const graphics_object& go)
 {
   return new Figure (go, new FigureWindow ());
 }
 
 Figure::Figure (const graphics_object& go, FigureWindow* win)
-     : Object (go, win), m_blockUpdates (false), m_figureToolBar (0),
-       m_menuBar (0), m_innerRect (), m_outerRect (),
-       m_mouseModeGroup (0)
+  : Object (go, win), m_blockUpdates (false), m_figureToolBar (0),
+    m_menuBar (0), m_innerRect (), m_outerRect (), m_mouseModeGroup (0)
 {
   m_container = new Container (win);
   win->setCentralWidget (m_container);
 
   figure::properties& fp = properties<figure> ();
 
   createFigureToolBarAndMenuBar ();
 
@@ -168,17 +171,18 @@ Figure::Figure (const graphics_object& g
   win->addReceiver (this);
   m_container->addReceiver (this);
 }
 
 Figure::~Figure (void)
 {
 }
 
-static std::string mouse_mode_to_string (MouseMode mode)
+static std::string
+mouse_mode_to_string (MouseMode mode)
 {
   switch (mode)
     {
     case NoMode:
       return "none";
 
     case RotateMode:
       return "rotate";
@@ -200,17 +204,18 @@ static std::string mouse_mode_to_string 
 
     default:
       break;
     }
 
   return "none";
 }
 
-static MouseMode mouse_mode_from_string (const std::string& mode)
+static MouseMode
+mouse_mode_from_string (const std::string& mode)
 {
   if (mode == "none")
     return NoMode;
   else if (mode == "rotate")
     return RotateMode;
   else if (mode == "zoom in")
     return ZoomInMode;
   else if (mode == "zoom out")
@@ -220,37 +225,40 @@ static MouseMode mouse_mode_from_string 
   else if (mode == "text")
     return TextMode;
   else if (mode == "select")
     return SelectMode;
   else
     return NoMode;
 }
 
-QString Figure::fileName (void)
+QString
+Figure::fileName (void)
 {
   gh_manager::auto_lock lock;
 
   const figure::properties& fp = properties<figure> ();
 
   std::string name = fp.get_filename ();
 
   return QString::fromStdString (name);
 }
 
-void Figure::setFileName (const QString& name)
+void
+Figure::setFileName (const QString& name)
 {
   gh_manager::auto_lock lock;
 
   figure::properties& fp = properties<figure> ();
 
   fp.set_filename (name.toStdString ());
 }
 
-MouseMode Figure::mouseMode (void)
+MouseMode
+Figure::mouseMode (void)
 {
   gh_manager::auto_lock lock;
 
   const figure::properties& fp = properties<figure> ();
 
   std::string mode = fp.get___mouse_mode__ ();
 
   if (mode == "zoom")
@@ -260,17 +268,18 @@ MouseMode Figure::mouseMode (void)
       std::string direction = zm.getfield ("Direction").string_value ();
 
       mode += " " + direction;
     }    
 
   return mouse_mode_from_string (mode);
 }
 
-void Figure::createFigureToolBarAndMenuBar (void)
+void
+Figure::createFigureToolBarAndMenuBar (void)
 {
   QMainWindow* win = qWidget<QMainWindow> ();
 
   m_figureToolBar = win->addToolBar (tr ("Figure ToolBar"));
   m_figureToolBar->setMovable (false);
   m_figureToolBar->setFloatable (false);
 
   m_mouseModeGroup = new MouseModeActionGroup (win);
@@ -316,32 +325,35 @@ void Figure::createFigureToolBarAndMenuB
   helpMenu->menuAction ()->setObjectName ("builtinMenu");
   helpMenu->addAction (tr ("&About QtHandles"), this,
                        SLOT (helpAboutQtHandles (void)));
   helpMenu->addAction (tr ("About &Qt"), qApp, SLOT (aboutQt (void)));
 
   m_menuBar->addReceiver (this);
 }
 
-void Figure::updateFigureToolBarAndMenuBar (void)
+void
+Figure::updateFigureToolBarAndMenuBar (void)
 {
   if (m_mouseModeGroup)
     {
       m_blockUpdates = true;
       m_mouseModeGroup->setMode (mouseMode ());
       m_blockUpdates = false;
     }
 }
 
-Container* Figure::innerContainer (void)
+Container*
+Figure::innerContainer (void)
 {
   return m_container;
 }
 
-void Figure::redraw (void)
+void
+Figure::redraw (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     {
     canvas->redraw ();
     //canvas->setMouseMode (RotateMode);
     }
@@ -353,37 +365,40 @@ void Figure::redraw (void)
 
       if (obj)
         obj->slotRedraw ();
     }
 
   updateFigureToolBarAndMenuBar ();
 }
 
-void Figure::print (const QString& file_cmd, const QString& term)
+void
+Figure::print (const QString& file_cmd, const QString& term)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->print (file_cmd, term);
 }
 
-void Figure::beingDeleted (void)
+void
+Figure::beingDeleted (void)
 {
   Canvas* canvas = m_container->canvas (m_handle.value (), false);
 
   if (canvas)
     canvas->blockRedraw (true);
 
   m_menuBar->removeReceiver (this);
   m_container->removeReceiver (this);
   qWidget<FigureWindow> ()->removeReceiver (this);
 }
 
-void Figure::update (int pId)
+void
+Figure::update (int pId)
 {
   if (m_blockUpdates)
     return;
 
   figure::properties& fp = properties<figure> ();
   QMainWindow* win = qWidget<QMainWindow> ();
 
   m_blockUpdates = true;
@@ -401,66 +416,75 @@ void Figure::update (int pId)
               offset += tb->sizeHint ().height ();
           if (! m_menuBar->isHidden ())
             offset += m_menuBar->sizeHint ().height () + 1;
           //qDebug () << "Figure::update(position)(adjusted):" << m_innerRect.adjusted (0, -offset, 0, 0);
           win->setGeometry (m_innerRect.adjusted (0, -offset, 0, 0));
           //qDebug () << "Figure::update(position): done";
         }
       break;
+
     case figure::properties::ID_NAME:
     case figure::properties::ID_NUMBERTITLE:
       win->setWindowTitle (Utils::fromStdString (fp.get_title ()));
       break;
+
     case figure::properties::ID_VISIBLE:
       if (fp.is_visible ())
         QTimer::singleShot (0, win, SLOT (show ()));
       else
         win->hide ();
       break;
+
     case figure::properties::ID_TOOLBAR:
       if (fp.toolbar_is ("none"))
         showFigureToolBar (false);
       else if (fp.toolbar_is ("figure"))
         showFigureToolBar (true);
       else // "auto"
         showFigureToolBar (! hasUiControlChildren (fp));
       break;
+
     case figure::properties::ID_MENUBAR:
       showMenuBar (fp.menubar_is ("figure"));
       break;
+
     case figure::properties::ID_KEYPRESSFCN:
       if (fp.get_keypressfcn ().is_empty ())
         m_container->canvas (m_handle)->clearEventMask (Canvas::KeyPress);
       else
         m_container->canvas (m_handle)->addEventMask (Canvas::KeyPress);
       break;
+
     case figure::properties::ID_KEYRELEASEFCN:
       if (fp.get_keyreleasefcn ().is_empty ())
         m_container->canvas (m_handle)->clearEventMask (Canvas::KeyRelease);
       else
         m_container->canvas (m_handle)->addEventMask (Canvas::KeyRelease);
       break;
+
     case figure::properties::ID_WINDOWBUTTONMOTIONFCN:
         {
           bool hasCallback = ! fp.get_windowbuttonmotionfcn ().is_empty ();
 
           m_container->setMouseTracking (hasCallback);
           foreach (QWidget* w, m_container->findChildren<QWidget*> ())
             { w->setMouseTracking (hasCallback); }
         }
       break;
+
     default:
       break;
     }
 
   m_blockUpdates = false;
 }
 
-void Figure::showFigureToolBar (bool visible)
+void
+Figure::showFigureToolBar (bool visible)
 {
   if ((! m_figureToolBar->isHidden ()) != visible)
     {
       int dy = m_figureToolBar->sizeHint ().height ();
       QRect r = qWidget<QWidget> ()->geometry ();
 
       if (! visible)
         r.adjust (0, dy, 0, 0);
@@ -471,17 +495,18 @@ void Figure::showFigureToolBar (bool vis
       qWidget<QWidget> ()->setGeometry (r);
       m_figureToolBar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
     }
 }
 
-void Figure::showMenuBar (bool visible)
+void
+Figure::showMenuBar (bool visible)
 {
   int h1 = m_menuBar->sizeHint ().height ();
 
   foreach (QAction* a, m_menuBar->actions ())
     if (a->objectName () == "builtinMenu")
       a->setVisible (visible);
 
   int h2 = m_menuBar->sizeHint ().height ();
@@ -505,74 +530,75 @@ void Figure::showMenuBar (bool visible)
       qWidget<QWidget> ()->setGeometry (r);
       m_menuBar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
     }
 }
 
-void Figure::updateMenuBar (void)
+void
+Figure::updateMenuBar (void)
 {
   gh_manager::auto_lock lock;
   graphics_object go = object ();
 
   if (go.valid_object ())
     showMenuBar (Utils::properties<figure> (go).menubar_is ("figure"));
 }
 
-QWidget* Figure::menu (void)
+QWidget*
+Figure::menu (void)
 {
   return qWidget<QMainWindow> ()->menuBar ();
 }
 
 struct UpdateBoundingBoxData
 {
   Matrix m_bbox;
   bool m_internal;
   graphics_handle m_handle;
   Figure* m_figure;
 };
 
-void Figure::updateBoundingBoxHelper (void* data)
+void
+Figure::updateBoundingBoxHelper (void* data)
 {
   gh_manager::auto_lock lock;
 
   UpdateBoundingBoxData* d = reinterpret_cast<UpdateBoundingBoxData*> (data);
   graphics_object go = gh_manager::get_object (d->m_handle);
 
   if (go.valid_object ())
     {
       figure::properties& fp = Utils::properties<figure> (go);
 
-      //qDebug ("Figure::updateBoundingBoxHelper: internal=%d, bbox=[%g %g %g %g]",
-      //        d->m_internal, d->m_bbox(0), d->m_bbox(1), d->m_bbox(2), d->m_bbox(3));
       fp.set_boundingbox (d->m_bbox, d->m_internal, false);
     }
 
   delete d;
 }
 
-void Figure::updateBoundingBox (bool internal, int flags)
+void
+Figure::updateBoundingBox (bool internal, int flags)
 {
   QWidget* win = qWidget<QWidget> ();
   Matrix bb (1, 4);
 
   if (internal)
     {
       QRect r = m_innerRect;
 
       if (flags & UpdateBoundingBoxPosition)
         r.moveTopLeft (win->mapToGlobal (m_container->pos ()));
       if (flags & UpdateBoundingBoxSize)
         r.setSize (m_container->size ());
 
       if (r.isValid () && r != m_innerRect)
         {
-          //qDebug() << "inner rect changed:" << m_innerRect << "->>" << r;
           m_innerRect = r;
 
           bb(0) = r.x ();
           bb(1) = r.y ();
           bb(2) = r.width ();
           bb(3) = r.height ();
         }
       else
@@ -584,17 +610,16 @@ void Figure::updateBoundingBox (bool int
 
       if (flags & UpdateBoundingBoxPosition)
         r.moveTopLeft (win->pos ());
       if (flags & UpdateBoundingBoxSize)
         r.setSize (win->frameGeometry ().size ());
 
       if (r.isValid () && r != m_outerRect)
         {
-          //qDebug() << "outer rect changed:" << m_outerRect << "->>" << r;
           m_outerRect = r;
 
           bb(0) = r.x ();
           bb(1) = r.y ();
           bb(2) = r.width ();
           bb(3) = r.height ();
         }
       else
@@ -603,83 +628,87 @@ void Figure::updateBoundingBox (bool int
 
   UpdateBoundingBoxData* d = new UpdateBoundingBoxData ();
 
   d->m_bbox = bb;
   d->m_internal = internal;
   d->m_handle = m_handle;
   d->m_figure = this;
 
-  //qDebug ("Figure::updateBoundingBox: internal=%d, bbox=[%g %g %g %g]",
-  //        d->m_internal, d->m_bbox(0), d->m_bbox(1), d->m_bbox(2), d->m_bbox(3));
   gh_manager::post_function (Figure::updateBoundingBoxHelper, d);
 }
 
-bool Figure::eventNotifyBefore (QObject* obj, QEvent* xevent)
+bool
+Figure::eventNotifyBefore (QObject* obj, QEvent* xevent)
 {
   if (! m_blockUpdates)
     {
       if (obj == m_container)
         {
           // Do nothing...
         }
       else if (obj == m_menuBar)
         {
           switch (xevent->type ())
             {
             case QEvent::ActionRemoved:
-                {
-                  QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
+              {
+                QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
 
-                  if (! a->isSeparator ()
-                      && a->objectName () != "builtinMenu")
-                    updateMenuBar ();
-                }
+                if (! a->isSeparator ()
+                    && a->objectName () != "builtinMenu")
+                  updateMenuBar ();
+              }
               break;
+
             default:
               break;
             }
         }
       else
         {
           switch (xevent->type ())
             {
             case QEvent::Close:
               xevent->ignore ();
               gh_manager::post_callback (m_handle, "closerequestfcn");
               return true;
+
             default:
               break;
             }
         }
     }
 
   return false;
 }
 
-void Figure::eventNotifyAfter (QObject* watched, QEvent* xevent)
+void
+Figure::eventNotifyAfter (QObject* watched, QEvent* xevent)
 {
   if (! m_blockUpdates)
     {
       if (watched == m_container)
         {
           switch (xevent->type ())
             {
             case QEvent::Resize:
               updateBoundingBox (true, UpdateBoundingBoxSize);
               break;
+
             case QEvent::ChildAdded:
               if (dynamic_cast<QChildEvent*> (xevent)->child
                   ()->isWidgetType())
                 {
                   gh_manager::auto_lock lock;
                   const figure::properties& fp = properties<figure> ();
 
                   showFigureToolBar (! hasUiControlChildren (fp));
                 }
+
             default:
               break;
             }
         }
       else if (watched == m_menuBar)
         {
           switch (xevent->type ())
             {
@@ -687,62 +716,68 @@ void Figure::eventNotifyAfter (QObject* 
                 {
                   QAction* a = dynamic_cast<QActionEvent*> (xevent)->action ();
 
                   if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu")
                     updateMenuBar ();
                 }
               break;
+
             default:
               break;
             }
         }
       else
         {
           switch (xevent->type ())
             {
             case QEvent::Move:
               updateBoundingBox (false, UpdateBoundingBoxPosition);
               updateBoundingBox (true, UpdateBoundingBoxPosition);
               break;
+
             case QEvent::Resize:
               updateBoundingBox (false, UpdateBoundingBoxSize);
               break;
+
             default:
               break;
             }
         }
     }
 }
 
-void Figure::helpAboutQtHandles (void)
+void
+Figure::helpAboutQtHandles (void)
 {
   QMessageBox::about (qWidget<QMainWindow> (), tr ("About QtHandles"),
                       ABOUT_TEXT);
 }
 
-void Figure::setMouseMode (MouseMode mode)
+void
+Figure::setMouseMode (MouseMode mode)
 {
   if (m_blockUpdates)
     return;
 
   gh_manager::auto_lock lock;
 
   figure::properties& fp = properties<figure> ();
 
   fp.set___mouse_mode__ (mouse_mode_to_string (mode));
 
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->setCursor (mode);
 }
 
-void Figure::fileSaveFigure (bool prompt)
+void
+Figure::fileSaveFigure (bool prompt)
 {
   QString file = fileName ();
 
   if (file.isEmpty ())
     {
       prompt = true;
 
       file = "untitled.pdf";
@@ -764,44 +799,51 @@ void Figure::fileSaveFigure (bool prompt
 
       setFileName (finfo.absoluteFilePath ());
 
       octave_link::post_event (this, &Figure::save_figure_callback,
                                file.toStdString ());
     }
 }
 
-void Figure::save_figure_callback (const std::string& file)
+void
+Figure::save_figure_callback (const std::string& file)
 {
   Ffeval (ovl ("print", file));
 }
   
-void Figure::fileSaveFigureAs (void)
+void
+Figure::fileSaveFigureAs (void)
 {
   fileSaveFigure (true);
 }
 
-void Figure::fileCloseFigure (void)
+void
+Figure::fileCloseFigure (void)
 {
   qWidget<QMainWindow> ()->close ();
 }
 
-void Figure::editCopy (void)
+void
+Figure::editCopy (void)
 {
 }
 
-void Figure::editCut (void)
+void
+Figure::editCut (void)
 {
 }
 
-void Figure::editPaste (void)
+void
+Figure::editPaste (void)
 {
 }
 
-void Figure::addCustomToolBar (QToolBar* bar, bool visible)
+void
+Figure::addCustomToolBar (QToolBar* bar, bool visible)
 {
   QMainWindow* win = qWidget<QMainWindow> ();
 
   if (! visible)
     win->addToolBar (bar);
   else
     {
       QSize sz = bar->sizeHint ();
@@ -816,17 +858,18 @@ void Figure::addCustomToolBar (QToolBar*
       win->addToolBar (bar);
       m_blockUpdates = false;
 
       //qDebug () << "Figure::addCustomToolBar:" << win->geometry ();
       updateBoundingBox (false);
     }
 }
 
-void Figure::showCustomToolBar (QToolBar* bar, bool visible)
+void
+Figure::showCustomToolBar (QToolBar* bar, bool visible)
 {
   QMainWindow* win = qWidget<QMainWindow> ();
 
   if ((! bar->isHidden ()) != visible)
     {
       QSize sz = bar->sizeHint ();
       QRect r = win->geometry ();
 
@@ -839,38 +882,42 @@ void Figure::showCustomToolBar (QToolBar
       win->setGeometry (r);
       bar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
     }
 }
 
-void Figure::updateContainer (void)
+void
+Figure::updateContainer (void)
 {
   redraw ();
 }
 
-void Figure::toggleAxes (void)
+void
+Figure::toggleAxes (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->toggleAxes (m_handle);
 }
   
-void Figure::toggleGrid (void)
+void
+Figure::toggleGrid (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->toggleGrid (m_handle);
 }
   
-void Figure::autoAxes (void)
+void
+Figure::autoAxes (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->autoAxes (m_handle);
 }
   
 }; // namespace QtHandles
diff --git a/libgui/graphics/FigureWindow.cc b/libgui/graphics/FigureWindow.cc
--- a/libgui/graphics/FigureWindow.cc
+++ b/libgui/graphics/FigureWindow.cc
@@ -37,15 +37,16 @@ FigureWindow::FigureWindow (QWidget* xpa
   // set icon from application resources
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
 }
 
 FigureWindow::~FigureWindow (void)
 {
 }
 
-QMenu* FigureWindow::createPopupMenu (void)
+QMenu*
+FigureWindow::createPopupMenu (void)
 {
   // For the time being, disable menubar/toolbar popup menu
   return 0;
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/GLCanvas.cc b/libgui/graphics/GLCanvas.cc
--- a/libgui/graphics/GLCanvas.cc
+++ b/libgui/graphics/GLCanvas.cc
@@ -42,71 +42,77 @@ GLCanvas::GLCanvas (QWidget* xparent, co
 {
   setFocusPolicy (Qt::ClickFocus);
 }
 
 GLCanvas::~GLCanvas (void)
 {
 }
 
-void GLCanvas::draw (const graphics_handle& gh)
+void
+GLCanvas::draw (const graphics_handle& gh)
 {
   gh_manager::auto_lock lock;
   graphics_object go = gh_manager::get_object (gh);
 
   if (go)
     {
       opengl_renderer r;
 
       r.set_viewport (width (), height ());
       r.draw(go);
     }
 }
 
-void GLCanvas::toggleAxes (const graphics_handle& gh)
+void
+GLCanvas::toggleAxes (const graphics_handle& gh)
 {
   canvasToggleAxes (gh);
 }
 
-void GLCanvas::toggleGrid (const graphics_handle& gh)
+void
+GLCanvas::toggleGrid (const graphics_handle& gh)
 {
   canvasToggleGrid (gh);
 }
 
-void GLCanvas::autoAxes (const graphics_handle& gh)
+void
+GLCanvas::autoAxes (const graphics_handle& gh)
 {
   canvasAutoAxes (gh);
 }
 
-graphics_object GLCanvas::selectFromAxes (const graphics_object& ax,
-                                          const QPoint& pt)
+graphics_object
+GLCanvas::selectFromAxes (const graphics_object& ax, const QPoint& pt)
 {
   makeCurrent ();
 
   if (ax)
     {
       opengl_selector s;
 
       s.set_viewport (width (), height ());
       return s.select (ax, pt.x (), height () - pt.y ());
     }
 
   return graphics_object ();
 }
 
-inline void glDrawZoomBox (const QPoint& p1, const QPoint& p2)
+inline void
+glDrawZoomBox (const QPoint& p1, const QPoint& p2)
 {
   glVertex2d (p1.x (), p1.y ());
   glVertex2d (p2.x (), p1.y ());
   glVertex2d (p2.x (), p2.y ());
   glVertex2d (p1.x (), p2.y ());
   glVertex2d (p1.x (), p1.y ());
 }
 
-void GLCanvas::drawZoomBox (const QPoint& p1, const QPoint& p2)
+void
+GLCanvas::drawZoomBox (const QPoint& p1, const QPoint& p2)
 {
   glPushMatrix ();
 
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
@@ -125,51 +131,59 @@ void GLCanvas::drawZoomBox (const QPoint
   glColor4f (0.45, 0.62, 0.81, 0.9);
   glDrawZoomBox (p1, p2);
   glEnd ();
 
   glPopAttrib ();
   glPopMatrix ();
 }
 
-void GLCanvas::paintGL (void)
+void
+GLCanvas::paintGL (void)
 {
   canvasPaintEvent ();
 }
 
-void GLCanvas::mouseDoubleClickEvent (QMouseEvent* xevent)
+void
+GLCanvas::mouseDoubleClickEvent (QMouseEvent* xevent)
 {
   canvasMouseDoubleClickEvent (xevent);
 }
 
-void GLCanvas::mouseMoveEvent (QMouseEvent* xevent)
+void
+GLCanvas::mouseMoveEvent (QMouseEvent* xevent)
 {
   canvasMouseMoveEvent (xevent);
 }
 
-void GLCanvas::mousePressEvent (QMouseEvent* xevent)
+void
+GLCanvas::mousePressEvent (QMouseEvent* xevent)
 {
   canvasMousePressEvent (xevent);
 }
 
-void GLCanvas::mouseReleaseEvent (QMouseEvent* xevent)
+void
+GLCanvas::mouseReleaseEvent (QMouseEvent* xevent)
 {
   canvasMouseReleaseEvent (xevent);
 }
 
-void GLCanvas::wheelEvent (QWheelEvent* xevent)
+void
+GLCanvas::wheelEvent (QWheelEvent* xevent)
 {
   canvasWheelEvent (xevent);
 }
 
-void GLCanvas::keyPressEvent (QKeyEvent* xevent)
+void
+GLCanvas::keyPressEvent (QKeyEvent* xevent)
 {
   if (! canvasKeyPressEvent (xevent))
     QGLWidget::keyPressEvent (xevent);
 }
 
-void GLCanvas::keyReleaseEvent (QKeyEvent* xevent)
+void
+GLCanvas::keyReleaseEvent (QKeyEvent* xevent)
 {
   if (! canvasKeyReleaseEvent (xevent))
     QGLWidget::keyReleaseEvent (xevent);
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/KeyMap.cc b/libgui/graphics/KeyMap.cc
--- a/libgui/graphics/KeyMap.cc
+++ b/libgui/graphics/KeyMap.cc
@@ -30,17 +30,18 @@ along with Octave; see the file COPYING.
 #include "KeyMap.h"
 
 namespace QtHandles
 {
 
 namespace KeyMap
 {
 
-std::string qKeyToKeyString (int key)
+std::string
+qKeyToKeyString (int key)
 {
   static QMap<int, std::string> keyMapper;
 
   if (keyMapper.isEmpty ())
     {
       keyMapper[Qt::Key_Escape] = "escape";
       keyMapper[Qt::Key_Tab] = "tab";
       keyMapper[Qt::Key_Backtab] = "backtab";
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -28,17 +28,18 @@ along with Octave; see the file COPYING.
 
 #include "Container.h"
 #include "ListBoxControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static void updateSelection (QListWidget* list, const Matrix& value)
+static void
+updateSelection (QListWidget* list, const Matrix& value)
 {
   octave_idx_type n = value.numel ();
   int lc = list->count ();
 
   list->clearSelection ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
@@ -55,33 +56,34 @@ static void updateSelection (QListWidget
         {
           // Invalid selection.
           list->clearSelection ();
           break;
         }
     }
 }
 
-ListBoxControl* ListBoxControl::create (const graphics_object& go)
+ListBoxControl*
+ListBoxControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new ListBoxControl (go, new QListWidget (container));
     }
 
   return 0;
 }
 
 ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget* list)
-     : BaseControl (go, list), m_blockCallback (false)
+  : BaseControl (go, list), m_blockCallback (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   list->addItems (Utils::fromStringVector (up.get_string_vector ()));
   if ((up.get_max () - up.get_min ()) > 1)
     list->setSelectionMode (QAbstractItemView::ExtendedSelection);
   else
     list->setSelectionMode (QAbstractItemView::SingleSelection);
@@ -111,49 +113,55 @@ ListBoxControl::ListBoxControl (const gr
   connect (list, SIGNAL (itemSelectionChanged (void)),
            SLOT (itemSelectionChanged (void)));
 }
 
 ListBoxControl::~ListBoxControl (void)
 {
 }
 
-void ListBoxControl::update (int pId)
+void
+ListBoxControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QListWidget* list = qWidget<QListWidget> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       m_blockCallback = true;
       list->clear ();
       list->addItems (Utils::fromStringVector (up.get_string_vector ()));
       updateSelection (list, up.get_value ().matrix_value ());
       m_blockCallback = false;
       break;
+
     case uicontrol::properties::ID_MIN:
+
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) > 1)
         list->setSelectionMode (QAbstractItemView::ExtendedSelection);
       else
         list->setSelectionMode (QAbstractItemView::SingleSelection);
       break;
+
     case uicontrol::properties::ID_VALUE:
       m_blockCallback = true;
       updateSelection (list, up.get_value ().matrix_value ());
       m_blockCallback = false;
       break;
+
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
-void ListBoxControl::itemSelectionChanged (void)
+void
+ListBoxControl::itemSelectionChanged (void)
 {
   if (! m_blockCallback)
     {
       QListWidget* list = qWidget<QListWidget> ();
 
       QModelIndexList l = list->selectionModel ()->selectedIndexes ();
       Matrix value (dim_vector (1, l.size ()));
       int i = 0;
diff --git a/libgui/graphics/Logger.cc b/libgui/graphics/Logger.cc
--- a/libgui/graphics/Logger.cc
+++ b/libgui/graphics/Logger.cc
@@ -34,52 +34,54 @@ along with Octave; see the file COPYING.
 
 namespace QtHandles
 {
 
 Logger* Logger::s_instance = 0;
 QMutex* Logger::s_mutex = 0;
 
 Logger::Logger (void)
-    : m_debugEnabled (false)
+  : m_debugEnabled (false)
 {
   QProcessEnvironment pe (QProcessEnvironment::systemEnvironment ());
 
   if (pe.value ("QTHANDLES_DEBUG", "0") != "0")
     m_debugEnabled = true;
 }
 
 Logger::~Logger (void)
 {
 }
 
-Logger* Logger::instance (void)
+Logger*
+Logger::instance (void)
 {
   if (! s_instance)
     {
       s_instance = new Logger ();
       s_mutex = new QMutex ();
     }
 
   return s_instance;
 }
 
 #define STATIC_LOGGER(fun) \
-void Logger::fun (const char* fmt, ...) \
-{ \
-  QMutexLocker lock (s_mutex); \
-  va_list vl; \
-  va_start (vl, fmt); \
-  instance ()->fun ## V (fmt, vl); \
-  va_end (vl); \
-}
+  void Logger::fun (const char* fmt, ...) \
+  { \
+    QMutexLocker lock (s_mutex); \
+    va_list vl; \
+    va_start (vl, fmt); \
+    instance ()->fun ## V (fmt, vl); \
+    va_end (vl); \
+  }
 
 STATIC_LOGGER (debug)
 
-void Logger::debugV (const char* fmt, va_list arg)
+void
+Logger::debugV (const char* fmt, va_list arg)
 {
   if (m_debugEnabled)
     {
       vfprintf (stderr, fmt, arg);
       fprintf (stderr, "\n");
     }
 }
 
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -31,17 +31,18 @@ along with Octave; see the file COPYING.
 
 #include "Figure.h"
 #include "Menu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static QKeySequence accelSequence (const uimenu::properties& up)
+static QKeySequence
+accelSequence (const uimenu::properties& up)
 {
   std::string s (up.get_accelerator ());
 
   if (! s.empty ())
     {
       char c = s[0];
       int keyMod = Qt::CTRL;
 
@@ -51,45 +52,49 @@ static QKeySequence accelSequence (const
         c -= ('a' - 'A');
       if (c >= 'A' && c <= 'Z')
         return QKeySequence (keyMod | static_cast<int> (c));
     }
 
   return QKeySequence ();
 }
 
-Menu* Menu::create (const graphics_object& go)
+Menu*
+Menu::create (const graphics_object& go)
 {
   Object* parent_obj = Object::parentObject (go);
 
   if (parent_obj)
     {
       QObject* qObj = parent_obj->qObject ();
 
       if (qObj)
         return new Menu (go, new QAction (qObj), parent_obj);
     }
 
   return 0;
 }
 
 Menu::Menu (const graphics_object& go, QAction* action, Object* xparent)
-    : Object (go, action), m_parent (0), m_separator (0)
+  : Object (go, action), m_parent (0), m_separator (0)
 {
   uimenu::properties& up = properties<uimenu> ();
 
   action->setText (Utils::fromStdString (up.get_label ()));
+
   if (up.is_checked ())
     {
       action->setCheckable (true);
       action->setChecked (up.is_checked ());
     }
+
   action->setEnabled (up.is_enable ());
   action->setShortcut (accelSequence (up));
   action->setVisible (up.is_visible ());
+
   if (up.is_separator ())
     {
       m_separator = new QAction (action);
       m_separator->setSeparator (true);
       m_separator->setVisible (up.is_visible ());
     }
 
   MenuContainer* menuContainer = dynamic_cast<MenuContainer*> (xparent);
@@ -146,45 +151,50 @@ Menu::Menu (const graphics_object& go, Q
 
   connect (action, SIGNAL (triggered (bool)), SLOT (actionTriggered (void)));
 }
 
 Menu::~Menu (void)
 {
 }
 
-void Menu::update (int pId)
+void
+Menu::update (int pId)
 {
   uimenu::properties& up = properties<uimenu> ();
   QAction* action = qWidget<QAction> ();
 
   switch (pId)
     {
     case uimenu::properties::ID_LABEL:
       action->setText (Utils::fromStdString (up.get_label ()));
       break;
+
     case uimenu::properties::ID_CHECKED:
       if (up.is_checked ())
         {
           action->setCheckable (true);
           action->setChecked (up.is_checked ());
         }
       else
         {
           action->setChecked (false);
           action->setCheckable (false);
         }
       break;
+
     case uimenu::properties::ID_ENABLE:
       action->setEnabled (up.is_enable ());
       break;
+
     case uimenu::properties::ID_ACCELERATOR:
       if (! action->menu ())
         action->setShortcut (accelSequence (up));
       break;
+
     case uimenu::properties::ID_SEPARATOR:
       if (up.is_separator ())
         {
           if (! m_separator)
             {
               m_separator = new QAction (action);
               m_separator->setSeparator (true);
               m_separator->setVisible (up.is_visible ());
@@ -194,89 +204,100 @@ void Menu::update (int pId)
         }
       else
         {
           if (m_separator)
             delete m_separator;
           m_separator = 0;
         }
       break;
+
     case uimenu::properties::ID_VISIBLE:
       action->setVisible (up.is_visible ());
       if (m_separator)
         m_separator->setVisible (up.is_visible ());
       break;
+
     case uimenu::properties::ID_POSITION:
-      if (m_separator)
-        m_parent->removeAction (m_separator);
-      m_parent->removeAction (action);
-        {
-          int pos = static_cast<int> (up.get_position ());
-          QAction* before = 0;
+      {
+        if (m_separator)
+          m_parent->removeAction (m_separator);
+
+        m_parent->removeAction (action);
 
-          if (pos > 0)
-            {
-              int count = 0;
+        int pos = static_cast<int> (up.get_position ());
+        QAction* before = 0;
+
+        if (pos > 0)
+          {
+            int count = 0;
 
-              foreach (QAction* a, m_parent->actions ())
-                if (! a->isSeparator () && a->objectName () != "builtinMenu")
-                  {
-                    count++;
-                    if (pos <= count)
-                      {
-                        before = a;
-                        break;
-                      }
-                  }
-            }
+            foreach (QAction* a, m_parent->actions ())
+              if (! a->isSeparator () && a->objectName () != "builtinMenu")
+                {
+                  count++;
+                  if (pos <= count)
+                    {
+                      before = a;
+                      break;
+                    }
+                }
+          }
 
-          if (m_separator)
-            m_parent->insertAction (before, m_separator);
-          m_parent->insertAction (before, action);
-          updateSiblingPositions ();
-        }
+        if (m_separator)
+          m_parent->insertAction (before, m_separator);
+
+        m_parent->insertAction (before, action);
+
+        updateSiblingPositions ();
+      }
       break;
+
     default:
       Object::update (pId);
       break;
     }
 }
 
-QWidget* Menu::menu (void)
+QWidget*
+Menu::menu (void)
 {
   QAction* action = qWidget<QAction> ();
   QMenu* _menu = action->menu ();
 
   if (! _menu)
     {
       _menu = new QMenu (action->parentWidget ());
       action->setMenu (_menu);
       action->setShortcut (QKeySequence ());
       connect (_menu, SIGNAL (aboutToShow (void)),
                this, SLOT (actionHovered (void)));
     }
 
   return _menu;
 }
 
-void Menu::actionTriggered (void)
+void
+Menu::actionTriggered (void)
 {
   QAction* action = qWidget<QAction> ();
 
   if (action->isCheckable ())
     action->setChecked (! action->isChecked ());
   gh_manager::post_callback (m_handle, "callback");
 }
 
-void Menu::actionHovered (void)
+void
+Menu::actionHovered (void)
 {
   gh_manager::post_callback (m_handle, "callback");
 }
 
-void Menu::updateSiblingPositions (void)
+void
+Menu::updateSiblingPositions (void)
 {
   if (m_parent)
     {
       double count = 1.0;
 
       foreach (QAction* a, m_parent->actions ())
         {
           if (! a->isSeparator () && a->objectName () != "builtinMenu")
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -62,17 +62,18 @@ MouseModeActionGroup::MouseModeActionGro
       connect (a, SIGNAL (toggled (bool)), this, SLOT (actionToggled (bool)));
     }
 }
 
 MouseModeActionGroup::~MouseModeActionGroup (void)
 {
 }
 
-void MouseModeActionGroup::actionToggled (bool checked)
+void
+MouseModeActionGroup::actionToggled (bool checked)
 {
   if (! checked)
     {
       if (sender () == m_current)
         {
           m_current = 0;
           emit modeChanged (NoMode);
         }
@@ -87,15 +88,16 @@ void MouseModeActionGroup::actionToggled
           for (int j = 0; j < m_actions.size (); j++)
             if (j != i)
               m_actions[j]->setChecked (false);
           emit modeChanged (static_cast<MouseMode> (i+1));
         }
     }
 }
 
-void MouseModeActionGroup::setMode (MouseMode mode)
+void
+MouseModeActionGroup::setMode (MouseMode mode)
 {
   for (int i = 0; i < m_actions.size (); i++)
     m_actions[i]->setChecked (i == mode - 1);
 }
   
 };
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -42,17 +42,18 @@ Object::Object (const graphics_object& g
   if (! lock)
     qCritical ("QtHandles::Object::Object: "
                "creating Object (h=%g) without a valid lock!!!",
                m_handle.value ());
 
   init (obj);
 }
 
-void Object::init (QObject* obj, bool)
+void
+Object::init (QObject* obj, bool)
 {
   if (m_qobject)
     qCritical ("QtHandles::Object::init: "
                "resetting QObject while in invalid state");
 
   m_qobject = obj;
 
   if (m_qobject)
@@ -63,113 +64,126 @@ void Object::init (QObject* obj, bool)
                SLOT (objectDestroyed (QObject*)));
     }
 }
 
 Object::~Object (void)
 {
 }
 
-graphics_object Object::object (void) const
+graphics_object
+Object::object (void) const
 {
   gh_manager::auto_lock lock (false);
 
   if (! lock)
     qCritical ("QtHandles::Object::object: "
                "accessing graphics object (h=%g) without a valid lock!!!",
                m_handle.value ());
 
   return gh_manager::get_object (m_handle);
 }
 
-void Object::slotUpdate (int pId)
+void
+Object::slotUpdate (int pId)
 {
   gh_manager::auto_lock lock;
 
   switch (pId)
     {
     // Special case for objects being deleted, as it's very likely
     // that the graphics_object already has been destroyed when this
     // is executed (because of the async behavior).
     case base_properties::ID_BEINGDELETED:
       beingDeleted ();
       break;
+
     default:
       if (object ().valid_object ())
         update (pId);
       break;
     }
 }
 
-void Object::slotFinalize (void)
+void
+Object::slotFinalize (void)
 {
   gh_manager::auto_lock lock;
 
   finalize ();
 }
 
-void Object::slotRedraw (void)
+void
+Object::slotRedraw (void)
 {
   gh_manager::auto_lock lock;
 
   if (object ().valid_object ())
     redraw ();
 }
 
-void Object::slotPrint (const QString& file_cmd, const QString& term)
+void
+Object::slotPrint (const QString& file_cmd, const QString& term)
 {
   gh_manager::auto_lock lock;
 
   if (object ().valid_object ())
     print (file_cmd, term);
 }
 
-void Object::update (int /* pId */)
+void
+Object::update (int /* pId */)
 {
 }
 
-void Object::finalize (void)
+void
+Object::finalize (void)
 {
   if (m_qobject)
     {
       delete m_qobject;
       m_qobject = 0;
     }
   deleteLater ();
 }
 
-void Object::redraw (void)
+void
+Object::redraw (void)
 {
 }
 
-void Object::print (const QString& /* file_cmd */, const QString& /* term */)
+void
+Object::print (const QString& /* file_cmd */, const QString& /* term */)
 {
 }
 
-void Object::beingDeleted (void)
+void
+Object::beingDeleted (void)
 {
 }
 
 void Object::objectDestroyed (QObject* obj)
 {
   if (obj && obj == m_qobject)
     m_qobject = 0;
 }
 
-Object* Object::parentObject (const graphics_object& go)
+Object*
+Object::parentObject (const graphics_object& go)
 {
   gh_manager::auto_lock lock;
 
   Object* parent = Backend::toolkitObject
     (gh_manager::get_object (go.get_parent ()));
 
   return parent;
 }
 
-Object* Object::fromQObject (QObject* obj)
+Object*
+Object::fromQObject (QObject* obj)
 {
   QVariant v = obj->property ("QtHandles::Object");
 
   if (v.isValid ())
     return reinterpret_cast<Object*> (qVariantValue<void*> (v));
 
   return 0;
 }
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -49,32 +49,34 @@ along with Octave; see the file COPYING.
 #include "ToggleButtonControl.h"
 #include "ToggleTool.h"
 #include "ToolBar.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ObjectFactory* ObjectFactory::instance (void)
+ObjectFactory*
+ObjectFactory::instance (void)
 {
   static ObjectFactory s_instance;
   static bool s_instanceCreated = false;
 
   if (! s_instanceCreated)
     {
       if (QThread::currentThread () != QApplication::instance ()->thread ())
         s_instance.moveToThread (QApplication::instance ()->thread ());
       s_instanceCreated = true;
     }
 
   return &s_instance;
 }
 
-void ObjectFactory::createObject (double handle)
+void
+ObjectFactory::createObject (double handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go (gh_manager::get_object (graphics_handle (handle)));
 
   if (go.valid_object ())
     {
       if (go.get_properties ().is_beingdeleted ())
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -35,17 +35,18 @@ namespace QtHandles
 {
 
 ObjectProxy::ObjectProxy (Object* obj)
   : QObject (), m_object (0)
 {
   init (obj);
 }
 
-void ObjectProxy::init (Object* obj)
+void
+ObjectProxy::init (Object* obj)
 {
   if (obj != m_object)
     {
       if (m_object)
         {
           disconnect (this, SIGNAL (sendUpdate (int)),
                       m_object, SLOT (slotUpdate (int)));
           disconnect (this, SIGNAL (sendFinalize (void)),
@@ -67,39 +68,44 @@ void ObjectProxy::init (Object* obj)
           connect (this, SIGNAL (sendRedraw (void)),
                    m_object, SLOT (slotRedraw (void)));
           connect (this, SIGNAL (sendPrint (const QString&, const QString&)),
                    m_object, SLOT (slotPrint (const QString&, const QString&)));
         }
     }
 }
 
-void ObjectProxy::setObject (Object* obj)
+void
+ObjectProxy::setObject (Object* obj)
 {
   emit sendFinalize ();
   init (obj);
 }
 
-void ObjectProxy::update (int pId)
+void
+ObjectProxy::update (int pId)
 {
   if (octave_thread::is_octave_thread ())
     emit sendUpdate (pId);
   else
     m_object->slotUpdate (pId);
 }
 
-void ObjectProxy::finalize (void)
+void
+ObjectProxy::finalize (void)
 {
   emit sendFinalize ();
   init (0);
 }
 
-void ObjectProxy::redraw (void)
+void
+ObjectProxy::redraw (void)
 {
   emit sendRedraw ();
 }
 
-  void ObjectProxy::print (const QString& file_cmd, const QString& term)
+void
+ObjectProxy::print (const QString& file_cmd, const QString& term)
 {
   emit sendPrint (file_cmd, term);
 }
 
 };
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -34,75 +34,79 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 #include "ContextMenu.h"
 #include "Panel.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static int frameStyleFromProperties (const uipanel::properties& pp)
+static int
+frameStyleFromProperties (const uipanel::properties& pp)
 {
   if (pp.bordertype_is ("none"))
     return QFrame::NoFrame;
   else if (pp.bordertype_is ("etchedin"))
     return (QFrame::Box | QFrame::Sunken);
   else if (pp.bordertype_is ("etchedout"))
     return (QFrame::Box | QFrame::Raised);
   else if (pp.bordertype_is ("beveledin"))
     return (QFrame::Panel | QFrame::Sunken);
   else if (pp.bordertype_is ("beveledout"))
     return (QFrame::Panel | QFrame::Raised);
   else
     return (QFrame::Panel | QFrame::Plain);
 }
 
-static void setupPalette (const uipanel::properties& pp, QPalette& p)
+static void
+setupPalette (const uipanel::properties& pp, QPalette& p)
 {
   p.setColor (QPalette::Window,
               Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
   p.setColor (QPalette::WindowText,
               Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
   p.setColor (QPalette::Light,
               Utils::fromRgb (pp.get_highlightcolor_rgb ()));
   p.setColor (QPalette::Dark,
               Utils::fromRgb (pp.get_shadowcolor_rgb ()));
 }
 
-static int borderWidthFromProperties (const uipanel::properties& pp)
+static int
+borderWidthFromProperties (const uipanel::properties& pp)
 {
   int bw = 0;
 
   if (! pp.bordertype_is ("none"))
     {
       bw = xround (pp.get_borderwidth ());
       if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
         bw *= 2;
     }
 
   return bw;
 }
 
-Panel* Panel::create (const graphics_object& go)
+Panel*
+Panel::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new Panel (go, new QFrame (container));
     }
 
   return 0;
 }
 
 Panel::Panel (const graphics_object& go, QFrame* frame)
-    : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
+  : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
 {
   uipanel::properties& pp = properties<uipanel> ();
 
   frame->setObjectName ("UIPanel");
   frame->setAutoFillBackground (true);
   Matrix bb = pp.get_boundingbox (false);
   frame->setGeometry (xround (bb(0)), xround (bb(1)),
                       xround (bb(2)), xround (bb(3)));
@@ -139,17 +143,18 @@ Panel::Panel (const graphics_object& go,
   else
     frame->hide ();
 }
 
 Panel::~Panel (void)
 {
 }
 
-bool Panel::eventFilter (QObject* watched, QEvent* xevent)
+bool
+Panel::eventFilter (QObject* watched, QEvent* xevent)
 {
   if (! m_blockUpdates)
     {
       if (watched == qObject ())
         {
           switch (xevent->type ())
             {
             case QEvent::Resize:
@@ -172,157 +177,172 @@ bool Panel::eventFilter (QObject* watche
                                                 (pp, frame->height ()));
                               m_title->resize (m_title->sizeHint ());
                             }
                         }
                       updateLayout ();
                     }
                 }
               break;
+
             case QEvent::MouseButtonPress:
                 {
                   QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       ContextMenu::executeAt (properties (), m->globalPos ());
                     }
                 }
               break;
+
             default:
               break;
             }
         }
       else if (watched == m_container)
         {
           switch (xevent->type ())
             {
             case QEvent::Resize:
               if (qWidget<QWidget> ()->isVisible ())
                 {
                   gh_manager::auto_lock lock;
 
                   properties ().update_boundingbox ();
                 }
               break;
+
             default:
               break;
             }
         }
     }
 
   return false;
 }
 
-void Panel::update (int pId)
+void
+Panel::update (int pId)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   m_blockUpdates = true;
 
   switch (pId)
     {
     case uipanel::properties::ID_POSITION:
-        {
-          Matrix bb = pp.get_boundingbox (false);
+      {
+        Matrix bb = pp.get_boundingbox (false);
 
-          frame->setGeometry (xround (bb(0)), xround (bb(1)),
-                              xround (bb(2)), xround (bb(3)));
-          updateLayout ();
-        }
+        frame->setGeometry (xround (bb(0)), xround (bb(1)),
+                            xround (bb(2)), xround (bb(3)));
+        updateLayout ();
+      }
       break;
+
     case uipanel::properties::ID_BORDERWIDTH:
       frame->setLineWidth (xround (pp.get_borderwidth ()));
       updateLayout ();
       break;
+
     case uipanel::properties::ID_BACKGROUNDCOLOR:
     case uipanel::properties::ID_FOREGROUNDCOLOR:
     case uipanel::properties::ID_HIGHLIGHTCOLOR:
     case uipanel::properties::ID_SHADOWCOLOR:
-        {
-          QPalette pal = frame->palette ();
+      {
+        QPalette pal = frame->palette ();
 
-          setupPalette (pp, pal);
-          frame->setPalette (pal);
-          if (m_title)
-            m_title->setPalette (pal);
-        }
+        setupPalette (pp, pal);
+        frame->setPalette (pal);
+        if (m_title)
+          m_title->setPalette (pal);
+      }
       break;
+
     case uipanel::properties::ID_TITLE:
-        {
-          QString title = Utils::fromStdString (pp.get_title ());
+      {
+        QString title = Utils::fromStdString (pp.get_title ());
 
-          if (title.isEmpty ())
-            {
-              if (m_title)
-                delete m_title;
-              m_title = 0;
-            }
-          else
-            {
-              if (! m_title)
-                {
-                  QPalette pal = frame->palette ();
+        if (title.isEmpty ())
+          {
+            if (m_title)
+              delete m_title;
+            m_title = 0;
+          }
+        else
+          {
+            if (! m_title)
+              {
+                QPalette pal = frame->palette ();
 
-                  m_title = new QLabel (title, frame);
-                  m_title->setAutoFillBackground (true);
-                  m_title->setContentsMargins (4, 0, 4, 0);
-                  m_title->setPalette (pal);
-                  m_title->setFont (Utils::computeFont<uipanel> (pp));
-                  m_title->show ();
-                }
-              else
-                {
-                  m_title->setText (title);
-                  m_title->resize (m_title->sizeHint ());
-                }
-            }
-          updateLayout ();
-        }
+                m_title = new QLabel (title, frame);
+                m_title->setAutoFillBackground (true);
+                m_title->setContentsMargins (4, 0, 4, 0);
+                m_title->setPalette (pal);
+                m_title->setFont (Utils::computeFont<uipanel> (pp));
+                m_title->show ();
+              }
+            else
+              {
+                m_title->setText (title);
+                m_title->resize (m_title->sizeHint ());
+              }
+          }
+        updateLayout ();
+      }
+      break;
+
     case uipanel::properties::ID_TITLEPOSITION:
       updateLayout ();
       break;
+
     case uipanel::properties::ID_BORDERTYPE:
       frame->setFrameStyle (frameStyleFromProperties (pp));
       updateLayout ();
       break;
+
     case uipanel::properties::ID_FONTNAME:
     case uipanel::properties::ID_FONTSIZE:
     case uipanel::properties::ID_FONTWEIGHT:
     case uipanel::properties::ID_FONTANGLE:
       if (m_title)
         {
           m_title->setFont (Utils::computeFont<uipanel> (pp));
           m_title->resize (m_title->sizeHint ());
           updateLayout ();
         }
       break;
+
     case uipanel::properties::ID_VISIBLE:
       frame->setVisible (pp.is_visible ());
       updateLayout ();
       break;
+
     default:
       break;
     }
 
   m_blockUpdates = false;
 }
 
-void Panel::redraw (void)
+void
+Panel::redraw (void)
 {
   Canvas* canvas = m_container->canvas (m_handle);
 
   if (canvas)
     canvas->redraw ();
 }
 
-void Panel::updateLayout (void)
+void
+Panel::updateLayout (void)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   Matrix bb = pp.get_boundingbox (true);
   int bw = borderWidthFromProperties (pp);
 
   frame->setFrameRect (QRect (xround (bb(0)) - bw, xround (bb(1)) - bw,
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -28,33 +28,34 @@ along with Octave; see the file COPYING.
 
 #include "Container.h"
 #include "PopupMenuControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-PopupMenuControl* PopupMenuControl::create (const graphics_object& go)
+PopupMenuControl*
+PopupMenuControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new PopupMenuControl (go, new QComboBox (container));
     }
 
   return 0;
 }
 
 PopupMenuControl::PopupMenuControl (const graphics_object& go, QComboBox *box)
-     : BaseControl (go, box), m_blockUpdate (false)
+  : BaseControl (go, box), m_blockUpdate (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   box->addItems (Utils::fromStdString (up.get_string_string ()).split ('|'));
 
   connect (box, SIGNAL (currentIndexChanged (int)),
            SLOT (currentIndexChanged (int)));
 }
@@ -89,39 +90,42 @@ void PopupMenuControl::update (int pId)
               gh_manager::post_set (m_handle, "value",
                                     octave_value (box->count () > 0
                                                   ? 1.0 : 0.0),
                                     false);
             }
         }
       m_blockUpdate = false;
       break;
+
     case uicontrol::properties::ID_VALUE:
         {
           Matrix value = up.get_value ().matrix_value ();
 
           if (value.numel () > 0)
             {
               int newIndex = int (value(0)) - 1;
 
               if (newIndex >= 0 && newIndex < box->count ()
                   && newIndex != box->currentIndex ())
                 {
                   box->setCurrentIndex (newIndex);
                 }
             }
         }
       break;
+
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
-void PopupMenuControl::currentIndexChanged (int index)
+void
+PopupMenuControl::currentIndexChanged (int index)
 {
   if (! m_blockUpdate)
     {
       gh_manager::post_set (m_handle, "value",
                             octave_value (double (index + 1)),
                             false);
       gh_manager::post_callback (m_handle, "callback");
     }
diff --git a/libgui/graphics/PushButtonControl.cc b/libgui/graphics/PushButtonControl.cc
--- a/libgui/graphics/PushButtonControl.cc
+++ b/libgui/graphics/PushButtonControl.cc
@@ -29,50 +29,54 @@ along with Octave; see the file COPYING.
 
 #include "PushButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-PushButtonControl* PushButtonControl::create (const graphics_object& go)
+PushButtonControl*
+PushButtonControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new PushButtonControl (go, new QPushButton (container));
     }
 
   return 0;
 }
 
-PushButtonControl::PushButtonControl (const graphics_object& go, QPushButton* btn)
+PushButtonControl::PushButtonControl (const graphics_object& go,
+                                      QPushButton* btn)
   : ButtonControl (go, btn)
 {
   btn->setAutoFillBackground (true);
 }
 
 PushButtonControl::~PushButtonControl (void)
 {
 }
 
-void PushButtonControl::update (int pId)
+void
+PushButtonControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QPushButton* btn = qWidget<QPushButton> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       btn->setText (Utils::fromStdString (up.get_string_string ()));
       break;
+
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 }; // namespave QtHandles
diff --git a/libgui/graphics/PushTool.cc b/libgui/graphics/PushTool.cc
--- a/libgui/graphics/PushTool.cc
+++ b/libgui/graphics/PushTool.cc
@@ -26,49 +26,52 @@ along with Octave; see the file COPYING.
 
 #include "PushTool.h"
 
 #include "ToolBarButton.cc"
 
 namespace QtHandles
 {
 
-PushTool* PushTool::create (const graphics_object& go)
+PushTool*
+PushTool::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
         return new PushTool (go, new QAction (parentWidget));
     }
 
   return 0;
 }
 
 PushTool::PushTool (const graphics_object& go, QAction* action)
-    : ToolBarButton<uipushtool> (go, action)
+  : ToolBarButton<uipushtool> (go, action)
 {
   connect (action, SIGNAL (triggered (bool)), this, SLOT (clicked (void)));
 }
 
 PushTool::~PushTool (void)
 {
 }
 
-void PushTool::update (int pId)
+void
+PushTool::update (int pId)
 {
   switch (pId)
     {
     default:
       ToolBarButton<uipushtool>::update (pId);
       break;
     }
 }
 
-void PushTool::clicked (void)
+void
+PushTool::clicked (void)
 {
   gh_manager::post_callback (m_handle, "clickedcallback");
 }
 
 };
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -40,50 +40,55 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 namespace Utils
 {
 
-QString fromStdString (const std::string& s)
+QString
+fromStdString (const std::string& s)
 {
   return QString::fromLocal8Bit (s.c_str ());
 }
 
-std::string toStdString (const QString& s)
+std::string
+toStdString (const QString& s)
 {
   return std::string (s.toLocal8Bit ().data ());
 }
 
-QStringList fromStringVector (const string_vector& v)
+QStringList
+fromStringVector (const string_vector& v)
 {
   QStringList l;
   octave_idx_type n = v.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     l << fromStdString (v[i]);
 
   return l;
 }
 
-string_vector toStringVector (const QStringList& l)
+string_vector
+toStringVector (const QStringList& l)
 {
   string_vector v (l.length ());
   int i = 0;
 
   foreach (const QString& s, l)
     v[i++] = toStdString (s);
 
   return v;
 }
 
 template <class T>
-QFont computeFont (const typename T::properties& props, int height)
+QFont
+computeFont (const typename T::properties& props, int height)
 {
   QFont f (fromStdString (props.get_fontname ()));
 
   static std::map<std::string, QFont::Weight> weightMap;
   static std::map<std::string, QFont::Style> angleMap;
   static bool mapsInitialized = false;
 
   if (! mapsInitialized)
@@ -104,40 +109,44 @@ QFont computeFont (const typename T::pro
   f.setWeight (weightMap[props.get_fontweight ()]);
   f.setStyle (angleMap[props.get_fontangle ()]);
 
   return f;
 }
 
 template QFont computeFont<uicontrol> (const uicontrol::properties& props,
                                        int height);
+
 template QFont computeFont<uipanel> (const uipanel::properties& props,
                                      int height);
 
-QColor fromRgb (const Matrix& rgb)
+QColor
+fromRgb (const Matrix& rgb)
 {
   QColor c;
 
   if (rgb.numel () == 3)
     c.setRgbF (rgb(0), rgb(1), rgb(2));
 
   return c;
 }
 
-Matrix toRgb (const QColor& c)
+Matrix
+toRgb (const QColor& c)
 {
   Matrix rgb (1, 3);
   double* rgbData = rgb.fortran_vec ();
 
   c.getRgbF (rgbData, rgbData+1, rgbData+2);
 
   return rgb;
 }
 
-std::string figureSelectionType (QMouseEvent* event, bool isDoubleClick)
+std::string
+figureSelectionType (QMouseEvent* event, bool isDoubleClick)
 {
   if (isDoubleClick)
     return std::string ("open");
   else
     {
       Qt::MouseButtons buttons = event->buttons ();
       Qt::KeyboardModifiers mods = event->modifiers ();
 
@@ -162,17 +171,18 @@ std::string figureSelectionType (QMouseE
           else if (mods == Qt::ControlModifier)
             return std::string ("alt");
         }
     }
 
   return std::string ("normal");
 }
 
-Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
+Matrix
+figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
 {
   Object* tkFig = Backend::toolkitObject (fig);
 
   if (tkFig)
     {
       Container* c = tkFig->innerContainer ();
 
       if (c)
@@ -183,18 +193,18 @@ Matrix figureCurrentPoint (const graphic
             tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
                                                                qp.y ());
         }
     }
 
   return Matrix (1, 2, 0.0);
 }
 
-Qt::Alignment fromHVAlign (const caseless_str& halign,
-                           const caseless_str& valign)
+Qt::Alignment
+fromHVAlign (const caseless_str& halign, const caseless_str& valign)
 {
   Qt::Alignment flags;
 
   if (halign.compare ("left"))
     flags |= Qt::AlignLeft;
   else if (halign.compare ("center"))
     flags |= Qt::AlignHCenter;
   else if (halign.compare ("right"))
@@ -209,17 +219,18 @@ Qt::Alignment fromHVAlign (const caseles
   else if (valign.compare ("bottom"))
     flags |= Qt::AlignBottom;
   else
     flags |= Qt::AlignVCenter;
 
   return flags;
 }
 
-QImage makeImageFromCData (const octave_value& v, int width, int height)
+QImage
+makeImageFromCData (const octave_value& v, int width, int height)
 {
   dim_vector dv (v.dims ());
 
   if (dv.length () == 3 && dv(2) == 3)
     {
       int w = qMin (dv(1), static_cast<octave_idx_type> (width));
       int h = qMin (dv(0), static_cast<octave_idx_type> (height));
 
@@ -284,17 +295,18 @@ QImage makeImageFromCData (const octave_
         }
 
       return img;
     }
 
   return QImage ();
 }
 
-octave_scalar_map makeKeyEventStruct (QKeyEvent* event)
+octave_scalar_map
+makeKeyEventStruct (QKeyEvent* event)
 {
   octave_scalar_map retval;
 
   retval.setfield ("Key", KeyMap::qKeyToKeyString (event->key ()));
   retval.setfield ("Character", toStdString (event->text ()));
 
   std::list<std::string> modList;
   Qt::KeyboardModifiers mods = event->modifiers ();
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -28,34 +28,35 @@ along with Octave; see the file COPYING.
 
 #include "RadioButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-RadioButtonControl* RadioButtonControl::create (const graphics_object& go)
+RadioButtonControl*
+RadioButtonControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new RadioButtonControl (go, new QRadioButton (container));
     }
 
   return 0;
 }
 
 RadioButtonControl::RadioButtonControl (const graphics_object& go,
                                         QRadioButton* radio)
-    : ButtonControl (go, radio)
+  : ButtonControl (go, radio)
 {
   radio->setAutoFillBackground (true);
   radio->setAutoExclusive (false);
 }
 
 RadioButtonControl::~RadioButtonControl (void)
 {
 }
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -30,34 +30,35 @@ along with Octave; see the file COPYING.
 #include "SliderControl.h"
 #include "QtHandlesUtils.h"
 
 #define RANGE_INT_MAX 1000000
 
 namespace QtHandles
 {
 
-SliderControl* SliderControl::create (const graphics_object& go)
+SliderControl*
+SliderControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new SliderControl (go, new QScrollBar (container));
     }
 
   return 0;
 }
 
 SliderControl::SliderControl (const graphics_object& go,
                               QAbstractSlider* slider)
-    : BaseControl (go, slider), m_blockUpdates (false)
+  : BaseControl (go, slider), m_blockUpdates (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   slider->setTracking (false);
   Matrix bb = up.get_boundingbox ();
   slider->setOrientation (bb(2) > bb(3) ? Qt::Horizontal : Qt::Vertical);
   Matrix steps = up.get_sliderstep ().matrix_value ();
   slider->setMinimum (0);
@@ -75,54 +76,58 @@ SliderControl::SliderControl (const grap
 
   connect (slider, SIGNAL (valueChanged (int)), SLOT (valueChanged (int)));
 }
 
 SliderControl::~SliderControl (void)
 {
 }
 
-void SliderControl::update (int pId)
+void
+SliderControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QScrollBar* slider = qWidget<QScrollBar> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_SLIDERSTEP:
-        {
-          Matrix steps = up.get_sliderstep ().matrix_value ();
+      {
+        Matrix steps = up.get_sliderstep ().matrix_value ();
 
-          slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
-          slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
-        }
+        slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
+        slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
+      }
       break;
+
     case uicontrol::properties::ID_VALUE:
-        {
-          Matrix value = up.get_value ().matrix_value ();
-          double dmax = up.get_max (), dmin = up.get_min ();
+      {
+        Matrix value = up.get_value ().matrix_value ();
+        double dmax = up.get_max (), dmin = up.get_min ();
 
-          if (value.numel () > 0)
-            {
-              int ival = xround (((value(0) - dmin) / (dmax - dmin))
-                                 * RANGE_INT_MAX);
+        if (value.numel () > 0)
+          {
+            int ival = xround (((value(0) - dmin) / (dmax - dmin))
+                               * RANGE_INT_MAX);
 
-              m_blockUpdates = true;
-              slider->setValue (ival);
-              m_blockUpdates = false;
-            }
-        }
+            m_blockUpdates = true;
+            slider->setValue (ival);
+            m_blockUpdates = false;
+          }
+      }
       break;
+
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
-void SliderControl::valueChanged (int ival)
+void
+SliderControl::valueChanged (int ival)
 {
   if (! m_blockUpdates)
     {
       gh_manager::auto_lock lock;
       graphics_object go = object ();
 
       if (go.valid_object ())
         {
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -28,64 +28,68 @@ along with Octave; see the file COPYING.
 
 #include "Container.h"
 #include "TextControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-TextControl* TextControl::create (const graphics_object& go)
+TextControl*
+TextControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
         return new TextControl (go, new QLabel (container));
     }
 
   return 0;
 }
 
 TextControl::TextControl (const graphics_object& go, QLabel* label)
-     : BaseControl (go, label)
+  : BaseControl (go, label)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   label->setAutoFillBackground (true);
   label->setTextFormat (Qt::PlainText);
   label->setWordWrap (false);
   label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
                                            up.get_verticalalignment ()));
   // FIXME: support string_vector
   label->setText (Utils::fromStdString (up.get_string_string ()));
 }
 
 TextControl::~TextControl (void)
 {
 }
 
-void TextControl::update (int pId)
+void
+TextControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QLabel* label = qWidget<QLabel> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       // FIXME: support string_vector
       label->setText (Utils::fromStdString (up.get_string_string ()));
       break;
+
     case uicontrol::properties::ID_HORIZONTALALIGNMENT:
     case uicontrol::properties::ID_VERTICALALIGNMENT:
       label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
                                                up.get_verticalalignment ()));
       break;
+
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/TextEdit.cc b/libgui/graphics/TextEdit.cc
--- a/libgui/graphics/TextEdit.cc
+++ b/libgui/graphics/TextEdit.cc
@@ -26,24 +26,26 @@ along with Octave; see the file COPYING.
 
 #include <QKeyEvent>
 
 #include "TextEdit.h"
 
 namespace QtHandles
 {
 
-void TextEdit::focusOutEvent (QFocusEvent* xevent)
+void
+TextEdit::focusOutEvent (QFocusEvent* xevent)
 {
   QTextEdit::focusOutEvent (xevent);
 
   emit editingFinished ();
 }
 
-void TextEdit::keyPressEvent (QKeyEvent* xevent)
+void
+TextEdit::keyPressEvent (QKeyEvent* xevent)
 {
   QTextEdit::keyPressEvent (xevent);
 
   if ((xevent->key () == Qt::Key_Return
        || xevent->key () == Qt::Key_Enter)
       && xevent->modifiers () == Qt::ControlModifier)
     emit editingFinished ();
 }
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -28,17 +28,18 @@ along with Octave; see the file COPYING.
 
 #include "ToggleButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-ToggleButtonControl* ToggleButtonControl::create (const graphics_object& go)
+ToggleButtonControl*
+ToggleButtonControl::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
diff --git a/libgui/graphics/ToggleTool.cc b/libgui/graphics/ToggleTool.cc
--- a/libgui/graphics/ToggleTool.cc
+++ b/libgui/graphics/ToggleTool.cc
@@ -26,64 +26,68 @@ along with Octave; see the file COPYING.
 
 #include "ToggleTool.h"
 
 #include "ToolBarButton.cc"
 
 namespace QtHandles
 {
 
-ToggleTool* ToggleTool::create (const graphics_object& go)
+ToggleTool*
+ToggleTool::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
         return new ToggleTool (go, new QAction (parentWidget));
     }
 
   return 0;
 }
 
 ToggleTool::ToggleTool (const graphics_object& go, QAction* action)
-    : ToolBarButton<uitoggletool> (go, action)
+  : ToolBarButton<uitoggletool> (go, action)
 {
   uitoggletool::properties& tp = properties<uitoggletool> ();
 
   action->setCheckable (true);
   action->setChecked (tp.is_state ());
 
   connect (action, SIGNAL (toggled (bool)),
            this, SLOT (triggered (bool)));
 }
 
 ToggleTool::~ToggleTool (void)
 {
 }
 
-void ToggleTool::update (int pId)
+void
+ToggleTool::update (int pId)
 {
   uitoggletool::properties& tp = properties<uitoggletool> ();
   QAction* action = qWidget<QAction> ();
 
   switch (pId)
     {
     case uitoggletool::properties::ID_STATE:
       action->setChecked (tp.is_state ());
       break;
+
     default:
       ToolBarButton<uitoggletool>::update (pId);
       break;
     }
 }
 
-void ToggleTool::triggered (bool checked)
+void
+ToggleTool::triggered (bool checked)
 {
   gh_manager::post_set (m_handle, "state", checked, false);
   gh_manager::post_callback (m_handle,
                              checked
                              ? "oncallback"
                              : "offcallback");
   gh_manager::post_callback (m_handle, "clickedcallback");
 }
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -36,17 +36,18 @@ along with Octave; see the file COPYING.
 
 #include "Figure.h"
 #include "ToolBar.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-static QAction* addEmptyAction (QToolBar* bar)
+static QAction*
+addEmptyAction (QToolBar* bar)
 {
   static QIcon _empty;
 
   if (_empty.isNull ())
     {
       QPixmap pix (16, 16);
 
       pix.fill (Qt::transparent);
@@ -57,33 +58,34 @@ static QAction* addEmptyAction (QToolBar
   QAction* a = bar->addAction (_empty, "Empty Toolbar");
 
   a->setEnabled (false);
   a->setToolTip ("");
 
   return a;
 }
 
-ToolBar* ToolBar::create (const graphics_object& go)
+ToolBar*
+ToolBar::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
         return new ToolBar (go, new QToolBar (parentWidget));
     }
 
   return 0;
 }
 
 ToolBar::ToolBar (const graphics_object& go, QToolBar* bar)
-     : Object (go, bar), m_empty (0), m_figure (0)
+  : Object (go, bar), m_empty (0), m_figure (0)
 {
   uitoolbar::properties& tp = properties<uitoolbar> ();
 
   bar->setFloatable (false);
   bar->setMovable (false);
   bar->setVisible (tp.is_visible ());
 
   m_empty = addEmptyAction (bar);
@@ -96,34 +98,37 @@ ToolBar::ToolBar (const graphics_object&
 
   bar->installEventFilter (this);
 }
 
 ToolBar::~ToolBar (void)
 {
 }
 
-void ToolBar::update (int pId)
+void
+ToolBar::update (int pId)
 {
   uitoolbar::properties& tp = properties<uitoolbar> ();
   QToolBar* bar = qWidget<QToolBar> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       if (m_figure)
         m_figure->showCustomToolBar (bar, tp.is_visible ());
       break;
+
     default:
       Object::update (pId);
       break;
     }
 }
 
-bool ToolBar::eventFilter (QObject* watched, QEvent* xevent)
+bool
+ToolBar::eventFilter (QObject* watched, QEvent* xevent)
 {
   if (watched == qObject ())
     {
       switch (xevent->type ())
         {
         case QEvent::ActionAdded:
         case QEvent::ActionRemoved:
             {
@@ -140,30 +145,33 @@ bool ToolBar::eventFilter (QObject* watc
                   else
                     {
                       if (bar->actions ().size () == 1)
                         m_empty->setVisible (true);
                     }
                 }
             }
           break;
+
         default:
           break;
         }
     }
 
   return false;
 }
 
-void ToolBar::hideEmpty (void)
+void
+ToolBar::hideEmpty (void)
 {
   m_empty->setVisible (false);
 }
 
-void ToolBar::beingDeleted (void)
+void
+ToolBar::beingDeleted (void)
 {
   if (m_figure)
     {
       QToolBar* bar = qWidget<QToolBar> ();
 
       if (bar)
         m_figure->showCustomToolBar (bar, false);
     }
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "ToolBarButton.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 template <class T>
 ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction* action)
-    : Object (go, action), m_separator (0)
+  : Object (go, action), m_separator (0)
 {
   typename T::properties& tp = properties<T> ();
 
   action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
   action->setVisible (tp.is_visible ());
   QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
   action->setIcon (QIcon (QPixmap::fromImage (img)));
   if (tp.is_separator ())
@@ -59,38 +59,42 @@ ToolBarButton<T>::ToolBarButton (const g
 }
 
 template <class T>
 ToolBarButton<T>::~ToolBarButton (void)
 {
 }
 
 template <class T>
-void ToolBarButton<T>::update (int pId)
+void
+ToolBarButton<T>::update (int pId)
 {
   typename T::properties& tp = properties<T> ();
   QAction* action = qWidget<QAction> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       action->setVisible (tp.is_visible ());
       if (m_separator)
         m_separator->setVisible (tp.is_visible ());
       break;
+
     case T::properties::ID_TOOLTIPSTRING:
       action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
       break;
+
     case T::properties::ID_CDATA:
-        {
-          QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
+      {
+        QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
 
-          action->setIcon (QIcon (QPixmap::fromImage (img)));
-        }
+        action->setIcon (QIcon (QPixmap::fromImage (img)));
+      }
       break;
+
     case T::properties::ID_SEPARATOR:
       if (tp.is_separator ())
         {
           if (! m_separator)
             {
               m_separator = new QAction (action);
               m_separator->setSeparator (true);
               m_separator->setVisible (tp.is_visible ());
@@ -102,18 +106,20 @@ void ToolBarButton<T>::update (int pId)
         }
       else
         {
           if (m_separator)
             delete m_separator;
           m_separator = 0;
         }
       break;
+
     case T::properties::ID_ENABLE:
       action->setEnabled (tp.is_enable ());
       break;
+
     default:
       Object::update (pId);
       break;
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -38,17 +38,18 @@ along with Octave; see the file COPYING.
 #include "Backend.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 static bool qtHandlesInitialized = false;
 
-bool __init__ (void)
+bool
+__init__ (void)
 {
   if (! qtHandlesInitialized)
     {
       if (qApp)
         {
           gh_manager::auto_lock lock;
 
           qRegisterMetaType<graphics_object> ("graphics_object");
@@ -89,17 +90,18 @@ bool __init__ (void)
         }
       else
         error ("__init_qt__: QApplication object must exist.");
     }
 
   return false;
 }
 
-bool __shutdown__ (void)
+bool
+__shutdown__ (void)
 {
   if (qtHandlesInitialized)
     {
       gh_manager::auto_lock lock;
 
       octave_add_atexit_function ("__shutdown_qt__");
 
       gtk_manager::unload_toolkit ("qt");
@@ -137,17 +139,18 @@ install___init_qt___functions (void)
                             "__init_qt__.cc", "");
 
   install_builtin_function (F__shutdown_qt__, "__shutdown_qt__",
                             "__init_qt__.cc", "");
 }
 
 #if 0
 
-static QStringList makeFilterSpecs (const Cell& filters)
+static QStringList
+makeFilterSpecs (const Cell& filters)
 {
   using namespace QtHandles::Utils;
 
   QStringList filterSpecs;
   QRegExp parenRe (" ?\\(.*\\)\\s*$");
 
   for (int i = 0; i < filters.rows (); i++)
     {
@@ -167,17 +170,18 @@ static QStringList makeFilterSpecs (cons
       specItem = QString ("%1 (%2)").arg (desc).arg (extList.join (" "));
 
       filterSpecs.append (specItem);
     }
 
   return filterSpecs;
 }
 
-static QString appendDirSep (const QString& d)
+static QString
+appendDirSep (const QString& d)
 {
   if (! d.endsWith ("/") && ! d.endsWith (QDir::separator ()))
     return (d + "/");
   return d;
 }
 
 DEFUN (__uigetfile_qt__, args, , "")
 {
