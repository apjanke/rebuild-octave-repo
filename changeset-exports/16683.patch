# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1368931390 14400
#      Sat May 18 22:43:10 2013 -0400
# Branch classdef
# Node ID e1c6ad54259f8817677016f0f3967fb59e757f07
# Parent  2c8dc18fa9c6e034e42e483f21e592e0b83e5541
# Parent  d3619d4d267cfe733bec1e2b4496af490557ff58
maint: periodic merge of default to classdef

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -71,8 +71,10 @@ a95432e7309ca6fc776c02939264bb6d443f3525
 2e8eb9ac43a5f8cfaf0423814a312ed47cb80485 rc-3-6-4-0
 df1aceb8f0bc6b5b5062907931cc663467f57d93 ss-3-7-1
 858cbf6fc2ec1c232f5cf1d75dc344439b39a89c rc-3-6-4-1
 faefa1bea8ddae3cab170afdeab68d3d15c4e623 ss-3-7-2
 0000000000000000000000000000000000000000 ss-3-7-2
 23a7661e529ae9bfc91693618f8c314c31f695ca ss-3-7-2
 cc5a7d1233f3acea85648baeb754fc0e8f225225 rc-3-6-4-2
 b29b10fbb7448cdfe29322446e1a589e7fe1a40a release-3-6-4
+4e50bd2946d8563d3e201cc04b3ba0720c991b06 ss-3-7-4
+608e307b49149b32a6d09c2f06493d04d3af9be4 ss-3-7-5
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -14,23 +14,23 @@ dnl Copyright (C) 1993-2012 John W. Eato
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, see
 ### <http://www.gnu.org/licenses/>.
 
 AC_PREREQ([2.62])
-AC_INIT([GNU Octave], [3.7.3+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.7.5], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2013-04-22"
+OCTAVE_RELEASE_DATE="2013-05-14"
 OCTAVE_COPYRIGHT="Copyright (C) 2013 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 dnl FIXME: We should auto-insert the Mercurial changeset ID into the
@@ -2594,20 +2594,20 @@ if test $build_gui = yes; then
     ## Check for Qt4
     if ! `$PKG_CONFIG --atleast-version=4.0.0 QtCore`; then
       AC_MSG_WARN([Qt >= 4.0.0 not found -- disabling GUI])
       build_gui=no
     fi
   fi
 
   if test $build_gui = yes; then
-    AC_CHECK_PROGS(MOC, [moc-qt5 moc-qt4 moc])
-    AC_CHECK_PROGS(UIC, [uic-qt5 uic-qt4 uic])
-    AC_CHECK_PROGS(RCC, [rcc])
-    AC_CHECK_PROGS(LRELEASE, [lrelease-qt5 lrelease-qt4 lrelease])
+    AC_CHECK_TOOLS(MOC, [moc-qt5 moc-qt4 moc])
+    AC_CHECK_TOOLS(UIC, [uic-qt5 uic-qt4 uic])
+    AC_CHECK_TOOLS(RCC, [rcc])
+    AC_CHECK_TOOLS(LRELEASE, [lrelease-qt5 lrelease-qt4 lrelease])
     if test -n "$MOC" && test -n "$UIC" && test -n "$RCC" && test -n "$LRELEASE"; then
       AC_DEFINE(HAVE_QT, 1, 
         [Define to 1 if Qt is available (libraries, developer header files, utility programs (moc, uic, rcc, and lrelease))])
     else
       AC_MSG_WARN([Qt utility programs moc, uic, rcc, and lrelease not found -- disabling GUI])
       build_gui=no
     fi
   fi
@@ -2643,16 +2643,23 @@ if test $build_gui = yes; then
       AC_MSG_WARN([Qscintilla library not found -- disabling built-in GUI editor])
     else
       ## Let's assume Qscintilla library is at the same location as
       ## other regular Qt libraries.
       QT_LIBS="$QT_LIBS -lqscintilla2"
       OCTAVE_CHECK_FUNC_FINDFIRST_MODERN
       AC_DEFINE(HAVE_QSCINTILLA, 1, 
         [Define to 1 if the QScintilla library and header files are available])
+
+      save_CPPFLAGS="$CPPFLAGS"
+      CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
+      AC_LANG_PUSH(C++)
+      AC_CHECK_HEADERS([Qsci/qscilexeroctave.h Qsci/qscilexermatlab.h])
+      AC_LANG_POP(C++)
+      CPPFLAGS="$save_CPPFLAGS"
     fi
 
     AC_CHECK_FUNCS([setlocale], [],
       [AC_MSG_WARN([setlocale not found -- disabling GUI])
        build_gui=no])
 
     if test $build_gui = yes; then
       case $host_os in
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -42,91 +42,20 @@ development of Octave core, i.e., code t
 You may consider developing and publishing a package instead; a great
 place for this is the allied Octave-Forge project
 (@url{http://octave.sourceforge.net}).  Note that the Octave project is
 inherently more conservative and follows narrower rules.
 
 @node Building the Development Sources
 @section Building the Development Sources
 
-In addition to all the tools (both optional and required) that are
-listed in @ref{Build Dependencies} you will need Mercurial, a
-distributed version control system (@url{http://mercurial.selenic.com}).
-Octave's sources are stored in a Mercurial archive.
-
-Once you have the required tools installed, you can build Octave by
-doing
-
-@itemize @bullet
-@item
-Check out a copy of the Octave sources:
-
-@example
-hg clone http://www.octave.org/hg/octave
-@end example
-
-@item
-Change to the top-level directory of the newly checked out sources:
-
-@example
-cd octave
-@end example
-
-@item
-Generate the necessary configuration files:
-
-@example
-./bootstrap
-@end example
-
-@item
-Create a build directory and change to it:
-
-@example
-@group
-mkdir build
-cd build
-@end group
-@end example
-
-By using a separate build directory, you will keep the source directory
-clean and it will be easy to completely remove all files generated by
-the build.  You can also have parallel build trees for different
-purposes that all share the same sources.  For example, one build tree
-may be configured to disable compiler optimization in order to allow for
-easier debugging while another may be configured to test building with
-other specialized compiler flags.
-
-@item
-Run Octave's configure script from the build directory:
-
-@example
-../configure
-@end example
-
-@item
-Run make in the build directory:
-
-@example
-make
-@end example
-
-@end itemize
-
-Once the build is finished, you will see a message like the following:
-
-@example
-@group
-Octave successfully built.  Now choose from the following:
-
-   ./run-octave    - to run in place to test before installing
-   make check      - to run the tests
-   make install    - to install (PREFIX=...)
-@end group
-@end example
+The directions for building from the Development sources change from
+time to time, so you should read the resources for developers on the web
+or in the development sources archive.  Start here:
+@url{http://www.octave.org/get-involved.html}.
 
 @node Basics of Generating a Changeset
 @section Basics of Generating a Changeset
 
 The preferable form of contribution is creating a Mercurial changeset
 and submit it to the @uref{http://savannah.gnu.org/bugs/?group=octave, bug} or
 @uref{http://savannah.gnu.org/patch/?func=additem&group=octave, patch}
 trackers@footnote{Please use the patch tracker only for patches which add new
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -280,16 +280,17 @@ Christophe Tournery
 Thomas Treichl
 Karsten Trulsen
 Frederick Umminger
 Utkarsh Upadhyay
 Daniel Wagenaar
 Stefan van der Walt
 Peter Van Wieren
 James R. Van Zandt
+Risto Vanhanen
 Gregory Vanuxem
 Ivana Varekova
 Thomas Walter
 Andreas Weber
 Olaf Weber
 Thomas Weber
 Rik Wehbring
 Bob Weigel
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -4,30 +4,54 @@ This file attempts to describe the rules
 DO NOT put this file into the distribution.
 
 * Working from the repository
 
 These notes are intended to help people working on sources cloned from
 the savannah source code repository.
 These requirements do not apply when building from a distribution tarball.
 
+* Quick start
+
+  1. Install all the required dependencies.  Precisely how to do that
+     depends on what type of system you are using.  There are more
+     details below.
+
+  2. Clone the Octave sources:
+
+       hg clone http://www.octave.org/hg/octave
+
+  3. Change to the top-level directory of the Octave source tree and run
+     the bootstrap script:
+
+       cd octave
+       ./bootstrap
+
+  4. Create a build directory, cd to it, then run configure and make:
+
+       mkdir .build
+       cd .build
+       ../configure
+       make
+
 ** Requirements
 
 We've opted to keep only the highest-level sources in the repository.
 This eases our maintenance burden, (fewer merges, etc.), but imposes
 more requirements on anyone wishing to build from the just-cloned
 sources.  For example, you have to use the latest stable versions of
 the maintainer tools we depend upon, including:
 
   - Autoconf <http://www.gnu.org/software/autoconf/>
   - Automake <http://www.gnu.org/software/automake/>
   - Bison <http://www.gnu.org/software/bison/>
   - Flex <http://www.gnu.org/software/flex/>
   - Gnulib <http://www.gnu.org/software/gnulib/>
   - GNU Make <http://www.gnu.org/software/make/>
+  - gperf <http://www.gnu.org/software/gperf/>
   - Gzip <http://www.gnu.org/software/gzip/>
   - Libtool <http://www.gnu.org/software/libtool/>
   - Mercurial <http://mercurial.selenic.com/>
   - Perl <http://www.cpan.org/>
   - Rsync <http://samba.anu.edu.au/rsync/>
   - Tar <http://www.gnu.org/software/tar/>
 
 Only building the initial full source tree will be a bit painful.
@@ -215,18 +239,16 @@ An overview of the directory layout of O
 
 
   libgui        -- the graphical user interface of GNU Octave
 
     src              source files.
 
       m-editor       source files for the m-file editor.
 
-      octave-adapter souce files for the octave layer for threadsafe
-                     communication with the octave interpreter.
       qtinfo         source files for the Qt texinfo browser.
 
       icons          icon files that will be compiled into the
                      executable via a resource file.
 
     qterminal        Qt terminal widget
 
     languages        translation files and list of translators.
@@ -299,17 +321,17 @@ An overview of the directory layout of O
     fntests.m        script to run function tests embedded in C++ and .m
                      files
 
 ----
 John W. Eaton
 jwe@octave.org
 
 
-Last updated: Thu, 10 Jan 2013 10:46:41 EST
+Last updated: Wed, 15 May 2013 03:02:45 EDT
 
 
 ################################################################################
 
 Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
diff --git a/libgui/qterminal/libqterminal/QTerminal.h b/libgui/qterminal/libqterminal/QTerminal.h
--- a/libgui/qterminal/libqterminal/QTerminal.h
+++ b/libgui/qterminal/libqterminal/QTerminal.h
@@ -19,17 +19,17 @@ You should have received a copy of the G
 along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef QTERMINAL_H
 #define QTERMINAL_H
 
 #include <QSettings>
-#include <QtGlobal>
+#include <QKeySequence>
 #include <QWidget>
 #include <QStringList>
 #include <QColor>
 #include <QList>
 #include <QMenu>
 
 class QTerminal : public QWidget
 {
@@ -71,16 +71,20 @@ public:
 
   virtual void setForegroundColor (const QColor& color) = 0;
 
   virtual void setSelectionColor (const QColor& color) = 0;
 
   virtual void setCursorColor (bool useForegroundColor,
                                const QColor& color) = 0;
 
+signals:
+
+  void report_status_message (const QString&);
+
 public slots:
 
   virtual void copyClipboard (void) = 0;
 
   virtual void pasteClipboard (void) = 0;
 
   virtual void handleCustomContextMenuRequested (const QPoint& at)
   {
@@ -89,28 +93,42 @@ public slots:
   }
 
   void notice_settings (const QSettings *settings);
 
 protected:
 
   QTerminal (QWidget *xparent = 0) : QWidget (xparent)
   {
-    connect (this, SIGNAL (customContextMenuRequested (QPoint)),
-             this, SLOT (handleCustomContextMenuRequested (QPoint)));
-
     setContextMenuPolicy (Qt::CustomContextMenu);
 
     _contextMenu = new QMenu (this);
 
-    QAction *copyAction  = _contextMenu->addAction ("Copy");
-    QAction *pasteAction = _contextMenu->addAction ("Paste");
+    QAction *copyAction 
+      = _contextMenu->addAction (tr ("Copy"),
+                                 this, SLOT (copyClipboard ()));
+
+    QAction *pasteAction
+      = _contextMenu->addAction (tr ("Paste"),
+                                 this, SLOT (pasteClipboard ()));
+
+    connect (this, SIGNAL (customContextMenuRequested (QPoint)),
+             this, SLOT (handleCustomContextMenuRequested (QPoint)));
 
-    connect (copyAction, SIGNAL (triggered()), this, SLOT (copyClipboard()));
-    connect (pasteAction, SIGNAL (triggered()), this, SLOT (pasteClipboard()));
+    connect (this, SIGNAL (report_status_message (const QString&)),
+             xparent, SLOT (report_status_message (const QString&)));
+
+    connect (xparent, SIGNAL (settings_changed (const QSettings *)),
+             this, SLOT (notice_settings (const QSettings *)));
+
+    connect (xparent, SIGNAL (copyClipboard_signal ()),
+             this, SLOT (copyClipboard ()));
+
+    connect (xparent, SIGNAL (pasteClipboard_signal ()),
+             this, SLOT (pasteClipboard ()));
   }
 
 private:
 
     QMenu *_contextMenu;
 };
 
 #endif // QTERMINAL_H
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.cpp b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalView.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
@@ -2259,17 +2259,26 @@ void TerminalView::setSelection(const QS
 }
 
 void TerminalView::copyClipboard()
 {
   if ( !_screenWindow )
     return;
 
   QString text = _screenWindow->selectedText(_preserveLineBreaks);
-  QApplication::clipboard()->setText(text);
+
+  if (text.isEmpty ())
+    {
+      // FIXME -- interrupt is only appropriate here if CTRL-C is bound
+      // to the copy action.  How can we determine that?
+
+      ::raise (SIGINT);
+    }
+  else
+    QApplication::clipboard()->setText(text);
 }
 
 void TerminalView::pasteClipboard()
 {
   emitSelection(false,false);
 }
 
 void TerminalView::pasteSelection()
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
@@ -38,16 +38,17 @@ along with Foobar.  If not, see <http://
 #include <fcntl.h>
 #include <io.h>
 #include <stdio.h>
 #include <stdarg.h>
 #define WIN32_LEAN_AND_MEAN
 #define _WIN32_WINNT 0x0500 
 #include <windows.h>
 #include <cstring>
+#include <csignal>
 #include <limits>
 
 #include "QWinTerminalImpl.h"
 #include "QTerminalColors.h"
 
 // Uncomment to log activity to LOGFILENAME
 // #define DEBUG_QCONSOLE
 #define LOGFILENAME "QConsole.log"
@@ -166,16 +167,17 @@ private:
   QPoint m_cursorPos;
   bool m_cursorBlinking;
   bool m_hasBlinkingCursor;
   QTimer *m_blinkCursorTimer;
   KeyboardCursorType m_cursorType;
 
   QPoint m_beginSelection;
   QPoint m_endSelection;
+  bool m_settingSelection;
 
   QColor m_selectionColor;
   QColor m_cursorColor;
 
   HANDLE m_stdOut;
   HWND m_consoleWindow;
   CHAR_INFO* m_buffer;
   CHAR_INFO* m_tmpBuffer;
@@ -197,17 +199,18 @@ static void maybeSwapPoints (QPoint& beg
     qSwap (begin, end);
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 QConsolePrivate::QConsolePrivate (QWinTerminalImpl* parent, const QString& cmd)
   : q (parent), m_command (cmd), m_hasBlinkingCursor (true),
     m_cursorType (BlockCursor), m_beginSelection (0, 0),
-    m_endSelection (0, 0), m_process (NULL), m_inWheelEvent (false)
+    m_endSelection (0, 0), m_settingSelection (false),
+    m_process (NULL), m_inWheelEvent (false)
 {
   log (NULL);
 
   // Possibly detach from any existing console
   log ("Detaching from existing console (if any)...\n");
   FreeConsole ();
   log ("Closing standard IO...\n");
   closeStandardIO (0, STD_INPUT_HANDLE, "STDIN");
@@ -1172,34 +1175,43 @@ QWinTerminalImpl::QWinTerminalImpl (cons
 
 QWinTerminalImpl::~QWinTerminalImpl (void)
 {
   delete d;
 }
 
 void QWinTerminalImpl::mouseMoveEvent (QMouseEvent *event)
 {
-  d->m_endSelection = d->posToCell (event->pos ());
+  if (d->m_settingSelection)
+    {
+      d->m_endSelection = d->posToCell (event->pos ());
 
-  updateSelection ();
+      updateSelection ();
+    }
 }
 
 void QWinTerminalImpl::mousePressEvent (QMouseEvent *event)
 {
   if (event->button () == Qt::LeftButton)
-    d->m_beginSelection = d->posToCell (event->pos ());
+    {
+      d->m_settingSelection = true;
+
+      d->m_beginSelection = d->posToCell (event->pos ());
+    }
 }
 
 void QWinTerminalImpl::mouseReleaseEvent (QMouseEvent *event)
 {
   if (event->button () == Qt::LeftButton)
     {
       d->m_endSelection = d->posToCell (event->pos ());
 
       updateSelection ();
+
+      d->m_settingSelection = false;
     }
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::viewResizeEvent (QConsoleView*, QResizeEvent*)
 {
   d->updateConsoleSize (true);
@@ -1421,17 +1433,28 @@ void QWinTerminalImpl::setSize (int colu
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::copyClipboard (void)
 {
   QClipboard *clipboard = QApplication::clipboard ();
 
-  clipboard->setText (d->getSelection ());
+  QString selection = d->getSelection ();
+
+  if (selection.isEmpty ())
+    {
+      ::raise (SIGINT);
+    }
+  else
+    {
+      clipboard->setText (selection);
+
+      emit report_status_message (tr ("copied selection to clipboard"));
+    }
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::pasteClipboard (void)
 {
   QString text = QApplication::clipboard()->text (QClipboard::Clipboard);
 
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -438,16 +438,23 @@ FileDialog::FileDialog (const QStringLis
     }
   else if (multimode == "create") // uiputfile
     {
       setFileMode (QFileDialog::AnyFile); 
       setAcceptMode (QFileDialog::AcceptSave);
       setOption (QFileDialog::DontConfirmOverwrite, false);
       setConfirmOverwrite(true);
     }
+  else if (multimode == "dir")    // uigetdir
+    {
+      setFileMode (QFileDialog::Directory);
+      setOption (QFileDialog::ShowDirsOnly, true);
+      setOption (QFileDialog::HideNameFilterDetails, true);
+      setAcceptMode (QFileDialog::AcceptOpen);
+    }
   else                           // uigetfile multiselect=off
     {
       setFileMode (QFileDialog::ExistingFile);
       setAcceptMode (QFileDialog::AcceptOpen);
     }
 
   setNameFilters (filters);
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -22,19 +22,23 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #ifdef HAVE_QSCINTILLA
 
 #include <Qsci/qsciapis.h>
-// Not available in the Debian repos yet!
-// #include <Qsci/qscilexeroctave.h>
-#include "lexer-octave-gui.h"
+#if defined (HAVE_QSCI_QSCILEXEROCTAVE_H)
+#define HAVE_LEXER_OCTAVE
+#include <Qsci/qscilexeroctave.h>
+#elif defined (HAVE_QSCI_QSCILEXERMATLAB_H)
+#define HAVE_LEXER_MATLAB
+#include <Qsci/qscilexermatlab.h>
+#endif
 #include <Qsci/qscilexercpp.h>
 #include <Qsci/qscilexerbash.h>
 #include <Qsci/qscilexerperl.h>
 #include <Qsci/qscilexerbatch.h>
 #include <Qsci/qscilexerdiff.h>
 #include <Qsci/qsciprinter.h>
 #include "resource-manager.h"
 #include <QApplication>
@@ -205,55 +209,84 @@ file_editor_tab::handle_margin_clicked (
     }
 }
 
 void
 file_editor_tab::update_lexer ()
 {
   QsciLexer *lexer = _edit_area->lexer ();
   delete lexer;
+  lexer = 0;
 
   if (_file_name.endsWith (".m")
-      || _file_name.endsWith (".M")
       || _file_name.endsWith ("octaverc"))
     {
-      lexer = new lexer_octave_gui ();
-    }
-  else if (_file_name.endsWith (".c")
-           || _file_name.endsWith (".cc")
-           || _file_name.endsWith (".cpp")
-           || _file_name.endsWith (".cxx")
-           || _file_name.endsWith (".c++")
-           || _file_name.endsWith (".h")
-           || _file_name.endsWith (".hh")
-           || _file_name.endsWith (".hpp")
-           || _file_name.endsWith (".h++"))
-    {
-      lexer = new QsciLexerCPP ();
+#if defined (HAVE_LEXER_OCTAVE)
+      lexer = new QsciLexerOctave ();
+#elif defined (HAVE_LEXER_MATLAB)
+      lexer = new QsciLexerMatlab ();
+#endif
     }
-  else if (_file_name.endsWith (".pl"))
+
+  if (! lexer)
     {
-      lexer = new QsciLexerPerl ();
-    }
-  else if (_file_name.endsWith (".bat"))
-    {
-      lexer = new QsciLexerBatch ();
+      if (_file_name.endsWith (".c")
+          || _file_name.endsWith (".cc")
+          || _file_name.endsWith (".cpp")
+          || _file_name.endsWith (".cxx")
+          || _file_name.endsWith (".c++")
+          || _file_name.endsWith (".h")
+          || _file_name.endsWith (".hh")
+          || _file_name.endsWith (".hpp")
+          || _file_name.endsWith (".h++"))
+        {
+          lexer = new QsciLexerCPP ();
+        }
+      else if (_file_name.endsWith (".pl"))
+        {
+          lexer = new QsciLexerPerl ();
+        }
+      else if (_file_name.endsWith (".bat"))
+        {
+          lexer = new QsciLexerBatch ();
+        }
+      else if (_file_name.endsWith (".diff"))
+        {
+          lexer = new QsciLexerDiff ();
+        }
+      else
+        {
+          // FIXME -- why should the bash lexer be the default?
+          lexer = new QsciLexerBash ();
+        }
     }
-  else if (_file_name.endsWith (".diff"))
+
+  if (lexer)
     {
-      lexer = new QsciLexerDiff ();
-    }
-  else // Default to bash lexer.
-    {
-      lexer = new QsciLexerBash ();
+      QsciAPIs *apis = new QsciAPIs(lexer);
+      if (apis)
+        {
+          QString keyword;
+          QStringList keyword_list;
+          int i;
+          for (i=1; i<=3; i++) // load the first 3 keyword sets
+            {
+              keyword = QString(lexer->keywords (i));           // get list
+              keyword_list = keyword.split (QRegExp ("\\s+"));  // split
+              for (i = 0; i < keyword_list.size (); i++)        // add to API
+                apis->add (keyword_list.at (i));
+            }
+          apis->prepare ();
+        }
     }
 
   QSettings *settings = resource_manager::get_settings ();
   if (settings)
     lexer->readSettings (*settings);
+
   _edit_area->setLexer (lexer);
 
 }
 
 // slot for fetab_set_focus: sets the focus to the current edit area
 void
 file_editor_tab::set_focus (const QWidget *ID)
 {
@@ -1055,18 +1088,40 @@ file_editor_tab::notice_settings (const 
 
   update_lexer ();
 
   QFontMetrics lexer_font_metrics (_edit_area->lexer ()->defaultFont (0));
 
   _edit_area->setCaretLineVisible
     (settings->value ("editor/highlightCurrentLine", true).toBool ());
 
-  if (settings->value ("editor/codeCompletion", true).toBool ())
-    _edit_area->setAutoCompletionThreshold (1);
+  if (settings->value ("editor/codeCompletion", true).toBool ())  // auto compl.
+    {
+      bool match_keywords = settings->value
+        ("editor/codeCompletion_keywords",true).toBool ();
+      bool match_document = settings->value
+        ("editor/codeCompletion_document",true).toBool ();
+
+      QsciScintilla::AutoCompletionSource source = QsciScintilla::AcsNone;
+      if (match_keywords)
+        if (match_document)
+          source = QsciScintilla::AcsAll;
+        else
+          source = QsciScintilla::AcsAPIs;
+      else
+        if (match_document)
+          source = QsciScintilla::AcsDocument;
+      _edit_area->setAutoCompletionSource (source);
+
+      _edit_area->setAutoCompletionReplaceWord
+        (settings->value ("editor/codeCompletion_replace",false).toBool ());
+
+      _edit_area->setAutoCompletionThreshold
+        (settings->value ("editor/codeCompletion_threshold",2).toInt ());
+    }
   else
     _edit_area->setAutoCompletionThreshold (-1);
 
   if (settings->value ("editor/showLineNumbers", true).toBool ())
     {
       _edit_area->setMarginLineNumbers (2, true);
       _edit_area->setMarginWidth (2, lexer_font_metrics.width ("9999"));
     }
diff --git a/libgui/src/m-editor/lexer-octave-gui.cc b/libgui/src/m-editor/lexer-octave-gui.cc
deleted file mode 100644
--- a/libgui/src/m-editor/lexer-octave-gui.cc
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#ifdef HAVE_QSCINTILLA
-
-#include "lexer-octave-gui.h"
-#include <qcolor.h>
-#include <qfont.h>
-
-// -----------------------------------------------------
-// Some basic functions
-// -----------------------------------------------------
-lexer_octave_gui::lexer_octave_gui (QObject *p)
-  : QsciLexer (p)
-{
-  // The API info that is used for auto completion
-  // TODO: Where to store a file with API info (raw or prepared?)?
-  // TODO: Also provide infos on octave-forge functions?
-  // TODO: Also provide infos on function parameters?
-  // By now, use the keywords-list from syntax highlighting
-  QString keyword;
-  QStringList keywordList;
-  keyword = this->keywords (1);           // get whole string with all keywords
-  keywordList = keyword.split (QRegExp ("\\s+"));  // split into single strings
-  lexer_api = new QsciAPIs (this);
-  if (lexer_api)
-    {
-      for (int i = 0; i < keywordList.size (); i++)  // add all keywords to API
-        lexer_api->add (keywordList.at (i));
-      lexer_api->prepare ();   // prepare API info ... this may take some time
-    }
-}
-
-lexer_octave_gui::~lexer_octave_gui()
-{
-  if (lexer_api)
-    delete lexer_api;
-}
-
-// -----------------------------------------------------------------------------
-// Redefined functions to make an octave lexer from the abtract class Qscilexer.
-//   Scintilla has an octave/matlab-lexer but the interface in Qscintilla is
-//   only available in version 2.5.1. Redefining the following purely virtual
-//   functions of the class QsciLexer () and the enum of available styles (see
-//   lexer-octave-gui.h provides the functionality of the octave lexer.
-// -----------------------------------------------------------------------------
-const char *
-lexer_octave_gui::language() const
-{
-  return "Octave";  // return the name of the language
-}
-
-const char *
-lexer_octave_gui::lexer() const
-{
-  return "octave";  // return the name of the lexer
-}
-
-QString
-lexer_octave_gui::description(int style) const
-{
-    switch (style)
-    {
-    case Default:
-        return tr("Default");
-    case Comment:
-        return tr("Comment");
-    case Command:
-        return tr("Command");
-    case Number:
-        return tr("Number");
-    case Keyword:
-        return tr("Keyword");
-    case SingleQuotedString:
-        return tr("Single-quoted string");
-    case Operator:
-        return tr("Operator");
-    case Identifier:
-        return tr("Identifier");
-    case DoubleQuotedString:
-        return tr("Double-quoted string");
-    }
-    return QString();  // no valid style, return empty string
-}
-
-
-// -----------------------------------------------------
-// The set of default colors
-// -----------------------------------------------------
-QColor
-lexer_octave_gui::defaultColor (int style) const
-{
-  switch (style)
-    {
-      case Default:
-      case Operator:
-        return QColor (0x00,0x00,0x00);
-
-      case Comment:
-        return QColor (0x00,0x7f,0x00);
-
-      case Command:
-        return QColor (0x7f,0x7f,0x00);
-
-      case Number:
-        return QColor (0x00,0x7f,0x7f);
-
-      case Keyword:
-        return QColor (0x00,0x00,0x7f);
-
-      case SingleQuotedString:
-      case DoubleQuotedString:
-        return QColor (0x7f,0x00,0x7f);
-    }
-
-    return QsciLexer::defaultColor (style);
-}
-
-// -----------------------------------------------------
-// The defaulot fonts
-// -----------------------------------------------------
-QFont
-lexer_octave_gui::defaultFont (int style) const
-{
-  QFont f;
-
-  switch (style)
-    {
-      case Keyword:
-        f = QsciLexer::defaultFont (style);
-        f.setBold(true);
-        break;
-
-      default:
-        f = QsciLexer::defaultFont (style);
-    }
-
-  return f;
-}
-
-// -----------------------------------------------------
-//  The style used for braces
-// -----------------------------------------------------
-int
-lexer_octave_gui::braceStyle() const
-{
-    return Operator;
-}
-
-// -----------------------------------------------------
-// The set of keywords for highlighting
-// -----------------------------------------------------
-const char *
-lexer_octave_gui::keywords(int set) const
-{
-  if (set == 1)
-      return resource_manager::octave_keywords ();
-
-  return 0;
-}
-
-#endif
diff --git a/libgui/src/m-editor/lexer-octave-gui.h b/libgui/src/m-editor/lexer-octave-gui.h
deleted file mode 100644
--- a/libgui/src/m-editor/lexer-octave-gui.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef LEXEROCTAVE_H
-#define LEXEROCTAVE_H
-
-#include "resource-manager.h"
-#include <QObject>
-#include <Qsci/qsciglobal.h>
-#include <Qsci/qscilexer.h>
-#include <Qsci/qsciapis.h>
-
-class lexer_octave_gui : public QsciLexer
-{
-  Q_OBJECT
-
-public:
-
-  enum {
-        Default = 0,
-        Comment = 1,
-        Command = 2,
-        Number = 3,
-        Keyword = 4,
-        SingleQuotedString = 5,
-        Operator = 6,
-        Identifier = 7,
-        DoubleQuotedString = 8
-    };
-
-
-  lexer_octave_gui (QObject *parent = 0);
-  ~lexer_octave_gui ();
-  virtual const char *keywords (int set) const;
-  virtual const char *lexer () const;
-  virtual const char *language () const;
-  QString description (int style) const;
-  QColor defaultColor (int style) const;
-  QFont defaultFont (int style) const;
-  int braceStyle() const;
-
-private:
-  lexer_octave_gui (const lexer_octave_gui &);
-  lexer_octave_gui &operator= (const lexer_octave_gui &);
-  QsciAPIs *lexer_api;
-};
-
-#endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <QKeySequence>
 #include <QApplication>
 #include <QLabel>
 #include <QMenuBar>
 #include <QMenu>
 #include <QAction>
 #include <QSettings>
 #include <QStyle>
 #include <QToolBar>
@@ -625,16 +626,28 @@ main_window::connect_visibility_changed 
   file_browser_window->connect_visibility_changed ();
   doc_browser_window->connect_visibility_changed ();
 #ifdef HAVE_QSCINTILLA
   editor_window->connect_visibility_changed ();
 #endif
   workspace_window->connect_visibility_changed ();
 }
 
+void
+main_window::copyClipboard (void)
+{
+  emit copyClipboard_signal ();
+}
+
+void
+main_window::pasteClipboard (void)
+{
+  emit pasteClipboard_signal ();
+}
+
 // Connect the signals emitted when the Octave thread wants to create
 // a dialog box of some sort.  Perhaps a better place for this would be
 // as part of the QUIWidgetCreator class.  However, mainWindow currently
 // is not a global variable and not accessible for connecting.
 
 void
 main_window::connect_uiwidget_links ()
 {
@@ -814,30 +827,32 @@ main_window::construct (void)
     win_y = 720;
 
   setGeometry (0, 0, win_x, win_y);
 
   setStatusBar (status_bar);
 
   construct_octave_qt_link ();
 
+#ifdef HAVE_QSCINTILLA
   connect (this,
            SIGNAL (insert_debugger_pointer_signal (const QString&, int)),
            editor_window,
            SLOT (handle_insert_debugger_pointer_request (const QString&, int)));
 
   connect (this,
            SIGNAL (delete_debugger_pointer_signal (const QString&, int)),
            editor_window,
            SLOT (handle_delete_debugger_pointer_request (const QString&, int)));
 
   connect (this,
            SIGNAL (update_breakpoint_marker_signal (bool, const QString&, int)),
            editor_window,
            SLOT (handle_update_breakpoint_marker_request (bool, const QString&, int)));
+#endif
 
   QDir curr_dir;
   set_current_working_directory (curr_dir.absolutePath ());
 
   octave_link::post_event (this, &main_window::resize_command_window_callback);
 }
 
 void
@@ -884,20 +899,22 @@ main_window::construct_octave_qt_link (v
            history_window, SLOT (clear_history (void)));
 
   connect (_octave_qt_link, SIGNAL (enter_debugger_signal ()),
            this, SLOT (handle_enter_debugger ()));
 
   connect (_octave_qt_link, SIGNAL (exit_debugger_signal ()),
            this, SLOT (handle_exit_debugger ()));
 
+#ifdef HAVE_QSCINTILLA
   connect (_octave_qt_link,
            SIGNAL (edit_file_signal (const QString&)),
            editor_window,
            SLOT (handle_edit_file_request (const QString&)));
+#endif
 
   connect (_octave_qt_link,
            SIGNAL (insert_debugger_pointer_signal (const QString&, int)),
            this,
            SLOT (handle_insert_debugger_pointer_request (const QString&, int)));
 
   connect (_octave_qt_link,
            SIGNAL (delete_debugger_pointer_signal (const QString&, int)),
@@ -941,18 +958,16 @@ main_window::construct_file_menu (QMenuB
 {
   QMenu *file_menu = p->addMenu (tr ("&File"));
 
   construct_new_menu (file_menu);
 
   _open_action
     = file_menu->addAction (QIcon (":/actions/icons/fileopen.png"),
                             tr ("Open..."));
-  _open_action->setShortcut (QKeySequence::Open);
-  _open_action->setShortcutContext (Qt::ApplicationShortcut);
 
 #ifdef HAVE_QSCINTILLA
   file_menu->addMenu (editor_window->get_mru_menu ());
 #endif
 
   file_menu->addSeparator ();
 
   QAction *load_workspace_action
@@ -970,18 +985,20 @@ main_window::construct_file_menu (QMenuB
   file_menu->addSeparator ();
 
   QAction *exit_action = file_menu->addAction (tr ("Exit"));
   exit_action->setShortcut (QKeySequence::Quit);
 
   connect (preferences_action, SIGNAL (triggered ()),
            this, SLOT (process_settings_dialog_request ()));
 
+#ifdef HAVE_QSCINTILLA
   connect (_open_action, SIGNAL (triggered ()),
            editor_window, SLOT (request_open_file ()));
+#endif
 
   connect (load_workspace_action, SIGNAL (triggered ()),
            this, SLOT (handle_load_workspace_request ()));
 
   connect (save_workspace_action, SIGNAL (triggered ()),
            this, SLOT (handle_save_workspace_request ()));
 
   connect (exit_action, SIGNAL (triggered ()),
@@ -998,21 +1015,23 @@ main_window::construct_new_menu (QMenu *
                            tr ("Script"));
 
   QAction *new_function_action = new_menu->addAction (tr ("Function"));
   new_function_action->setEnabled (true);
 
   QAction *new_figure_action = new_menu->addAction (tr ("Figure"));
   new_figure_action->setEnabled (true);
 
+#ifdef HAVE_QSCINTILLA
   connect (_new_script_action, SIGNAL (triggered ()),
            editor_window, SLOT (request_new_script ()));
 
   connect (new_function_action, SIGNAL (triggered ()),
            editor_window, SLOT (request_new_function ()));
+#endif
 
   connect (new_figure_action, SIGNAL (triggered ()),
            this, SLOT (handle_new_figure_request ()));
 }
 
 void
 main_window::construct_edit_menu (QMenuBar *p)
 {
@@ -1021,37 +1040,26 @@ main_window::construct_edit_menu (QMenuB
   QKeySequence ctrl_shift = Qt::ControlModifier + Qt::ShiftModifier;
 
   _undo_action
     = edit_menu->addAction (QIcon (":/actions/icons/undo.png"), tr ("Undo"));
   _undo_action->setShortcut (QKeySequence::Undo);
 
   edit_menu->addSeparator ();
 
-  _cut_action
-    = edit_menu->addAction (QIcon (":/actions/icons/editcut.png"), tr ("Cut"));
-  _cut_action->setShortcut (ctrl_shift + Qt::Key_X);
-
   _copy_action
-    = edit_menu->addAction (QIcon (":/actions/icons/editcopy.png"), tr ("Copy"));
+    = edit_menu->addAction (QIcon (":/actions/icons/editcopy.png"),
+                            tr ("Copy"), this, SLOT (copyClipboard ()));
   _copy_action->setShortcut (ctrl_shift + Qt::Key_C);
 
   _paste_action
-    = edit_menu->addAction (QIcon (":/actions/icons/editpaste.png"), tr ("Paste"));
+    = edit_menu->addAction (QIcon (":/actions/icons/editpaste.png"),
+                            tr ("Paste"), this, SLOT (pasteClipboard ()));
   _paste_action->setShortcut (ctrl_shift + Qt::Key_V);
 
-  QAction *select_all_action
-    = edit_menu->addAction (tr ("Select All"));
-  select_all_action->setEnabled (false); // TODO: Make this work.
-
-  QAction *delete_action
-    = edit_menu->addAction (tr ("Delete"));
-  delete_action->setShortcut (Qt::Key_Delete);
-  delete_action->setEnabled (false); // TODO: Make this work.
-
   edit_menu->addSeparator ();
 
   QAction *find_files_action
     = edit_menu->addAction (tr ("Find Files..."));
   find_files_action->setShortcut (ctrl_shift + Qt::Key_F);
 
   edit_menu->addSeparator ();
 
@@ -1059,22 +1067,16 @@ main_window::construct_edit_menu (QMenuB
     = edit_menu->addAction (tr ("Clear Command Window"));
 
   QAction *clear_command_history
     = edit_menu->addAction(tr ("Clear Command History"));
 
   QAction *clear_workspace_action
     = edit_menu->addAction (tr ("Clear Workspace"));
 
-  connect (_copy_action, SIGNAL (triggered()),
-           command_window, SLOT (copyClipboard ()));
-
-  connect (_paste_action, SIGNAL (triggered()),
-           command_window, SLOT (pasteClipboard ()));
-
   connect (find_files_action, SIGNAL (triggered()),
            this, SLOT (find_files ()));
 
   connect (clear_command_window_action, SIGNAL (triggered ()),
            this, SLOT (handle_clear_command_window_request ()));
 
   connect (clear_command_history, SIGNAL (triggered ()),
            this, SLOT (handle_clear_history_request ()));
@@ -1254,18 +1256,20 @@ main_window::construct_window_menu (QMen
            workspace_window, SLOT (focus ()));
 
   connect (history_action, SIGNAL (triggered ()),
            history_window, SLOT (focus ()));
 
   connect (file_browser_action, SIGNAL (triggered ()),
            file_browser_window, SLOT (focus ()));
 
+#ifdef HAVE_QSCINTILLA
   connect (editor_action, SIGNAL (triggered ()),
            editor_window, SLOT (focus ()));
+#endif
 
   connect (documentation_action, SIGNAL (triggered ()),
            doc_browser_window, SLOT (focus ()));
 
   connect (reset_windows_action, SIGNAL (triggered ()),
            this, SLOT (reset_windows ()));
 }
 
@@ -1329,17 +1333,16 @@ main_window::construct_tool_bar (void)
   _main_tool_bar = addToolBar ("Main");
 
   _main_tool_bar->setObjectName ("MainToolBar");
   _main_tool_bar->addAction (_new_script_action);
   _main_tool_bar->addAction (_open_action);
 
   _main_tool_bar->addSeparator ();
 
-  _main_tool_bar->addAction (_cut_action);
   _main_tool_bar->addAction (_copy_action);
   _main_tool_bar->addAction (_paste_action);
   _main_tool_bar->addAction (_undo_action);
 
   _main_tool_bar->addSeparator ();
 
   _current_directory_combo_box = new QComboBox (this);
   _current_directory_combo_box->setFixedWidth (current_directory_width);
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -81,16 +81,19 @@ signals:
   void new_file_signal (const QString&);
   void open_file_signal (const QString&);
 
   void insert_debugger_pointer_signal (const QString& file, int line);
   void delete_debugger_pointer_signal (const QString& file, int line);
   void update_breakpoint_marker_signal (bool insert, const QString& file,
                                         int line);
 
+  void copyClipboard_signal (void);
+  void pasteClipboard_signal (void);
+
 public slots:
   void report_status_message (const QString& statusMessage);
   void handle_save_workspace_request (void);
   void handle_load_workspace_request (const QString& file = QString ());
   void handle_clear_command_window_request (void);
   void handle_clear_workspace_request (void);
   void handle_clear_history_request (void);
   void handle_rename_variable_request (const QString& old_name,
@@ -133,16 +136,19 @@ public slots:
   void handle_update_breakpoint_marker_request (bool insert,
                                                 const QString& file, int line);
 
   void read_settings (void);
   void set_window_layout (QSettings *settings);
   void write_settings (void);
   void connect_visibility_changed (void);
 
+  void copyClipboard (void);
+  void pasteClipboard (void);
+
   void connect_uiwidget_links ();
 
   void handle_create_dialog (const QString& message, const QString& title,
                              const QString& icon, const QStringList& button,
                              const QString& defbutton,
                              const QStringList& role);
 
   void handle_create_listview (const QStringList& list, const QString& mode,
@@ -251,17 +257,16 @@ private:
   QAction *_debug_step_into;
   QAction *_debug_step_over;
   QAction *_debug_step_out;
   QAction *_debug_quit;
 
   QAction *_new_script_action;
   QAction *_open_action;
 
-  QAction *_cut_action;
   QAction *_copy_action;
   QAction *_paste_action;
   QAction *_undo_action;
 
   // Toolbars.
   QComboBox *_current_directory_combo_box;
   static const int current_directory_width = 300;
   static const int current_directory_max_visible = 16;
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -64,18 +64,17 @@ octave_gui_ICONS = \
 
 octave_gui_MOC =
 
 if AMCOND_HAVE_QSCINTILLA
 octave_gui_MOC += \
   src/m-editor/moc-file-editor-interface.cc \
   src/m-editor/moc-file-editor-tab.cc \
   src/m-editor/moc-file-editor.cc \
-  src/m-editor/moc-find-dialog.cc \
-  src/m-editor/moc-lexer-octave-gui.cc
+  src/m-editor/moc-find-dialog.cc
 endif
 
 octave_gui_MOC += \
   src/moc-dialog.cc \
   src/moc-documentation-dock-widget.cc \
   src/moc-files-dock-widget.cc \
   src/moc-history-dock-widget.cc \
   src/moc-main-window.cc \
@@ -106,17 +105,16 @@ noinst_HEADERS += \
   src/octave-dock-widget.h \
   src/documentation-dock-widget.h \
   src/files-dock-widget.h \
   src/history-dock-widget.h \
   src/m-editor/file-editor-interface.h \
   src/m-editor/file-editor-tab.h \
   src/m-editor/file-editor.h \
   src/m-editor/find-dialog.h \
-  src/m-editor/lexer-octave-gui.h \
   src/main-window.h \
   src/octave-gui.h \
   src/octave-main-thread.h \
   src/octave-qt-link.h \
   src/qtinfo/parser.h \
   src/qtinfo/webinfo.h \
   src/resource-manager.h \
   src/settings-dialog.h \
@@ -131,17 +129,16 @@ noinst_HEADERS += \
 src_libgui_src_la_SOURCES = \
   src/dialog.cc \
   src/documentation-dock-widget.cc \
   src/files-dock-widget.cc \
   src/history-dock-widget.cc \
   src/m-editor/file-editor-tab.cc \
   src/m-editor/file-editor.cc \
   src/m-editor/find-dialog.cc \
-  src/m-editor/lexer-octave-gui.cc \
   src/main-window.cc \
   src/octave-gui.cc \
   src/octave-main-thread.cc \
   src/octave-qt-link.cc \
   src/qtinfo/parser.cc \
   src/qtinfo/webinfo.cc \
   src/resource-manager.cc \
   src/settings-dialog.cc \
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <QtGui/QApplication>
 #include <QTranslator>
 
 #include <iostream>
 
+#include <unistd.h>
 #include <fcntl.h>
 
 #if defined (HAVE_SYS_IOCTL_H)
 #include <sys/ioctl.h>
 #endif
 
 #include "lo-utils.h"
 #include "oct-env.h"
@@ -44,22 +45,17 @@ along with Octave; see the file COPYING.
 #include "main-window.h"
 #include "octave-gui.h"
 
 // Dissociate from the controlling terminal, if any.
 
 static void
 dissociate_terminal (void)
 {
-#if ! defined (__WIN32__) || defined (__CYGWIN__)
-# if defined (HAVE_SYS_IOCTL_H) && defined (TIOCNOTTY)
-
-  ioctl (0, TIOCNOTTY);
-
-# else
+#if ! (defined (__WIN32__) || defined (__APPLE__)) || defined (__CYGWIN__)
  
   pid_t pid = fork ();
 
   if (pid < 0)
     {
       std::cerr << "fork failed!" << std::endl;;
       exit (1);
     }
@@ -72,25 +68,27 @@ dissociate_terminal (void)
           std::cerr << "setsid error" << std::endl;
           exit (1);
         }
     }
   else
     {
       // Parent
 
+      // FIXME -- we should catch signals and pass them on to the child
+      // process in some way, possibly translating SIGINT to SIGTERM.
+
       int status;
 
       waitpid (pid, &status, 0);
 
       exit (octave_wait::ifexited (status)
             ? octave_wait::exitstatus (status) : 127);
     }
 
-# endif
 #endif
 }
 
 int
 octave_start_gui (int argc, char *argv[])
 {
   dissociate_terminal ();
 
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -30,16 +30,25 @@ along with Octave; see the file COPYING.
 #include "settings-dialog.h"
 #include "ui-settings-dialog.h"
 #include <QDir>
 #include <QFileInfo>
 #include <QVector>
 
 #ifdef HAVE_QSCINTILLA
 #include <QScrollArea>
+
+#if defined (HAVE_QSCI_QSCILEXEROCTAVE_H)
+#define HAVE_LEXER_OCTAVE
+#include <Qsci/qscilexeroctave.h>
+#elif defined (HAVE_QSCI_QSCILEXERMATLAB_H)
+#define HAVE_LEXER_MATLAB
+#include <Qsci/qscilexermatlab.h>
+#endif
+
 #include <Qsci/qscilexercpp.h>
 #include <Qsci/qscilexerbash.h>
 #include <Qsci/qscilexerperl.h>
 #include <Qsci/qscilexerbatch.h>
 #include <Qsci/qscilexerdiff.h>
 #endif
 
 settings_dialog::settings_dialog (QWidget *p):
@@ -79,16 +88,20 @@ settings_dialog::settings_dialog (QWidge
   ui->general_icon_graphic-> setChecked (widget_icon_set == "GRAPHIC");
   ui->general_icon_letter-> setChecked (widget_icon_set == "LETTER");
 
   ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor",false).toBool ());
   ui->customFileEditor->setText (settings->value ("customFileEditor").toString ());
   ui->editor_showLineNumbers->setChecked (settings->value ("editor/showLineNumbers",true).toBool () );
   ui->editor_highlightCurrentLine->setChecked (settings->value ("editor/highlightCurrentLine",true).toBool () );
   ui->editor_codeCompletion->setChecked (settings->value ("editor/codeCompletion",true).toBool () );
+  ui->editor_spinbox_ac_threshold->setValue (settings->value ("editor/codeCompletion_threshold",2).toInt ());
+  ui->editor_checkbox_ac_keywords->setChecked (settings->value ("editor/codeCompletion_keywords",true).toBool ());
+  ui->editor_checkbox_ac_document->setChecked (settings->value ("editor/codeCompletion_document",false).toBool ());
+  ui->editor_checkbox_ac_replace->setChecked (settings->value ("editor/codeCompletion_replace",false).toBool ());
   ui->editor_longWindowTitle->setChecked (settings->value ("editor/longWindowTitle",false).toBool ());
   ui->editor_restoreSession->setChecked (settings->value ("editor/restoreSession",true).toBool ());
   ui->terminal_fontName->setCurrentFont (QFont (settings->value ("terminal/fontName","Courier New").toString()) );
   ui->terminal_fontSize->setValue (settings->value ("terminal/fontSize",10).toInt ());
   ui->showFileSize->setChecked (settings->value ("filesdockwidget/showFileSize",false).toBool());
   ui->showFileType->setChecked (settings->value ("filesdockwidget/showFileType",false).toBool());
   ui->showLastModified->setChecked (settings->value ("filesdockwidget/showLastModified",false).toBool());
   ui->showHiddenFiles->setChecked (settings->value ("filesdockwidget/showHiddenFiles",false).toBool());
@@ -131,19 +144,25 @@ settings_dialog::settings_dialog (QWidge
   read_workspace_colors (settings);
 
   // terminal colors
   read_terminal_colors (settings);
 
 #ifdef HAVE_QSCINTILLA
   // editor styles: create lexer, read settings, and create dialog elements
   QsciLexer *lexer;
-  lexer = new lexer_octave_gui ();
+#if defined (HAVE_LEXER_OCTAVE)
+  lexer = new QsciLexerOctave ();
   read_lexer_settings (lexer,settings);
   delete lexer;
+#elif defined (HAVE_LEXER_MATLAB)
+  lexer = new QsciLexerMatlab ();
+  read_lexer_settings (lexer,settings);
+  delete lexer;
+#endif
   lexer = new QsciLexerCPP ();
   read_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerPerl ();
   read_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerBatch ();
   read_lexer_settings (lexer,settings);
@@ -354,16 +373,20 @@ settings_dialog::write_changed_settings 
 
   // other settings
   settings->setValue ("toolbar_icon_size", ui->toolbar_icon_size->value ());
   settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
   settings->setValue ("customFileEditor", ui->customFileEditor->text ());
   settings->setValue ("editor/showLineNumbers", ui->editor_showLineNumbers->isChecked ());
   settings->setValue ("editor/highlightCurrentLine", ui->editor_highlightCurrentLine->isChecked ());
   settings->setValue ("editor/codeCompletion", ui->editor_codeCompletion->isChecked ());
+  settings->setValue ("editor/codeCompletion_threshold", ui->editor_spinbox_ac_threshold->value ());
+  settings->setValue ("editor/codeCompletion_keywords", ui->editor_checkbox_ac_keywords->isChecked ());
+  settings->setValue ("editor/codeCompletion_document", ui->editor_checkbox_ac_document->isChecked ());
+  settings->setValue ("editor/codeCompletion_replace", ui->editor_checkbox_ac_replace->isChecked ());
   settings->setValue ("editor/longWindowTitle", ui->editor_longWindowTitle->isChecked());
   settings->setValue ("editor/restoreSession", ui->editor_restoreSession->isChecked ());
   settings->setValue ("terminal/fontSize", ui->terminal_fontSize->value());
   settings->setValue ("terminal/fontName", ui->terminal_fontName->currentFont().family());
   settings->setValue ("filesdockwidget/showFileSize", ui->showFileSize->isChecked ());
   settings->setValue ("filesdockwidget/showFileType", ui->showFileType->isChecked ());
   settings->setValue ("filesdockwidget/showLastModified", ui->showLastModified->isChecked ());
   settings->setValue ("filesdockwidget/showHiddenFiles", ui->showHiddenFiles->isChecked ());
@@ -387,19 +410,25 @@ settings_dialog::write_changed_settings 
     case 2: cursorType = "underline";  break;
     }
   settings->setValue ("terminal/cursorType", cursorType);
   settings->sync ();
 
 #ifdef HAVE_QSCINTILLA
   // editor styles: create lexer, get dialog contents, and write settings
   QsciLexer *lexer;
-  lexer = new lexer_octave_gui ();
+#if defined (HAVE_LEXER_OCTAVE)
+  lexer = new QsciLexerOctave ();
   write_lexer_settings (lexer,settings);
   delete lexer;
+#elif defined (HAVE_LEXER_MATLAB)
+  lexer = new QsciLexerMatlab ();
+  write_lexer_settings (lexer,settings);
+  delete lexer;
+#endif
   lexer = new QsciLexerCPP ();
   write_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerPerl ();
   write_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerBatch ();
   write_lexer_settings (lexer,settings);
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -20,18 +20,19 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifndef SETTINGSDIALOG_H
 #define SETTINGSDIALOG_H
 
 #include <QDialog>
 #include <QSettings>
+
 #ifdef HAVE_QSCINTILLA
-#include "lexer-octave-gui.h"
+class QsciLexer;
 #endif
 
 namespace Ui
 {
   class settings_dialog;
 }
 
 class settings_dialog:public QDialog
diff --git a/libgui/src/settings-dialog.ui b/libgui/src/settings-dialog.ui
--- a/libgui/src/settings-dialog.ui
+++ b/libgui/src/settings-dialog.ui
@@ -27,17 +27,17 @@
   </property>
   <property name="windowTitle">
    <string>Settings</string>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QTabWidget" name="tabWidget">
      <property name="currentIndex">
-      <number>3</number>
+      <number>0</number>
      </property>
      <widget class="QWidget" name="tab_4">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <attribute name="title">
        <string>General</string>
       </attribute>
@@ -191,20 +191,17 @@
       </widget>
      </widget>
      <widget class="QWidget" name="tab">
       <attribute name="title">
        <string>Editor</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_6">
        <item>
-        <layout class="QVBoxLayout" name="verticalLayout_5">
-         <item>
-          <layout class="QHBoxLayout" name="horizontalLayout_4"/>
-         </item>
+        <layout class="QVBoxLayout" name="verticalLayout_9">
          <item>
           <widget class="QCheckBox" name="editor_showLineNumbers">
            <property name="enabled">
             <bool>true</bool>
            </property>
            <property name="text">
             <string>Show line numbers</string>
            </property>
@@ -216,42 +213,167 @@
             <bool>true</bool>
            </property>
            <property name="text">
             <string>Highlight current line</string>
            </property>
           </widget>
          </item>
          <item>
-          <widget class="QCheckBox" name="editor_codeCompletion">
-           <property name="enabled">
-            <bool>true</bool>
-           </property>
-           <property name="text">
-            <string>Code completion</string>
-           </property>
-           <property name="checked">
-            <bool>false</bool>
-           </property>
-          </widget>
-         </item>
-         <item>
           <widget class="QCheckBox" name="editor_longWindowTitle">
            <property name="text">
             <string>Show complete path in window title</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="editor_restoreSession">
            <property name="text">
             <string>Restore tabs from previous session on startup</string>
            </property>
           </widget>
          </item>
+         <item>
+          <layout class="QGridLayout" name="gridLayout_2">
+           <item row="0" column="2">
+            <layout class="QHBoxLayout" name="horizontalLayout_2">
+             <property name="spacing">
+              <number>6</number>
+             </property>
+             <item>
+              <widget class="QLabel" name="editor_label_ac_threshold">
+               <property name="enabled">
+                <bool>false</bool>
+               </property>
+               <property name="text">
+                <string>Characters before list with suggestions is displayed</string>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QSpinBox" name="editor_spinbox_ac_threshold">
+               <property name="enabled">
+                <bool>false</bool>
+               </property>
+               <property name="toolTip">
+                <string/>
+               </property>
+               <property name="whatsThis">
+                <string/>
+               </property>
+               <property name="suffix">
+                <string/>
+               </property>
+               <property name="minimum">
+                <number>1</number>
+               </property>
+               <property name="maximum">
+                <number>6</number>
+               </property>
+               <property name="value">
+                <number>2</number>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <spacer name="horizontalSpacer_2">
+               <property name="orientation">
+                <enum>Qt::Horizontal</enum>
+               </property>
+               <property name="sizeHint" stdset="0">
+                <size>
+                 <width>40</width>
+                 <height>20</height>
+                </size>
+               </property>
+              </spacer>
+             </item>
+            </layout>
+           </item>
+           <item row="1" column="2">
+            <layout class="QHBoxLayout" name="horizontalLayout_4">
+             <item>
+              <widget class="QCheckBox" name="editor_checkbox_ac_keywords">
+               <property name="enabled">
+                <bool>false</bool>
+               </property>
+               <property name="text">
+                <string>Match keywords</string>
+               </property>
+               <property name="checked">
+                <bool>true</bool>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QCheckBox" name="editor_checkbox_ac_document">
+               <property name="enabled">
+                <bool>false</bool>
+               </property>
+               <property name="text">
+                <string>Match words in document</string>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <spacer name="horizontalSpacer_8">
+               <property name="orientation">
+                <enum>Qt::Horizontal</enum>
+               </property>
+               <property name="sizeHint" stdset="0">
+                <size>
+                 <width>40</width>
+                 <height>20</height>
+                </size>
+               </property>
+              </spacer>
+             </item>
+            </layout>
+           </item>
+           <item row="0" column="0">
+            <widget class="QCheckBox" name="editor_codeCompletion">
+             <property name="enabled">
+              <bool>true</bool>
+             </property>
+             <property name="text">
+              <string>Code completion</string>
+             </property>
+             <property name="checked">
+              <bool>false</bool>
+             </property>
+            </widget>
+           </item>
+           <item row="0" column="1">
+            <spacer name="horizontalSpacer_7">
+             <property name="orientation">
+              <enum>Qt::Horizontal</enum>
+             </property>
+             <property name="sizeType">
+              <enum>QSizePolicy::Fixed</enum>
+             </property>
+             <property name="sizeHint" stdset="0">
+              <size>
+               <width>20</width>
+               <height>0</height>
+              </size>
+             </property>
+            </spacer>
+           </item>
+           <item row="2" column="2">
+            <widget class="QCheckBox" name="editor_checkbox_ac_replace">
+             <property name="enabled">
+              <bool>false</bool>
+             </property>
+             <property name="text">
+              <string>Replace the rest of the actual word by suggested word</string>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </item>
         </layout>
        </item>
        <item>
         <spacer name="verticalSpacer">
          <property name="orientation">
           <enum>Qt::Vertical</enum>
          </property>
          <property name="sizeHint" stdset="0">
@@ -913,10 +1035,90 @@
      <y>383</y>
     </hint>
     <hint type="destinationlabel">
      <x>111</x>
      <y>413</y>
     </hint>
    </hints>
   </connection>
+  <connection>
+   <sender>editor_codeCompletion</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_label_ac_threshold</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>83</x>
+     <y>223</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>288</x>
+     <y>223</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>editor_codeCompletion</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_spinbox_ac_threshold</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>83</x>
+     <y>223</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>412</x>
+     <y>223</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>editor_codeCompletion</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_checkbox_ac_keywords</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>83</x>
+     <y>170</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>238</x>
+     <y>201</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>editor_codeCompletion</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_checkbox_ac_document</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>83</x>
+     <y>170</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>390</x>
+     <y>201</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>editor_codeCompletion</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_checkbox_ac_replace</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>83</x>
+     <y>170</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>427</x>
+     <y>229</y>
+    </hint>
+   </hints>
+  </connection>
  </connections>
 </ui>
diff --git a/libgui/src/terminal-dock-widget.cc b/libgui/src/terminal-dock-widget.cc
--- a/libgui/src/terminal-dock-widget.cc
+++ b/libgui/src/terminal-dock-widget.cc
@@ -31,60 +31,29 @@ terminal_dock_widget::terminal_dock_widg
   : octave_dock_widget (p), terminal (QTerminal::create (p))
 {
   terminal->setObjectName ("OctaveTerminal");
   terminal->setFocusPolicy (Qt::StrongFocus);
 
   setObjectName ("TerminalDockWidget");
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Command Window"));
+
   setWidget (terminal);
-
-  connect (this, SIGNAL (visibilityChanged (bool)),
-           this, SLOT (handle_visibility (bool)));
-
-  // Forward signals to QTerminal widget.
-
-  connect (this, SIGNAL (notice_settings_signal (const QSettings *)),
-           terminal, SLOT (notice_settings (const QSettings *)));
-
-  connect (this, SIGNAL (copyClipboard_signal (void)),
-           terminal, SLOT (copyClipboard (void)));
-
-  connect (this, SIGNAL (pasteClipboard_signal (void)),
-           terminal, SLOT (pasteClipboard (void)));
 }
 
 bool
 terminal_dock_widget::has_focus (void) const
 {
   QWidget *w = widget ();
 
   return w->hasFocus ();
 }
 
 void
-terminal_dock_widget::notice_settings (const QSettings *settings)
-{
-  emit notice_settings_signal (settings);
-}
-
-void
-terminal_dock_widget::copyClipboard (void)
-{
-  emit copyClipboard_signal ();
-}
-
-void
-terminal_dock_widget::pasteClipboard (void)
-{
-  emit pasteClipboard_signal ();
-}
-
-void
 terminal_dock_widget::focus (void)
 {
   octave_dock_widget::focus ();
 
   QWidget *w = widget ();
 
   w->setFocus ();
   w->activateWindow ();
diff --git a/libgui/src/terminal-dock-widget.h b/libgui/src/terminal-dock-widget.h
--- a/libgui/src/terminal-dock-widget.h
+++ b/libgui/src/terminal-dock-widget.h
@@ -34,34 +34,16 @@ class terminal_dock_widget : public octa
   Q_OBJECT
 
 public:
 
   terminal_dock_widget (QWidget *parent = 0);
 
   bool has_focus (void) const;
 
-signals:
-
-public slots:
-
-  void notice_settings (const QSettings *settings);
-
-  void copyClipboard (void);
-
-  void pasteClipboard (void);
-
   void focus (void);
 
-signals:
-
-  void notice_settings_signal (const QSettings *settings); 
-
-  void copyClipboard_signal (void);
-
-  void pasteClipboard_signal (void);
-
 private:
 
   QTerminal *terminal;
 };
 
 #endif // TERMINALDOCKWIDGET_H
diff --git a/libinterp/interp-core/ls-mat5.cc b/libinterp/interp-core/ls-mat5.cc
--- a/libinterp/interp-core/ls-mat5.cc
+++ b/libinterp/interp-core/ls-mat5.cc
@@ -76,16 +76,17 @@ along with Octave; see the file COPYING.
 
 #include "parse.h"
 #include "defaults.h"
 
 #ifdef HAVE_ZLIB
 #include <zlib.h>
 #endif
 
+#define READ_PAD(is_small_data_element, l) ((is_small_data_element) ? 4 : (((l)+7)/8)*8)
 #define PAD(l) (((l) > 0 && (l) <= 4) ? 4 : (((l)+7)/8)*8)
 #define INT8(l) ((l) == miINT8 || (l) == miUINT8 || (l) == miUTF8)
 
 
 // The subsystem data block
 static octave_value subsys_ov;
 
 // FIXME -- the following enum values should be the same as the
@@ -368,41 +369,42 @@ read_mat5_integer_data (std::istream& is
                         mat5_data_type type);
 
 #define OCTAVE_MAT5_INTEGER_READ(TYP) \
   { \
         TYP re (dims); \
   \
         std::streampos tmp_pos; \
   \
-        if (read_mat5_tag (is, swap, type, len)) \
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element)) \
           { \
             error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
         octave_idx_type n = re.numel (); \
         tmp_pos = is.tellg (); \
         read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
                                 static_cast<enum mat5_data_type> (type)); \
   \
         if (! is || error_state) \
           { \
             error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len))); \
+        is.seekg (tmp_pos + static_cast<std::streamoff>\
+                  (READ_PAD (is_small_data_element, len))); \
   \
         if (imag) \
           { \
             /* We don't handle imag integer types, convert to an array */ \
             NDArray im (dims); \
   \
-            if (read_mat5_tag (is, swap, type, len)) \
+            if (read_mat5_tag (is, swap, type, len, is_small_data_element)) \
               { \
                 error ("load: reading matrix data for '%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             n = im.numel (); \
             read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
@@ -422,20 +424,22 @@ read_mat5_integer_data (std::istream& is
   \
             tc = ctmp;  \
           } \
         else \
           tc = re; \
   }
 
 // Read one element tag from stream IS,
-// place the type code in TYPE and the byte count in BYTES
+// place the type code in TYPE, the byte count in BYTES and true (false) to 
+// IS_SMALL_DATA_ELEMENT if the tag is 4 (8) bytes long.
 // return nonzero on error
 static int
-read_mat5_tag (std::istream& is, bool swap, int32_t& type, int32_t& bytes)
+read_mat5_tag (std::istream& is, bool swap, int32_t& type, int32_t& bytes,
+               bool& is_small_data_element)
 {
   unsigned int upper;
   int32_t temp;
 
   if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
     goto data_read_error;
 
   if (swap)
@@ -443,24 +447,26 @@ read_mat5_tag (std::istream& is, bool sw
 
   upper = (temp >> 16) & 0xffff;
   type = temp & 0xffff;
 
   if (upper)
     {
       // "compressed" format
       bytes = upper;
+      is_small_data_element = true;
     }
   else
     {
       if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
         goto data_read_error;
       if (swap)
         swap_bytes<4> (&temp);
       bytes = temp;
+      is_small_data_element = false;
     }
 
   return 0;
 
  data_read_error:
   return 1;
 }
 
@@ -504,20 +510,21 @@ read_mat5_binary_element (std::istream& 
 
   // MAT files always use IEEE floating point
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
   if ((number == 1) ^ swap)
     flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
   else
     flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
 
-  // element type and length
+  // element type, length and small data element flag
   int32_t type = 0;
   int32_t element_length;
-  if (read_mat5_tag (is, swap, type, element_length))
+  bool is_small_data_element;
+  if (read_mat5_tag (is, swap, type, element_length, is_small_data_element))
     return retval;                      // EOF
 
   if (type == miCOMPRESSED)
     {
 #ifdef HAVE_ZLIB
       // If C++ allowed us direct access to the file descriptor of an
       // ifstream in a uniform way, the code below could be vastly
       // simplified, and additional copies of the data in memory
@@ -618,17 +625,18 @@ read_mat5_binary_element (std::istream& 
       tc = Matrix ();
       return retval;
     }
 
   pos = is.tellg ();
 
   // array flags subelement
   int32_t len;
-  if (read_mat5_tag (is, swap, type, len) || type != miUINT32 || len != 8)
+  if (read_mat5_tag (is, swap, type, len, is_small_data_element) ||
+      type != miUINT32 || len != 8 || is_small_data_element)
     {
       error ("load: invalid array flags subelement");
       goto early_read_error;
     }
 
   int32_t flags;
   read_int (is, swap, flags);
 
@@ -644,43 +652,45 @@ read_mat5_binary_element (std::istream& 
   read_int (is, swap, tmp_nzmax);   // max number of non-zero in sparse
   nzmax = tmp_nzmax;
 
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
-      if (read_mat5_tag (is, swap, type, dim_len) || type != miINT32)
+      if (read_mat5_tag (is, swap, type, dim_len, is_small_data_element) ||
+          type != miINT32)
         {
           error ("load: invalid dimensions array subelement");
           goto early_read_error;
         }
 
       int ndims = dim_len / 4;
       dims.resize (ndims);
       for (int i = 0; i < ndims; i++)
         {
           int32_t n;
           read_int (is, swap, n);
           dims(i) = n;
         }
 
       std::streampos tmp_pos = is.tellg ();
-      is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (dim_len) - dim_len));
+      is.seekg (tmp_pos + static_cast<std::streamoff>
+                (READ_PAD (is_small_data_element, dim_len) - dim_len));
     }
   else
     {
       // Why did mathworks decide to not have dims for a workspace!!!
       dims.resize (2);
       dims(0) = 1;
       dims(1) = 1;
     }
 
-  if (read_mat5_tag (is, swap, type, len) || !INT8(type))
+  if (read_mat5_tag (is, swap, type, len, is_small_data_element) || !INT8(type))
     {
       error ("load: invalid array name subelement");
       goto early_read_error;
     }
 
   {
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
@@ -688,17 +698,18 @@ read_mat5_binary_element (std::istream& 
 
     std::streampos tmp_pos = is.tellg ();
 
     if (len)
       {
         if (! is.read (name, len ))
           goto data_read_error;
 
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff>
+                  (READ_PAD (is_small_data_element, len)));
       }
 
     name[len] = '\0';
     retval = name;
   }
 
   switch (arrayclass)
     {
@@ -752,57 +763,59 @@ read_mat5_binary_element (std::istream& 
             ridx = sm.ridx ();
             cidx = sm.cidx ();
             data = sm.data ();
           }
 
         // row indices
         std::streampos tmp_pos;
 
-        if (read_mat5_tag (is, swap, type, len))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
             error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, ridx, nzmax, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
             error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff>
+                  (READ_PAD (is_small_data_element, len)));
 
         // col indices
-        if (read_mat5_tag (is, swap, type, len))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
             error ("load: reading sparse column data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, cidx, nc + 1, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
             error ("load: reading sparse column data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff>
+                  (READ_PAD (is_small_data_element, len)));
 
         // real data subelement
-        if (read_mat5_tag (is, swap, type, len))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
             error ("load: reading sparse matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
@@ -816,24 +829,25 @@ read_mat5_binary_element (std::istream& 
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
             error ("load: reading sparse matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff>
+                  (READ_PAD (is_small_data_element, len)));
 
         // imaginary data subelement
         if (imag)
           {
             NDArray im (dim_vector (static_cast<int> (nnz), 1));
 
-            if (read_mat5_tag (is, swap, type, len))
+            if (read_mat5_tag (is, swap, type, len, is_small_data_element))
               {
                 error ("load: reading sparse matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
@@ -1055,33 +1069,34 @@ read_mat5_binary_element (std::istream& 
         Octave_map m (dim_vector (1, 1));
         int n_fields = 2;
         string_vector field (n_fields);
 
         for (int i = 0; i < n_fields; i++)
           {
             int32_t fn_type;
             int32_t fn_len;
-            if (read_mat5_tag (is, swap, fn_type, fn_len) || !INT8(fn_type))
+            if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element) ||
+                !INT8(fn_type))
               {
                 error ("load: invalid field name subelement");
                 goto data_read_error;
               }
 
             OCTAVE_LOCAL_BUFFER (char, elname, fn_len + 1);
 
             std::streampos tmp_pos = is.tellg ();
 
             if (fn_len)
               {
                 if (! is.read (elname, fn_len))
                   goto data_read_error;
 
-                is.seekg (tmp_pos +
-                          static_cast<std::streamoff> (PAD (fn_len)));
+                is.seekg (tmp_pos + static_cast<std::streamoff>
+                          (READ_PAD (is_small_data_element, fn_len)));
               }
 
             elname[fn_len] = '\0';
 
             field(i) = elname;
           }
 
         std::vector<Cell> elt (n_fields);
@@ -1116,33 +1131,35 @@ read_mat5_binary_element (std::istream& 
         tc = m;
       }
       break;
 
     case MAT_FILE_OBJECT_CLASS:
       {
         isclass = true;
 
-        if (read_mat5_tag (is, swap, type, len) || !INT8(type))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element) ||
+            !INT8(type))
           {
             error ("load: invalid class name");
             goto skip_ahead;
           }
 
         {
           OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
           std::streampos tmp_pos = is.tellg ();
 
           if (len)
             {
               if (! is.read (name, len ))
                 goto data_read_error;
 
-              is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+              is.seekg (tmp_pos + static_cast<std::streamoff>
+                        (READ_PAD (is_small_data_element, len)));
             }
 
           name[len] = '\0';
           classname = name;
         }
       }
       // Fall-through
     case MAT_FILE_STRUCT_CLASS:
@@ -1152,41 +1169,43 @@ read_mat5_binary_element (std::istream& 
         int32_t fn_len;
         int32_t field_name_length;
 
         // field name length subelement -- actually the maximum length
         // of a field name.  The Matlab docs promise this will always
         // be 32.  We read and use the actual value, on the theory
         // that eventually someone will recognize that's a waste of
         // space.
-        if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT32)
+        if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element) ||
+            fn_type != miINT32)
           {
             error ("load: invalid field name length subelement");
             goto data_read_error;
           }
 
         if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len ))
           goto data_read_error;
 
         if (swap)
           swap_bytes<4> (&field_name_length);
 
         // field name subelement.  The length of this subelement tells
         // us how many fields there are.
-        if (read_mat5_tag (is, swap, fn_type, fn_len) || !INT8(fn_type))
+        if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element) ||
+            !INT8(fn_type))
           {
             error ("load: invalid field name subelement");
             goto data_read_error;
           }
 
         octave_idx_type n_fields = fn_len/field_name_length;
 
         if (n_fields > 0)
           {
-            fn_len = PAD (fn_len);
+            fn_len = READ_PAD (is_small_data_element, fn_len);
 
             OCTAVE_LOCAL_BUFFER (char, elname, fn_len);
 
             if (! is.read (elname, fn_len))
               goto data_read_error;
 
             std::vector<Cell> elt (n_fields);
 
@@ -1315,42 +1334,43 @@ read_mat5_binary_element (std::istream& 
     case MAT_FILE_SINGLE_CLASS:
       {
         FloatNDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
-        if (read_mat5_tag (is, swap, type, len))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff>
+                  (READ_PAD (is_small_data_element, len)));
 
         if (imag)
           {
             // imaginary data subelement
 
             FloatNDArray im (dims);
 
-            if (read_mat5_tag (is, swap, type, len))
+            if (read_mat5_tag (is, swap, type, len, is_small_data_element))
               {
                 error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
@@ -1381,34 +1401,35 @@ read_mat5_binary_element (std::istream& 
     default:
       {
         NDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
-        if (read_mat5_tag (is, swap, type, len))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff>
+                  (READ_PAD (is_small_data_element, len)));
 
         if (logicalvar)
           {
             // Logical variables can either be MAT_FILE_UINT8_CLASS or
             // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
             // variable and convert it.
 
             boolNDArray out (dims);
@@ -1419,17 +1440,17 @@ read_mat5_binary_element (std::istream& 
             tc = out;
           }
         else if (imag)
           {
             // imaginary data subelement
 
             NDArray im (dims);
 
-            if (read_mat5_tag (is, swap, type, len))
+            if (read_mat5_tag (is, swap, type, len, is_small_data_element))
               {
                 error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -142,23 +142,41 @@ object) relevant global values before an
         } \
       else \
         { \
           return curr_lexer->handle_op_internal (TOK, false, COMPAT); \
         } \
     } \
   while (0)
 
+#define CMD_OR_COMPUTED_ASSIGN_OP(PATTERN, TOK) \
+ \
+  do \
+    { \
+      curr_lexer->lexer_debug (PATTERN); \
+ \
+      if (curr_lexer->previous_token_may_be_command ()) \
+        { \
+          yyless (0); \
+          curr_lexer->push_start_state (COMMAND_START); \
+        } \
+      else \
+        { \
+          return curr_lexer->handle_incompatible_op (PATTERN, TOK, false); \
+        } \
+    } \
+  while (0)
+    
 #define CMD_OR_UNARY_OP(PATTERN, TOK, COMPAT) \
  \
   do \
     { \
       curr_lexer->lexer_debug (PATTERN); \
  \
-      if (curr_lexer->looks_like_command_arg ()) \
+      if (curr_lexer->previous_token_may_be_command ()) \
         { \
           yyless (0); \
           curr_lexer->push_start_state (COMMAND_START); \
         } \
       else \
         { \
           int tok \
             = (COMPAT \
@@ -732,41 +750,58 @@ ANY_INCLUDING_NL (.|{NL})
 %{
 // Superclass method identifiers.
 %}
 
 {IDENT}@{IDENT} |
 {IDENT}@{IDENT}.{IDENT} {
     curr_lexer->lexer_debug ("{IDENT}@{IDENT}|{IDENT}@{IDENT}.{IDENT}");
 
-    int id_tok = curr_lexer->handle_superclass_identifier ();
-
-    if (id_tok >= 0)
+    if (curr_lexer->previous_token_may_be_command ())
+      {
+        yyless (0);
+        curr_lexer->push_start_state (COMMAND_START);
+      }
+    else
       {
-        curr_lexer->looking_for_object_index = true;
-
-        return curr_lexer->count_token_internal (id_tok);
+        int id_tok = curr_lexer->handle_superclass_identifier ();
+
+        if (id_tok >= 0)
+          {
+            curr_lexer->looking_for_object_index = true;
+
+            return curr_lexer->count_token_internal (id_tok);
+          }
       }
   }
 
 %{
 // Metaclass query
 %}
 
 \?{IDENT} |
 \?{IDENT}\.{IDENT} {
     curr_lexer->lexer_debug ("\\?{IDENT}|\\?{IDENT}\\.{IDENT}");
 
-    int id_tok = curr_lexer->handle_meta_identifier ();
-
-    if (id_tok >= 0)
+    if (curr_lexer->previous_token_may_be_command ()
+        &&  curr_lexer->space_follows_previous_token ())
+      {
+        yyless (0);
+        curr_lexer->push_start_state (COMMAND_START);
+      }
+    else
       {
-        curr_lexer->looking_for_object_index = true;
-
-        return curr_lexer->count_token_internal (id_tok);
+        int id_tok = curr_lexer->handle_meta_identifier ();
+
+        if (id_tok >= 0)
+          {
+            curr_lexer->looking_for_object_index = true;
+
+            return curr_lexer->count_token_internal (id_tok);
+          }
       }
   }
 
 "@" {
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
         yyless (0);
@@ -823,16 +858,22 @@ ANY_INCLUDING_NL (.|{NL})
     curr_lexer->lexer_debug ("'");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
         yyless (0);
         curr_lexer->push_start_state (COMMAND_START);
       }
+    else if (curr_lexer->at_beginning_of_statement)
+      {
+        curr_lexer->current_input_column++;
+        int retval = curr_lexer->handle_string ('\'');
+        return curr_lexer->count_token_internal (retval);
+      }
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (curr_lexer->whitespace_is_significant ())
           {
             if (curr_lexer->space_follows_previous_token ())
               {
@@ -991,47 +1032,18 @@ ANY_INCLUDING_NL (.|{NL})
 
     return curr_lexer->handle_op (",", ',', at_beginning_of_statement);
   }
 
 ".'" {
     return curr_lexer->handle_op (".'", TRANSPOSE, false);
   }
 
-"++" {
-    curr_lexer->lexer_debug ("++");
-
-    int tok = curr_lexer->handle_incompatible_unary_op (PLUS_PLUS, false);
-
-    if (tok < 0)
-      {
-        yyless (0);
-        curr_lexer->xunput (',');
-        // Adjust for comma that was not really in the input stream.
-        curr_lexer->current_input_column--;
-      }
-    else
-      return tok;
-  }
-
-"--" {
-    curr_lexer->lexer_debug ("--");
-
-    int tok = curr_lexer->handle_incompatible_unary_op (MINUS_MINUS, false);
-
-    if (tok < 0)
-      {
-        yyless (0);
-        curr_lexer->xunput (',');
-        // Adjust for comma that was not really in the input stream.
-        curr_lexer->current_input_column--;
-      }
-    else
-      return tok;
-  }
+"++" { CMD_OR_UNARY_OP ("++", PLUS_PLUS, false); }
+"--" { CMD_OR_UNARY_OP ("--", MINUS_MINUS, false); }
 
 "(" {
     curr_lexer->lexer_debug ("(");
 
     bool unput_comma = false;
 
     if (curr_lexer->whitespace_is_significant ()
         && curr_lexer->space_follows_previous_token ())
@@ -1114,34 +1126,34 @@ ANY_INCLUDING_NL (.|{NL})
 %}
 
 "=" {
     curr_lexer->maybe_mark_previous_token_as_variable ();
 
     return curr_lexer->handle_op ("=", '=');
   }
 
-"+="   { return curr_lexer->handle_incompatible_op ("+=", ADD_EQ); }
-"-="   { return curr_lexer->handle_incompatible_op ("-=", SUB_EQ); }
-"*="   { return curr_lexer->handle_incompatible_op ("*=", MUL_EQ); }
-"/="   { return curr_lexer->handle_incompatible_op ("/=", DIV_EQ); }
-"\\="  { return curr_lexer->handle_incompatible_op ("\\=", LEFTDIV_EQ); }
-".+="  { return curr_lexer->handle_incompatible_op (".+=", ADD_EQ); }
-".-="  { return curr_lexer->handle_incompatible_op (".-=", SUB_EQ); }
-".*="  { return curr_lexer->handle_incompatible_op (".*=", EMUL_EQ); }
-"./="  { return curr_lexer->handle_incompatible_op ("./=", EDIV_EQ); }
-".\\=" { return curr_lexer->handle_incompatible_op (".\\=", ELEFTDIV_EQ); }
-"^="   { return curr_lexer->handle_incompatible_op ("^=", POW_EQ); }
-"**="  { return curr_lexer->handle_incompatible_op ("^=", POW_EQ); }
-".^="  { return curr_lexer->handle_incompatible_op (".^=", EPOW_EQ); }
-".**=" { return curr_lexer->handle_incompatible_op (".^=", EPOW_EQ); }
-"&="   { return curr_lexer->handle_incompatible_op ("&=", AND_EQ); }
-"|="   { return curr_lexer->handle_incompatible_op ("|=", OR_EQ); }
-"<<="  { return curr_lexer->handle_incompatible_op ("<<=", LSHIFT_EQ); }
-">>="  { return curr_lexer->handle_incompatible_op (">>=", RSHIFT_EQ); }
+"+="   { CMD_OR_COMPUTED_ASSIGN_OP ("+=", ADD_EQ); }
+"-="   { CMD_OR_COMPUTED_ASSIGN_OP ("-=", SUB_EQ); }
+"*="   { CMD_OR_COMPUTED_ASSIGN_OP ("*=", MUL_EQ); }
+"/="   { CMD_OR_COMPUTED_ASSIGN_OP ("/=", DIV_EQ); }
+"\\="  { CMD_OR_COMPUTED_ASSIGN_OP ("\\=", LEFTDIV_EQ); }
+".+="  { CMD_OR_COMPUTED_ASSIGN_OP (".+=", ADD_EQ); }
+".-="  { CMD_OR_COMPUTED_ASSIGN_OP (".-=", SUB_EQ); }
+".*="  { CMD_OR_COMPUTED_ASSIGN_OP (".*=", EMUL_EQ); }
+"./="  { CMD_OR_COMPUTED_ASSIGN_OP ("./=", EDIV_EQ); }
+".\\=" { CMD_OR_COMPUTED_ASSIGN_OP (".\\=", ELEFTDIV_EQ); }
+"^="   { CMD_OR_COMPUTED_ASSIGN_OP ("^=", POW_EQ); }
+"**="  { CMD_OR_COMPUTED_ASSIGN_OP ("^=", POW_EQ); }
+".^="  { CMD_OR_COMPUTED_ASSIGN_OP (".^=", EPOW_EQ); }
+".**=" { CMD_OR_COMPUTED_ASSIGN_OP (".^=", EPOW_EQ); }
+"&="   { CMD_OR_COMPUTED_ASSIGN_OP ("&=", AND_EQ); }
+"|="   { CMD_OR_COMPUTED_ASSIGN_OP ("|=", OR_EQ); }
+"<<="  { CMD_OR_COMPUTED_ASSIGN_OP ("<<=", LSHIFT_EQ); }
+">>="  { CMD_OR_COMPUTED_ASSIGN_OP (">>=", RSHIFT_EQ); }
 
 %{
 // In Matlab, '{' may also trigger command syntax.
 %}
 
 "{" {
     curr_lexer->lexer_debug ("{");
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -522,19 +522,19 @@ cell_or_matrix_row
 
 fcn_handle      : '@' FCN_HANDLE
                   {
                     $$ = parser.make_fcn_handle ($2);
                     lexer.looking_at_function_handle--;
                   }
                 ;
 
-anon_fcn_handle : '@' param_list statement
+anon_fcn_handle : '@' param_list stmt_begin statement
                   {
-                    $$ = parser.make_anon_fcn_handle ($2, $3);
+                    $$ = parser.make_anon_fcn_handle ($2, $4);
                     lexer.nesting_level.remove ();
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
@@ -863,34 +863,34 @@ if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
-if_cmd_list1    : expression opt_sep opt_list
+if_cmd_list1    : expression stmt_begin opt_sep opt_list
                   {
                     $1->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
 
-                    $$ = parser.start_if_command ($1, $3);
+                    $$ = parser.start_if_command ($1, $4);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
-elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
+elseif_clause   : ELSEIF stash_comment opt_sep expression stmt_begin opt_sep opt_list
                   {
                     $4->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
 
-                    $$ = parser.make_elseif_clause ($1, $4, $6, $2);
+                    $$ = parser.make_elseif_clause ($1, $4, $7, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
 
 // ================
@@ -921,58 +921,58 @@ case_list1      : switch_case
                   { $$ = new tree_switch_case_list ($1); }
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
-switch_case     : CASE stash_comment opt_sep expression opt_sep opt_list
-                  { $$ = parser.make_switch_case ($1, $4, $6, $2); }
+switch_case     : CASE stash_comment opt_sep expression stmt_begin opt_sep opt_list
+                  { $$ = parser.make_switch_case ($1, $4, $7, $2); }
                 ;
 
 default_case    : OTHERWISE stash_comment opt_sep opt_list
                   {
                     $$ = new tree_switch_case ($4, $2);
                   }
                 ;
 
 // =======
 // Looping
 // =======
 
-loop_command    : WHILE stash_comment expression opt_sep opt_list END
+loop_command    : WHILE stash_comment expression stmt_begin opt_sep opt_list END
                   {
                     $3->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
 
-                    if (! ($$ = parser.make_while_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = parser.make_while_command ($1, $3, $6, $7, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
                     if (! ($$ = parser.make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
                   }
-                | FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
+                | FOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (FOR, $1, $3, $5, 0,
-                                                  $7, $8, $2)))
+                                                  $8, $9, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (FOR, $1, $4, $6, 0,
                                                   $9, $10, $2)))
                       ABORT_PARSE;
                   }
-                | PARFOR stash_comment assign_lhs '=' expression opt_sep opt_list END
+                | PARFOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $3, $5,
-                                                  0, $7, $8, $2)))
+                                                  0, $8, $9, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $4, $6,
                                                   $8, $11, $12, $2)))
                       ABORT_PARSE;
                   }
@@ -1491,16 +1491,20 @@ enum_list       : class_enum
 class_enum      : identifier '(' expression ')'
                   { $$ = new tree_classdef_enum ($1, $3); }
                 ;
 
 // =============
 // Miscellaneous
 // =============
 
+stmt_begin      : // empty
+                  { lexer.at_beginning_of_statement = true; }
+                ;
+
 stash_comment   : // empty
                   { $$ = octave_comment_buffer::get_comment (); }
                 ;
 
 parse_error     : LEXICAL_ERROR
                   { parser.bison_error ("parse error"); }
                 | error
                 ;
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -154,16 +154,29 @@ tree_anon_fcn_handle::rvalue1 (int)
 %! g = @(t) feval (@(x) t*x, 2);
 %! assert (g(0.5) == 1);
 
 %!test
 %! h = @(x) sin (x);
 %! g = @(f, x) h (x);
 %! f = @() g (@(x) h, pi);
 %! assert (f () == sin (pi));
+
+The next two tests are intended to test parsing of a character string
+vs. hermitian operator at the beginning of an anonymous function
+expression.  The use of ' for the character string and the spacing is
+intentional, so don't change it.
+
+%!test
+%! f = @() 'foo';
+%! assert (f (), 'foo');
+
+%!test
+%! f = @()'foo';
+%! assert (f (), 'foo');
 */
 
 octave_value_list
 tree_anon_fcn_handle::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -211,17 +211,22 @@ tree_index_expression::get_struct_index
     {
       tree_expression *df = *p_dyn_field;
 
       if (df)
         {
           octave_value t = df->rvalue1 ();
 
           if (! error_state)
-            fn = t.string_value ();
+            {
+              if (t.is_string () && t.rows () == 1)
+                fn = t.string_value ();
+              else
+                error ("dynamic structure field names must be character strings");
+            }
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
 
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1573,16 +1573,17 @@ AC_DEFUN([OCTAVE_PROG_GPERF], [
   if test -z "$GPERF"; then
     GPERF='$(top_srcdir)/build-aux/missing gperf'
     warn_gperf="
 
 I didn't find gperf, but it's only a problem if you need to
 reconstruct oct-gperf.h 
 "
     OCTAVE_CONFIGURE_WARNING([warn_gperf])
+    GPERF='$(top_srcdir)/build-aux/missing gperf'
   fi
   AC_SUBST(GPERF)
 ])
 dnl
 dnl Check for makeinfo.
 dnl
 AC_DEFUN([OCTAVE_PROG_MAKEINFO], [
   dnl use MKINFO, not MAKEINFO, for variable name because Automake
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -78,17 +78,17 @@
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ##
 ## This program was originally granted to the public domain
 ##
 ## 2002-03-08 Paul Kienzle <pkienzle@users.sf.net>
 ## * Initial revision
 ## 2005-11-27 Bill Denney <bill@givebillmoney.com>
-## * Significant modifications of the input arguements for additional
+## * Significant modifications of the input arguments for additional
 ## functionality.
 
 function dlmwrite (file, M, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2012 Erik Kjellson
+## Copyright (C) 2012-2013 Erik Kjellson <erikiiofph7@users.sourceforge.net>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -54,17 +54,16 @@
 ##
 ## @item Wav file
 ##
 ## @end itemize
 ##
 ## @seealso{textscan, dlmread, csvread, load}
 ## @end deftypefn
 
-## Author: Erik Kjellson <erikiiofph7@users.sourceforge.net>
 
 function [output, delimiter, header_rows] = importdata (varargin)
 
   ## Default values
   fname   = "";
   delimiter  = "";
   header_rows = -1;
 
@@ -188,18 +187,18 @@ function [output, delimiter, header_rows
   output.data       = [];
   output.textdata   = [];
   output.rowheaders = [];
   output.colheaders = [];
 
   ## Read file into string and count the number of header rows
   file_content = fileread (fname);
 
-  ## Split the file into rows (using \r\n or \n as delimiters between rows).
-  file_content_rows = regexp (file_content, "\r?\n", "split");
+  ## Split the file into rows (using \n and/or \r as delimiters between rows).
+  file_content_rows = regexp (file_content, "\n|\n\r|\r|\r\n", "split");
 
   ## FIXME: guess delimiter, if it isn't defined
   if (isempty (delimiter))
     error ("importdata: Guessing delimiter is not implemented yet, you have to specify it.");
   endif
 
   ## FIXME: A more intelligent way to count number of header rows. This
   ## is needed e.g. when delimiter=' ' and the header contains spaces...
@@ -429,8 +428,21 @@ endfunction
 %! fputs (fid, "3.1\t-7.2\t0\r\n0.012\t6.5\t128");
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, "\\t");
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
+%!test
+%! # CR for line breaks
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1\t-7.2\t0\r0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -148,17 +148,17 @@ function [t, p] = orderfields (s1, s2)
   if (numel (s1) == 0)
     args = cell (1, 2 * numel (names));
     args(1:2:end) = names;
     args(2:2:end) = {[]};
     t = struct (args{:});
   else
     n = numel (s1);
     for i = 1:numel (names)
-      el = names(i);
+      el = names{i};
       [t(1:n).(el)] = s1(:).(el);
     endfor
     ## inherit dimensions
     t = reshape (t, size (s1));
   endif
 
 endfunction
 
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -28,25 +28,40 @@
 
 function retval = optimget (options, parname, default)
 
   if (nargin < 2 || nargin > 4 || ! isstruct (options) || ! ischar (parname))
     print_usage ();
   endif
 
   opts = __all_opts__ ();
-  idx = lookup (tolower (opts), tolower (parname), "m");
+  idx = strncmpi (opts, parname, numel (parname));
+
+  nmatch = sum (idx);
 
-  if (idx)
+  if (nmatch == 1)
     parname = opts{idx};
+  elseif (nmatch == 0)
+    warning ("unrecognized option: %s", parname);
   else
-    warning ("unrecognized option: %s", parname);
+    fmt = sprintf ("ambiguous option: %%s (%s%%s)",
+                   repmat ("%s, ", 1, nmatch-1));
+    warning (fmt, parname, opts{idx});
   endif
   if (isfield (options, parname))
     retval = options.(parname);
   elseif (nargin > 2)
     retval = default;
   else
     retval = [];
   endif
 
 endfunction
 
+%!error optimget ()
+
+%!shared opts
+%! opts = optimset ("tolx", 0.1, "maxit", 100);
+%!assert (optimget (opts, "TolX"), 0.1);
+%!assert (optimget (opts, "maxit"), 100);
+%!assert (optimget (opts, "MaxITer"), 100);
+%!warning (optimget (opts, "Max"));
+%!warning (optimget (opts, "foobar"));
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -126,27 +126,30 @@ function retval = optimset (varargin)
   elseif (nargs == 2 && isstruct (varargin{1}) && isstruct (varargin{2}))
     ## Set slots in old from nonempties in new.  Should we be checking
     ## to ensure that the field names are expected?
     old = varargin{1};
     new = varargin{2};
     fnames = fieldnames (old);
     ## skip validation if we're in the internal query
     validation = ! isempty (opts);
-    lopts = tolower (opts);
     for [val, key] = new
       if (validation)
         ## Case insensitive lookup in all options.
-        i = lookup (lopts, tolower (key));
+        i = strncmpi (opts, key, length (key));
+        nmatch = sum (i);
         ## Validate option.
-        if (i > 0 && strcmpi (opts{i}, key))
-          ## Use correct case.
-          key = opts{i};
+        if (nmatch == 1)
+          key = opts{find (i)};
+        elseif (nmatch == 0)
+          warning ("unrecognized option: %s", key);
         else
-          warning ("unrecognized option: %s", key);
+          fmt = sprintf ("ambiguous option: %%s (%s%%s)",
+                         repmat ("%s, ", 1, nmatch-1));
+          warning (fmt, key, opts{i});
         endif
       endif
       old.(key) = val;
     endfor
     retval = old;
   elseif (rem (nargs, 2) && isstruct (varargin{1}))
     ## Set values in old from name/value pairs.
     pairs = reshape (varargin(2:end), 2, []);
@@ -160,11 +163,12 @@ function retval = optimset (varargin)
     print_usage ();
   endif
 
 endfunction
 
 
 %!assert (optimget (optimset ("tolx", 1e-2), "tOLx"), 1e-2)
 %!assert (isfield (optimset ("tolFun", 1e-3), "TolFun"))
+%!warning (optimset ("Max", 10));
+%!warning (optimset ("foobar", 13));
 
 %!error (optimset ("%NOT_A_REAL_FUNCTION_NAME%"))
-
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -180,16 +180,19 @@ function h = findobj (varargin)
         na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
   endwhile
 
   numpairs = np - 1;
+  if (~ isempty (logicaloperator))
+    logicaloperator = shift (logicaloperator, 1);
+  endif
 
   ## Load all objects which qualify for being searched.
   idepth = 0;
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
       children = union (children, get (handles(n), "children"));
@@ -238,22 +241,50 @@ function h = findobj (varargin)
       endfor
     endfor
   endif
 
   h = h (keepers != 0);
   h = reshape (h, [numel(h), 1]);
 endfunction
 
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = plot (1:10);
+%!   set (h, "tag", "foobar")
+%!   g = findobj (gcf (), "tag", "foobar", "type", "line", "color", [0 0 1]);
+%!   assert (g, h)
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   obj = findobj (hf, "type", "line");
 %!   assert (l, obj);
 %!   assert (gca, findobj (hf, "type", "axes"));
 %!   assert (hf, findobj (hf, "type", "figure"));
 %!   assert (isempty (findobj (hf, "type", "xyzxyz")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   subplot (2, 2, 1)
+%!   imagesc (rand (10))
+%!   subplot (2, 2, 2)
+%!   surf (peaks)
+%!   subplot (2, 2, 3)
+%!   contour (peaks)
+%!   subplot (2, 2, 4)
+%!   plot (peaks)
+%!   h1 = findobj (gcf (), "-regexp", "Type", "image|surface|hggroup");
+%!   h2 = findobj (gcf (), "Type", "image", "-or", "Type", "surface", "-or", "Type", "hggroup");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+%! assert (h2, h1)
+
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -30,21 +30,21 @@
 ## @seealso{meshgrid}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth@marine.usf.edu>
 
 function varargout = ndgrid (varargin)
 
   if (nargin == 1)
-    n = max ([nargout, 2]);
+    n = max ([nargout, 1]);
     ## If only one input argument is given, repeat it n-times
     varargin(1:n) = varargin(1);
-  elseif (nargin >= nargout)
-    n = max ([nargin, 2]);
+  elseif (nargin > 0 && nargin >= nargout)
+    n = max ([nargin, 1]);
   else
     error ("ndgrid: wrong number of input arguments");
   endif
 
   ## Determine the size of the output arguments
 
   shape = zeros (1, n);
 
@@ -67,16 +67,27 @@ function varargout = ndgrid (varargin)
 
     varargout{i} = repmat (reshape (varargin{i}, r), s);
   endfor
 
 endfunction
 
 
 %!test
+%! x = 1:3;
+%! assert (isequal (ndgrid (x), x(:)));
+
+%!test
+%! x = 1:3;
+%! [XX, YY] = ndgrid (x);
+%! assert (size_equal (XX, YY));
+%! assert (isequal (XX, repmat(x(:), 1, numel(x))));
+%! assert (isequal (YY, repmat(x, numel(x), 1)));
+
+%!test
 %! x = 1:2;
 %! y = 1:3;
 %! z = 1:4;
 %! [XX, YY, ZZ] = ndgrid (x, y, z);
 %! assert (size_equal (XX, YY, ZZ));
 %! assert (ndims (XX), 3);
 %! assert (size (XX), [2, 3, 4]);
 %! assert (XX(1) * YY(1) * ZZ(1), x(1) * y(1) * z(1));
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -25,42 +25,56 @@
 ## used to customize the dialog title.
 ## @seealso{uigetfile, uiputfile}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function dirname = uigetdir (init_path = pwd, dialog_name = "Select Directory to Open")
 
-  defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
-  funcname = ["__uigetdir_", defaulttoolkit, "__"];
-  functype = exist (funcname);
-  if (! __is_function__ (funcname))
-    funcname = "__uigetdir_fltk__";
+  if (! __octave_link_enabled__ ())
+    defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
+    funcname = ["__uigetdir_", defaulttoolkit, "__"];
+    functype = exist (funcname);
     if (! __is_function__ (funcname))
-      error ("uigetdir: fltk graphics toolkit required");
-    elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uigetdir: no implementation for toolkit '%s', using 'fltk' instead",
-               defaulttoolkit);
+      funcname = "__uigetdir_fltk__";
+      if (! __is_function__ (funcname))
+        error ("uigetdir: fltk graphics toolkit required");
+      elseif (! strcmp (defaulttoolkit, "gnuplot"))
+        warning ("uigetdir: no implementation for toolkit '%s', using 'fltk' instead",
+                 defaulttoolkit);
+      endif
     endif
   endif
 
   if (nargin > 2)
     print_usage ();
   endif
 
   if (!ischar (init_path) || !ischar (dialog_name))
     error ("uigetdir: INIT_PATH and DIALOG_NAME must be string arguments");
   endif
 
   if (!isdir (init_path))
     init_path = fileparts (init_path);
   endif
-  dirname = feval (funcname, init_path, dialog_name);
+
+  if (__octave_link_enabled__ ())
+    file_filter = cell (0, 2);
+    default_file_name = "";
+    dialog_position = [240, 120];
+    dialog_mode = "dir";
 
+    [filename, dirname, filterindex] ...
+      = __octave_link_file_dialog__ (file_filter, dialog_name,
+                                     default_file_name, dialog_position,
+                                     dialog_mode, init_path);
+  else
+    dirname = feval (funcname, init_path, dialog_name);
+  endif
 endfunction
 
 
 %!demo
 %! uigetdir (pwd, 'Select Directory');
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
diff --git a/scripts/startup/inputrc b/scripts/startup/inputrc
--- a/scripts/startup/inputrc
+++ b/scripts/startup/inputrc
@@ -14,8 +14,13 @@
 ## history-search-forward:
 ## 
 ##   Search forward through the history for the string of characters
 ##   between the start of the current line and the point.  This is a
 ##   non-incremental search.  Bound to "\e[B", the ANSI escape
 ##   sequence for the DOWN arrow.
 
 "\e[B": history-search-forward
+
+## Disable so the usual paste shortcut will work on Windows systems.
+## \C-q should still be available for quoted insert.
+
+"\C-v": ""
diff --git a/test/for.tst b/test/for.tst
--- a/test/for.tst
+++ b/test/for.tst
@@ -104,8 +104,16 @@
 %! endfor
 
 %!test
 %! a = {1,3;2,4};
 %! j = 0;
 %! for i = cat (3, a, cellfun (@(x) 4 + x, a, "UniformOutput", 0))
 %!   assert (i, {1 + 2*j; 2 + 2*j++})
 %! endfor
+
+%% test parsing of single-quoted character string appearing at the
+%% beginning of a for loop
+%!test
+%! for i = 1:5
+%!   'foo';
+%! endfor
+%! assert (i, 5);
diff --git a/test/if.tst b/test/if.tst
--- a/test/if.tst
+++ b/test/if.tst
@@ -80,8 +80,27 @@
 %!   __printf_assert__ ("pass\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
 %! end
 %! assert (__prog_output_assert__ ("pass"));
 
+%% test parsing of single-quoted character string appearing at the
+%% beginning of an if condition
+%!test
+%! if (1)
+%!   'foo';
+%!   x = 13;
+%! endif
+%! assert (x, 13);
+
+%% test parsing of single-quoted character string appearing at the
+%% beginning of an if condition
+%!test
+%! if (0)
+%!   x = 42;
+%! elseif (1)
+%!   'foo';
+%!   x = 13;
+%! endif
+%! assert (x, 13);
diff --git a/test/switch.tst b/test/switch.tst
--- a/test/switch.tst
+++ b/test/switch.tst
@@ -88,8 +88,17 @@
 %!error <syntax error> eval ("switch endswitch")
 
 %% test/octave.test/switch/switch-5.m
 %!error <syntax error> eval ("switch case endswitch")
 
 %% test/octave.test/switch/switch-6.m
 %!error <syntax error> eval ("switch 1 default 1; endswitch")
 
+%% test parsing of single-quoted character string appearing immediately
+%% after a switch case
+%!test
+%! switch (1)
+%!   case 1
+%!     'foo';
+%!     x = 13;
+%! endswitch
+%! assert (x, 13);
diff --git a/test/while.tst b/test/while.tst
--- a/test/while.tst
+++ b/test/while.tst
@@ -63,8 +63,16 @@
 %!   if (i < 3)
 %!     continue;
 %!   endif
 %!   __printf_assert__ ("%d", i);
 %! endwhile
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("34"));
 
+%% test parsing of single-quoted character string appearing immediately
+%% after a while condition.
+%!test
+%! i = 0;
+%! while (++i < 5)
+%!   'foo';
+%! endwhile
+%! assert (i, 5);
