# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1332913605 25200
#      Tue Mar 27 22:46:45 2012 -0700
# Node ID 60e5cf354d8008432747cb02ec4c6ec15ba1799d
# Parent  36cfbd23fe9fbd1aec6e2f5ba520d321b2e40b73
Update %!tests in DLD-FUNCTIONS/ directory with Octave coding conventions.

* __contourc__.cc, __delaunayn__.cc, __dispatch__.cc, __dsearchn__.cc,
__fltk_uigetfile__.cc, __glpk__.cc, __lin_interpn__.cc, __magick_read__.cc,
__pchip_deriv__.cc, __qp__.cc, __voronoi__.cc, besselj.cc, betainc.cc,
bsxfun.cc, cellfun.cc, chol.cc, conv2.cc, convhulln.cc, dassl.cc, det.cc,
dlmread.cc, dmperm.cc, dot.cc, eig.cc, eigs.cc, fft.cc, fft2.cc, filter.cc,
find.cc, gammainc.cc, gcd.cc, givens.cc, hess.cc, hex2num.cc, inv.cc, kron.cc,
lookup.cc, lsode.cc, lu.cc, luinc.cc, matrix_type.cc, max.cc, mgorth.cc,
nproc.cc, qr.cc, quad.cc, quadcc.cc, qz.cc, rand.cc, rcond.cc, regexp.cc,
schur.cc, spparms.cc, sqrtm.cc, str2double.cc, strfind.cc, sub2ind.cc, svd.cc,
syl.cc, time.cc, tril.cc, tsearch.cc: Update %!tests in DLD-FUNCTIONS/
directory with Octave coding conventions.

diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -330,13 +330,11 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -219,13 +219,11 @@ Undocumented internal function.\n\
 #else
   error ("__delaunayn__: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/DLD-FUNCTIONS/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/DLD-FUNCTIONS/__dispatch__.cc
@@ -126,13 +126,11 @@ DEFUN_DLD (__dispatch__, args, nargout,
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -105,13 +105,11 @@ Undocumented internal function.\n\
           retval(0) = idx;
         }
     }
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -130,15 +130,13 @@ Undocumented internal function.\n\
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
 
 #endif
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -851,13 +851,11 @@ Undocumented internal function.\n\
   gripe_not_supported ("glpk");
 
 #endif
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -352,13 +352,11 @@ Undocumented internal function.\n\
 
       retval = lin_interpn<double, NDArray> (n, X, V, Y);
     }
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -528,20 +528,18 @@ function.  Instead use @code{imread}.\n\
   error ("imread: image reading capabilities were disabled when Octave was compiled");
 
 #endif
 
   return output;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
 
 #ifdef HAVE_MAGICK
 
 static void
 jpg_settings (std::vector<Magick::Image>& imvec,
               const Octave_map& options,
               bool)
@@ -920,20 +918,18 @@ function.  Instead use @code{imwrite}.\n
   error ("__magick_write__: not available in this version of Octave");
 
 #endif
 
 return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
 
 #ifdef HAVE_MAGICK
 
 template<class T>
 static octave_value
 magick_to_octave_value (const T magick)
 {
@@ -1145,20 +1141,18 @@ not be using this function.  Instead use
   error ("imfinfo: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
 
 #undef GET_PARAM
 
 // Determine the file formats supported by GraphicsMagick.  This is
 // called once at the beginning of imread or imwrite to determine
 // exactly which file formats are supported, so error messages can be
 // displayed properly.
@@ -1212,13 +1206,11 @@ Undocumented internal function.\n\
   error ("__magick_format_list__: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -158,13 +158,11 @@ Undocumented internal function.\n\
           retval = dmat;
         }
     }
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -525,13 +525,11 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -324,13 +324,11 @@ Undocumented internal function.\n\
 #else
   error ("%s: not available in this version of Octave", caller.c_str ());
 #endif
 
   return retval;
 }
 
 /*
-
 ## No test needed for internal helper function.
 %!assert (1)
-
 */
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -649,290 +649,290 @@ return @code{NaN}.\n\
 }
 
 /*
 %! # Test values computed with GP/PARI version 2.3.3
 %!
 %!shared alpha, x, jx, yx, ix, kx, nix
 %!
 %! # Bessel functions, even order, positive and negative x
-%! alpha = 2; x = 1.25;
+%! alpha = 2;  x = 1.25;
 %! jx = 0.1710911312405234823613091417;
 %! yx = -1.193199310178553861283790424;
 %! ix = 0.2220184483766341752692212604;
 %! kx = 0.9410016167388185767085460540;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), jx, 100*eps)
-%!assert(bessely(-alpha,x), yx, 100*eps)
-%!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps)
-%!assert(besselh(-alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(-alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (-alpha,x), jx, 100*eps)
+%!assert (bessely (-alpha,x), yx, 100*eps)
+%!assert (besseli (-alpha,x), ix, 100*eps)
+%!assert (besselk (-alpha,x), kx, 100*eps)
+%!assert (besselh (-alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (-alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! x *= -1;
 %! yx = -1.193199310178553861283790424 + 0.3421822624810469647226182835*I;
 %! kx = 0.9410016167388185767085460540 - 0.6974915263814386815610060884*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, odd order, positive and negative x
-%! alpha = 3; x = 2.5;
+%! alpha = 3;  x = 2.5;
 %! jx = 0.2166003910391135247666890035;
 %! yx = -0.7560554967536709968379029772;
 %! ix = 0.4743704087780355895548240179;
 %! kx = 0.2682271463934492027663765197;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), -jx, 100*eps)
-%!assert(bessely(-alpha,x), -yx, 100*eps)
-%!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps)
-%!assert(besselh(-alpha,1,x), -(jx + I*yx), 100*eps)
-%!assert(besselh(-alpha,2,x), -(jx - I*yx), 100*eps)
+%!assert (besselj (-alpha,x), -jx, 100*eps)
+%!assert (bessely (-alpha,x), -yx, 100*eps)
+%!assert (besseli (-alpha,x), ix, 100*eps)
+%!assert (besselk (-alpha,x), kx, 100*eps)
+%!assert (besselh (-alpha,1,x), -(jx + I*yx), 100*eps)
+%!assert (besselh (-alpha,2,x), -(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! x *= -1;
 %! jx = -jx;
 %! yx = 0.7560554967536709968379029772 - 0.4332007820782270495333780070*I;
 %! ix = -ix;
 %! kx = -0.2682271463934492027663765197 - 1.490278591297463775542004240*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, fractional order, positive and negative x
 %!
-%! alpha = 3.5; x = 2.75;
+%! alpha = 3.5;  x = 2.75;
 %! jx = 0.1691636439842384154644784389;
 %! yx = -0.8301381935499356070267953387;
 %! ix = 0.3930540878794826310979363668;
 %! kx = 0.2844099013460621170288192503;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! nix = 0.2119931212254662995364461998;
 %!
-%!assert(besselj(-alpha,x), yx, 100*eps)
-%!assert(bessely(-alpha,x), -jx, 100*eps)
-%!assert(besseli(-alpha,x), nix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps)
-%!assert(besselh(-alpha,1,x), -I*(jx + I*yx), 100*eps)
-%!assert(besselh(-alpha,2,x), I*(jx - I*yx), 100*eps)
+%!assert (besselj (-alpha,x), yx, 100*eps)
+%!assert (bessely (-alpha,x), -jx, 100*eps)
+%!assert (besseli (-alpha,x), nix, 100*eps)
+%!assert (besselk (-alpha,x), kx, 100*eps)
+%!assert (besselh (-alpha,1,x), -I*(jx + I*yx), 100*eps)
+%!assert (besselh (-alpha,2,x), I*(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! x *= -1;
 %! jx *= -I;
 %! yx = -0.8301381935499356070267953387*I;
 %! ix *= -I;
 %! kx = -0.9504059335995575096509874508*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, even order, complex x
 %!
-%! alpha = 2; x = 1.25 + 3.625 * I;
+%! alpha = 2;  x = 1.25 + 3.625 * I;
 %! jx = -1.299533366810794494030065917 + 4.370833116012278943267479589*I;
 %! yx = -4.370357232383223896393056727 - 1.283083391453582032688834041*I;
 %! ix = -0.6717801680341515541002273932 - 0.2314623443930774099910228553*I;
 %! kx = -0.01108009888623253515463783379 + 0.2245218229358191588208084197*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), jx, 100*eps)
-%!assert(bessely(-alpha,x), yx, 100*eps)
-%!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps)
-%!assert(besselh(-alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(-alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (-alpha,x), jx, 100*eps)
+%!assert (bessely (-alpha,x), yx, 100*eps)
+%!assert (besseli (-alpha,x), ix, 100*eps)
+%!assert (besselk (-alpha,x), kx, 100*eps)
+%!assert (besselh (-alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (-alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, odd order, complex x
 %!
 %! alpha = 3; x = 2.5 + 1.875 * I;
 %! jx = 0.1330721523048277493333458596 + 0.5386295217249660078754395597*I;
 %! yx = -0.6485072392105829901122401551 + 0.2608129289785456797046996987*I;
 %! ix = -0.6182064685486998097516365709 + 0.4677561094683470065767989920*I;
 %! kx = -0.1568585587733540007867882337 - 0.05185853709490846050505141321*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), -jx, 100*eps)
-%!assert(bessely(-alpha,x), -yx, 100*eps)
-%!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps)
-%!assert(besselh(-alpha,1,x), -(jx + I*yx), 100*eps)
-%!assert(besselh(-alpha,2,x), -(jx - I*yx), 100*eps)
+%!assert (besselj (-alpha,x), -jx, 100*eps)
+%!assert (bessely (-alpha,x), -yx, 100*eps)
+%!assert (besseli (-alpha,x), ix, 100*eps)
+%!assert (besselk (-alpha,x), kx, 100*eps)
+%!assert (besselh (-alpha,1,x), -(jx + I*yx), 100*eps)
+%!assert (besselh (-alpha,2,x), -(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, fractional order, complex x
 %!
-%! alpha = 3.5; x = 1.75 + 4.125 * I;
+%! alpha = 3.5;  x = 1.75 + 4.125 * I;
 %! jx = -3.018566131370455929707009100 - 0.7585648436793900607704057611*I;
 %! yx = 0.7772278839106298215614791107 - 3.018518722313849782683792010*I;
 %! ix = 0.2100873577220057189038160913 - 0.6551765604618246531254970926*I;
 %! kx = 0.1757147290513239935341488069 + 0.08772348296883849205562558311*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps)
-%!assert(bessely(alpha,x), yx, 100*eps)
-%!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps)
-%!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
-%!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
+%!assert (besselj (alpha,x), jx, 100*eps)
+%!assert (bessely (alpha,x), yx, 100*eps)
+%!assert (besseli (alpha,x), ix, 100*eps)
+%!assert (besselk (alpha,x), kx, 100*eps)
+%!assert (besselh (alpha,1,x), jx + I*yx, 100*eps)
+%!assert (besselh (alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %!  nix = 0.09822388691172060573913739253 - 0.7110230642207380127317227407*I;
 %!
-%!assert(besselj(-alpha,x), yx, 100*eps)
-%!assert(bessely(-alpha,x), -jx, 100*eps)
-%!assert(besseli(-alpha,x), nix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps)
-%!assert(besselh(-alpha,1,x), -I*(jx + I*yx), 100*eps)
-%!assert(besselh(-alpha,2,x), I*(jx - I*yx), 100*eps)
+%!assert (besselj (-alpha,x), yx, 100*eps)
+%!assert (bessely (-alpha,x), -jx, 100*eps)
+%!assert (besseli (-alpha,x), nix, 100*eps)
+%!assert (besselk (-alpha,x), kx, 100*eps)
+%!assert (besselh (-alpha,1,x), -I*(jx + I*yx), 100*eps)
+%!assert (besselh (-alpha,2,x), I*(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
-%!assert(bessely(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
-%!assert(besseli(-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
-%!assert(besselh(-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
-%!assert(besselh(-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
+%!assert (besselj (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
+%!assert (bessely (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
+%!assert (besseli (-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
+%!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
+%!assert (besselh (-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
+%!assert (besselh (-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
 
 
 Tests contributed by Robert T. Short.
 Tests are based on the properties and tables in A&S:
  Abramowitz and Stegun, "Handbook of Mathematical Functions",
  1972.
 
 For regular Bessel functions, there are 3 tests. These compare octave
@@ -968,70 +968,70 @@ modified spherical Bessel function tests
 %!       [-0.048383776468198,  0.4970941025,  0.4460590584];
 %!       [-0.177596771314338, -0.3275791376,  0.0465651163];
 %!       [ 0.266339657880378,  0.1352484276, -0.2302734105];
 %!       [-0.245935764451348,  0.0434727462,  0.2546303137];
 %!       [ 0.146884054700421, -0.1654838046, -0.1733614634];
 %!       [-0.014224472826781,  0.2051040386,  0.0415716780];
 %!       [-0.103110398228686, -0.1634199694,  0.0844338303]];
 %!
-%! Yt = [[-Inf,          -Inf,         -Inf         ];
+%! Yt = [[-Inf,          -Inf,          -Inf        ];
 %!       [ 0.4980703596,  0.1459181380, -0.38133585 ];
 %!       [-0.3085176252,  0.1478631434,  0.36766288 ];
 %!       [ 0.1173132861, -0.2591285105, -0.18641422 ];
 %!       [ 0.0556711673,  0.2490154242, -0.00586808 ];
 %!       [-0.1712143068, -0.1538382565,  0.14660019 ];
 %!       [ 0.2054642960,  0.0210736280, -0.20265448 ];
 %!       [-0.1604111925,  0.0985727987,  0.17167666 ]];
 %!
-%! J = besselj(n,z);
-%! Y = bessely(n,z);
-%! assert(Jt(:,1), J(:,1), 0.5e-10);
-%! assert(Yt(:,1), Y(:,1), 0.5e-10);
-%! assert(Jt(:,2:3), J(:,2:3), 0.5e-10);
+%! J = besselj (n,z);
+%! Y = bessely (n,z);
+%! assert (Jt(:,1), J(:,1), 0.5e-10);
+%! assert (Yt(:,1), Y(:,1), 0.5e-10);
+%! assert (Jt(:,2:3), J(:,2:3), 0.5e-10);
 
 Table 9.2 - J and Y for integer orders 3-9.
 
 %!test
-%!  n = (3:9);
-%!  z = (0:2:20).';
+%! n = (3:9);
+%! z = (0:2:20).';
 %!
-%!  Jt = [[ 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00];
-%!        [ 1.2894e-01, 3.3996e-02, 7.0396e-03, 1.2024e-03, 1.7494e-04, 2.2180e-05, 2.4923e-06];
-%!        [ 4.3017e-01, 2.8113e-01, 1.3209e-01, 4.9088e-02, 1.5176e-02, 4.0287e-03, 9.3860e-04];
-%!        [ 1.1477e-01, 3.5764e-01, 3.6209e-01, 2.4584e-01, 1.2959e-01, 5.6532e-02, 2.1165e-02];
-%!        [-2.9113e-01,-1.0536e-01, 1.8577e-01, 3.3758e-01, 3.2059e-01, 2.2345e-01, 1.2632e-01];
-%!        [ 5.8379e-02,-2.1960e-01,-2.3406e-01,-1.4459e-02, 2.1671e-01, 3.1785e-01, 2.9186e-01];
-%!        [ 1.9514e-01, 1.8250e-01,-7.3471e-02,-2.4372e-01,-1.7025e-01, 4.5095e-02, 2.3038e-01];
-%!        [-1.7681e-01, 7.6244e-02, 2.2038e-01, 8.1168e-02,-1.5080e-01,-2.3197e-01,-1.1431e-01];
-%!        [-4.3847e-02,-2.0264e-01,-5.7473e-02, 1.6672e-01, 1.8251e-01,-7.0211e-03,-1.8953e-01];
-%!        [ 1.8632e-01, 6.9640e-02,-1.5537e-01,-1.5596e-01, 5.1399e-02, 1.9593e-01, 1.2276e-01];
-%!        [-9.8901e-02, 1.3067e-01, 1.5117e-01,-5.5086e-02,-1.8422e-01,-7.3869e-02, 1.2513e-01]];
+%! Jt = [[ 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00];
+%!       [ 1.2894e-01, 3.3996e-02, 7.0396e-03, 1.2024e-03, 1.7494e-04, 2.2180e-05, 2.4923e-06];
+%!       [ 4.3017e-01, 2.8113e-01, 1.3209e-01, 4.9088e-02, 1.5176e-02, 4.0287e-03, 9.3860e-04];
+%!       [ 1.1477e-01, 3.5764e-01, 3.6209e-01, 2.4584e-01, 1.2959e-01, 5.6532e-02, 2.1165e-02];
+%!       [-2.9113e-01,-1.0536e-01, 1.8577e-01, 3.3758e-01, 3.2059e-01, 2.2345e-01, 1.2632e-01];
+%!       [ 5.8379e-02,-2.1960e-01,-2.3406e-01,-1.4459e-02, 2.1671e-01, 3.1785e-01, 2.9186e-01];
+%!       [ 1.9514e-01, 1.8250e-01,-7.3471e-02,-2.4372e-01,-1.7025e-01, 4.5095e-02, 2.3038e-01];
+%!       [-1.7681e-01, 7.6244e-02, 2.2038e-01, 8.1168e-02,-1.5080e-01,-2.3197e-01,-1.1431e-01];
+%!       [-4.3847e-02,-2.0264e-01,-5.7473e-02, 1.6672e-01, 1.8251e-01,-7.0211e-03,-1.8953e-01];
+%!       [ 1.8632e-01, 6.9640e-02,-1.5537e-01,-1.5596e-01, 5.1399e-02, 1.9593e-01, 1.2276e-01];
+%!       [-9.8901e-02, 1.3067e-01, 1.5117e-01,-5.5086e-02,-1.8422e-01,-7.3869e-02, 1.2513e-01]];
 %!
-%!  Yt = [[       -Inf,       -Inf,       -Inf,       -Inf,       -Inf,       -Inf,       -Inf];
-%!        [-1.1278e+00,-2.7659e+00,-9.9360e+00,-4.6914e+01,-2.7155e+02,-1.8539e+03,-1.4560e+04];
-%!        [-1.8202e-01,-4.8894e-01,-7.9585e-01,-1.5007e+00,-3.7062e+00,-1.1471e+01,-4.2178e+01];
-%!        [ 3.2825e-01, 9.8391e-02,-1.9706e-01,-4.2683e-01,-6.5659e-01,-1.1052e+00,-2.2907e+00];
-%!        [ 2.6542e-02, 2.8294e-01, 2.5640e-01, 3.7558e-02,-2.0006e-01,-3.8767e-01,-5.7528e-01];
-%!        [-2.5136e-01,-1.4495e-01, 1.3540e-01, 2.8035e-01, 2.0102e-01, 1.0755e-03,-1.9930e-01];
-%!        [ 1.2901e-01,-1.5122e-01,-2.2982e-01,-4.0297e-02, 1.8952e-01, 2.6140e-01, 1.5902e-01];
-%!        [ 1.2350e-01, 2.0393e-01,-6.9717e-03,-2.0891e-01,-1.7209e-01, 3.6816e-02, 2.1417e-01];
-%!        [-1.9637e-01,-7.3222e-05, 1.9633e-01, 1.2278e-01,-1.0425e-01,-2.1399e-01,-1.0975e-01];
-%!        [ 3.3724e-02,-1.7722e-01,-1.1249e-01, 1.1472e-01, 1.8897e-01, 3.2253e-02,-1.6030e-01];
-%!        [ 1.4967e-01, 1.2409e-01,-1.0004e-01,-1.7411e-01,-4.4312e-03, 1.7101e-01, 1.4124e-01]];
+%! Yt = [[       -Inf,       -Inf,       -Inf,       -Inf,       -Inf,       -Inf,       -Inf];
+%!       [-1.1278e+00,-2.7659e+00,-9.9360e+00,-4.6914e+01,-2.7155e+02,-1.8539e+03,-1.4560e+04];
+%!       [-1.8202e-01,-4.8894e-01,-7.9585e-01,-1.5007e+00,-3.7062e+00,-1.1471e+01,-4.2178e+01];
+%!       [ 3.2825e-01, 9.8391e-02,-1.9706e-01,-4.2683e-01,-6.5659e-01,-1.1052e+00,-2.2907e+00];
+%!       [ 2.6542e-02, 2.8294e-01, 2.5640e-01, 3.7558e-02,-2.0006e-01,-3.8767e-01,-5.7528e-01];
+%!       [-2.5136e-01,-1.4495e-01, 1.3540e-01, 2.8035e-01, 2.0102e-01, 1.0755e-03,-1.9930e-01];
+%!       [ 1.2901e-01,-1.5122e-01,-2.2982e-01,-4.0297e-02, 1.8952e-01, 2.6140e-01, 1.5902e-01];
+%!       [ 1.2350e-01, 2.0393e-01,-6.9717e-03,-2.0891e-01,-1.7209e-01, 3.6816e-02, 2.1417e-01];
+%!       [-1.9637e-01,-7.3222e-05, 1.9633e-01, 1.2278e-01,-1.0425e-01,-2.1399e-01,-1.0975e-01];
+%!       [ 3.3724e-02,-1.7722e-01,-1.1249e-01, 1.1472e-01, 1.8897e-01, 3.2253e-02,-1.6030e-01];
+%!       [ 1.4967e-01, 1.2409e-01,-1.0004e-01,-1.7411e-01,-4.4312e-03, 1.7101e-01, 1.4124e-01]];
 %!
-%!  n = (3:9);
-%!  z = (0:2:20).';
-%!  J=besselj(n,z);
-%!  Y=bessely(n,z);
+%! n = (3:9);
+%! z = (0:2:20).';
+%! J = besselj (n,z);
+%! Y = bessely (n,z);
 %!
-%!  assert(J(1,:), zeros (1, columns (J)));
-%!  assert(J(2:end,:), Jt(2:end,:), -5e-5);
-%!  assert(Yt(1,:), Y(1,:));
-%!  assert(Y(2:end,:), Yt(2:end,:), -5e-5);
+%! assert (J(1,:), zeros (1, columns (J)));
+%! assert (J(2:end,:), Jt(2:end,:), -5e-5);
+%! assert (Yt(1,:), Y(1,:));
+%! assert (Y(2:end,:), Yt(2:end,:), -5e-5);
 
 Table 9.4 - J and Y for various integer orders and arguments.
 
 %!test
 %! Jt = [[ 7.651976866e-01,   2.238907791e-01,  -1.775967713e-01,  -2.459357645e-01,  5.581232767e-02,  1.998585030e-02];
 %!       [ 2.497577302e-04,   7.039629756e-03,   2.611405461e-01,  -2.340615282e-01, -8.140024770e-02, -7.419573696e-02];
 %!       [ 2.630615124e-10,   2.515386283e-07,   1.467802647e-03,   2.074861066e-01, -1.138478491e-01, -5.473217694e-02];
 %!       [ 2.297531532e-17,   7.183016356e-13,   4.796743278e-07,   4.507973144e-03, -1.082255990e-01,  1.519812122e-02];
@@ -1048,79 +1048,78 @@ Table 9.4 - J and Y for various integer 
 %!       [-4.113970315e+22,  -4.081651389e+16,  -5.933965297e+08,  -1.597483848e+03,  1.644263395e-02,  5.124797308e-02]
 %!       [-3.048128783e+39,  -2.913223848e+30,  -4.028568418e+18,  -7.256142316e+09, -1.164572349e-01,  6.138839212e-03]
 %!       [-7.184874797e+57,  -6.661541235e+45,  -9.216816571e+29,  -1.362803297e+18, -4.530801120e-02,  4.074685217e-02]
 %!       [-2.191142813e+77,  -1.976150576e+62,  -2.788837017e+42,  -3.641066502e+27, -2.103165546e-01,  7.650526394e-02]
 %!       [-3.775287810e+185, -3.000826049e+155, -5.084863915e+115, -4.849148271e+85, -3.293800188e+18, -1.669214114e-01]];
 %!
 %! n = [(0:5:20).';30;40;50;100];
 %! z = [1,2,5,10,50,100];
-%! J = besselj(n.',z.').';
-%! Y = bessely(n.',z.').';
-%!  assert(J, Jt, -1e-9);
-%!  assert(Y, Yt, -1e-9);
+%! J = besselj (n.', z.').';
+%! Y = bessely (n.', z.').';
+%! assert (J, Jt, -1e-9);
+%! assert (Y, Yt, -1e-9);
 
 Table 9.8 - I and K for integer orders 0, 1, 2.
 
 %!test
 %! n  = 0:2;
 %! z1 = [0.1;2.5;5.0];
 %! z2 = [7.5;10.0;15.0;20.0];
-%! rtbl = [ [ 0.9071009258   0.0452984468   0.1251041992   2.6823261023  10.890182683    1.995039646  ];
-%!          [ 0.2700464416   0.2065846495   0.2042345837   0.7595486903   0.9001744239   0.759126289  ];
-%!          [ 0.1835408126   0.1639722669   0.7002245988   0.5478075643   0.6002738588   0.132723593  ];
-%!          [ 0.1483158301   0.1380412115   0.111504840    0.4505236991   0.4796689336   0.57843541   ];
-%!          [ 0.1278333372   0.1212626814   0.103580801    0.3916319344   0.4107665704   0.47378525   ];
-%!          [ 0.1038995314   0.1003741751   0.090516308    0.3210023535   0.3315348950   0.36520701   ];
-%!          [ 0.0897803119   0.0875062222   0.081029690    0.2785448768   0.2854254970   0.30708743   ]];
+%! rtbl = [[ 0.9071009258   0.0452984468   0.1251041992   2.6823261023  10.890182683    1.995039646  ];
+%!         [ 0.2700464416   0.2065846495   0.2042345837   0.7595486903   0.9001744239   0.759126289  ];
+%!         [ 0.1835408126   0.1639722669   0.7002245988   0.5478075643   0.6002738588   0.132723593  ];
+%!         [ 0.1483158301   0.1380412115   0.111504840    0.4505236991   0.4796689336   0.57843541   ];
+%!         [ 0.1278333372   0.1212626814   0.103580801    0.3916319344   0.4107665704   0.47378525   ];
+%!         [ 0.1038995314   0.1003741751   0.090516308    0.3210023535   0.3315348950   0.36520701   ];
+%!         [ 0.0897803119   0.0875062222   0.081029690    0.2785448768   0.2854254970   0.30708743   ]];
 %!
 %! tbl = [besseli(n,z1,1), besselk(n,z1,1)];
-%! tbl(:,3) = tbl(:,3).*(exp(z1).*z1.^(-2));
-%! tbl(:,6) = tbl(:,6).*(exp(-z1).*z1.^(2));
+%! tbl(:,3) = tbl(:,3) .* (exp(z1).*z1.^(-2));
+%! tbl(:,6) = tbl(:,6) .* (exp(-z1).*z1.^(2));
 %! tbl = [tbl;[besseli(n,z2,1),besselk(n,z2,1)]];
 %!
-%! assert(tbl, rtbl, -2e-8);
+%! assert (tbl, rtbl, -2e-8);
 
 Table 9.9 - I and K for orders 3-9.
 
 %!test
 %! It = [[  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00];
 %!       [  2.8791e-02  6.8654e-03  1.3298e-03  2.1656e-04  3.0402e-05  3.7487e-06  4.1199e-07];
 %!       [  6.1124e-02  2.5940e-02  9.2443e-03  2.8291e-03  7.5698e-04  1.7968e-04  3.8284e-05];
 %!       [  7.4736e-02  4.1238e-02  1.9752e-02  8.3181e-03  3.1156e-03  1.0484e-03  3.1978e-04];
 %!       [  7.9194e-02  5.0500e-02  2.8694e-02  1.4633e-02  6.7449e-03  2.8292e-03  1.0866e-03];
 %!       [  7.9830e-02  5.5683e-02  3.5284e-02  2.0398e-02  1.0806e-02  5.2694e-03  2.3753e-03];
 %!       [  7.8848e-02  5.8425e-02  3.9898e-02  2.5176e-02  1.4722e-02  8.0010e-03  4.0537e-03];
 %!       [  7.7183e-02  5.9723e-02  4.3056e-02  2.8969e-02  1.8225e-02  1.0744e-02  5.9469e-03];
 %!       [  7.5256e-02  6.0155e-02  4.5179e-02  3.1918e-02  2.1240e-02  1.3333e-02  7.9071e-03];
 %!       [  7.3263e-02  6.0059e-02  4.6571e-02  3.4186e-02  2.3780e-02  1.5691e-02  9.8324e-03];
 %!       [  7.1300e-02  5.9640e-02  4.7444e-02  3.5917e-02  2.5894e-02  1.7792e-02  1.1661e-02]];
 %!
-%! Kt = [
-%!      [         Inf         Inf         Inf         Inf         Inf         Inf         Inf];
+%! Kt = [[ Inf         Inf         Inf         Inf         Inf         Inf         Inf];
 %!      [  4.7836e+00  1.6226e+01  6.9687e+01  3.6466e+02  2.2576e+03  1.6168e+04  1.3160e+05];
 %!      [  1.6317e+00  3.3976e+00  8.4268e+00  2.4465e+01  8.1821e+01  3.1084e+02  1.3252e+03];
 %!      [  9.9723e-01  1.6798e+00  3.2370e+00  7.0748e+00  1.7387e+01  4.7644e+01  1.4444e+02];
 %!      [  7.3935e-01  1.1069e+00  1.8463e+00  3.4148e+00  6.9684e+00  1.5610e+01  3.8188e+01];
 %!      [  6.0028e-01  8.3395e-01  1.2674e+00  2.1014e+00  3.7891e+00  7.4062e+00  1.5639e+01];
 %!      [  5.1294e-01  6.7680e-01  9.6415e-01  1.4803e+00  2.4444e+00  4.3321e+00  8.2205e+00];
 %!      [  4.5266e-01  5.7519e-01  7.8133e-01  1.1333e+00  1.7527e+00  2.8860e+00  5.0510e+00];
 %!      [  4.0829e-01  5.0414e-01  6.6036e-01  9.1686e-01  1.3480e+00  2.0964e+00  3.4444e+00];
 %!      [  3.7411e-01  4.5162e-01  5.7483e-01  7.7097e-01  1.0888e+00  1.6178e+00  2.5269e+00];
 %!      [  3.4684e-01  4.1114e-01  5.1130e-01  6.6679e-01  9.1137e-01  1.3048e+00  1.9552e+00]];
 %!
 %! n = (3:9);
 %! z = (0:2:20).';
-%! I=besseli(n,z,1);
-%! K=besselk(n,z,1);
+%! I = besseli (n,z,1);
+%! K = besselk (n,z,1);
 %!
-%! assert(abs (I(1,:)), zeros(1, columns(I)));
-%! assert(I(2:end,:), It(2:end,:), -5e-5);
-%! assert(Kt(1,:), K(1,:));
-%! assert(K(2:end,:), Kt(2:end,:), -5e-5);
+%! assert (abs (I(1,:)), zeros (1, columns(I)));
+%! assert (I(2:end,:), It(2:end,:), -5e-5);
+%! assert (Kt(1,:), K(1,:));
+%! assert (K(2:end,:), Kt(2:end,:), -5e-5);
 
 Table 9.11 - I and K for various integer orders and arguments.
 
 %!test
 %! It = [[   1.266065878e+00    2.279585302e+00    2.723987182e+01    2.815716628e+03     2.93255378e+20     1.07375171e+42 ];
 %!       [   2.714631560e-04    9.825679323e-03    2.157974547e+00    7.771882864e+02     2.27854831e+20     9.47009387e+41 ];
 %!       [   2.752948040e-10    3.016963879e-07    4.580044419e-03    2.189170616e+01     1.07159716e+20     6.49897552e+41 ];
 %!       [   2.370463051e-17    8.139432531e-13    1.047977675e-06    1.043714907e-01     3.07376455e+19     3.47368638e+41 ];
@@ -1137,34 +1136,34 @@ Table 9.11 - I and K for various integer
 %!       [   6.294369360e+22    5.770856853e+16    4.827000521e+08    1.787442782e+02     1.70614838e-21     3.38520541e-44 ];
 %!       [   4.706145527e+39    4.271125755e+30    4.112132063e+18    2.030247813e+09     2.00581681e-19     3.97060205e-43 ];
 %!       [   1.114220651e+58    9.940839886e+45    1.050756722e+30    5.938224681e+17     1.29986971e-16     1.20842080e-41 ];
 %!       [   3.406896854e+77    2.979981740e+62    3.394322243e+42    2.061373775e+27     4.00601349e-13     9.27452265e-40 ];
 %!       [   5.900333184e+185   4.619415978e+155   7.039860193e+115   4.596674084e+85     1.63940352e+13     7.61712963e-25 ]];
 %!
 %! n = [(0:5:20).';30;40;50;100];
 %! z = [1,2,5,10,50,100];
-%! I = besseli(n.',z.').';
-%! K = besselk(n.',z.').';
-%! assert(I, It, -5e-9);
-%! assert(K, Kt, -5e-9);
+%! I = besseli (n.', z.').';
+%! K = besselk (n.', z.').';
+%! assert (I, It, -5e-9);
+%! assert (K, Kt, -5e-9);
 
 The next section checks that negative integer orders and positive
 integer orders are appropriately related.
 
 %!test
-%! n=(0:2:20);
-%! assert(besselj(n,1), besselj(-n,1), 1e-8);
-%! assert(-besselj(n+1,1), besselj(-n-1,1), 1e-8);
+%! n = (0:2:20);
+%! assert (besselj (n,1), besselj (-n,1), 1e-8);
+%! assert (-besselj (n+1,1), besselj (-n-1,1), 1e-8);
 
 besseli(n,z) = besseli(-n,z);
 
 %!test
-%! n=(0:2:20);
-%! assert(besseli(n,1), besseli(-n,1), 1e-8);
+%! n = (0:2:20);
+%! assert (besseli (n,1), besseli (-n,1), 1e-8);
 
 Table 10.1 - j and y for integer orders 0, 1, 2.
 Compare against excerpts of Table 10.1, Abramowitz and Stegun.
 
 %!test
 %! n = (0:2);
 %! z = [0.1;(2.5:2.5:10.0).'];
 %!
@@ -1190,35 +1189,35 @@ Compare against excerpts of Table 10.2, 
 
  Important note: In A&S, y_4(0.1) = -1.0507e+7, but Octave returns
  y_4(0.1) = -1.0508e+07 (-10507503.75). If I compute the same term using
  a series, the difference is in the eighth significant digit so I left
  the Octave results in place.
 
 %!test
 %! n = (3:8);
-%! z = (0:2.5:10).'; z(1)=0.1;
+%! z = (0:2.5:10).';  z(1)=0.1;
 %!
 %! jt = [[ 9.5185e-06  1.0577e-07  9.6163e-10  7.3975e-12  4.9319e-14  2.9012e-16];
 %!       [ 1.0392e-01  3.0911e-02  7.3576e-03  1.4630e-03  2.5009e-04  3.7516e-05];
 %!       [ 2.2982e-01  1.8702e-01  1.0681e-01  4.7967e-02  1.7903e-02  5.7414e-03];
 %!       [-6.1713e-02  7.9285e-02  1.5685e-01  1.5077e-01  1.0448e-01  5.8188e-02];
 %!       [-3.9496e-02 -1.0559e-01 -5.5535e-02  4.4501e-02  1.1339e-01  1.2558e-01]];
 %!
 %! yt = [[-1.5015e+05 -1.0508e+07 -9.4553e+08 -1.0400e+11 -1.3519e+13 -2.0277e+15];
 %!       [-7.9660e-01 -1.7766e+00 -5.5991e+00 -2.2859e+01 -1.1327e+02 -6.5676e+02];
 %!       [-1.5443e-02 -1.8662e-01 -3.2047e-01 -5.1841e-01 -1.0274e+00 -2.5638e+00];
 %!       [ 1.2705e-01  1.2485e-01  2.2774e-02 -9.1449e-02 -1.8129e-01 -2.7112e-01];
 %!       [-9.5327e-02 -1.6599e-03  9.3834e-02  1.0488e-01  4.2506e-02 -4.1117e-02]];
 %!
-%! j = sqrt((pi/2)./z).*besselj(n+1/2,z);
-%! y = sqrt((pi/2)./z).*bessely(n+1/2,z);
+%! j = sqrt ((pi/2)./z) .* besselj (n+1/2,z);
+%! y = sqrt ((pi/2)./z) .* bessely (n+1/2,z);
 %!
-%! assert(jt, j, -5e-5);
-%! assert(yt, y, -5e-5);
+%! assert (jt, j, -5e-5);
+%! assert (yt, y, -5e-5);
 
 Table 10.4 - j and y for various integer orders and arguments.
 
 %!test
 %! jt = [[ 8.414709848e-01    4.546487134e-01   -1.917848549e-01   -5.440211109e-02   -5.247497074e-03   -5.063656411e-03];
 %!       [ 9.256115861e-05    2.635169770e-03    1.068111615e-01   -5.553451162e-02   -2.004830056e-02   -9.290148935e-03];
 %!       [ 7.116552640e-11    6.825300865e-08    4.073442442e-04    6.460515449e-02   -1.503922146e-02   -1.956578597e-04];
 %!       [ 5.132686115e-18    1.606982166e-13    1.084280182e-07    1.063542715e-03   -1.129084539e-02    7.877261748e-03];
@@ -1235,16 +1234,13 @@ Table 10.4 - j and y for various integer
 %!       [ -3.239592219e+23   -1.605436493e+17   -9.267951403e+08   -1.211210605e+03    1.375953130e-02    5.631729379e-05]
 %!       [ -2.946428547e+40   -1.407393871e+31   -7.760717570e+18   -6.908318646e+09   -2.241226812e-02   -5.412929349e-03]
 %!       [ -8.028450851e+58   -3.720929322e+46   -2.055758716e+30   -1.510304919e+18    4.978797221e-05   -7.048420407e-04]
 %!       [ -2.739192285e+78   -1.235021944e+63   -6.964109188e+42   -4.528227272e+27   -4.190000150e-02    1.074782297e-02]
 %!       [-6.683079463e+186  -2.655955830e+156  -1.799713983e+116   -8.573226309e+85   -1.125692891e+18   -2.298385049e-02]];
 %!
 %! n = [(0:5:20).';30;40;50;100];
 %! z = [1,2,5,10,50,100];
-%! j = sqrt((pi/2)./z).*besselj((n+1/2).',z.').';
-%! y = sqrt((pi/2)./z).*bessely((n+1/2).',z.').';
-%! assert(j, jt, -1e-9);
-%! assert(y, yt, -1e-9);
-
-
-
+%! j = sqrt ((pi/2)./z) .* besselj ((n+1/2).', z.').';
+%! y = sqrt ((pi/2)./z) .* bessely ((n+1/2).', z.').';
+%! assert (j, jt, -1e-9);
+%! assert (y, yt, -1e-9);
 */
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -278,55 +278,53 @@ compatible dimensions.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %% test/octave.test/arith/betainc-1.m
 %!test
-%! a=[1, 1.5, 2, 3];
-%! b=[4, 3, 2, 1];
-%! v1=betainc(1,a,b);
-%! v2=[1,1,1,1];
+%! a = [1, 1.5, 2, 3];
+%! b = [4, 3, 2, 1];
+%! v1 = betainc (1,a,b);
+%! v2 = [1,1,1,1];
 %! x = [.2, .4, .6, .8];
-%! v3=betainc(x, a, b);
-%! v4 = 1-betainc(1.-x, b, a);
-%! assert(v1, v2, sqrt(eps));
-%! assert(v3, v4, sqrt(eps));
+%! v3 = betainc (x, a, b);
+%! v4 = 1 - betainc (1.-x, b, a);
+%! assert (v1, v2, sqrt (eps));
+%! assert (v3, v4, sqrt (eps));
 
 %% Single precision
 %!test
-%! a=single ([1, 1.5, 2, 3]);
-%! b=single ([4, 3, 2, 1]);
-%! v1=betainc(1,a,b);
-%! v2=single ([1,1,1,1]);
+%! a = single ([1, 1.5, 2, 3]);
+%! b = single ([4, 3, 2, 1]);
+%! v1 = betainc (1,a,b);
+%! v2 = single ([1,1,1,1]);
 %! x = single ([.2, .4, .6, .8]);
-%! v3=betainc(x, a, b);
-%! v4 = 1-betainc(1.-x, b, a);
-%! assert(v1, v2, sqrt(eps ('single')));
-%! assert(v3, v4, sqrt(eps ('single')));
+%! v3 = betainc (x, a, b);
+%! v4 = 1 - betainc (1.-x, b, a);
+%! assert (v1, v2, sqrt (eps ("single")));
+%! assert (v3, v4, sqrt (eps ("single")));
 
 %% Mixed double/single precision
 %!test
-%! a=single ([1, 1.5, 2, 3]);
-%! b=[4, 3, 2, 1];
-%! v1=betainc(1,a,b);
-%! v2=single ([1,1,1,1]);
+%! a = single ([1, 1.5, 2, 3]);
+%! b = [4, 3, 2, 1];
+%! v1 = betainc (1,a,b);
+%! v2 = single ([1,1,1,1]);
 %! x = [.2, .4, .6, .8];
-%! v3=betainc(x, a, b);
-%! v4 = 1-betainc(1.-x, b, a);
-%! assert(v1, v2, sqrt(eps ('single')));
-%! assert(v3, v4, sqrt(eps ('single')));
+%! v3 = betainc (x, a, b);
+%! v4 = 1-betainc (1.-x, b, a);
+%! assert (v1, v2, sqrt (eps ('single')));
+%! assert (v3, v4, sqrt (eps ('single')));
 
 %% test/octave.test/arith/betainc-2.m
-%!error <Invalid call to betainc> betainc();
+%!error betainc ()
 
 %% test/octave.test/arith/betainc-3.m
-%!error <Invalid call to betainc> betainc(1);
+%!error betainc> betainc (1)
 
 %% test/octave.test/arith/betainc-4.m
-%!error <Invalid call to betainc> betainc(1,2);
-
+%!error betainc> betainc (1,2)
 */
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -657,137 +657,137 @@ dimensionality as the other array.\n\
 
 /*
 
 %!shared a, b, c, f
 %! a = randn (4, 4);
 %! b = mean (a, 1);
 %! c = mean (a, 2);
 %! f = @minus;
-%!error(bsxfun (f));
-%!error(bsxfun (f, a));
-%!error(bsxfun (a, b));
-%!error(bsxfun (a, b, c));
-%!error(bsxfun (f, a, b, c));
-%!error(bsxfun (f, ones(4, 0), ones(4, 4)))
-%!assert(bsxfun (f, ones(4, 0), ones(4, 1)), zeros(4, 0));
-%!assert(bsxfun (f, ones(1, 4), ones(4, 1)), zeros(4, 4));
-%!assert(bsxfun (f, a, b), a - repmat(b, 4, 1));
-%!assert(bsxfun (f, a, c), a - repmat(c, 1, 4));
-%!assert(bsxfun ("minus", ones(1, 4), ones(4, 1)), zeros(4, 4));
+%!error (bsxfun (f))
+%!error (bsxfun (f, a))
+%!error (bsxfun (a, b))
+%!error (bsxfun (a, b, c))
+%!error (bsxfun (f, a, b, c))
+%!error (bsxfun (f, ones (4, 0), ones (4, 4)))
+%!assert (bsxfun (f, ones (4, 0), ones (4, 1)), zeros (4, 0))
+%!assert (bsxfun (f, ones (1, 4), ones (4, 1)), zeros (4, 4))
+%!assert (bsxfun (f, a, b), a - repmat (b, 4, 1))
+%!assert (bsxfun (f, a, c), a - repmat (c, 1, 4))
+%!assert (bsxfun ("minus", ones (1, 4), ones (4, 1)), zeros (4, 4))
 
 %!shared a, b, c, f
 %! a = randn (4, 4);
 %! a(1) *= 1i;
 %! b = mean (a, 1);
 %! c = mean (a, 2);
 %! f = @minus;
-%!error(bsxfun (f));
-%!error(bsxfun (f, a));
-%!error(bsxfun (a, b));
-%!error(bsxfun (a, b, c));
-%!error(bsxfun (f, a, b, c));
-%!error(bsxfun (f, ones(4, 0), ones(4, 4)))
-%!assert(bsxfun (f, ones(4, 0), ones(4, 1)), zeros(4, 0));
-%!assert(bsxfun (f, ones(1, 4), ones(4, 1)), zeros(4, 4));
-%!assert(bsxfun (f, a, b), a - repmat(b, 4, 1));
-%!assert(bsxfun (f, a, c), a - repmat(c, 1, 4));
-%!assert(bsxfun ("minus", ones(1, 4), ones(4, 1)), zeros(4, 4));
+%!error (bsxfun (f))
+%!error (bsxfun (f, a))
+%!error (bsxfun (a, b))
+%!error (bsxfun (a, b, c))
+%!error (bsxfun (f, a, b, c))
+%!error (bsxfun (f, ones (4, 0), ones (4, 4)))
+%!assert (bsxfun (f, ones (4, 0), ones (4, 1)), zeros (4, 0))
+%!assert (bsxfun (f, ones (1, 4), ones (4, 1)), zeros (4, 4))
+%!assert (bsxfun (f, a, b), a - repmat (b, 4, 1))
+%!assert (bsxfun (f, a, c), a - repmat (c, 1, 4))
+%!assert (bsxfun ("minus", ones (1, 4), ones (4, 1)), zeros (4, 4))
 
 %!shared a, b, c, f
 %! a = randn (4, 4);
 %! a(end) *= 1i;
 %! b = mean (a, 1);
 %! c = mean (a, 2);
 %! f = @minus;
-%!error(bsxfun (f));
-%!error(bsxfun (f, a));
-%!error(bsxfun (a, b));
-%!error(bsxfun (a, b, c));
-%!error(bsxfun (f, a, b, c));
-%!error(bsxfun (f, ones(4, 0), ones(4, 4)))
-%!assert(bsxfun (f, ones(4, 0), ones(4, 1)), zeros(4, 0));
-%!assert(bsxfun (f, ones(1, 4), ones(4, 1)), zeros(4, 4));
-%!assert(bsxfun (f, a, b), a - repmat(b, 4, 1));
-%!assert(bsxfun (f, a, c), a - repmat(c, 1, 4));
-%!assert(bsxfun ("minus", ones(1, 4), ones(4, 1)), zeros(4, 4));
+%!error (bsxfun (f))
+%!error (bsxfun (f, a))
+%!error (bsxfun (a, b))
+%!error (bsxfun (a, b, c))
+%!error (bsxfun (f, a, b, c))
+%!error (bsxfun (f, ones (4, 0), ones (4, 4)))
+%!assert (bsxfun (f, ones (4, 0), ones (4, 1)), zeros (4, 0))
+%!assert (bsxfun (f, ones (1, 4), ones (4, 1)), zeros (4, 4))
+%!assert (bsxfun (f, a, b), a - repmat (b, 4, 1))
+%!assert (bsxfun (f, a, c), a - repmat (c, 1, 4))
+%!assert (bsxfun ("minus", ones (1, 4), ones (4, 1)), zeros (4, 4))
 
 %!shared a, b, c, f
 %! a = randn (4, 4);
 %! b = a (1, :);
 %! c = a (:, 1);
 %! f = @(x, y) x == y;
-%!error(bsxfun (f));
-%!error(bsxfun (f, a));
-%!error(bsxfun (a, b));
-%!error(bsxfun (a, b, c));
-%!error(bsxfun (f, a, b, c));
-%!error(bsxfun (f, ones(4, 0), ones(4, 4)))
-%!assert(bsxfun (f, ones(4, 0), ones(4, 1)), zeros(4, 0, "logical"));
-%!assert(bsxfun (f, ones(1, 4), ones(4, 1)), ones(4, 4, "logical"));
-%!assert(bsxfun (f, a, b), a == repmat(b, 4, 1));
-%!assert(bsxfun (f, a, c), a == repmat(c, 1, 4));
+%!error (bsxfun (f))
+%!error (bsxfun (f, a))
+%!error (bsxfun (a, b))
+%!error (bsxfun (a, b, c))
+%!error (bsxfun (f, a, b, c))
+%!error (bsxfun (f, ones (4, 0), ones (4, 4)))
+%!assert (bsxfun (f, ones (4, 0), ones (4, 1)), zeros (4, 0, "logical"))
+%!assert (bsxfun (f, ones (1, 4), ones (4, 1)), ones (4, 4, "logical"))
+%!assert (bsxfun (f, a, b), a == repmat (b, 4, 1))
+%!assert (bsxfun (f, a, c), a == repmat (c, 1, 4))
 
 %!shared a, b, c, d, f
 %! a = randn (4, 4, 4);
 %! b = mean (a, 1);
 %! c = mean (a, 2);
 %! d = mean (a, 3);
 %! f = @minus;
-%!error(bsxfun (f, ones([4, 0, 4]), ones([4, 4, 4])));
-%!assert(bsxfun (f, ones([4, 0, 4]), ones([4, 1, 4])), zeros([4, 0, 4]));
-%!assert(bsxfun (f, ones([4, 4, 0]), ones([4, 1, 1])), zeros([4, 4, 0]));
-%!assert(bsxfun (f, ones([1, 4, 4]), ones([4, 1, 4])), zeros([4, 4, 4]));
-%!assert(bsxfun (f, ones([4, 4, 1]), ones([4, 1, 4])), zeros([4, 4, 4]));
-%!assert(bsxfun (f, ones([4, 1, 4]), ones([1, 4, 4])), zeros([4, 4, 4]));
-%!assert(bsxfun (f, ones([4, 1, 4]), ones([1, 4, 1])), zeros([4, 4, 4]));
-%!assert(bsxfun (f, a, b), a - repmat(b, [4, 1, 1]));
-%!assert(bsxfun (f, a, c), a - repmat(c, [1, 4, 1]));
-%!assert(bsxfun (f, a, d), a - repmat(d, [1, 1, 4]));
-%!assert(bsxfun ("minus", ones([4, 0, 4]), ones([4, 1, 4])), zeros([4, 0, 4]));
+%!error (bsxfun (f, ones ([4, 0, 4]), ones ([4, 4, 4])))
+%!assert (bsxfun (f, ones ([4, 0, 4]), ones ([4, 1, 4])), zeros ([4, 0, 4]))
+%!assert (bsxfun (f, ones ([4, 4, 0]), ones ([4, 1, 1])), zeros ([4, 4, 0]))
+%!assert (bsxfun (f, ones ([1, 4, 4]), ones ([4, 1, 4])), zeros ([4, 4, 4]))
+%!assert (bsxfun (f, ones ([4, 4, 1]), ones ([4, 1, 4])), zeros ([4, 4, 4]))
+%!assert (bsxfun (f, ones ([4, 1, 4]), ones ([1, 4, 4])), zeros ([4, 4, 4]))
+%!assert (bsxfun (f, ones ([4, 1, 4]), ones ([1, 4, 1])), zeros ([4, 4, 4]))
+%!assert (bsxfun (f, a, b), a - repmat (b, [4, 1, 1]))
+%!assert (bsxfun (f, a, c), a - repmat (c, [1, 4, 1]))
+%!assert (bsxfun (f, a, d), a - repmat (d, [1, 1, 4]))
+%!assert (bsxfun ("minus", ones ([4, 0, 4]), ones ([4, 1, 4])), zeros ([4, 0, 4]))
 
-%% The below is a very hard case to treat
-%!assert(bsxfun (f, ones([4, 1, 4, 1]), ones([1, 4, 1, 4])), zeros([4, 4, 4, 4]));
+%% The test below is a very hard case to treat
+%!assert (bsxfun (f, ones ([4, 1, 4, 1]), ones ([1, 4, 1, 4])), zeros ([4, 4, 4, 4]));
 
 %!shared a, b, aa, bb
 %! a = randn (3, 1, 3);
 %! aa = a(:, ones (1, 3), :, ones (1, 3));
 %! b = randn (1, 3, 3, 3);
 %! bb = b(ones (1, 3), :, :, :);
-%!assert (bsxfun (@plus, a, b), aa + bb);
-%!assert (bsxfun (@minus, a, b), aa - bb);
-%!assert (bsxfun (@times, a, b), aa .* bb);
-%!assert (bsxfun (@rdivide, a, b), aa ./ bb);
-%!assert (bsxfun (@ldivide, a, b), aa .\ bb);
-%!assert (bsxfun (@power, a, b), aa .^ bb);
-%!assert (bsxfun (@power, abs (a), b), abs (aa) .^ bb);
-%!assert (bsxfun (@eq, round (a), round (b)), round (aa) == round (bb));
-%!assert (bsxfun (@ne, round (a), round (b)), round (aa) != round (bb));
-%!assert (bsxfun (@lt, a, b), aa < bb);
-%!assert (bsxfun (@le, a, b), aa <= bb);
-%!assert (bsxfun (@gt, a, b), aa > bb);
-%!assert (bsxfun (@ge, a, b), aa >= bb);
-%!assert (bsxfun (@min, a, b), min (aa, bb));
-%!assert (bsxfun (@max, a, b), max (aa, bb));
-%!assert (bsxfun (@and, a > 0, b > 0), (aa > 0) & (bb > 0));
-%!assert (bsxfun (@or, a > 0, b > 0), (aa > 0) | (bb > 0));
+%!assert (bsxfun (@plus, a, b), aa + bb)
+%!assert (bsxfun (@minus, a, b), aa - bb)
+%!assert (bsxfun (@times, a, b), aa .* bb)
+%!assert (bsxfun (@rdivide, a, b), aa ./ bb)
+%!assert (bsxfun (@ldivide, a, b), aa .\ bb)
+%!assert (bsxfun (@power, a, b), aa .^ bb)
+%!assert (bsxfun (@power, abs (a), b), abs (aa) .^ bb)
+%!assert (bsxfun (@eq, round (a), round (b)), round (aa) == round (bb))
+%!assert (bsxfun (@ne, round (a), round (b)), round (aa) != round (bb))
+%!assert (bsxfun (@lt, a, b), aa < bb)
+%!assert (bsxfun (@le, a, b), aa <= bb)
+%!assert (bsxfun (@gt, a, b), aa > bb)
+%!assert (bsxfun (@ge, a, b), aa >= bb)
+%!assert (bsxfun (@min, a, b), min (aa, bb))
+%!assert (bsxfun (@max, a, b), max (aa, bb))
+%!assert (bsxfun (@and, a > 0, b > 0), (aa > 0) & (bb > 0))
+%!assert (bsxfun (@or, a > 0, b > 0), (aa > 0) | (bb > 0))
 
 %% Test automatic bsxfun
 %
 %!test
 %! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, \
 %!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, \
 %!         @and, @or, @xor };
 %!
 %! float_types = {@single, @double};
 %! int_types = {@int8, @int16, @int32, @int64, \
-%!             @uint8, @uint16, @uint32, @uint64};
+%!              @uint8, @uint16, @uint32, @uint64};
 %!
-%! x = rand (3)*10-5;
-%! y = rand (3,1)*10-5;
+%! x = rand (3) * 10-5;
+%! y = rand (3,1) * 10-5;
 %!
 %! for i=1:length (funs)
 %!   for j = 1:length(float_types)
 %!     for k = 1:length(int_types)
 %!
 %!       fun = funs{i};
 %!       f_type = float_types{j};
 %!       i_type = int_types{k};
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -707,311 +707,312 @@ v = cellfun (@@det, a); # faster\n\
     error ("cellfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 
 %!function r = __f11 (x)
-%!  global __cellfun_test_num_outputs__
+%!  global __cellfun_test_num_outputs__;
 %!  __cellfun_test_num_outputs__ = nargout;
 %!  r = x;
 %!endfunction
 
 %!function __f01 (x)
-%!  global __cellfun_test_num_outputs__
+%!  global __cellfun_test_num_outputs__;
 %!  __cellfun_test_num_outputs__ = nargout;
 %!endfunction
 
 %!test
-%! global __cellfun_test_num_outputs__
+%! global __cellfun_test_num_outputs__;
 %! cellfun (@__f11, {1});
-%! assert (__cellfun_test_num_outputs__, 0)
+%! assert (__cellfun_test_num_outputs__, 0);
 %! x = cellfun (@__f11, {1});
-%! assert (__cellfun_test_num_outputs__, 1)
+%! assert (__cellfun_test_num_outputs__, 1);
 
 %!test
-%! global __cellfun_test_num_outputs__
+%! global __cellfun_test_num_outputs__;
 %! cellfun (@__f01, {1});
-%! assert (__cellfun_test_num_outputs__, 0)
+%! assert (__cellfun_test_num_outputs__, 0);
 
 %!error x = cellfun (@__f01, {1, 2});
 
 %!test
-%! assert (cellfun (@__f11, {1, 2}), [1, 2])
-%! assert (cellfun (@__f11, {1, 2}, 'uniformoutput', false), {1, 2})
+%! assert (cellfun (@__f11, {1, 2}), [1, 2]);
+%! assert (cellfun (@__f11, {1, 2}, 'uniformoutput', false), {1, 2});
 
 %!test
-%!  [a,b] = cellfun (@(x) x, cell (2, 0));
-%!  assert (a, zeros (2, 0));
-%!  assert (b, zeros (2, 0));
+%! [a,b] = cellfun (@(x) x, cell (2, 0));
+%! assert (a, zeros (2, 0));
+%! assert (b, zeros (2, 0));
 
 %!test
-%!  [a,b] = cellfun (@(x) x, cell (2, 0), "uniformoutput", false);
-%!  assert (a, cell (2, 0));
-%!  assert (b, cell (2, 0));
+%! [a,b] = cellfun (@(x) x, cell (2, 0), "uniformoutput", false);
+%! assert (a, cell (2, 0));
+%! assert (b, cell (2, 0));
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = __cellfunerror (S, varargin)
+%!function z = __cellfunerror (S, varargin)
 %!  z = S;
 %!endfunction
 
 %% First input argument can be a string, an inline function,
 %% a function_handle or an anonymous function
 %!test
-%!  A = cellfun ("islogical", {true, 0.1, false, i*2});
-%!  assert (A, [true, false, true, false]);
+%! A = cellfun ("islogical", {true, 0.1, false, i*2});
+%! assert (A, [true, false, true, false]);
 %!test
-%!  A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
-%!  assert (A, [true, false, true, false]);
+%! A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
+%! assert (A, [true, false, true, false]);
 %!test
-%!  A = cellfun (@islogical, {true, 0.1, false, i*2});
-%!  assert (A, [true, false, true, false]);
+%! A = cellfun (@islogical, {true, 0.1, false, i*2});
+%! assert (A, [true, false, true, false]);
 %!test
-%!  A = cellfun (@(x) islogical(x), {true, 0.1, false, i*2});
-%!  assert (A, [true, false, true, false]);
+%! A = cellfun (@(x) islogical(x), {true, 0.1, false, i*2});
+%! assert (A, [true, false, true, false]);
 
 %% First input argument can be the special string "isreal",
 %% "isempty", "islogical", "length", "ndims" or "prodofsize"
 %!test
-%!  A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
-%!  assert (A, [true, true, false, false, true, true]);
+%! A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
+%! assert (A, [true, true, false, false, true, true]);
 %!test
-%!  A = cellfun ("isempty", {true, 0.1, false, i*2, [], "abc"});
-%!  assert (A, [false, false, false, false, true, false]);
+%! A = cellfun ("isempty", {true, 0.1, false, i*2, [], "abc"});
+%! assert (A, [false, false, false, false, true, false]);
 %!test
-%!  A = cellfun ("islogical", {true, 0.1, false, i*2, [], "abc"});
-%!  assert (A, [true, false, true, false, false, false]);
+%! A = cellfun ("islogical", {true, 0.1, false, i*2, [], "abc"});
+%! assert (A, [true, false, true, false, false, false]);
 %!test
-%!  A = cellfun ("length", {true, 0.1, false, i*2, [], "abc"});
-%!  assert (A, [1, 1, 1, 1, 0, 3]);
+%! A = cellfun ("length", {true, 0.1, false, i*2, [], "abc"});
+%! assert (A, [1, 1, 1, 1, 0, 3]);
 %!test
-%!  A = cellfun ("ndims", {[1, 2; 3, 4]; (cell (1,2,3,4))});
-%!  assert (A, [2; 4]);
+%! A = cellfun ("ndims", {[1, 2; 3, 4]; (cell (1,2,3,4))});
+%! assert (A, [2; 4]);
 %!test
-%!  A = cellfun ("prodofsize", {[1, 2; 3, 4], (cell (1,2,3,4))});
-%!  assert (A, [4, 24]);
+%! A = cellfun ("prodofsize", {[1, 2; 3, 4], (cell (1,2,3,4))});
+%! assert (A, [4, 24]);
 
 %% Number of input and output arguments may not be limited to one
 %!test
-%!  A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5});
-%!  assert (A, [6, 7, 8]);
+%! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5});
+%! assert (A, [6, 7, 8]);
 %!test
-%!  A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, \
-%!    "UniformOutput", false);
-%!  assert (A, {6, 7, 8});
+%! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, \
+%!              "UniformOutput", false);
+%! assert (A, {6, 7, 8});
 %!test %% Two input arguments of different types
-%!  A = cellfun (@(x,y) islogical (x) && ischar (y), {false, true}, {"a", 3});
-%!  assert (A, [true, false]);
+%! A = cellfun (@(x,y) islogical (x) && ischar (y), {false, true}, {"a", 3});
+%! assert (A, [true, false]);
 %!test %% Pass another variable to the anonymous function
-%!  y = true; A = cellfun (@(x) islogical (x) && y, {false, 0.3});
-%!  assert (A, [true, false]);
+%! y = true;
+%! A = cellfun (@(x) islogical (x) && y, {false, 0.3});
+%! assert (A, [true, false]);
 %!test %% Three ouptut arguments of different type
-%!  [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
-%!  assert (isequal (A, {true, true; [], true}));
-%!  assert (isequal (B, {true, true; [], true}));
-%!  assert (isequal (C, {10, 11; [], 12}));
+%! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
+%! assert (isequal (A, {true, true; [], true}));
+%! assert (isequal (B, {true, true; [], true}));
+%! assert (isequal (C, {10, 11; [], 12}));
 
 %% Input arguments can be of type cell array of logical
 %!test
-%!  A = cellfun (@(x,y) x == y, {false, true}, {true, true});
-%!  assert (A, [false, true]);
+%! A = cellfun (@(x,y) x == y, {false, true}, {true, true});
+%! assert (A, [false, true]);
 %!test
-%!  A = cellfun (@(x,y) x == y, {false; true}, {true; true}, \
-%!    "UniformOutput", true);
-%!  assert (A, [false; true]);
+%! A = cellfun (@(x,y) x == y, {false; true}, {true; true}, \
+%!              "UniformOutput", true);
+%! assert (A, [false; true]);
 %!test
-%!  A = cellfun (@(x) x, {false, true; false, true}, "UniformOutput", false);
-%!  assert (A, {false, true; false, true});
+%! A = cellfun (@(x) x, {false, true; false, true}, "UniformOutput", false);
+%! assert (A, {false, true; false, true});
 %!test %% Three ouptut arguments of same type
-%!  [A, B, C] = cellfun (@find, {true, false; false, true}, \
-%!    "UniformOutput", false);
-%!  assert (isequal (A, {true, []; [], true}));
-%!  assert (isequal (B, {true, []; [], true}));
-%!  assert (isequal (C, {true, []; [], true}));
+%! [A, B, C] = cellfun (@find, {true, false; false, true}, \
+%!                      "UniformOutput", false);
+%! assert (isequal (A, {true, []; [], true}));
+%! assert (isequal (B, {true, []; [], true}));
+%! assert (isequal (C, {true, []; [], true}));
 %!test
-%!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "ErrorHandler", @__cellfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
+%!              "ErrorHandler", @__cellfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
+%!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 
 %% Input arguments can be of type cell array of numeric
 %!test
-%!  A = cellfun (@(x,y) x>y, {1.1, 4.2}, {3.1, 2+3*i});
-%!  assert (A, [false, true]);
+%! A = cellfun (@(x,y) x>y, {1.1, 4.2}, {3.1, 2+3*i});
+%! assert (A, [false, true]);
 %!test
-%!  A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, \
-%!    "UniformOutput", true);
-%!  assert (A, [false, true; false, false]);
+%! A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, \
+%!              "UniformOutput", true);
+%! assert (A, [false, true; false, false]);
 %!test
-%!  A = cellfun (@(x,y) x:y, {1.1, 4}, {3.1, 6}, "UniformOutput", false);
-%!  assert (isequal (A{1}, [1.1, 2.1, 3.1]));
-%!  assert (isequal (A{2}, [4, 5, 6]));
+%! A = cellfun (@(x,y) x:y, {1.1, 4}, {3.1, 6}, "UniformOutput", false);
+%! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
+%! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
-%!  [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
-%!  assert (isequal (A, {true, true; [], true}));
-%!  assert (isequal (B, {true, true; [], true}));
-%!  assert (isequal (C, {10, 11; [], 12}));
+%! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
+%! assert (isequal (A, {true, true; [], true}));
+%! assert (isequal (B, {true, true; [], true}));
+%! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "ErrorHandler", @__cellfunerror);
-%!  B = isfield (A(1), "message") && isfield (A(1), "index");
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%!              "ErrorHandler", @__cellfunerror);
+%! B = isfield (A(1), "message") && isfield (A(1), "index");
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
-%!  B = isfield (A(1), "message") && isfield (A(1), "index");
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
+%! B = isfield (A(1), "message") && isfield (A(1), "index");
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell arrays of character or strings
 %!error %% "UniformOutput" false should be used
-%!  A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
+%! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
-%!  A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
-%!  assert (A, [false; true]);
+%! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
+%! assert (A, [false; true]);
 %!test
-%!  A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
-%!  assert (A, {"abc", "def"});
+%! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
+%! assert (A, {"abc", "def"});
 %!test
-%!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "ErrorHandler", @__cellfunerror);
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%!              "ErrorHandler", @__cellfunerror);
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
 %!error
-%!  vst1.a = 1.1; vst1.b = 4.2; vst2.a = 3.1; vst2.b = 2;
-%!  A = cellfun (@(x,y) (x.a < y.a) && (x.b > y.b), vst1, vst2);
+%! vst1.a = 1.1;  vst1.b = 4.2;  vst2.a = 3.1;  vst2.b = 2;
+%! A = cellfun (@(x,y) (x.a < y.a) && (x.b > y.b), vst1, vst2);
 
 %% Input arguments can be of type cell array of cell arrays
 %!test
-%!  A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}});
-%!  assert (A, [1, 0], 1e-16);
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}});
+%! assert (A, [1, 0], 1e-16);
 %!test
-%!  A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
-%!    "UniformOutput", true);
-%!  assert (A, [1; 0], 1e-16);
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
+%!              "UniformOutput", true);
+%! assert (A, [1; 0], 1e-16);
 %!test
-%!  A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "UniformOutput", false);
-%!  assert (A, {true, false});
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%!              "UniformOutput", false);
+%! assert (A, {true, false});
 %!test
-%!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "ErrorHandler", @__cellfunerror);
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%!              "ErrorHandler", @__cellfunerror);
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
 %!test
-%!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
-%!  A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b), {a}, {b});
-%!  assert (A, true);
+%! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b), {a}, {b});
+%! assert (A, true);
 %!test
-%!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
-%!  A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
-%!    "UniformOutput", true);
-%!  assert (A, true);
+%! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
+%!              "UniformOutput", true);
+%! assert (A, true);
 %!test
-%!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
-%!  A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
-%!    "UniformOutput", false);
-%!  assert (A, {true});
+%! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
+%!              "UniformOutput", false);
+%! assert (A, {true});
 %!test
-%!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
-%!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "ErrorHandler", @__cellfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
+%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
+%!              "ErrorHandler", @__cellfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
-%!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
+%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
+%!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 
 %% A lot of other tests
-%!error(cellfun(1))
-%!error(cellfun('isclass',1))
-%!error(cellfun('size',1))
-%!error(cellfun(@sin,{[]},'BadParam',false))
-%!error(cellfun(@sin,{[]},'UniformOuput'))
-%!error(cellfun(@sin,{[]},'ErrorHandler'))
-%!assert(cellfun(@sin,{0,1}),sin([0,1]))
-%!assert(cellfun(inline('sin(x)'),{0,1}),sin([0,1]))
-%!assert(cellfun('sin',{0,1}),sin([0,1]))
-%!assert(cellfun('isempty',{1,[]}),[false,true])
-%!assert(cellfun('islogical',{false,pi}),[true,false])
-%!assert(cellfun('isreal',{1i,1}),[false,true])
-%!assert(cellfun('length',{zeros(2,2),1}),[2,1])
-%!assert(cellfun('prodofsize',{zeros(2,2),1}),[4,1])
-%!assert(cellfun('ndims',{zeros([2,2,2]),1}),[3,2])
-%!assert(cellfun('isclass',{zeros([2,2,2]),'test'},'double'),[true,false])
-%!assert(cellfun('size',{zeros([1,2,3]),1},1),[1,1])
-%!assert(cellfun('size',{zeros([1,2,3]),1},2),[2,1])
-%!assert(cellfun('size',{zeros([1,2,3]),1},3),[3,1])
-%!assert(cellfun(@atan2,{1,1},{1,2}),[atan2(1,1),atan2(1,2)])
-%!assert(cellfun(@atan2,{1,1},{1,2},'UniformOutput',false),{atan2(1,1),atan2(1,2)})
-%!assert(cellfun(@sin,{1,2;3,4}),sin([1,2;3,4]))
-%!assert(cellfun(@atan2,{1,1;1,1},{1,2;1,2}),atan2([1,1;1,1],[1,2;1,2]))
-%!error(cellfun(@factorial,{-1,3}))
-%!assert(cellfun(@factorial,{-1,3},'ErrorHandler',@(x,y) NaN),[NaN,6])
+%!assert (cellfun (@sin, {0,1}), sin ([0,1]))
+%!assert (cellfun (inline ("sin (x)"), {0,1}), sin ([0,1]))
+%!assert (cellfun ("sin", {0,1}), sin ([0,1]))
+%!assert (cellfun ("isempty", {1,[]}), [false,true])
+%!assert (cellfun ("islogical", {false,pi}), [true,false])
+%!assert (cellfun ("isreal", {1i,1}), [false,true])
+%!assert (cellfun ("length", {zeros(2,2),1}), [2,1])
+%!assert (cellfun ("prodofsize", {zeros(2,2),1}), [4,1])
+%!assert (cellfun ("ndims", {zeros([2,2,2]),1}), [3,2])
+%!assert (cellfun ("isclass", {zeros([2,2,2]),"test"}, "double"), [true,false])
+%!assert (cellfun ("size", {zeros([1,2,3]),1}, 1), [1,1])
+%!assert (cellfun ("size", {zeros([1,2,3]),1}, 2), [2,1])
+%!assert (cellfun ("size", {zeros([1,2,3]),1}, 3), [3,1])
+%!assert (cellfun (@atan2, {1,1}, {1,2}), [atan2(1,1), atan2(1,2)])
+%!assert (cellfun (@atan2, {1,1}, {1,2},"UniformOutput", false), {atan2(1,1), atan2(1,2)})
+%!assert (cellfun (@sin, {1,2;3,4}), sin ([1,2;3,4]))
+%!assert (cellfun (@atan2, {1,1;1,1}, {1,2;1,2}), atan2 ([1,1;1,1],[1,2;1,2]))
+%!error cellfun (@factorial, {-1,3})
+%!assert (cellfun (@factorial,{-1,3},"ErrorHandler",@(x,y) NaN), [NaN,6])
 %!test
-%! [a,b,c]=cellfun(@fileparts,{fullfile("a","b","c.d"),fullfile("e","f","g.h")},'UniformOutput',false);
-%! assert(a,{fullfile("a","b"),fullfile("e","f")})
-%! assert(b,{'c','g'})
-%! assert(c,{'.d','.h'})
+%! [a,b,c] = cellfun (@fileparts, {fullfile("a","b","c.d"), fullfile("e","f","g.h")}, "UniformOutput", false);
+%! assert (a, {fullfile("a","b"), fullfile("e","f")});
+%! assert (b, {"c", "g"});
+%! assert (c, {".d", ".h"});
 
+%!error cellfun (1)
+%!error cellfun ("isclass", 1)
+%!error cellfun ("size", 1)
+%!error cellfun (@sin, {[]}, "BadParam", false)
+%!error cellfun (@sin, {[]}, "UniformOuput")
+%!error cellfun (@sin, {[]}, "ErrorHandler")
 */
 
 // Arrayfun was originally a .m file written by Bill Denney and Jaroslav
 // Hajek.  It was converted to C++ by jwe so that it could properly
 // handle the nargout = 0 case.
 
 DEFUN_DLD (arrayfun, args, nargout,
   "-*- texinfo -*-\n\
@@ -1431,224 +1432,228 @@ arrayfun (@@str2num, [1234],\n\
   else
     error ("arrayfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 %!function r = __f11 (x)
-%!  global __arrayfun_test_num_outputs__
+%!  global __arrayfun_test_num_outputs__;
 %!  __arrayfun_test_num_outputs__ = nargout;
 %!  r = x;
 %!endfunction
 
 %!function __f01 (x)
-%!  global __arrayfun_test_num_outputs__
+%!  global __arrayfun_test_num_outputs__;
 %!  __arrayfun_test_num_outputs__ = nargout;
 %!endfunction
 
 %!test
-%! global __arrayfun_test_num_outputs__
+%! global __arrayfun_test_num_outputs__;
 %! arrayfun (@__f11, {1});
-%! assert (__arrayfun_test_num_outputs__, 0)
+%! assert (__arrayfun_test_num_outputs__, 0);
 %! x = arrayfun (@__f11, {1});
-%! assert (__arrayfun_test_num_outputs__, 1)
+%! assert (__arrayfun_test_num_outputs__, 1);
 
 %!test
-%! global __arrayfun_test_num_outputs__
+%! global __arrayfun_test_num_outputs__;
 %! arrayfun (@__f01, {1});
-%! assert (__arrayfun_test_num_outputs__, 0)
+%! assert (__arrayfun_test_num_outputs__, 0);
 
 %!error x = arrayfun (@__f01, [1, 2]);
 
 %!test
-%! assert (arrayfun (@__f11, [1, 2]), [1, 2])
-%! assert (arrayfun (@__f11, [1, 2], 'uniformoutput', false), {1, 2});
-%! assert (arrayfun (@__f11, {1, 2}), {1, 2})
-%! assert (arrayfun (@__f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
+%! assert (arrayfun (@__f11, [1, 2]), [1, 2]);
+%! assert (arrayfun (@__f11, [1, 2], "uniformoutput", false), {1, 2});
+%! assert (arrayfun (@__f11, {1, 2}), {1, 2});
+%! assert (arrayfun (@__f11, {1, 2}, "uniformoutput", false), {{1}, {2}});
 
-%!assert (arrayfun (@ones, 1, [2,3], 'uniformoutput', false), {[1,1], [1,1,1]});
+%!assert (arrayfun (@ones, 1, [2,3], "uniformoutput", false), {[1,1], [1,1,1]})
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = __arrayfunerror (S, varargin)
-%!      z = S;
+%!function z = __arrayfunerror (S, varargin)
+%!  z = S;
 %!endfunction
 %% First input argument can be a string, an inline function, a
 %% function_handle or an anonymous function
 %!test
-%!  arrayfun (@isequal, [false, true], [true, true]); %% No output argument
+%! arrayfun (@isequal, [false, true], [true, true]); %% No output argument
 %!error
-%!  arrayfun (@isequal); %% One or less input arguments
+%! arrayfun (@isequal); %% One or less input arguments
 %!test
-%!  A = arrayfun ("isequal", [false, true], [true, true]);
-%!  assert (A, [false, true]);
+%! A = arrayfun ("isequal", [false, true], [true, true]);
+%! assert (A, [false, true]);
 %!test
-%!  A = arrayfun (inline ("(x == y)", "x", "y"), [false, true], [true, true]);
-%!  assert (A, [false, true]);
+%! A = arrayfun (inline ("(x == y)", "x", "y"), [false, true], [true, true]);
+%! assert (A, [false, true]);
 %!test
-%!  A = arrayfun (@isequal, [false, true], [true, true]);
-%!  assert (A, [false, true]);
+%! A = arrayfun (@isequal, [false, true], [true, true]);
+%! assert (A, [false, true]);
 %!test
-%!  A = arrayfun (@(x,y) isequal(x,y), [false, true], [true, true]);
-%!  assert (A, [false, true]);
+%! A = arrayfun (@(x,y) isequal(x,y), [false, true], [true, true]);
+%! assert (A, [false, true]);
 
 %% Number of input and output arguments may be greater than one
 %#!test
-%!  A = arrayfun (@(x) islogical (x), false);
-%!  assert (A, true);
+%! A = arrayfun (@(x) islogical (x), false);
+%! assert (A, true);
 %!test
-%!  A = arrayfun (@(x,y,z) x + y + z, [1, 1, 1], [2, 2, 2], [3, 4, 5]);
-%!  assert (A, [6, 7, 8], 1e-16);
+%! A = arrayfun (@(x,y,z) x + y + z, [1, 1, 1], [2, 2, 2], [3, 4, 5]);
+%! assert (A, [6, 7, 8], 1e-16);
 %!test %% Two input arguments of different types
-%!  A = arrayfun (@(x,y) islogical (x) && ischar (y), false, "a");
-%!  assert (A, true);
+%! A = arrayfun (@(x,y) islogical (x) && ischar (y), false, "a");
+%! assert (A, true);
 %!test %% Pass another variable to the anonymous function
-%!  y = true; A = arrayfun (@(x) islogical (x && y), false);
-%!  assert (A, true);
+%! y = true;
+%! A = arrayfun (@(x) islogical (x && y), false);
+%! assert (A, true);
 %!test %% Three ouptut arguments of different type
-%!  [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
-%!  assert (isequal (A, {true, true; [], true}));
-%!  assert (isequal (B, {true, true; [], true}));
-%!  assert (isequal (C, {10, 11; [], 12}));
+%! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
+%! assert (isequal (A, {true, true; [], true}));
+%! assert (isequal (B, {true, true; [], true}));
+%! assert (isequal (C, {10, 11; [], 12}));
 
 %% Input arguments can be of type logical
 %!test
-%!  A = arrayfun (@(x,y) x == y, [false, true], [true, true]);
-%!  assert (A, [false, true]);
+%! A = arrayfun (@(x,y) x == y, [false, true], [true, true]);
+%! assert (A, [false, true]);
 %!test
-%!  A = arrayfun (@(x,y) x == y, [false; true], [true; true], "UniformOutput", true);
-%!  assert (A, [false; true]);
+%! A = arrayfun (@(x,y) x == y, [false; true], [true; true], "UniformOutput", true);
+%! assert (A, [false; true]);
 %!test
-%!  A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
-%!  assert (A, {false, true, false, true});
+%! A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
+%! assert (A, {false, true, false, true});
 %!test %% Three ouptut arguments of same type
-%!  [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
-%!  assert (isequal (A, {true, []; [], true}));
-%!  assert (isequal (B, {true, []; [], true}));
-%!  assert (isequal (C, {true, []; [], true}));
+%! [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
+%! assert (isequal (A, {true, []; [], true}));
+%! assert (isequal (B, {true, []; [], true}));
+%! assert (isequal (C, {true, []; [], true}));
 %!test
-%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @__arrayfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! A = arrayfun (@(x,y) array2str (x,y), true, true, \
+%!               "ErrorHandler", @__arrayfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = arrayfun (@(x,y) array2str (x,y), true, true, \
-%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! A = arrayfun (@(x,y) array2str (x,y), true, true, "UniformOutput", true, \
+%!               "ErrorHandler", @__arrayfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 
 %% Input arguments can be of type numeric
 %!test
-%!  A = arrayfun (@(x,y) x>y, [1.1, 4.2], [3.1, 2+3*i]);
-%!  assert (A, [false, true]);
+%! A = arrayfun (@(x,y) x>y, [1.1, 4.2], [3.1, 2+3*i]);
+%! assert (A, [false, true]);
 %!test
-%!  A = arrayfun (@(x,y) x>y, [1.1, 4.2; 2, 4], [3.1, 2; 2, 4+2*i], "UniformOutput", true);
-%!  assert (A, [false, true; false, false]);
+%! A = arrayfun (@(x,y) x>y, [1.1, 4.2; 2, 4], [3.1, 2; 2, 4+2*i], "UniformOutput", true);
+%! assert (A, [false, true; false, false]);
 %!test
-%!  A = arrayfun (@(x,y) x:y, [1.1, 4], [3.1, 6], "UniformOutput", false);
-%!  assert (isequal (A{1}, [1.1, 2.1, 3.1]));
-%!  assert (isequal (A{2}, [4, 5, 6]));
+%! A = arrayfun (@(x,y) x:y, [1.1, 4], [3.1, 6], "UniformOutput", false);
+%! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
+%! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
-%!  [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
-%!  assert (isequal (A, {true, true; [], true}));
-%!  assert (isequal (B, {true, true; [], true}));
-%!  assert (isequal (C, {10, 11; [], 12}));
+%! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
+%! assert (isequal (A, {true, true; [], true}));
+%! assert (isequal (B, {true, true; [], true}));
+%! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @__arrayfunerror);
-%!  B = isfield (A(1), "message") && isfield (A(1), "index");
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%!               "ErrorHandler", @__arrayfunerror);
+%! B = isfield (A(1), "message") && isfield (A(1), "index");
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
-%!  B = isfield (A(1), "message") && isfield (A(1), "index");
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
+%! B = isfield (A(1), "message") && isfield (A(1), "index");
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type character or strings
 %!test
-%!  A = arrayfun (@(x,y) x>y, ["ad", "c", "ghi"], ["cc", "d", "fgh"]);
-%!  assert (A, [false, true, false, true, true, true]);
+%! A = arrayfun (@(x,y) x>y, ["ad", "c", "ghi"], ["cc", "d", "fgh"]);
+%! assert (A, [false, true, false, true, true, true]);
 %!test
-%!  A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
-%!  assert (A, [false; true]);
+%! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
+%! assert (A, [false; true]);
 %!test
-%!  A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
-%!  assert (A, {"abc", "def"});
-%! %#!test
-%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @__arrayfunerror);
-%!   B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
-%!   assert (B, true);
+%! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
+%! assert (A, {"abc", "def"});
+%!test
+%! A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], \
+%!               "ErrorHandler", @__arrayfunerror);
+%! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
+%! assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
-%!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
-%!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
-%!  assert (A, true);
+%! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
+%! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
+%! assert (A, true);
 %!test
-%!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
-%!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b, "UniformOutput", true);
-%!  assert (A, true);
+%! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
+%! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b, "UniformOutput", true);
+%! assert (A, true);
 %!test
-%!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
-%!  A = arrayfun (@(x,y) x.a:y.a, a, b, "UniformOutput", false);
-%!  assert (isequal (A, {[1.1, 2.1, 3.1]}));
+%! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
+%! A = arrayfun (@(x,y) x.a:y.a, a, b, "UniformOutput", false);
+%! assert (isequal (A, {[1.1, 2.1, 3.1]}));
 %!test
-%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%!  A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
-%!                "ErrorHandler", @__arrayfunerror);
-%!  assert (isfield (A, "identifier"), true);
-%!  assert (isfield (A, "message"), true);
-%!  assert (isfield (A, "index"), true);
-%!  assert (isempty (A.message), false);
-%!  assert (A.index, 1);
+%! A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
+%!               "ErrorHandler", @__arrayfunerror);
+%! assert (isfield (A, "identifier"), true);
+%! assert (isfield (A, "message"), true);
+%! assert (isfield (A, "index"), true);
+%! assert (isempty (A.message), false);
+%! assert (A.index, 1);
 
 %% Input arguments can be of type cell array
 %!test
-%!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2});
-%!  assert (A, [true, false]);
+%! A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2});
+%! assert (A, [true, false]);
 %!test
-%!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1; 4.2}, {3.1; 2}, "UniformOutput", true);
-%!  assert (A, [true; false]);
+%! A = arrayfun (@(x,y) x{1} < y{1}, {1.1; 4.2}, {3.1; 2}, "UniformOutput", true);
+%! assert (A, [true; false]);
 %!test
-%!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2}, "UniformOutput", false);
-%!  assert (A, {true, false});
+%! A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2}, "UniformOutput", false);
+%! assert (A, {true, false});
 %!test
-%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 %!test
-%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
-%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
-%!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
-%!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
-%!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
-%!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
-%!  assert ([A(1).index, A(2).index], [1, 2]);
+%! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
+%!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
+%! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
+%! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
+%! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
+%! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
+%! assert ([A(1).index, A(2).index], [1, 2]);
 */
 
 static void
 do_num2cell_helper (const dim_vector& dv,
                     const Array<int>& dimv,
                     dim_vector& celldv, dim_vector& arraydv,
                     Array<int>& perm)
 {
@@ -1899,21 +1904,19 @@ num2cell ([1,2;3,4],1)\n\
       else
         gripe_wrong_type_arg ("num2cell", array);
     }
 
   return retval;
 }
 
 /*
-
-%!assert(num2cell([1,2;3,4]),{1,2;3,4})
-%!assert(num2cell([1,2;3,4],1),{[1;3],[2;4]})
-%!assert(num2cell([1,2;3,4],2),{[1,2];[3,4]})
-
+%!assert (num2cell ([1,2;3,4]), {1,2;3,4})
+%!assert (num2cell ([1,2;3,4], 1), {[1;3],[2;4]})
+%!assert (num2cell ([1,2;3,4], 2), {[1,2];[3,4]})
 */
 
 static bool
 mat2cell_mismatch (const dim_vector& dv,
                    const Array<octave_idx_type> *d, int nd)
 {
   for (int i = 0; i < nd; i++)
     {
@@ -2247,28 +2250,26 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
           retval = do_mat2cell (a, d, nargin-1);
         }
     }
 
   return retval;
 }
 
 /*
+%!test
+%! x = reshape (1:20, 5, 4);
+%! c = mat2cell (x, [3,2], [3,1]);
+%! assert (c, {[1,6,11;2,7,12;3,8,13],[16;17;18];[4,9,14;5,10,15],[19;20]});
 
 %!test
-%! x = reshape(1:20,5,4);
-%! c = mat2cell(x,[3,2],[3,1]);
-%! assert(c,{[1,6,11;2,7,12;3,8,13],[16;17;18];[4,9,14;5,10,15],[19;20]})
-
-%!test
-%! x = 'abcdefghij';
-%! c = mat2cell(x,1,[0,4,2,0,4,0]);
-%! empty1by0str = resize('',1,0);
-%! assert(c,{empty1by0str,'abcd','ef',empty1by0str,'ghij',empty1by0str})
-
+%! x = "abcdefghij";
+%! c = mat2cell (x, 1, [0,4,2,0,4,0]);
+%! empty1by0str = resize ("", 1, 0);
+%! assert (c, {empty1by0str,"abcd","ef",empty1by0str,"ghij",empty1by0str});
 */
 
 // FIXME: it would be nice to allow ranges being handled without a conversion.
 template <class NDA>
 static Cell
 do_cellslices_nda (const NDA& array,
                    const Array<octave_idx_type>& lb,
                    const Array<octave_idx_type>& ub,
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -366,26 +366,24 @@ sparse matrices.\n\
             gripe_wrong_type_arg ("chol", arg);
         }
     }
 
   return retval;
 }
 
 /*
-
-%!assert(chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps));
-%!assert(chol (single([2, 1; 1, 1])), single([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps('single')));
+%!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
+%!assert (chol (single([2, 1; 1, 1])), single([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
 
-%!error chol ([1, 2; 3, 4]);
-%!error chol ([1, 2; 3, 4; 5, 6]);
-%!error <Invalid call to chol> chol ();
-%!error <unexpected second or third input> chol (1, 2);
-
- */
+%!error <matrix must be positive definite> chol ([1, 2; 3, 4])
+%!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
+%!error chol ()
+%!error <unexpected second or third input> chol (1, 2)
+*/
 
 DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
 Use the Cholesky@tie{}factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{A}.\n\
 @seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
@@ -508,30 +506,28 @@ symmetric positive definite matrix @var{
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!shared A, Ainv
 %! A = [2,0.2;0.2,1];
-%! Ainv = inv(A);
+%! Ainv = inv (A);
 %!test
-%! Ainv1 = cholinv(A);
-%! assert (norm(Ainv-Ainv1),0,1e-10)
+%! Ainv1 = cholinv (A);
+%! assert (norm (Ainv-Ainv1), 0, 1e-10);
 %!testif HAVE_CHOLMOD
-%! Ainv2 = inv(sparse(A));
-%! assert (norm(Ainv-Ainv2),0,1e-10)
+%! Ainv2 = inv (sparse (A));
+%! assert (norm (Ainv-Ainv2), 0, 1e-10);
 %!testif HAVE_CHOLMOD
-%! Ainv3 = cholinv(sparse(A));
-%! assert (norm(Ainv-Ainv3),0,1e-10)
-
+%! Ainv3 = cholinv (sparse (A));
+%! assert (norm (Ainv-Ainv3), 0, 1e-10);
 */
 
 DEFUN_DLD (chol2inv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} chol2inv (@var{U})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
 decomposition, @var{U}.  Note that @var{U} should be an upper-triangular\n\
 matrix with positive diagonal elements.  @code{chol2inv (@var{U})}\n\
@@ -781,69 +777,55 @@ If @var{info} is not present, an error m
 %!         0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
 %!        -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
 %!
 %! uc = [ 0.54267 + 0.91519i ;
 %!        0.99647 + 0.43141i ;
 %!        0.83760 + 0.68977i ;
 %!        0.39160 + 0.90378i ];
 
-
+%!test
+%! R = chol (A);
+%! R1 = cholupdate (R, u);
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - R'*R - u*u', Inf) < 1e1*eps);
+%!
+%! R1 = cholupdate (R1, u, "-");
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1 - R, Inf) < 1e1*eps);
 
 %!test
-%! R = chol(A);
-%!
-%! R1 = cholupdate(R,u);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - R'*R - u*u',Inf) < 1e1*eps)
-%!
-%! R1 = cholupdate(R1,u,"-");
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1 - R,Inf) < 1e1*eps)
+%! R = chol (Ac);
+%! R1 = cholupdate (R, uc);
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - R'*R - uc*uc', Inf) < 1e1*eps);
 %!
-%!test
-%! R = chol(Ac);
-%!
-%! R1 = cholupdate(R,uc);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - R'*R - uc*uc',Inf) < 1e1*eps)
-%!
-%! R1 = cholupdate(R1,uc,"-");
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1 - R,Inf) < 1e1*eps)
+%! R1 = cholupdate (R1, uc, "-");
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1 - R, Inf) < 1e1*eps);
 
 %!test
-%! R = chol(single(A));
-%!
-%! R1 = cholupdate(R,single(u));
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - R'*R - single(u*u'),Inf) < 1e1*eps('single'))
-%!
-%! R1 = cholupdate(R1,single(u),"-");
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1 - R,Inf) < 2e1*eps('single'))
+%! R = chol (single (A));
+%! R1 = cholupdate (R, single (u));
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (R1'*R1 - R'*R - single (u*u'), Inf) < 1e1*eps ("single"));
 %!
+%! R1 = cholupdate (R1, single (u), "-");
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (R1 - R, Inf) < 2e1*eps ("single"));
+
 %!test
-%! R = chol(single(Ac));
-%!
-%! R1 = cholupdate(R,single(uc));
+%! R = chol (single (Ac));
+%! R1 = cholupdate (R, single (uc));
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (R1'*R1 - R'*R - single (uc*uc'), Inf) < 1e1*eps ("single"));
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - R'*R - single(uc*uc'),Inf) < 1e1*eps('single'))
-%!
-%! R1 = cholupdate(R1,single(uc),"-");
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1 - R,Inf) < 2e1*eps('single'))
+%! R1 = cholupdate (R1, single (uc), "-");
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (R1 - R, Inf) < 2e1*eps ("single"));
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 @deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
@@ -967,142 +949,143 @@ If @var{info} is not present, an error m
 /*
 %!test
 %! u2 = [  0.35080 ;
 %!         0.63930 ;
 %!         3.31057 ;
 %!        -0.13825 ;
 %!         0.45266 ];
 %!
-%! R = chol(A);
+%! R = chol (A);
 %!
-%! j = 3; p = [1:j-1, j+1:5];
-%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
+%! j = 3;  p = [1:j-1, j+1:5];
+%! R1 = cholinsert (R, j, u2);
+%! A1 = R1'*R1;
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(A1(p,p) - A,Inf) < 1e1*eps)
-%!
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (A1(p,p) - A, Inf) < 1e1*eps);
+
 %!test
 %! u2 = [  0.35080  + 0.04298i;
 %!         0.63930  + 0.23778i;
 %!         3.31057  + 0.00000i;
 %!        -0.13825  + 0.19879i;
 %!         0.45266  + 0.50020i];
 %!
-%! R = chol(Ac);
+%! R = chol (Ac);
 %!
-%! j = 3; p = [1:j-1, j+1:5];
-%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
+%! j = 3;  p = [1:j-1, j+1:5];
+%! R1 = cholinsert (R, j, u2);
+%! A1 = R1'*R1;
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(A1(p,p) - Ac,Inf) < 1e1*eps)
-%!
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (A1(p,p) - Ac, Inf) < 1e1*eps);
 
 %!test
 %! u2 = single ([  0.35080 ;
 %!                 0.63930 ;
 %!                 3.31057 ;
 %!                -0.13825 ;
 %!                 0.45266 ]);
 %!
 %! R = chol(single(A));
 %!
-%! j = 3; p = [1:j-1, j+1:5];
-%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
+%! j = 3;  p = [1:j-1, j+1:5];
+%! R1 = cholinsert (R, j, u2);
+%! A1 = R1'*R1;
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(A1(p,p) - A,Inf) < 1e1*eps('single'))
-%!
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (A1(p,p) - A, Inf) < 1e1*eps ("single"));
+
 %!test
 %! u2 = single ([  0.35080  + 0.04298i;
 %!                 0.63930  + 0.23778i;
 %!                 3.31057  + 0.00000i;
 %!                -0.13825  + 0.19879i;
 %!                 0.45266  + 0.50020i]);
 %!
-%! R = chol(single(Ac));
+%! R = chol (single (Ac));
 %!
-%! j = 3; p = [1:j-1, j+1:5];
-%! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
+%! j = 3;  p = [1:j-1, j+1:5];
+%! R1 = cholinsert (R, j, u2);
+%! A1 = R1'*R1;
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(A1(p,p) - single(Ac),Inf) < 2e1*eps('single'))
-%!
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (A1(p,p) - single (Ac), Inf) < 2e1*eps ("single"));
 
 %!test
-%! cu = chol (triu (A), 'upper');
-%! cl = chol (tril (A), 'lower');
-%! assert (cu, cl', eps)
-%!
+%! cu = chol (triu (A), "upper");
+%! cl = chol (tril (A), "lower");
+%! assert (cu, cl', eps);
+
 %!test
 %! cca  = chol (Ac);
 %!
-%! ccal  = chol (Ac, 'lower');
-%! ccal2 = chol (tril (Ac), 'lower');
+%! ccal  = chol (Ac, "lower");
+%! ccal2 = chol (tril (Ac), "lower");
 %!
-%! ccau  = chol (Ac, 'upper');
-%! ccau2 = chol (triu (Ac), 'upper');
+%! ccau  = chol (Ac, "upper");
+%! ccau2 = chol (triu (Ac), "upper");
 %!
-%! assert (cca'*cca,     Ac, eps)
-%! assert (ccau'*ccau,   Ac, eps)
-%! assert (ccau2'*ccau2, Ac, eps)
+%! assert (cca'*cca,     Ac, eps);
+%! assert (ccau'*ccau,   Ac, eps);
+%! assert (ccau2'*ccau2, Ac, eps);
 %!
-%! assert (cca, ccal',  eps)
-%! assert (cca, ccau,   eps)
-%! assert (cca, ccal2', eps)
-%! assert (cca, ccau2,  eps)
-%!
+%! assert (cca, ccal',  eps);
+%! assert (cca, ccau,   eps);
+%! assert (cca, ccal2', eps);
+%! assert (cca, ccau2,  eps);
+
 %!test
 %! cca  = chol (single (Ac));
 %!
-%! ccal  = chol (single (Ac), 'lower');
-%! ccal2 = chol (tril (single (Ac)), 'lower');
+%! ccal  = chol (single (Ac), "lower");
+%! ccal2 = chol (tril (single (Ac)), "lower");
 %!
-%! ccau  = chol (single (Ac), 'upper');
-%! ccau2 = chol (triu (single (Ac)), 'upper');
+%! ccau  = chol (single (Ac), "upper");
+%! ccau2 = chol (triu (single (Ac)), "upper");
 %!
-%! assert (cca'*cca,     single (Ac), eps ('single'))
-%! assert (ccau'*ccau,   single (Ac), eps ('single'))
-%! assert (ccau2'*ccau2, single (Ac), eps ('single'))
+%! assert (cca'*cca,     single (Ac), eps ("single"));
+%! assert (ccau'*ccau,   single (Ac), eps ("single"));
+%! assert (ccau2'*ccau2, single (Ac), eps ("single"));
 %!
-%! assert (cca, ccal',  eps ('single'))
-%! assert (cca, ccau,   eps ('single'))
-%! assert (cca, ccal2', eps ('single'))
-%! assert (cca, ccau2,  eps ('single'))
+%! assert (cca, ccal',  eps ("single"));
+%! assert (cca, ccau,   eps ("single"));
+%! assert (cca, ccal2', eps ("single"));
+%! assert (cca, ccau2,  eps ("single"));
 
 %!test
 %! a = [12,  2,  3,  4;
 %!       2, 14,  5,  3;
 %!       3,  5, 16,  6;
 %!       4,  3,  6, 16];
 %!
 %! b = [0,  1,  2,  3;
 %!     -1,  0,  1,  2;
 %!     -2, -1,  0,  1;
 %!     -3, -2, -1,  0];
 %!
 %! ca = a + i*b;
 %!   
 %! cca  = chol (ca);
 %!
-%! ccal  = chol (ca, 'lower');
-%! ccal2 = chol (tril (ca), 'lower');
+%! ccal  = chol (ca, "lower");
+%! ccal2 = chol (tril (ca), "lower");
 %!
-%! ccau  = chol (ca, 'upper');
-%! ccau2 = chol (triu (ca), 'upper');
+%! ccau  = chol (ca, "upper");
+%! ccau2 = chol (triu (ca), "upper");
 %!
-%! assert (cca'*cca,     ca, 16*eps)
-%! assert (ccau'*ccau,   ca, 16*eps)
-%! assert (ccau2'*ccau2, ca, 16*eps)
+%! assert (cca'*cca,     ca, 16*eps);
+%! assert (ccau'*ccau,   ca, 16*eps);
+%! assert (ccau2'*ccau2, ca, 16*eps);
 %!
-%! assert (cca, ccal',  16*eps)
-%! assert (cca, ccau,   16*eps)
-%! assert (cca, ccal2', 16*eps)
-%! assert (cca, ccau2,  16*eps)
-
+%! assert (cca, ccal',  16*eps);
+%! assert (cca, ccau,   16*eps);
+%! assert (cca, ccal2', 16*eps);
+%! assert (cca, ccau2,  16*eps);
 */
 
 DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
@@ -1194,48 +1177,48 @@ triangular, return the Cholesky@tie{}fac
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol(A);
 %!
-%! j = 3; p = [1:j-1,j+1:4];
-%! R1 = choldelete(R,j);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
+%! j = 3;  p = [1:j-1,j+1:4];
+%! R1 = choldelete (R, j);
 %!
-%!test
-%! R = chol(Ac);
-%!
-%! j = 3; p = [1:j-1,j+1:4];
-%! R1 = choldelete(R,j);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
-%! R = chol(single(A));
+%! R = chol (Ac);
+%!
+%! j = 3;  p = [1:j-1,j+1:4];
+%! R1 = choldelete (R, j);
 %!
-%! j = 3; p = [1:j-1,j+1:4];
-%! R1 = choldelete(R,j);
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - Ac(p,p), Inf) < 1e1*eps);
+
+%!test
+%! R = chol (single (A));
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
+%! j = 3;  p = [1:j-1,j+1:4];
+%! R1 = choldelete (R, j);
 %!
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
+
 %!test
 %! R = chol(single(Ac));
 %!
-%! j = 3; p = [1:j-1,j+1:4];
+%! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
+%! assert (norm (triu (R1)-R1, Inf), single (0));
+%! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
 
 DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
@@ -1333,67 +1316,67 @@ triangular, return the Cholesky@tie{}fac
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! R = chol(A);
+%! R = chol (A);
 %!
-%! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
-%! R1 = cholshift(R,i,j);
+%! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
+%! R1 = cholshift (R, i, j);
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 %!
-%! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
-%! R1 = cholshift(R,i,j);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
+%! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
+%! R1 = cholshift (R, i, j);
 %!
+%! assert (norm(triu(R1)-R1, Inf), 0);
+%! assert (norm(R1'*R1 - A(p,p), Inf) < 1e1*eps);
+
 %!test
-%! R = chol(Ac);
+%! R = chol (Ac);
 %!
-%! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
-%! R1 = cholshift(R,i,j);
+%! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
+%! R1 = cholshift (R, i, j);
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - Ac(p,p), Inf) < 1e1*eps);
 %!
-%! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
-%! R1 = cholshift(R,i,j);
+%! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
+%! R1 = cholshift (R, i, j);
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - Ac(p,p), Inf) < 1e1*eps);
 
 %!test
-%! R = chol(single(A));
+%! R = chol (single (A));
+%! 
+%! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
+%! R1 = cholshift (R, i, j);
+%!
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
+%!
+%! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
+%! R1 = cholshift (R, i, j);
 %!
-%! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
-%! R1 = cholshift(R,i,j);
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
+
+%!test
+%! R = chol (single (Ac));
 %!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
+%! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
+%! R1 = cholshift (R, i, j);
+%!
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 %!
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
-%! R1 = cholshift(R,i,j);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
-%!
-%!test
-%! R = chol(single(Ac));
+%! R1 = cholshift (R, i, j);
 %!
-%! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
-%! R1 = cholshift(R,i,j);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
-%!
-%! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
-%! R1 = cholshift(R,i,j);
-%!
-%! assert(norm(triu(R1)-R1,Inf) == 0)
-%! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
+%! assert (norm (triu (R1)-R1, Inf), 0);
+%! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -255,29 +255,28 @@ When the third argument is a matrix, ret
 %!assert (conv2 (A,B, "same"), C(3:5,3:6))
 %!assert (conv2 (A,B, "valid"), zeros (0, 0))
 %!assert (size (conv2 (B,A, "valid")), [3 2])
 
 %% Clear shared variables so they are not reported for tests below
 %!shared
 
 %% Test cases from Bug #34893
-%!assert (conv2 ([1:5;1:5], [1:2], 'same'), [4 7 10 13 10; 4 7 10 13 10])
-%!assert (conv2 ([1:5;1:5]', [1:2]', 'same'), [4 7 10 13 10; 4 7 10 13 10]')
-%!#assert (conv2 ([1:5;1:5], [1:2], 'valid'), [4 7 10 13; 4 7 10 13])
-%!assert (conv2 ([1:5;1:5]', [1:2]', 'valid'), [4 7 10 13; 4 7 10 13]')
+%!assert (conv2 ([1:5;1:5], [1:2], "same"), [4 7 10 13 10; 4 7 10 13 10])
+%!assert (conv2 ([1:5;1:5]', [1:2]', "same"), [4 7 10 13 10; 4 7 10 13 10]')
+%!#assert (conv2 ([1:5;1:5], [1:2], "valid"), [4 7 10 13; 4 7 10 13])
+%!assert (conv2 ([1:5;1:5]', [1:2]', "valid"), [4 7 10 13; 4 7 10 13]')
 
 %% Test input validation
 %!error conv2 ()
 %!error conv2 (1)
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
-
 */
 
 DEFUN_DLD (convn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{C} =} convn (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
 Return the n-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -290,17 +290,17 @@ convex hull is calculated.\n\n\
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "Qt");
 %! assert (size (h), [12 3]); 
 %! h = sortrows (sort (h, 2), [1:3]);
 %! assert (h, [1 2 4; 1 2 6; 1 4 8; 1 5 6; 1 5 8; 2 3 4; 2 3 7; 2 6 7; 3 4 7; 4 7 8; 5 6 7; 5 7 8]);
 %! assert (v, 1, 10*eps);
 %! [h2, v2] = convhulln (cube); % Test defaut option = "Qt"
-%! assert (size (h2), size (h))
+%! assert (size (h2), size (h));
 %! h2 = sortrows (sort (h2, 2), [1:3]);
 %! assert (h2, h);
 %! assert (v2, v, 10*eps);
 
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "QJ");
 %! assert (size (h), [12 3]); 
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -477,93 +477,89 @@ parameters for @code{dassl}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%% dassl-1.m
-%%
-%% Test dassl() function
-%%
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         20 May 1998
-%%
-%% Problem
-%%
-%%    y1' = -y2,   y1(0) = 1
-%%    y2' =  y1,   y2(0) = 0
-%%
-%% Solution
-%%
-%%    y1(t) = cos(t)
-%%    y2(t) = sin(t)
-
+## dassl-1.m
+##
+## Test dassl() function
+##
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         20 May 1998
+##
+## Problem
+##
+##    y1' = -y2,   y1(0) = 1
+##    y2' =  y1,   y2(0) = 0
+##
+## Solution
+##
+##    y1(t) = cos(t)
+##    y2(t) = sin(t)
+##
 %!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+x(2); xdot(2)-x(1)];
 %!endfunction
 
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%!
 %! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
-%! assert(all (all (abs (x - y) < tol)));
+%! assert (x, y, tol);
 
-%% dassl-2.m
-%%
-%% Test dassl() function
-%%
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         20 May 1998
-%%
-%% Based on SLATEC quick check for DASSL by Linda Petzold
-%%
-%% Problem
-%%
-%%   x1' + 10*x1 = 0,   x1(0) = 1
-%%   x1  + x2    = 1,   x2(0) = 0
-%%
-%%
-%% Solution
-%%
-%%  x1(t) = exp(-10*t)
-%%  x2(t) = 1 - x(1)
-
+## dassl-2.m
+##
+## Test dassl() function
+##
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         20 May 1998
+##
+## Based on SLATEC quick check for DASSL by Linda Petzold
+##
+## Problem
+##
+##   x1' + 10*x1 = 0,   x1(0) = 1
+##   x1  + x2    = 1,   x2(0) = 0
+##
+##
+## Solution
+##
+##  x1(t) = exp(-10*t)
+##  x2(t) = 1 - x(1)
+##
 %!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+10*x(1); x(1)+x(2)-1];
 %!endfunction
 
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [-10; 10];
 %! t = (0:0.2:1)';
 %!
 %! tol = 500 * dassl_options ("relative tolerance");
 %!
-%!
 %! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [exp(-10*t), 1-exp(-10*t)];
 %!
-%! assert(all (all (abs (x - y) < tol)));
+%! assert (x, y, tol);
 
 %!test
 %! dassl_options ("absolute tolerance", eps);
-%! assert(dassl_options ("absolute tolerance") == eps);
+%! assert (dassl_options ("absolute tolerance") == eps);
 
-%!error <Invalid call to dassl_options> dassl_options ("foo", 1, 2);
-
+%!error dassl_options ("foo", 1, 2)
 */
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -240,16 +240,14 @@ For that, use any of the condition numbe
         }
       else
         gripe_wrong_type_arg ("det", arg);
     }
   return retval;
 }
 
 /*
-
-%!assert(det ([1, 2; 3, 4]), -2, 10 * eps);
-%!assert(det (single([1, 2; 3, 4])), single(-2), 10 * eps ('single'));
-%!error <Invalid call to det> det ();
-%!error <Invalid call to det> det (1, 2);
-%!error det ([1, 2; 3, 4; 5, 6]);
-
+%!assert (det ([1, 2; 3, 4]), -2, 10*eps)
+%!assert (det (single ([1, 2; 3, 4])), single (-2), 10*eps ("single"))
+%!error det ()
+%!error det (1, 2)
+%!error <argument must be a square matrix> det ([1, 2; 3, 4; 5, 6])
 */
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -475,48 +475,46 @@ fields.  The default is zero.\n\
       else
         retval(0) = rdata;
     }
 
   return retval;
 }
 
 /*
-
 %!shared file
 %! file = tmpnam ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4, 5, 6\n7, 8, 9\n10, 11, 12");
 %! fclose (fid);
 
-%!assert (dlmread (file), [1, 2, 3; 4, 5, 6; 7, 8, 9;10, 11, 12]);
-%!assert (dlmread (file, ","), [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12]);
-%!assert (dlmread (file, ",", [1, 0, 2, 1]), [4, 5; 7, 8]);
-%!assert (dlmread (file, ",", "B1..C2"), [2, 3; 5, 6]);
-%!assert (dlmread (file, ",", "B1:C2"), [2, 3; 5, 6]);
-%!assert (dlmread (file, ",", "..C2"), [1, 2, 3; 4, 5, 6]);
-%!assert (dlmread (file, ",", 0, 1), [2, 3; 5, 6; 8, 9; 11, 12]);
-%!assert (dlmread (file, ",", "B1.."), [2, 3; 5, 6; 8, 9; 11, 12]);
+%!assert (dlmread (file), [1, 2, 3; 4, 5, 6; 7, 8, 9;10, 11, 12])
+%!assert (dlmread (file, ","), [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12])
+%!assert (dlmread (file, ",", [1, 0, 2, 1]), [4, 5; 7, 8])
+%!assert (dlmread (file, ",", "B1..C2"), [2, 3; 5, 6])
+%!assert (dlmread (file, ",", "B1:C2"), [2, 3; 5, 6])
+%!assert (dlmread (file, ",", "..C2"), [1, 2, 3; 4, 5, 6])
+%!assert (dlmread (file, ",", 0, 1), [2, 3; 5, 6; 8, 9; 11, 12])
+%!assert (dlmread (file, ",", "B1.."), [2, 3; 5, 6; 8, 9; 11, 12])
 %!error (dlmread (file, ",", [0 1]))
 
 %!test
 %! unlink (file);
 
 %!shared file
 %! file = tmpnam ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4+4i, 5, 6\n7, 8, 9\n10, 11, 12");
 %! fclose (fid);
 
-%!assert (dlmread (file), [1, 2, 3; 4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
-%!assert (dlmread (file, ","), [1, 2, 3; 4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
-%!assert (dlmread (file, ",", [1, 0, 2, 1]), [4 + 4i, 5; 7, 8]);
-%!assert (dlmread (file, ",", "A2..B3"), [4 + 4i, 5; 7, 8]);
-%!assert (dlmread (file, ",", "A2:B3"), [4 + 4i, 5; 7, 8]);
-%!assert (dlmread (file, ",", "..B3"), [1, 2; 4 + 4i, 5; 7, 8]);
-%!assert (dlmread (file, ",", 1, 0), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
-%!assert (dlmread (file, ",", "A2.."), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
+%!assert (dlmread (file), [1, 2, 3; 4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12])
+%!assert (dlmread (file, ","), [1, 2, 3; 4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12])
+%!assert (dlmread (file, ",", [1, 0, 2, 1]), [4 + 4i, 5; 7, 8])
+%!assert (dlmread (file, ",", "A2..B3"), [4 + 4i, 5; 7, 8])
+%!assert (dlmread (file, ",", "A2:B3"), [4 + 4i, 5; 7, 8])
+%!assert (dlmread (file, ",", "..B3"), [1, 2; 4 + 4i, 5; 7, 8])
+%!assert (dlmread (file, ",", 1, 0), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12])
+%!assert (dlmread (file, ",", "A2.."), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12])
 %!error (dlmread (file, ",", [0 1]))
 
 %!test
 %! unlink (file);
-
 */
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -167,30 +167,29 @@ 16(4):303-324, 1990.\n\
 #else
   error ("dmperm: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 /*
-
 %!testif HAVE_CXSPARSE
-%! n=20;
-%! a=speye(n,n);a=a(randperm(n),:);
-%! assert(a(dmperm(a),:),speye(n))
+%! n = 20;
+%! a = speye (n,n);
+%! a = a(randperm (n),:);
+%! assert (a(dmperm (a),:), speye (n));
 
 %!testif HAVE_CXSPARSE
-%! n=20;
-%! d=0.2;
-%! a=tril(sprandn(n,n,d),-1)+speye(n,n);
-%! a=a(randperm(n),randperm(n));
-%! [p,q,r,s]=dmperm(a);
-%! assert(tril(a(p,q),-1),sparse(n,n))
-
+%! n = 20;
+%! d = 0.2;
+%! a = tril (sprandn (n,n,d), -1) + speye (n,n);
+%! a = a(randperm (n), randperm (n));
+%! [p,q,r,s] = dmperm (a);
+%! assert (tril (a(p,q), -1), sparse (n, n));
 */
 
 DEFUN_DLD (sprank, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} sprank (@var{S})\n\
 @cindex structural rank\n\
 \n\
 Calculate the structural rank of the sparse matrix @var{S}.  Note that\n\
@@ -216,16 +215,15 @@ numerical rank of the matrix @var{S} is 
 #else
   error ("sprank: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 /*
-
-%!error(sprank(1,2));
+%!testif HAVE_CXSPARSE
+%! assert (sprank (speye (20)), 20)
 %!testif HAVE_CXSPARSE
-%! assert(sprank(speye(20)), 20)
-%!testif HAVE_CXSPARSE
-%! assert(sprank([1,0,2,0;2,0,4,0]),2)
+%! assert (sprank ([1,0,2,0;2,0,4,0]), 2)
 
+%!error sprank (1,2)
 */
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -232,28 +232,26 @@ but avoids forming a temporary array and
     }
   else
     error ("dot: X and Y must be numeric");
 
   return retval;
 }
 
 /*
-
-%! assert(dot ([1, 2], [2, 3]), 11);
+%!assert (dot ([1, 2], [2, 3]), 8)
 
 %!test
 %! x = [2, 1; 2, 1];
 %! y = [-0.5, 2; 0.5, -2];
-%! assert(dot (x, y), [0 0]);
+%! assert (dot (x, y), [0 0]);
 
 %!test
-%! x = [ 1+i, 3-i; 1-i, 3-i];
-%! assert(dot (x, x), [4, 20]);
-
+%! x = [1+i, 3-i; 1-i, 3-i];
+%! assert (dot (x, x), [4, 20]);
 */
 
 DEFUN_DLD (blkmm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
@@ -352,17 +350,15 @@ endfor\n\
     }
   else
     error ("blkmm: A and B must be numeric");
 
   return retval;
 }
 
 /*
-
 %!test
 %! x(:,:,1) = [1 2; 3 4];
 %! x(:,:,2) = [1 1; 1 1];
 %! z(:,:,1) = [7 10; 15 22];
 %! z(:,:,2) = [2 2; 2 2];
-%! assert(blkmm (x,x),z);
-
+%! assert (blkmm (x,x), z);
 */
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -249,88 +249,86 @@ The eigenvalues returned by @code{eig} a
             }
         }
     }
 
   return retval;
 }
 
 /*
-
-%!assert(eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps));
+%!assert (eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps))
 
 %!test
 %! [v, d] = eig ([1, 2; 2, 1]);
 %! x = 1 / sqrt (2);
-%! assert(d, [-1, 0; 0, 3], sqrt (eps));
-%! assert(v, [-x, x; x, x], sqrt (eps));
+%! assert (d, [-1, 0; 0, 3], sqrt (eps));
+%! assert (v, [-x, x; x, x], sqrt (eps));
 
-%!assert(eig (single ([1, 2; 2, 1])), single([-1; 3]), sqrt (eps('single')));
+%!assert (eig (single ([1, 2; 2, 1])), single ([-1; 3]), sqrt (eps ("single")))
 
 %!test
-%! [v, d] = eig (single([1, 2; 2, 1]));
-%! x = single(1 / sqrt (2));
-%! assert(d, single([-1, 0; 0, 3]), sqrt (eps('single')));
-%! assert(v, [-x, x; x, x], sqrt (eps('single')));
+%! [v, d] = eig (single ([1, 2; 2, 1]));
+%! x = single (1 / sqrt (2));
+%! assert (d, single ([-1, 0; 0, 3]), sqrt (eps ("single")));
+%! assert (v, [-x, x; x, x], sqrt (eps ("single")));
 
 %!test
-%! A = [1, 2; -1, 1]; B = [3, 3; 1, 2];
+%! A = [1, 2; -1, 1];  B = [3, 3; 1, 2];
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
 
 %!test
-%! A = single([1, 2; -1, 1]); B = single([3, 3; 1, 2]);
+%! A = single ([1, 2; -1, 1]);  B = single ([3, 3; 1, 2]);
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps('single')));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps('single')));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
 
 %!test
-%! A = [1, 2; 2, 1]; B = [3, -2; -2, 3];
+%! A = [1, 2; 2, 1];  B = [3, -2; -2, 3];
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
 
 %!test
-%! A = single([1, 2; 2, 1]); B = single([3, -2; -2, 3]);
+%! A = single ([1, 2; 2, 1]);  B = single ([3, -2; -2, 3]);
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps('single')));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps('single')));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
 
 %!test
-%! A = [1+3i, 2+i; 2-i, 1+3i]; B = [5+9i, 2+i; 2-i, 5+9i];
+%! A = [1+3i, 2+i; 2-i, 1+3i];  B = [5+9i, 2+i; 2-i, 5+9i];
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
 
 %!test
-%! A = single([1+3i, 2+i; 2-i, 1+3i]); B = single([5+9i, 2+i; 2-i, 5+9i]);
+%! A = single ([1+3i, 2+i; 2-i, 1+3i]);  B = single ([5+9i, 2+i; 2-i, 5+9i]);
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps('single')));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps('single')));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
 
 %!test
-%! A = [1+3i, 2+3i; 3-8i, 8+3i]; B = [8+i, 3+i; 4-9i, 3+i];
+%! A = [1+3i, 2+3i; 3-8i, 8+3i];  B = [8+i, 3+i; 4-9i, 3+i];
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
 
 %!test
-%! A = single([1+3i, 2+3i; 3-8i, 8+3i]); B = single([8+i, 3+i; 4-9i, 3+i]);
+%! A = single ([1+3i, 2+3i; 3-8i, 8+3i]);  B = single ([8+i, 3+i; 4-9i, 3+i]);
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps('single')));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps('single')));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
 
 %!test
-%! A = [1, 2; 3, 8]; B = [8, 3; 4, 3];
+%! A = [1, 2; 3, 8];  B = [8, 3; 4, 3];
 %! [v, d] = eig (A, B);
-%! assert(A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert(A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
+%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
 
-%!error <Invalid call to eig> eig ();
-%!error <Invalid call to eig> eig ([1, 2; 3, 4], [4, 3; 2, 1], 1);
-%!error eig ([1, 2; 3, 4], 2);
-%!error eig ([1, 2; 3, 4; 5, 6]);
-%!error eig ("abcd");
-%!error eig ([1 2 ; 2 3], "abcd");
-%!error eig (false, [1 2 ; 2 3]);
-
+%!error eig ()
+%!error eig ([1, 2; 3, 4], [4, 3; 2, 1], 1)
+%!error <EIG requires same size matrices> eig ([1, 2; 3, 4], 2)
+%!error <argument must be a square matrix> eig ([1, 2; 3, 4; 5, 6])
+%!error <wrong type argument> eig ("abcd")
+%!error <wrong type argument> eig ([1 2 ; 2 3], "abcd")
+%!error <wrong type argument> eig (false, [1 2 ; 2 3])
 */
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -764,769 +764,757 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 #endif
 
   return retval;
 }
 
 /* #### SPARSE MATRIX VERSIONS #### */
 
 /*
-
-%% Real positive definite tests, n must be even
+## Real positive definite tests, n must be even
 %!shared n, k, A, d0, d2
 %! n = 20;
 %! k = 4;
-%! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
 %! d0 = eig (A);
 %! d2 = sort (d0);
-%! [~, idx] = sort (abs(d0));
+%! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A,k+1);
-%! assert (d1, d0(end:-1:(end-k)),1e-11);
+%! d1 = eigs (A, k+1);
+%! assert (d1, d0(end:-1:(end-k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lm');
+%! d1 = eigs (A, k, "lm");
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, 'sm');
+%! d1 = eigs (A, k, "sm");
 %! assert (d1, d0(k:-1:1), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'la');
+%! d1 = eigs (A, k, "la");
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sa');
+%! d1 = eigs (A, k, "sa");
 %! assert (d1, d2(1:k), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'be');
+%! d1 = eigs (A, k, "be");
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1, 'be');
+%! d1 = eigs (A, k+1, "be");
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
-%! [~,idx0] = sort (abs(d0 - 4.1));
-%! [~,idx1] = sort (abs(d1 - 4.1));
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
 %!testif HAVE_ARPACK, HAVE_CHOLMOD
-%! d1 = eigs(A, speye(n), k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, speye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
+%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, speye(n), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, speye(n), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
+%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
-%! opts.issym = 1; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'lm', opts);
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
-%! opts.issym = 1; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'sm', opts);
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! fn = @(x) (A - 4.1 * eye(n)) \ x;
-%! opts.issym = 1; opts.isreal = 1;
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 1;  opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (d1, eigs(A,k,4.1), 1e-11);
+%! assert (d1, eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! AA = speye (10);
 %! fn = @(x) AA * x;
-%! opts.issym = 1; opts.isreal = 1;
-%! assert (eigs (fn, 10, AA, 3, 'lm', opts), [1; 1; 1],10*eps);
+%! opts.issym = 1;  opts.isreal = 1;
+%! assert (eigs (fn, 10, AA, 3, "lm", opts), [1; 1; 1], 10*eps);
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! [v1,d1] = eigs(A, k, 'sm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'la');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "la");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sa');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sa");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'be');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "be");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
-
 */
 
 /*
-
-%% Real unsymmetric tests
+## Real unsymmetric tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
-%! A =  sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
+%! A =  sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
 %! d0 = eig (A);
-%! [~, idx] = sort (abs(d0));
+%! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A,k+1);
-%! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, 'sm');
-%! assert (abs(d1), abs(d0(1:k)), 1e-11);
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lr');
-%! [~, idx] = sort (real(d0));
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (d0));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sr');
-%! [~, idx] = sort (real(abs(d0)));
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(1:k)), 1e-11);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'li');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'si');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
-%! [~,idx0] = sort (abs(d0 - 4.1));
-%! [~,idx1] = sort (abs(d1 - 4.1));
-%! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
-%! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_CHOLMOD
-%! d1 = eigs(A, speye(n), k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, speye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, speye(n), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, speye(n), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
-%! opts.issym = 0; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
-%! opts.issym = 0; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'sm', opts);
-%! assert (abs(d1), d0(1:k), 1e-11);
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! fn = @(x) (A - 4.1 * eye(n)) \ x;
-%! opts.issym = 0; opts.isreal = 1;
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! [v1,d1] = eigs(A, k, 'sm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'li');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'si');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
-
 */
 
 /*
-
-%% Complex hermitian tests
+## Complex hermitian tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
-%! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
 %! d0 = eig (A);
-%! [~, idx] = sort (abs(d0));
+%! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A,k+1);
-%! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, 'sm');
-%! assert (abs(d1), abs(d0(1:k)), 1e-11);
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lr');
-%! [~, idx] = sort (real(abs(d0)));
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (abs (d0)));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sr');
-%! [~, idx] = sort (real(abs(d0)));
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(1:k)), 1e-11);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'li');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'si');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
-%! [~,idx0] = sort (abs(d0 - 4.1));
-%! [~,idx1] = sort (abs(d1 - 4.1));
-%! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
-%! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_CHOLMOD
-%! d1 = eigs(A, speye(n), k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, speye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, speye(n), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, speye(n), k, 4.1, opts);
-%! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
-%! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
-%! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
-%! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
-%! opts.issym = 0; opts.isreal = 0;
-%! d1 = eigs (fn, n, k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
-%! opts.issym = 0; opts.isreal = 0;
-%! d1 = eigs (fn, n, k, 'sm', opts);
-%! assert (abs(d1), d0(1:k), 1e-11);
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! fn = @(x) (A - 4.1 * eye(n)) \ x;
-%! opts.issym = 0; opts.isreal = 0;
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! [v1,d1] = eigs(A, k, 'sm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'li');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'si');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
-
 */
 
 /* #### FULL MATRIX VERSIONS #### */
 
 /*
-
-%% Real positive definite tests, n must be even
+## Real positive definite tests, n must be even
 %!shared n, k, A, d0, d2
 %! n = 20;
 %! k = 4;
-%! A = full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
+%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
 %! d0 = eig (A);
 %! d2 = sort (d0);
-%! [~, idx] = sort (abs(d0));
+%! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A,k+1);
+%! d1 = eigs (A, k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lm');
+%! d1 = eigs (A, k, "lm");
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sm');
+%! d1 = eigs (A, k, "sm");
 %! assert (d1, d0(k:-1:1), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'la');
+%! d1 = eigs (A, k, "la");
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sa');
+%! d1 = eigs (A, k, "sa");
 %! assert (d1, d2(1:k), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'be');
+%! d1 = eigs (A, k, "be");
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1, 'be');
+%! d1 = eigs (A, k+1, "be");
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
-%! [~,idx0] = sort (abs(d0 - 4.1));
-%! [~,idx1] = sort (abs(d1 - 4.1));
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs(A, eye(n), k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, eye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! assert (eigs(A,k,4.1), eigs(A,eye(n),k,4.1), 1e-11);
+%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, eye(n), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, eye(n), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! assert (eigs(A,k,4.1), eigs(A,eye(n),k,4.1), 1e-11);
+%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
-%! opts.issym = 1; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'lm', opts);
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
-%! opts.issym = 1; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'sm', opts);
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
 %!testif HAVE_ARPACK
-%! fn = @(x) (A - 4.1 * eye(n)) \ x;
-%! opts.issym = 1; opts.isreal = 1;
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 1;  opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (d1, eigs(A,k,4.1), 1e-11);
+%! assert (d1, eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'la');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "la");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sa');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sa");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'be');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "be");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
-
 */
 
 /*
-
-%% Real unsymmetric tests
+## Real unsymmetric tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
-%! A =  full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
+%! A =  full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
 %! d0 = eig (A);
-%! [~, idx] = sort (abs(d0));
+%! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A,k+1);
-%! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sm');
-%! assert (abs(d1), abs(d0(1:k)), 1e-11);
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lr');
-%! [~, idx] = sort (real(d0));
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (d0));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sr');
-%! [~, idx] = sort (real(abs(d0)));
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(1:k)), 1e-11);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'li');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'si');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
-%! [~,idx0] = sort (abs(d0 - 4.1));
-%! [~,idx1] = sort (abs(d1 - 4.1));
-%! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
-%! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs(A, eye(n), k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, eye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, eye(n), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, eye(n), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! assert (abs(eigs(A,k,4.1)), abs(eigs(A,eye(n),k,4.1)), 1e-11);
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
 %!testif HAVE_ARPACK
-%! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,eye(n),k,4.1))), 1e-11);
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
-%! opts.issym = 0; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
-%! opts.issym = 0; opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 'sm', opts);
-%! assert (abs(d1), d0(1:k), 1e-11);
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
 %!testif HAVE_ARPACK
-%! fn = @(x) (A - 4.1 * eye(n)) \ x;
-%! opts.issym = 0; opts.isreal = 1;
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'li');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'si');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
-
 */
 
 /*
-
-%% Complex hermitian tests
+## Complex hermitian tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
-%! A = full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
+%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
 %! d0 = eig (A);
-%! [~, idx] = sort (abs(d0));
+%! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A,k+1);
-%! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sm');
-%! assert (abs(d1), abs(d0(1:k)), 1e-11);
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'lr');
-%! [~, idx] = sort (real(abs(d0)));
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (abs (d0)));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'sr');
-%! [~, idx] = sort (real(abs(d0)));
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
 %! d2 = d0(idx);
-%! assert (real(d1), real(d2(1:k)), 1e-11);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'li');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 'si');
-%! [~, idx] = sort (imag(abs(d0)));
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
 %! d2 = d0(idx);
-%! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
-%! [~,idx0] = sort (abs(d0 - 4.1));
-%! [~,idx1] = sort (abs(d1 - 4.1));
-%! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
-%! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
 %!testif HAVE_ARPACK
-%! d1 = eigs(A, eye(n), k, 'lm');
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! d1 = eigs (A, eye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, eye(n), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
-%! d1 = eigs(A, eye(n), k, 4.1, opts);
-%! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
-%! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK
-%! opts.cholB=true;
+%! opts.cholB = true;
 %! q = [2:n,1];
-%! opts.permB=q;
-%! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
-%! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
-%! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK
-%! assert (abs(eigs(A,k,4.1)), abs(eigs(A,eye(n),k,4.1)), 1e-11);
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
 %!testif HAVE_ARPACK
-%! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,eye(n),k,4.1))), 1e-11);
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
-%! opts.issym = 0; opts.isreal = 0;
-%! d1 = eigs (fn, n, k, 'lm', opts);
-%! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
-%! opts.issym = 0; opts.isreal = 0;
-%! d1 = eigs (fn, n, k, 'sm', opts);
-%! assert (abs(d1), d0(1:k), 1e-11);
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
 %!testif HAVE_ARPACK
-%! fn = @(x) (A - 4.1 * eye(n)) \ x;
-%! opts.issym = 0; opts.isreal = 0;
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs(d1), eigs(A,k,4.1), 1e-11);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sm');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'lr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'sr');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'li');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 %!testif HAVE_ARPACK
-%! [v1,d1] = eigs(A, k, 'si');
-%! d1 = diag(d1);
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
 %! for i=1:k
-%!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
-
 */
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -172,34 +172,33 @@ do_fft (const octave_value_list &args, c
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
 /*
+%!assert (fft ([]), [])
+%!assert (fft (zeros (10,0)), zeros (10,0))
+%!assert (fft (zeros (0,10)), zeros (0,10))
+%!assert (fft (0), 0)
+%!assert (fft (1), 1)
+%!assert (fft (ones (2,2)), [2,2; 0,0])
+%!assert (fft (eye (2,2)), [1,1; 1,-1])
 
-%!error(fft())
-%!assert(fft([]), [])
-%!assert(fft(zeros(10,0)), zeros(10,0))
-%!assert(fft(zeros(0,10)), zeros(0,10))
-%!assert(fft(0), 0)
-%!assert(fft(1), 1)
-%!assert(fft(ones(2,2)), [2,2; 0,0])
-%!assert(fft(eye(2,2)), [1,1; 1,-1])
+%!assert (fft (single ([])), single ([]))
+%!assert (fft (zeros (10,0,"single")), zeros (10,0,"single"))
+%!assert (fft (zeros (0,10,"single")), zeros (0,10,"single"))
+%!assert (fft (single (0)), single (0))
+%!assert (fft (single (1)), single (1))
+%!assert (fft (ones (2,2,"single")), single ([2,2; 0,0]))
+%!assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
 
-%!assert(fft(single([])), single([]))
-%!assert(fft(zeros(10,0,'single')), zeros(10,0,'single'))
-%!assert(fft(zeros(0,10,'single')), zeros(0,10,'single'))
-%!assert(fft(single(0)), single(0))
-%!assert(fft(single(1)), single(1))
-%!assert(fft(ones(2,2,'single')), single([2,2; 0,0]))
-%!assert(fft(eye(2,2,'single')), single([1,1; 1,-1]))
-
+%!error (fft ())
 */
 
 
 DEFUN_DLD (fft, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} fft (@var{x})\n\
 @deftypefnx {Loadable Function} {} fft (@var{x}, @var{n})\n\
 @deftypefnx {Loadable Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
@@ -251,72 +250,70 @@ If called with three arguments, @var{dim
 dimension of the matrix along which the inverse FFT is performed\n\
 @seealso{fft, ifft2, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "ifft", 1);
 }
 
 /*
+%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+%%         Comalco Research and Technology
+%%         02 May 2000
+%!test
+%! N = 64;
+%! n = 4;
+%! t = 2*pi*(0:1:N-1)/N;
+%! s = cos (n*t);
+%! S = fft (s);
+%!
+%! answer = zeros (size (t));
+%! answer(n+1) = N/2;
+%! answer(N-n+1) = N/2;
+%!
+%! assert (S, answer, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! N=64;
-%! n=4;
+%! N = 64;
+%! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
-%! s = cos(n*t);
-%! S = fft(s);
-%!
-%! answer = zeros (size(t));
-%! answer(n+1) = N/2;
-%! answer(N-n+1) = N/2;
-%!
-%! assert(S, answer, 4*N*eps);
-
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
-%!test
-%! N=64;
-%! n=7;
-%! t = 2*pi*(0:1:N-1)/N;
-%! s = cos(n*t);
+%! s = cos (n*t);
 %!
 %! S = zeros (size(t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
-%! assert(ifft(S), s, 4*N*eps);
+%! assert (ifft (S), s, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! N=64;
-%! n=4;
+%! N = 64;
+%! n = 4;
 %! t = single (2*pi*(0:1:N-1)/N);
-%! s = cos(n*t);
-%! S = fft(s);
+%! s = cos (n*t);
+%! S = fft (s);
 %!
-%! answer = zeros (size(t),'single');
+%! answer = zeros (size (t), "single");
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
 %!
-%! assert(S, answer, 4*N*eps('single'));
+%! assert (S, answer, 4*N*eps ("single"));
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! N=64;
-%! n=7;
+%! N = 64;
+%! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
-%! s = cos(n*t);
+%! s = cos (n*t);
 %!
-%! S = zeros (size(t),'single');
+%! S = zeros (size (t), "single");
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
-%! assert(ifft(S), s, 4*N*eps('single'));
-
+%! assert (ifft (S), s, 4*N*eps ("single"));
 */
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -204,93 +204,91 @@ If @var{A} is a multi-dimensional matrix
 of @var{A} is treated separately\n\
 @seealso {fft2, ifft, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
+%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+%%         Comalco Research and Technology
+%%         02 May 2000
+%!test
+%! M = 16;
+%! N = 8;
+%!
+%! m = 5;
+%! n = 3;
+%!
+%! x = 2*pi*(0:1:M-1)/M;
+%! y = 2*pi*(0:1:N-1)/N;
+%! sx = cos (m*x);
+%! sy = sin (n*y);
+%! s = kron (sx',sy);
+%! S = fft2 (s);
+%! answer = kron (fft (sx)', fft (sy));
+%! assert (S, answer, 4*M*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! M=16;
-%! N=8;
-%!
-%! m=5;
-%! n=3;
+%! M = 12;
+%! N = 7;
 %!
-%! x = 2*pi*(0:1:M-1)/M;
-%! y = 2*pi*(0:1:N-1)/N;
-%! sx = cos(m*x);
-%! sy = sin(n*y);
-%! s=kron(sx',sy);
-%! S = fft2(s);
-%! answer = kron(fft(sx)',fft(sy));
-%! assert(S, answer, 4*M*N*eps);
-
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
-%!test
-%! M=12;
-%! N=7;
-%!
-%! m=3;
-%! n=2;
+%! m = 3;
+%! n = 2;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
 %!
-%! sx = cos(m*x);
-%! sy = cos(n*y);
+%! sx = cos (m*x);
+%! sy = cos (n*y);
 %!
-%! S = kron(fft(sx)',fft(sy));
-%! answer=kron(sx',sy);
-%! s = ifft2(S);
+%! S = kron (fft (sx)', fft (sy));
+%! answer = kron (sx', sy);
+%! s = ifft2 (S);
 %!
-%! assert(s, answer, 30*eps);
+%! assert (s, answer, 30*eps);
 
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! M=16;
-%! N=8;
+%! M = 16;
+%! N = 8;
 %!
-%! m=5;
-%! n=3;
+%! m = 5;
+%! n = 3;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
-%! sx = single(cos(m*x));
-%! sy = single(sin(n*y));
-%! s=kron(sx',sy);
-%! S = fft2(s);
-%! answer = kron(fft(sx)',fft(sy));
-%! assert(S, answer, 4*M*N*eps('single'));
+%! sx = single (cos (m*x));
+%! sy = single (sin (n*y));
+%! s = kron (sx', sy);
+%! S = fft2 (s);
+%! answer = kron (fft (sx)', fft (sy));
+%! assert (S, answer, 4*M*N*eps ("single"));
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
-%! M=12;
-%! N=7;
+%! M = 12;
+%! N = 7;
 %!
-%! m=3;
-%! n=2;
+%! m = 3;
+%! n = 2;
 %!
-%! x = single(2*pi*(0:1:M-1)/M);
-%! y = single(2*pi*(0:1:N-1)/N);
+%! x = single (2*pi*(0:1:M-1)/M);
+%! y = single (2*pi*(0:1:N-1)/N);
 %!
-%! sx = cos(m*x);
-%! sy = cos(n*y);
+%! sx = cos (m*x);
+%! sy = cos (n*y);
 %!
-%! S = kron(fft(sx)',fft(sy));
-%! answer=kron(sx',sy);
-%! s = ifft2(S);
+%! S = kron (fft (sx)', fft (sy));
+%! answer = kron (sx', sy);
+%! s = ifft2 (S);
 %!
-%! assert(s, answer, 30*eps('single'));
-
+%! assert (s, answer, 30*eps ("single"));
 */
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -656,78 +656,81 @@ filter (MArray<FloatComplex>&, MArray<Fl
         MArray<FloatComplex>&, int dim);
 
 template MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, int dim);
 
 /*
 %!shared a, b, x, r
 %!test
-%!  a = [1 1];
-%!  b = [1 1];
-%!  x = zeros (1,10); x(1) = 1;
-%!  assert(filter(b,   [1], x  ), [1 1 0 0 0 0 0 0 0 0]);
-%!  assert(filter(b,   [1], x.'), [1 1 0 0 0 0 0 0 0 0].');
-%!  assert(filter(b.', [1], x  ), [1 1 0 0 0 0 0 0 0 0]  );
-%!  assert(filter(b.', [1], x.'), [1 1 0 0 0 0 0 0 0 0].');
-%!  assert(filter([1], a,   x  ), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1]  );
-%!  assert(filter([1], a,   x.'), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1].');
-%!  assert(filter([1], a.', x  ), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1]  );
-%!  assert(filter([1], a.', x.'), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1].');
-%!  assert(filter(b,   a,   x  ), [1 0 0 0 0 0 0 0 0 0]  );
-%!  assert(filter(b.', a,   x  ), [1 0 0 0 0 0 0 0 0 0]  );
-%!  assert(filter(b,   a.', x  ), [1 0 0 0 0 0 0 0 0 0]  );
-%!  assert(filter(b.', a,   x  ), [1 0 0 0 0 0 0 0 0 0]  );
-%!  assert(filter(b,   a,   x.'), [1 0 0 0 0 0 0 0 0 0].');
-%!  assert(filter(b.', a,   x.'), [1 0 0 0 0 0 0 0 0 0].');
-%!  assert(filter(b,   a.', x.'), [1 0 0 0 0 0 0 0 0 0].');
-%!  assert(filter(b.', a,   x.'), [1 0 0 0 0 0 0 0 0 0].');
-%!
+%! a = [1 1];
+%! b = [1 1];
+%! x = zeros (1,10);  x(1) = 1;
+%! assert (filter (b,   [1], x  ), [1 1 0 0 0 0 0 0 0 0]);
+%! assert (filter (b,   [1], x.'), [1 1 0 0 0 0 0 0 0 0].');
+%! assert (filter (b.', [1], x  ), [1 1 0 0 0 0 0 0 0 0]  );
+%! assert (filter (b.', [1], x.'), [1 1 0 0 0 0 0 0 0 0].');
+%! assert (filter ([1], a,   x  ), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1]  );
+%! assert (filter ([1], a,   x.'), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1].');
+%! assert (filter ([1], a.', x  ), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1]  );
+%! assert (filter ([1], a.', x.'), [+1 -1 +1 -1 +1 -1 +1 -1 +1 -1].');
+%! assert (filter (b,   a,   x  ), [1 0 0 0 0 0 0 0 0 0]  );
+%! assert (filter (b.', a,   x  ), [1 0 0 0 0 0 0 0 0 0]  );
+%! assert (filter (b,   a.', x  ), [1 0 0 0 0 0 0 0 0 0]  );
+%! assert (filter (b.', a,   x  ), [1 0 0 0 0 0 0 0 0 0]  );
+%! assert (filter (b,   a,   x.'), [1 0 0 0 0 0 0 0 0 0].');
+%! assert (filter (b.', a,   x.'), [1 0 0 0 0 0 0 0 0 0].');
+%! assert (filter (b,   a.', x.'), [1 0 0 0 0 0 0 0 0 0].');
+%! assert (filter (b.', a,   x.'), [1 0 0 0 0 0 0 0 0 0].');
+
 %!test
-%!  r = sqrt(1/2)*(1+i);
-%!  a = a*r;
-%!  b = b*r;
-%!  assert(filter(b, [1], x   ), r*[1 1 0 0 0 0 0 0 0 0]   );
-%!  assert(filter(b, [1], r*x ), r*r*[1 1 0 0 0 0 0 0 0 0] );
-%!  assert(filter(b, [1], x.' ), r*[1 1 0 0 0 0 0 0 0 0].' );
-%!  assert(filter(b, a,   x   ),   [1 0 0 0 0 0 0 0 0 0]   );
-%!  assert(filter(b, a,   r*x ), r*[1 0 0 0 0 0 0 0 0 0]   );
-%!
+%! r = sqrt (1/2) * (1+i);
+%! a = a*r;
+%! b = b*r;
+%! assert (filter (b, [1], x   ), r*[1 1 0 0 0 0 0 0 0 0]   );
+%! assert (filter (b, [1], r*x ), r*r*[1 1 0 0 0 0 0 0 0 0] );
+%! assert (filter (b, [1], x.' ), r*[1 1 0 0 0 0 0 0 0 0].' );
+%! assert (filter (b, a,   x   ),   [1 0 0 0 0 0 0 0 0 0]   );
+%! assert (filter (b, a,   r*x ), r*[1 0 0 0 0 0 0 0 0 0]   );
+
 %!shared a, b, x, y, so
 %!test
-%!  a = [1,1]; b = [1,1];
-%!  x = zeros (1,10); x(1) = 1;
-%!  [y, so] = filter (b, [1], x, [-1]);
-%!  assert(y, [0 1 0 0 0 0 0 0 0 0]);
-%!  assert(so,0);
-%!
+%! a = [1,1];
+%! b = [1,1];
+%! x = zeros (1,10);  x(1) = 1;
+%! [y, so] = filter (b, [1], x, [-1]);
+%! assert (y, [0 1 0 0 0 0 0 0 0 0]);
+%! assert (so, 0);
+
 %!test
-%!  x  = zeros (10,3); x(1,1)=-1; x(1,2)=1;
-%!  y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
-%!  y = filter (b, [1], x);
-%!  assert(y,y0);
-%!
+%! x  = zeros (10,3);  x(1,1) = -1;  x(1,2) = 1;
+%! y0 = zeros (10,3); y0(1:2,1) = -1;  y0(1:2,2) = 1;
+%! y = filter (b, [1], x);
+%! assert (y, y0);
+
 %!test
-%!  a = [1,1]; b=[1,1];
-%!  x = zeros (4,4,2); x(1,1:4,1) = +1; x(1,1:4,2) = -1;
-%!  y0 = zeros (4,4,2); y0(1:2,1:4,1) = +1; y0(1:2,1:4,2) = -1;
-%!  y = filter (b, [1], x);
-%!  assert(y, y0);
-%!
-%!assert(filter (1, ones(10,1)/10, []), []);
-%!assert(filter (1, ones(10,1)/10, zeros(0,10)), zeros(0,10));
-%!assert(filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5));
+%! a = [1,1];
+%! b=[1,1];
+%! x = zeros (4,4,2);  x(1,1:4,1) = +1;  x(1,1:4,2) = -1;
+%! y0 = zeros (4,4,2);  y0(1:2,1:4,1) = +1;  y0(1:2,1:4,2) = -1;
+%! y = filter (b, [1], x);
+%! assert (y, y0);
+
+%!assert (filter (1, ones(10,1)/10, []), [])
+%!assert (filter (1, ones(10,1)/10, zeros(0,10)), zeros(0,10))
+%!assert (filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5))
+
 %% Test using initial conditions
-%!assert(filter([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2]);
-%!assert(filter([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2]);
-%!assert(filter([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18]);
-%!error (filter([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'));
-%!assert(filter([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21]);
-%% Test of DIM parameter
+%!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2])
+%!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2])
+%!assert (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18])
+%!error (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'))
+%!assert (filter ([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21])
+
+## Test of DIM parameter
 %!test
 %! x = ones (2, 1, 3, 4);
 %! x(1,1,:,:) = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! y0 = [1 1 6 2 15 3 2 1 8 2 18 3 3 1 10 2 21 3 4 1 12 2 24 3];
 %! y0 = reshape (y0, size (x));
-%! y = filter([1 1 1], 1, x, [], 3);
+%! y = filter ([1 1 1], 1, x, [], 3);
 %! assert (y, y0);
-
 */
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -565,38 +565,38 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
     }
   else
     gripe_wrong_type_arg ("find", arg);
 
   return retval;
 }
 
 /*
-%!assert(find (char ([0, 97])), 2);
-%!assert(find ([1, 0, 1, 0, 1]), [1, 3, 5]);
-%!assert(find ([1; 0; 3; 0; 1]), [1; 3; 5]);
-%!assert(find ([0, 0, 2; 0, 3, 0; -1, 0, 0]), [3; 5; 7]);
+%!assert (find (char ([0, 97])), 2)
+%!assert (find ([1, 0, 1, 0, 1]), [1, 3, 5])
+%!assert (find ([1; 0; 3; 0; 1]), [1; 3; 5])
+%!assert (find ([0, 0, 2; 0, 3, 0; -1, 0, 0]), [3; 5; 7])
 
 %!test
 %! [i, j, v] = find ([0, 0, 2; 0, 3, 0; -1, 0, 0]);
 %!
-%! assert(i, [3; 2; 1]);
-%! assert(j, [1; 2; 3]);
-%! assert(v, [-1; 3; 2]);
+%! assert (i, [3; 2; 1]);
+%! assert (j, [1; 2; 3]);
+%! assert (v, [-1; 3; 2]);
 
-%!assert(find (single([1, 0, 1, 0, 1])), [1, 3, 5]);
-%!assert(find (single([1; 0; 3; 0; 1])), [1; 3; 5]);
-%!assert(find (single([0, 0, 2; 0, 3, 0; -1, 0, 0])), [3; 5; 7]);
+%!assert (find (single ([1, 0, 1, 0, 1])), [1, 3, 5])
+%!assert (find (single ([1; 0; 3; 0; 1])), [1; 3; 5])
+%!assert (find (single ([0, 0, 2; 0, 3, 0; -1, 0, 0])), [3; 5; 7])
 
 %!test
-%! [i, j, v] = find (single([0, 0, 2; 0, 3, 0; -1, 0, 0]));
+%! [i, j, v] = find (single ([0, 0, 2; 0, 3, 0; -1, 0, 0]));
 %!
-%! assert(i, [3; 2; 1]);
-%! assert(j, [1; 2; 3]);
-%! assert(v, single([-1; 3; 2]));
+%! assert (i, [3; 2; 1]);
+%! assert (j, [1; 2; 3]);
+%! assert (v, single ([-1; 3; 2]));
 
 %!test
 %! pcol = [5 1 4 3 2];
 %! P = eye (5) (:, pcol);
 %! [i, j, v] = find (P);
 %! [ifull, jfull, vfull] = find (full (P));
 %! assert (i, ifull);
 %! assert (j, jfull);
@@ -612,11 +612,10 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
 %! assert (all (v == 1));
 
 %!assert (find ([2 0 1 0 5 0], 1), 1)
 %!assert (find ([2 0 1 0 5 0], 2, "last"), [3, 5])
 
 %!assert (find ([2 0 1 0 5 0], Inf), [1, 3, 5])
 %!assert (find ([2 0 1 0 5 0], Inf, "last"), [1, 3, 5])
 
-%!error <Invalid call to find> find ();
-
+%!error find ()
 */
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -203,28 +203,28 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! a = [.5 .5 .5 .5 .5];
 %! x = [0 1 2 3 4];
-%! v1 = sqrt(pi)*erf(x)./gamma(a);
-%! v3 = gammainc(x.*x,a);
-%! assert(v1, v3, sqrt(eps));
+%! v1 = sqrt (pi)*erf (x)./gamma (a);
+%! v3 = gammainc (x.*x, a);
+%! assert (v1, v3, sqrt (eps));
 
-%!assert (gammainc(0:4,0.5,"upper"), 1-gammainc(0:4,0.5),1e-10)
+%!assert (gammainc (0:4,0.5, "upper"), 1-gammainc (0:4,0.5), 1e-10)
 
 %!test
 %! a = single ([.5 .5 .5 .5 .5]);
-%! x = single([0 1 2 3 4]);
-%! v1 = sqrt(pi('single'))*erf(x)./gamma(a);
-%! v3 = gammainc(x.*x,a);
-%! assert(v1, v3, sqrt(eps('single')));
+%! x = single ([0 1 2 3 4]);
+%! v1 = sqrt (pi ("single"))*erf (x)./gamma (a);
+%! v3 = gammainc (x.*x, a);
+%! assert (v1, v3, sqrt (eps ("single")));
 
-%!assert (gammainc(single(0:4),single(0.5),"upper"), single(1)-gammainc(single(0:4),single(0.5)),single(1e-7))
-
+%!assert (gammainc (single (0:4), single (0.5), "upper"), 
+%!        single (1)-gammainc (single (0:4), single (0.5)),
+%!        single (1e-7))
 */
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -510,21 +510,19 @@ that,\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
+%!assert (gcd (200, 300, 50, 35), 5)
+%!assert (gcd (int16 (200), int16 (300), int16 (50), int16 (35)), int16 (5))
+%!assert (gcd (uint64 (200), uint64 (300), uint64 (50), uint64 (35)), uint64 (5))
+%!assert (gcd (18-i, -29+3i), -3-4i)
 
-%!assert(gcd (200, 300, 50, 35), 5)
-%!assert(gcd (int16(200), int16(300), int16(50), int16(35)), int16(5))
-%!assert(gcd (uint64(200), uint64(300), uint64(50), uint64(35)), uint64(5))
-%!assert(gcd (18-i, -29+3i), -3-4i)
-
-%!error <Invalid call to gcd> gcd ();
+%!error gcd ()
 
 %!test
 %! s.a = 1;
-%! fail("gcd (s)");
-
+%! fail ("gcd (s)");
 */
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -200,16 +200,15 @@ givens (1, 1)\n\
             }
         }
     }
 
   return retval;
 }
 
 /*
+%!assert (givens (1,1), [1, 1; -1, 1] / sqrt (2), 2*eps)
+%!assert (givens (1,0), eye (2))
+%!assert (givens (0,1), [0, 1; -1 0])
 
-%!assert (givens (1,1), [1, 1; -1, 1]/sqrt(2), 2*eps);
-%!assert (givens (1,0), eye(2));
-%!assert (givens (0,1), [0, 1; -1 0]);
-%!error givens(1);
-%!error givens()
-
+%!error givens ()
+%!error givens (1)
 */
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -168,24 +168,22 @@ Nash, and Van Loan, IEEE Transactions on
           gripe_wrong_type_arg ("hess", arg);
         }
     }
 
   return retval;
 }
 
 /*
-
 %!test
 %! a = [1, 2, 3; 5, 4, 6; 8, 7, 9];
 %! [p, h] = hess (a);
-%! assert(p * h * p', a, sqrt(eps));
+%! assert (p * h * p', a, sqrt (eps));
 
 %!test
-%! a = single([1, 2, 3; 5, 4, 6; 8, 7, 9]);
+%! a = single ([1, 2, 3; 5, 4, 6; 8, 7, 9]);
 %! [p, h] = hess (a);
-%! assert(p * h * p', a, sqrt(eps ('single')));
+%! assert (p * h * p', a, sqrt (eps ("single")));
 
-%!error <Invalid call to hess> hess ();
-%!error <Invalid call to hess> hess ([1, 2; 3, 4], 2);
-%!error hess ([1, 2; 3, 4; 5, 6]);
-
+%!error hess ()
+%!error hess ([1, 2; 3, 4], 2)
+%!error <argument must be a square matrix> hess ([1, 2; 3, 4; 5, 6])
 */
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -114,17 +114,17 @@ hex2num ([\"4005bf0a8b145769\"; \"402400
             retval =  m;
         }
     }
 
   return retval;
 }
 
 /*
-%!assert (hex2num(['c00';'bff';'000';'3ff';'400']),[-2:2]')
+%!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 */
 
 DEFUN_DLD (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
 string of the IEEE 754 representation of the number.  For example:\n\
 \n\
@@ -183,10 +183,10 @@ num2hex ([-1, 1, e, Inf, NaN, NA])\n\
           retval = m;
         }
     }
 
   return retval;
 }
 
 /*
-%!assert (num2hex (-2:2),['c000000000000000';'bff0000000000000';'0000000000000000';'3ff0000000000000';'4000000000000000'])
+%!assert (num2hex (-2:2), ["c000000000000000";"bff0000000000000";"0000000000000000";"3ff0000000000000";"4000000000000000"])
 */
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -219,25 +219,23 @@ of a sparse matrix if possible.\n\
         warning ("inverse: matrix singular to machine precision, rcond = %g",
                  rcond);
     }
 
   return retval;
 }
 
 /*
-
-%!assert(inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
-%!assert(inv (single([1, 2; 3, 4])), single([-2, 1; 1.5, -0.5]), sqrt (eps ('single')))
+%!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
+%!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
 
-%!error <Invalid call to inv> inv ();
-%!error <Invalid call to inv> inv ([1, 2; 3, 4], 2);
-%!error inv ([1, 2; 3, 4; 5, 6]);
-
- */
+%!error inv ()
+%!error inv ([1, 2; 3, 4], 2)
+%!error <argument must be a square matrix> inv ([1, 2; 3, 4; 5, 6])
+*/
 
 // FIXME -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN_DLD (inverse, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{x} =} inverse (@var{A})\n\
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -284,22 +284,20 @@ Since the Kronecker product is associati
   else
     print_usage ();
 
   return retval;
 }
 
 
 /*
-
 %!test
-%! x = ones(2);
-%! assert( kron (x, x), ones (4));
+%! x = ones (2);
+%! assert (kron (x, x), ones (4));
 
 %!shared x, y, z
 %! x =  [1, 2];
 %! y =  [-1, -2];
 %! z =  [1,  2,  3,  4; 1,  2,  3,  4; 1,  2,  3,  4];
 %!assert (kron (1:4, ones (3, 1)), z)
 %!assert (kron (x, y, z), kron (kron (x, y), z))
 %!assert (kron (x, y, z), kron (x, kron (y, z)))
-
 */
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -368,30 +368,30 @@ at most n-1).\n\
   else
     print_usage ();
 
   return retval;
 
 }
 
 /*
-%!assert (lookup(1:3, 0.5), 0)     # value before table
-%!assert (lookup(1:3, 3.5), 3)     # value after table error
-%!assert (lookup(1:3, 1.5), 1)     # value within table error
-%!assert (lookup(1:3, [3,2,1]), [3,2,1])
-%!assert (lookup([1:4]', [1.2, 3.5]'), [1, 3]');
-%!assert (lookup([1:4], [1.2, 3.5]'), [1, 3]');
-%!assert (lookup([1:4]', [1.2, 3.5]), [1, 3]);
-%!assert (lookup([1:4], [1.2, 3.5]), [1, 3]);
-%!assert (lookup(1:3, [3, 2, 1]), [3, 2, 1]);
-%!assert (lookup([3:-1:1], [3.5, 3, 1.2, 2.5, 2.5]), [0, 1, 2, 1, 1])
-%!assert (isempty(lookup([1:3], [])))
-%!assert (isempty(lookup([1:3]', [])))
-%!assert (lookup(1:3, [1, 2; 3, 0.5]), [1, 2; 3, 0]);
-%!assert (lookup(1:4, [1, 1.2; 3, 2.5], "m"), [1, 0; 3, 0]);
-%!assert (lookup(4:-1:1, [1, 1.2; 3, 2.5], "m"), [4, 0; 2, 0]);
-%!assert (lookup(1:4, [1, 1.2; 3, 2.5], "b"), logical ([1, 0; 3, 0]));
-%!assert (lookup(4:-1:1, [1, 1.2; 3, 2.5], "b"), logical ([4, 0; 2, 0]));
+%!assert (lookup (1:3, 0.5), 0)     # value before table
+%!assert (lookup (1:3, 3.5), 3)     # value after table error
+%!assert (lookup (1:3, 1.5), 1)     # value within table error
+%!assert (lookup (1:3, [3,2,1]), [3,2,1])
+%!assert (lookup ([1:4]', [1.2, 3.5]'), [1, 3]')
+%!assert (lookup ([1:4], [1.2, 3.5]'), [1, 3]')
+%!assert (lookup ([1:4]', [1.2, 3.5]), [1, 3])
+%!assert (lookup ([1:4], [1.2, 3.5]), [1, 3])
+%!assert (lookup (1:3, [3, 2, 1]), [3, 2, 1])
+%!assert (lookup ([3:-1:1], [3.5, 3, 1.2, 2.5, 2.5]), [0, 1, 2, 1, 1])
+%!assert (isempty (lookup ([1:3], [])))
+%!assert (isempty (lookup ([1:3]', [])))
+%!assert (lookup (1:3, [1, 2; 3, 0.5]), [1, 2; 3, 0])
+%!assert (lookup (1:4, [1, 1.2; 3, 2.5], "m"), [1, 0; 3, 0])
+%!assert (lookup (4:-1:1, [1, 1.2; 3, 2.5], "m"), [4, 0; 2, 0])
+%!assert (lookup (1:4, [1, 1.2; 3, 2.5], "b"), logical ([1, 0; 3, 0]))
+%!assert (lookup (4:-1:1, [1, 1.2; 3, 2.5], "b"), logical ([4, 0; 2, 0]))
 %!
-%!assert (lookup({"apple","lemon","orange"}, {"banana","kiwi"; "ananas","mango"}), [1,1;0,2])
-%!assert (lookup({"apple","lemon","orange"}, "potato"), 3)
-%!assert (lookup({"orange","lemon","apple"}, "potato"), 0)
+%!assert (lookup ({"apple","lemon","orange"}, {"banana","kiwi"; "ananas","mango"}), [1,1;0,2])
+%!assert (lookup ({"apple","lemon","orange"}, "potato"), 3)
+%!assert (lookup ({"orange","lemon","apple"}, "potato"), 0)
 */
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -470,77 +470,79 @@ parameters for @code{lsode}.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%% dassl-1.m
-%%
-%% Test lsode() function
-%%
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         20 May 1998
-%%
-%% Problem
-%%
-%%    y1' = -y2,   y1(0) = 1
-%%    y2' =  y1,   y2(0) = 0
-%%
-%% Solution
-%%
-%%    y1(t) = cos(t)
-%%    y2(t) = sin(t)
+## dassl-1.m
+##
+## Test lsode() function
+##
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         20 May 1998
+##
+## Problem
+##
+##    y1' = -y2,   y1(0) = 1
+##    y2' =  y1,   y2(0) = 0
+##
+## Solution
+##
+##    y1(t) = cos(t)
+##    y2(t) = sin(t)
+##
 %!function xdot = __f (x, t)
 %!  xdot = [-x(2); x(1)];
+%!endfunction
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 500 * lsode_options ("relative tolerance");
 %!
-%!
 %! x = lsode ("__f", x0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
-%! assert(all (all (abs (x - y) < tol)));
+%! assert (x, y, tol);
 
 %!function xdotdot = __f (x, t)
 %!  xdotdot = [x(2); -x(1)];
+%!endfunction
 %!test
 %!
 %! x0 = [1; 0];
 %! t = [0; 2*pi];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
 %! x = lsode ("__f", x0, t);
 %!
 %! y = [1, 0; 1, 0];
 %!
-%! assert(all (all (abs (x - y) < tol)));
+%! assert (x, y, tol);
 
 %!function xdot = __f (x, t)
 %!  xdot = x;
+%!endfunction
 %!test
 %!
 %! x0 = 1;
 %! t = [0; 1];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
 %! x = lsode ("__f", x0, t);
 %!
 %! y = [1; e];
 %!
-%! assert(all (all (abs (x - y) < tol)));
+%! assert (x, y, tol);
 
 %!test
 %! lsode_options ("absolute tolerance", eps);
-%! assert(lsode_options ("absolute tolerance") == eps);
+%! assert (lsode_options ("absolute tolerance") == eps);
 
-%!error <Invalid call to lsode_options> lsode_options ("foo", 1, 2);
-
+%!error lsode_options ("foo", 1, 2)
 */
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -524,71 +524,69 @@ information.\n\
       else
         gripe_wrong_type_arg ("lu", arg);
     }
 
   return retval;
 }
 
 /*
-
 %!assert(lu ([1, 2; 3, 4]), [3, 4; 1/3, 2/3], eps);
 
 %!test
 %! [l, u] = lu ([1, 2; 3, 4]);
-%! assert(l, [1/3, 1; 1, 0], sqrt (eps));
-%! assert(u, [3, 4; 0, 2/3], sqrt (eps));
+%! assert (l, [1/3, 1; 1, 0], sqrt (eps));
+%! assert (u, [3, 4; 0, 2/3], sqrt (eps));
 
 %!test
 %! [l, u, p] = lu ([1, 2; 3, 4]);
-%! assert(l, [1, 0; 1/3, 1], sqrt (eps));
-%! assert(u, [3, 4; 0, 2/3], sqrt (eps));
-%! assert(p(:,:), [0, 1; 1, 0], sqrt (eps));
+%! assert (l, [1, 0; 1/3, 1], sqrt (eps));
+%! assert (u, [3, 4; 0, 2/3], sqrt (eps));
+%! assert (p(:,:), [0, 1; 1, 0], sqrt (eps));
 
 %!test
-%! [l, u, p] = lu ([1, 2; 3, 4],'vector');
-%! assert(l, [1, 0; 1/3, 1], sqrt (eps));
-%! assert(u, [3, 4; 0, 2/3], sqrt (eps));
-%! assert(p, [2;1], sqrt (eps));
+%! [l, u, p] = lu ([1, 2; 3, 4], "vector");
+%! assert (l, [1, 0; 1/3, 1], sqrt (eps));
+%! assert (u, [3, 4; 0, 2/3], sqrt (eps));
+%! assert (p, [2;1], sqrt (eps));
 
 %!test
-%! [l u p] = lu ([1, 2; 3, 4; 5, 6]);
-%! assert(l, [1, 0; 1/5, 1; 3/5, 1/2], sqrt (eps));
-%! assert(u, [5, 6; 0, 4/5], sqrt (eps));
-%! assert(p(:,:), [0, 0, 1; 1, 0, 0; 0 1 0], sqrt (eps));
+%! [l, u, p] = lu ([1, 2; 3, 4; 5, 6]);
+%! assert (l, [1, 0; 1/5, 1; 3/5, 1/2], sqrt (eps));
+%! assert (u, [5, 6; 0, 4/5], sqrt (eps));
+%! assert (p(:,:), [0, 0, 1; 1, 0, 0; 0 1 0], sqrt (eps));
 
-%!assert(lu (single([1, 2; 3, 4])), single([3, 4; 1/3, 2/3]), eps('single'));
+%!assert (lu (single ([1, 2; 3, 4])), single ([3, 4; 1/3, 2/3]), eps ("single"))
 
 %!test
-%! [l, u] = lu (single([1, 2; 3, 4]));
-%! assert(l, single([1/3, 1; 1, 0]), sqrt (eps('single')));
-%! assert(u, single([3, 4; 0, 2/3]), sqrt (eps('single')));
+%! [l, u] = lu (single ([1, 2; 3, 4]));
+%! assert (l, single ([1/3, 1; 1, 0]), sqrt (eps ("single")));
+%! assert (u, single ([3, 4; 0, 2/3]), sqrt (eps ("single")));
 
 %!test
-%! [l, u, p] = lu (single([1, 2; 3, 4]));
-%! assert(l, single([1, 0; 1/3, 1]), sqrt (eps('single')));
-%! assert(u, single([3, 4; 0, 2/3]), sqrt (eps('single')));
-%! assert(p(:,:), single([0, 1; 1, 0]), sqrt (eps('single')));
+%! [l, u, p] = lu (single ([1, 2; 3, 4]));
+%! assert (l, single ([1, 0; 1/3, 1]), sqrt (eps ("single")));
+%! assert (u, single ([3, 4; 0, 2/3]), sqrt (eps ("single")));
+%! assert (p(:,:), single ([0, 1; 1, 0]), sqrt (eps ("single")));
 
 %!test
-%! [l, u, p] = lu (single([1, 2; 3, 4]),'vector');
-%! assert(l, single([1, 0; 1/3, 1]), sqrt (eps('single')));
-%! assert(u, single([3, 4; 0, 2/3]), sqrt (eps('single')));
-%! assert(p, single([2;1]), sqrt (eps('single')));
+%! [l, u, p] = lu (single ([1, 2; 3, 4]), "vector");
+%! assert (l, single ([1, 0; 1/3, 1]), sqrt (eps ("single")));
+%! assert (u, single ([3, 4; 0, 2/3]), sqrt (eps ("single")));
+%! assert (p, single ([2;1]), sqrt (eps ("single")));
 
 %!test
-%! [l u p] = lu (single([1, 2; 3, 4; 5, 6]));
-%! assert(l, single([1, 0; 1/5, 1; 3/5, 1/2]), sqrt (eps('single')));
-%! assert(u, single([5, 6; 0, 4/5]), sqrt (eps('single')));
-%! assert(p(:,:), single([0, 0, 1; 1, 0, 0; 0 1 0]), sqrt (eps('single')));
+%! [l u p] = lu (single ([1, 2; 3, 4; 5, 6]));
+%! assert (l, single ([1, 0; 1/5, 1; 3/5, 1/2]), sqrt (eps ("single")));
+%! assert (u, single ([5, 6; 0, 4/5]), sqrt (eps ("single")));
+%! assert (p(:,:), single ([0, 0, 1; 1, 0, 0; 0 1 0]), sqrt (eps ("single")));
 
-%!error <Invalid call to lu> lu ();
-%!error lu ([1, 2; 3, 4], 2);
-
- */
+%!error lu ()
+%!error <can not define pivoting threshold> lu ([1, 2; 3, 4], 2)
+*/
 
 static
 bool check_lu_dims (const octave_value& l, const octave_value& u,
                     const octave_value& p)
 {
   octave_idx_type m = l.rows (), k = u.rows (), n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
             && k == std::min (m, n) &&
@@ -780,80 +778,80 @@ recompute the factorization from scratch
 %!      0.53010;
 %!      0.80683 ];
 %!
 %! v = [0.98810;
 %!      0.24295;
 %!      0.43167 ];
 %!
 %! Ac = [0.620405 + 0.956953i  0.480013 + 0.048806i  0.402627 + 0.338171i;
-%!      0.589077 + 0.658457i  0.013205 + 0.279323i  0.229284 + 0.721929i;
-%!      0.092758 + 0.345687i  0.928679 + 0.241052i  0.764536 + 0.832406i;
-%!      0.912098 + 0.721024i  0.049018 + 0.269452i  0.730029 + 0.796517i;
-%!      0.112849 + 0.603871i  0.486352 + 0.142337i  0.355646 + 0.151496i ];
+%!       0.589077 + 0.658457i  0.013205 + 0.279323i  0.229284 + 0.721929i;
+%!       0.092758 + 0.345687i  0.928679 + 0.241052i  0.764536 + 0.832406i;
+%!       0.912098 + 0.721024i  0.049018 + 0.269452i  0.730029 + 0.796517i;
+%!       0.112849 + 0.603871i  0.486352 + 0.142337i  0.355646 + 0.151496i ];
 %!
 %! uc = [0.20351 + 0.05401i;
-%!      0.13141 + 0.43708i;
-%!      0.29808 + 0.08789i;
-%!      0.69821 + 0.38844i;
-%!      0.74871 + 0.25821i ];
+%!       0.13141 + 0.43708i;
+%!       0.29808 + 0.08789i;
+%!       0.69821 + 0.38844i;
+%!       0.74871 + 0.25821i ];
 %!
 %! vc = [0.85839 + 0.29468i;
-%!      0.20820 + 0.93090i;
-%!      0.86184 + 0.34689i ];
+%!       0.20820 + 0.93090i;
+%!       0.86184 + 0.34689i ];
 %!
 
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(A);
-%! [L,U] = luupdate(L,U,P*u,v);
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - A - u*v.'),Inf) < norm(A)*1e1*eps)
+%! [L,U,P] = lu (A);
+%! [L,U] = luupdate (L,U,P*u,v);
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - A - u*v.'), Inf) < norm (A)*1e1*eps);
 %!
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(Ac);
-%! [L,U] = luupdate(L,U,P*uc,vc);
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - Ac - uc*vc.'),Inf) < norm(Ac)*1e1*eps)
+%! [L,U,P] = lu (Ac);
+%! [L,U] = luupdate (L,U,P*uc,vc);
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - Ac - uc*vc.'), Inf) < norm (Ac)*1e1*eps);
 
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(single(A));
-%! [L,U] = luupdate(L,U,P*single(u),single(v));
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - single(A) - single(u)*single(v).'),Inf) < norm(single(A))*1e1*eps('single'))
+%! [L,U,P] = lu (single (A));
+%! [L,U] = luupdate (L,U,P*single (u), single (v));
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - single (A) - single (u)*single (v).'), Inf) < norm (single (A))*1e1*eps ("single"));
 %!
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(single(Ac));
-%! [L,U] = luupdate(L,U,P*single(uc),single(vc));
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - single(Ac) - single(uc)*single(vc).'),Inf) < norm(single(Ac))*1e1*eps('single'))
+%! [L,U,P] = lu (single (Ac));
+%! [L,U] = luupdate (L,U,P*single (uc),single (vc));
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - single (Ac) - single (uc)*single (vc).'), Inf) < norm (single (Ac))*1e1*eps ("single"));
 
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(A);
-%! [L,U,P] = luupdate(L,U,P,u,v);
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - A - u*v.'),Inf) < norm(A)*1e1*eps)
+%! [L,U,P] = lu (A);
+%! [L,U,P] = luupdate (L,U,P,u,v);
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - A - u*v.'), Inf) < norm (A)*1e1*eps);
 %!
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(Ac);
-%! [L,U,P] = luupdate(L,U,P,uc,vc);
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - Ac - uc*vc.'),Inf) < norm(Ac)*1e1*eps)
+%! [L,U,P] = lu (Ac);
+%! [L,U,P] = luupdate (L,U,P,uc,vc);
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - Ac - uc*vc.'), Inf) < norm (Ac)*1e1*eps);
 
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(single(A));
-%! [L,U,P] = luupdate(L,U,P,single(u),single(v));
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - single(A) - single(u)*single(v).'),Inf) < norm(single(A))*1e1*eps('single'))
+%! [L,U,P] = lu (single (A));
+%! [L,U,P] = luupdate (L,U,P,single (u),single (v));
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - single (A) - single (u)*single (v).'), Inf) < norm (single (A))*1e1*eps ("single"));
 %!
 %!testif HAVE_QRUPDATE_LUU
-%! [L,U,P] = lu(single(Ac));
-%! [L,U,P] = luupdate(L,U,P,single(uc),single(vc));
-%! assert(norm(vec(tril(L)-L),Inf) == 0)
-%! assert(norm(vec(triu(U)-U),Inf) == 0)
-%! assert(norm(vec(P'*L*U - single(Ac) - single(uc)*single(vc).'),Inf) < norm(single(Ac))*1e1*eps('single'))
+%! [L,U,P] = lu (single (Ac));
+%! [L,U,P] = luupdate (L,U,P,single (uc),single (vc));
+%! assert (norm (vec (tril (L)-L), Inf) == 0);
+%! assert (norm (vec (triu (U)-U), Inf) == 0);
+%! assert (norm (vec (P'*L*U - single (Ac) - single (uc)*single (vc).'), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -360,26 +360,24 @@ Given the string argument \"vector\", @c
             error ("luinc: matrix A must be sparse");
         }
     }
 
   return retval;
 }
 
 /*
+%!testif HAVE_UMFPACK
+%! a = sparse ([1,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
+%! [l,u] = luinc (a, 1e-10);
+%! assert (l*u, sparse ([1,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]), 1e-10);
+%! opts.droptol = 1e-10;
+%! [l,u] = luinc (a, opts);
+%! assert (l*u, sparse ([1,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]), 1e-10);
 
 %!testif HAVE_UMFPACK
-%! a=sparse([1,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
-%! [l,u]=luinc(a,1e-10);
-%! assert(l*u, sparse([1,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]),1e-10);
-%! opts.droptol=1e-10;
-%! [l,u]=luinc(a,opts);
-%! assert(l*u, sparse([1,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]),1e-10);
-
-%!testif HAVE_UMFPACK
-%! a=sparse([1i,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
-%! [l,u]=luinc(a,1e-10);
-%! assert(l*u, sparse([1i,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]),1e-10);
-%! opts.droptol=1e-10;
-%! [l,u]=luinc(a,opts);
-%! assert(l*u, sparse([1i,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]),1e-10);
-
+%! a = sparse ([1i,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
+%! [l,u] = luinc (a, 1e-10);
+%! assert (l*u, sparse ([1i,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]), 1e-10);
+%! opts.droptol = 1e-10;
+%! [l,u] = luinc (a, opts);
+%! assert (l*u, sparse ([1i,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]), 1e-10);
 */
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -503,115 +503,119 @@ LU@tie{}factorization.  Once the matrix 
             }
         }
     }
 
   return retval;
 }
 
 /*
-
-## FIXME
+## FIXME:
 ## Disable tests for lower under-determined and upper over-determined
 ## matrices as this detection is disabled in MatrixType due to issues
 ## of non minimum norm solution being found.
 
-%!assert(matrix_type(speye(10,10)),"Diagonal");
-%!assert(matrix_type(speye(10,10)([2:10,1],:)),"Permuted Diagonal");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]]),"Upper");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
-%!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]),"Lower");
-%!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]([2,1,3:11],:)),"Permuted Lower");
-%!test
-%! bnd=spparms("bandden");
-%! spparms("bandden",0.5);
-%! a = spdiags(rand(10,3)-0.5,[-1,0,1],10,10);
-%! assert(matrix_type(a),"Tridiagonal");
-%! assert(matrix_type(a'+a+2*speye(10)),"Tridiagonal Positive Definite");
-%! spparms("bandden",bnd);
-%!test
-%! bnd=spparms("bandden");
-%! spparms("bandden",0.5);
-%! a = spdiags(randn(10,4),[-2:1],10,10);
-%! assert(matrix_type(a),"Banded");
-%! assert(matrix_type(a'*a),"Banded Positive Definite");
-%! spparms("bandden",bnd);
-%!test
-%! a=[speye(10,10),[sparse(9,1);1];-1,sparse(1,9),1];
-%! assert(matrix_type(a),"Full");
-%! assert(matrix_type(a'*a),"Positive Definite");
-%!assert(matrix_type(speye(10,11)),"Diagonal");
-%!assert(matrix_type(speye(10,11)([2:10,1],:)),"Permuted Diagonal");
-%!assert(matrix_type(speye(11,10)),"Diagonal");
-%!assert(matrix_type(speye(11,10)([2:11,1],:)),"Permuted Diagonal");
-%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]]),"Upper");
-%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]](:,[2,1,3:12])),"Permuted Upper");
-%!assert(matrix_type([speye(11,9),[1;sparse(8,1);1;0]]),"Upper");
-%!assert(matrix_type([speye(11,9),[1;sparse(8,1);1;0]](:,[2,1,3:10])),"Permuted Upper");
-%#!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]),"Lower");
-%#!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]([2,1,3:12],:)),"Permuted Lower");
-%!assert(matrix_type([speye(9,11);[1,sparse(1,8),1,0]]),"Lower");
-%!assert(matrix_type([speye(9,11);[1,sparse(1,8),1,0]]([2,1,3:10],:)),"Permuted Lower");
-%!assert(matrix_type(spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
+%!assert (matrix_type (speye (10,10)), "Diagonal")
+%!assert (matrix_type (speye (10,10)([2:10,1],:)), "Permuted Diagonal")
+%!assert (matrix_type ([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]]), "Upper")
+%!assert (matrix_type ([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]](:,[2,1,3:11])), "Permuted Upper")
+%!assert (matrix_type ([speye(10,10),sparse(10,1);1,sparse(1,9),1]), "Lower")
+%!assert (matrix_type ([speye(10,10),sparse(10,1);1,sparse(1,9),1]([2,1,3:11],:)), "Permuted Lower")
 
-%!assert(matrix_type(1i*speye(10,10)),"Diagonal");
-%!assert(matrix_type(1i*speye(10,10)([2:10,1],:)),"Permuted Diagonal");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]]),"Upper");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
-%!assert(matrix_type([speye(10,10),sparse(10,1);1i,sparse(1,9),1]),"Lower");
-%!assert(matrix_type([speye(10,10),sparse(10,1);1i,sparse(1,9),1]([2,1,3:11],:)),"Permuted Lower");
 %!test
-%! bnd=spparms("bandden");
-%! spparms("bandden",0.5);
-%! assert(matrix_type(spdiags(1i*randn(10,3),[-1,0,1],10,10)),"Tridiagonal");
-%! a = 1i*(rand(9,1)-0.5);a=[[a;0],ones(10,1),[0;-a]];
-%! assert(matrix_type(spdiags(a,[-1,0,1],10,10)),"Tridiagonal Positive Definite");
-%! spparms("bandden",bnd);
+%! bnd = spparms ("bandden");
+%! spparms ("bandden", 0.5);
+%! a = spdiags (rand (10,3)-0.5,[-1,0,1],10,10);
+%! assert (matrix_type (a), "Tridiagonal");
+%! assert (matrix_type (a'+a+2*speye (10)), "Tridiagonal Positive Definite");
+%! spparms ("bandden", bnd);
+%!test
+%! bnd=spparms ("bandden");
+%! spparms ("bandden", 0.5);
+%! a = spdiags (randn (10,4),[-2:1],10,10);
+%! assert (matrix_type (a), "Banded");
+%! assert (matrix_type (a'*a), "Banded Positive Definite");
+%! spparms ("bandden", bnd);
 %!test
-%! bnd=spparms("bandden");
-%! spparms("bandden",0.5);
-%! assert(matrix_type(spdiags(1i*randn(10,4),[-2:1],10,10)),"Banded");
-%! a = 1i*(rand(9,2)-0.5);a=[[a;[0,0]],ones(10,1),[[0;-a(:,2)],[0;0;-a(1:8,1)]]];
-%! assert(matrix_type(spdiags(a,[-2:2],10,10)),"Banded Positive Definite");
-%! spparms("bandden",bnd);
-%!test
-%! a=[speye(10,10),[sparse(9,1);1i];-1,sparse(1,9),1];
-%! assert(matrix_type(a),"Full");
-%! assert(matrix_type(a'*a),"Positive Definite");
-%!assert(matrix_type(1i*speye(10,11)),"Diagonal");
-%!assert(matrix_type(1i*speye(10,11)([2:10,1],:)),"Permuted Diagonal");
-%!assert(matrix_type(1i*speye(11,10)),"Diagonal");
-%!assert(matrix_type(1i*speye(11,10)([2:11,1],:)),"Permuted Diagonal");
-%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]]),"Upper");
-%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]](:,[2,1,3:12])),"Permuted Upper");
-%!assert(matrix_type([speye(11,9),[1i;sparse(8,1);1i;0]]),"Upper");
-%!assert(matrix_type([speye(11,9),[1i;sparse(8,1);1i;0]](:,[2,1,3:10])),"Permuted Upper");
-%#!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]),"Lower");
-%#!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]([2,1,3:12],:)),"Permuted Lower");
-%!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]),"Lower");
-%!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]([2,1,3:10],:)),"Permuted Lower");
-%!assert(matrix_type(1i*spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
+%! a = [speye(10,10),[sparse(9,1);1];-1,sparse(1,9),1];
+%! assert (matrix_type (a), "Full");
+%! assert (matrix_type (a'*a), "Positive Definite");
+
+%!assert (matrix_type (speye (10,11)), "Diagonal")
+%!assert (matrix_type (speye (10,11)([2:10,1],:)), "Permuted Diagonal")
+%!assert (matrix_type (speye (11,10)), "Diagonal")
+%!assert (matrix_type (speye (11,10)([2:11,1],:)), "Permuted Diagonal")
+%#!assert (matrix_type ([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]]), "Upper")
+%#!assert (matrix_type ([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]](:,[2,1,3:12])), "Permuted Upper")
+%!assert (matrix_type ([speye(11,9),[1;sparse(8,1);1;0]]), "Upper")
+%!assert (matrix_type ([speye(11,9),[1;sparse(8,1);1;0]](:,[2,1,3:10])), "Permuted Upper")
+%#!assert (matrix_type ([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]), "Lower")
+%#!assert (matrix_type ([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]([2,1,3:12],:)), "Permuted Lower")
+%!assert (matrix_type ([speye(9,11);[1,sparse(1,8),1,0]]), "Lower")
+%!assert (matrix_type ([speye(9,11);[1,sparse(1,8),1,0]]([2,1,3:10],:)), "Permuted Lower")
+%!assert (matrix_type (spdiags (randn (10,4),[-2:1],10,9)), "Rectangular")
+
+%!assert (matrix_type (1i*speye (10,10)), "Diagonal")
+%!assert (matrix_type (1i*speye (10,10)([2:10,1],:)), "Permuted Diagonal")
+%!assert (matrix_type ([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]]), "Upper")
+%!assert (matrix_type ([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]](:,[2,1,3:11])), "Permuted Upper")
+%!assert (matrix_type ([speye(10,10),sparse(10,1);1i,sparse(1,9),1]), "Lower")
+%!assert (matrix_type ([speye(10,10),sparse(10,1);1i,sparse(1,9),1]([2,1,3:11],:)), "Permuted Lower")
 
 %!test
-%! a = matrix_type(spdiags(randn(10,3),[-1,0,1],10,10),"Singular");
-%! assert(matrix_type(a),"Singular");
-
-%!assert(matrix_type(triu(ones(10,10))),"Upper");
-%!assert(matrix_type(triu(ones(10,10),-1)),"Full");
-%!assert(matrix_type(tril(ones(10,10))),"Lower");
-%!assert(matrix_type(tril(ones(10,10),1)),"Full");
-%!assert(matrix_type(10*eye(10,10) + ones(10,10)), "Positive Definite");
-%!assert(matrix_type(ones(11,10)),"Rectangular")
+%! bnd = spparms ("bandden");
+%! spparms ("bandden", 0.5);
+%! assert (matrix_type (spdiags (1i*randn (10,3),[-1,0,1],10,10)), "Tridiagonal");
+%! a = 1i*(rand (9,1)-0.5);
+%! a = [[a;0],ones(10,1),[0;-a]];
+%! assert (matrix_type (spdiags (a,[-1,0,1],10,10)), "Tridiagonal Positive Definite");
+%! spparms ("bandden", bnd);
+%!test
+%! bnd = spparms ("bandden");
+%! spparms ("bandden", 0.5);
+%! assert (matrix_type (spdiags (1i*randn (10,4),[-2:1],10,10)), "Banded");
+%! a = 1i*(rand (9,2)-0.5);
+%! a = [[a;[0,0]],ones(10,1),[[0;-a(:,2)],[0;0;-a(1:8,1)]]];
+%! assert (matrix_type (spdiags (a,[-2:2],10,10)), "Banded Positive Definite");
+%! spparms ("bandden", bnd);
 %!test
-%! a = matrix_type(ones(10,10),"Singular");
-%! assert(matrix_type(a),"Singular");
+%! a = [speye(10,10),[sparse(9,1);1i];-1,sparse(1,9),1];
+%! assert (matrix_type (a), "Full");
+%! assert (matrix_type (a'*a), "Positive Definite");
+
+%!assert (matrix_type (1i*speye (10,11)), "Diagonal")
+%!assert (matrix_type (1i*speye (10,11)([2:10,1],:)), "Permuted Diagonal")
+%!assert (matrix_type (1i*speye (11,10)), "Diagonal")
+%!assert (matrix_type (1i*speye (11,10)([2:11,1],:)), "Permuted Diagonal")
+%#!assert (matrix_type ([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]]), "Upper")
+%#!assert (matrix_type ([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]](:,[2,1,3:12])), "Permuted Upper")
+%!assert (matrix_type ([speye(11,9),[1i;sparse(8,1);1i;0]]), "Upper")
+%!assert (matrix_type ([speye(11,9),[1i;sparse(8,1);1i;0]](:,[2,1,3:10])), "Permuted Upper")
+%#!assert (matrix_type ([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]), "Lower")
+%#!assert (matrix_type ([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]([2,1,3:12],:)), "Permuted Lower")
+%!assert (matrix_type ([speye(9,11);[1i,sparse(1,8),1i,0]]), "Lower")
+%!assert (matrix_type ([speye(9,11);[1i,sparse(1,8),1i,0]]([2,1,3:10],:)), "Permuted Lower")
+%!assert (matrix_type (1i*spdiags(randn(10,4),[-2:1],10,9)), "Rectangular")
 
-%!assert(matrix_type(triu(1i*ones(10,10))),"Upper");
-%!assert(matrix_type(triu(1i*ones(10,10),-1)),"Full");
-%!assert(matrix_type(tril(1i*ones(10,10))),"Lower");
-%!assert(matrix_type(tril(1i*ones(10,10),1)),"Full");
-%!assert(matrix_type(10*eye(10,10) + 1i*triu(ones(10,10),1) -1i*tril(ones(10,10),-1)), "Positive Definite");
-%!assert(matrix_type(ones(11,10)),"Rectangular")
+%!test
+%! a = matrix_type (spdiags (randn (10,3),[-1,0,1],10,10), "Singular");
+%! assert (matrix_type (a), "Singular");
+
+%!assert (matrix_type (triu (ones(10,10))), "Upper")
+%!assert (matrix_type (triu (ones(10,10),-1)), "Full")
+%!assert (matrix_type (tril (ones(10,10))), "Lower")
+%!assert (matrix_type (tril (ones(10,10),1)), "Full")
+%!assert (matrix_type (10*eye (10,10) + ones (10,10)), "Positive Definite")
+%!assert (matrix_type (ones (11,10)), "Rectangular")
 %!test
-%! a = matrix_type(ones(10,10),"Singular");
-%! assert(matrix_type(a),"Singular");
+%! a = matrix_type (ones (10,10), "Singular");
+%! assert (matrix_type (a), "Singular");
 
+%!assert (matrix_type (triu (1i*ones (10,10))), "Upper")
+%!assert (matrix_type (triu (1i*ones (10,10),-1)), "Full")
+%!assert (matrix_type (tril (1i*ones (10,10))), "Lower")
+%!assert (matrix_type (tril (1i*ones (10,10),1)), "Full")
+%!assert (matrix_type (10*eye (10,10) + 1i*triu (ones (10,10),1) -1i*tril (ones (10,10),-1)), "Positive Definite")
+%!assert (matrix_type (ones (11,10)), "Rectangular")
+%!test
+%! a = matrix_type (ones (10,10), "Singular");
+%! assert (matrix_type (a), "Singular");
 */
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -353,40 +353,32 @@ minimum value(s).  Thus,\n\
 @end example\n\
 @seealso{max, cummin, cummax}\n\
 @end deftypefn")
 {
   return do_minmax_body (args, nargout, true);
 }
 
 /*
-
-%% test/octave.test/arith/min-1.m
-%!assert (min ([1, 4, 2, 3]) == 1);
-%!assert (min ([1; -10; 5; -2]) == -10);
-
-%% test/octave.test/arith/min-2.m
-%!assert(all (min ([4, i; -2, 2]) == [-2, i]));
-
-%% test/octave.test/arith/min-3.m
-%!error <Invalid call to min> min ();
-
-%% test/octave.test/arith/min-4.m
-%!error <Invalid call to min> min (1, 2, 3, 4);
+%!assert (min ([1, 4, 2, 3]), 1)
+%!assert (min ([1; -10; 5; -2]), -10)
+%!assert (min ([4, i; -2, 2]), [-2, i])
 
 %!test
-%! x = reshape (1:8,[2,2,2]);
-%! assert (max (x,[],1), reshape ([2, 4, 6, 8], [1,2,2]));
-%! assert (max (x,[],2), reshape ([3, 4, 7, 8], [2,1,2]));
-%! [y, i ] = max (x, [], 3);
+%! x = reshape (1:8, [2,2,2]);
+%! assert (max (x, [], 1), reshape ([2, 4, 6, 8], [1,2,2]));
+%! assert (max (x, [], 2), reshape ([3, 4, 7, 8], [2,1,2]));
+%! [y, i] = max (x, [], 3);
+%! assert (ndims (y), 2);
 %! assert (y, [5, 7; 6, 8]);
-%! assert (ndims(y), 2);
+%! assert (ndims (i), 2);
 %! assert (i, [2, 2; 2, 2]);
-%! assert (ndims(i), 2);
 
+%!error min ()
+%!error min (1, 2, 3, 4)
 */
 
 DEFUN_DLD (max, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} max (@var{x})\n\
 @deftypefnx {Loadable Function} {} max (@var{x}, @var{y})\n\
 @deftypefnx {Loadable Function} {} max (@var{x}, [], @var{dim})\n\
 @deftypefnx {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
@@ -432,41 +424,32 @@ maximum value(s).  Thus,\n\
 @end example\n\
 @seealso{min, cummax, cummin}\n\
 @end deftypefn")
 {
   return do_minmax_body (args, nargout, false);
 }
 
 /*
-
-%% test/octave.test/arith/max-1.m
-%!assert (max ([1, 4, 2, 3]) == 4);
-%!assert (max ([1; -10; 5; -2]) == 5);
-
-%% test/octave.test/arith/max-2.m
-%!assert(all (max ([4, i 4.999; -2, 2, 3+4i]) == [4, 2, 3+4i]));
-
-%% test/octave.test/arith/max-3.m
-%!error <Invalid call to max> max ();
-
-%% test/octave.test/arith/max-4.m
-%!error <Invalid call to max> max (1, 2, 3, 4);
+%!assert (max ([1, 4, 2, 3]), 4)
+%!assert (max ([1; -10; 5; -2]), 5)
+%!assert (max ([4, i 4.999; -2, 2, 3+4i]), [4, 2, 3+4i])
 
 %!test
-%! x = reshape (1:8,[2,2,2]);
-%! assert (min (x,[],1), reshape ([1, 3, 5, 7], [1,2,2]));
-%! assert (min (x,[],2), reshape ([1, 2, 5, 6], [2,1,2]));
-%! [y, i ] = min (x, [], 3);
+%! x = reshape (1:8, [2,2,2]);
+%! assert (min (x, [], 1), reshape ([1, 3, 5, 7], [1,2,2]));
+%! assert (min (x, [], 2), reshape ([1, 2, 5, 6], [2,1,2]));
+%! [y, i] = min (x, [], 3);
+%! assert (ndims(y), 2);
 %! assert (y, [1, 3; 2, 4]);
-%! assert (ndims(y), 2);
+%! assert (ndims(i), 2);
 %! assert (i, [1, 1; 1, 1]);
-%! assert (ndims(i), 2);
 
-
+%!error max ()
+%!error max (1, 2, 3, 4)
 */
 
 template <class ArrayType>
 static octave_value_list
 do_cumminmax_red_op (const octave_value& arg,
                      int nargout, int dim, bool ismin)
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/DLD-FUNCTIONS/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/DLD-FUNCTIONS/mgorth.cc
@@ -134,21 +134,21 @@ On exit, @var{y} is a unit vector such t
           retval(0) = x;
         }
     }
 
   return retval;
 }
 
 /*
-
 %!test
-%! for ii=1:100; assert (abs (mgorth (randn (5, 1), eye (5, 4))), [0 0 0 0 1]', eps); endfor
+%! for ii=1:100
+%!   assert (abs (mgorth (randn (5, 1), eye (5, 4))), [0 0 0 0 1]', eps);
+%! endfor
 
 %!test
 %! a = hilb (5);
 %! a(:, 1) /= norm (a(:, 1));
 %! for ii = 1:5
 %!   a(:, ii) = mgorth (a(:, ii), a(:, 1:ii-1));
 %! endfor
 %! assert (a' * a, eye (5), 1e10);
-
 */
diff --git a/src/DLD-FUNCTIONS/nproc.cc b/src/DLD-FUNCTIONS/nproc.cc
--- a/src/DLD-FUNCTIONS/nproc.cc
+++ b/src/DLD-FUNCTIONS/nproc.cc
@@ -80,13 +80,11 @@ variable.\n\
     }
 
   retval = num_processors (query);
 
   return retval;
 }
 
 /*
-
-%% Must always report at least 1 cpu available
+## Must always report at least 1 cpu available
 %!assert (nproc () >= 1);
-
 */
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -451,312 +451,296 @@ x = @var{R} \\ @var{C}\n\
             gripe_wrong_type_arg ("qr", arg);
         }
     }
 
   return retval;
 }
 
 /*
-
 %!test
 %! a = [0, 2, 1; 2, 1, 2];
 %!
 %! [q, r] = qr (a);
-%!
 %! [qe, re] = qr (a, 0);
 %!
 %! assert (q * r, a, sqrt (eps));
 %! assert (qe * re, a, sqrt (eps));
 
 %!test
 %! a = [0, 2, 1; 2, 1, 2];
 %!
-%! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
-%!
+%! [q, r, p] = qr (a);  # FIXME: not giving right dimensions. 
 %! [qe, re, pe] = qr (a, 0);
 %!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!test
 %! a = [0, 2; 2, 1; 1, 2];
 %!
 %! [q, r] = qr (a);
-%!
 %! [qe, re] = qr (a, 0);
 %!
 %! assert (q * r, a, sqrt (eps));
 %! assert (qe * re, a, sqrt (eps));
 
 %!test
 %! a = [0, 2; 2, 1; 1, 2];
 %!
 %! [q, r, p] = qr (a);
-%!
 %! [qe, re, pe] = qr (a, 0);
 %!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
-%!error <Invalid call to qr> qr ();
-%!error <Invalid call to qr> qr ([1, 2; 3, 4], 0, 2);
+%!error qr ()
+%!error qr ([1, 2; 3, 4], 0, 2)
 
 %!function retval = __testqr (q, r, a, p)
-%!  tol = 100*eps (class(q));
+%!  tol = 100*eps (class (q));
 %!  retval = 0;
 %!  if (nargin == 3)
-%!    n1 = norm (q*r-a);
-%!    n2 = norm (q'*q-eye(columns(q)));
+%!    n1 = norm (q*r - a);
+%!    n2 = norm (q'*q - eye (columns (q)));
 %!    retval = (n1 < tol && n2 < tol);
 %!  else
-%!    n1 = norm (q'*q-eye(columns(q)));
+%!    n1 = norm (q'*q - eye (columns (q)));
 %!    retval = (n1 < tol);
 %!    if (isvector (p))
-%!      n2 = norm (q*r-a(:,p));
+%!      n2 = norm (q*r - a(:,p));
 %!      retval = (retval && n2 < tol);
 %!    else
 %!      n2 = norm (q*r - a*p);
 %!      retval = (retval && n2 < tol);
 %!    endif
 %!  endif
 %!endfunction
 
 %!test
-%!
 %! t = ones (24, 1);
 %! j = 1;
 %!
-%! if false # eliminate big matrix tests
-%!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%! if (false)  # eliminate big matrix tests
+%!   a = rand (5000, 20);
+%!   [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%!   [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%!   [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%!   [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %!
 %!   a = a+1i*eps;
-%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%!   [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%!   [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%!   [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%!   [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
-%!
-%! a = a+1i*eps;
-%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
-%!
-%! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%! [q,r]   = qr (a);   t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a');  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a);   t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a');  t(j++) = __testqr (q, r, a', p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%! [q,r]   = qr (a);   t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a');  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a);   t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a');  t(j++) = __testqr (q, r, a', p);
+%!
+%! a = [ ones(1,15); sqrt(eps)*eye(15) ];
+%! [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %!
-%! a = [
-%! 611   196  -192   407    -8   -52   -49    29
-%! 196   899   113  -192   -71   -43    -8   -44
-%! -192   113   899   196    61    49     8    52
-%! 407  -192   196   611     8    44    59   -23
-%! -8   -71    61     8   411  -599   208   208
-%! -52   -43    49    44  -599   411   208   208
-%! -49    -8     8    59   208   208    99  -911
-%! 29   -44    52   -23   208   208  -911    99
-%! ];
-%! [q,r] = qr(a);
+%! a = a+1i*eps;
+%! [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %!
-%! assert(all (t) && norm(q*r-a) < 5000*eps);
+%! a = [ 611   196  -192   407    -8   -52   -49    29
+%!       196   899   113  -192   -71   -43    -8   -44
+%!      -192   113   899   196    61    49     8    52
+%!       407  -192   196   611     8    44    59   -23
+%!        -8   -71    61     8   411  -599   208   208
+%!       -52   -43    49    44  -599   411   208   208
+%!       -49    -8     8    59   208   208    99  -911
+%!        29   -44    52   -23   208   208  -911    99 ];
+%! [q,r] = qr (a);
+%!
+%! assert (all (t) && norm (q*r - a) < 5000*eps);
 
 %!test
 %! a = single ([0, 2, 1; 2, 1, 2]);
 %!
 %! [q, r] = qr (a);
-%!
 %! [qe, re] = qr (a, 0);
 %!
-%! assert (q * r, a, sqrt (eps ('single')));
-%! assert (qe * re, a, sqrt (eps ('single')));
+%! assert (q * r, a, sqrt (eps ("single")));
+%! assert (qe * re, a, sqrt (eps ("single")));
 
 %!test
-%! a = single([0, 2, 1; 2, 1, 2]);
+%! a = single ([0, 2, 1; 2, 1, 2]);
 %!
-%! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
-%!
+%! [q, r, p] = qr (a);  # FIXME: not giving right dimensions.
 %! [qe, re, pe] = qr (a, 0);
 %!
-%! assert (q * r, a * p, sqrt (eps('single')));
-%! assert (qe * re, a(:, pe), sqrt (eps('single')));
+%! assert (q * r, a * p, sqrt (eps ("single")));
+%! assert (qe * re, a(:, pe), sqrt (eps ("single")));
 
 %!test
-%! a = single([0, 2; 2, 1; 1, 2]);
+%! a = single ([0, 2; 2, 1; 1, 2]);
 %!
 %! [q, r] = qr (a);
-%!
 %! [qe, re] = qr (a, 0);
 %!
-%! assert (q * r, a, sqrt (eps('single')));
-%! assert (qe * re, a, sqrt (eps('single')));
+%! assert (q * r, a, sqrt (eps ("single")));
+%! assert (qe * re, a, sqrt (eps ("single")));
 
 %!test
-%! a = single([0, 2; 2, 1; 1, 2]);
+%! a = single ([0, 2; 2, 1; 1, 2]);
 %!
 %! [q, r, p] = qr (a);
-%!
 %! [qe, re, pe] = qr (a, 0);
 %!
-%! assert (q * r, a * p, sqrt (eps('single')));
-%! assert (qe * re, a(:, pe), sqrt (eps('single')));
+%! assert (q * r, a * p, sqrt (eps ("single")));
+%! assert (qe * re, a(:, pe), sqrt (eps ("single")));
 
-%!error <Invalid call to qr> qr ();
-%!error <Invalid call to qr> qr ([1, 2; 3, 4], 0, 2);
+%!error qr ()
+%!error qr ([1, 2; 3, 4], 0, 2)
 
 %!test
-%!
 %! t = ones (24, 1);
 %! j = 1;
 %!
-%! if false # eliminate big matrix tests
-%!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%! if (false)  # eliminate big matrix tests
+%!   a = rand (5000,20);
+%!   [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%!   [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%!   [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%!   [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %!
-%!   a = a+1i*eps('single');
-%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%!   a = a+1i*eps ("single");
+%!   [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%!   [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%!   [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%!   [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %! endif
 %!
-%! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
+%! a = [ ones(1,15); sqrt(eps("single"))*eye(15) ];
+%! [q,r]   = qr (a);   t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a');  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a);   t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a');  t(j++) = __testqr (q, r, a', p);
 %!
-%! a = a+1i*eps('single');
-%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
+%! a = a+1i*eps ("single");
+%! [q,r]   = qr (a);   t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a');  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a);   t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a');  t(j++) = __testqr (q, r, a', p);
 %!
-%! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%! a = [ ones(1,15); sqrt(eps("single"))*eye(15) ];
+%! [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a', p);
 %!
-%! a = a+1i*eps('single');
-%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
+%! a = a+1i*eps ("single");
+%! [q,r]   = qr (a, 0);  t(j++) = __testqr (q, r, a);
+%! [q,r]   = qr (a',0);  t(j++) = __testqr (q, r, a');
+%! [q,r,p] = qr (a, 0);  t(j++) = __testqr (q, r, a, p);
+%! [q,r,p] = qr (a',0);  t(j++) = __testqr (q, r, a',p);
 %!
-%! a = [
-%! 611   196  -192   407    -8   -52   -49    29
-%! 196   899   113  -192   -71   -43    -8   -44
-%! -192   113   899   196    61    49     8    52
-%! 407  -192   196   611     8    44    59   -23
-%! -8   -71    61     8   411  -599   208   208
-%! -52   -43    49    44  -599   411   208   208
-%! -49    -8     8    59   208   208    99  -911
-%! 29   -44    52   -23   208   208  -911    99
-%! ];
-%! [q,r] = qr(a);
+%! a = [ 611   196  -192   407    -8   -52   -49    29
+%!       196   899   113  -192   -71   -43    -8   -44
+%!      -192   113   899   196    61    49     8    52
+%!       407  -192   196   611     8    44    59   -23
+%!        -8   -71    61     8   411  -599   208   208
+%!       -52   -43    49    44  -599   411   208   208
+%!       -49    -8     8    59   208   208    99  -911
+%!        29   -44    52   -23   208   208  -911    99 ];
+%! [q,r] = qr (a);
 %!
-%! assert(all (t) && norm(q*r-a) < 5000*eps('single'));
+%! assert (all (t) && norm (q*r-a) < 5000*eps ("single"));
 
-%% The deactivated tests below can't be tested till rectangular back-subs is
-%% implemented for sparse matrices.
+## The deactivated tests below can't be tested till rectangular back-subs is
+## implemented for sparse matrices.
 
 %!testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = sprandn(n,n,d)+speye(n,n);
-%! r = qr(a);
-%! assert(r'*r,a'*a,1e-10)
+%! n = 20;  d = 0.2;
+%! a = sprandn (n,n,d) + speye (n,n);
+%! r = qr (a);
+%! assert (r'*r, a'*a, 1e-10)
 
 %!testif HAVE_COLAMD
-%! n = 20; d= 0.2;
-%! a = sprandn(n,n,d)+speye(n,n);
-%! q = symamd(a);
+%! n = 20;  d = 0.2;
+%! a = sprandn (n,n,d) + speye (n,n);
+%! q = symamd (a);
 %! a = a(q,q);
-%! r = qr(a);
-%! assert(r'*r,a'*a,1e-10)
+%! r = qr (a);
+%! assert (r'*r, a'*a, 1e-10)
 
 %!testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = sprandn(n,n,d)+speye(n,n);
-%! [c,r] = qr(a,ones(n,1));
-%! assert (r\c,full(a)\ones(n,1),10e-10)
+%! n = 20;  d = 0.2;
+%! a = sprandn (n,n,d) + speye (n,n);
+%! [c,r] = qr (a, ones (n,1));
+%! assert (r\c, full (a)\ones (n,1), 10e-10)
 
 %!testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = sprandn(n,n,d)+speye(n,n);
-%! b = randn(n,2);
-%! [c,r] = qr(a,b);
-%! assert (r\c,full(a)\b,10e-10)
+%! n = 20;  d = 0.2;
+%! a = sprandn (n,n,d) + speye (n,n);
+%! b = randn (n,2);
+%! [c,r] = qr (a, b);
+%! assert (r\c, full (a)\b, 10e-10)
 
 %% Test under-determined systems!!
 %!#testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = sprandn(n,n+1,d)+speye(n,n+1);
-%! b = randn(n,2);
-%! [c,r] = qr(a,b);
-%! assert (r\c,full(a)\b,10e-10)
+%! n = 20;  d = 0.2;
+%! a = sprandn (n,n+1,d) + speye (n,n+1);
+%! b = randn (n,2);
+%! [c,r] = qr (a, b);
+%! assert (r\c, full (a)\b, 10e-10)
 
 %!testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = 1i*sprandn(n,n,d)+speye(n,n);
-%! r = qr(a);
-%! assert(r'*r,a'*a,1e-10)
+%! n = 20;  d = 0.2;
+%! a = 1i*sprandn (n,n,d) + speye (n,n);
+%! r = qr (a);
+%! assert (r'*r,a'*a,1e-10)
 
 %!testif HAVE_COLAMD
-%! n = 20; d= 0.2;
-%! a = 1i*sprandn(n,n,d)+speye(n,n);
-%! q = symamd(a);
+%! n = 20;  d = 0.2;
+%! a = 1i*sprandn (n,n,d) + speye (n,n);
+%! q = symamd (a);
 %! a = a(q,q);
-%! r = qr(a);
-%! assert(r'*r,a'*a,1e-10)
+%! r = qr (a);
+%! assert (r'*r, a'*a, 1e-10)
 
 %!testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = 1i*sprandn(n,n,d)+speye(n,n);
-%! [c,r] = qr(a,ones(n,1));
-%! assert (r\c,full(a)\ones(n,1),10e-10)
+%! n = 20;  d = 0.2;
+%! a = 1i*sprandn (n,n,d) + speye (n,n);
+%! [c,r] = qr (a, ones (n,1));
+%! assert (r\c, full (a)\ones (n,1), 10e-10)
 
 %!testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = 1i*sprandn(n,n,d)+speye(n,n);
-%! b = randn(n,2);
-%! [c,r] = qr(a,b);
-%! assert (r\c,full(a)\b,10e-10)
+%! n = 20;  d = 0.2;
+%! a = 1i*sprandn (n,n,d) + speye (n,n);
+%! b = randn (n,2);
+%! [c,r] = qr (a, b);
+%! assert (r\c, full (a)\b, 10e-10)
 
 %% Test under-determined systems!!
 %!#testif HAVE_CXSPARSE
-%! n = 20; d= 0.2;
-%! a = 1i*sprandn(n,n+1,d)+speye(n,n+1);
-%! b = randn(n,2);
-%! [c,r] = qr(a,b);
-%! assert (r\c,full(a)\b,10e-10)
+%! n = 20;  d = 0.2;
+%! a = 1i*sprandn (n,n+1,d) + speye (n,n+1);
+%! b = randn (n,2);
+%! [c,r] = qr (a, b);
+%! assert (r\c, full (a)\b, 10e-10)
 
-%!error qr(sprandn(10,10,0.2),ones(10,1));
-
+%!error qr (sprandn (10,10,0.2), ones (10,1))
 */
 
 static
 bool check_qr_dims (const octave_value& q, const octave_value& r,
                     bool allow_ecf = false)
 {
   octave_idx_type m = q.rows (), k = r.rows (), n = r.columns ();
   return ((q.ndims () == 2 && r.ndims () == 2 && k == q.columns ())
@@ -880,16 +864,17 @@ The QR@tie{}factorization supplied may b
       else
         error ("qrupdate: Q and R dimensions don't match");
     }
   else
     error ("qrupdate: Q, R, U, and V must be numeric");
 
   return retval;
 }
+
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
 %!      0.383594  0.291238  0.085574;
 %!      0.265712  0.268003  0.238409;
 %!      0.669966  0.743851  0.445057 ];
 %!
@@ -916,42 +901,42 @@ The QR@tie{}factorization supplied may b
 %!      0.74871 + 0.25821i ];
 %!
 %! vc = [0.85839 + 0.29468i;
 %!      0.20820 + 0.93090i;
 %!      0.86184 + 0.34689i ];
 %!
 
 %!test
-%! [Q,R] = qr(A);
-%! [Q,R] = qrupdate(Q,R,u,v);
-%! assert(norm(vec(Q'*Q - eye(5)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - A - u*v'),Inf) < norm(A)*1e1*eps)
+%! [Q,R] = qr (A);
+%! [Q,R] = qrupdate (Q, R, u, v);
+%! assert (norm (vec (Q'*Q - eye (5)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R)-R), Inf) == 0);
+%! assert (norm (vec (Q*R - A - u*v'), Inf) < norm (A)*1e1*eps);
 %!
 %!test
-%! [Q,R] = qr(Ac);
-%! [Q,R] = qrupdate(Q,R,uc,vc);
-%! assert(norm(vec(Q'*Q - eye(5)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - Ac - uc*vc'),Inf) < norm(Ac)*1e1*eps)
+%! [Q,R] = qr (Ac);
+%! [Q,R] = qrupdate (Q, R, uc, vc);
+%! assert (norm (vec (Q'*Q - eye (5)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R)-R), Inf) == 0);
+%! assert (norm (vec (Q*R - Ac - uc*vc'), Inf) < norm (Ac)*1e1*eps);
 
 %!test
-%! [Q,R] = qr(single(A));
-%! [Q,R] = qrupdate(Q,R,single(u),single(v));
-%! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - single(A) - single(u)*single(v)'),Inf) < norm(single(A))*1e1*eps('single'))
+%! [Q,R] = qr (single (A));
+%! [Q,R] = qrupdate (Q, R, single (u), single (v));
+%! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R)-R), Inf) == 0);
+%! assert (norm (vec (Q*R - single (A) - single (u)*single (v)'), Inf) < norm (single (A))*1e1*eps ("single"));
 %!
 %!test
-%! [Q,R] = qr(single(Ac));
-%! [Q,R] = qrupdate(Q,R,single(uc),single(vc));
-%! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - single(Ac) - single(uc)*single(vc)'),Inf) < norm(single(Ac))*1e1*eps('single'))
+%! [Q,R] = qr (single (Ac));
+%! [Q,R] = qrupdate (Q, R, single (uc), single (vc));
+%! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R)-R), Inf) == 0);
+%! assert (norm (vec (Q*R - single (Ac) - single (uc)*single (vc)'), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrinsert, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
@@ -1105,72 +1090,72 @@ If @var{orient} is @code{\"row\"}, full 
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! [Q,R] = qr(A);
-%! [Q,R] = qrinsert(Q,R,3,u);
-%! assert(norm(vec(Q'*Q - eye(5)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [A(:,1:2) u A(:,3)]),Inf) < norm(A)*1e1*eps)
+%! [Q,R] = qr (A);
+%! [Q,R] = qrinsert (Q, R, 3, u);
+%! assert (norm (vec (Q'*Q - eye (5)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [A(:,1:2) u A(:,3)]), Inf) < norm (A)*1e1*eps);
 %!test
-%! [Q,R] = qr(Ac);
-%! [Q,R] = qrinsert(Q,R,3,uc);
-%! assert(norm(vec(Q'*Q - eye(5)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [Ac(:,1:2) uc Ac(:,3)]),Inf) < norm(Ac)*1e1*eps)
+%! [Q,R] = qr (Ac);
+%! [Q,R] = qrinsert (Q, R, 3, uc);
+%! assert (norm (vec (Q'*Q - eye (5)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [Ac(:,1:2) uc Ac(:,3)]), Inf) < norm (Ac)*1e1*eps);
 %!test
 %! x = [0.85082  0.76426  0.42883 ];
 %!
-%! [Q,R] = qr(A);
-%! [Q,R] = qrinsert(Q,R,3,x,'row');
-%! assert(norm(vec(Q'*Q - eye(6)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [A(1:2,:);x;A(3:5,:)]),Inf) < norm(A)*1e1*eps)
+%! [Q,R] = qr (A);
+%! [Q,R] = qrinsert (Q, R, 3, x, "row");
+%! assert (norm (vec (Q'*Q - eye (6)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [A(1:2,:);x;A(3:5,:)]), Inf) < norm (A)*1e1*eps);
 %!test
 %! x = [0.20351 + 0.05401i  0.13141 + 0.43708i  0.29808 + 0.08789i ];
 %!
-%! [Q,R] = qr(Ac);
-%! [Q,R] = qrinsert(Q,R,3,x,'row');
-%! assert(norm(vec(Q'*Q - eye(6)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [Ac(1:2,:);x;Ac(3:5,:)]),Inf) < norm(Ac)*1e1*eps)
+%! [Q,R] = qr (Ac);
+%! [Q,R] = qrinsert (Q, R, 3, x, "row");
+%! assert (norm (vec (Q'*Q - eye (6)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [Ac(1:2,:);x;Ac(3:5,:)]), Inf) < norm (Ac)*1e1*eps);
 
 %!test
-%! [Q,R] = qr(single(A));
-%! [Q,R] = qrinsert(Q,R,3,single(u));
-%! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - single([A(:,1:2) u A(:,3)])),Inf) < norm(single(A))*1e1*eps('single'))
+%! [Q,R] = qr (single (A));
+%! [Q,R] = qrinsert (Q, R, 3, single (u));
+%! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - single ([A(:,1:2) u A(:,3)])), Inf) < norm (single (A))*1e1*eps ("single"));
 %!test
-%! [Q,R] = qr(single(Ac));
-%! [Q,R] = qrinsert(Q,R,3,single(uc));
-%! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - single([Ac(:,1:2) uc Ac(:,3)])),Inf) < norm(single(Ac))*1e1*eps('single'))
+%! [Q,R] = qr (single (Ac));
+%! [Q,R] = qrinsert (Q, R, 3, single (uc));
+%! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - single ([Ac(:,1:2) uc Ac(:,3)])), Inf) < norm (single (Ac))*1e1*eps ("single"));
 %!test
-%! x = single([0.85082  0.76426  0.42883 ]);
+%! x = single ([0.85082  0.76426  0.42883 ]);
 %!
-%! [Q,R] = qr(single(A));
-%! [Q,R] = qrinsert(Q,R,3,x,'row');
-%! assert(norm(vec(Q'*Q - eye(6,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - single([A(1:2,:);x;A(3:5,:)])),Inf) < norm(single(A))*1e1*eps('single'))
+%! [Q,R] = qr (single (A));
+%! [Q,R] = qrinsert (Q, R, 3, x, "row");
+%! assert (norm (vec (Q'*Q - eye (6,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - single ([A(1:2,:);x;A(3:5,:)])), Inf) < norm (single (A))*1e1*eps ("single"));
 %!test
-%! x = single([0.20351 + 0.05401i  0.13141 + 0.43708i  0.29808 + 0.08789i ]);
+%! x = single ([0.20351 + 0.05401i  0.13141 + 0.43708i  0.29808 + 0.08789i ]);
 %!
-%! [Q,R] = qr(single(Ac));
-%! [Q,R] = qrinsert(Q,R,3,x,'row');
-%! assert(norm(vec(Q'*Q - eye(6,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - single([Ac(1:2,:);x;Ac(3:5,:)])),Inf) < norm(single(Ac))*1e1*eps('single'))
+%! [Q,R] = qr (single (Ac));
+%! [Q,R] = qrinsert (Q, R, 3, x, "row");
+%! assert (norm (vec (Q'*Q - eye (6,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - single ([Ac(1:2,:);x;Ac(3:5,:)])), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrdelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
@@ -1317,125 +1302,125 @@ If @var{orient} is @code{\"row\"}, full 
 /*
 %!test
 %! AA = [0.091364  0.613038  0.027504  0.999083;
 %!       0.594638  0.425302  0.562834  0.603537;
 %!       0.383594  0.291238  0.742073  0.085574;
 %!       0.265712  0.268003  0.783553  0.238409;
 %!       0.669966  0.743851  0.457255  0.445057 ];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3);
-%! assert(norm(vec(Q'*Q - eye(5)),Inf) < 16*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(:,1:2) AA(:,4)]),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3);
+%! assert (norm (vec (Q'*Q - eye (5)), Inf) < 16*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(:,1:2) AA(:,4)]), Inf) < norm (AA)*1e1*eps);
 %!
 %!test
 %! AA = [0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!       0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!       0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!       0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!       0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ] * I;
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3);
-%! assert(norm(vec(Q'*Q - eye(5)),Inf) < 16*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(:,1:2) AA(:,4)]),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3);
+%! assert (norm (vec (Q'*Q - eye (5)), Inf) < 16*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(:,1:2) AA(:,4)]), Inf) < norm (AA)*1e1*eps);
 %!
 %!test
 %! AA = [0.091364  0.613038  0.027504  0.999083;
 %!       0.594638  0.425302  0.562834  0.603537;
 %!       0.383594  0.291238  0.742073  0.085574;
 %!       0.265712  0.268003  0.783553  0.238409;
 %!       0.669966  0.743851  0.457255  0.445057 ];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3,'row');
-%! assert(norm(vec(Q'*Q - eye(4)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3, "row");
+%! assert (norm (vec (Q'*Q - eye (4)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps);
 %!
 %!test
 %! AA = [0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!       0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!       0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!       0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!       0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ] * I;
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3,'row');
-%! assert(norm(vec(Q'*Q - eye(4)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3, "row");
+%! assert (norm (vec (Q'*Q - eye (4)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps);
 
 %!test
-%! AA = single([0.091364  0.613038  0.027504  0.999083;
-%!              0.594638  0.425302  0.562834  0.603537;
-%!              0.383594  0.291238  0.742073  0.085574;
-%!              0.265712  0.268003  0.783553  0.238409;
-%!              0.669966  0.743851  0.457255  0.445057 ]);
+%! AA = single ([0.091364  0.613038  0.027504  0.999083;
+%!               0.594638  0.425302  0.562834  0.603537;
+%!               0.383594  0.291238  0.742073  0.085574;
+%!               0.265712  0.268003  0.783553  0.238409;
+%!               0.669966  0.743851  0.457255  0.445057 ]);
+%!
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3);
+%! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(:,1:2) AA(:,4)]), Inf) < norm (AA)*1e1*eps ("single"));
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3);
-%! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(:,1:2) AA(:,4)]),Inf) < norm(AA)*1e1*eps('single'))
+%!test
+%! AA = single ([0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
+%!               0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
+%!               0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
+%!               0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
+%!               0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ]) * I;
+%!
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3);
+%! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(:,1:2) AA(:,4)]), Inf) < norm (AA)*1e1*eps ("single"));
 %!
 %!test
-%! AA = single([0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
+%! AA = single ([0.091364  0.613038  0.027504  0.999083;
+%!               0.594638  0.425302  0.562834  0.603537;
+%!               0.383594  0.291238  0.742073  0.085574;
+%!               0.265712  0.268003  0.783553  0.238409;
+%!               0.669966  0.743851  0.457255  0.445057 ]);
+%!
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3, "row");
+%! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1.5e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
+%!testif HAVE_QRUPDATE
+%! # Same test as above but with more precicision
+%! AA = single ([0.091364  0.613038  0.027504  0.999083;
+%!               0.594638  0.425302  0.562834  0.603537;
+%!               0.383594  0.291238  0.742073  0.085574;
+%!               0.265712  0.268003  0.783553  0.238409;
+%!               0.669966  0.743851  0.457255  0.445057 ]);
+%!
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3, "row");
+%! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
+%!
+%!test
+%! AA = single ([0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!              0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!              0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!              0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!              0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ]) * I;
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3);
-%! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(:,1:2) AA(:,4)]),Inf) < norm(AA)*1e1*eps('single'))
-%!
-%!test
-%! AA = single([0.091364  0.613038  0.027504  0.999083;
-%!              0.594638  0.425302  0.562834  0.603537;
-%!              0.383594  0.291238  0.742073  0.085574;
-%!              0.265712  0.268003  0.783553  0.238409;
-%!              0.669966  0.743851  0.457255  0.445057 ]);
-%!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3,'row');
-%! assert(norm(vec(Q'*Q - eye(4,'single')),Inf) < 1.5e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps('single'))
-%!testif HAVE_QRUPDATE
-%! # Same test as above but with more precicision
-%! AA = single([0.091364  0.613038  0.027504  0.999083;
-%!              0.594638  0.425302  0.562834  0.603537;
-%!              0.383594  0.291238  0.742073  0.085574;
-%!              0.265712  0.268003  0.783553  0.238409;
-%!              0.669966  0.743851  0.457255  0.445057 ]);
-%!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3,'row');
-%! assert(norm(vec(Q'*Q - eye(4,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps('single'))
-%!
-%!test
-%! AA = single([0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
-%!              0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
-%!              0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
-%!              0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
-%!              0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ]) * I;
-%!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrdelete(Q,R,3,'row');
-%! assert(norm(vec(Q'*Q - eye(4,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps('single'))
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrdelete (Q, R, 3, "row");
+%! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrshift (@var{Q}, @var{R}, @var{i}, @var{j})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
@@ -1532,82 +1517,82 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
       else
         error ("qrshift: dimensions mismatch");
     }
   else
     error ("qrshift: Q and R must be numeric");
 
   return retval;
 }
+
 /*
 %!test
 %! AA = A.';
-%! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
+%! i = 2;  j = 4;  p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps);
 %!
-%! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
+%! j = 2;  i = 4;  p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps);
 %!
 %!test
 %! AA = Ac.';
-%! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
+%! i = 2;  j = 4;  p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps);
 %!
-%! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
+%! j = 2;  i = 4;  p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
-
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3)), Inf) < 1e1*eps);
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps);
 
 %!test
 %! AA = single (A).';
-%! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
+%! i = 2;  j = 4;  p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps ("single"));
 %!
-%! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
+%! j = 2;  i = 4;  p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps ("single"));
 %!
 %!test
-%! AA = single(Ac).';
-%! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
+%! AA = single (Ac).';
+%! i = 2;  j = 4;  p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps ("single"));
 %!
-%! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
+%! j = 2;  i = 4;  p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
-%! [Q,R] = qr(AA);
-%! [Q,R] = qrshift(Q,R,i,j);
-%! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
-%! assert(norm(vec(triu(R)-R),Inf) == 0)
-%! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
+%! [Q,R] = qr (AA);
+%! [Q,R] = qrshift (Q, R, i, j);
+%! assert (norm (vec (Q'*Q - eye (3,"single")), Inf) < 1e1*eps ("single"));
+%! assert (norm (vec (triu (R) - R), Inf) == 0);
+%! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps ("single"));
 */
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -468,44 +468,51 @@ variable by routines @code{dblquad} and 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!function y = __f (x)
-%! y = x + 1;
+%!  y = x + 1;
 %!endfunction
 
 %!test
 %! [v, ier, nfun, err] = quad ("__f", 0, 5);
-%! assert(ier == 0 && abs (v - 17.5) < sqrt (eps) && nfun > 0 &&
-%!        err < sqrt (eps))
+%! assert (ier, 0);
+%! assert (v, 17.5, sqrt (eps));
+%! assert (nfun > 0);
+%! assert (err < sqrt (eps));
+
 %!test
-%! [v, ier, nfun, err] = quad ("__f", single(0), single(5));
-%! assert(ier == 0 && abs (v - 17.5) < sqrt (eps ("single")) && nfun > 0 &&
-%!        err < sqrt (eps ("single")))
+%! [v, ier, nfun, err] = quad ("__f", single (0), single (5));
+%! assert (ier, 0);
+%! assert (v, 17.5, sqrt (eps ("single")));
+%! assert (nfun > 0);
+%! assert (err < sqrt (eps ("single")));
 
 %!function y = __f (x)
 %!  y = x .* sin (1 ./ x) .* sqrt (abs (1 - x));
 %!endfunction
 
 %!test
 %!  [v, ier, nfun, err] = quad ("__f", 0.001, 3);
-%! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps) && nfun > 0);
+%! assert (ier == 0 || ier == 1);
+%! assert (v, 1.98194120273598, sqrt (eps));
+%! assert (nfun > 0);
+
 %!test
-%!  [v, ier, nfun, err] = quad ("__f", single(0.001), single(3));
-%! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps ("single")) && nfun > 0);
+%!  [v, ier, nfun, err] = quad ("__f", single (0.001), single (3));
+%! assert (ier == 0 || ier == 1);
+%! assert (v, 1.98194120273598, sqrt (eps ("single")));
+%! assert (nfun > 0);
 
-%!error <Invalid call to quad> quad ();
-
-%!error <Invalid call to quad> quad ("__f", 1, 2, 3, 4, 5);
+%!error quad ()
+%!error quad ("__f", 1, 2, 3, 4, 5)
 
 %!test
 %! quad_options ("absolute tolerance", eps);
-%! assert(quad_options ("absolute tolerance") == eps);
+%! assert (quad_options ("absolute tolerance") == eps);
 
-%!error <Invalid call to quad_options> quad_options (1, 2, 3);
-
+%!error quad_options (1, 2, 3)
 */
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -2233,33 +2233,31 @@ Mathematical Software, Vol. 37, Issue 3,
     retval(1) = err;
   retval(0) = igral;
   /* All is well that ends well. */
   return retval;
 }
 
 
 /*
-
-%!assert (quadcc(@sin,-pi,pi), 0, 1e-6)
-%!assert (quadcc(inline('sin'),-pi,pi), 0, 1e-6)
-%!assert (quadcc('sin',-pi,pi), 0, 1e-6)
+%!assert (quadcc (@sin, -pi, pi), 0, 1e-6)
+%!assert (quadcc (inline ("sin"),- pi, pi), 0, 1e-6)
+%!assert (quadcc ("sin", -pi, pi), 0, 1e-6)
 
-%!assert (quadcc(@sin,-pi,0), -2, 1e-6)
-%!assert (quadcc(@sin,0,pi), 2, 1e-6)
-%!assert (quadcc(@(x) 1./sqrt(x), 0, 1), 2, 1e-6)
-%!assert (quadcc(@(x) 1./(sqrt(x).*(x+1)), 0, Inf), pi, 1e-6)
+%!assert (quadcc (@sin, -pi, 0), -2, 1e-6)
+%!assert (quadcc (@sin, 0, pi), 2, 1e-6)
+%!assert (quadcc (@(x) 1./sqrt (x), 0, 1), 2, 1e-6)
+%!assert (quadcc (@(x) 1./(sqrt (x).*(x+1)), 0, Inf), pi, 1e-6)
 
-%!assert (quadcc (@(x) exp(-x .^ 2), -Inf, Inf), sqrt(pi), 1e-6)
-%!assert (quadcc (@(x) exp(-x .^ 2), -Inf, 0), sqrt(pi)/2, 1e-6)
+%!assert (quadcc (@(x) exp (-x .^ 2), -Inf, Inf), sqrt (pi), 1e-6)
+%!assert (quadcc (@(x) exp (-x .^ 2), -Inf, 0), sqrt (pi)/2, 1e-6)
 
 %% Test input validation
 %!error (quadcc ())
 %!error (quadcc (@sin))
 %!error (quadcc (@sin, 0))
-%!error (quadcc (@sin, ones(2), pi))
+%!error (quadcc (@sin, ones (2), pi))
 %!error (quadcc (@sin, -i, pi))
-%!error (quadcc (@sin, 0, ones(2)))
+%!error (quadcc (@sin, 0, ones (2)))
 %!error (quadcc (@sin, 0, i))
 %!error (quadcc (@sin, 0, pi, 0))
 %!error (quadcc (@sin, 0, pi, 1e-6, [ i ]))
-
 */
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -1238,32 +1238,31 @@ compatibility with @sc{matlab}.\n\
   std::cout << "qz: exiting (at long last)" << std::endl;
 #endif
 
   return retval;
 }
 
 /*
 %!shared a, b, c
-%!  a = [1 2; 0 3];
-%!  b = [1 0; 0 0];
-%!  c = [0 1; 0 0];
-%!assert(qz (a,b), 1);
-%!assert(isempty (qz (a,c)));
+%! a = [1 2; 0 3];
+%! b = [1 0; 0 0];
+%! c = [0 1; 0 0];
+%!assert (qz (a,b), 1)
+%!assert (isempty (qz (a,c)))
 
-%% Exaple 7.7.3 in Golub & Van Loan
+## Exaple 7.7.3 in Golub & Van Loan
 %!test
 %! a = [ 10  1  2;
 %!        1  2 -1;
 %!        1  1  2];
-%! b = reshape(1:9,3,3);
+%! b = reshape (1:9,3,3);
 %! [aa, bb, q, z, v, w, lambda] = qz (a, b);
-%! sz = length(lambda);
-%! observed =  (b * v * diag ([lambda;0])) (:, 1:sz);
+%! sz = length (lambda);
+%! observed = (b * v * diag ([lambda;0])) (:, 1:sz);
 %! assert ( (a*v) (:, 1:sz), observed, norm (observed) * 1e-14);
 %! observed = (diag ([lambda;0]) * w' * b) (1:sz, :);
 %! assert ( (w'*a) (1:sz, :) , observed, norm (observed) * 1e-13);
 %! assert (q * a * z, aa, norm (aa) * 1e-14);
 %! assert (q * b * z, bb, norm (bb) * 1e-14);
 
-%% FIXME: Still need a test for third form of calling qz
-
+## FIXME: Still need a test for third form of calling qz
 */
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-re-mat.h"
 
 /*
 %!shared __random_statistical_tests__
-%! % Flag whether the statistical tests should be run in "make check" or not
+%! # Flag whether the statistical tests should be run in "make check" or not
 %! __random_statistical_tests__ = 0;
 */
 
 static octave_value
 do_rand (const octave_value_list& args, int nargin, const char *fcn,
          const std::string& distribution, bool additional_arg = false)
 {
   octave_value retval;
@@ -410,85 +410,84 @@ using the \"reset\" keyword.\n\
 
   return retval;
 }
 
 // FIXME -- The old generator (selected when "seed" is set) will not
 // work properly if compiled to use 64-bit integers.
 
 /*
-%!test # 'state' can be a scalar
-%! rand('state',12); x = rand(1,4);
-%! rand('state',12); y = rand(1,4);
-%! assert(x,y);
-%!test # 'state' can be a vector
-%! rand('state',[12,13]); x=rand(1,4);
-%! rand('state',[12;13]); y=rand(1,4);
-%! assert(x,y);
-%!test # querying 'state' doesn't disturb sequence
-%! rand('state',12); rand(1,2); x=rand(1,2);
-%! rand('state',12); rand(1,2);
-%! s=rand('state'); y=rand(1,2);
-%! assert(x,y);
-%! rand('state',s); z=rand(1,2);
-%! assert(x,z);
-%!test # 'seed' must be a scalar
-%! rand('seed',12); x = rand(1,4);
-%! rand('seed',12); y = rand(1,4);
-%! assert(x,y);
-%!error(rand('seed',[12,13]))
-%!test # querying 'seed' returns a value which can be used later
-%! s=rand('seed'); x=rand(1,2);
-%! rand('seed',s); y=rand(1,2);
-%! assert(x,y);
-%!test # querying 'seed' doesn't disturb sequence
-%! rand('seed',12); rand(1,2); x=rand(1,2);
-%! rand('seed',12); rand(1,2);
-%! s=rand('seed'); y=rand(1,2);
-%! assert(x,y);
-%! rand('seed',s); z=rand(1,2);
-%! assert(x,z);
+%!test  # "state" can be a scalar
+%! rand ("state", 12);  x = rand (1,4);
+%! rand ("state", 12);  y = rand (1,4);
+%! assert (x, y);
+%!test  # "state" can be a vector
+%! rand ("state", [12,13]);  x = rand (1,4);
+%! rand ("state", [12;13]);  y = rand (1,4);
+%! assert (x, y);
+%!test  # querying "state" doesn't disturb sequence
+%! rand ("state", 12);  rand (1,2);  x = rand (1,2);
+%! rand ("state", 12);  rand (1,2);
+%! s = rand ("state");  y = rand (1,2);
+%! assert (x, y);
+%! rand ("state", s);  z = rand (1,2);
+%! assert (x, z);
+%!test  # "seed" must be a scalar
+%! rand ("seed", 12);  x = rand (1,4);
+%! rand ("seed", 12);  y = rand (1,4);
+%! assert (x, y);
+%!error <seed must be a real scalar> rand ("seed", [12,13])
+%!test  # querying "seed" returns a value which can be used later
+%! s = rand ("seed");  x = rand (1,2);
+%! rand ("seed", s);  y = rand (1,2);
+%! assert (x, y);
+%!test  # querying "seed" doesn't disturb sequence
+%! rand ("seed", 12);  rand (1,2);  x = rand (1,2);
+%! rand ("seed", 12);  rand (1,2);
+%! s = rand ("seed");  y = rand (1,2);
+%! assert (x, y);
+%! rand ("seed", s);  z = rand (1,2);
+%! assert (x, z);
 */
 
 /*
 %!test
-%! % Test fixed state
-%! rand("state",1);
-%! assert (rand(1,6), [0.1343642441124013 0.8474337369372327 0.763774618976614 0.2550690257394218 0.495435087091941 0.4494910647887382],1e-6);
+%! # Test fixed state
+%! rand ("state", 1);
+%! assert (rand (1,6), [0.1343642441124013 0.8474337369372327 0.763774618976614 0.2550690257394218 0.495435087091941 0.4494910647887382], 1e-6);
 %!test
-%! % Test fixed seed
-%! rand("seed",1);
-%! assert (rand(1,6), [0.8668024251237512 0.9126510815694928 0.09366085007786751 0.1664607301354408 0.7408077004365623 0.7615650338120759],1e-6);
+%! # Test fixed seed
+%! rand ("seed", 1);
+%! assert (rand (1,6), [0.8668024251237512 0.9126510815694928 0.09366085007786751 0.1664607301354408 0.7408077004365623 0.7615650338120759], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   rand("state",12);
-%!   x = rand(100000,1);
-%!   assert(max(x)<1.); %*** Please report this!!! ***
-%!   assert(min(x)>0.); %*** Please report this!!! ***
-%!   assert(mean(x),0.5,0.0024);
-%!   assert(var(x),1/48,0.0632);
-%!   assert(skewness(x),0,0.012);
-%!   assert(kurtosis(x),-6/5,0.0094);
+%!   # statistical tests may fail occasionally.
+%!   rand ("state", 12);
+%!   x = rand (100000, 1);
+%!   assert (max (x) < 1);   #*** Please report this!!! ***
+%!   assert (min (x) > 0);   #*** Please report this!!! ***
+%!   assert (mean (x), 0.5, 0.0024);
+%!   assert (var (x), 1/48, 0.0632);
+%!   assert (skewness (x), 0, 0.012);
+%!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   rand("seed",12);
-%!   x = rand(100000,1);
-%!   assert(max(x)<1.); %*** Please report this!!! ***
-%!   assert(min(x)>0.); %*** Please report this!!! ***
-%!   assert(mean(x),0.5,0.0024);
-%!   assert(var(x),1/48,0.0632);
-%!   assert(skewness(x),0,0.012);
-%!   assert(kurtosis(x),-6/5,0.0094);
+%!   # statistical tests may fail occasionally.
+%!   rand ("seed", 12);
+%!   x = rand (100000, 1);
+%!   assert (max (x) < 1);   #*** Please report this!!! ***
+%!   assert (min (x) > 0);   #*** Please report this!!! ***
+%!   assert (mean (x), 0.5, 0.0024);
+%!   assert (var (x), 1/48, 0.0632);
+%!   assert (skewness (x), 0, 0.012);
+%!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 */
 
-
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN_DLD (randn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randn (@var{n})\n\
 @deftypefnx {Loadable Function} {} randn (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Loadable Function} {} randn ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randn (\"state\")\n\
@@ -518,42 +517,42 @@ J. Statistical Software, vol 5, 2000,\n\
 
   retval = do_rand (args, nargin, "randn", "normal");
 
   return retval;
 }
 
 /*
 %!test
-%! % Test fixed state
-%! randn("state",1);
-%! assert (randn(1,6), [-2.666521678978671 -0.7381719971724564 1.507903992673601 0.6019427189162239 -0.450661261143348 -0.7054431351574116],1e-6);
+%! # Test fixed state
+%! randn ("state", 1);
+%! assert (randn (1, 6), [-2.666521678978671 -0.7381719971724564 1.507903992673601 0.6019427189162239 -0.450661261143348 -0.7054431351574116], 1e-6);
 %!test
-%! % Test fixed seed
-%! randn("seed",1);
-%! assert (randn(1,6), [-1.039402365684509 -1.25938892364502 0.1968704611063004 0.3874166905879974 -0.5976632833480835 -0.6615074276924133],1e-6);
+%! # Test fixed seed
+%! randn ("seed", 1);
+%! assert (randn (1, 6), [-1.039402365684509 -1.25938892364502 0.1968704611063004 0.3874166905879974 -0.5976632833480835 -0.6615074276924133], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randn("state",12);
-%!   x = randn(100000,1);
-%!   assert(mean(x),0,0.01);
-%!   assert(var(x),1,0.02);
-%!   assert(skewness(x),0,0.02);
-%!   assert(kurtosis(x),0,0.04);
+%!   # statistical tests may fail occasionally.
+%!   randn ("state", 12);
+%!   x = randn (100000, 1);
+%!   assert (mean (x), 0, 0.01);
+%!   assert (var (x), 1, 0.02);
+%!   assert (skewness (x), 0, 0.02);
+%!   assert (kurtosis (x), 0, 0.04);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randn("seed",12);
-%!   x = randn(100000,1);
-%!   assert(mean(x),0,0.01);
-%!   assert(var(x),1,0.02);
-%!   assert(skewness(x),0,0.02);
-%!   assert(kurtosis(x),0,0.04);
+%!   # statistical tests may fail occasionally.
+%!   randn ("seed", 12);
+%!   x = randn (100000, 1);
+%!   assert (mean (x), 0, 0.01);
+%!   assert (var (x), 1, 0.02);
+%!   assert (skewness (x), 0, 0.02);
+%!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
 
 DEFUN_DLD (rande, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} rande (@var{n})\n\
 @deftypefnx {Loadable Function} {} rande (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Loadable Function} {} rande ([@var{n} @var{m} @dots{}])\n\
@@ -583,44 +582,44 @@ J. Statistical Software, vol 5, 2000,\n\
 
   retval = do_rand (args, nargin, "rande", "exponential");
 
   return retval;
 }
 
 /*
 %!test
-%! % Test fixed state
-%! rande("state",1);
-%! assert (rande(1,6), [3.602973885835625 0.1386190677555021 0.6743112889616958 0.4512830847258422 0.7255744741233175 0.3415969205292291],1e-6);
+%! # Test fixed state
+%! rande ("state", 1);
+%! assert (rande (1, 6), [3.602973885835625 0.1386190677555021 0.6743112889616958 0.4512830847258422 0.7255744741233175 0.3415969205292291], 1e-6);
 %!test
-%! % Test fixed seed
-%! rande("seed",1);
-%! assert (rande(1,6), [0.06492075175653866 1.717980206012726 0.4816154008731246 0.5231300676241517 0.103910739364359 1.668931916356087],1e-6);
+%! # Test fixed seed
+%! rande ("seed", 1);
+%! assert (rande (1, 6), [0.06492075175653866 1.717980206012726 0.4816154008731246 0.5231300676241517 0.103910739364359 1.668931916356087], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally
-%!   rande("state",1);
-%!   x = rande(100000,1);
-%!   assert(min(x)>0); % *** Please report this!!! ***
-%!   assert(mean(x),1,0.01);
-%!   assert(var(x),1,0.03);
-%!   assert(skewness(x),2,0.06);
-%!   assert(kurtosis(x),6,0.7);
+%!   # statistical tests may fail occasionally
+%!   rande ("state", 1);
+%!   x = rande (100000, 1);
+%!   assert (min (x) > 0);   # *** Please report this!!! ***
+%!   assert (mean (x), 1, 0.01);
+%!   assert (var (x), 1, 0.03);
+%!   assert (skewness (x), 2, 0.06);
+%!   assert (kurtosis (x), 6, 0.7);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally
-%!   rande("seed",1);
-%!   x = rande(100000,1);
-%!   assert(min(x)>0); % *** Please report this!!! ***
-%!   assert(mean(x),1,0.01);
-%!   assert(var(x),1,0.03);
-%!   assert(skewness(x),2,0.06);
-%!   assert(kurtosis(x),6,0.7);
+%!   # statistical tests may fail occasionally
+%!   rande ("seed", 1);
+%!   x = rande (100000, 1);
+%!   assert (min (x)>0);   # *** Please report this!!! ***
+%!   assert (mean (x), 1, 0.01);
+%!   assert (var (x), 1, 0.03);
+%!   assert (skewness (x), 2, 0.06);
+%!   assert (kurtosis (x), 6, 0.7);
 %! endif
 */
 
 DEFUN_DLD (randg, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randg (@var{n})\n\
 @deftypefnx {Loadable Function} {} randg (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Loadable Function} {} randg ([@var{n} @var{m} @dots{}])\n\
@@ -721,166 +720,175 @@ r = r / sum (r)\n\
   else
     retval = do_rand (args, nargin, "randg", "gamma", true);
 
   return retval;
 }
 
 /*
 %!test
-%! randg("state",12)
-%!assert(randg([-inf,-1,0,inf,nan]),[nan,nan,nan,nan,nan]) % *** Please report
-
+%! randg ("state", 12)
+%! assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]); # *** Please report
 
 %!test
-%! % Test fixed state
-%! randg("state",1);
-%! assert (randg(0.1,1,6), [0.0103951513331241 8.335671459898252e-05 0.00138691397249762 0.000587308416993855 0.495590518784736 2.3921917414795e-12],1e-6);
+%! # Test fixed state
+%! randg ("state", 1);
+%! assert (randg (0.1, 1, 6), [0.0103951513331241 8.335671459898252e-05 0.00138691397249762 0.000587308416993855 0.495590518784736 2.3921917414795e-12], 1e-6);
 %!test
-%! % Test fixed state
-%! randg("state",1);
-%! assert (randg(0.95,1,6), [3.099382433255327 0.3974529788871218 0.644367450750855 1.143261091802246 1.964111762696822 0.04011915547957939],1e-6);
+%! # Test fixed state
+%! randg ("state", 1);
+%! assert (randg (0.95, 1, 6), [3.099382433255327 0.3974529788871218 0.644367450750855 1.143261091802246 1.964111762696822 0.04011915547957939], 1e-6);
 %!test
-%! % Test fixed state
-%! randg("state",1);
-%! assert (randg(1,1,6), [0.2273389379645993 1.288822625058359 0.2406335209340746 1.218869553370733 1.024649860162554 0.09631230343599533],1e-6);
+%! # Test fixed state
+%! randg ("state", 1);
+%! assert (randg (1, 1, 6), [0.2273389379645993 1.288822625058359 0.2406335209340746 1.218869553370733 1.024649860162554 0.09631230343599533], 1e-6);
 %!test
-%! % Test fixed state
-%! randg("state",1);
-%! assert (randg(10,1,6), [3.520369644331133 15.15369864472106 8.332112081991205 8.406211067432674 11.81193475187611 10.88792728177059],1e-5);
+%! # Test fixed state
+%! randg ("state", 1);
+%! assert (randg (10, 1, 6), [3.520369644331133 15.15369864472106 8.332112081991205 8.406211067432674 11.81193475187611 10.88792728177059], 1e-5);
 %!test
-%! % Test fixed state
-%! randg("state",1);
-%! assert (randg(100,1,6), [75.34570255262264 115.4911985594699 95.23493031356388 95.48926019250911 106.2397448229803 103.4813150404118],1e-4);
+%! # Test fixed state
+%! randg ("state", 1);
+%! assert (randg (100, 1, 6), [75.34570255262264 115.4911985594699 95.23493031356388 95.48926019250911 106.2397448229803 103.4813150404118], 1e-4);
 %!test
-%! % Test fixed seed
-%! randg("seed",1);
-%! assert (randg(0.1,1,6), [0.07144210487604141 0.460641473531723 0.4749028384685516 0.06823389977216721 0.000293838675133884 1.802567535340305e-12],1e-6);
+%! # Test fixed seed
+%! randg ("seed", 1);
+%! assert (randg (0.1, 1, 6), [0.07144210487604141 0.460641473531723 0.4749028384685516 0.06823389977216721 0.000293838675133884 1.802567535340305e-12], 1e-6);
 %!test
-%! % Test fixed seed
-%! randg("seed",1);
-%! assert (randg(0.95,1,6), [1.664905071258545 1.879976987838745 1.905677795410156 0.9948706030845642 0.5606933236122131 0.0766092911362648],1e-6);
+%! # Test fixed seed
+%! randg ("seed", 1);
+%! assert (randg (0.95, 1, 6), [1.664905071258545 1.879976987838745 1.905677795410156 0.9948706030845642 0.5606933236122131 0.0766092911362648], 1e-6);
 %!test
-%! % Test fixed seed
-%! randg("seed",1);
-%! assert (randg(1,1,6), [0.03512085229158401 0.6488978862762451 0.8114678859710693 0.1666885763406754 1.60791552066803 1.90356981754303],1e-6);
+%! # Test fixed seed
+%! randg ("seed", 1);
+%! assert (randg (1, 1, 6), [0.03512085229158401 0.6488978862762451 0.8114678859710693 0.1666885763406754 1.60791552066803 1.90356981754303], 1e-6);
 %!test
-%! % Test fixed seed
-%! randg("seed",1);
-%! assert (randg(10,1,6), [6.566435813903809 10.11648464202881 10.73162078857422 7.747178077697754 6.278522491455078 6.240195751190186],1e-5);
+%! # Test fixed seed
+%! randg ("seed", 1);
+%! assert (randg (10, 1, 6), [6.566435813903809 10.11648464202881 10.73162078857422 7.747178077697754 6.278522491455078 6.240195751190186], 1e-5);
 %!test
-%! % Test fixed seed
-%! randg("seed",1);
-%! assert (randg(100,1,6), [89.40208435058594 101.4734725952148 103.4020004272461 93.62763214111328 88.33104705810547 88.1871337890625],1e-4);
+%! # Test fixed seed
+%! randg ("seed", 1);
+%! assert (randg (100, 1, 6), [89.40208435058594 101.4734725952148 103.4020004272461 93.62763214111328 88.33104705810547 88.1871337890625], 1e-4);
+
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("state",12)
-%!   a=0.1; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.01);
-%!   assert(var(x),     a,         0.01);
-%!   assert(skewness(x),2/sqrt(a), 1.);
-%!   assert(kurtosis(x),6/a,       50.);
+%!   # statistical tests may fail occasionally.
+%!   randg ("state", 12);
+%!   a = 0.1;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.01);
+%!   assert (var (x),      a,          0.01);
+%!   assert (skewness (x), 2/sqrt (a), 1);
+%!   assert (kurtosis (x), 6/a,        50);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("state",12)
-%!   a=0.95; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.01);
-%!   assert(var(x),     a,         0.04);
-%!   assert(skewness(x),2/sqrt(a), 0.2);
-%!   assert(kurtosis(x),6/a,       2.);
+%!   # statistical tests may fail occasionally.
+%!   randg ("state", 12);
+%!   a = 0.95;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.01);
+%!   assert (var (x),      a,          0.04);
+%!   assert (skewness (x), 2/sqrt (a), 0.2);
+%!   assert (kurtosis (x), 6/a,        2);
+%! endif
+%!test
+%! if (__random_statistical_tests__)
+%!   # statistical tests may fail occasionally.
+%!   randg ("state", 12);
+%!   a = 1;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.01);
+%!   assert (var (x),      a,          0.04);
+%!   assert (skewness (x), 2/sqrt (a), 0.2);
+%!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("state",12)
-%!   a=1; x = randg(a,100000,1);
-%!   assert(mean(x),a,             0.01);
-%!   assert(var(x),a,              0.04);
-%!   assert(skewness(x),2/sqrt(a), 0.2);
-%!   assert(kurtosis(x),6/a,       2.);
+%!   # statistical tests may fail occasionally.
+%!   randg ("state", 12);
+%!   a = 10;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.1);
+%!   assert (var (x),      a,          0.5);
+%!   assert (skewness (x), 2/sqrt (a), 0.1);
+%!   assert (kurtosis (x), 6/a,        0.5);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("state",12)
-%!   a=10; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.1);
-%!   assert(var(x),     a,         0.5);
-%!   assert(skewness(x),2/sqrt(a), 0.1);
-%!   assert(kurtosis(x),6/a,       0.5);
+%!   # statistical tests may fail occasionally.
+%!   randg ("state", 12);
+%!   a = 100;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.2);
+%!   assert (var (x),      a,          2);
+%!   assert (skewness (x), 2/sqrt (a), 0.05);
+%!   assert (kurtosis (x), 6/a,        0.2);
+%! endif
+%!test
+%! randg ("seed", 12);
+%!assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]) # *** Please report
+%!test
+%! if (__random_statistical_tests__)
+%!   # statistical tests may fail occasionally.
+%!   randg ("seed", 12);
+%!   a = 0.1;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.01);
+%!   assert (var (x),      a,          0.01);
+%!   assert (skewness (x), 2/sqrt (a), 1);
+%!   assert (kurtosis (x), 6/a,        50);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("state",12)
-%!   a=100; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.2);
-%!   assert(var(x),     a,         2.);
-%!   assert(skewness(x),2/sqrt(a), 0.05);
-%!   assert(kurtosis(x),6/a,       0.2);
+%!   # statistical tests may fail occasionally.
+%!   randg ("seed", 12);
+%!   a = 0.95;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.01);
+%!   assert (var (x),      a,          0.04);
+%!   assert (skewness (x), 2/sqrt (a), 0.2);
+%!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
-%! randg("seed",12)
-%!assert(randg([-inf,-1,0,inf,nan]),[nan,nan,nan,nan,nan]) % *** Please report
-%!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("seed",12)
-%!   a=0.1; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.01);
-%!   assert(var(x),     a,         0.01);
-%!   assert(skewness(x),2/sqrt(a), 1.);
-%!   assert(kurtosis(x),6/a,       50.);
+%!   # statistical tests may fail occasionally.
+%!   randg ("seed", 12);
+%!   a = 1;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.01);
+%!   assert (var (x),      a,          0.04);
+%!   assert (skewness (x), 2/sqrt (a), 0.2);
+%!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("seed",12)
-%!   a=0.95; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.01);
-%!   assert(var(x),     a,         0.04);
-%!   assert(skewness(x),2/sqrt(a), 0.2);
-%!   assert(kurtosis(x),6/a,       2.);
-%! endif
-%!test
-%! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("seed",12)
-%!   a=1; x = randg(a,100000,1);
-%!   assert(mean(x),a,             0.01);
-%!   assert(var(x),a,              0.04);
-%!   assert(skewness(x),2/sqrt(a), 0.2);
-%!   assert(kurtosis(x),6/a,       2.);
+%!   # statistical tests may fail occasionally.
+%!   randg ("seed", 12);
+%!   a = 10;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.1);
+%!   assert (var (x),      a,          0.5);
+%!   assert (skewness (x), 2/sqrt (a), 0.1);
+%!   assert (kurtosis (x), 6/a,        0.5);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("seed",12)
-%!   a=10; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.1);
-%!   assert(var(x),     a,         0.5);
-%!   assert(skewness(x),2/sqrt(a), 0.1);
-%!   assert(kurtosis(x),6/a,       0.5);
-%! endif
-%!test
-%! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randg("seed",12)
-%!   a=100; x = randg(a,100000,1);
-%!   assert(mean(x),    a,         0.2);
-%!   assert(var(x),     a,         2.);
-%!   assert(skewness(x),2/sqrt(a), 0.05);
-%!   assert(kurtosis(x),6/a,       0.2);
+%!   # statistical tests may fail occasionally.
+%!   randg ("seed", 12);
+%!   a = 100;
+%!   x = randg (a, 100000, 1);
+%!   assert (mean (x),     a,          0.2);
+%!   assert (var (x),      a,          2);
+%!   assert (skewness (x), 2/sqrt (a), 0.05);
+%!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 */
 
-
 DEFUN_DLD (randp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randp (@var{l}, @var{n})\n\
 @deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Loadable Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randp (\"state\")\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", \"reset\")\n\
@@ -929,96 +937,96 @@ D 50 p1284, 1994.\n\
   else
     retval = do_rand (args, nargin, "randp", "poisson", true);
 
   return retval;
 }
 
 /*
 %!test
-%! randp("state",12)
-%!assert(randp([-inf,-1,0,inf,nan]),[nan,nan,0,nan,nan]); % *** Please report
+%! randp ("state", 12);
+%! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
-%! % Test fixed state
-%! randp("state",1);
-%! assert(randp(5,1,6),[5 5 3 7 7 3])
+%! # Test fixed state
+%! randp ("state", 1);
+%! assert (randp (5, 1, 6), [5 5 3 7 7 3])
 %!test
-%! % Test fixed state
-%! randp("state",1);
-%! assert(randp(15,1,6),[13 15 8 18 18 15])
+%! # Test fixed state
+%! randp ("state", 1);
+%! assert (randp (15, 1, 6), [13 15 8 18 18 15])
 %!test
-%! % Test fixed state
-%! randp("state",1);
-%! assert(randp(1e9,1,6),[999915677 999976657 1000047684 1000019035 999985749 999977692],-1e-6)
+%! # Test fixed state
+%! randp ("state", 1);
+%! assert (randp (1e9, 1, 6), [999915677 999976657 1000047684 1000019035 999985749 999977692], -1e-6)
 %!test
-%! % Test fixed state
-%! randp("seed",1);
-%! %%assert(randp(5,1,6),[8 2 3 6 6 8])
-%! assert(randp(5,1,5),[8 2 3 6 6])
+%! # Test fixed state
+%! randp ("seed", 1);
+%! %%assert (randp (5, 1, 6), [8 2 3 6 6 8])
+%! assert (randp (5, 1, 5), [8 2 3 6 6])
 %!test
-%! % Test fixed state
-%! randp("seed",1);
-%! assert(randp(15,1,6),[15 16 12 10 10 12])
+%! # Test fixed state
+%! randp ("seed", 1);
+%! assert (randp (15, 1, 6), [15 16 12 10 10 12])
 %!test
-%! % Test fixed state
-%! randp("seed",1);
-%! assert(randp(1e9,1,6),[1000006208 1000012224 999981120 999963520 999963072 999981440],-1e-6)
+%! # Test fixed state
+%! randp ("seed", 1);
+%! assert (randp (1e9, 1, 6), [1000006208 1000012224 999981120 999963520 999963072 999981440], -1e-6)
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randp("state",12)
-%!   for a=[5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
-%!     x = randp(a(1),100000,1);
-%!     assert(min(x)>=0); % *** Please report this!!! ***
-%!     assert(mean(x),a(1),a(2));
-%!     assert(var(x),a(1),0.02*a(1));
-%!     assert(skewness(x),1/sqrt(a(1)),a(3));
-%!     assert(kurtosis(x),1/a(1),3*a(3));
+%!   # statistical tests may fail occasionally.
+%!   randp ("state", 12);
+%!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
+%!     x = randp (a (1), 100000, 1);
+%!     assert (min (x) >= 0);   # *** Please report this!!! ***
+%!     assert (mean (x), a(1), a(2));
+%!     assert (var (x), a(1), 0.02*a(1));
+%!     assert (skewness (x), 1/sqrt (a(1)), a(3));
+%!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randp("state",12)
-%!   for a=[5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
-%!     x = randp(a(1)*ones(100000,1),100000,1);
-%!     assert(min(x)>=0); % *** Please report this!!! ***
-%!     assert(mean(x),a(1),a(2));
-%!     assert(var(x),a(1),0.02*a(1));
-%!     assert(skewness(x),1/sqrt(a(1)),a(3));
-%!     assert(kurtosis(x),1/a(1),3*a(3));
+%!   # statistical tests may fail occasionally.
+%!   randp ("state", 12);
+%!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
+%!     x = randp (a(1)*ones (100000, 1), 100000, 1);
+%!     assert (min (x) >= 0);   # *** Please report this!!! ***
+%!     assert (mean (x), a(1), a(2));
+%!     assert (var (x), a(1), 0.02*a(1));
+%!     assert (skewness (x), 1/sqrt (a(1)), a(3));
+%!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
-%! randp("seed",12)
-%!assert(randp([-inf,-1,0,inf,nan]),[nan,nan,0,nan,nan]); % *** Please report
+%! randp ("seed", 12);
+%! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randp("seed",12)
-%!   for a=[5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
-%!     x = randp(a(1),100000,1);
-%!     assert(min(x)>=0); % *** Please report this!!! ***
-%!     assert(mean(x),a(1),a(2));
-%!     assert(var(x),a(1),0.02*a(1));
-%!     assert(skewness(x),1/sqrt(a(1)),a(3));
-%!     assert(kurtosis(x),1/a(1),3*a(3));
+%!   # statistical tests may fail occasionally.
+%!   randp ("seed", 12);
+%!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
+%!     x = randp (a(1), 100000, 1);
+%!     assert (min (x) >= 0);   # *** Please report this!!! ***
+%!     assert (mean (x), a(1), a(2));
+%!     assert (var (x), a(1), 0.02*a(1));
+%!     assert (skewness (x), 1/sqrt (a(1)), a(3));
+%!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   % statistical tests may fail occasionally.
-%!   randp("seed",12)
-%!   for a=[5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
-%!     x = randp(a(1)*ones(100000,1),100000,1);
-%!     assert(min(x)>=0); % *** Please report this!!! ***
-%!     assert(mean(x),a(1),a(2));
-%!     assert(var(x),a(1),0.02*a(1));
-%!     assert(skewness(x),1/sqrt(a(1)),a(3));
-%!     assert(kurtosis(x),1/a(1),3*a(3));
+%!   # statistical tests may fail occasionally.
+%!   randp ("seed", 12);
+%!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
+%!     x = randp (a(1)*ones (100000, 1), 100000, 1);
+%!     assert (min (x) >= 0);   # *** Please report this!!! ***
+%!     assert (mean (x), a(1), a(2));
+%!     assert (var (x), a(1), 0.02*a(1));
+%!     assert (skewness (x), 1/sqrt (a(1)), a(3));
+%!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
@@ -1121,11 +1129,11 @@ using std::unordered_map;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(sort (randperm (20)),1:20)
-%!assert(length (randperm (20,10)), 10)
+%!assert (sort (randperm (20)), 1:20)
+%!assert (length (randperm (20,10)), 10)
 */
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -82,15 +82,13 @@ instead.\n\
       retval = m.rcond (mattyp);
       args(0).matrix_type (mattyp);
     }
 
   return retval;
 }
 
 /*
-
-%!assert( rcond (eye (2)), 1)
-%!assert( rcond (ones (2)), 0)
-%!assert( rcond ([1 1; 2 1]), 1/9)
-%!assert( rcond (magic (4)), 0, eps)
-
+%!assert (rcond (eye (2)), 1)
+%!assert (rcond (ones (2)), 0)
+%!assert (rcond ([1 1; 2 1]), 1/9)
+%!assert (rcond (magic (4)), 0, eps)
 */
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -644,195 +644,193 @@ Alternatively, use (?x) in the pattern.\
     retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexp");
   else
     retval = octregexp (args, nargout, "regexp");
 
   return retval;
 }
 
 /*
-
 ## PCRE_ERROR_MATCHLIMIT test
 %!test
-%! s=sprintf('\t4\n0000\t-0.00\t-0.0000\t4\t-0.00\t-0.0000\t4\n0000\t-0.00\t-0.0000\t0\t-0.00\t-');
-%! ws = warning("query");
+%! s = sprintf ('\t4\n0000\t-0.00\t-0.0000\t4\t-0.00\t-0.0000\t4\n0000\t-0.00\t-0.0000\t0\t-0.00\t-');
+%! ws = warning ("query");
 %! unwind_protect
-%!   warning("off");
-%!   regexp(s, '(\s*-*\d+[.]*\d*\s*)+\n');
+%!   warning ("off");
+%!   regexp (s, '(\s*-*\d+[.]*\d*\s*)+\n');
 %! unwind_protect_cleanup
-%!   warning(ws);
+%!   warning (ws);
 %! end_unwind_protect
 
-## seg-fault test
-%!assert(regexp("abcde","."),[1,2,3,4,5])
+## segfault test
+%!assert (regexp ("abcde", "."), [1,2,3,4,5])
 ## Infinite loop test
-%!assert (isempty (regexp("abcde", "")))
+%!assert (isempty (regexp ("abcde", "")))
 
 ## Check that anchoring of pattern works correctly
-%!assert(regexp('abcabc','^abc'),1);
-%!assert(regexp('abcabc','abc$'),4);
-%!assert(regexp('abcabc','^abc$'),zeros(1,0));
+%!assert (regexp ('abcabc', '^abc'), 1)
+%!assert (regexp ('abcabc', 'abc$'), 4)
+%!assert (regexp ('abcabc', '^abc$'), zeros (1,0))
 
 %!test
-%! [s, e, te, m, t] = regexp(' No Match ', 'f(.*)uck');
-%! assert (s,zeros(1,0))
-%! assert (e,zeros(1,0))
-%! assert (te,cell(1,0))
-%! assert (m, cell(1,0))
-%! assert (t, cell(1,0))
+%! [s, e, te, m, t] = regexp (' No Match ', 'f(.*)uck');
+%! assert (s, zeros (1,0));
+%! assert (e, zeros (1,0));
+%! assert (te, cell (1,0));
+%! assert (m, cell (1,0));
+%! assert (t, cell (1,0));
 
 %!test
-%! [s, e, te, m, t] = regexp(' FiRetrUck ', 'f(.*)uck');
-%! assert (s,zeros(1,0))
-%! assert (e,zeros(1,0))
-%! assert (te,cell(1,0))
-%! assert (m, cell(1,0))
-%! assert (t, cell(1,0))
+%! [s, e, te, m, t] = regexp (' FiRetrUck ', 'f(.*)uck');
+%! assert (s, zeros (1,0));
+%! assert (e, zeros (1,0));
+%! assert (te, cell (1,0));
+%! assert (m, cell (1,0));
+%! assert (t, cell (1,0));
 
 %!test
-%! [s, e, te, m, t] = regexp(' firetruck ', 'f(.*)uck');
-%! assert (s,2)
-%! assert (e,10)
-%! assert (te{1},[3,7])
-%! assert (m{1}, 'firetruck')
-%! assert (t{1}{1}, 'iretr')
+%! [s, e, te, m, t] = regexp (' firetruck ', 'f(.*)uck');
+%! assert (s, 2);
+%! assert (e, 10);
+%! assert (te{1}, [3, 7]);
+%! assert (m{1}, 'firetruck');
+%! assert (t{1}{1}, 'iretr');
 
 %!test
-%! [s, e, te, m, t] = regexp('short test string','\w*r\w*');
-%! assert (s,[1,12])
-%! assert (e,[5,17])
-%! assert (size(te), [1,2])
-%! assert (isempty(te{1}))
-%! assert (isempty(te{2}))
-%! assert (m{1},'short')
-%! assert (m{2},'string')
-%! assert (size(t), [1,2])
-%! assert (isempty(t{1}))
-%! assert (isempty(t{2}))
+%! [s, e, te, m, t] = regexp ('short test string', '\w*r\w*');
+%! assert (s, [1, 12]);
+%! assert (e, [5, 17]);
+%! assert (size (te), [1, 2]);
+%! assert (isempty (te{1}));
+%! assert (isempty (te{2}));
+%! assert (m{1}, 'short');
+%! assert (m{2}, 'string');
+%! assert (size (t), [1, 2]);
+%! assert (isempty (t{1}));
+%! assert (isempty (t{2}));
 
 %!test
-%! [s, e, te, m, t] = regexp('short test string','\w*r\w*','once');
-%! assert (s,1)
-%! assert (e,5)
-%! assert (isempty(te))
-%! assert (m,'short')
-%! assert (isempty(t))
+%! [s, e, te, m, t] = regexp ('short test string', '\w*r\w*', 'once');
+%! assert (s, 1);
+%! assert (e, 5);
+%! assert (isempty (te));
+%! assert (m, 'short');
+%! assert (isempty (t));
 
 %!test
-%! [m, te, e, s, t] = regexp('short test string','\w*r\w*','once', 'match', 'tokenExtents', 'end', 'start', 'tokens');
-%! assert (s,1)
-%! assert (e,5)
-%! assert (isempty(te))
-%! assert (m,'short')
-%! assert (isempty(t))
+%! [m, te, e, s, t] = regexp ('short test string', '\w*r\w*', 'once', 'match', 'tokenExtents', 'end', 'start', 'tokens');
+%! assert (s, 1);
+%! assert (e, 5);
+%! assert (isempty (te));
+%! assert (m, 'short');
+%! assert (isempty (t));
 
 %!test
-%! [s, e, te, m, t, nm] = regexp('short test string','(?<word1>\w*t)\s*(?<word2>\w*t)');
-%! assert (s,1)
-%! assert (e,10)
-%! assert (size(te), [1,1])
-%! assert (te{1}, [1 5; 7, 10])
-%! assert (m{1},'short test')
-%! assert (size(t),[1,1])
-%! assert (t{1}{1},'short')
-%! assert (t{1}{2},'test')
-%! assert (size(nm), [1,1])
-%! assert (!isempty(fieldnames(nm)))
-%! assert (sort(fieldnames(nm)),{'word1';'word2'})
-%! assert (nm.word1,'short')
-%! assert (nm.word2,'test')
+%! [s, e, te, m, t, nm] = regexp ('short test string', '(?<word1>\w*t)\s*(?<word2>\w*t)');
+%! assert (s, 1);
+%! assert (e, 10);
+%! assert (size (te), [1, 1]);
+%! assert (te{1}, [1,5; 7,10]);
+%! assert (m{1}, 'short test');
+%! assert (size (t), [1, 1]);
+%! assert (t{1}{1}, 'short');
+%! assert (t{1}{2}, 'test');
+%! assert (size (nm), [1, 1]);
+%! assert (! isempty (fieldnames (nm)));
+%! assert (sort (fieldnames (nm)), {'word1';'word2'});
+%! assert (nm.word1, 'short');
+%! assert (nm.word2, 'test');
 
 %!test
-%! [nm, m, te, e, s, t] = regexp('short test string','(?<word1>\w*t)\s*(?<word2>\w*t)', 'names', 'match', 'tokenExtents', 'end', 'start', 'tokens');
-%! assert (s,1)
-%! assert (e,10)
-%! assert (size(te), [1,1])
-%! assert (te{1}, [1 5; 7, 10])
-%! assert (m{1},'short test')
-%! assert (size(t),[1,1])
-%! assert (t{1}{1},'short')
-%! assert (t{1}{2},'test')
-%! assert (size(nm), [1,1])
-%! assert (!isempty(fieldnames(nm)))
-%! assert (sort(fieldnames(nm)),{'word1';'word2'})
-%! assert (nm.word1,'short')
-%! assert (nm.word2,'test')
+%! [nm, m, te, e, s, t] = regexp ('short test string', '(?<word1>\w*t)\s*(?<word2>\w*t)', 'names', 'match', 'tokenExtents', 'end', 'start', 'tokens');
+%! assert (s, 1);
+%! assert (e, 10);
+%! assert (size (te), [1, 1]);
+%! assert (te{1}, [1,5; 7,10]);
+%! assert (m{1}, 'short test');
+%! assert (size (t), [1, 1]);
+%! assert (t{1}{1}, 'short');
+%! assert (t{1}{2}, 'test');
+%! assert (size (nm), [1, 1]);
+%! assert (!isempty (fieldnames (nm)));
+%! assert (sort (fieldnames (nm)), {'word1';'word2'});
+%! assert (nm.word1, 'short');
+%! assert (nm.word2, 'test');
 
 %!test
-%! [t, nm] = regexp("John Davis\nRogers, James",'(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)','tokens','names');
-%! assert (size(t), [1,2]);
-%! assert (t{1}{1},'John');
-%! assert (t{1}{2},'Davis');
-%! assert (t{2}{1},'Rogers');
-%! assert (t{2}{2},'James');
-%! assert (size(nm), [1,1]);
-%! assert (nm.first{1},'John');
-%! assert (nm.first{2},'James');
-%! assert (nm.last{1},'Davis');
-%! assert (nm.last{2},'Rogers');
+%! [t, nm] = regexp ("John Davis\nRogers, James", '(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)', 'tokens', 'names');
+%! assert (size (t), [1, 2]);
+%! assert (t{1}{1}, 'John');
+%! assert (t{1}{2}, 'Davis');
+%! assert (t{2}{1}, 'Rogers');
+%! assert (t{2}{2}, 'James');
+%! assert (size (nm), [1, 1]);
+%! assert (nm.first{1}, 'John');
+%! assert (nm.first{2}, 'James');
+%! assert (nm.last{1}, 'Davis');
+%! assert (nm.last{2}, 'Rogers');
 
 ## Tests for named tokens
 %!test
 %! # Parenthesis in named token (ie (int)) causes a problem
-%! assert (regexp('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
+%! assert (regexp ('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
 
 %!test
 %! ## Mix of named and unnamed tokens can cause segfault (bug #35683)
 %! str = "abcde";
 %! ptn = '(?<T1>a)(\w+)(?<T2>d\w+)';
 %! tokens = regexp (str, ptn, "names");
 %! assert (isstruct (tokens) && numel (tokens) == 1);
 %! assert (tokens.T1, "a");
 %! assert (tokens.T2, "de");
 
-%!assert(regexp("abc\nabc",'.'),[1:7])
-%!assert(regexp("abc\nabc",'.','dotall'),[1:7])
+%!assert (regexp ("abc\nabc", '.'), [1:7])
+%!assert (regexp ("abc\nabc", '.', 'dotall'), [1:7])
 %!test
-%! assert(regexp("abc\nabc",'(?s).'),[1:7])
-%! assert(regexp("abc\nabc",'.','dotexceptnewline'),[1,2,3,5,6,7])
-%! assert(regexp("abc\nabc",'(?-s).'),[1,2,3,5,6,7])
+%! assert (regexp ("abc\nabc", '(?s).'), [1:7]);
+%! assert (regexp ("abc\nabc", '.', 'dotexceptnewline'), [1,2,3,5,6,7]);
+%! assert (regexp ("abc\nabc", '(?-s).'), [1,2,3,5,6,7]);
 
-%!assert(regexp("caseCaSe",'case'),1)
-%!assert(regexp("caseCaSe",'case',"matchcase"),1)
-%!assert(regexp("caseCaSe",'case',"ignorecase"),[1,5])
+%!assert (regexp ("caseCaSe", 'case'), 1)
+%!assert (regexp ("caseCaSe", 'case', "matchcase"), 1)
+%!assert (regexp ("caseCaSe", 'case', "ignorecase"), [1,5])
 %!test
-%! assert(regexp("caseCaSe",'(?-i)case'),1)
-%! assert(regexp("caseCaSe",'(?i)case'),[1,5])
+%! assert (regexp ("caseCaSe", '(?-i)case'), 1);
+%! assert (regexp ("caseCaSe", '(?i)case'), [1, 5]);
 
-%!assert (regexp("abc\nabc",'c$'),7)
-%!assert (regexp("abc\nabc",'c$',"stringanchors"),7)
+%!assert (regexp ("abc\nabc", 'c$'), 7)
+%!assert (regexp ("abc\nabc", 'c$', "stringanchors"), 7)
 %!test
-%! assert (regexp("abc\nabc",'(?-m)c$'),7)
-%! assert (regexp("abc\nabc",'c$',"lineanchors"),[3,7])
-%! assert (regexp("abc\nabc",'(?m)c$'),[3,7])
+%! assert (regexp ("abc\nabc", '(?-m)c$'), 7);
+%! assert (regexp ("abc\nabc", 'c$',"lineanchors"), [3, 7]);
+%! assert (regexp ("abc\nabc", '(?m)c$'), [3,7]);
 
-%!assert (regexp("this word",'s w'),4)
-%!assert (regexp("this word",'s w','literalspacing'),4)
+%!assert (regexp ("this word", 's w'), 4)
+%!assert (regexp ("this word", 's w', 'literalspacing'), 4)
 %!test
-%! assert (regexp("this word",'(?-x)s w','literalspacing'),4)
-%! assert (regexp("this word",'s w','freespacing'),zeros(1,0))
-%! assert (regexp("this word",'(?x)s w'),zeros(1,0))
+%! assert (regexp ("this word", '(?-x)s w', 'literalspacing'), 4);
+%! assert (regexp ("this word", 's w', 'freespacing'), zeros (1,0));
+%! assert (regexp ("this word", '(?x)s w'), zeros (1,0));
 
-%!error regexp('string', 'tri', 'BadArg');
-%!error regexp('string');
+%!error regexp ('string', 'tri', 'BadArg')
+%!error regexp ('string')
 
-%!assert(regexp({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'},'-'),{6;[1,5,9];zeros(1,0)})
-%!assert(regexp({'asdfg-dfd','-dfd-dfd-','qasfdfdaq'},'-'),{6,[1,5,9],zeros(1,0)})
-%!assert(regexp({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'},{'-';'f';'q'}),{6;[3,7];[1,9]})
-%!assert(regexp('Strings',{'t','s'}),{2,7})
+%!assert (regexp ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, '-'), {6;[1,5,9];zeros(1,0)})
+%!assert (regexp ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, {'-';'f';'q'}), {6;[3,7];[1,9]})
+%!assert (regexp ('Strings', {'t','s'}), {2, 7})
 
 ## Test case for lookaround operators
 %!test
-%! assert(regexp('Iraq','q(?!u)'),4)
-%! assert(regexp('quit','q(?!u)'), zeros(1,0))
-%! assert(regexp('quit','q(?=u)','match'), {'q'})
-%! assert(regexp("quit",'q(?=u+)','match'), {'q'})
-%! assert(regexp("qit",'q(?=u+)','match'), cell(1,0))
-%! assert(regexp("qit",'q(?=u*)','match'), {'q'})
-%! assert(regexp('thingamabob','(?<=a)b'), 9)
+%! assert (regexp ('Iraq', 'q(?!u)'), 4);
+%! assert (regexp ('quit', 'q(?!u)'), zeros (1, 0));
+%! assert (regexp ('quit', 'q(?=u)' , 'match'), {'q'});
+%! assert (regexp ("quit", 'q(?=u+)', 'match'), {'q'});
+%! assert (regexp ("qit",  'q(?=u+)', 'match'), cell (1, 0));
+%! assert (regexp ("qit",  'q(?=u*)', 'match'), {'q'});
+%! assert (regexp ('thingamabob', '(?<=a)b'), 9);
 
 ## Tests for split option.
 %!shared str
 %! str = "foo bar foo";
 %!test
 %! [a, b] = regexp (str, "f..", "match", "split");
 %! assert (a, {"foo", "foo"});
 %! assert (b, {"", " bar ", ""});
@@ -841,18 +839,18 @@ Alternatively, use (?x) in the pattern.\
 %! assert (a, "foo");
 %! assert (b, {"", " bar foo"});
 %!test
 %! [a, b] = regexp (str, "fx.", "match", "split");
 %! assert (a, cell (1, 0));
 %! assert (b, {"foo bar foo"});
 %!test
 %! [a, b] = regexp (str, "fx.", "match", "split", "once");
-%! assert (a, "");
-%! assert (b, "foo bar foo")
+%! assert (a, "");;
+%! assert (b, "foo bar foo");
 
 %!shared str
 %! str = "foo bar";
 %!test
 %! [a, b] = regexp (str, "f..", "match", "split");
 %! assert (a, {"foo"});
 %! assert (b, {"", " bar"});
 %!test
@@ -862,17 +860,16 @@ Alternatively, use (?x) in the pattern.\
 %!test
 %! [a, b] = regexp (str, "x", "match", "split");
 %! assert (a, cell (1, 0));
 %! assert (b, {"foo bar"});
 %!test
 %! [a, b] = regexp (str, "[o]+", "match", "split");
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
-
 */
 
 DEFUN_DLD (regexpi, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 \n\
 Case insensitive regular expression string matching.  Search for @var{pat} in\n\
@@ -892,149 +889,146 @@ syntax of the search pattern.\n\
     retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexpi", true);
   else
     retval = octregexp (args, nargout, "regexpi", true);
 
   return retval;
 }
 
 /*
-
-## seg-fault test
-%!assert(regexpi("abcde","."),[1,2,3,4,5])
+## segfault test
+%!assert (regexpi ("abcde", "."), [1,2,3,4,5])
 
 ## Check that anchoring of pattern works correctly
-%!assert(regexpi('abcabc','^ABC'),1);
-%!assert(regexpi('abcabc','ABC$'),4);
-%!assert(regexpi('abcabc','^ABC$'),zeros(1,0));
+%!assert (regexpi ('abcabc', '^ABC'), 1)
+%!assert (regexpi ('abcabc', 'ABC$'), 4)
+%!assert (regexpi ('abcabc', '^ABC$'), zeros (1,0))
 
 %!test
-%! [s, e, te, m, t] = regexpi(' No Match ', 'f(.*)uck');
-%! assert (s,zeros(1,0))
-%! assert (e,zeros(1,0))
-%! assert (te,cell(1,0))
-%! assert (m, cell(1,0))
-%! assert (t, cell(1,0))
+%! [s, e, te, m, t] = regexpi (' No Match ', 'f(.*)uck');
+%! assert (s, zeros (1,0));
+%! assert (e, zeros (1,0));
+%! assert (te, cell (1,0));
+%! assert (m, cell (1,0));
+%! assert (t, cell (1,0));
 
 %!test
-%! [s, e, te, m, t] = regexpi(' FiRetrUck ', 'f(.*)uck');
-%! assert (s,2)
-%! assert (e,10)
-%! assert (te{1},[3,7])
-%! assert (m{1}, 'FiRetrUck')
-%! assert (t{1}{1}, 'iRetr')
+%! [s, e, te, m, t] = regexpi (' FiRetrUck ', 'f(.*)uck');
+%! assert (s, 2);
+%! assert (e, 10);
+%! assert (te{1}, [3, 7]);
+%! assert (m{1}, 'FiRetrUck');
+%! assert (t{1}{1}, 'iRetr');
 
 %!test
-%! [s, e, te, m, t] = regexpi(' firetruck ', 'f(.*)uck');
-%! assert (s,2)
-%! assert (e,10)
-%! assert (te{1},[3,7])
-%! assert (m{1}, 'firetruck')
-%! assert (t{1}{1}, 'iretr')
+%! [s, e, te, m, t] = regexpi (' firetruck ', 'f(.*)uck');
+%! assert (s, 2);
+%! assert (e, 10);
+%! assert (te{1}, [3, 7]);
+%! assert (m{1}, 'firetruck');
+%! assert (t{1}{1}, 'iretr');
 
 %!test
-%! [s, e, te, m, t] = regexpi('ShoRt Test String','\w*r\w*');
-%! assert (s,[1,12])
-%! assert (e,[5,17])
-%! assert (size(te), [1,2])
-%! assert (isempty(te{1}))
-%! assert (isempty(te{2}))
-%! assert (m{1},'ShoRt')
-%! assert (m{2},'String')
-%! assert (size(t), [1,2])
-%! assert (isempty(t{1}))
-%! assert (isempty(t{2}))
+%! [s, e, te, m, t] = regexpi ('ShoRt Test String', '\w*r\w*');
+%! assert (s, [1, 12]);
+%! assert (e, [5, 17]);
+%! assert (size (te), [1, 2]);
+%! assert (isempty (te{1}));
+%! assert (isempty (te{2}));
+%! assert (m{1}, 'ShoRt');
+%! assert (m{2}, 'String');
+%! assert (size (t), [1, 2]);
+%! assert (isempty (t{1}));
+%! assert (isempty (t{2}));
 
 %!test
-%! [s, e, te, m, t] = regexpi('ShoRt Test String','\w*r\w*','once');
-%! assert (s,1)
-%! assert (e,5)
-%! assert (isempty(te))
-%! assert (m,'ShoRt')
-%! assert (isempty(t))
+%! [s, e, te, m, t] = regexpi ('ShoRt Test String', '\w*r\w*', 'once');
+%! assert (s, 1);
+%! assert (e, 5);
+%! assert (isempty (te));
+%! assert (m, 'ShoRt');
+%! assert (isempty (t));
 
 %!test
-%! [m, te, e, s, t] = regexpi('ShoRt Test String','\w*r\w*','once', 'match', 'tokenExtents', 'end', 'start', 'tokens');
-%! assert (s,1)
-%! assert (e,5)
-%! assert (isempty(te))
-%! assert (m,'ShoRt')
-%! assert (isempty(t))
+%! [m, te, e, s, t] = regexpi ('ShoRt Test String', '\w*r\w*', 'once', 'match', 'tokenExtents', 'end', 'start', 'tokens');
+%! assert (s, 1);
+%! assert (e, 5);
+%! assert (isempty (te));
+%! assert (m, 'ShoRt');
+%! assert (isempty (t));
 
 %!test
-%! [s, e, te, m, t, nm] = regexpi('ShoRt Test String','(?<word1>\w*t)\s*(?<word2>\w*t)');
-%! assert (s,1)
-%! assert (e,10)
-%! assert (size(te), [1,1])
-%! assert (te{1}, [1 5; 7, 10])
-%! assert (m{1},'ShoRt Test')
-%! assert (size(t),[1,1])
-%! assert (t{1}{1},'ShoRt')
-%! assert (t{1}{2},'Test')
-%! assert (size(nm), [1,1])
-%! assert (!isempty(fieldnames(nm)))
-%! assert (sort(fieldnames(nm)),{'word1';'word2'})
-%! assert (nm.word1,'ShoRt')
-%! assert (nm.word2,'Test')
+%! [s, e, te, m, t, nm] = regexpi ('ShoRt Test String', '(?<word1>\w*t)\s*(?<word2>\w*t)');
+%! assert (s, 1);
+%! assert (e, 10);
+%! assert (size (te), [1, 1]);
+%! assert (te{1}, [1,5; 7,10]);
+%! assert (m{1}, 'ShoRt Test');
+%! assert (size (t), [1, 1]);
+%! assert (t{1}{1}, 'ShoRt');
+%! assert (t{1}{2}, 'Test');
+%! assert (size (nm), [1, 1]);
+%! assert (! isempty (fieldnames (nm)));
+%! assert (sort (fieldnames (nm)), {'word1';'word2'});
+%! assert (nm.word1, 'ShoRt');
+%! assert (nm.word2, 'Test');
 
 %!test
-%! [nm, m, te, e, s, t] = regexpi('ShoRt Test String','(?<word1>\w*t)\s*(?<word2>\w*t)', 'names', 'match', 'tokenExtents', 'end', 'start', 'tokens');
-%! assert (s,1)
-%! assert (e,10)
-%! assert (size(te), [1,1])
-%! assert (te{1}, [1 5; 7, 10])
-%! assert (m{1},'ShoRt Test')
-%! assert (size(t),[1,1])
-%! assert (t{1}{1},'ShoRt')
-%! assert (t{1}{2},'Test')
-%! assert (size(nm), [1,1])
-%! assert (!isempty(fieldnames(nm)))
-%! assert (sort(fieldnames(nm)),{'word1';'word2'})
-%! assert (nm.word1,'ShoRt')
-%! assert (nm.word2,'Test')
+%! [nm, m, te, e, s, t] = regexpi ('ShoRt Test String', '(?<word1>\w*t)\s*(?<word2>\w*t)', 'names', 'match', 'tokenExtents', 'end', 'start', 'tokens');
+%! assert (s, 1);
+%! assert (e, 10);
+%! assert (size (te), [1, 1]);
+%! assert (te{1}, [1,5; 7,10]);
+%! assert (m{1}, 'ShoRt Test');
+%! assert (size (t), [1, 1]);
+%! assert (t{1}{1}, 'ShoRt');
+%! assert (t{1}{2}, 'Test');
+%! assert (size (nm), [1, 1]);
+%! assert (!isempty (fieldnames (nm)));
+%! assert (sort (fieldnames (nm)), {'word1';'word2'});
+%! assert (nm.word1, 'ShoRt');
+%! assert (nm.word2, 'Test');
 
-%!assert(regexpi("abc\nabc",'.'),[1:7])
-%!assert(regexpi("abc\nabc",'.','dotall'),[1:7])
+%!assert (regexpi ("abc\nabc", '.'), [1:7])
+%!assert (regexpi ("abc\nabc", '.', 'dotall'), [1:7])
 %!test
-%! assert(regexpi("abc\nabc",'(?s).'),[1:7])
-%! assert(regexpi("abc\nabc",'.','dotexceptnewline'),[1,2,3,5,6,7])
-%! assert(regexpi("abc\nabc",'(?-s).'),[1,2,3,5,6,7])
+%! assert (regexpi ("abc\nabc", '(?s).'), [1:7]);
+%! assert (regexpi ("abc\nabc", '.', 'dotexceptnewline'), [1,2,3,5,6,7]);
+%! assert (regexpi ("abc\nabc", '(?-s).'), [1,2,3,5,6,7]);
 
-%!assert(regexpi("caseCaSe",'case'),[1,5])
-%!assert(regexpi("caseCaSe",'case',"matchcase"),1)
-%!assert(regexpi("caseCaSe",'case',"ignorecase"),[1,5])
+%!assert (regexpi ("caseCaSe", 'case'), [1, 5])
+%!assert (regexpi ("caseCaSe", 'case', "matchcase"), 1)
+%!assert (regexpi ("caseCaSe", 'case', "ignorecase"), [1, 5])
 %!test
-%! assert(regexpi("caseCaSe",'(?-i)case'),1)
-%! assert(regexpi("caseCaSe",'(?i)case'),[1,5])
+%! assert (regexpi ("caseCaSe", '(?-i)case'), 1);
+%! assert (regexpi ("caseCaSe", '(?i)case'), [1, 5]);
 
-%!assert (regexpi("abc\nabc",'C$'),7)
-%!assert (regexpi("abc\nabc",'C$',"stringanchors"),7)
+%!assert (regexpi ("abc\nabc", 'C$'), 7)
+%!assert (regexpi ("abc\nabc", 'C$', "stringanchors"), 7)
 %!test
-%! assert (regexpi("abc\nabc",'(?-m)C$'),7)
-%! assert (regexpi("abc\nabc",'C$',"lineanchors"),[3,7])
-%! assert (regexpi("abc\nabc",'(?m)C$'),[3,7])
+%! assert (regexpi ("abc\nabc", '(?-m)C$'), 7);
+%! assert (regexpi ("abc\nabc", 'C$', "lineanchors"), [3, 7]);
+%! assert (regexpi ("abc\nabc", '(?m)C$'), [3, 7]);
 
-%!assert (regexpi("this word",'S w'),4)
-%!assert (regexpi("this word",'S w','literalspacing'),4)
+%!assert (regexpi ("this word", 'S w'), 4)
+%!assert (regexpi ("this word", 'S w', 'literalspacing'), 4)
 %!test
-%! assert (regexpi("this word",'(?-x)S w','literalspacing'),4)
-%! assert (regexpi("this word",'S w','freespacing'),zeros(1,0))
-%! assert (regexpi("this word",'(?x)S w'),zeros(1,0))
-
-%!error regexpi('string', 'tri', 'BadArg');
-%!error regexpi('string');
+%! assert (regexpi ("this word", '(?-x)S w', 'literalspacing'), 4);
+%! assert (regexpi ("this word", 'S w', 'freespacing'), zeros (1,0));
+%! assert (regexpi ("this word", '(?x)S w'), zeros (1,0));
 
-%!assert(regexpi({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'},'-'),{6;[1,5,9];zeros(1,0)})
-%!assert(regexpi({'asdfg-dfd','-dfd-dfd-','qasfdfdaq'},'-'),{6,[1,5,9],zeros(1,0)})
-%!assert(regexpi({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'},{'-';'f';'q'}),{6;[3,7];[1,9]})
-%!assert(regexpi('Strings',{'t','s'}),{2,[1,7]})
+%!error regexpi ('string', 'tri', 'BadArg')
+%!error regexpi ('string')
 
+%!assert (regexpi ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, '-'), {6;[1,5,9];zeros(1, 0)})
+%!assert (regexpi ({'asdfg-dfd', '-dfd-dfd-', 'qasfdfdaq'}, '-'), {6, [1,5,9], zeros(1,0)})
+%!assert (regexpi ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, {'-';'f';'q'}), {6;[3,7];[1,9]})
+%!assert (regexpi ('Strings', {'t', 's'}), {2, [1, 7]})
 */
 
-
 static octave_value
 octregexprep (const octave_value_list &args, const std::string &who)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   // Make sure we have string, pattern, replacement
@@ -1191,61 +1185,59 @@ This option is present for compatibility
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
 /*
 %!test  # Replace with empty
 %! xml = '<!-- This is some XML --> <tag v="hello">some stuff<!-- sample tag--></tag>';
-%! t = regexprep(xml,'<[!?][^>]*>','');
-%! assert(t,' <tag v="hello">some stuff</tag>')
+%! t = regexprep (xml, '<[!?][^>]*>', '');
+%! assert (t, ' <tag v="hello">some stuff</tag>');
 
 %!test  # Replace with non-empty
 %! xml = '<!-- This is some XML --> <tag v="hello">some stuff<!-- sample tag--></tag>';
-%! t = regexprep(xml,'<[!?][^>]*>','?');
-%! assert(t,'? <tag v="hello">some stuff?</tag>')
+%! t = regexprep (xml, '<[!?][^>]*>', '?');
+%! assert (t, '? <tag v="hello">some stuff?</tag>');
 
 %!test  # Check that 'tokenize' is ignored
 %! xml = '<!-- This is some XML --> <tag v="hello">some stuff<!-- sample tag--></tag>';
-%! t = regexprep(xml,'<[!?][^>]*>','','tokenize');
-%! assert(t,' <tag v="hello">some stuff</tag>')
+%! t = regexprep (xml, '<[!?][^>]*>', '', 'tokenize');
+%! assert (t, ' <tag v="hello">some stuff</tag>');
 
 ## Test capture replacement
 %!test
 %! data = "Bob Smith\nDavid Hollerith\nSam Jenkins";
 %! result = "Smith, Bob\nHollerith, David\nJenkins, Sam";
-%! t = regexprep(data,'(?m)^(\w+)\s+(\w+)$','$2, $1');
-%! assert(t,result)
+%! t = regexprep (data, '(?m)^(\w+)\s+(\w+)$', '$2, $1');
+%! assert (t, result);
 
 ## Return the original if no match
-%!assert(regexprep('hello','world','earth'),'hello')
+%!assert (regexprep ('hello', 'world', 'earth'), 'hello')
 
 ## Test a general replacement
-%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_"), "a_b_c_d_e_f_g");
+%!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_"), "a_b_c_d_e_f_g")
 
 ## Make sure it works at the beginning and end
-%!assert(regexprep("a[b]c{d}e-f=g", "a", "_"), "_[b]c{d}e-f=g");
-%!assert(regexprep("a[b]c{d}e-f=g", "g", "_"), "a[b]c{d}e-f=_");
+%!assert (regexprep ("a[b]c{d}e-f=g", "a", "_"), "_[b]c{d}e-f=g")
+%!assert (regexprep ("a[b]c{d}e-f=g", "g", "_"), "a[b]c{d}e-f=_")
 
 ## Options
-%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_", "once"), "a_b]c{d}e-f=g");
-%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "ignorecase"), "a_b_c_d_e_f_g");
+%!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_", "once"), "a_b]c{d}e-f=g")
+%!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "ignorecase"), "a_b_c_d_e_f_g")
 
 ## Option combinations
-%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "once", "ignorecase"), "a_b]c{d}e-f=g");
+%!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "once", "ignorecase"), "a_b]c{d}e-f=g")
 
 ## End conditions on replacement
-%!assert(regexprep("abc","(b)",".$1"),"a.bc");
-%!assert(regexprep("abc","(b)","$1"),"abc");
-%!assert(regexprep("abc","(b)","$1."),"ab.c");
-%!assert(regexprep("abc","(b)","$1.."),"ab..c");
+%!assert (regexprep ("abc", "(b)", ".$1"), "a.bc");
+%!assert (regexprep ("abc", "(b)", "$1"), "abc");
+%!assert (regexprep ("abc", "(b)", "$1."), "ab.c");
+%!assert (regexprep ("abc", "(b)", "$1.."), "ab..c");
 
 ## Test cell array arguments
-%!assert(regexprep("abc",{"b","a"},"?"),"??c")
-%!assert(regexprep({"abc","cba"},"b","?"),{"a?c","c?a"})
-%!assert(regexprep({"abc","cba"},{"b","a"},{"?","!"}),{"!?c","c?!"})
+%!assert (regexprep ("abc", {"b","a"}, "?"), "??c")
+%!assert (regexprep ({"abc","cba"}, "b", "?"), {"a?c","c?a"})
+%!assert (regexprep ({"abc","cba"}, {"b","a"}, {"?","!"}), {"!?c","c?!"})
 
 # Nasty lookbehind expression
-%!test
-%! assert(regexprep('x^(-1)+y(-1)+z(-1)=0','(?<=[a-z]+)\(\-[1-9]*\)','_minus1'),'x^(-1)+y_minus1+z_minus1=0')
-
+%!assert (regexprep ('x^(-1)+y(-1)+z(-1)=0', '(?<=[a-z]+)\(\-[1-9]*\)', '_minus1'),'x^(-1)+y_minus1+z_minus1=0')
 */
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -270,33 +270,31 @@ Riccati equations in control (see @code{
             }
         }
     }
 
   return retval;
 }
 
 /*
-
 %!test
 %! a = [1, 2, 3; 4, 5, 9; 7, 8, 6];
 %! [u, s] = schur (a);
-%! assert(u' * a * u, s, sqrt (eps));
+%! assert (u' * a * u, s, sqrt (eps));
 
 %!test
-%! a = single([1, 2, 3; 4, 5, 9; 7, 8, 6]);
+%! a = single ([1, 2, 3; 4, 5, 9; 7, 8, 6]);
 %! [u, s] = schur (a);
-%! assert(u' * a * u, s, sqrt (eps('single')));
+%! assert (u' * a * u, s, sqrt (eps ("single")));
 
 %!test
-%! fail("schur ([1, 2; 3, 4], 2)","warning");
+%! fail("schur ([1, 2; 3, 4], 2)", "warning");
 
-%!error <Invalid call to schur> schur ();
-%!error schur ([1, 2, 3; 4, 5, 6]);
-
+%!error schur ()
+%!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
 DEFUN_DLD (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
 Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a complex,\n\
 upper triangular Schur@tie{}form @var{T}.\n\
 \n\
@@ -356,29 +354,28 @@ Note also that @var{U} and @var{T} are n
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! A = [1, 1, 1, 2; 1, 2, 1, 1; 1, 1, 3, 1; -2, 1, 1, 1];
 %! [u, t] = schur (A);
 %! [U, T] = rsf2csf (u, t);
-%! assert (norm (u * t * u' - U * T * U'), 0, 1e-12)
-%! assert (norm (A - U * T * U'), 0, 1e-12)
+%! assert (norm (u * t * u' - U * T * U'), 0, 1e-12);
+%! assert (norm (A - U * T * U'), 0, 1e-12);
 
 %!test
 %! A = rand (10);
 %! [u, t] = schur (A);
 %! [U, T] = rsf2csf (u, t);
-%! assert (norm (tril (T, -1)), 0)
-%! assert (norm (U * U'), 1, 1e-14)
+%! assert (norm (tril (T, -1)), 0);
+%! assert (norm (U * U'), 1, 1e-14);
 
 %!test
 %! A = [0, 1;-1, 0];
 %! [u, t] = schur (A);
 %! [U, T] = rsf2csf (u,t);
-%! assert (U * T * U', A, 1e-14)
+%! assert (U * T * U', A, 1e-14);
 */
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -173,17 +173,16 @@ running time.\n\
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
 }
 
 /*
-
 %!test
 %! old_vals = spparms ();  # save state
 %! spparms ("defaults");
 %! vals = spparms ();
 %! assert (vals, [0 1 1 0 3 3 0.5 1.0 1.0 0.1 0.5 1.0 0.001]');
 %! [keys, vals] = spparms ();
 %! assert (rows (keys), 13);
 %! assert (keys(2,:), "ths_rel");
@@ -191,18 +190,19 @@ running time.\n\
 %! spparms ([3 2 1]);
 %! assert (spparms ()(1:3), [3, 2, 1]');
 %! assert (spparms ("ths_rel"), 2);
 %! spparms ("exact_d", 5);
 %! assert (spparms ("exact_d"), 5);
 %! spparms (old_vals);     # restore state
 
 %% Test input validation
-%!error (spparms (1, 2, 3))
-%!error ([x, y, z] = spparms ())
-%!error (spparms ("UNKNOWN_KEY"))
-%!error (spparms ({1, 2, 3}))
-%!error (spparms (ones (14, 1)))
-%!error (spparms (1, 1))
-%!error (spparms ("ths_rel", "hello"))
-%!error (spparms ("UNKNOWN_KEY", 1))
-
+%!error <too many input arguments> spparms (1, 2, 3)
+%!error <too many output arguments> [x, y, z] = spparms ()
+%!error <KEY not recognized> spparms ("UNKNOWN_KEY")
+%!#error <input must be a string> spparms ({1, 2, 3})
+%!error spparms ({1, 2, 3})
+%!error <too many elements in vector VALS> spparms (ones (14, 1))
+%!error <first argument must be a string> spparms (1, 1)
+%!#error <second argument must be a real scalar> spparms ("ths_rel", "hello")
+%!error spparms ("ths_rel", "hello")
+%!error <KEY not found> spparms ("UNKNOWN_KEY", 1)
 */
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -255,25 +255,22 @@ Mathematics, Manchester, England, Januar
       octave_value s = retval(0);
       retval(1) = xfrobnorm (s*s - arg) / xfrobnorm (arg);
     }
 
   return retval;
 }
 
 /*
-
 %!assert (sqrtm (2*ones (2)), ones (2), 3*eps)
 
 ## The following two tests are from the reference in the docstring above.
-
 %!test
 %! x = [0 1; 0 0];
-%! assert (any (isnan (sqrtm (x))(:) ))
+%! assert (any (isnan (sqrtm (x))(:)));
 
 %!test
-%! x = eye (4); x(2,2) = x(3,3) = 2^-26; x(1,4) = 1;
-%! z = eye (4); z(2,2) = z(3,3) = 2^-13; z(1,4) = 0.5;
-%! [y, err] = sqrtm(x);
-%! assert (y, z)
-%! assert (err, 0)   ## Yes, this one has to hold exactly
-
+%! x = eye (4);  x(2,2) = x(3,3) = 2^-26;  x(1,4) = 1;
+%! z = eye (4);  z(2,2) = z(3,3) = 2^-13;  z(1,4) = 0.5;
+%! [y, err] = sqrtm (x);
+%! assert (y, z);
+%! assert (err, 0);   ## Yes, this one has to hold exactly
 */
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -345,20 +345,19 @@ risk of using @code{eval} on unknown dat
   else
     retval = NDArray (args(0).dims (), octave_NaN);
 
 
   return retval;
 }
 
 /*
-
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
-%!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i]);
+%!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i])
 %!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double ("1,222.5"), 1222.5)
 %!assert (str2double ("i"), i)
 %!assert (str2double ("2j"), 2i)
 %!assert (str2double ("2 + j"), 2+j)
 %!assert (str2double ("i*2 + 3"), 3+2i)
 %!assert (str2double (".5*i + 3.5"), 3.5+0.5i)
 %!assert (str2double ("1e-3 + i*.25"), 1e-3 + 0.25i)
@@ -373,10 +372,9 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
 %!assert (str2double (zeros(3,1,2)), NaN (3,1,2))
-
 */
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -242,27 +242,25 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!error strfind ();
-%!error strfind ("foo", "bar", 1);
-%!error strfind ("foo", 100);
-%!error strfind (100, "foo");
+%!assert (strfind ("abababa", "aba"), [1, 3, 5])
+%!assert (strfind ("abababa", "aba", "overlaps", false), [1, 5])
+%!assert (strfind ({"abababa", "bla", "bla"}, "a"), {[1, 3, 5, 7], 3, 3})
+%!assert (strfind ("Linux _is_ user-friendly. It just isn't ignorant-friendly or idiot-friendly.", "friendly"), [17, 50, 68])
 
-%!assert (strfind ("abababa", "aba"), [1, 3, 5]);
-%!assert (strfind ("abababa", "aba", "overlaps", false), [1, 5]);
-%!assert (strfind ({"abababa", "bla", "bla"}, "a"), {[1, 3, 5, 7], 3, 3});
-%!assert (strfind ("Linux _is_ user-friendly. It just isn't ignorant-friendly or idiot-friendly.", "friendly"), [17, 50, 68]);
-
+%!error strfind ()
+%!error strfind ("foo", "bar", 1)
+%!error <PATTERN must be a string> strfind ("foo", 100)
+%!error <first argument must be a string> strfind (100, "foo")
 */
 
 static Array<char>
 qs_replace (const Array<char>& str, const Array<char>& pat,
             const Array<char>& rep,
             const octave_idx_type table[TABSIZE],
             bool overlaps = true)
 {
@@ -402,19 +400,16 @@ done for each element and a cell array i
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(strcmp (strrep ("This is a test string", "is", "&%$"),
-%! "Th&%$ &%$ a test string"));
-%!assert(strrep ("abababc", "abab", "xyz"), "xyzxyzc");
-%!assert(strrep ("abababc", "abab", "xyz", "overlaps", false), "xyzabc");
+%!assert (strrep ("This is a test string", "is", "&%$"),
+%!                "Th&%$ &%$ a test string")
+%!assert (strrep ("abababc", "abab", "xyz"), "xyzxyzc")
+%!assert (strrep ("abababc", "abab", "xyz", "overlaps", false), "xyzabc")
 
-%!error strrep ();
-
-%!error strrep ("foo", "bar", 3, 4);
-
+%!error strrep ()
+%!error strrep ("foo", "bar", 3, 4)
 */
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -118,61 +118,58 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
           retval = idx;
         }
     }
 
   return retval;
 }
 
 /*
-
-# Test input validation
-%!error <sub2ind: dimension vector > sub2ind([10 10.5], 1, 1);
-%!error <subscript indices > sub2ind([10 10], 1.5, 1);
-%!error <subscript indices > sub2ind([10 10], 1, 1.5);
-
-# Test evaluation
-%!shared s1, s2, s3, in
-%! s1 = [   1   1   1   1 ;   2   2   2   2 ];
-%! s2 = [   1   1   2   2 ;   1   1   2   2 ];
-%! s3 = [   1   2   1   2 ;   1   2   1   2 ];
-%! in = [   1 101  11 111 ;   2 102  12 112 ];
-%!assert (sub2ind([10 10 10], s1, s2, s3), in);
-%!shared
+## Test evaluation
+%!test
+%! s1 = [ 1   1   1   1 ; 2   2   2   2 ];
+%! s2 = [ 1   1   2   2 ; 1   1   2   2 ];
+%! s3 = [ 1   2   1   2 ; 1   2   1   2 ];
+%! in = [ 1 101  11 111 ; 2 102  12 112 ];
+%! assert (sub2ind ([10 10 10], s1, s2, s3), in);
 
 # Test low index
-%!assert (sub2ind([10 10 10], 1, 1, 1), 1);
-%!error <subscript indices > sub2ind([10 10 10], 0, 1, 1);
-%!error <subscript indices > sub2ind([10 10 10], 1, 0, 1);
-%!error <subscript indices > sub2ind([10 10 10], 1, 1, 0);
+%!assert (sub2ind ([10 10 10], 1, 1, 1), 1)
+%!error <subscript indices> sub2ind ([10 10 10], 0, 1, 1)
+%!error <subscript indices> sub2ind ([10 10 10], 1, 0, 1)
+%!error <subscript indices> sub2ind ([10 10 10], 1, 1, 0)
 
 # Test high index
-%!assert (sub2ind([10 10 10], 10, 10, 10), 1000);
-%!error <sub2ind: index out of range> sub2ind([10 10 10], 11, 10, 10);
-%!error <sub2ind: index out of range> sub2ind([10 10 10], 10, 11, 10);
-%!error <sub2ind: index out of range> sub2ind([10 10 10], 10, 10, 11);
+%!assert (sub2ind ([10 10 10], 10, 10, 10), 1000)
+%!error <index out of range> sub2ind ([10 10 10], 11, 10, 10)
+%!error <index out of range> sub2ind ([10 10 10], 10, 11, 10)
+%!error <index out of range> sub2ind ([10 10 10], 10, 10, 11)
 
 # Test high index in the trailing dimensions
-%!assert (sub2ind([10, 1], 2, 1, 1), 2);
-%!error <sub2ind: index out of range> sub2ind([10, 1], 1, 2, 1);
-%!error <sub2ind: index out of range> sub2ind([10, 1], 1, 1, 2);
-%!assert (sub2ind([10 10], 2, 2, 1), 12);
-%!error <sub2ind: index out of range> sub2ind([10 10], 2, 1, 2);
-%!error <sub2ind: index out of range> sub2ind([10 10], 1, 2, 2);
+%!assert (sub2ind ([10, 1], 2, 1, 1), 2)
+%!error <index out of range> sub2ind ([10, 1], 1, 2, 1)
+%!error <index out of range> sub2ind ([10, 1], 1, 1, 2)
+%!assert (sub2ind ([10 10], 2, 2, 1), 12)
+%!error <index out of range> sub2ind ([10 10], 2, 1, 2)
+%!error <index out of range> sub2ind ([10 10], 1, 2, 2)
 
 # Test handling of empty arguments
-%!assert (sub2ind([10 10], zeros(0,0), zeros(0,0)), zeros(0,0));
-%!assert (sub2ind([10 10], zeros(2,0), zeros(2,0)), zeros(2,0));
-%!assert (sub2ind([10 10], zeros(0,2), zeros(0,2)), zeros(0,2));
-%!error <sub2ind: all subscripts .* same size> sub2ind([10 10 10], zeros(0,2), zeros(2,0));
+%!assert (sub2ind ([10 10], zeros (0,0), zeros (0,0)), zeros (0,0))
+%!assert (sub2ind ([10 10], zeros (2,0), zeros (2,0)), zeros (2,0))
+%!assert (sub2ind ([10 10], zeros (0,2), zeros (0,2)), zeros (0,2))
+%!error <all subscripts .* same size> sub2ind ([10 10 10], zeros (0,2), zeros (2,0))
 
 # Test handling of arguments of different size
-%!error <sub2ind: all subscripts .* same size> sub2ind([10 10], ones(1,2), ones(1,3));
-%!error <sub2ind: all subscripts .* same size> sub2ind([10 10], ones(1,2), ones(2,1));
+%!error <all subscripts .* same size> sub2ind ([10 10], ones (1,2), ones (1,3))
+%!error <all subscripts .* same size> sub2ind ([10 10], ones (1,2), ones (2,1))
 
+## Test input validation
+%!error <dimension vector> sub2ind ([10 10.5], 1, 1)
+%!error <subscript indices> sub2ind ([10 10], 1.5, 1)
+%!error <subscript indices> sub2ind ([10 10], 1, 1.5)
 */
 
 DEFUN_DLD (ind2sub, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
 Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -320,18 +320,17 @@ decomposition, eliminating the unnecessa
             }
         }
     }
 
   return retval;
 }
 
 /*
-
-%!assert(svd ([1, 2; 2, 1]), [3; 1], sqrt (eps));
+%!assert (svd ([1, 2; 2, 1]), [3; 1], sqrt (eps))
 
 %!test
 %! [u, s, v] = svd ([1, 2; 2, 1]);
 %! x = 1 / sqrt (2);
 %! assert (u, [-x, -x; -x, x], sqrt (eps));
 %! assert (s, [3, 0; 0, 1], sqrt (eps));
 %! assert (v, [-x, x; -x, -x], sqrt (eps));
 
@@ -350,63 +349,62 @@ decomposition, eliminating the unnecessa
 %! [u, s, v] = svd (a, 1);
 %! assert (u * s * v', a, sqrt (eps));
 
 %!test
 %! a = [1, 2; 3, 4; 5, 6];
 %! [u, s, v] = svd (a, 1);
 %! assert (u * s * v', a, sqrt (eps));
 
-%!assert(svd (single([1, 2; 2, 1])), single([3; 1]), sqrt (eps('single')));
+%!assert (svd (single ([1, 2; 2, 1])), single ([3; 1]), sqrt (eps ("single")))
 
 %!test
-%! [u, s, v] = svd (single([1, 2; 2, 1]));
+%! [u, s, v] = svd (single ([1, 2; 2, 1]));
 %! x = single (1 / sqrt (2));
-%! assert (u, [-x, -x; -x, x], sqrt (eps('single')));
-%! assert (s, single([3, 0; 0, 1]), sqrt (eps('single')));
-%! assert (v, [-x, x; -x, -x], sqrt (eps('single')));
+%! assert (u, [-x, -x; -x, x], sqrt (eps ("single")));
+%! assert (s, single ([3, 0; 0, 1]), sqrt (eps ("single")));
+%! assert (v, [-x, x; -x, -x], sqrt (eps ("single")));
 
 %!test
-%! a = single([1, 2, 3; 4, 5, 6]);
+%! a = single ([1, 2, 3; 4, 5, 6]);
 %! [u, s, v] = svd (a);
-%! assert (u * s * v', a, sqrt (eps('single')));
+%! assert (u * s * v', a, sqrt (eps ("single")));
 
 %!test
-%! a = single([1, 2; 3, 4; 5, 6]);
+%! a = single ([1, 2; 3, 4; 5, 6]);
 %! [u, s, v] = svd (a);
-%! assert (u * s * v', a, sqrt (eps('single')));
+%! assert (u * s * v', a, sqrt (eps ("single")));
 
 %!test
-%! a = single([1, 2, 3; 4, 5, 6]);
+%! a = single ([1, 2, 3; 4, 5, 6]);
 %! [u, s, v] = svd (a, 1);
-%! assert (u * s * v', a, sqrt (eps('single')));
+%! assert (u * s * v', a, sqrt (eps ("single")));
 
 %!test
-%! a = single([1, 2; 3, 4; 5, 6]);
+%! a = single ([1, 2; 3, 4; 5, 6]);
 %! [u, s, v] = svd (a, 1);
-%! assert (u * s * v', a, sqrt (eps('single')));
+%! assert (u * s * v', a, sqrt (eps ("single")));
 
 %!test
 %! a = zeros (0, 5);
 %! [u, s, v] = svd (a);
 %! assert (size (u), [0, 0]);
 %! assert (size (s), [0, 5]);
 %! assert (size (v), [5, 5]);
 
 %!test
 %! a = zeros (5, 0);
 %! [u, s, v] = svd (a, 1);
 %! assert (size (u), [5, 0]);
 %! assert (size (s), [0, 0]);
 %! assert (size (v), [0, 0]);
 
-%!error <Invalid call to svd> svd ();
-%!error <Invalid call to svd> svd ([1, 2; 4, 5], 2, 3);
-%!error <Invalid call to svd> [u, v] = svd ([1, 2; 3, 4]);
-
+%!error svd ()
+%!error svd ([1, 2; 4, 5], 2, 3)
+%!error [u, v] = svd ([1, 2; 3, 4])
 */
 
 DEFUN_DLD (svd_driver, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{val} =} svd_driver ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
 @deftypefnx {Loadable Function} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -204,17 +204,15 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
           retval = Sylvester (ca, cb, cc);
         }
     }
 
   return retval;
 }
 
 /*
-
-%!assert(syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12]), [-1/2, -2/3; -2/3, -1/2], sqrt (eps));
-%!assert(syl (single([1, 2; 3, 4]), single([5, 6; 7, 8]), single([9, 10; 11, 12])), single([-1/2, -2/3; -2/3, -1/2]), sqrt (eps('single')));
+%!assert (syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12]), [-1/2, -2/3; -2/3, -1/2], sqrt (eps))
+%!assert (syl (single ([1, 2; 3, 4]), single ([5, 6; 7, 8]), single ([9, 10; 11, 12])), single ([-1/2, -2/3; -2/3, -1/2]), sqrt (eps ("single")))
 
-%!error <Invalid call to syl> syl ();
-%!error <Invalid call to syl> syl (1, 2, 3, 4);
-%!error syl ([1, 2; 3, 4], [1, 2, 3; 4, 5, 6], [4, 3]);
-
+%!error syl ()
+%!error syl (1, 2, 3, 4)
+%!error <must be a square matrix> syl ([1, 2; 3, 4], [1, 2, 3; 4, 5, 6], [4, 3])
 */
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -117,19 +117,17 @@ value returned by @code{time} was 856163
     retval = octave_time ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(time () > 0);
-
+%!assert (time () > 0)
 */
 
 DEFUN_DLD (gmtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{tm_struct} =} gmtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to CUT (Coordinated Universal Time).\n\
 For example:\n\
@@ -166,35 +164,32 @@ gmtime (time ())\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! ts = gmtime (time ());
-%! assert((isstruct (ts)
-%! && isfield (ts, "usec")
-%! && isfield (ts, "year")
-%! && isfield (ts, "mon")
-%! && isfield (ts, "mday")
-%! && isfield (ts, "sec")
-%! && isfield (ts, "min")
-%! && isfield (ts, "wday")
-%! && isfield (ts, "hour")
-%! && isfield (ts, "isdst")
-%! && isfield (ts, "yday")));
+%! assert (isstruct (ts));
+%! assert (isfield (ts, "usec"));
+%! assert (isfield (ts, "year"));
+%! assert (isfield (ts, "mon"));
+%! assert (isfield (ts, "mday"));
+%! assert (isfield (ts, "sec"));
+%! assert (isfield (ts, "min"));
+%! assert (isfield (ts, "wday"));
+%! assert (isfield (ts, "hour"));
+%! assert (isfield (ts, "isdst"));
+%! assert (isfield (ts, "yday"));
 
-%!error <Invalid call to gmtime> gmtime ();
-
-%!error <Invalid call to gmtime> gmtime (1, 2);
-
+%!error gmtime ()
+%!error gmtime (1, 2)
 */
 
 DEFUN_DLD (localtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{tm_struct} =} localtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
@@ -230,35 +225,32 @@ localtime (time ())\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! ts = localtime (time ());
-%! assert((isstruct (ts)
-%! && isfield (ts, "usec")
-%! && isfield (ts, "year")
-%! && isfield (ts, "mon")
-%! && isfield (ts, "mday")
-%! && isfield (ts, "sec")
-%! && isfield (ts, "min")
-%! && isfield (ts, "wday")
-%! && isfield (ts, "hour")
-%! && isfield (ts, "isdst")
-%! && isfield (ts, "yday")));
+%! assert (isstruct (ts));
+%! assert (isfield (ts, "usec"));
+%! assert (isfield (ts, "year"));
+%! assert (isfield (ts, "mon"));
+%! assert (isfield (ts, "mday"));
+%! assert (isfield (ts, "sec"));
+%! assert (isfield (ts, "min"));
+%! assert (isfield (ts, "wday"));
+%! assert (isfield (ts, "hour"));
+%! assert (isfield (ts, "isdst"));
+%! assert (isfield (ts, "yday"));
 
-%!error <Invalid call to localtime> localtime ();
-
-%!error <Invalid call to localtime> localtime (1, 2);
-
+%!error localtime ()
+%!error localtime (1, 2)
 */
 
 DEFUN_DLD (mktime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
 of seconds since the epoch.  For example:\n\
 \n\
@@ -291,31 +283,28 @@ mktime (localtime (time ()))\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! t = time ();
-%! assert(fix (mktime (localtime (t))) == fix (t));
-
-%!error <Invalid call to mktime> mktime ();
+%! assert (fix (mktime (localtime (t))) == fix (t));
 
-%!error <Invalid call to mktime> mktime (1, 2, 3);
-
-%% These tests fail on systems with mktime functions of limited
-%% intelligence:
+## These tests fail on systems with mktime functions of limited
+## intelligence:
 %!assert (datestr (datenum (1969, 1, 1), 0), "01-Jan-1969 00:00:00")
 %!assert (datestr (datenum (1901, 1, 1), 0), "01-Jan-1901 00:00:00")
 %!assert (datestr (datenum (1795, 1, 1), 0), "01-Jan-1795 00:00:00")
 
+%!error mktime ()
+%!error mktime (1, 2, 3)
 */
 
 DEFUN_DLD (strftime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
 Format the time structure @var{tm_struct} in a flexible way using the\n\
 format string @var{fmt} that contains @samp{%} substitutions\n\
 similar to those in @code{printf}.  Except where noted, substituted\n\
@@ -493,27 +482,24 @@ Year (1970-).\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
+%!assert (ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ()))));
+%!assert (ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ()))));
+%!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))));
+%!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
+%!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
 
-%!assert((ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ())))
-%! && ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ())))
-%! && ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ())))
-%! && ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ())))
-%! && ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ())))));
-
-%!error <Invalid call to strftime> strftime ();
-
-%!error <Invalid call to strftime> strftime ("foo", localtime (time ()), 1);
-
+%!error strftime ()
+%!error strftime ("foo", localtime (time ()), 1)
 */
 
 DEFUN_DLD (strptime, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -402,27 +402,29 @@ DEFUN_DLD (triu, args, ,
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 See the documentation for the @code{tril} function (@pxref{tril}).\n\
 @end deftypefn")
 {
   return do_trilu ("triu", args);
 }
 
 /*
-
 %!test
 %! a = [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %!
 %! l0 = [1, 0, 0; 4, 5, 0; 7, 8, 9; 10, 11, 12];
 %! l1 = [1, 2, 0; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %! l2 = [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %! lm1 = [0, 0, 0; 4, 0, 0; 7, 8, 0; 10, 11, 12];
 %! lm2 = [0, 0, 0; 0, 0, 0; 7, 0, 0; 10, 11, 0];
 %! lm3 = [0, 0, 0; 0, 0, 0; 0, 0, 0; 10, 0, 0];
 %! lm4 = [0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0];
 %!
-%! assert((tril (a, -4) == lm4 && tril (a, -3) == lm3
-%! && tril (a, -2) == lm2 && tril (a, -1) == lm1
-%! && tril (a) == l0 && tril (a, 1) == l1 && tril (a, 2) == l2));
+%! assert (tril (a, -4), lm4); 
+%! assert (tril (a, -3), lm3);
+%! assert (tril (a, -2), lm2);
+%! assert (tril (a, -1), lm1);
+%! assert (tril (a), l0);
+%! assert (tril (a, 1), l1);
+%! assert (tril (a, 2), l2);
 
-%!error tril ();
-
+%!error tril ()
 */
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -171,16 +171,16 @@ points @code{(@var{xi}, @var{yi})}.  For
   return retval;
 }
 
 /*
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
 %! tri = [1, 2, 3];
-%!error (tsearch())
 %!assert (tsearch (x,y,tri,-1,-1), 1)
 %!assert (tsearch (x,y,tri, 1,-1), 1)
 %!assert (tsearch (x,y,tri,-1, 1), 1)
 %!assert (tsearch (x,y,tri,-1/3, -1/3), 1)
 %!assert (tsearch (x,y,tri, 1, 1), NaN)
 
+%!error tsearch ()
 */
