# HG changeset patch
# User Rik <rik@octave.org>
# Date 1459119001 25200
#      Sun Mar 27 15:50:01 2016 -0700
# Node ID f7f97d7e929435462c4e770f30396c934563b734
# Parent  a81c9a0a05e34f551644c8c0ee6b02352790d38e
doc: Wrap m-file docstrings to 79 characters + newline (80 total).

* isrecording.m, soundsc.m, delaunay3.m, cell2mat.m, cumtrapz.m, del2.m,
inputParser.m, interp1.m, interp3.m, narginchk.m, profile.m,
validateattributes.m, delaunayn.m, tsearchn.m, voronoin.m, brighten.m,
cmunique.m, colorcube.m, imfinfo.m, imshow.m, edit.m, orderfields.m, run.m,
warning_ids.m, ode23.m, ode45.m, odeget.m, integrate_adaptive.m, kahan.m,
ode_struct_value_check.m, runge_kutta_23.m, fminunc.m, fsolve.m, fzero.m,
pkg.m, build.m, specular.m, view.m, bar.m, barh.m, contour3.m, isosurface.m,
line.m, pie.m, pie3.m, quiver3.m, scatter.m, scatter3.m, stem3.m, stemleaf.m,
surfl.m, tetramesh.m, isfigure.m, mkpp.m, pchip.m, residue.m, splinefit.m,
rmpref.m, unique.m, eigs.m, ilu.m, factor.m, factorial.m, gallery.m, hankel.m,
histc.m, ols.m, finv.m, fpdf.m, kruskal_wallis_test.m, weekday.m:
Wrap m-file docstrings to 79 characters + newline (80 total).

diff --git a/scripts/audio/@audiorecorder/isrecording.m b/scripts/audio/@audiorecorder/isrecording.m
--- a/scripts/audio/@audiorecorder/isrecording.m
+++ b/scripts/audio/@audiorecorder/isrecording.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} isrecording (@var{recorder})
-## Return true if the audiorecorder object @var{recorder} is currently recording
-## audio and false otherwise.
+## Return true if the audiorecorder object @var{recorder} is currently
+## recording audio and false otherwise.
 ## @end deftypefn
 
 function result = isrecording (recorder)
 
   if (nargin != 1)
     print_usage ();
   endif
 
diff --git a/scripts/audio/soundsc.m b/scripts/audio/soundsc.m
--- a/scripts/audio/soundsc.m
+++ b/scripts/audio/soundsc.m
@@ -28,20 +28,20 @@
 ## mono or stereo audio, respectively.
 ##
 ## If @var{fs} is not given, a default sample rate of 8000 samples per second
 ## is used.
 ##
 ## The optional argument @var{nbits} specifies the bit depth to play to the
 ## audio device and defaults to 8 bits.
 ##
-## By default, @var{y} is automatically normalized to the range [-1, 1].  If the
-## range [@var{ymin}, @var{ymax}] is given, then elements of @var{y} that fall
-## within the range @var{ymin} @leq{} @var{y} @leq{} @var{ymax} are scaled to
-## the range [-1, 1] instead.
+## By default, @var{y} is automatically normalized to the range [-1, 1].  If
+## the range [@var{ymin}, @var{ymax}] is given, then elements of @var{y}
+## that fall within the range @var{ymin} @leq{} @var{y} @leq{} @var{ymax}
+## are scaled to the range [-1, 1] instead.
 ##
 ## For more control over audio playback, use the @code{audioplayer} class.
 ## @seealso{sound, record}
 ## @end deftypefn
 
 function soundsc (y, fs, nbits, yrange)
 
   if (nargin < 1 || nargin > 4)
diff --git a/scripts/deprecated/delaunay3.m b/scripts/deprecated/delaunay3.m
--- a/scripts/deprecated/delaunay3.m
+++ b/scripts/deprecated/delaunay3.m
@@ -30,19 +30,19 @@
 ## tetrahedron.
 ##
 ## The set of tetrahedrons @var{tetr} is a matrix of size [n, 4].  Each
 ## row defines a tetrahedron and the four columns are the four vertices
 ## of the tetrahedron.  The value of @code{@var{tetr}(i,j)} is an index into
 ## @var{x}, @var{y}, @var{z} for the location of the j-th vertex of the i-th
 ## tetrahedron.
 ##
-## An optional fourth argument, which must be a string or cell array of strings,
-## contains options passed to the underlying qhull command.
-## See the documentation for the Qhull library for details
+## An optional fourth argument, which must be a string or cell array of
+## strings, contains options passed to the underlying qhull command.  See the
+## documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default options are @code{@{"Qt", "Qbb", "Qc", "Qz"@}}.
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
 ## used.  Otherwise, @var{options} replaces the default argument list.
 ## To append user options to the defaults it is necessary to repeat the
 ## default arguments in @var{options}.  Use a null string to pass no arguments.
 ##
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -18,17 +18,18 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{m} =} cell2mat (@var{c})
 ## Convert the cell array @var{c} into a matrix by concatenating all
 ## elements of @var{c} into a hyperrectangle.
 ##
 ## Elements of @var{c} must be numeric, logical, or char matrices; or cell
-## arrays; or structs; and @code{cat} must be able to concatenate them together.
+## arrays; or structs; and @code{cat} must be able to concatenate them
+## together.
 ## @seealso{mat2cell, num2cell}
 ## @end deftypefn
 
 function m = cell2mat (c)
 
   if (nargin != 1)
     print_usage ();
   endif
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -26,17 +26,18 @@
 ## @w{@code{cumtrapz (@var{y})}} computes the cumulative integral of @var{y}
 ## along the first non-singleton dimension.  Where @code{trapz} reports only
 ## the overall integral sum, @code{cumtrapz} reports the current partial sum
 ## value at each point of @var{y}.
 ##
 ## When the argument @var{x} is omitted an equally spaced @var{x} vector with
 ## unit spacing (1) is assumed.  @code{cumtrapz (@var{x}, @var{y})} evaluates
 ## the integral with respect to the spacing in @var{x} and the values in
-## @var{y}.  This is useful if the points in @var{y} have been sampled unevenly.
+## @var{y}.  This is useful if the points in @var{y} have been sampled
+## unevenly.
 ##
 ## If the optional @var{dim} argument is given, operate along this dimension.
 ##
 ## Application Note: If @var{x} is not specified then unit spacing will be
 ## used.  To scale the integral to the correct value you must multiply by the
 ## actual spacing value (deltaX).
 ## @seealso{trapz, cumsum}
 ## @end deftypefn
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -40,18 +40,18 @@
 ## @group
 ##       1    / d^2            d^2         \
 ## D  = --- * | ---  M(x,y) +  ---  M(x,y) |
 ##       4    \ dx^2           dy^2        /
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## For N-dimensional arrays the sum in parentheses is expanded to include second
-## derivatives over the additional higher dimensions.
+## For N-dimensional arrays the sum in parentheses is expanded to include
+## second derivatives over the additional higher dimensions.
 ##
 ## The spacing between evaluation points may be defined by @var{h}, which is a
 ## scalar defining the equidistant spacing in all dimensions.  Alternatively,
 ## the spacing in each dimension may be defined separately by @var{dx},
 ## @var{dy}, etc.  A scalar spacing argument defines equidistant spacing,
 ## whereas a vector argument can be used to specify variable spacing.  The
 ## length of the spacing vectors must match the respective dimension of
 ## @var{M}.  The default spacing value is 1.
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -143,18 +143,18 @@
 ## @command{ParamValue} or @command{Switch} arguments.
 ##
 ## @seealso{nargin, validateattributes, validatestring, varargin}
 ## @end deftypefn
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} addOptional (@var{argname}, @var{default})
 ## @deftypefnx {} {} addOptional (@var{argname}, @var{default}, @var{validator})
-## Add new optional argument to the object @var{parser} of the class inputParser
-## to implement an ordered arguments type of API
+## Add new optional argument to the object @var{parser} of the class
+## inputParser to implement an ordered arguments type of API
 ##
 ## @var{argname} must be a string with the name of the new argument.  The order
 ## in which new arguments are added with @command{addOptional}, represents the
 ## expected order of arguments.
 ##
 ## @var{default} will be the value used when the argument is not specified.
 ##
 ## @var{validator} is an optional anonymous function to validate the given
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -70,18 +70,18 @@
 ## beyond the endpoints using the current @var{method}.  If @var{extrap} is a
 ## number, then replace values beyond the endpoints with that number.  When
 ## unspecified, @var{extrap} defaults to @code{NA}.
 ##
 ## If the string argument @qcode{"pp"} is specified, then @var{xi} should not
 ## be supplied and @code{interp1} returns a piecewise polynomial object.  This
 ## object can later be used with @code{ppval} to evaluate the interpolation.
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
-## @var{y}, @var{method}, @qcode{"pp"}), @var{xi}) == interp1 (@var{x}, @var{y},
-## @var{xi}, @var{method}, @qcode{"extrap"})}.
+## @var{y}, @var{method}, @qcode{"pp"}), @var{xi}) == interp1 (@var{x},
+## @var{y}, @var{xi}, @var{method}, @qcode{"extrap"})}.
 ##
 ## Duplicate points in @var{x} specify a discontinuous interpolant.  There
 ## may be at most 2 consecutive points with the same value.
 ## If @var{x} is increasing, the default discontinuous interpolant is
 ## right-continuous.  If @var{x} is decreasing, the default discontinuous
 ## interpolant is left-continuous.
 ## The continuity condition of the interpolant may be specified by using
 ## the options @qcode{"left"} or @qcode{"right"} to select a left-continuous
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -39,22 +39,22 @@
 ## If called without @var{x}, @var{y}, @var{z}, and just a single reference
 ## data matrix @var{v}, the 3-D region
 ## @code{@var{x} = 1:columns (@var{v}), @var{y} = 1:rows (@var{v}),
 ## @var{z} = 1:size (@var{v}, 3)} is assumed.
 ## This saves memory if the grid is regular and the distance between points is
 ## not important.
 ##
 ## If called with a single reference data matrix @var{v} and a refinement
-## value @var{n}, then perform interpolation over a 3-D grid where each original
-## interval has been recursively subdivided @var{n} times.  This results in
-## @code{2^@var{n}-1} additional points for every interval in the original
-## grid.  If @var{n} is omitted a value of 1 is used.  As an example, the
-## interval [0,1] with @code{@var{n}==2} results in a refined interval with
-## points at [0, 1/4, 1/2, 3/4, 1].
+## value @var{n}, then perform interpolation over a 3-D grid where each
+## original interval has been recursively subdivided @var{n} times.  This
+## results in @code{2^@var{n}-1} additional points for every interval in the
+## original grid.  If @var{n} is omitted a value of 1 is used.  As an
+## example, the interval [0,1] with @code{@var{n}==2} results in a refined
+## interval with points at [0, 1/4, 1/2, 3/4, 1].
 ##
 ## The interpolation @var{method} is one of:
 ##
 ## @table @asis
 ## @item @qcode{"nearest"}
 ## Return the nearest neighbor.
 ##
 ## @item @qcode{"linear"} (default)
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -16,21 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} narginchk (@var{minargs}, @var{maxargs})
 ## Check for correct number of input arguments.
 ##
 ## Generate an error message if the number of arguments in the calling function
-## is outside the range @var{minargs} and @var{maxargs}.  Otherwise, do nothing.
+## is outside the range @var{minargs} and @var{maxargs}.  Otherwise, do
+## nothing.
 ##
 ## Both @var{minargs} and @var{maxargs} must be scalar numeric values.  Zero,
-## Inf, and negative values are all allowed, and @var{minargs} and @var{maxargs}
-## may be equal.
+## Inf, and negative values are all allowed, and @var{minargs} and
+## @var{maxargs} may be equal.
 ##
 ## Note that this function evaluates @code{nargin} on the caller.
 ##
 ## @seealso{nargoutchk, error, nargout, nargin}
 ## @end deftypefn
 
 ## Author: CarnÃ« Draug <carandraug+dev@gmail.com>
 
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -36,19 +36,19 @@
 ## @item profile clear
 ## Clear all collected profiler data.
 ##
 ## @item profile resume
 ## Restart profiling without clearing the old data.  All newly collected
 ## statistics are added to the existing ones.
 ##
 ## @item @var{S} = profile ("status")
-## Return a structure with information about the current status of the profiler.
-## At the moment, the only field is @code{ProfilerStatus} which is either
-## @qcode{"on"} or @qcode{"off"}.
+## Return a structure with information about the current status of the
+## profiler.  At the moment, the only field is @code{ProfilerStatus} which is
+## either @qcode{"on"} or @qcode{"off"}.
 ##
 ## @item @var{T} = profile ("info")
 ## Return the collected profiling statistics in the structure @var{T}.  The
 ## flat profile is returned in the field @code{FunctionTable} which is an
 ## array of structures, each entry corresponding to a function which was called
 ## and for which profiling statistics are present.  In addition, the field
 ## @code{Hierarchical} contains the hierarchical call tree.  Each node has an
 ## index into the @code{FunctionTable} identifying the function it corresponds
diff --git a/scripts/general/validateattributes.m b/scripts/general/validateattributes.m
--- a/scripts/general/validateattributes.m
+++ b/scripts/general/validateattributes.m
@@ -50,17 +50,18 @@
 ## @end table
 ##
 ## @var{attributes} must be a cell array with names of checks for @var{A}.
 ## Some of them require an additional value to be supplied right after the
 ## name (see details for each below).
 ##
 ## @table @asis
 ## @item @qcode{"<="}
-## All values are less than or equal to the following value in @var{attributes}.
+## All values are less than or equal to the following value in
+## @var{attributes}.
 ##
 ## @item @qcode{"<"}
 ## All values are less than the following value in @var{attributes}.
 ##
 ## @item @qcode{">="}
 ## All values are greater than or equal to the following value in
 ## @var{attributes}.
 ##
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -26,19 +26,19 @@
 ## points from the set.
 ##
 ## The input matrix @var{pts} of size [n, dim] contains n points in a space of
 ## dimension dim.  The return matrix @var{T} has size [m, dim+1].  Each row of
 ## @var{T} contains a set of indices back into the original set of points
 ## @var{pts} which describes a simplex of dimension dim.  For example, a 2-D
 ## simplex is a triangle and 3-D simplex is a tetrahedron.
 ##
-## An optional second argument, which must be a string or cell array of strings,
-## contains options passed to the underlying qhull command.
-## See the documentation for the Qhull library for details
+## An optional second argument, which must be a string or cell array of
+## strings, contains options passed to the underlying qhull command.  See the
+## documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default options depend on the dimension of the input:
 ##
 ## @itemize
 ## @item 2-D and 3-D: @var{options} = @code{@{"Qt", "Qbb", "Qc", "Qz"@}}
 ##
 ## @item 4-D and higher: @var{options} = @code{@{"Qt", "Qbb", "Qc", "Qx"@}}
 ## @end itemize
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -20,18 +20,18 @@
 ## @deftypefn  {} {@var{idx} =} tsearchn (@var{x}, @var{t}, @var{xi})
 ## @deftypefnx {} {[@var{idx}, @var{p}] =} tsearchn (@var{x}, @var{t}, @var{xi})
 ## Search for the enclosing Delaunay convex hull.
 ##
 ## For @code{@var{t} = delaunayn (@var{x})}, finds the index in @var{t}
 ## containing the points @var{xi}.  For points outside the convex hull,
 ## @var{idx} is NaN.
 ##
-## If requested @code{tsearchn} also returns the Barycentric coordinates @var{p}
-## of the enclosing triangles.
+## If requested @code{tsearchn} also returns the Barycentric coordinates
+## @var{p} of the enclosing triangles.
 ## @seealso{delaunay, delaunayn}
 ## @end deftypefn
 
 function [idx, p] = tsearchn (x, t, xi)
   if (nargin != 3)
     print_usage ();
   endif
 
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -22,19 +22,19 @@
 ## Compute N-dimensional Voronoi facets.
 ##
 ## The input matrix @var{pts} of size [n, dim] contains n points in a space of
 ## dimension dim.
 ##
 ## @var{C} contains the points of the Voronoi facets.  The list @var{F}
 ## contains, for each facet, the indices of the Voronoi points.
 ##
-## An optional second argument, which must be a string or cell array of strings,
-## contains options passed to the underlying qhull command.
-## See the documentation for the Qhull library for details
+## An optional second argument, which must be a string or cell array of
+## strings, contains options passed to the underlying qhull command.  See the
+## documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ##
 ## The default options depend on the dimension of the input:
 ##
 ## @itemize
 ## @item 2-D and 3-D: @var{options} = @code{@{"Qbb"@}}
 ##
 ## @item 4-D and higher: @var{options} = @code{@{"Qbb", "Qx"@}}
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -27,17 +27,18 @@
 ## value darkens and a positive value brightens the colormap.
 ##
 ## If the @var{map} argument is omitted, the function is applied to the current
 ## colormap.
 ##
 ## The first argument can also be a valid graphics handle @var{h}, in which
 ## case @code{brighten} is applied to the colormap associated with this handle.
 ##
-## If no output is specified then the result is written to the current colormap.
+## If no output is specified then the result is written to the current
+## colormap.
 ## @seealso{colormap, contrast}
 ## @end deftypefn
 
 function rmap = brighten (arg1, beta)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
--- a/scripts/image/cmunique.m
+++ b/scripts/image/cmunique.m
@@ -25,19 +25,19 @@
 ## the smallest colormap possible @var{newmap}.
 ##
 ## When the input is an indexed image (@var{X} with colormap @var{map}) the
 ## output is a colormap @var{newmap} from which any repeated rows have been
 ## eliminated.  The output image, @var{Y}, is the original input image with
 ## the indices adjusted to match the new, possibly smaller, colormap.
 ##
 ## When the input is an RGB image (an @nospell{MxNx3} array), the output
-## colormap will contain one entry for every unique color in the original image.
-## In the worst case the new map could have as many rows as the number of
-## pixels in the original image.
+## colormap will contain one entry for every unique color in the original
+## image.  In the worst case the new map could have as many rows as the
+## number of pixels in the original image.
 ##
 ## When the input is a grayscale image @var{I}, the output colormap will
 ## contain one entry for every unique intensity value in the original image.
 ## In the worst case the new map could have as many rows as the number of
 ## pixels in the original image.
 ##
 ## Implementation Details:
 ##
diff --git a/scripts/image/colorcube.m b/scripts/image/colorcube.m
--- a/scripts/image/colorcube.m
+++ b/scripts/image/colorcube.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{map} =} colorcube ()
 ## @deftypefnx {} {@var{map} =} colorcube (@var{n})
 ## Create color colormap.  This colormap is composed of as many equally
 ## spaced colors (not grays) in the RGB color space as possible.
 ##
-## If there are not a perfect number @var{n} of regularly spaced colors then the
-## remaining entries in the colormap are gradients of pure red, green, blue,
-## and gray.
+## If there are not a perfect number @var{n} of regularly spaced colors then
+## the remaining entries in the colormap are gradients of pure red, green,
+## blue, and gray.
 ##
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 function map = colorcube (n)
 
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -68,18 +68,18 @@
 ## @item DelayTime
 ## Time in 1/100ths of a second (0 to 65535) which must expire before
 ## displaying the next image in an animated sequence.
 ##
 ## @item LoopCount
 ## Number of iterations to loop an animation.
 ##
 ## @item ByteOrder
-## Endian option for formats that support it.  Value is @qcode{"little-endian"},
-## @qcode{"big-endian"}, or @qcode{"undefined"}.
+## Endian option for formats that support it.  Value is
+## @qcode{"little-endian"}, @qcode{"big-endian"}, or @qcode{"undefined"}.
 ##
 ## @item Gamma
 ## Gamma level of the image.  The same color image displayed on two different
 ## workstations may look different due to differences in the display monitor.
 ##
 ## @item Quality
 ## JPEG/MIFF/PNG compression level.  Value is an integer in the range [0 100].
 ##
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -45,22 +45,24 @@
 ## @var{value1} is the display range as described above.
 ##
 ## @item @qcode{"colormap"}
 ## @var{value1} is the colormap to use when displaying an indexed image.
 ##
 ## @item @qcode{"xdata"}
 ## If @var{value1} is a two element vector, it must contain horizontal axis
 ## limits in the form [xmin xmax]; Otherwise @var{value1} must be a vector and
-## only the first and last elements will be used for xmin and xmax respectively.
+## only the first and last elements will be used for xmin and xmax
+## respectively.
 ##
 ## @item @qcode{"ydata"}
 ## If @var{value1} is a two element vector, it must contain vertical axis
 ## limits in the form [ymin ymax]; Otherwise @var{value1} must be a vector and
-## only the first and last elements will be used for ymin and ymax respectively.
+## only the first and last elements will be used for ymin and ymax
+## respectively.
 ##
 ## @end table
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
 
 ## Author: Stefan van der Walt  <stefan@sun.ac.za>
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -39,40 +39,40 @@
 ## @item
 ## If @var{name} is the name of a function defined in the interpreter but not
 ## in an m-file, then an m-file will be created in @env{HOME} to contain that
 ## function along with its current definition.
 ##
 ## @item
 ## If @code{@var{name}.cc} is specified, then it will search for
 ## @code{@var{name}.cc} in the path and try to modify it, otherwise it will
-## create a new @file{.cc} file in the current directory.  If @var{name} happens
-## to be an m-file or interpreter defined function, then the text of that
-## function will be inserted into the .cc file as a comment.
+## create a new @file{.cc} file in the current directory.  If @var{name}
+## happens to be an m-file or interpreter defined function, then the text of
+## that function will be inserted into the .cc file as a comment.
 ##
 ## @item
 ## If @file{@var{name}.ext} is on your path then it will be edited, otherwise
 ## the editor will be started with @file{@var{name}.ext} in the current
 ## directory as the filename.  If @file{@var{name}.ext} is not modifiable,
 ## it will be copied to @env{HOME} before editing.
 ##
 ## @strong{Warning:} You may need to clear @var{name} before the new definition
 ## is available.  If you are editing a .cc file, you will need to execute
 ## @code{mkoctfile @file{@var{name}.cc}} before the definition will be
 ## available.
 ## @end itemize
 ##
 ## If @code{edit} is called with @var{field} and @var{value} variables, the
 ## value of the control field @var{field} will be set to @var{value}.
 ##
-## If an output argument is requested and the first input argument is @code{get}
-## then @code{edit} will return the value of the control field @var{field}.
-## If the control field does not exist, edit will return a structure
-## containing all fields and values.  Thus, @code{edit ("get", "all")} returns
-## a complete control structure.
+## If an output argument is requested and the first input argument is
+## @code{get} then @code{edit} will return the value of the control field
+## @var{field}.  If the control field does not exist, edit will return a
+## structure containing all fields and values.  Thus, @code{edit ("get",
+## "all")} returns a complete control structure.
 ##
 ## The following control fields are used:
 ##
 ## @table @samp
 ## @item home
 ## This is the location of user local m-files.  Be sure it is in your path.
 ## The default is @file{~/octave}.
 ##
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -22,20 +22,20 @@
 ## @deftypefnx {} {@var{sout}] =} orderfields (@var{s1}, @{@var{cellstr}@})
 ## @deftypefnx {} {@var{sout}] =} orderfields (@var{s1}, @var{p})
 ## @deftypefnx {} {[@var{sout}, @var{p}] =} orderfields (@dots{})
 ## Return a @emph{copy} of @var{s1} with fields arranged alphabetically, or as
 ## specified by the second input.
 ##
 ## Given one input struct @var{s1}, arrange field names alphabetically.
 ##
-## If a second struct argument is given, arrange field names in @var{s1} as they
-## appear in @var{s2}.  The second argument may also specify the order in a
-## cell array of strings @var{cellstr}.  The second argument may also be a
-## permutation vector.
+## If a second struct argument is given, arrange field names in @var{s1} as
+## they appear in @var{s2}.  The second argument may also specify the order
+## in a cell array of strings @var{cellstr}.  The second argument may also
+## be a permutation vector.
 ##
 ## The optional second output argument @var{p} is the permutation vector which
 ## converts the original name order to the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -21,19 +21,19 @@
 ## @deftypefnx {} {} run ("@var{script}")
 ## Run @var{script} in the current workspace.
 ##
 ## Scripts which reside in directories specified in Octave's load path, and
 ## which end with the extension @file{".m"}, can be run simply by typing
 ## their name.  For scripts not located on the load path, use @code{run}.
 ##
 ## The filename @var{script} can be a bare, fully qualified, or relative
-## filename and with or without a file extension.  If no extension is specified,
-## Octave will first search for a script with the @file{".m"} extension before
-## falling back to the script name without an extension.
+## filename and with or without a file extension.  If no extension is
+## specified, Octave will first search for a script with the @file{".m"}
+## extension before falling back to the script name without an extension.
 ##
 ## Implementation Note: If @var{script} includes a path component, then
 ## @code{run} first changes the working directory to the directory where
 ## @var{script} is found.  Next, the script is executed.  Finally, @code{run}
 ## returns to the original working directory unless @code{script} has
 ## specifically changed directories.
 ## @seealso{path, addpath, source}
 ## @end deftypefn
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -115,17 +115,18 @@
 ## By default, the @code{Octave:associativity-change} warning is enabled.
 ##
 ## @item Octave:autoload-relative-file-name
 ## If the @code{Octave:autoload-relative-file-name} is enabled,
 ## Octave will warn when parsing autoload() function calls with relative
 ## paths to function files.  This usually happens when using autoload()
 ## calls in PKG_ADD files, when the PKG_ADD file is not in the same
 ## directory as the .oct file referred to by the autoload() command.
-## By default, the @code{Octave:autoload-relative-file-name} warning is enabled.
+## By default, the @code{Octave:autoload-relative-file-name} warning is
+## enabled.
 ##
 ## @item Octave:built-in-variable-assignment
 ## By default, the @code{Octave:built-in-variable-assignment} warning is
 ## enabled.
 ##
 ## @item Octave:deprecated-keyword
 ## If the @code{Octave:deprecated-keyword} warning is enabled, a
 ## warning is issued when Octave encounters a keyword that is obsolete and
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -60,31 +60,31 @@
 ## The function typically returns two outputs.  Variable @var{t} is a
 ## column vector and contains the times where the solution was found.  The
 ## output @var{y} is a matrix in which each column refers to a different
 ## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## The output can also be returned as a structure @var{solution} which
 ## has field @var{x} containing the time where the solution was evaluated and
 ## field @var{y} containing the solution matrix for the times in @var{x}.
-## Use @code{fieldnames (@var{solution})} to see the other fields and additional
-## information returned.
+## Use @code{fieldnames (@var{solution})} to see the other fields and
+## additional information returned.
 ##
 ## If using the @qcode{"Events"} option then three additional outputs may
 ## be returned.  @var{te} holds the time when an Event function returned a
 ## zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
 ##
 ## This function can be called with two output arguments: @var{t} and @var{y}.
 ## Variable @var{t} is a column vector and contains the time stamps, instead
-## @var{y} is a matrix in which each column refers to a different unknown of the
-## problem and the rows number is the same of @var{t} rows number so that each
-## row of @var{y} contains the values of all unknowns at the time value
-## contained in the corresponding row in @var{t}.
+## @var{y} is a matrix in which each column refers to a different unknown of
+## the problem and the rows number is the same of @var{t} rows number so
+## that each row of @var{y} contains the values of all unknowns at the time
+## value contained in the corresponding row in @var{t}.
 ##
 ## Example: Solve the @nospell{Van der Pol} equation
 ##
 ## @example
 ## @group
 ## fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
 ## [@var{t},@var{y}] = ode23 (fvdp, [0, 20], [2, 0]);
 ## @end group
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -58,18 +58,18 @@
 ## The function typically returns two outputs.  Variable @var{t} is a
 ## column vector and contains the times where the solution was found.  The
 ## output @var{y} is a matrix in which each column refers to a different
 ## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## The output can also be returned as a structure @var{solution} which
 ## has field @var{x} containing the time where the solution was evaluated and
 ## field @var{y} containing the solution matrix for the times in @var{x}.
-## Use @code{fieldnames (@var{solution})} to see the other fields and additional
-## information returned.
+## Use @code{fieldnames (@var{solution})} to see the other fields and
+## additional information returned.
 ##
 ## If using the @qcode{"Events"} option then three additional outputs may
 ## be returned.  @var{te} holds the time when an Event function returned a
 ## zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
 ##
 ## Example: Solve the @nospell{Van der Pol} equation
diff --git a/scripts/ode/odeget.m b/scripts/ode/odeget.m
--- a/scripts/ode/odeget.m
+++ b/scripts/ode/odeget.m
@@ -19,20 +19,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{val} =} odeget (@var{ode_opt}, @var{field})
 ## @deftypefnx {} {@var{val} =} odeget (@var{ode_opt}, @var{field}, @var{default})
 ##
 ## Query the value of the property @var{field} in the ODE options structure
 ## @var{ode_opt}.
 ##
-## If called with two input arguments and the first input argument @var{ode_opt}
-## is an ODE option structure and the second input argument @var{field} is a
-## string specifying an option name, then return the option value @var{val}
-## corresponding to @var{field} from @var{ode_opt}.
+## If called with two input arguments and the first input argument
+## @var{ode_opt} is an ODE option structure and the second input argument
+## @var{field} is a string specifying an option name, then return the option
+## value @var{val} corresponding to @var{field} from @var{ode_opt}.
 ##
 ## If called with an optional third input argument, and @var{field} is
 ## not set in the structure @var{ode_opt}, then return the default value
 ## @var{default} instead.
 ## @seealso{odeset}
 ## @end deftypefn
 
 ## FIXME: 4th input argument "opt" is undocumented.
diff --git a/scripts/ode/private/integrate_adaptive.m b/scripts/ode/private/integrate_adaptive.m
--- a/scripts/ode/private/integrate_adaptive.m
+++ b/scripts/ode/private/integrate_adaptive.m
@@ -50,17 +50,18 @@
 ## @math{y' = f(t,y)}.
 ## @end ifnothtml
 ##
 ## The fourth input argument is the time vector which defines the integration
 ## interval, i.e., @var{[tspan(1), tspan(end)]} and all intermediate elements
 ## are taken as times at which the solution is required.
 ##
 ## The fifth argument represents the initial conditions for the ODEs and the
-## last input argument contains some options that may be needed for the stepper.
+## last input argument contains some options that may be needed for the
+## stepper.
 ##
 ## @end deftypefn
 ##
 ## @seealso{integrate_const, integrate_n_steps}
 
 function solution = integrate_adaptive (stepper, order, func, tspan, x0,
                                         options)
 
diff --git a/scripts/ode/private/kahan.m b/scripts/ode/private/kahan.m
--- a/scripts/ode/private/kahan.m
+++ b/scripts/ode/private/kahan.m
@@ -33,17 +33,18 @@
 ## The first input argument is the variable that will contain the summation,
 ## so that is also returned as first output argument in order to reuse it in
 ## next calls to @code{kahan} function.
 ##
 ## The second input argument contains the compensation term and it is returned
 ## as the second output argument so that it can be reused in future calls of
 ## the same summation.
 ##
-## The third input argument @var{term} is the variable to be added to @var{sum}.
+## The third input argument @var{term} is the variable to be added to
+## @var{sum}.
 ## @end deftypefn
 
 function [sum, comp] = kahan (sum, comp, term)
 
   y = term - comp;
   t = sum + y;
   comp = (t - sum) - y;
   sum = t;
diff --git a/scripts/ode/private/ode_struct_value_check.m b/scripts/ode/private/ode_struct_value_check.m
--- a/scripts/ode/private/ode_struct_value_check.m
+++ b/scripts/ode/private/ode_struct_value_check.m
@@ -17,17 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} ode_struct_value_check (@var{"caller"}, @var{ode_struct})
 ## @deftypefnx {} {} ode_struct_value_check (@var{"caller"), @var{ode_struct}, @var{"solver"})
 ## @deftypefnx {} {@var{ode_struct} =} ode_struct_value_check (@dots{})
 ##
-## Validate the fields and values in the ODE options structure @var{ode_struct}.
+## Validate the fields and values in the ODE options structure
+## @var{ode_struct}.
 ##
 ## The first argument @var{caller} is a string with the name of the calling
 ## function so that warning and error messages properly display the source
 ## of any problems.
 ##
 ## The second argument @var{ode_struct} is a structure with fields and values
 ## that configure the ODE solvers (@pxref{XREFodeset,,odeset).
 ##
diff --git a/scripts/ode/private/runge_kutta_23.m b/scripts/ode/private/runge_kutta_23.m
--- a/scripts/ode/private/runge_kutta_23.m
+++ b/scripts/ode/private/runge_kutta_23.m
@@ -26,18 +26,18 @@
 ## @deftypefnx {} {[@var{t_next}, @var{x_next}, @var{x_est}, @var{k_vals_out}] =} runge_kutta_23 (@dots{})
 ##
 ## This function can be used to integrate a system of ODEs with a given initial
 ## condition @var{x} from @var{t} to @var{t+dt}, with the Bogacki-Shampine
 ## method of third order.  For the definition of this method see
 ## @url{http://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods}.
 ##
 ## @var{@fun} is a function handle that defines the ODE: @code{y' = f(tau,y)}.
-## The function must accept two inputs where the first is time @var{tau} and the
-## second is a column vector of unknowns @var{y}.
+## The function must accept two inputs where the first is time @var{tau} and
+## the second is a column vector of unknowns @var{y}.
 ##
 ## @var{t} is the first extreme of integration interval.
 ##
 ## @var{x} is the initial condition of the system..
 ##
 ## @var{dt} is the timestep, that is the length of the integration interval.
 ##
 ## The optional fourth argument @var{options} specifies options for the ODE
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -36,21 +36,21 @@
 ## @var{options} is a structure specifying additional options.  Currently,
 ## @code{fminunc} recognizes these options:
 ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
 ## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
 ## @qcode{"GradObj"}, @qcode{"FinDiffType"}, @qcode{"TypicalX"},
 ## @qcode{"AutoScaling"}.
 ##
 ## If @qcode{"GradObj"} is @qcode{"on"}, it specifies that @var{fcn}, when
-## called with two output arguments, also returns the Jacobian matrix of partial
-## first derivatives at the requested point.  @code{TolX} specifies the
-## termination tolerance for the unknown variables @var{x}, while @code{TolFun}
-## is a tolerance for the objective function value @var{fval}.  The default is
-## @code{1e-7} for both options.
+## called with two output arguments, also returns the Jacobian matrix of
+## partial first derivatives at the requested point.  @code{TolX} specifies
+## the termination tolerance for the unknown variables @var{x}, while
+## @code{TolFun} is a tolerance for the objective function value @var{fval}.
+##  The default is @code{1e-7} for both options.
 ##
 ## For a description of the other options, see @code{optimset}.
 ##
 ## On return, @var{x} is the location of the minimum and @var{fval} contains
 ## the value of the objective function at @var{x}.
 ##
 ## @var{info} may be one of the following values:
 ##
@@ -71,19 +71,20 @@
 ##
 ## @item -1
 ## Algorithm terminated by @code{OutputFcn}.
 ##
 ## @item -3
 ## The trust region radius became excessively small.
 ## @end table
 ##
-## Optionally, @code{fminunc} can return a structure with convergence statistics
-## (@var{output}), the output gradient (@var{grad}) at the solution @var{x},
-## and approximate Hessian (@var{hess}) at the solution @var{x}.
+## Optionally, @code{fminunc} can return a structure with convergence
+## statistics (@var{output}), the output gradient (@var{grad}) at the
+## solution @var{x}, and approximate Hessian (@var{hess}) at the solution
+## @var{x}.
 ##
 ## Application Notes: If the objective function is a single nonlinear equation
 ## of one variable then using @code{fminbnd} is usually a better choice.
 ##
 ## The algorithm used by @code{fminsearch} is a gradient search which depends
 ## on the objective function being differentiable.  If the function has
 ## discontinuities it may be better to use a derivative-free algorithm such as
 ## @code{fminsearch}.
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -48,19 +48,19 @@
 ##
 ## If @qcode{"AutoScaling"} is on, the variables will be automatically scaled
 ## according to the column norms of the (estimated) Jacobian.  As a result,
 ## TolF becomes scaling-independent.  By default, this option is off because
 ## it may sometimes deliver unexpected (though mathematically correct) results.
 ##
 ## If @qcode{"Updating"} is @qcode{"on"}, the function will attempt to use
 ## @nospell{Broyden} updates to update the Jacobian, in order to reduce the
-## amount of Jacobian calculations.  If your user function always calculates the
-## Jacobian (regardless of number of output arguments) then this option provides
-## no advantage and should be set to false.
+## amount of Jacobian calculations.  If your user function always calculates
+## the Jacobian (regardless of number of output arguments) then this option
+## provides no advantage and should be set to false.
 ##
 ## @qcode{"ComplexEqn"} is @qcode{"on"}, @code{fsolve} will attempt to solve
 ## complex equations in complex variables, assuming that the equations possess
 ## a complex derivative (i.e., are holomorphic).  If this is not what you want,
 ## you should unpack the real and imaginary parts of the system to get a real
 ## system.
 ##
 ## For description of the other options, see @code{optimset}.
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -71,20 +71,22 @@
 ## @itemize
 ## @item iterations
 ##  Number of iterations through loop.
 ##
 ## @item nfev
 ##  Number of function evaluations.
 ##
 ## @item bracketx
-##  A two-element vector with the final bracketing of the zero along the x-axis.
+##  A two-element vector with the final bracketing of the zero along the
+## x-axis.
 ##
 ## @item brackety
-##  A two-element vector with the final bracketing of the zero along the y-axis.
+##  A two-element vector with the final bracketing of the zero along the
+## y-axis.
 ## @end itemize
 ## @seealso{optimset, fsolve}
 ## @end deftypefn
 
 ## This is essentially the ACM algorithm 748: Enclosing Zeros of
 ## Continuous Functions due to Alefeld, Potra and Shi, ACM Transactions
 ## on Mathematical Software, Vol. 21, No. 3, September 1995. Although
 ## the workflow should be the same, the structure of the algorithm has
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -163,17 +163,18 @@
 ## For example:
 ##
 ## @example
 ## oct_forge_pkgs = pkg ("list", "-forge")
 ## @end example
 ##
 ## @item describe
 ## Show a short description of the named installed packages, with the option
-## @qcode{"-verbose"} also list functions provided by the package.  For example,
+## @qcode{"-verbose"} also list functions provided by the package.  For
+## example,
 ##
 ## @example
 ## pkg describe -verbose all
 ## @end example
 ##
 ## @noindent
 ## will describe all installed packages and the functions they provide.
 ## If one output is requested a cell of structure containing the
@@ -265,18 +266,18 @@
 ## where @code{builddir} is the name of a directory where the temporary
 ## installation will be produced and the binary packages will be found.
 ## The options @option{-verbose} and @option{-nodeps} are respected, while
 ## all other options are ignored.
 ##
 ## @item rebuild
 ## Rebuild the package database from the installed directories.  This can
 ## be used in cases where the package database has been corrupted.
-## It can also take the @option{-auto} and @option{-noauto} options to allow the
-## autoloading state of a package to be changed.  For example,
+## It can also take the @option{-auto} and @option{-noauto} options to allow
+## the autoloading state of a package to be changed.  For example,
 ##
 ## @example
 ## pkg rebuild -noauto image
 ## @end example
 ##
 ## @noindent
 ## will remove the autoloading status of the image package.
 ##
diff --git a/scripts/pkg/private/build.m b/scripts/pkg/private/build.m
--- a/scripts/pkg/private/build.m
+++ b/scripts/pkg/private/build.m
@@ -20,17 +20,19 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {} build (@var{builddir}, @var{tarballs}, @var{verbose})
 ## Prepare binary packages from Octave source packages.
 ##
 ## Boils down to (for each in @var{tarballs}):
 ##
 ## @enumerate
 ## @item untar the tarball in @var{builddir};
+##
 ## @item build anything necessary (configure and make);
+##
 ## @item repackage specifying the build arch in the tarball filename.
 ## @end enumerate
 ##
 ## @end deftypefn
 
 function build (builddir, tarballs, verbose)
   if (nargin != 3)
     print_usage ();
diff --git a/scripts/plot/appearance/specular.m b/scripts/plot/appearance/specular.m
--- a/scripts/plot/appearance/specular.m
+++ b/scripts/plot/appearance/specular.m
@@ -23,18 +23,18 @@
 ## normal vector elements @var{sx}, @var{sy}, @var{sz} using Phong's
 ## approximation.
 ##
 ## The light source location and viewer location vectors are specified using
 ## parameters @var{lv} and @var{vv} respectively.  The location vectors can
 ## given as 2-element vectors [azimuth, elevation] in degrees or as 3-element
 ## vectors [x, y, z].
 ##
-## An optional sixth argument specifies the specular exponent (spread) @var{se}.
-## If not given, @var{se} defaults to 10.
+## An optional sixth argument specifies the specular exponent (spread)
+## @var{se}.  If not given, @var{se} defaults to 10.
 ## @seealso{diffuse, surfl}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = specular (sx, sy, sz, lv, vv, se)
 
   if (nargin < 5 || nargin > 6)
diff --git a/scripts/plot/appearance/view.m b/scripts/plot/appearance/view.m
--- a/scripts/plot/appearance/view.m
+++ b/scripts/plot/appearance/view.m
@@ -34,17 +34,18 @@
 ## and @w{@var{elevation} = 90}, which is the default for 2-D graphs.
 ##
 ## The call @code{view (3)} sets the viewpoint to @w{@var{azimuth} = -37.5}
 ## and @w{@var{elevation} = 30}, which is the default for 3-D graphs.
 ##
 ## If the first argument @var{hax} is an axes handle, then operate on
 ## this axis rather than the current axes returned by @code{gca}.
 ##
-## If no inputs are given, return the current @var{azimuth} and @var{elevation}.
+## If no inputs are given, return the current @var{azimuth} and
+## @var{elevation}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function [azimuth, elevation] = view (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("view", varargin{:});
   if (isempty (hax))
diff --git a/scripts/plot/draw/bar.m b/scripts/plot/draw/bar.m
--- a/scripts/plot/draw/bar.m
+++ b/scripts/plot/draw/bar.m
@@ -35,17 +35,18 @@
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument which can take the following values:
 ##
 ## @table @asis
 ## @item @qcode{"grouped"} (default)
-## Side-by-side bars with a gap between bars and centered over the X-coordinate.
+## Side-by-side bars with a gap between bars and centered over the
+## X-coordinate.
 ##
 ## @item  @qcode{"stacked"}
 ## Bars are stacked so that each X value has a single bar composed of
 ## multiple segments.
 ##
 ## @item @qcode{"hist"}
 ## Side-by-side bars with no gap between bars and centered over the
 ## X-coordinate.
diff --git a/scripts/plot/draw/barh.m b/scripts/plot/draw/barh.m
--- a/scripts/plot/draw/barh.m
+++ b/scripts/plot/draw/barh.m
@@ -35,17 +35,18 @@
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument which can take the following values:
 ##
 ## @table @asis
 ## @item @qcode{"grouped"} (default)
-## Side-by-side bars with a gap between bars and centered over the Y-coordinate.
+## Side-by-side bars with a gap between bars and centered over the
+## Y-coordinate.
 ##
 ## @item  @qcode{"stacked"}
 ## Bars are stacked so that each Y value has a single bar composed of
 ## multiple segments.
 ##
 ## @item @qcode{"hist"}
 ## Side-by-side bars with no gap between bars and centered over the
 ## Y-coordinate.
diff --git a/scripts/plot/draw/contour3.m b/scripts/plot/draw/contour3.m
--- a/scripts/plot/draw/contour3.m
+++ b/scripts/plot/draw/contour3.m
@@ -37,17 +37,18 @@
 ##
 ## The appearance of contour lines can be defined with a line style @var{style}
 ## in the same manner as @code{plot}.  Only line style and color are used;
 ## Any markers defined by @var{style} are ignored.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
-## The optional output @var{c} are the contour levels in @code{contourc} format.
+## The optional output @var{c} are the contour levels in @code{contourc}
+## format.
 ##
 ## The optional return value @var{h} is a graphics handle to the hggroup
 ## comprising the contour lines.
 ##
 ## Example:
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/draw/isosurface.m b/scripts/plot/draw/isosurface.m
--- a/scripts/plot/draw/isosurface.m
+++ b/scripts/plot/draw/isosurface.m
@@ -37,18 +37,18 @@
 ## @command{patch} function.
 ##
 ## If called with further input arguments @var{x}, @var{y} and @var{z}
 ## which are three--dimensional arrays with the same size than @var{val}
 ## then the volume data is taken at those given points.
 ##
 ## The string input argument @qcode{"noshare"} is only for compatibility and
 ## has no effect.  If given the string input argument
-## @qcode{"verbose"} then print messages to the command line interface about the
-## current progress.
+## @qcode{"verbose"} then print messages to the command line interface about
+## the current progress.
 ##
 ## If called with the input argument @var{col} which is a
 ## three-dimensional array of the same size than @var{val} then take
 ## those values for the interpolation of coloring the isosurface
 ## geometry.  Add the field @var{FaceVertexCData} to the structure
 ## array @var{fv}.
 ##
 ## If called with two or three output arguments then return the
diff --git a/scripts/plot/draw/line.m b/scripts/plot/draw/line.m
--- a/scripts/plot/draw/line.m
+++ b/scripts/plot/draw/line.m
@@ -29,18 +29,18 @@
 ## insert in the current axes.
 ##
 ## Multiple property-value pairs may be specified for the line object, but they
 ## must appear in pairs.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
-## The optional return value @var{h} is a graphics handle (or vector of handles)
-## to the line objects created.
+## The optional return value @var{h} is a graphics handle (or vector of
+## handles) to the line objects created.
 ##
 ## @seealso{image, patch, rectangle, surface, text}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = line (varargin)
 
diff --git a/scripts/plot/draw/pie.m b/scripts/plot/draw/pie.m
--- a/scripts/plot/draw/pie.m
+++ b/scripts/plot/draw/pie.m
@@ -37,19 +37,19 @@
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a list of handles to the patch
 ## and text objects generating the plot.
 ##
 ## Note: If @code{sum (@var{x}) @leq{} 1} then the elements of @var{x} are
-## interpreted as percentages directly and are not normalized by @code{sum (x)}.
-## Furthermore, if the sum is less than 1 then there will be a missing slice
-## in the pie plot to represent the missing, unspecified percentage.
+## interpreted as percentages directly and are not normalized by @code{sum
+## (x)}.  Furthermore, if the sum is less than 1 then there will be a missing
+## slice in the pie plot to represent the missing, unspecified percentage.
 ##
 ## @seealso{pie3, bar, hist, rose}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function h = pie (varargin)
diff --git a/scripts/plot/draw/pie3.m b/scripts/plot/draw/pie3.m
--- a/scripts/plot/draw/pie3.m
+++ b/scripts/plot/draw/pie3.m
@@ -38,19 +38,19 @@
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a list of graphics handles to the
 ## patch, surface, and text objects generating the plot.
 ##
 ## Note: If @code{sum (@var{x}) @leq{} 1} then the elements of @var{x} are
-## interpreted as percentages directly and are not normalized by @code{sum (x)}.
-## Furthermore, if the sum is less than 1 then there will be a missing slice
-## in the pie plot to represent the missing, unspecified percentage.
+## interpreted as percentages directly and are not normalized by @code{sum
+## (x)}.  Furthermore, if the sum is less than 1 then there will be a missing
+## slice in the pie plot to represent the missing, unspecified percentage.
 ##
 ## @seealso{pie, bar, hist, rose}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function h = pie3 (varargin)
diff --git a/scripts/plot/draw/quiver3.m b/scripts/plot/draw/quiver3.m
--- a/scripts/plot/draw/quiver3.m
+++ b/scripts/plot/draw/quiver3.m
@@ -37,18 +37,18 @@
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 0.9.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## of the same format as the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## drawn rather than arrows.  If the argument @qcode{"filled"} is given then the
-## markers are filled.
+## drawn rather than arrows.  If the argument @qcode{"filled"} is given then
+## the markers are filled.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
diff --git a/scripts/plot/draw/scatter.m b/scripts/plot/draw/scatter.m
--- a/scripts/plot/draw/scatter.m
+++ b/scripts/plot/draw/scatter.m
@@ -33,18 +33,18 @@
 ## The size of the markers is determined by @var{s}, which can be a scalar
 ## or a vector of the same length as @var{x} and @var{y}.  If @var{s}
 ## is not given, or is an empty matrix, then a default value of 8 points is
 ## used.
 ##
 ## The color of the markers is determined by @var{c}, which can be a string
 ## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
-## a scaled index into the current colormap; or an @nospell{Nx3} matrix defining
-## the RGB color of each marker individually.
+## a scaled index into the current colormap; or an @nospell{Nx3} matrix
+## defining the RGB color of each marker individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
 ## If no marker is specified it defaults to @qcode{"o"} or circles.
 ## If the argument @qcode{"filled"} is given then the markers are filled.
 ##
 ## Additional property/value pairs are passed directly to the underlying
 ## patch object.
diff --git a/scripts/plot/draw/scatter3.m b/scripts/plot/draw/scatter3.m
--- a/scripts/plot/draw/scatter3.m
+++ b/scripts/plot/draw/scatter3.m
@@ -33,18 +33,18 @@
 ## The size of the markers is determined by @var{s}, which can be a scalar
 ## or a vector of the same length as @var{x}, @var{y}, and @var{z}.  If @var{s}
 ## is not given, or is an empty matrix, then a default value of 8 points is
 ## used.
 ##
 ## The color of the markers is determined by @var{c}, which can be a string
 ## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
-## a scaled index into the current colormap; or an @nospell{Nx3} matrix defining
-## the RGB color of each marker individually.
+## a scaled index into the current colormap; or an @nospell{Nx3} matrix
+## defining the RGB color of each marker individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
 ## If no marker is specified it defaults to @qcode{"o"} or circles.
 ## If the argument @qcode{"filled"} is given then the markers are filled.
 ##
 ## Additional property/value pairs are passed directly to the underlying
 ## patch object.
diff --git a/scripts/plot/draw/stem3.m b/scripts/plot/draw/stem3.m
--- a/scripts/plot/draw/stem3.m
+++ b/scripts/plot/draw/stem3.m
@@ -22,17 +22,18 @@
 ## @deftypefnx {} {} stem3 (@dots{}, "filled")
 ## @deftypefnx {} {} stem3 (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {} {} stem3 (@var{hax}, @dots{})
 ## @deftypefnx {} {@var{h} =} stem3 (@dots{})
 ## Plot a 3-D stem graph.
 ##
 ## Stems are drawn from the height @var{z} to the location in the x-y plane
 ## determined by @var{x} and @var{y}.  The default color is @qcode{"b"} (blue),
-## the default line style is @qcode{"-"}, and the default marker is @qcode{"o"}.
+## the default line style is @qcode{"-"}, and the default marker is
+## @qcode{"o"}.
 ##
 ## The line style can be altered by the @code{linespec} argument in the same
 ## manner as the @code{plot} command.  If the @qcode{"filled"} argument is
 ## present the markers at the top of the stems will be filled in.
 ##
 ## Optional property/value pairs may be specified to control the appearance
 ## of the plot.
 ##
diff --git a/scripts/plot/draw/stemleaf.m b/scripts/plot/draw/stemleaf.m
--- a/scripts/plot/draw/stemleaf.m
+++ b/scripts/plot/draw/stemleaf.m
@@ -66,17 +66,18 @@
 ##
 ## With no return argument, the plot is immediately displayed.  If an output
 ## argument is provided, the plot is returned as an array of strings.
 ##
 ## The leaf digits are not sorted.  If sorted leaf values are desired, use
 ## @code{@var{xs} = sort (@var{x})} before calling @code{stemleaf (@var{xs})}.
 ##
 ## The stem and leaf plot and associated displays are described in:
-## Ch. 3, @cite{Exploratory Data Analysis} by J. W. Tukey, Addison-Wesley, 1977.
+## Chapter 3, @cite{Exploratory Data Analysis} by J. W. Tukey, Addison-Wesley,
+## 1977.
 ## @seealso{hist, printd}
 ## @end deftypefn
 
 ## Author: Michael D. Godfrey <michaeldgodfrey@gmail.com>
 ## Description: Compute stem and leaf plot
 
 function plotstr = stemleaf (x, caption, stem_sz)
   ## Compute and display a stem and leaf plot of the vector x.  The x
diff --git a/scripts/plot/draw/surfl.m b/scripts/plot/draw/surfl.m
--- a/scripts/plot/draw/surfl.m
+++ b/scripts/plot/draw/surfl.m
@@ -36,19 +36,19 @@
 ## Thus, columns of @var{z} correspond to different @var{x} values and rows
 ## of @var{z} correspond to different @var{y} values.
 ##
 ## The default lighting mode @qcode{"cdata"}, changes the cdata property of the
 ## surface object to give the impression of a lighted surface.
 ## @strong{Warning:} The alternative mode @qcode{"light"} mode which creates a
 ## light object to illuminate the surface is not implemented (yet).
 ##
-## The light source location can be specified using @var{lsrc}.  It can be given
-## as a 2-element vector [azimuth, elevation] in degrees, or as a 3-element
-## vector [lx, ly, lz].  The default value is rotated 45 degrees
+## The light source location can be specified using @var{lsrc}.  It can be
+## given as a 2-element vector [azimuth, elevation] in degrees, or as a
+## 3-element vector [lx, ly, lz].  The default value is rotated 45 degrees
 ## counterclockwise to the current view.
 ##
 ## The material properties of the surface can specified using a 4-element
 ## vector @var{P} = [@var{AM} @var{D} @var{SP} @var{exp}] which defaults to
 ## @var{p} = [0.55 0.6 0.4 10].
 ##
 ## @table @asis
 ## @item @qcode{"AM"} strength of ambient light
diff --git a/scripts/plot/draw/tetramesh.m b/scripts/plot/draw/tetramesh.m
--- a/scripts/plot/draw/tetramesh.m
+++ b/scripts/plot/draw/tetramesh.m
@@ -16,17 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} tetramesh (@var{T}, @var{X})
 ## @deftypefnx {} {} tetramesh (@var{T}, @var{X}, @var{C})
 ## @deftypefnx {} {} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
 ## @deftypefnx {} {@var{h} =} tetramesh (@dots{})
-## Display the tetrahedrons defined in the m-by-4 matrix @var{T} as 3-D patches.
+## Display the tetrahedrons defined in the m-by-4 matrix @var{T} as 3-D
+## patches.
 ##
 ## @var{T} is typically the output of a Delaunay triangulation of a 3-D set
 ## of points.  Every row of @var{T} contains four indices into the n-by-3
 ## matrix @var{X} of the vertices of a tetrahedron.  Every row in @var{X}
 ## represents one point in 3-D space.
 ##
 ## The vector @var{C} specifies the color of each tetrahedron as an index
 ## into the current colormap.  The default value is 1:m where m is the number
diff --git a/scripts/plot/util/isfigure.m b/scripts/plot/util/isfigure.m
--- a/scripts/plot/util/isfigure.m
+++ b/scripts/plot/util/isfigure.m
@@ -16,17 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} isfigure (@var{h})
 ## Return true if @var{h} is a figure graphics handle and false otherwise.
 ##
 ## If @var{h} is a matrix then return a logical array which is true where the
-## elements of @var{h} are figure graphics handles and false where they are not.
+## elements of @var{h} are figure graphics handles and false where they are
+## not.
 ## @seealso{isaxes, ishandle}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = isfigure (h)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -28,22 +28,22 @@
 ##
 ## When @var{m} is the polynomial order @var{coefs} must be of size:
 ## @var{ni} x @var{m} + 1.
 ##
 ## The i-th row of @var{coefs}, @code{@var{coefs} (@var{i},:)}, contains the
 ## coefficients for the polynomial over the @var{i}-th interval, ordered from
 ## highest (@var{m}) to lowest (@var{0}).
 ##
-## @var{coefs} may also be a multi-dimensional array, specifying a vector-valued
-## or array-valued polynomial.  In that case the polynomial order is defined
-## by the length of the last dimension of @var{coefs}.  The size of first
-## dimension(s) are given by the scalar or vector @var{d}.  If @var{d} is not
-## given it is set to @code{1}.  In any case @var{coefs} is reshaped to a 2-D
-## matrix of size @code{[@var{ni}*prod(@var{d} @var{m})] }
+## @var{coefs} may also be a multi-dimensional array, specifying a
+## vector-valued or array-valued polynomial.  In that case the polynomial
+## order is defined by the length of the last dimension of @var{coefs}.  The
+## size of first dimension(s) are given by the scalar or vector @var{d}.  If
+## @var{d} is not given it is set to @code{1}.  In any case @var{coefs} is
+## reshaped to a 2-D matrix of size @code{[@var{ni}*prod(@var{d} @var{m})]}.
 ##
 ## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
   ## check number of arguments
   if (nargin < 2 || nargin > 3)
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -46,17 +46,18 @@
 ## given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row of this matrix is then treated separately.  Note that this is
-## exactly opposite to @code{interp1} but is done for @sc{matlab} compatibility.
+## exactly opposite to @code{interp1} but is done for @sc{matlab}
+## compatibility.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date: 9. mar 2001
 ##
 ## S_k = a_k + b_k*x + c_k*x^2 + d_k*x^3; (spline polynom)
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -82,18 +82,18 @@
 ## @end ifnottex
 ##
 ## The second calling form performs the inverse operation and computes the
 ## reconstituted quotient of polynomials, @var{b}(s)/@var{a}(s), from the
 ## partial fraction expansion; represented by the residues, poles, and a direct
 ## polynomial specified by @var{r}, @var{p} and @var{k}, and the pole
 ## multiplicity @var{e}.
 ##
-## If the multiplicity, @var{e}, is not explicitly specified the multiplicity is
-## determined by the function @code{mpoles}.
+## If the multiplicity, @var{e}, is not explicitly specified the
+## multiplicity is determined by the function @code{mpoles}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## r = [-2; 7; 3];
 ## p = [2; 2; 1];
 ## k = [1, 0];
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -26,19 +26,19 @@
 ## @deftypefnx {} {@var{pp} =} splinefit (@dots{}, "constraints", @var{constraints})
 ##
 ## Fit a piecewise cubic spline with breaks (knots) @var{breaks} to the
 ## noisy data, @var{x} and @var{y}.
 ##
 ## @var{x} is a vector, and @var{y} is a vector or N-D array.  If @var{y} is an
 ## N-D array, then @var{x}(j) is matched to @var{y}(:,@dots{},:,j).
 ##
-## @var{p} is a positive integer defining the number of intervals along @var{x},
-## and @var{p}+1 is the number of breaks.  The number of points in each interval
-## differ by no more than 1.
+## @var{p} is a positive integer defining the number of intervals along
+## @var{x}, and @var{p}+1 is the number of breaks.  The number of points in
+## each interval differ by no more than 1.
 ##
 ## The optional property @var{periodic} is a logical value which specifies
 ## whether a periodic boundary condition is applied to the spline.  The
 ## length of the period is @code{max (@var{breaks}) - min (@var{breaks})}.
 ## The default value is @code{false}.
 ##
 ## The optional property @var{robust} is a logical value which specifies
 ## if robust fitting is to be applied to reduce the influence of outlying
diff --git a/scripts/prefs/rmpref.m b/scripts/prefs/rmpref.m
--- a/scripts/prefs/rmpref.m
+++ b/scripts/prefs/rmpref.m
@@ -15,17 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} rmpref ("@var{group}", "@var{pref}")
 ## @deftypefnx {} {} rmpref ("@var{group}", @{"@var{pref1}", "@var{pref2}", @dots{}@})
 ## @deftypefnx {} {} rmpref ("@var{group}")
-## Remove the named preference @var{pref} from the preference group @var{group}.
+## Remove the named preference @var{pref} from the preference group
+## @var{group}.
 ##
 ## The named preference group must be a string.
 ##
 ## The preference @var{pref} may be a string or cell array of strings.
 ##
 ## If @var{pref} is not specified, remove the preference group @var{group}.
 ##
 ## It is an error to remove a nonexistent preference or group.
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -21,29 +21,31 @@
 ## @deftypefn  {} {} unique (@var{x})
 ## @deftypefnx {} {} unique (@var{x}, "rows")
 ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
 ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
 ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
 ## Return the unique elements of @var{x} sorted in ascending order.
 ##
 ## If the input @var{x} is a column vector then return a column vector;
-## Otherwise, return a row vector.  @var{x} may also be a cell array of strings.
+## Otherwise, return a row vector.  @var{x} may also be a cell array of
+## strings.
 ##
 ## If the optional argument @qcode{"rows"} is given then return the unique
 ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
 ## to use this option.
 ##
 ## If requested, return index vectors @var{i} and @var{j} such that
 ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
 ##
-## Additionally, if @var{i} is a requested output then one of @qcode{"first"} or
-## @qcode{"last"} may be given as an input.  If @qcode{"last"} is specified,
-## return the highest possible indices in @var{i}, otherwise, if @qcode{"first"}
-## is specified, return the lowest.  The default is @qcode{"last"}.
+## Additionally, if @var{i} is a requested output then one of
+## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+## @qcode{"last"} is specified, return the highest possible indices in
+## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest. 
+## The default is @qcode{"last"}.
 ## @seealso{union, intersect, setdiff, setxor, ismember}
 ## @end deftypefn
 
 function [y, i, j] = unique (x, varargin)
 
   if (nargin < 1)
     print_usage ();
   elseif (! (isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -102,17 +102,18 @@
 ## @end table
 ##
 ## If @var{opts} is given, it is a structure defining possible options that
 ## @code{eigs} should use.  The fields of the @var{opts} structure are:
 ##
 ## @table @code
 ## @item issym
 ## If @var{af} is given, then flags whether the function @var{af} defines a
-## symmetric problem.  It is ignored if @var{A} is given.  The default is false.
+## symmetric problem.  It is ignored if @var{A} is given.  The default is
+## false.
 ##
 ## @item isreal
 ## If @var{af} is given, then flags whether the function @var{af} defines a
 ## real problem.  It is ignored if @var{A} is given.  The default is true.
 ##
 ## @item tol
 ## Defines the required convergence tolerance, calculated as
 ## @code{tol * norm (A)}.  The default is @code{eps}.
@@ -168,23 +169,23 @@
 ## for the standard eigenvalue problem, where @code{I} is the identity matrix
 ## of the same size as @var{A}.
 ##
 ## @item (A - sigma * B) \ x
 ## for the general eigenvalue problem.
 ## @end table
 ##
 ## The return arguments of @code{eigs} depend on the number of return arguments
-## requested.  With a single return argument, a vector @var{d} of length @var{k}
-## is returned containing the @var{k} eigenvalues that have been found.  With
-## two return arguments, @var{V} is a @var{n}-by-@var{k} matrix whose columns
-## are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The
-## eigenvalues themselves are returned in @var{d} in the form of a
-## @var{n}-by-@var{k} matrix, where the elements on the diagonal are the
-## eigenvalues.
+## requested.  With a single return argument, a vector @var{d} of length
+## @var{k} is returned containing the @var{k} eigenvalues that have been
+## found.  With two return arguments, @var{V} is a @var{n}-by-@var{k} matrix
+## whose columns are the @var{k} eigenvectors corresponding to the returned
+## eigenvalues.  The eigenvalues themselves are returned in @var{d} in the
+## form of a @var{n}-by-@var{k} matrix, where the elements on the diagonal
+## are the eigenvalues.
 ##
 ## Given a third return argument @var{flag}, @code{eigs} returns the status
 ## of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.
 ## Any other value indicates a failure to converge.
 ##
 ## This function is based on the @sc{arpack} package, written by
 ## @nospell{R. Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang}.  For more
 ## information see @url{http://www.caam.rice.edu/software/ARPACK/}.
diff --git a/scripts/sparse/ilu.m b/scripts/sparse/ilu.m
--- a/scripts/sparse/ilu.m
+++ b/scripts/sparse/ilu.m
@@ -149,17 +149,18 @@
 ## opts.droptol = 1e-4;
 ## [L, U] = ilu (A, opts);
 ## x = bicg (A, b, tol, maxit, L, U);
 ## norm (A * x - b, inf)
 ## @end group
 ## @end example
 ##
 ## This example uses ILU as preconditioner for a random FEM-Matrix, which has a
-## large condition number.  Without @var{L} and @var{U} BICG would not converge.
+## large condition number.  Without @var{L} and @var{U} BICG would not
+## converge.
 ##
 ## @seealso{lu, ichol, bicg, gmres}
 ## @end deftypefn
 
 function [L, U, P] = ilu (A, opts = struct ())
 
   if (nargin < 1 || nargin > 2 || (nargout > 3))
     print_usage ();
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -21,17 +21,18 @@
 ## @deftypefnx {} {[@var{pf}, @var{n}] =} factor (@var{q})
 ## Return the prime factorization of @var{q}.
 ##
 ## The prime factorization is defined as @code{prod (@var{pf}) == @var{q}}
 ## where every element of @var{pf} is a prime number.  If @code{@var{q} == 1},
 ## return 1.
 ##
 ## With two output arguments, return the unique prime factors @var{pf} and
-## their multiplicities.  That is, @code{prod (@var{pf} .^ @var{n}) == @var{q}}.
+## their multiplicities.  That is,
+## @code{prod (@var{pf} .^ @var{n}) == @var{q}}.
 ##
 ## Implementation Note: The input @var{q} must be less than
 ## @code{flintmax} (9.0072e+15) in order to factor correctly.
 ## @seealso{gcd, lcm, isprime, primes}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -13,17 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} factorial (@var{n})
-## Return the factorial of @var{n} where @var{n} is a real non-negative integer.
+## Return the factorial of @var{n} where @var{n} is a real non-negative
+## integer.
 ##
 ## If @var{n} is a scalar, this is equivalent to @code{prod (1:@var{n})}.  For
 ## vector or matrix arguments, return the factorial of each element in the
 ## array.
 ##
 ## For non-integers see the generalized factorial function @code{gamma}.
 ## Note that the factorial function grows large quite quickly, and even
 ## with double precision values overflow will occur if @var{n} > 171.  For
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -149,18 +149,18 @@
 ## @deftypefnx {} {@var{a} =} gallery ("integerdata", @var{imax}, @var{M}, @var{N}, @dots{}, @var{j})
 ## @deftypefnx {} {@var{a} =} gallery ("integerdata", [@var{imin}, @var{imax}], [@var{M} @var{N} @dots{}], @var{j})
 ## @deftypefnx {} {@var{a} =} gallery ("integerdata", [@var{imin}, @var{imax}], @var{M}, @var{N}, @dots{}, @var{j})
 ## @deftypefnx {} {@var{a} =} gallery ("integerdata", @dots{}, "@var{class}")
 ## Create a matrix with random integers in the range [1, @var{imax}].
 ## If @var{imin} is given then the integers are in the range
 ## [@var{imin}, @var{imax}].
 ##
-## The second input is a matrix of dimensions describing the size of the output.
-## The dimensions can also be input as comma-separated arguments.
+## The second input is a matrix of dimensions describing the size of the
+## output.  The dimensions can also be input as comma-separated arguments.
 ##
 ## The input @var{j} is an integer index in the range [0, 2^32-1].  The values
 ## of the output matrix are always exactly the same (reproducibility) for a
 ## given size input and @var{j} index.
 ##
 ## The final optional argument determines the class of the resulting matrix.
 ## Possible values for @var{class}: @qcode{"uint8"}, @qcode{"uint16"},
 ## @qcode{"uint32"}, @qcode{"int8"}, @qcode{"int16"}, int32", @qcode{"single"},
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -19,17 +19,18 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {} hankel (@var{c})
 ## @deftypefnx {} {} hankel (@var{c}, @var{r})
 ## Return the Hankel matrix constructed from the first column @var{c}, and
 ## (optionally) the last row @var{r}.
 ##
 ## If the last element of @var{c} is not the same as the first element of
 ## @var{r}, the last element of @var{c} is used.  If the second argument is
-## omitted, it is assumed to be a vector of zeros with the same size as @var{c}.
+## omitted, it is assumed to be a vector of zeros with the same size as
+## @var{c}.
 ##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector @var{r},
 ## has the elements
 ## @tex
 ## $$
 ## H(i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -19,31 +19,31 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{n} =} histc (@var{x}, @var{edges})
 ## @deftypefnx {} {@var{n} =} histc (@var{x}, @var{edges}, @var{dim})
 ## @deftypefnx {} {[@var{n}, @var{idx}] =} histc (@dots{})
 ## Compute histogram counts.
 ##
 ## When @var{x} is a vector, the function counts the number of elements of
-## @var{x} that fall in the histogram bins defined by @var{edges}.  This must be
-## a vector of monotonically increasing values that define the edges of the
-## histogram bins.  @code{@var{n}(k)} contains the number of elements in
-## @var{x} for which @code{@var{edges}(k) <= @var{x} < @var{edges}(k+1)}.
+## @var{x} that fall in the histogram bins defined by @var{edges}.  This
+## must be a vector of monotonically increasing values that define the edges
+## of the histogram bins.  @code{@var{n}(k)} contains the number of elements
+## in @var{x} for which @code{@var{edges}(k) <= @var{x} < @var{edges}(k+1)}.
 ## The final element of @var{n} contains the number of elements of @var{x}
 ## exactly equal to the last element of @var{edges}.
 ##
 ## When @var{x} is an @math{N}-dimensional array, the computation is carried
 ## out along dimension @var{dim}.  If not specified @var{dim} defaults to the
 ## first non-singleton dimension.
 ##
 ## When a second output argument is requested an index matrix is also returned.
-## The @var{idx} matrix has the same size as @var{x}.  Each element of @var{idx}
-## contains the index of the histogram bin in which the corresponding element
-## of @var{x} was counted.
+## The @var{idx} matrix has the same size as @var{x}.  Each element of
+## @var{idx} contains the index of the histogram bin in which the
+## corresponding element of @var{x} was counted.
 ## @seealso{hist}
 ## @end deftypefn
 
 function [n, idx] = histc (x, edges, dim)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -36,17 +36,18 @@
 ## $b$ is a $k \times p$ matrix, and $e$ is a $t \times p$ matrix.
 ## @end tex
 ## @ifnottex
 ## @math{y} is a @math{t} by @math{p} matrix, @math{x} is a @math{t} by @math{k}
 ## matrix, @math{b} is a @math{k} by @math{p} matrix, and @math{e} is a
 ## @math{t} by @math{p} matrix.
 ## @end ifnottex
 ##
-## Each row of @var{y} and @var{x} is an observation and each column a variable.
+## Each row of @var{y} and @var{x} is an observation and each column a
+## variable.
 ##
 ## The return values @var{beta}, @var{sigma}, and @var{r} are defined as
 ## follows.
 ##
 ## @table @var
 ## @item beta
 ## The OLS estimator for @math{b}.
 ## @tex
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -15,17 +15,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} finv (@var{x}, @var{m}, @var{n})
 ## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the F distribution with @var{m} and @var{n} degrees of freedom.
+## at @var{x} of the F distribution with @var{m} and @var{n} degrees of
+## freedom.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the F distribution
 
 function inv = finv (x, m, n)
 
   if (nargin != 3)
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -15,17 +15,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} fpdf (@var{x}, @var{m}, @var{n})
 ## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the F distribution with @var{m} and @var{n} degrees of freedom.
+## at @var{x} of the F distribution with @var{m} and @var{n} degrees of
+## freedom.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the F distribution
 
 function pdf = fpdf (x, m, n)
 
   if (nargin != 3)
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -32,17 +32,18 @@
 ##
 ## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
 ##
 ## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group of
 ## ties where @var{t} is the number of ties in the group and @var{n} is the
 ## total number of values in the input data.  For more info on this
 ## adjustment see @nospell{William H. Kruskal and W. Allen Wallis},
 ## @cite{Use of Ranks in One-Criterion Variance Analysis},
-## Journal of the American Statistical Association, Vol. 47, No. 260 (Dec 1952).
+## Journal of the American Statistical Association, Vol. 47, No. 260 (Dec
+## 1952).
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{k}) is returned
 ## in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -14,17 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {[@var{n}, @var{s}] =} weekday (@var{d})
 ## @deftypefnx {} {[@var{n}, @var{s}] =} weekday (@var{d}, @var{format})
-## Return the day of the week as a number in @var{n} and as a string in @var{s}.
+## Return the day of the week as a number in @var{n} and as a string in
+## @var{s}.
 ##
 ## The days of the week are numbered 1--7 with the first day being Sunday.
 ##
 ## @var{d} is a serial date number or a date string.
 ##
 ## If the string @var{format} is not present or is equal to @qcode{"short"}
 ## then @var{s} will contain the abbreviated name of the weekday.  If
 ## @var{format} is @qcode{"long"} then @var{s} will contain the full name.
