# HG changeset patch
# User jwe
# Date 948265163 0
#      Wed Jan 19 06:59:23 2000 +0000
# Node ID 434790acb067ccfc285ffee13fa90788dcdaebf9
# Parent  f758be6e17301d7972ecf5a0975e034f82627d83
[project @ 2000-01-19 06:58:51 by jwe]

diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -134,8 +134,180 @@ you would like to help improve Octave in
 
 @node Models, Distributions, Tests, Statistics
 @section Models
 
 @DOCSTRING(logistic_regression)
 
 @node Distributions,  , Models, Statistics
 @section Distributions
+
+@DOCSTRING(beta_cdf)
+
+@DOCSTRING(beta_inv)
+
+@DOCSTRING(beta_pdf)
+
+@DOCSTRING(beta_rnd)
+
+@DOCSTRING(binomial_cdf)
+
+@DOCSTRING(binomial_inv)
+
+@DOCSTRING(binomial_pdf)
+
+@DOCSTRING(binomial_rnd)
+
+@DOCSTRING(cauchy_cdf)
+
+@DOCSTRING(cauchy_inv)
+
+@DOCSTRING(cauchy_pdf)
+
+@DOCSTRING(cauchy_rnd)
+
+@DOCSTRING(chisquare_cdf)
+
+@DOCSTRING(chisquare_inv)
+
+@DOCSTRING(chisquare_pdf)
+
+@DOCSTRING(chisquare_rnd)
+
+@DOCSTRING(discrete_cdf)
+
+@DOCSTRING(discrete_inv)
+
+@DOCSTRING(discrete_pdf)
+
+@DOCSTRING(discrete_rnd)
+
+@DOCSTRING(empirical_cdf)
+
+@DOCSTRING(empirical_inv)
+
+@DOCSTRING(empirical_pdf)
+
+@DOCSTRING(empirical_rnd)
+
+@DOCSTRING(exponential_cdf)
+
+@DOCSTRING(exponential_inv)
+
+@DOCSTRING(exponential_pdf)
+
+@DOCSTRING(exponential_rnd)
+
+@DOCSTRING(f_cdf)
+
+@DOCSTRING(f_inv)
+
+@DOCSTRING(f_pdf)
+
+@DOCSTRING(f_rnd)
+
+@DOCSTRING(gamma_cdf)
+
+@DOCSTRING(gamma_inv)
+
+@DOCSTRING(gamma_pdf)
+
+@DOCSTRING(gamma_rnd)
+
+@DOCSTRING(geometric_cdf)
+
+@DOCSTRING(geometric_inv)
+
+@DOCSTRING(geometric_pdf)
+
+@DOCSTRING(geometric_rnd)
+
+@DOCSTRING(hypergeometric_cdf)
+
+@DOCSTRING(hypergeometric_inv)
+
+@DOCSTRING(hypergeometric_pdf)
+
+@DOCSTRING(hypergeometric_rnd)
+
+@DOCSTRING(kolmogorov_smirnov_cdf)
+
+@DOCSTRING(laplace_cdf)
+
+@DOCSTRING(laplace_inv)
+
+@DOCSTRING(laplace_pdf)
+
+@DOCSTRING(laplace_rnd)
+
+@DOCSTRING(logistic_cdf)
+
+@DOCSTRING(logistic_inv)
+
+@DOCSTRING(logistic_pdf)
+
+@DOCSTRING(logistic_rnd)
+
+@DOCSTRING(lognormal_cdf)
+
+@DOCSTRING(lognormal_inv)
+
+@DOCSTRING(lognormal_pdf)
+
+@DOCSTRING(lognormal_rnd)
+
+@DOCSTRING(normal_cdf)
+
+@DOCSTRING(normal_inv)
+
+@DOCSTRING(normal_pdf)
+
+@DOCSTRING(normal_rnd)
+
+@DOCSTRING(pascal_cdf)
+
+@DOCSTRING(pascal_inv)
+
+@DOCSTRING(pascal_pdf)
+
+@DOCSTRING(pascal_rnd)
+
+@DOCSTRING(poisson_cdf)
+
+@DOCSTRING(poisson_inv)
+
+@DOCSTRING(poisson_pdf)
+
+@DOCSTRING(poisson_rnd)
+
+@DOCSTRING(stdnormal_cdf)
+
+@DOCSTRING(stdnormal_inv)
+
+@DOCSTRING(stdnormal_pdf)
+
+@DOCSTRING(stdnormal_rnd)
+
+@DOCSTRING(t_cdf)
+
+@DOCSTRING(t_inv)
+
+@DOCSTRING(t_pdf)
+
+@DOCSTRING(t_rnd)
+
+@DOCSTRING(uniform_cdf)
+
+@DOCSTRING(uniform_inv)
+
+@DOCSTRING(uniform_pdf)
+
+@DOCSTRING(uniform_rnd)
+
+@DOCSTRING(weibull_cdf)
+
+@DOCSTRING(weibull_inv)
+
+@DOCSTRING(weibull_pdf)
+
+@DOCSTRING(weibull_rnd)
+
+@DOCSTRING(wiener_rnd)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,97 @@
+2000-01-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* statistics/distributions/beta_cdf.m: Texinfoize doc string.
+	* statistics/distributions/beta_inv.m: Ditto.
+	* statistics/distributions/beta_pdf.m: Ditto.
+	* statistics/distributions/beta_rnd.m: Ditto.
+	* statistics/distributions/binomial_cdf.m: Ditto.
+	* statistics/distributions/binomial_inv.m: Ditto.
+	* statistics/distributions/binomial_pdf.m: Ditto.
+	* statistics/distributions/binomial_rnd.m: Ditto.
+	* statistics/distributions/cauchy_cdf.m: Ditto.
+	* statistics/distributions/cauchy_inv.m: Ditto.
+	* statistics/distributions/cauchy_pdf.m: Ditto.
+	* statistics/distributions/cauchy_rnd.m: Ditto.
+	* statistics/distributions/chisquare_cdf.m: Ditto.
+	* statistics/distributions/chisquare_inv.m: Ditto.
+	* statistics/distributions/chisquare_pdf.m: Ditto.
+	* statistics/distributions/chisquare_rnd.m: Ditto.
+	* statistics/distributions/discrete_cdf.m: Ditto.
+	* statistics/distributions/discrete_inv.m: Ditto.
+	* statistics/distributions/discrete_pdf.m: Ditto.
+	* statistics/distributions/discrete_rnd.m: Ditto.
+	* statistics/distributions/empirical_cdf.m: Ditto.
+	* statistics/distributions/empirical_inv.m: Ditto.
+	* statistics/distributions/empirical_pdf.m: Ditto.
+	* statistics/distributions/empirical_rnd.m: Ditto.
+	* statistics/distributions/exponential_cdf.m: Ditto.
+	* statistics/distributions/exponential_inv.m: Ditto.
+	* statistics/distributions/exponential_pdf.m: Ditto.
+	* statistics/distributions/exponential_rnd.m: Ditto.
+	* statistics/distributions/f_cdf.m: Ditto.
+	* statistics/distributions/f_inv.m: Ditto.
+	* statistics/distributions/f_pdf.m: Ditto.
+	* statistics/distributions/f_rnd.m: Ditto.
+	* statistics/distributions/gamma_cdf.m: Ditto.
+	* statistics/distributions/gamma_inv.m: Ditto.
+	* statistics/distributions/gamma_pdf.m: Ditto.
+	* statistics/distributions/gamma_rnd.m: Ditto.
+	* statistics/distributions/geometric_cdf.m: Ditto.
+	* statistics/distributions/geometric_inv.m: Ditto.
+	* statistics/distributions/geometric_pdf.m: Ditto.
+	* statistics/distributions/geometric_rnd.m: Ditto.
+	* statistics/distributions/hypergeometric_cdf.m: Ditto.
+	* statistics/distributions/hypergeometric_inv.m: Ditto.
+	* statistics/distributions/hypergeometric_pdf.m: Ditto.
+	* statistics/distributions/hypergeometric_rnd.m: Ditto.
+	* statistics/distributions/kolmogorov_smirnov_cdf.m: Ditto.
+	* statistics/distributions/laplace_cdf.m: Ditto.
+	* statistics/distributions/laplace_inv.m: Ditto.
+	* statistics/distributions/laplace_pdf.m: Ditto.
+	* statistics/distributions/laplace_rnd.m: Ditto.
+	* statistics/distributions/logistic_cdf.m: Ditto.
+	* statistics/distributions/logistic_inv.m: Ditto.
+	* statistics/distributions/logistic_pdf.m: Ditto.
+	* statistics/distributions/logistic_rnd.m: Ditto.
+	* statistics/distributions/lognormal_cdf.m: Ditto.
+	* statistics/distributions/lognormal_inv.m: Ditto.
+	* statistics/distributions/lognormal_pdf.m: Ditto.
+	* statistics/distributions/lognormal_rnd.m: Ditto.
+	* statistics/distributions/normal_cdf.m: Ditto.
+	* statistics/distributions/normal_inv.m: Ditto.
+	* statistics/distributions/normal_pdf.m: Ditto.
+	* statistics/distributions/normal_rnd.m: Ditto.
+	* statistics/distributions/pascal_cdf.m: Ditto.
+	* statistics/distributions/pascal_inv.m: Ditto.
+	* statistics/distributions/pascal_pdf.m: Ditto.
+	* statistics/distributions/pascal_rnd.m: Ditto.
+	* statistics/distributions/poisson_cdf.m: Ditto.
+	* statistics/distributions/poisson_inv.m: Ditto.
+	* statistics/distributions/poisson_pdf.m: Ditto.
+	* statistics/distributions/poisson_rnd.m: Ditto.
+	* statistics/distributions/stdnormal_cdf.m: Ditto.
+	* statistics/distributions/stdnormal_inv.m: Ditto.
+	* statistics/distributions/stdnormal_pdf.m: Ditto.
+	* statistics/distributions/stdnormal_rnd.m: Ditto.
+	* statistics/distributions/t_cdf.m: Ditto.
+	* statistics/distributions/t_inv.m: Ditto.
+	* statistics/distributions/t_pdf.m: Ditto.
+	* statistics/distributions/t_rnd.m: Ditto.
+	* statistics/distributions/uniform_cdf.m: Ditto.
+	* statistics/distributions/uniform_inv.m: Ditto.
+	* statistics/distributions/uniform_pdf.m: Ditto.
+	* statistics/distributions/uniform_rnd.m: Ditto.
+	* statistics/distributions/weibull_cdf.m: Ditto.
+	* statistics/distributions/weibull_inv.m: Ditto.
+	* statistics/distributions/weibull_pdf.m: Ditto.
+	* statistics/distributions/weibull_rnd.m: Ditto.
+	* statistics/distributions/wiener_rnd.m: Ditto.
+
 2000-01-18  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* statistics/base/values.m: Texinfoize doc string.
 	* statistics/base/var.m: Ditto.
 	* statistics/base/table.m: Ditto.
 	* statistics/base/studentize.m: Ditto.
 	* statistics/base/statistics.m: Ditto.
 	* statistics/base/spearman.m: Ditto.
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -34,17 +34,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
 
 function X = loadaudio (name, ext, bit)
 
   if (nargin == 0 || nargin > 3)
-    usage ("loadaudio (name [, ext [, bit]])");
+    usage ("loadaudio (name, ext, bit)");
   endif
 
   if (nargin == 1)
     ext = "lin";
   endif
 
   if (nargin < 3)
     bit = 8;
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -34,17 +34,17 @@ function y = mu2lin (x, bit)
 
   if (nargin == 1)
     bit = 8;
   elseif (nargin == 2)
     if (bit != 8 && bit != 16)
       error ("mu2lin: bit must be either 8 or 16");
     endif
   else
-    usage ("y = mu2lin (x [, bit])");
+    usage ("y = mu2lin (x, bit)");
   endif
 
   if (! is_vector (x))
     error ("mu2lin: x must be a vector");
   endif
 
   exp_lut = [0; 132; 396; 924; 1980; 4092; 8316; 16764];
 
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -26,17 +26,17 @@
 ## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
-  usage_msg = "playaudio (name [, ext])  or  playaudio (X)";
+  usage_msg = "playaudio (name, ext)  or  playaudio (X)";
 
   if (nargin == 1 && is_vector (name) && ! isstr (name))
     ## play a vector
     [nr, nc] = size (name);
     if (nc != 1)
       if (nr == 1)
         name = name';
         nr = nc;
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -29,17 +29,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 September 1994
 ## Adapted-By: jwe
 
 function saveaudio (name, X, ext, bit)
 
   if (nargin < 2 || nargin > 4)
-    usage ("saveaudio (X, name [, ext [, bit]])");
+    usage ("saveaudio (X, name, ext, bit)");
   endif
 
   if (nargin == 2)
     ext = "lin";
   endif
 
   if (nargin < 4)
     bit = 8;
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -31,12 +31,12 @@ function setaudio (w_type, value)
 
   if (nargin == 0)
     system ("mixer");
   elseif (nargin == 1)
     system (sprintf ("mixer %s", w_type));
   elseif (nargin == 2)
     system (sprintf ("mixer %s %d", w_type, value));
   else
-    usage ("setaudio ([w_type [, value]])");
+    usage ("setaudio (w_type, value)");
   endif
 
 endfunction
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -32,36 +32,36 @@
 ## @end deftypefn
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Future value of an investment
 
 function v = fv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("fv (r, n, p [, l] [, method])");
+    usage ("fv (r, n, p, l, method)");
   endif
 
-  if !(is_scalar (r) && (r > -1))
+  if (! (is_scalar (r) && (r > -1)))
     error ("fv:  r must be a scalar > -1");
-  elseif !(is_scalar (n) && (n > 0))
+  elseif (! (is_scalar (n) && (n > 0)))
     error ("fv:  n must be a positive scalar");
-  elseif !is_scalar (p)
+  elseif (! is_scalar (p))
     error ("fv:  p must be a scalar.");
   endif
 
   if (r != 0)
     v = p * ((1 + r)^n - 1) / r;
   else
     v = p * n;
   endif
 
   if (nargin > 3)
     if (nargin == 5)
-      if !isstr (m)
+      if (! isstr (m))
         error ("fv:  `method' must be a string");
       endif
     elseif isstr (l)
       m = l;
       l = 0;
     else
       m = "e";
     endif
diff --git a/scripts/finance/fvl.m b/scripts/finance/fvl.m
--- a/scripts/finance/fvl.m
+++ b/scripts/finance/fvl.m
@@ -28,19 +28,19 @@
 ## Description:  Future value of an initial lump sum investment
 
 function v = fvl (r, n, l)
 
   if (nargin != 3)
     usage ("fvl (r, n, l)");
   endif
 
-  if !(is_scalar (r) && (r > -1))
+  if (! (is_scalar (r) && (r > -1)))
     error ("fvl:  r has to be a scalar > -1");
-  elseif !(is_scalar (n) && (n > 0))
+  elseif (! (is_scalar (n) && (n > 0)))
     error ("fvl:  n has to be a positive scalar");
-  elseif !is_scalar (l)
+  elseif (! is_scalar (l))
     error ("fvl:  l has to be a scalar");
   endif
 
   v = l * (1 + r)^n;
 
 endfunction
\ No newline at end of file
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -25,33 +25,25 @@
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Internal rate of return of an investment
 
 function r = irr (p, i)
 
   if (nargin == 1)
     i = 0;
-  elseif !(nargin == 2)
-    usage ("irr (p [, i])");
+  elseif (! (nargin == 2))
+    usage ("irr (p, i)");
   endif
 
-  tmp = output_precision;
-  output_precision = 15;
-  if !(is_vector (p))
+  if (! (is_vector (p)))
     error ("irr:  p must be a vector");
   else
-    p_string = type p;
+    p_string = strcat ("[", sprintf ("%.15f, ", p), "]");
   endif
 
-  if !is_scalar (i)
+  if (! is_scalar (i))
     error ("irr:  i must be a scalar");
   endif
 
-  string = ["function delta = f (r) ", ...
-      "delta = npv (r, %s) - %g;  end"];
-  eval (sprintf (string, p_string, i));
-
-  r = fsolve ("f", 0.01);
-
-  output_precision = tmp;
+  r = fsolve (sprintf ("npv (x, %s) - %g", p_string, i), 0.01);
 
 endfunction
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -32,44 +32,44 @@
 ## @seealso{pv, pmt, rate, and npv}
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("nper (r, p, a [, l] [, method])");
+    usage ("nper (r, p, a, l, method)");
   endif
 
-  if !(is_scalar (r) && (r > -1))
+  if (! (is_scalar (r) && (r > -1)))
     error ("nper:  r must be a scalar > -1");
-  elseif !is_scalar (p)
+  elseif (! is_scalar (p))
     error ("nper:  p must be a scalar");
-  elseif !is_scalar (a)
+  elseif (! is_scalar (a))
     error ("nper:  a must be a scalar");
   endif
 
   if (nargin == 5)
-    if !isstr (m)
+    if (! isstr (m))
       error ("nper:  `method' must be a string");
     endif
   elseif (nargin == 4)
-    if isstr (l)
+    if (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     m = "e";
     l = 0;
   endif
 
-  if strcmp (m, "b")
+  if (strcmp (m, "b"))
     p = p * (1 + r);
   endif
 
   q = (p - r * a) / (p - r * l);
 
   if (q > 0)
     n = - log (q) / log (1 + r);
   else
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -31,39 +31,39 @@
 ## @seealso{irr and pv}
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Net present value of a series of payments
 
 function v = npv (r, p, i)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("npv (r, p [, i]");
+    usage ("npv (r, p, i");
   endif
 
-  if !(is_vector (p))
+  if (! (is_vector (p)))
     error ("npv:  p has to be a vector");
   else
     n = length (p);
     p = reshape (p, 1, n);
   endif
 
-  if any (any (r <= -1))
+  if (any (any (r <= -1)))
     error ("npv:  all interest rates must be > -1");
   endif
-  if is_scalar (r)
+  if (is_scalar (r))
     d = 1 ./ (1 + r) .^ (0 : n);
   elseif (is_vector (r) && (length (r) == n))
     d = [1, (1 ./ cumprod (reshape (1 + r, 1, n)))];
   else
     error ("npv: r must be a scalar or a vector of the same length as p");
   endif
 
   if (nargin == 3)
-    if !is_scalar (i)
+    if (! is_scalar (i))
       error ("npv:  I_0 must be a scalar");
     endif
   else
     i = 0;
   endif
 
   p = [i, p];
   v = sum (d .* p);
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -29,46 +29,46 @@
 ## @seealso{pv, nper, and rate}
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("pmt (r, n, a [, l] [, method])");
+    usage ("pmt (r, n, a, l, method)");
   endif
 
-  if !(is_scalar (r) && (r > -1))
+  if (! (is_scalar (r) && (r > -1)))
     error ("pmt:  rate must be a scalar > -1");
-  elseif !(is_scalar (n) && (n > 0))
+  elseif (! (is_scalar (n) && (n > 0)))
     error ("pmt:  n must be a positive scalar");
-  elseif !(is_scalar (a) && (a > 0))
+  elseif (! (is_scalar (a) && (a > 0)))
     error ("pmt:  a must be a positive scalar.");
   endif
 
   if (nargin == 5)
-    if !isstr (m)
+    if (! isstr (m))
       error ("pmt:  `method' must be a string");
     endif
   elseif (nargin == 4)
-    if isstr (l)
+    if (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
   endif
 
   p = r * (a - l * (1 + r)^(-n)) / (1 - (1 + r)^(-n));
 
-  if strcmp (m, "b")
+  if (strcmp (m, "b"))
     p = p / (1 + r);
   endif
 
 
 endfunction
 
 
 
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -32,48 +32,48 @@
 ## @seealso{pmt, nper, rate, and npv}
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Present value of an investment
 
 function v = pv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("pv (r, n, p [, l] [, method])");
+    usage ("pv (r, n, p, l, method)");
   endif
 
-  if !(is_scalar (r) && (r > -1))
+  if (! (is_scalar (r) && (r > -1)))
     error ("pv:  r must be a scalar > -1");
-  elseif !(is_scalar (n) && (n > 0))
+  elseif (! (is_scalar (n) && (n > 0)))
     error ("pv:  n must be a positive scalar");
-  elseif !is_scalar (p)
+  elseif (! is_scalar (p))
     error ("pv:  p must be a scalar.");
   endif
 
   if (r != 0)
     v = p * (1 - (1 + r)^(-n)) / r;
   else
     v = p * n;
   endif
 
   if (nargin > 3)
     if (nargin == 5)
-      if !isstr (m)
+      if (! isstr (m))
         error ("pv:  `method' must be a string");
       endif
-    elseif isstr (l)
+    elseif (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
-    if strcmp (m, "b")
+    if (strcmp (m, "b"))
       v = v * (1 + r);
     endif
-    if is_scalar (l)
+    if (is_scalar (l))
       v = v + pvl (r, n, l);
     else
       error ("pv:  l must be a scalar");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/finance/pvl.m b/scripts/finance/pvl.m
--- a/scripts/finance/pvl.m
+++ b/scripts/finance/pvl.m
@@ -28,19 +28,19 @@
 ## Description:  Present value of an investment that pays off at the end
 
 function v = pvl (r, n, p)
 
   if (nargin != 3)
     usage ("pvl (r, n, p)");
   endif
 
-  if !(is_scalar (r) && (r > -1))
+  if (! (is_scalar (r) && (r > -1)))
     error ("pvl:  r has to be a scalar > -1");
-  elseif !(is_scalar (n) && (n > 0))
+  elseif (! (is_scalar (n) && (n > 0)))
     error ("pvl:  n has to be a positive scalar");
-  elseif !is_scalar (p)
+  elseif (! is_scalar (p))
     error ("pvl:  p has to be a scalar");
   endif
 
   v = p / (1 + r)^n;
 
 endfunction
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -29,46 +29,43 @@
 ## @seealso{pv, pmt, nper, and npv}
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Rate of return of an investment
 
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("rate (n, p, v [, l] [, method])");
+    usage ("rate (n, p, v, l, method)");
   endif
 
-  if !(is_scalar (n) && (n > 0))
+  if (! (is_scalar (n) && (n > 0)))
     error ("rate:  n must be a positive scalar");
-  elseif !is_scalar (p)
+  elseif (! is_scalar (p))
     error ("rate:  p must be a scalar");
-  elseif !is_scalar (v)
+  elseif (! is_scalar (v))
     error ("rate:  p must be a scalar");
   endif
 
   if (nargin == 5)
-    if !isstr (m)
+    if (! isstr (m))
       error ("rate:  `method' must be a string");
     endif
   elseif (nargin == 4)
-    if isstr (l)
+    if (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
   endif
 
-  if !is_scalar (l)
+  if (! is_scalar (l))
     error ("rate:  l must be a scalar");
   endif
 
-  string = ["function delta = f (r) ", ...
-      "delta = pv (r, %g, %g, %g, \"%s\") - %g;  end"];
-  eval (sprintf (string, n, p, l, m, v));
-
-  [r, info] = fsolve ("f", 0);
+  [r, info] = fsolve (sprintf ("pv (x, %g, %g, %g, \"%s\") - %g",
+			       n, p, l, m, v), 0);
 
 endfunction
diff --git a/scripts/finance/vol.m b/scripts/finance/vol.m
--- a/scripts/finance/vol.m
+++ b/scripts/finance/vol.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Volatility of financial time series data
 
 function retval = vol (X, m, n)
 
   if (nargin < 2)
-    usage ("vol (X, m [, n])");
+    usage ("vol (X, m, n)");
   endif
 
   [xr, xc] = size (X);
 
   if (nargin > 2)
     if (n * m > xr)
       error ("vol:  I need more data!");
     endif
@@ -44,17 +44,17 @@ function retval = vol (X, m, n)
     n = 1;
     if (n * m > xr)
       error ("vol:  I need more data!");
     endif
   endif
 
   U = zeros (xr - 1, xc);
 
-  if all (X)
+  if (all (X))
     U = X ((2 : xr), :) ./ X((1 : (xr-1)), :);
   else
     error ("vol:  zero element in X");
   endif
 
   U = log(U);
   U = U - ones (xr - 1, 1) * sum (U) / (xr - 1);
 
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -45,17 +45,17 @@ function x = diff (x, k)
     k = 1;
   elseif (nargin == 2)
     if (! (is_scalar (k) && k == round (k) && k >= 0))
       error ("diff: k must be a nonnegative integer");
     elseif (k == 0)
       return;
     endif
   else
-    usage ("diff (x [, k]");
+    usage ("diff (x, k");
   endif
 
   if (isstr (x))
     error ("diff: symbolic differentiation not (yet) supported");
   elseif (is_vector (x))
     n = length (x);
     if (n <= k)
       x = [];
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -69,17 +69,17 @@ function retval = logspace (x1, x2, n)
     npoints = 50;
   elseif (nargin == 3)
     if (length (n) == 1)
       npoints = fix (n);
     else
       error ("logspace: arguments must be scalars");
     endif
   else
-    usage ("logspace (x1, x2 [, n])");
+    usage ("logspace (x1, x2, n)");
   endif
 
   if (npoints < 2)
     error ("logspace: npoints must be greater than 2");
   endif
 
   if (length (x1) == 1 && length (x2) == 1)
     x2_tmp = x2;
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -73,12 +73,12 @@ function y = rot90 (x, k)
     elseif (k == 2)
       y = flipud (fliplr (x));
     elseif (k == 3)
       y = (flipud (x)).';
     else
       error ("rot90: internal error!");
     endif
   else
-    usage ("rot90 (x [, k])");
+    usage ("rot90 (x, k)");
   endif
 
 endfunction
diff --git a/scripts/general/tril.m b/scripts/general/tril.m
--- a/scripts/general/tril.m
+++ b/scripts/general/tril.m
@@ -73,17 +73,17 @@ function retval = tril (x, k)
 
   if (nargin == 1)
     k = 0;
   elseif (nargin == 2)
     if ((k > 0 && k > nc) || (k < 0 && k < -nr))
       error ("tril: requested diagonal out of range");
     endif
   else
-    usage ("tril (x [, k])");
+    usage ("tril (x, k)");
   endif
 
   for j = 1 : min (nc, nr+k)
     nr_limit = max (1, j-k);
     retval (nr_limit:nr, j) = x (nr_limit:nr, j);
   endfor
 
 endfunction
diff --git a/scripts/general/triu.m b/scripts/general/triu.m
--- a/scripts/general/triu.m
+++ b/scripts/general/triu.m
@@ -30,17 +30,17 @@ function retval = triu (x, k)
 
   if (nargin == 1)
     k = 0;
   elseif (nargin == 2)
     if ((k > 0 && k > nc) || (k < 0 && k < -nr))
       error ("triu: requested diagonal out of range");
     endif
   else
-    usage ("triu (x [, k])");
+    usage ("triu (x, k)");
   endif
 
   for j = max (1, k+1) : nc
     nr_limit = min (nr, j-k);
     retval (1:nr_limit, j) = x (1:nr_limit, j);
   endfor
 
 endfunction
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -79,17 +79,17 @@
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function k = commutation_matrix (m, n)
 
   if (nargin < 1 || nargin > 2)
-    usage ("commutation_matrix (m [, n])");
+    usage ("commutation_matrix (m, n)");
   else
     if (! (is_scalar (m) && m == round (m) && m > 0))
       error ("commutation_matrix: m must be a positive integer");
     endif
     if (nargin == 1)
       n = m;
     elseif (! (is_scalar (n) && n == round (n) && n > 0))
       error ("commutation_matrix: n must be a positive integer");
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -55,17 +55,17 @@
 ## @end deftypefn
 ## @seealso{cond and svd}
 
 ## Author: jwe
 
 function retval = norm (x, p)
 
   if (nargin < 1 || nargin > 2)
-    error ("usage: norm (x [, p])");
+    error ("usage: norm (x, p)");
   endif
 
   if (isempty (x))
     retval = [];
     return;
   endif
 
   ## Do we have a vector or matrix as the first argument?
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -46,17 +46,17 @@ function retval = null (A, tol)
     s = S(1);
   else
     s = diag (S);
   endif
 
   if (nargin == 1)
     tol = max (size (A)) * s (1) * eps;
   elseif (nargin != 2)
-    usage ("null (A [, tol])");
+    usage ("null (A, tol)");
   endif
 
   rank = sum (s > tol);
 
   if (rank < cols)
     retval = V (:, rank+1:cols);
   else
     retval = zeros (cols, 0);
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -59,13 +59,13 @@ function retval = orth (A, tol)
     if (rank > 0)
       retval = -U (:, 1:rank);
     else
       retval = zeros (rows, 0);
     endif
 
   else
 
-    usage ("orth (a [, tol]");
+    usage ("orth (a, tol");
 
   endif
 
 endfunction
diff --git a/scripts/plot/__plr__.m b/scripts/plot/__plr__.m
--- a/scripts/plot/__plr__.m
+++ b/scripts/plot/__plr__.m
@@ -120,12 +120,12 @@ function __plr__ (theta, rho, fmt)
           error ("polar: matrix dimensions must match");
         endif
         x = rho .* cos (theta);
         y = rho .* sin (theta);
         __plt2mm__ (x, y, fmt);
       endif
     endif
   else
-    usage ("__plr__ (x [, y])");
+    usage ("__plr__ (x, y)");
   endif
 
 endfunction
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -166,17 +166,17 @@ function [r, p, k, e] = residue (b, a, t
   ##
   ## | 4|   | 1 0 0 |   | r(1) |
   ## | 1| = | 0 0 1 | * | r(2) |
   ## |-2|   | 0 1 1 |   | r(3) |
   ##
   ## We then solve for the residues using matrix division.
 
   if (nargin < 2 || nargin > 3)
-    usage ("residue (b, a [, toler])");
+    usage ("residue (b, a, toler)");
   endif
 
   if (nargin == 2)
     toler = .001;
   endif
 
   ## Make sure both polynomials are in reduced form.
 
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -44,12 +44,12 @@
 
 function y = pow2 (f, e)
 
   if (nargin == 1)
     y = 2 .^ f;
   elseif (nargin == 2)
     y = f .* (2 .^ e);
   else
-    usage ("y = pow2 (f [, e])");
+    usage ("y = pow2 (f, e)");
   endif
 
 endfunction
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -15,26 +15,26 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} center (@var{x})
 ## If @var{x} is a vector, subtract its mean.
 ## If @var{x} is a matrix, do the above for each column.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Center by subtracting means
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Center by subtracting means
 
 function retval = center (x)
 
   if (nargin != 1)
     usage ("center (x)");
   endif
 
   if is_vector (x)
     retval = x - mean(x);
   elseif is_matrix (x)
     retval = x - ones (rows (x), 1) * mean(x);
   else
-    error ("center:  x must be a vector or a matrix.");
+    error ("center: x must be a vector or a matrix.");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -18,18 +18,18 @@
 ## @deftypefn {Function File} {} cloglog (@var{x})
 ## Return the complementary log-log function of @var{x}, defined as
 ##
 ## @example
 ## - log (- log (@var{x}))
 ## @end example
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Complementary log-log function
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Complementary log-log function
 
 function y = cloglog (x)
 
   if (nargin != 1)
     usage ("cloglog (x)");
   endif
 
   y = - log (- log (x));
diff --git a/scripts/statistics/base/cor.m b/scripts/statistics/base/cor.m
--- a/scripts/statistics/base/cor.m
+++ b/scripts/statistics/base/cor.m
@@ -21,23 +21,23 @@
 ## @var{j}-th variable in @var{y}.
 ##
 ## For matrices, each row is an observation and each column a variable;
 ## vectors are always observations and may be row or column vectors.
 ##
 ## @code{cor (@var{x})} is equivalent to @code{cor (@var{x}, @var{x})}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute correlations
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute correlations
 
 function retval = cor (x, y)
 
   if (nargin < 1 || nargin > 2)
-    usage ("cor (x [, y])");
+    usage ("cor (x, y)");
   endif
 
   if (nargin == 2)
     c = cov (x, y);
     s = std (x)' * std (y);
     retval = c ./ s;
   elseif (nargin == 1)
     c = cov (x);
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -18,23 +18,23 @@
 ## @deftypefn {Function File} {} cov (@var{x}, @var{y})
 ## If each row of @var{x} and @var{y} is an observation and each column is
 ## a variable, the (@var{i},@var{j})-th entry of
 ## @code{cov (@var{x}, @var{y})} is the covariance between the @var{i}-th
 ## variable in @var{x} and the @var{j}-th variable in @var{y}.  If called
 ## with one argument, compute @code{cov (@var{x}, @var{x})}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute covariances
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute covariances
 
 function c = cov (x, y)
 
   if (nargin < 1 || nargin > 2)
-    usage ("cov (x [, y])");
+    usage ("cov (x, y)");
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   n = rows (x);
 
   if (nargin == 2)
diff --git a/scripts/statistics/base/cut.m b/scripts/statistics/base/cut.m
--- a/scripts/statistics/base/cut.m
+++ b/scripts/statistics/base/cut.m
@@ -24,35 +24,35 @@
 ## the category has @code{length (@var{breaks}) - 1} groups.
 ##
 ## The returned value is a vector of the same size as @var{x} telling
 ## which group each point in @var{x} belongs to.  Groups are labelled
 ## from 1 to the number of groups; points outside the range of
 ## @var{breaks} are labelled by @code{NaN}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Cut data into intervals
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Cut data into intervals
 
 function group = cut (X, BREAKS)
 
   if (nargin != 2)
     usage ("cut (X, BREAKS)");
   endif
 
   if !is_vector (X)
-    error ("cut:  X must be a vector");
+    error ("cut: X must be a vector");
   endif
   if is_scalar (BREAKS)
     BREAKS = linspace (min (X), max (X), BREAKS + 1);
     BREAKS(1) = BREAKS(1) - 1;
   elseif is_vector (BREAKS)
     BREAKS = sort (BREAKS);
   else
-    error ("cut:  BREAKS must be a scalar or vector");
+    error ("cut: BREAKS must be a scalar or vector");
   endif
 
   group = NaN * ones (size (X));
   m = length (BREAKS);
   if any (k = find ((X >= min (BREAKS)) & (X <= max (BREAKS))))
     n = length (k);
     group(k) = sum ((ones (m, 1) * reshape (X(k), 1, n))
                     > (reshape (BREAKS, m, 1) * ones (1, n)));
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -66,17 +66,17 @@
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
 ## Adapted-By: jwe
 
 function [BETA, v, R] = gls (Y, X, O)
 
   if (nargin != 3)
-    usage ("[BETA, v [, R]] = gls (Y, X, O)");
+    usage ("[BETA, v, R] = gls (Y, X, O)");
   endif
 
   [rx, cx] = size (X);
   [ry, cy] = size (Y);
   if (rx != ry)
     error ("gls: incorrect matrix dimensions");
   endif
 
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -18,17 +18,17 @@
 ## @deftypefn {Function File} {} iqr (@var{x})
 ## If @var{x} is a vector, return the interquartile range, i.e., the
 ## difference between the upper and lower quartile, of the input data.
 ##
 ## If @var{x} is a matrix, do the above for each column of @var{x}.
 ## @end deftypefn
 
 ## Author KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Interquartile range
+## Description: Interquartile range
 
 function y = iqr (x)
 
   if (nargin != 1)
     usage ("iqr (x)");
   endif
 
   y = empirical_inv (3/4, x) - empirical_inv (1/4, x);
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -56,37 +56,36 @@
 ##  are the ranks of
 ## @var{x} and @var{y}, respectively.
 ##
 ## If @var{x} and @var{y} are drawn from independent distributions,
 ## Kendall's @var{tau} is asymptotically normal with mean 0 and variance
 ## @code{(2 * (2@var{n}+5)) / (9 * @var{n} * (@var{n}-1))}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Kendall's rank correlation tau
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Kendall's rank correlation tau
 
 function tau = kendall (x, y)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("kendall (x [, y])");
+    usage ("kendall (x, y)");
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   [n, c] = size (x);
 
   if (nargin == 2)
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
-      error (["kendall:  ", ...
-              "x and y must have the same number of observations"]);
+      error ("kendall: x and y must have the same number of observations");
     else
       x = [x, y];
     endif
   endif
 
   r   = ranks (x);
   m   = sign (kron (r, ones (n, 1)) - kron (ones (n, 1), r));
   tau = cor (m);
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -15,18 +15,18 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} logit (@var{p})
 ## For each component of @var{p}, return the logit @code{log (@var{p} /
 ## (1-@var{p}))} of @var{p}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Logit transformation
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Logit transformation
 
 function y = logit (p)
 
   if (nargin == 1)
     y = logistic_inv (p);
   else
     usage ("logit (p)");
   endif
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -41,27 +41,27 @@
 ## @item "g"
 ## Computer the geometric mean.
 ##
 ## @item "h"
 ## Compute the harmonic mean.
 ## @end table
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute arithmetic, geometric, and harmonic mean
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute arithmetic, geometric, and harmonic mean
 
 function y = mean (x, opt)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("mean (x [, opt])");
+    usage ("mean (x, opt])");
   endif
 
   if isempty (x)
-    error ("mean:  x must not be empty");
+    error ("mean: x must not be empty");
   endif
 
   if (rows (x) == 1)
     x = x.';
   endif
 
   if (nargin == 1)
     opt = "a";
@@ -79,12 +79,12 @@ function y = mean (x, opt)
     endif
   elseif (strcmp (opt, "h"))
     y = NaN * ones (1, c);
     i = find (all (x != 0));
     if any (i)
       y(i) = r ./ sum (1 ./ x(:, i));
     endif
   else
-    error (sprintf ("mean:  option `%s' not recognized", opt));
+    error ("mean: option `%s' not recognized", opt);
   endif
 
 endfunction
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -16,18 +16,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} meansq (@var{x})
 ## For vector arguments, return the mean square of the values.
 ## For matrix arguments, return a row vector contaning the mean square
 ## of each column.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute mean square
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute mean square
 
 function y = meansq (x)
 
   if (nargin != 1)
     usage ("meansq (x)");
   endif
 
   y = mean (x.^2);
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -31,28 +31,28 @@
 ##
 ## @noindent
 ## computes the third central absolute moment of @var{x}.
 ## @end deftypefn
 
 ## Can easily be made to work for continuous distributions (using quad)
 ## as well, but how does the general case work?
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute moments
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute moments
 
 function m = moment (x, p, opt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("moment (x, p [, type]")
+    usage ("moment (x, p, type");
   endif
 
   [nr, nc] = size (x);
   if (nr == 0 || nc == 0)
-    error ("moment:  x must not be empty");
+    error ("moment: x must not be empty");
   elseif (nr == 1)
     x  = reshape (x, nc, 1);
     nr = nc;
   endif
 
   if (nargin == 3)
     tmp = implicit_str_to_num_ok;
     implicit_str_to_num_ok = "true";
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -76,17 +76,17 @@
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
 ## Adapted-By: jwe
 
 function [BETA, SIGMA, R] = ols (Y, X)
 
   if (nargin != 2)
-    error("usage : [BETA, SIGMA [, R]] = ols (Y, X)");
+    usage ("[BETA, SIGMA, R] = ols (Y, X)");
   endif
 
   [nr, nc] = size (X);
   [ry, cy] = size (Y);
   if (nr != ry)
     error ("ols: incorrect matrix dimensions");
   endif
 
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -32,27 +32,27 @@
 ##
 ## @example
 ## ppplot (x, "uniform", 2, 4)
 ## @end example
 ##
 ## If no output arguments are given, the data are plotted directly.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Perform a PP-plot (probability plot)
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Perform a PP-plot (probability plot)
 
 function [p, y] = ppplot (x, dist, ...)
 
   if (nargin < 1)
-    usage ("ppplot (x [, dist [, params]])");
+    usage ("ppplot (x, dist, params)");
   endif
 
   if !is_vector (x)
-    error ("ppplot:  x must be a vector.");
+    error ("ppplot: x must be a vector.");
   endif
 
   s = sort (x);
   n = length (x);
   p = ((1 : n)' - 0.5) / n;
   if (nargin == 1)
     F = "stdnormal_cdf";
   else
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -16,17 +16,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} probit (@var{p})
 ## For each component of @var{p}, return the probit (the quantile of the
 ## standard normal distribution) of @var{p}.
 ## @end deftypefn
 
 ## Written by KH <Kurt.Hornik@ci.tuwien.ac.at> on 1995/02/04
-## Description:  Probit transformation
+## Description: Probit transformation
 
 function y = probit (p)
 
   if (nargin == 1)
     y = stdnormal_inv (p);
   else
     usage ("probit (p)");
   endif
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -34,27 +34,27 @@
 ##
 ## @example
 ## qqplot (x, "uniform", 2, 4)
 ## @end example
 ##
 ## If no output arguments are given, the data are plotted directly.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Perform a QQ-plot (quantile plot)
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Perform a QQ-plot (quantile plot)
 
 function [q, s] = qqplot (x, dist, ...)
 
   if (nargin < 1)
-    usage ("qqplot (x [,dist [,params]])");
+    usage ("qqplot (x, dist, params)");
   endif
 
   if !(is_vector(x))
-    error ("qqplot:  x must be a vector.");
+    error ("qqplot: x must be a vector.");
   endif
 
   s = sort (x);
   n = length (x);
   t = ((1 : n)' - .5) / n;
   if (nargin == 1)
     f = "stdnormal_inv";
   else
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -17,18 +17,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} range (@var{x})
 ## If @var{x} is a vector, return the range, i.e., the difference
 ## between the maximum and the minimum, of the input data.
 ##
 ## If @var{x} is a matrix, do the above for each column of @var{x}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute range
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute range
 
 function y = range (x)
 
   if (nargin != 1)
     usage ("range (x)");
   endif
 
   y = max (x) - min (x);
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -17,18 +17,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ranks (@var{x})
 ## If @var{x} is a vector, return the (column) vector of ranks of
 ## @var{x} adjusted for ties.
 ##
 ## If @var{x} is a matrix, do the above for each column of @var{x}.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute ranks
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute ranks
 
 ## This code is rather ugly, but is there an easy way to get the ranks
 ## adjusted for ties from sort?
 
 function y = ranks (x)
 
   if (nargin != 1)
     usage ("ranks (x)");
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -15,18 +15,18 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} run_count (@var{x}, @var{n})
 ## Count the upward runs in the columns of @var{x} of length 1, 2, ...,
 ## @var{n}-1 and greater than or equal to @var{n}.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Count upward runs
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Count upward runs
 
 function retval = run_count (x, n)
 
   [xr, xc] = size(x);
 
   tmp = zeros (xr,xc);
   retval = zeros (n, xc);
 
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -28,36 +28,35 @@
 ## For two data vectors @var{x} and @var{y}, Spearman's @var{rho} is the
 ## correlation of the ranks of @var{x} and @var{y}.
 ##
 ## If @var{x} and @var{y} are drawn from independent distributions,
 ## @var{rho} has zero mean and variance @code{1 / (n - 1)}, and is
 ## asymptotically normally distributed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Spearman's rank correlation rho
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Spearman's rank correlation rho
 
 function rho = spearman (x, y)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("spearman (x [, y])");
+    usage ("spearman (x, y)");
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   n = rows (x);
 
   if (nargin == 1)
     rho = cor (ranks (x));
   else
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
-      error (["spearman:  ", ...
-              "x and y must have the same number of observations"]);
+      error ("spearman: x and y must have the same number of observations");
     endif
     rho = cor (ranks (x), ranks (y));
   endif
 
 endfunction
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -18,18 +18,18 @@
 ## @deftypefn {Function File} {} statistics (@var{x})
 ## If @var{x} is a matrix, return a matrix with the minimum, first
 ## quartile, median, third quartile, maximum, mean, standard deviation,
 ## skewness and kurtosis of the columns of @var{x} as its rows.
 ##
 ## If @var{x} is a vector, treat it as a column vector.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute basic statistics
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute basic statistics
 
 function S = statistics (X)
 
   if (nargin != 1)
     usage ("S = statistics (X)");
   endif
 
   if (prod (size (X)) > 1)
@@ -41,12 +41,12 @@ function S = statistics (X)
                 (empirical_inv ([0.25;0.5;0.75], X(:,k)));
                 (max (X(:,k)));
                 (mean (X(:,k)));
                 (std (X(:,k)));
                 (skewness (X(:,k)));
                 (kurtosis (X(:,k)))];
     endfor
   else
-    error ("statistics:  invalid argument");
+    error ("statistics: invalid argument");
   endif
 
 endfunction
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -17,18 +17,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} studentize (@var{x})
 ## If @var{x} is a vector, subtract its mean and divide by its standard
 ## deviation.
 ##
 ## If @var{x} is a matrix, do the above for each column.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Subtract mean and divide by standard deviation
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Subtract mean and divide by standard deviation
 
 function t = studentize (x)
 
   if (nargin != 1)
     usage ("studentize (x)");
   endif
 
   if is_vector (x)
@@ -37,12 +37,12 @@ function t = studentize (x)
     else
       t = (x - mean (x)) / std (x);
     endif
   elseif is_matrix (x)
     l = ones (rows (x), 1);
     t = x - l * mean (x);
     t = t ./ (l * max ([(std (t)); (! any (t))]));
   else
-    error ("studentize:  x must be a vector or a matrix.");
+    error ("studentize: x must be a vector or a matrix.");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -18,32 +18,32 @@
 ## @deftypefn {Function File} {} [@var{t}, @var{l_x}] = table (@var{x})
 ## @deftypefnx {Function File} {} [@var{t}, @var{l_x}, @var{l_y}] = table (@var{x}, @var{y})
 ## Create a contingency table @var{t} from data vectors.  The @var{l}
 ## vectors are the corresponding levels.
 ##
 ## Currently, only 1- and 2-dimensional tables are supported.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Cross tabulation
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Cross tabulation
 
 function [t, v, w] = table (x, y)
 
   if (nargin == 1)
     if !(is_vector (x))
-      error ("table:  x must be a vector");
+      error ("table: x must be a vector");
     endif
     v = values (x);
     for i = 1 : length (v)
       t(i) = sum (x == v(i) | isnan (v(i)) * isnan (x));
     endfor
   elseif (nargin == 2)
     if !(is_vector (x) && is_vector (y) && (length (x) == length (y)))
-      error ("table:  x and y must be vectors of the same length");
+      error ("table: x and y must be vectors of the same length");
     endif
     v = values (x);
     w = values (y);
     for i = 1 : length (v)
       for j = 1 : length (w)
         t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
                       (y == w(j) | isnan (w(j)) * isnan (y)));
       endfor
diff --git a/scripts/statistics/base/values.m b/scripts/statistics/base/values.m
--- a/scripts/statistics/base/values.m
+++ b/scripts/statistics/base/values.m
@@ -15,27 +15,27 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} values (@var{x})
 ## Return the different values in a column vector, arranged in ascending
 ## order.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Extract unique elements
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Extract unique elements
 
 function v = values (x)
 
   if (nargin != 1)
     usage ("values (x)");
   endif
 
   if !(is_vector (x))
-    error ("values:  x must be a vector");
+    error ("values: x must be a vector");
   endif
 
   i = any (isnan (x));
   x = x(find(!isnan (x)));      # HACK!
   n = length (x);
   x = reshape (x, n, 1);
   s = sort (x);
   v = s([1; (find (s(2:n) > s(1:n-1)) + 1)]);
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -16,28 +16,28 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} var (@var{x})
 ## For vector arguments, return the (real) variance of the values.
 ## For matrix arguments, return a row vector contaning the variance for
 ## each column.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compute variance
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compute variance
 
 function y = var(x)
 
   if (nargin != 1)
     usage ("var (x)");
   endif
 
   [nr, nc] = size (x);
   if (nr == 0 || nc == 0)
-    error ("var:  x must not be empty");
+    error ("var: x must not be empty");
   elseif ((nr == 1) && (nc == 1))
     y = 0;
   elseif ((nr == 1) || (nc == 1))
     n = length (x);
     y = (sumsq (x) - sum(x)^2 / n) / (n - 1);
   else
     y = (sumsq (x) - sum(x).^2 / nr) / (nr - 1);
   endif
diff --git a/scripts/statistics/distributions/beta_cdf.m b/scripts/statistics/distributions/beta_cdf.m
--- a/scripts/statistics/distributions/beta_cdf.m
+++ b/scripts/statistics/distributions/beta_cdf.m
@@ -9,52 +9,54 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  beta_cdf (x, a, b)
-##
-## For each element of x, returns the CDF at x of the beta distribution
-## with parameters a and b, i.e., PROB( beta(a,b) <= x).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} beta_cdf (@var{x}, @var{a}, @var{b})
+## For each element of @var{x}, returns the CDF at @var{x} of the beta
+## distribution with parameters @var{a} and @var{b}, i.e.,
+## PROB (beta (@var{a}, @var{b}) <= @var{x}).
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Beta distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Beta distribution
 
 function cdf = beta_cdf (x, a, b)
 
   if (nargin != 3)
     usage ("beta_cdf (a, b, x)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("beta_cdf:  x, a and b must be of common size or scalar");
+    error ("beta_cdf: x, a and b must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   cdf = zeros (s, 1);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     cdf (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x >= 1) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     cdf (k) = ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     cdf (k) = betai (a(k), b(k), x(k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/beta_inv.m b/scripts/statistics/distributions/beta_inv.m
--- a/scripts/statistics/distributions/beta_inv.m
+++ b/scripts/statistics/distributions/beta_inv.m
@@ -9,77 +9,79 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  beta_inv (x, a, b)
-##
-## For each component of x, compute the quantile (the inverse of the
-## CDF) at x of the Beta distribution with parameters a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} beta_inv (@var{x}, @var{a}, @var{b})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the Beta distribution with parameters @var{a}
+## and @var{b}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Beta distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Beta distribution
 
 function inv = beta_inv (x, a, b)
 
   if (nargin != 3)
     usage ("beta_inv (x, a, b)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("beta_inv:  x, a and b must be of common size or scalars");
+    error ("beta_inv: x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   inv = zeros (s, 1);
 
   k = find ((x < 0) | (x > 1) | !(a > 0) | !(b > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     inv (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x == 1) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     inv (k) = ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     a = a (k);
     b = b (k);
     x = x (k);
     y = a ./ b;
     l = find (y < eps);
-    if any (l)
+    if (any (l))
       y(l) = sqrt (eps) * ones (length (l), 1);
     endif
     l = find (y > 1 - eps);
-    if any (l)
+    if (any (l))
       y(l) = 1 - sqrt (eps) * ones (length (l), 1);
     endif
 
     y_old = y;
     for i = 1 : 100
       h     = (beta_cdf (y_old, a, b) - x) ./ beta_pdf (y_old, a, b);
       y_new = y_old - h;
       ind   = find (y_new <= eps);
       if (any (ind))
         y_new (ind) = y_old (ind) / 10;
       endif
       ind = find (y_new >= 1 - eps);
-      if any (ind)
+      if (any (ind))
         y_new (ind) = 1 - (1 - y_old (ind)) / 10;
       endif
       h = y_old - y_new;
       if (max (abs (h)) < sqrt (eps))
         break;
       endif
       y_old = y_new;
     endfor
diff --git a/scripts/statistics/distributions/beta_pdf.m b/scripts/statistics/distributions/beta_pdf.m
--- a/scripts/statistics/distributions/beta_pdf.m
+++ b/scripts/statistics/distributions/beta_pdf.m
@@ -9,48 +9,49 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  beta_pdf (x, a, b)
-##
-## For each element of x, returns the PDF at x of the beta distribution
-## with parameters a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} beta_pdf (@var{x}, @var{a}, @var{b})
+## For each element of @var{x}, returns the PDF at @var{x} of the beta
+## distribution with parameters @var{a} and @var{b}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the Beta distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the Beta distribution
 
 function pdf = beta_pdf (x, a, b)
 
   if (nargin != 3)
     usage ("beta_pdf (a, b, x)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("beta_pdf:  x, a and b must be of common size or scalar");
+    error ("beta_pdf: x, a and b must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   pdf = zeros (s, 1);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     pdf (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
-  if any (k)
-    pdf(k) = exp ((a(k) - 1) .* log (x(k)) ...
-        + (b(k) - 1) .* log (1 - x(k))) ./ beta (a(k), b(k));
+  if (any (k))
+    pdf(k) = exp ((a(k) - 1) .* log (x(k))
+		  + (b(k) - 1) .* log (1 - x(k))) ./ beta (a(k), b(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/beta_rnd.m b/scripts/statistics/distributions/beta_rnd.m
--- a/scripts/statistics/distributions/beta_rnd.m
+++ b/scripts/statistics/distributions/beta_rnd.m
@@ -9,51 +9,49 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  beta_rnd (a, b [, r, c])
-##
-## beta_rnd (a, b) returns a matrix of random samples from the Beta
-## distribution with parameters a and b.  The size of the matrix is the
-## common size of a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} beta_rnd (@var{a}, @var{b}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the Beta
+## distribution with parameters @var{a} and @var{b}.  Both @var{a} and
+## @var{b} must be scalar or of size @var{r} by @var{c}.
 ##
-## beta_rnd (a, b, r, c) returns an r by c matrix of random samples from
-## the Beta distribution with parameters a and b.  Both a and b must be
-## scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{a} and @var{b}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Beta distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Beta distribution
 
 function rnd = beta_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("beta_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("beta_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("beta_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("beta_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
-      error (strcat("beta_rnd:  ",
-                    "a and b must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("beta_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
-      error ("beta_rnd:  a and b must be of common size or scalar");
+      error ("beta_rnd: a and b must be of common size or scalar");
     endif
   else
-    usage ("beta_rnd (a, b [, r, c])");
+    usage ("beta_rnd (a, b, r, c)");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   rnd = zeros (1, s);
 
diff --git a/scripts/statistics/distributions/binomial_cdf.m b/scripts/statistics/distributions/binomial_cdf.m
--- a/scripts/statistics/distributions/binomial_cdf.m
+++ b/scripts/statistics/distributions/binomial_cdf.m
@@ -9,57 +9,57 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  binomial_cdf (x, n, p)
-##
-## For each element of x, compute the CDF at x of the binomial
-## distribution with parameters n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} binomial_cdf (@var{x}, @var{n}, @var{p})
+## For each element of @var{x}, compute the CDF at @var{x} of the
+## binomial distribution with parameters @var{n} and @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the binomial distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the binomial distribution
 
 function cdf = binomial_cdf (x, n, p)
 
   if (nargin != 3)
     usage ("binomial_cdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
-    error (["binomial_cdf:  ", ...
-            "x, n and p must be of common size or scalar"]);
+    error ("binomial_cdf: x, n and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
-  k = find (isnan (x) | !(n >= 0) | (n != round (n)) ...
-      | !(p >= 0) | !(p <= 1));
-  if any (k)
+  k = find (isnan (x) | !(n >= 0) | (n != round (n))
+	    | !(p >= 0) | !(p <= 1));
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((x >= n) & (n >= 0) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= n) & (n >= 0) & (n == round (n))
+	    & (p >= 0) & (p <= 1));
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x < n) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= 0) & (x < n) & (n == round (n))
+	    & (p >= 0) & (p <= 1));
+  if (any (k))
     tmp = floor (x(k));
     cdf(k) = 1 - betai (tmp + 1, n(k) - tmp, p(k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/binomial_inv.m b/scripts/statistics/distributions/binomial_inv.m
--- a/scripts/statistics/distributions/binomial_inv.m
+++ b/scripts/statistics/distributions/binomial_inv.m
@@ -9,56 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  binomial_inv (x, n, p)
-##
-## For each element of x, compute the quantile at x of the binomial
-## distribution with parameters n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} binomial_inv (@var{x}, @var{n}, @var{p})
+## For each element of @var{x}, compute the quantile at @var{x} of the
+## binomial distribution with parameters @var{n} and @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the binomial distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the binomial distribution
 
 function inv = binomial_inv (x, n, p)
 
   if (nargin != 3)
     usage ("binomial_inv (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
-    error (["binomial_inv:  ", ...
-            "x, n and p must be of common size or scalars"]);
+    error ("binomial_inv: x, n and p must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   inv = zeros (1, s);
 
-  k = find (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != round (n)) ...
-      | !(p >= 0) | !(p <= 1));
-  if any (k)
+  k = find (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != round (n))
+	    | !(p >= 0) | !(p <= 1));
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x <= 1) & (n >= 0) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= 0) & (x <= 1) & (n >= 0) & (n == round (n))
+	    & (p >= 0) & (p <= 1));
+  if (any (k))
     cdf = binomial_pdf (0, n(k), p(k));
     while (any (inv(k) < n(k)))
       m = find (cdf < x(k));
-      if any (m)
+      if (any (m))
         inv(k(m)) = inv(k(m)) + 1;
         cdf(m) = cdf(m) + binomial_pdf (inv(k(m)), n(k(m)), p(k(m)));
       else
         break;
       endif
     endwhile
   endif
 
diff --git a/scripts/statistics/distributions/binomial_pdf.m b/scripts/statistics/distributions/binomial_pdf.m
--- a/scripts/statistics/distributions/binomial_pdf.m
+++ b/scripts/statistics/distributions/binomial_pdf.m
@@ -9,51 +9,51 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  binomial_pdf (x, n, p)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the binomial distribution with parameters n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} binomial_pdf (@var{x}, @var{n}, @var{p})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the binomial distribution with parameters @var{n}
+## and @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the binomial distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the binomial distribution
 
 function pdf = binomial_pdf (x, n, p)
 
   if (nargin != 3)
     usage ("binomial_pdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
-    error (["binomial_pdf:  ", ...
-            "x, n and p must be of common size or scalar"]);
+    error ("binomial_pdf: x, n and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
-  k = find (isnan (x) | !(n >= 0) | (n != round (n)) ...
-      | !(p >= 0) | !(p <= 1));
-  if any (k)
+  k = find (isnan (x) | !(n >= 0) | (n != round (n)) | !(p >= 0) | !(p <= 1));
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x <= n) & (x == round (x)) ...
-      & (n == round (n)) & (p >= 0) & (p <= 1));
-  if any (k)
-    pdf(k) = bincoeff (n(k), x(k)) .* (p(k) .^ x(k)) ...
-        .* ((1 - p(k)) .^ (n(k) - x(k)));
+  k = find ((x >= 0) & (x <= n) & (x == round (x))
+	    & (n == round (n)) & (p >= 0) & (p <= 1));
+  if (any (k))
+    pdf(k) = (bincoeff (n(k), x(k)) .* (p(k) .^ x(k))
+	      .* ((1 - p(k)) .^ (n(k) - x(k))));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/binomial_rnd.m b/scripts/statistics/distributions/binomial_rnd.m
--- a/scripts/statistics/distributions/binomial_rnd.m
+++ b/scripts/statistics/distributions/binomial_rnd.m
@@ -9,67 +9,65 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  binomial_rnd (n, p [, r, c])
-##
-## binomial_rnd (n, p) returns a matrix of random samples from the
-## binomial distribution with parameters n and p.  The size of the
-## matrix is the common size of n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} binomial_rnd (@var{n}, @var{p}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## binomial distribution with parameters @var{n} and @var{p}.  Both
+## @var{n} and @var{p} must be scalar or of size @var{r} by @var{c}.
 ##
-## binomial_rnd (n, p, r, c) returns an r by c matrix of random samples
-## from the binomial distribution with parameters n and p. Both n and p
-## must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{n} and @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the binomial distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the binomial distribution
 
 function rnd = binomial_rnd (n, p, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("binomial_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("binomial_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("binomial_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("binomial_rnd: c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
-      error (strcat("binomial_rnd:  ",
-                    "n and p must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("binomial_rnd: n and p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
     if (retval > 0)
-      error ("binomial_rnd:  n and p must be of common size or scalar");
+      error ("binomial_rnd: n and p must be of common size or scalar");
     endif
   else
-    usage ("binomial_rnd (n, p [, r, c])");
+    usage ("binomial_rnd (n, p, r, c)");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   p = reshape (p, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)) |
             !(p <= 0) | !(p >= 1));
-  if any (k)
+  if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((n > 0) & (n < Inf) & (n == round (n)) & (p >= 0) & (p <= 1));
-  if any (k)
+  if (any (k))
     N = max (n(k));
     L = length (k);
     tmp = rand (N, L);
     ind = (1 : N)' * ones (1, L);
     rnd(k) = sum ((tmp < ones (N, 1) * p(k)) &
                   (ind <= ones (N, 1) * n(k)));
   endif
 
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -9,50 +9,51 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  cauchy_cdf (x [, lambda, sigma])
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the Cauchy distribution with location parameter lambda
-## and scale parameter sigma. Default values are lambda = 0, sigma = 1.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cauchy_cdf (@var{x}, @var{lambda}, @var{sigma})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the Cauchy distribution with location
+## parameter @var{lambda} and scale parameter @var{sigma}.  Default
+## values are @var{lambda} = 0, @var{sigma} = 1. 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Cauchy distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Cauchy distribution
 
 function cdf = cauchy_cdf (x, location, scale)
 
-  if !(nargin == 1 || nargin == 3)
-    usage ("cauchy_cdf (x [, lambda, sigma])");
+  if (! (nargin == 1 || nargin == 3))
+    usage ("cauchy_cdf (x, lambda, sigma)");
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   [retval, x, location, scale] = common_size (x, location, scale);
   if (retval > 0)
-    error (["cauchy_cdf:  ", ...
-            "x, lambda and sigma must be of common size or scalar"]);
+    error ("cauchy_cdf: x, lambda and sigma must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   location = reshape (location, 1, s);
   scale = reshape (scale, 1, s);
   cdf = NaN * ones (1, s);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
-  if any (k)
+  if (any (k))
     cdf(k) = 0.5 + atan ((x(k) - location(k)) ./ scale(k)) / pi;
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -9,63 +9,64 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  cauchy_inv (x [, lambda, sigma])
-##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the Cauchy distribution with location parameter lambda and
-## scale parameter sigma. Default values are lambda = 0, sigma = 1.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cauchy_inv (@var{x}, @var{lambda}, @var{sigma})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the Cauchy distribution with location parameter
+## @var{lambda} and scale parameter @var{sigma}.  Default values are
+## @var{lambda} = 0, @var{sigma} = 1. 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Cauchy distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Cauchy distribution
 
 function inv = cauchy_inv (x, location, scale)
 
-  if !(nargin == 1 || nargin == 3)
-    usage ("cauchy_inv (x [, lambda, sigma])");
+  if (! (nargin == 1 || nargin == 3))
+    usage ("cauchy_inv (x, lambda, sigma)");
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   [retval, x, location, scale] = common_size (x, location, scale);
   if (retval > 0)
-    error (["cauchy_inv:  ", ...
-            "x, lambda and sigma must be of common size or scalar"]);
+    error ("cauchy_inv: x, lambda and sigma must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   location = reshape (location, 1, s);
   scale = reshape (scale, 1, s);
 
   inv = NaN * ones (1, s);
 
   ok = ((location > -Inf) & (location < Inf) &
        (scale > 0) & (scale < Inf));
 
   k = find ((x == 0) & ok);
-  if any (k)
+  if (any (k))
     inv(k) = -Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & ok);
-  if any (k)
+  if (any (k))
     inv(k) = location(k) - scale(k) .* cot (pi * x(k));
   endif
 
   k = find ((x == 1) & ok);
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -9,52 +9,53 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  cauchy_pdf (x [, lambda, sigma])
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the Cauchy distribution with location parameter lambda and
-## scale parameter sigma > 0. Default values are lambda = 0, sigma = 1.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cauchy_pdf (@var{x}, @var{lambda}, @var{sigma})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the Cauchy distribution with location parameter
+## @var{lambda} and scale parameter @var{sigma} > 0.  Default values are
+## @var{lambda} = 0, @var{sigma} = 1. 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the Cauchy distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the Cauchy distribution
 
 function pdf = cauchy_pdf (x, location, scale)
 
-  if !(nargin == 1 || nargin == 3)
-    usage ("cauchy_pdf (x [, lambda, sigma])");
+  if (! (nargin == 1 || nargin == 3))
+    usage ("cauchy_pdf (x, lambda, sigma)");
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   [retval, x, location, scale] = common_size (x, location, scale);
   if (retval > 0)
-    error (["cauchy_pdf:  ", ...
-            "x, lambda and sigma must be of common size or scalar"]);
+    error ("cauchy_pdf: x, lambda and sigma must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   location = reshape (location, 1, s);
   scale = reshape (scale, 1, s);
 
   pdf = NaN * ones (1, s);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
-  if any (k)
-    pdf(k) = (1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2)) ...
-             / pi ./ scale(k);
+  if (any (k))
+    pdf(k) = ((1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2))
+	      / pi ./ scale(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -9,53 +9,51 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  cauchy_rnd (lambda, sigma [, r, c])
-##
-## cauchy_rnd (lambda, sigma) returns a matrix of random samples from
-## the Cauchy distribution with parameters lambda and sigma.  The size
-## of the matrix is the common size of the parameters.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cauchy_rnd (@var{lambda}, @var{sigma}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the Cauchy
+## distribution with parameters @var{lambda} and @var{sigma} which must
+## both be scalar or of size @var{r} by @var{c}.
 ##
-## cauchy_rnd (lambda, sigma, r, c) returns an r by c matrix of random
-## samples from the Cauchy distribution with parameters lambda and sigma
-## which must both be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{lambda} and @var{sigma}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Cauchy distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (l, scale, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("cauchy_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("cauchy_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("cauchy_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("cauchy_rnd: c must be a positive integer");
     endif
     [retval, l, scale] = common_size (l, scale, zeros (r, c));
     if (retval > 0)
-      error (strcat("cauchy_rnd:  ",
-                    "lambda and sigma must be scalar or of size",
-                    sprintf ("%d by %d.", r, c)));
+      error ("cauchy_rnd: lambda and sigma must be scalar or of size %d by %d",
+	     r, c); 
     endif
   elseif (nargin == 2)
     [retval, l, scale] = common_size (l, scale);
     if (retval > 0)
-      error (["cauchy_rnd:  ", ...
-              "lambda and sigma must be of common size or scalar"]);
+      error ("cauchy_rnd: lambda and sigma must be of common size or scalar");
     endif
     [r, c] = size (l);
   else
-    usage ("cauchy_rnd (lambda, sigma [, r, c])");
+    usage ("cauchy_rnd (lambda, sigma, r, c)");
   endif
 
   s = r * c;
   l = reshape (l, 1, s);
   scale = reshape (scale, 1, s);
 
   rnd = NaN * ones (1, s);
 
diff --git a/scripts/statistics/distributions/chisquare_cdf.m b/scripts/statistics/distributions/chisquare_cdf.m
--- a/scripts/statistics/distributions/chisquare_cdf.m
+++ b/scripts/statistics/distributions/chisquare_cdf.m
@@ -9,42 +9,42 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  chisquare_cdf (x, n)
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the chisquare distribution with n degrees of freedom.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} chisquare_cdf (@var{x}, @var{n})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the chisquare distribution with @var{n}
+## degrees of freedom.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  CDF of the chi-square distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: CDF of the chi-square distribution
 
 function cdf = chisquare_cdf (x, n)
 
   if (nargin != 2)
     usage ("chisquare_cdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
-    error (["chisquare_cdf:  ", ...
-            "x and n must be of common size or scalar"]);
+    error ("chisquare_cdf: x and n must be of common size or scalar");
   endif
 
   cdf = gamma_cdf (x, n / 2, 1 / 2);
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  n should be positive integer\n");
+  if (any (k))
+    warning ("chisquare_cdf: n should be positive integer");
     [r, c] = size (x);
     cdf = reshape (cdf, 1, r * c);
     cdf(k) = NaN * ones (1, length (k));
     cdf = reshape (cdf, r, c);
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_inv.m b/scripts/statistics/distributions/chisquare_inv.m
--- a/scripts/statistics/distributions/chisquare_inv.m
+++ b/scripts/statistics/distributions/chisquare_inv.m
@@ -9,41 +9,42 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  chisquare_inv (x, n)
-##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the chisquare distribution with n degrees of freedom.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} chisquare_inv (@var{x}, @var{n})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the chisquare distribution with @var{n} degrees of
+## freedom.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  Quantile function of the chi-square distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: Quantile function of the chi-square distribution
 
 function inv = chisquare_inv (x, n)
 
   if (nargin != 2)
     usage ("chisquare_inv (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
-    error ("chisquare_inv:  x and n must be of common size or scalar");
+    error ("chisquare_inv: x and n must be of common size or scalar");
   endif
 
   inv = gamma_inv (x, n / 2, 1 / 2);
 
   ## Allow only for (positive) integer n.
   k = find (n != round (n));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  n should be positive integer\n");
+  if (any (k))
+    warning ("chisquare_inv: n should be positive integer");
     [r, c] = size (x);
     inv = reshape (inv, 1, r * c);
     inv(k) = NaN * ones (1, length (k));
     inv = reshape (inv, r, c);
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_pdf.m b/scripts/statistics/distributions/chisquare_pdf.m
--- a/scripts/statistics/distributions/chisquare_pdf.m
+++ b/scripts/statistics/distributions/chisquare_pdf.m
@@ -9,42 +9,42 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  chisquare_pdf (x, n)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the chisquare distribution with k degrees of freedom.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} chisquare_pdf (@var{x}, @var{n})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the chisquare distribution with @var{k} degrees
+## of freedom.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  PDF of the chi-sqaure distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: PDF of the chi-sqaure distribution
 
 function pdf = chisquare_pdf (x, n)
 
   if (nargin != 2)
     usage ("chisquare_pdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
-    error (["chisquare_pdf:  ", ...
-            "x and n must be of common size or scalar"]);
+    error ("chisquare_pdf: x and n must be of common size or scalar");
   endif
 
   pdf = gamma_pdf (x, n / 2, 1 / 2);
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  n should be positive integer\n");
+  if (any (k))
+    warning ("chisquare_pdf: n should be positive integer");
     [r, c] = size (x);
     pdf = reshape (pdf, 1, r * c);
     pdf(k) = NaN * ones (1, length (k));
     pdf = reshape (pdf, r, c);
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/chisquare_rnd.m b/scripts/statistics/distributions/chisquare_rnd.m
--- a/scripts/statistics/distributions/chisquare_rnd.m
+++ b/scripts/statistics/distributions/chisquare_rnd.m
@@ -9,46 +9,44 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  chisquare_rnd (n [, r, c])
-##
-## chisquare_rnd (n) returns a matrix of random samples from the
-## chisquare distribution with n degrees of freedom.  The size of the
-## matrix is the size of n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} chisquare_rnd (@var{n}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## chisquare distribution with @var{n} degrees of freedom.  @var{n} must
+## be a scalar or of size @var{r} by @var{c}.
 ##
-## chisquare_rnd (n, r, c) returns an r by c matrix of random samples
-## from the chisquare distribution with n degrees of freedom.  n must be
-## a scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the size of @var{n}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the chi-square distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the chi-square distribution
 
 function rnd = chisquare_rnd (n, r, c)
 
   if (nargin == 3)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("chisquare_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("chisquare_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("chisquare_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("chisquare_rnd: c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
-      error (strcat("chisquare_rnd:  ",
-                    "n must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("chisquare_rnd: n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
-    usage ("chisquare_rnd (n [, r, c])");
+    usage ("chisquare_rnd (n, r, c)");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)));
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -9,53 +9,54 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  discrete_cdf (X, V, P)
-##
-## For each element of X, compute the cumulative distribution function
-## (CDF) at X of a univariate discrete distribution which assumes the
-## values in V with probabilities P.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} discrete_cdf (@var{x}, @var{v}, @var{p})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of a univariate discrete distribution which
+## assumes the values in v with probabilities @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of a discrete distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of a discrete distribution
 
-function cdf = discrete_cdf (X, V, P)
+function cdf = discrete_cdf (x, v, p)
 
   if (nargin != 3)
-    usage ("discrete_cdf (X, V, P)");
+    usage ("discrete_cdf (x, v, p)");
   endif
 
-  [r, c] = size (X);
+  [r, c] = size (x);
 
-  if (! is_vector (V))
-    error ("discrete_cdf: V must be a vector");
-  elseif (! is_vector (P) || (length (P) != length (V)))
-    error ("discrete_cdf: P must be a vector with length (V) elements");
-  elseif (! (all (P >= 0) && any (P)))
-    error ("discrete_cdf: P must be a nonzero, nonnegative vector");
+  if (! is_vector (v))
+    error ("discrete_cdf: v must be a vector");
+  elseif (! is_vector (p) || (length (p) != length (v)))
+    error ("discrete_cdf: p must be a vector with length (v) elements");
+  elseif (! (all (p >= 0) && any (p)))
+    error ("discrete_cdf: p must be a nonzero, nonnegative vector");
   endif
 
   n = r * c;
-  m = length (V);
-  X = reshape (X, n, 1);
-  V = reshape (V, 1, m);
+  m = length (v);
+  x = reshape (x, n, 1);
+  v = reshape (v, 1, m);
   P = reshape (P / sum (P), m, 1);
 
   cdf = zeros (n, 1);
-  k = find (isnan (X));
-  if any (k)
+  k = find (isnan (x));
+  if (any (k))
     cdf (k) = NaN * ones (length (k), 1);
   endif
-  k = find (!isnan (X));
-  if any (k)
+  k = find (!isnan (x));
+  if (any (k))
     n = length (k);
-    cdf (k) = ((X(k) * ones (1, m)) >= (ones (n, 1) * V)) * P;
+    cdf (k) = ((x(k) * ones (1, m)) >= (ones (n, 1) * V)) * P;
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -9,58 +9,59 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  discrete_inv (X, V, P)
-##
-## For each component of X, compute the quantile (the inverse of the
-## CDF) at X of the univariate distribution which assumes the values in
-## V with probabilities P.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} discrete_inv (@var{x}, @var{v}, @var{p})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the univariate distribution which assumes the
+## values in @var{v} with probabilities @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of a discrete distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of a discrete distribution
 
-function inv = discrete_inv (X, V, P)
+function inv = discrete_inv (x, v, p)
 
   if (nargin != 3)
-    usage ("discrete_inv (X, V, P)");
+    usage ("discrete_inv (x, v, p)");
   endif
 
-  [r, c] = size (X);
+  [r, c] = size (x);
 
-  if (! is_vector (V))
-    error ("discrete_inv:  V must be a vector");
-  elseif (! is_vector (P) || (length (P) != length (V)))
-    error ("discrete_inv:  P must be a vector with length (V) elements");
-  elseif (! (all (P >= 0) && any (P)))
-    error ("discrete_inv:  P must be a nonzero, nonnegative vector");
+  if (! is_vector (v))
+    error ("discrete_inv: v must be a vector");
+  elseif (! is_vector (p) || (length (p) != length (v)))
+    error ("discrete_inv: p must be a vector with length (v) elements");
+  elseif (! (all (p >= 0) && any (p)))
+    error ("discrete_inv: p must be a nonzero, nonnegative vector");
   endif
 
   n = r * c;
-  X = reshape (X, 1, n);
-  m = length (V);
-  [V, ind] = sort (V);
-  s = reshape (cumsum (P / sum (P)), m, 1);
+  x = reshape (x, 1, n);
+  m = length (v);
+  [v, ind] = sort (v);
+  s = reshape (cumsum (p / sum (p)), m, 1);
 
   inv = NaN * ones (n, 1);
-  if any (k = find (X == 0))
+  if (any (k = find (x == 0)))
     inv(k) = -Inf * ones (1, length (k));
   endif
-  if any (k = find (X == 1))
-    inv(k) = V(m) * ones (1, length (k));
+  if (any (k = find (x == 1)))
+    inv(k) = v(m) * ones (1, length (k));
   endif
-  if any (k = find ((X > 0) & (X < 1)))
+  if (any (k = find ((x > 0) & (x < 1))))
     n = length (k);
     ## --FIXME--
     ## This does not work!
-    inv(k) = V(sum ((ones (m, 1) * X(k)) > (s * ones (1, n))) + 1);
+    inv(k) = v(sum ((ones (m, 1) * x(k)) > (s * ones (1, n))) + 1);
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
 
 
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -9,53 +9,54 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  discrete_pdf (X, V, P)
-##
-## For each element of X, compute the probability density function (PDF)
-## at X of a univariate discrete distribution which assumes the values
-## in V with probabilities P.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} discrete_pdf (@var{x}, @var{v}, @var{p})
+## For each element of @var{x}, compute the probability density function
+## (pDF) at @var{x} of a univariate discrete distribution which assumes
+## the values in @var{v} with probabilities @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of a discrete distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: pDF of a discrete distribution
 
-function pdf = discrete_pdf (X, V, P)
+function pdf = discrete_pdf (x, v, p)
 
   if (nargin != 3)
-    usage ("discrete_pdf (X, V, P)");
+    usage ("discrete_pdf (x, v, p)");
   endif
 
-  [r, c] = size (X);
+  [r, c] = size (x);
 
-  if (! is_vector (V))
-    error ("discrete_pdf:  V must be a vector");
-  elseif (! is_vector (P) || (length (P) != length (V)))
-    error ("discrete_pdf:  P must be a vector with length (V) elements");
-  elseif (! (all (P >= 0) && any (P)))
-    error ("discrete_pdf:  P must be a nonzero, nonnegative vector");
+  if (! is_vector (v))
+    error ("discrete_pdf: v must be a vector");
+  elseif (! is_vector (p) || (length (p) != length (v)))
+    error ("discrete_pdf: p must be a vector with length (v) elements");
+  elseif (! (all (p >= 0) && any (p)))
+    error ("discrete_pdf: p must be a nonzero, nonnegative vector");
   endif
 
   n = r * c;
-  m = length (V);
-  X = reshape (X, n, 1);
-  V = reshape (V, 1, m);
-  P = reshape (P / sum (P), m, 1);
+  m = length (v);
+  x = reshape (x, n, 1);
+  v = reshape (v, 1, m);
+  p = reshape (p / sum (p), m, 1);
 
   pdf = zeros (n, 1);
-  k = find (isnan (X));
-  if any (k)
+  k = find (isnan (x));
+  if (any (k))
     pdf (k) = NaN * ones (length (k), 1);
   endif
-  k = find (!isnan (X));
-  if any (k)
+  k = find (!isnan (x));
+  if (any (k))
     n = length (k);
-    pdf (k) = ((X(k) * ones (1, m)) == (ones (n, 1) * V)) * P;
+    pdf (k) = ((x(k) * ones (1, m)) == (ones (n, 1) * v)) * P;
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -9,44 +9,45 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  discrete_rnd (N, V, P)
-##
-## Generate a row vector containing a random sample of size N from the
-## univariate distribution which assumes the values in V with
-## probabilities P.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} discrete_rnd (@var{n}, @var{v}, @var{p})
+## Generate a row vector containing a random sample of size @var{n} from
+## the univariate distribution which assumes the values in @var{v} with
+## probabilities @var{p}.
 ##
-## Currently, N must be a scalar.
+## Currently, @var{n} must be a scalar.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from a discrete distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from a discrete distribution
 
-function rnd = discrete_rnd (N, V, P)
+function rnd = discrete_rnd (n, v, p)
 
   if (nargin != 3)
-    usage ("discrete_rnd (N, V, P)");
+    usage ("discrete_rnd (n, v, p)");
   endif
 
-  if (! is_scalar (N))
-    error ("discrete_rnd:  N must be a scalar");
+  if (! is_scalar (n))
+    error ("discrete_rnd: n must be a scalar");
   endif
 
-  if (! is_vector (V))
-    error ("discrete_rnd:  V must be a vector");
-  elseif (! is_vector (P) || (length (P) != length (V)))
-    error ("discrete_rnd:  P must be a vector with length (V) elements");
-  elseif (! (all (P >= 0) && any (P)))
-    error ("discrete_rnd:  P must be a nonzero, nonnegative vector");
+  if (! is_vector (v))
+    error ("discrete_rnd: v must be a vector");
+  elseif (! is_vector (p) || (length (p) != length (v)))
+    error ("discrete_rnd: p must be a vector with length (v) elements");
+  elseif (! (all (p >= 0) && any (p)))
+    error ("discrete_rnd: p must be a nonzero, nonnegative vector");
   endif
 
-  u = rand (1, N);
-  m = length (P);
-  s = reshape (cumsum (P / sum (P)), m, 1);
+  u = rand (1, n);
+  m = length (p);
+  s = reshape (cumsum (p / sum (p)), m, 1);
 
-  rnd = V (1 + sum ((s * ones (1, N)) <= ((ones (m, 1) * u))));
+  rnd = v (1 + sum ((s * ones (1, n)) <= ((ones (m, 1) * u))));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -9,26 +9,27 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  empirical_cdf (X, DATA)
-##
-## For each element of X, compute the cumulative distribution function
-## (CDF) at X of the empirical distribution obtained from the univariate
-## sample DATA.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} empirical_cdf (@var{x}, @var{data})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the empirical distribution obtained from
+## the univariate sample @var{data}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the empirical distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the empirical distribution
 
-function cdf = empirical_cdf (X, DATA)
+function cdf = empirical_cdf (x, data)
 
-  if (! is_vector (DATA))
-    error ("empirical_cdf:  DATA must be a vector");
+  if (! is_vector (data))
+    error ("empirical_cdf: data must be a vector");
   endif
 
-  cdf = discrete_cdf (X, DATA, ones (size (DATA)) / length (DATA));
+  cdf = discrete_cdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -9,26 +9,27 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  empirical_inv (X, DATA)
-##
-## For each element of X, compute the quantile (the inverse of the CDF)
-## at X of the empirical distribution obtained from the univariate
-## sample DATA.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} empirical_inv (@var{x}, @var{data})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the empirical distribution obtained from the
+## univariate sample @var{data}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the empirical distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the empirical distribution
 
-function inv = empirical_inv (X, DATA)
+function inv = empirical_inv (x, data)
 
-  if (! is_vector (DATA))
-    error ("empirical_inv:  DATA must be a vector");
+  if (! is_vector (data))
+    error ("empirical_inv: data must be a vector");
   endif
 
-  inv = discrete_inv (X, DATA, ones (size (DATA)) / length (DATA));
+  inv = discrete_inv (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -9,26 +9,27 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  empirical_pdf (X, DATA)
-##
-## For each element of X, compute the probability density function (PDF)
-## at X of the empirical distribution obtained from the univariate
-## sample DATA.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} empirical_pdf (@var{x}, @var{data})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the empirical distribution obtained from the
+## univariate sample @var{data}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the empirical distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the empirical distribution
 
-function pdf = empirical_pdf (X, DATA)
+function pdf = empirical_pdf (x, data)
 
-  if (! is_vector (DATA))
-    error ("empirical_pdf:  DATA must be a vector");
+  if (! is_vector (data))
+    error ("empirical_pdf: data must be a vector");
   endif
 
-  pdf = discrete_pdf (X, DATA, ones (size (DATA)) / length (DATA));
+  pdf = discrete_pdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -9,25 +9,26 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  empirical_rnd (N, DATA)
-##
-## Generate a bootstrap sample of size N from the empirical distribution
-## obtained from the univariate sample DATA.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} empirical_rnd (@var{n}, @var{data})
+## Generate a bootstrap sample of size @var{n} from the empirical
+## distribution obtained from the univariate sample @var{data}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Bootstrap samples from the empirical distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Bootstrap samples from the empirical distribution
 
-function rnd = empirical_rnd (N, DATA)
+function rnd = empirical_rnd (n, data)
 
-  if (! is_vector (DATA))
-    error ("empirical_rnd:  DATA must be a vector");
+  if (! is_vector (data))
+    error ("empirical_rnd: data must be a vector");
   endif
 
-  rnd = discrete_rnd (N, DATA, ones (size (DATA)) / length (DATA));
+  rnd = discrete_rnd (n, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/exponential_cdf.m b/scripts/statistics/distributions/exponential_cdf.m
--- a/scripts/statistics/distributions/exponential_cdf.m
+++ b/scripts/statistics/distributions/exponential_cdf.m
@@ -9,25 +9,27 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  exponential_cdf (x, lambda)
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the exponential distribution with parameter lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} exponential_cdf (@var{x}, @var{lambda})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the exponential distribution with
+## parameter @var{lambda}.
 ##
 ## The arguments can be of common size or scalar.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the exponential distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the exponential distribution
 
 function cdf = exponential_cdf (x, l)
 
   if (nargin != 2)
     usage ("exponential_cdf (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
@@ -37,25 +39,25 @@ function cdf = exponential_cdf (x, l)
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(l > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == Inf) & (l > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < Inf) & (l > 0));
-  if any (k)
+  if (any (k))
     cdf (k) = 1 - exp (- l(k) .* x(k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/exponential_inv.m b/scripts/statistics/distributions/exponential_inv.m
--- a/scripts/statistics/distributions/exponential_inv.m
+++ b/scripts/statistics/distributions/exponential_inv.m
@@ -9,52 +9,53 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  exponential_inv (x, lambda)
-##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the exponential distribution with parameter lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} exponential_inv (@var{x}, @var{lambda})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the exponential distribution with parameter
+## @var{lambda}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the exponential distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the exponential distribution
 
 function inv = exponential_inv (x, l)
 
   if (nargin != 2)
     usage ("exponential_inv (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
-    error (["exponential_inv:  ", ...
-            "x and lambda must be of common size or scalar"]);
+    error ("exponential_inv: x and lambda must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   inv = zeros (1, s);
 
   k = find (!(l > 0) | (x < 0) | (x > 1) | isnan (x));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (l > 0));
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & (l > 0));
-  if any (k)
+  if (any (k))
     inv(k) = - log (1 - x(k)) ./ l(k);
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/exponential_pdf.m b/scripts/statistics/distributions/exponential_pdf.m
--- a/scripts/statistics/distributions/exponential_pdf.m
+++ b/scripts/statistics/distributions/exponential_pdf.m
@@ -9,47 +9,47 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  exponential_pdf (x, lambda)
-##
-## For each element of x, compute the probability density function (PDF)
-## of the exponential distribution with parameter lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} exponential_pdf (@var{x}, @var{lambda})
+## For each element of @var{x}, compute the probability density function
+## (PDF) of the exponential distribution with parameter @var{lambda}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the exponential distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the exponential distribution
 
 function pdf = exponential_pdf (x, l)
 
   if (nargin != 2)
     usage ("exponential_pdf (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
-    error (["exponential_pdf:  ", ...
-            "x and lambda must be of common size or scalar"]);
+    error ("exponential_pdf: x and lambda must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   pdf = zeros (1, s);
 
   k = find (!(l > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < Inf) & (l > 0));
-  if any (k)
+  if (any (k))
     pdf(k) = l(k) .* exp (- l(k) .* x(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/exponential_rnd.m b/scripts/statistics/distributions/exponential_rnd.m
--- a/scripts/statistics/distributions/exponential_rnd.m
+++ b/scripts/statistics/distributions/exponential_rnd.m
@@ -9,46 +9,45 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  exponential_rnd (lambda [, r, c])
-##
-## exponential_rnd (lambda) returns a matrix of random samples from the
-## exponential distribution with parameter lambda.  The size of the
-## matrix is the size of lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} exponential_rnd (@var{lambda}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## exponential distribution with parameter @var{lambda}, which must be a
+## scalar or of size @var{r} by @var{c}.
 ##
-## exponential_rnd (lambda, r, c) returns an r by c matrix of random
-## samples from the exponential distribution with parameter lambda,
-## which must be a scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the size of @var{lambda}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the exponential distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the exponential distribution
 
 function rnd = exponential_rnd (l, r, c)
 
   if (nargin == 3)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("exponential_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("exponential_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("exponential_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("exponential_rnd: c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
-      error (strcat("exponential_rnd:  ",
-                    "lambda must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("exponential_rnd: lambda must be scalar or of size %d by %d",
+	     r, c);
     endif
   elseif (nargin != 1)
-    usage ("exponential_rnd (lambda [, r, c])");
+    usage ("exponential_rnd (lambda, r, c)");
   endif
 
   [r, c] = size (l);
   s = r * c;
   l = reshape (l, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(l > 0) | !(l < Inf));
diff --git a/scripts/statistics/distributions/f_cdf.m b/scripts/statistics/distributions/f_cdf.m
--- a/scripts/statistics/distributions/f_cdf.m
+++ b/scripts/statistics/distributions/f_cdf.m
@@ -9,61 +9,61 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  f_cdf (x, m, n)
-##
-## For each element of x, compute the CDF at x of the F distribution
-## with m and n degrees of freedom, i.e., PROB( F(m,n) <= x ).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} f_cdf (@var{x}, @var{m}, @var{n})
+## For each element of @var{x}, compute the CDF at @var{x} of the F
+## distribution with @var{m} and @var{n} degrees of freedom, i.e.,
+## PROB (F (@var{m}, @var{n}) <= @var{x}). 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the F distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the F distribution
 
 function cdf = f_cdf (x, m, n)
 
   if (nargin != 3)
     usage ("f_cdf (x, m, n)");
   endif
 
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
-    error ("f_cdf:  x, m and n must be of common size or scalar");
+    error ("f_cdf: x, m and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   cdf = zeros (1, s);
 
   k = find (!(m > 0) | !(n > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == Inf) & (m > 0) & (n > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
-  if any (k)
-    cdf(k) = 1 - betai (n(k) / 2, m(k) / 2, ...
-        1 ./ (1 + m(k) .* x(k) ./ n(k)));
+  if (any (k))
+    cdf(k) = 1 - betai (n(k) / 2, m(k) / 2, 1 ./ (1 + m(k) .* x(k) ./ n(k)));
   endif
 
   ## should we really only allow for positive integer m, n?
   k = find ((m != round (m)) | (n != round (n)));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  m and n should be positive integers\n");
+  if (any (k))
+    warning ("f_cdf: m and n should be positive integers");
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/f_inv.m b/scripts/statistics/distributions/f_inv.m
--- a/scripts/statistics/distributions/f_inv.m
+++ b/scripts/statistics/distributions/f_inv.m
@@ -9,61 +9,62 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  f_inv (x, m, n)
-##
-## For each component of x, compute the quantile (the inverse of the
-## CDF) at x of the F distribution with parameters m and n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} f_inv (@var{x}, @var{m}, @var{n})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the F distribution with parameters @var{m} and
+## @var{n}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the F distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the F distribution
 
 function inv = f_inv (x, m, n)
 
   if (nargin != 3)
     usage ("f_inv (x, m, n)");
   endif
 
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
-    error ("f_inv:  x, m and n must be of common size or scalar");
+    error ("f_inv: x, m and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(m > 0) | !(n > 0));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (m > 0) & (n > 0));
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & (m > 0) & (n > 0));
-  if any (k)
-    inv(k) = (1 ./ beta_inv (1 - x(k), n(k) / 2, m(k) / 2) - 1) ...
-        .* n(k) ./ m(k);
+  if (any (k))
+    inv(k) = ((1 ./ beta_inv (1 - x(k), n(k) / 2, m(k) / 2) - 1)
+	      .* n(k) ./ m(k));
   endif
 
   ## should we really only allow for positive integer m, n?
   k = find ((m != round (m)) | (n != round (n)));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  m and n should be positive integers\n");
+  if (any (k))
+    warning ("f_inv: m and n should be positive integers");
     inv(k) = NaN * ones (1, length (k));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/f_pdf.m b/scripts/statistics/distributions/f_pdf.m
--- a/scripts/statistics/distributions/f_pdf.m
+++ b/scripts/statistics/distributions/f_pdf.m
@@ -9,58 +9,59 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  f_pdf (x, m, n)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the F distribution with m and n degrees of freedom.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} f_pdf (@var{x}, @var{m}, @var{n})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the F distribution with @var{m} and @var{n}
+## degrees of freedom.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the F distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the F distribution
 
 function pdf = f_pdf (x, m, n)
 
   if (nargin != 3)
     usage ("f_pdf (x, m, n).");
   endif
 
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
-    error ("f_pdf:  x, m and n must be of common size or scalar");
+    error ("f_pdf: x, m and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x) | !(m > 0) | !(n > 0));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
-  if any (k)
+  if (any (k))
     tmp = m(k) .* x(k) ./ n(k);
-    pdf(k) = exp ((m(k) / 2 - 1) .* log (tmp) ...
-        - ((m(k) + n(k)) / 2) .* log (1 + tmp)) ...
-        .* (m(k) ./ n(k)) ./ beta (m(k) / 2, n(k) / 2);
+    pdf(k) = (exp ((m(k) / 2 - 1) .* log (tmp)
+		   - ((m(k) + n(k)) / 2) .* log (1 + tmp))
+	      .* (m(k) ./ n(k)) ./ beta (m(k) / 2, n(k) / 2));
   endif
 
   ## should we really only allow for positive integer m, n?
   k = find ((m != round (m)) | (n != round (n)));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  m and n should be positive integers\n");
+  if (any (k))
+    warning ("f_pdf: m and n should be positive integers");
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/f_rnd.m b/scripts/statistics/distributions/f_rnd.m
--- a/scripts/statistics/distributions/f_rnd.m
+++ b/scripts/statistics/distributions/f_rnd.m
@@ -9,51 +9,49 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  f_rnd (m, n [, r, c])
-##
-## f_rnd (m, n) returns a matrix of random samples from the F
-## distribution with m and n degrees of freedom.  The size of the matrix
-## is the common size of m and n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} f_rnd (@var{m}, @var{n}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the F
+## distribution with @var{m} and @var{n} degrees of freedom.  Both
+## @var{m} and @var{n} must be scalar or of size @var{r} by @var{c}.
 ##
-## f_rnd (m, n, r, c) returns an r by c matrix of random samples from
-## the F distribution with m and n degrees of freedom.  Both m and n
-## must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{m} and @var{n}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the F distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the F distribution
 
 function rnd = f_rnd (m, n, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("f_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("f_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("f_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("f_rnd: c must be a positive integer");
     endif
     [retval, m, n] = common_size (m, n, zeros (r, c));
     if (retval > 0)
-      error (strcat("f_rnd:  ",
-                    "m and n must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("f_rnd: m and n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, m, n] = common_size (m, n);
     if (retval > 0)
-      error ("f_rnd:  m and n must be of common size or scalar");
+      error ("f_rnd: m and n must be of common size or scalar");
     endif
   else
-    usage ("f_rnd (m, n [, r, c])");
+    usage ("f_rnd (m, n, r, c)");
   endif
 
   [r, c] = size (m);
   s = r * c;
   m = reshape (m, 1, s);
   n = reshape (n, 1, s);
   rnd = zeros (1, s);
 
diff --git a/scripts/statistics/distributions/gamma_cdf.m b/scripts/statistics/distributions/gamma_cdf.m
--- a/scripts/statistics/distributions/gamma_cdf.m
+++ b/scripts/statistics/distributions/gamma_cdf.m
@@ -9,47 +9,49 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  gamma_cdf (x, a, b)
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the Gamma distribution with parameters a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} gamma_cdf (@var{x}, @var{a}, @var{b})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the Gamma distribution with parameters
+## @var{a} and @var{b}.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  CDF of the Gamma distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: CDF of the Gamma distribution
 
 function cdf = gamma_cdf (x, a, b)
 
   if (nargin != 3)
     usage ("gamma_cdf (x, a, b)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("gamma_cdf:  x, a and b must be of common size or scalars");
+    error ("gamma_cdf: x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   cdf = zeros (s, 1);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     cdf (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     cdf (k) = gammai (a(k), b(k) .* x(k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/gamma_inv.m b/scripts/statistics/distributions/gamma_inv.m
--- a/scripts/statistics/distributions/gamma_inv.m
+++ b/scripts/statistics/distributions/gamma_inv.m
@@ -9,60 +9,62 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  gamma_inv (x, a, b)
-##
-## For each component of x, compute the quantile (the inverse of the
-## CDF) at x of the Gamma distribution with parameters a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} gamma_inv (@var{x}, @var{a}, @var{b})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the Gamma distribution with parameters @var{a}
+## and @var{b}. 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Gamma distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Gamma distribution
 
 function inv = gamma_inv (x, a, b)
 
   if (nargin != 3)
     usage ("gamma_inv (x, a, b)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("gamma_inv:  x, a and b must be of common size or scalars");
+    error ("gamma_inv: x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   inv = zeros (s, 1);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a > 0) | !(b > 0));
-  if any (k)
+  if (any (k))
     inv (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x == 1) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     inv (k) = Inf * ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
-  if any (k)
+  if (any (k))
     a = a (k);
     b = b (k);
     x = x (k);
     y = a ./ b;
     l = find (x < eps);
-    if any (l)
+    if (any (l))
       y(l) = sqrt (eps) * ones (length (l), 1);
     endif
 
     y_old = y;
     for i = 1 : 100
       h     = (gamma_cdf (y_old, a, b) - x) ./ gamma_pdf (y_old, a, b);
       y_new = y_old - h;
       ind   = find (y_new <= eps);
diff --git a/scripts/statistics/distributions/gamma_pdf.m b/scripts/statistics/distributions/gamma_pdf.m
--- a/scripts/statistics/distributions/gamma_pdf.m
+++ b/scripts/statistics/distributions/gamma_pdf.m
@@ -9,48 +9,50 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  gamma_pdf (x, a, b)
-##
-## For each element of x, return the probability density function (PDF)
-## at x of the Gamma distribution with parameters a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} gamma_pdf (@var{x}, @var{a}, @var{b})
+## For each element of @var{x}, return the probability density function
+## (PDF) at @var{x} of the Gamma distribution with parameters @var{a}
+## and @var{b}.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  PDF of the Gamma distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: PDF of the Gamma distribution
 
 function pdf = gamma_pdf (x, a, b)
 
   if (nargin != 3)
     usage ("gamma_pdf (x, a, b)");
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("gamma_pdf:  x, a and b must be of common size or scalars");
+    error ("gamma_pdf: x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, s, 1);
   a   = reshape (a, s, 1);
   b   = reshape (b, s, 1);
   pdf = zeros (s, 1);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     pdf (k) = NaN * ones (length (k), 1);
   endif
 
   k = find ((x > 0) & (a > 0) & (b > 0));
-  if any (k)
-    pdf (k) = (b(k) .^ a(k)) .* (x(k) .^ (a(k) - 1)) ...
-        .* exp(-b(k) .* x(k)) ./ gamma (a(k));
+  if (any (k))
+    pdf(k) = ((b(k) .^ a(k)) .* (x(k) .^ (a(k) - 1))
+	      .* exp(-b(k) .* x(k)) ./ gamma (a(k)));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/gamma_rnd.m b/scripts/statistics/distributions/gamma_rnd.m
--- a/scripts/statistics/distributions/gamma_rnd.m
+++ b/scripts/statistics/distributions/gamma_rnd.m
@@ -9,52 +9,49 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  gamma_rnd (a, b [, r, c])
-##
-## gamma_rnd (a, b) returns a matrix of random samples from the Gamma
-## distribution with parameters a and b.  The size of the matrix is the
-## common size of a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} gamma_rnd (@var{a}, @var{b}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the Gamma
+## distribution with parameters @var{a} and @var{b}.  Both @var{a} and
+## @var{b} must be scalar or of size @var{r} by @var{c}.
 ##
-## gamma_rnd (a, b, r, c) returns an r by c matrix of random samples
-## from the Gamma distribution with parameters a and b.  Both a and b
-## must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{a} and @var{b}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Gamma distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Gamma distribution
 
 function rnd = gamma_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("gamma_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("gamma_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("gamma_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("gamma_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
-      error (strcat("gamma_rnd:  ",
-                    "a and b must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("gamma_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
-      error (["gamma_rnd:  ", ...
-              "a and b must be of common size or scalar"]);
+      error ("gamma_rnd: a and b must be of common size or scalar");
     endif
   else
-    usage ("gamma_rnd (a, b [, r, c])");
+    usage ("gamma_rnd (a, b, r, c)");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   rnd = zeros (1, s);
 
diff --git a/scripts/statistics/distributions/geometric_cdf.m b/scripts/statistics/distributions/geometric_cdf.m
--- a/scripts/statistics/distributions/geometric_cdf.m
+++ b/scripts/statistics/distributions/geometric_cdf.m
@@ -9,53 +9,52 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  geometric_cdf (x, p)
-##
-## For each element of x, compute the CDF at x of the geometric
-## distribution with parameter p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} geometric_cdf (@var{x}, @var{p})
+## For each element of @var{x}, compute the CDF at @var{x} of the
+## geometric distribution with parameter @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the geometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the geometric distribution
 
 function cdf = geometric_cdf (x, p)
 
   if (nargin != 2)
     usage ("geometric_cdf (x, p)");
   endif
 
   [retval, x, p] = common_size (x, p);
   if (retval > 0)
-    error (["geometric_cdf:  ", ...
-            "x and p must be of common size or scalar"]);
+    error ("geometric_cdf: x and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(p >= 0) | !(p <= 1));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == Inf) & (p >= 0) & (p <= 1));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x < Inf) & (x == round (x)) ...
-      & (p > 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (p > 0) & (p <= 1));
+  if (any (k))
     cdf(k) = 1 - ((1 - p(k)) .^ (x(k) + 1));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/geometric_inv.m b/scripts/statistics/distributions/geometric_inv.m
--- a/scripts/statistics/distributions/geometric_inv.m
+++ b/scripts/statistics/distributions/geometric_inv.m
@@ -9,53 +9,53 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  geometric_inv (x, p)
-##
-## For each element of x, compute the quantile at x of the geometric
-## distribution with parameter p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} geometric_inv (@var{x}, @var{p})
+## For each element of @var{x}, compute the quantile at @var{x} of the
+## geometric distribution with parameter @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the geometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the geometric distribution
 
 function inv = geometric_inv (x, p)
 
   if (nargin != 2)
     usage ("geometric_inv (x, p)");
   endif
 
   [retval, x, p] = common_size (x, p);
   if (retval > 0)
-    error (["geometric_inv:  ", ...
-            "x and p must be of common size or scalar"]);
+    error ("geometric_inv: x and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   p   = reshape (p, 1, s);
   inv = zeros (1, s);
 
   k = find (!(x >= 0) | !(x <= 1) | !(p >= 0) | !(p <= 1));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (p >= 0) & (p <= 1));
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & (p > 0) & (p <= 1));
-  if any (k)
-    inv(k) = max (ceil (log (1 - x(k)) ./ log (1 - p(k))) - 1, ...
-        zeros (1, length (k)));
+  if (any (k))
+    inv(k) = max (ceil (log (1 - x(k)) ./ log (1 - p(k))) - 1,
+		  zeros (1, length (k)));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/geometric_pdf.m b/scripts/statistics/distributions/geometric_pdf.m
--- a/scripts/statistics/distributions/geometric_pdf.m
+++ b/scripts/statistics/distributions/geometric_pdf.m
@@ -9,54 +9,53 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  geometric_pdf (x, p)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the geometric distribution with parameter p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} geometric_pdf (@var{x}, @var{p})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the geometric distribution with parameter @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the geometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the geometric distribution
 
 function pdf = geometric_pdf (x, p)
 
   if (nargin != 2)
     usage ("geometric_pdf (x, p)");
   endif
 
   [retval, x, p] = common_size (x, p);
   if (retval > 0)
-    error (["geometric_pdf:  ", ...
-            "x and p must be of common size or scalar"]);
+    error ("geometric_pdf: x and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(p >= 0) | !(p <= 1));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   ## Just for the fun of it ...
   k = find ((x == Inf) & (p == 0));
-  if any (k)
+  if (any (k))
     pdf(k) = ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x < Inf) & (x == round (x)) ...
-      & (p > 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (p > 0) & (p <= 1));
+  if (any (k))
     pdf(k) = p(k) .* ((1 - p(k)) .^ x(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/geometric_rnd.m b/scripts/statistics/distributions/geometric_rnd.m
--- a/scripts/statistics/distributions/geometric_rnd.m
+++ b/scripts/statistics/distributions/geometric_rnd.m
@@ -9,46 +9,44 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  geometric_rnd (p [, r, c])
-##
-## geometric_rnd (p) returns a matrix of random samples from the
-## geometric distribution with parameter p.  The size of the matrix is
-## the size of p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} geometric_rnd (@var{p}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## geometric distribution with parameter @var{p}, which must be a scalar
+## or of size @var{r} by @var{c}.
 ##
-## geometric_rnd (p, r, c) returns an r by c matrix of random samples
-## from the geometric distribution with parameter p, which must be a
-## scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the size of @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the geometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the geometric distribution
 
 function rnd = geometric_rnd (p, r, c)
 
   if (nargin == 3)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("geometric_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("geometric_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("geometric_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("geometric_rnd: c must be a positive integer");
     endif
     [retval, p] = common_size (p, zeros (r, c));
     if (retval > 0)
-      error (strcat("geometric_rnd:  ",
-                    "p must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("geometric_rnd: p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
-    usage ("geometric_rnd (p [, r, c])");
+    usage ("geometric_rnd (p, r, c)");
   endif
 
   [r, c] = size (p);
   s = r * c;
   p = reshape (p, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(p >= 0) | !(p <= 1));
diff --git a/scripts/statistics/distributions/hypergeometric_cdf.m b/scripts/statistics/distributions/hypergeometric_cdf.m
--- a/scripts/statistics/distributions/hypergeometric_cdf.m
+++ b/scripts/statistics/distributions/hypergeometric_cdf.m
@@ -9,27 +9,31 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## Compute the cumulative distribution function (CDF) at x of the
-## hypergeometric distribution with parameters m, t, and n.  This is the
-## probability of obtaining not more than x marked items when randomly
-## drawing a sample of size n without replacement from a population of
-## total size t containing m marked items.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} hypergeometric_cdf (@var{x}, @var{m}, @var{t}, @var{n})
+## Compute the cumulative distribution function (CDF) at @var{x} of the
+## hypergeometric distribution with parameters @var{m}, @var{t}, and
+## @var{n}.  This is the probability of obtaining not more than @var{x}
+## marked items when randomly drawing a sample of size @var{n} without
+## replacement from a population of total size @var{t} containing
+## @var{m} marked items.
 ##
-## The parameters m, t, and n must positive integers with m and n not
-## greater than t.
+## The parameters @var{m}, @var{t}, and @var{n} must positive integers
+## with @var{m} and @var{n} not greater than @var{t}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the hypergeometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the hypergeometric distribution
 
 function cdf = hypergeometric_cdf (x, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometrix_cdf (x, m, t, n)");
   endif
 
   if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
diff --git a/scripts/statistics/distributions/hypergeometric_inv.m b/scripts/statistics/distributions/hypergeometric_inv.m
--- a/scripts/statistics/distributions/hypergeometric_inv.m
+++ b/scripts/statistics/distributions/hypergeometric_inv.m
@@ -9,24 +9,28 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## For each element of x, compute the quantile at x of the hypergeometric
-## distribution with parameters m, t, and n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} hypergeometric_inv (@var{x}, @var{m}, @var{t}, @var{n})
+## For each element of @var{x}, compute the quantile at @var{x} of the
+## hypergeometric distribution with parameters @var{m}, @var{t}, and
+## @var{n}.
 ##
-## The parameters m, t, and n must positive integers with m and n not
-## greater than t.
+## The parameters @var{m}, @var{t}, and @var{n} must positive integers
+## with @var{m} and @var{n} not greater than @var{t}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the hypergeometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the hypergeometric distribution
 
 function inv = hypergeometric_inv (x, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometric_inv (x, m, t, n)");
   endif
 
   if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
diff --git a/scripts/statistics/distributions/hypergeometric_pdf.m b/scripts/statistics/distributions/hypergeometric_pdf.m
--- a/scripts/statistics/distributions/hypergeometric_pdf.m
+++ b/scripts/statistics/distributions/hypergeometric_pdf.m
@@ -9,56 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  hypergeometric_pdf (x, m, t, n)
-##
-## Compute the probability density function (PDF) at x of the
-## hypergeometric distribution with parameters m, t, and n. This is the
-## probability of obtaining x marked items when randomly drawing a
-## sample of size n without replacement from a population of total size
-## t containing m marked items.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} hypergeometric_pdf (@var{x}, @var{m}, @var{t}, @var{n})
+## Compute the probability density function (PDF) at @var{x} of the
+## hypergeometric distribution with parameters @var{m}, @var{t}, and
+## @var{n}. This is the probability of obtaining @var{x} marked items
+## when randomly drawing a sample of size @var{n} without replacement
+## from a population of total size @var{t} containing @var{m} marked items.
 ##
 ## The arguments must be of common size or scalar.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the hypergeometric distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the hypergeometric distribution
 
 function pdf = hypergeometric_pdf (x, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometric_pdf (x, m, t, n)");
   endif
 
   [retval, x, m, t, n] = common_size (x, m, t, n);
   if (retval > 0)
-    error (["hypergeometric_pdf:  ", ...
-            "x, m, t, and n must be of common size or scalar"]);
+    error ("hypergeometric_pdf: x, m, t, and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   t = reshape (t, 1, s);
   n = reshape (n, 1, s);
   pdf = zeros * ones (1, s);
   ## everything in i1 gives NaN
   i1 = ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
         (t != round (t)) | (n != round (n)) | (m > t) | (n > t));
   ## everything in i2 gives 0 unless in i1
   i2 = ((x != round (x)) | (x < 0) | (x > m) | (n < x) | (n-x > t-m));
   k = find (i1);
-  if any (k)
+  if (any (k))
     pdf (k) = NaN * ones (size (k));
   endif
   k = find (!i1 & !i2);
-  if any (k)
+  if (any (k))
     pdf (k) = (bincoeff (m(k), x(k)) .* bincoeff (t(k)-m(k), n(k)-x(k))
                ./ bincoeff (t(k), n(k)));
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/hypergeometric_rnd.m b/scripts/statistics/distributions/hypergeometric_rnd.m
--- a/scripts/statistics/distributions/hypergeometric_rnd.m
+++ b/scripts/statistics/distributions/hypergeometric_rnd.m
@@ -9,21 +9,25 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## Generate a row vector containing a random sample of size N from the
-## hypergeometric distribution with parameters m, t, and n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} hypergeometric_rnd (@var{N}, @var{m}, @var{t}, @var{n})
+## Generate a row vector containing a random sample of size @var{N} from
+## the hypergeometric distribution with parameters @var{m}, @var{t}, and
+## @var{n}.
 ##
-## The parameters m, t, and n must positive integers with m and n not
-## greater than t.
+## The parameters @var{m}, @var{t}, and @var{n} must positive integers
+## with @var{m} and @var{n} not greater than @var{t}.
+## @end deftypefn
 
 function rnd = hypergeometric_rnd (N, m, t, n)
 
   if (nargin != 4)
     usage ("hypergeometric_rnd (N, m, t, n)");
   endif
 
   if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -9,45 +9,59 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  kolmogorov_smirnov_cdf (x [, tol])
-##
-## Returns the CDF at x of the Kolmogorov-Smirnov distribution,
-## i.e. Q(x) = sum_{k=-\infty}^\infty (-1)^k exp(-2 k^2 x^2), x > 0.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} kolmogorov_smirnov_cdf (@var{x}, @var{tol})
+## Return the CDF at @var{x} of the Kolmogorov-Smirnov distribution,
+## @iftex
+## @tex
+## $$ Q(x) = sum_{k=-\infty}^\infty (-1)^k exp(-2 k^2 x^2) $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+##          Inf
+## Q(x) =   SUM    (-1)^k exp(-2 k^2 x^2)
+##        k = -Inf
+## @end example
+## @end ifinfo
 ##
-## The optional tol specifies the precision up to which the series
-## should be evaluated;  the default is tol = eps.
+## @noindent
+## for @var{x} > 0.
+##
+## The optional parameter @var{tol} specifies the precision up to which
+## the series should be evaluated;  the default is @var{tol} = @code{eps}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Kolmogorov-Smirnov distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Kolmogorov-Smirnov distribution
 
 function cdf = kolmogorov_smirnov_cdf (x, tol)
 
   if (nargin < 1 || nargin > 2)
-    usage ("kolmogorov_smirnov_cdf (x [, tol])");
+    usage ("kolmogorov_smirnov_cdf (x, tol)");
   endif
 
   if (nargin == 1)
     tol = eps;
   else
     if (!is_scalar (tol) || !(tol > 0))
-      error (["kolmogorov_smirnov_cdf:  ", ...
-              "tol has to be a positive scalar."]);
+      error ("kolmogorov_smirnov_cdf: tol has to be a positive scalar");
     endif
   endif
 
   [nr, nc] = size(x);
   if (min (nr, nc) == 0)
-    error ("kolmogorov_smirnov_cdf:  x must not be empty.");
+    error ("kolmogorov_smirnov_cdf: x must not be empty");
   endif
 
   n   = nr * nc;
   x   = reshape (x, 1, n);
   cdf = zeros (1, n);
   ind = find (x > 0);
   if (length (ind) > 0)
     y   = x(ind);
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -9,45 +9,46 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  laplace_cdf (x)
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the Laplace distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} laplace_cdf (@var{x})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the Laplace distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Laplace distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Laplace distribution
 
 function cdf = laplace_cdf (x)
 
   if (nargin != 1)
     usage ("laplace_cdf (x)");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find (x == Inf);
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x > -Inf) & (x < Inf));
-  if any (k)
+  if (any (k))
     cdf(k) = (1 + sign (x(k)) .* (1 - exp (- abs (x(k))))) / 2;
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -9,46 +9,47 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  laplace_inv (x)
-##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the Laplace distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} laplace_inv (@var{x})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the Laplace distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Laplace distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Laplace distribution
 
 function inv = laplace_inv (x)
 
   if (nargin != 1)
     usage ("laplace_inv (x)");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   inv = (-Inf) * ones (1, s);
 
   k = find (isnan (x) | (x < 0) | (x > 1));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find (x == 1);
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1));
-  if any (k)
-    inv(k) = (x(k) < 1/2) .* log (2 * x(k)) ...
-        - (x(k) > 1/2) .* log (2 * (1 - x(k)));
+  if (any (k))
+    inv(k) = ((x(k) < 1/2) .* log (2 * x(k))
+	      - (x(k) > 1/2) .* log (2 * (1 - x(k))));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -9,40 +9,41 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  laplace_pdf (x)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the Laplace distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} laplace_pdf (@var{x})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the Laplace distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the Laplace distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the Laplace distribution
 
 function pdf = laplace_pdf (x)
 
   if (nargin != 1)
     usage ("laplace_pdf (x)");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x > -Inf) & (x < Inf));
-  if any (k)
+  if (any (k))
     pdf(k) = exp (- abs (x(k))) / 2;
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -9,34 +9,35 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  laplace_rnd (r, c)
-##
-## Return an r by c matrix of random numbers from the Laplace
-## distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} laplace_rnd (@var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random numbers from the
+## Laplace distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Laplace distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Laplace distribution
 
 function rnd = laplace_rnd (r, c)
 
   if (nargin != 2)
     usage ("laplace_rnd (r, c)");
   endif
 
-  if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-    error ("laplace_rnd:  r must be a positive integer");
+  if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    error ("laplace_rnd: r must be a positive integer");
   endif
-  if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-    error ("laplace_rnd:  c must be a positive integer");
+  if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    error ("laplace_rnd: c must be a positive integer");
   endif
 
   tmp = rand (r, c);
   rnd = ((tmp < 1/2) .* log (2 * tmp)
          - (tmp > 1/2) .* log (2 * (1 - tmp)));
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -9,23 +9,24 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  logistic_cdf (x)
-##
-## For each component of x, compute the CDF at x of the logistic
-## distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} logistic_cdf (@var{x})
+## For each component of @var{x}, compute the CDF at @var{x} of the
+## logistic distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the logistic distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the logistic distribution
 
 function cdf = logistic_cdf (x)
 
   if (nargin != 1)
     usage ("logistic_cdf (x)");
   endif
 
   cdf = 1 ./ (1 + exp (- x));
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -9,50 +9,51 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  logistic_inv (x)
-##
-## For each component of x, compute the quantile (the inverse of the
-## CDF) at x of the logistic distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} logistic_inv (@var{x})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the logistic distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the logistic distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the logistic distribution
 
 function inv = logistic_inv (x)
 
   if (nargin != 1)
     usage ("logistic_inv (x)");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find (x == 0);
-  if any (k)
+  if (any (k))
     inv(k) = (-Inf) * ones (1, length (k));
   endif
 
   k = find (x == 1);
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1));
-  if any (k)
+  if (any (k))
     inv (k) = - log (1 ./ x(k) - 1);
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -9,23 +9,24 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  logistic_pdf (x)
-##
-## For each component of x, compute the PDF at x of the logistic
-## distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} logistic_pdf (@var{x})
+## For each component of @var{x}, compute the PDF at @var{x} of the
+## logistic distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the logistic distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the logistic distribution
 
 function pdf = logistic_pdf (x)
 
   if (nargin != 1)
     usage ("logistic_pdf (x)");
   endif
 
   cdf = logistic_cdf (x);
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -9,32 +9,33 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  logistic_rnd (r, c)
-##
-## Return an r by c matrix of random numbers from the logistic
-## distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} logistic_rnd (@var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random numbers from the
+## logistic distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the logistic distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the logistic distribution
 
 function rnd = logistic_rnd (r, c)
 
   if (nargin != 2)
     usage ("logistic_rnd (r, c)");
   endif
 
-  if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-    error ("logistic_rnd:  r must be a positive integer");
+  if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    error ("logistic_rnd: r must be a positive integer");
   endif
-  if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-    error ("logistic_rnd:  c must be a positive integer");
+  if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    error ("logistic_rnd: c must be a positive integer");
   endif
 
   rnd = - log (1 ./ rand (r, c) - 1);
 
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_cdf.m b/scripts/statistics/distributions/lognormal_cdf.m
--- a/scripts/statistics/distributions/lognormal_cdf.m
+++ b/scripts/statistics/distributions/lognormal_cdf.m
@@ -9,69 +9,68 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  lognormal_cdf (x [, a, v])
+## -*- texinfo -*-
+## @deftypefn {Function File} {} lognormal_cdf (@var{x}, @var{a}, @var{v})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the lognormal distribution with
+## parameters @var{a} and @var{v}.  If a random variable follows this
+## distribution, its logarithm is normally distributed with mean
+## @code{log (@var{a})} and variance @var{v}.
 ##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the lognormal distribution with parameters a and v. If
-## a random variable follows this distribution, its logarithm is
-## normally distributed with mean log (a) and variance v.
-##
-## Default values are a = 1, v = 1.
+## Default values are @var{a} = 1, @var{v} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the log normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the log normal distribution
 
 function cdf = lognormal_cdf (x, a, v)
 
-  if !((nargin == 1) || (nargin == 3))
-    usage ("lognormal_cdf (x [, a, v])");
+  if (! ((nargin == 1) || (nargin == 3)))
+    usage ("lognormal_cdf (x, a, v)");
   endif
 
   if (nargin == 1)
     a = 1;
     v = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
   ## not work (because exp (Inf) -> NaN etc):
   ## cdf = normal_cdf (log (x), log (a), v);
   ## Hence ...
 
   [retval, x, a, v] = common_size (x, a, v);
   if (retval > 0)
-    error (["lognormal_cdf:  ", ...
-        "x, a and v must be of common size or scalars"]);
+    error ("lognormal_cdf: x, a and v must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   cdf = zeros (1, s);
 
-  k = find (isnan (x) | !(a > 0) | !(a < Inf) ...
-      | !(v > 0) | !(v < Inf));
-  if any (k)
+  k = find (isnan (x) | !(a > 0) | !(a < Inf) | !(v > 0) | !(v < Inf));
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == Inf) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
-  k = find ((x > 0) & (x < Inf) & (a > 0) & (a < Inf) ...
-      & (v > 0) & (v < Inf));
-  if any (k)
+  k = find ((x > 0) & (x < Inf) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
+  if (any (k))
     cdf(k) = stdnormal_cdf ((log (x(k)) - log (a(k))) ./ sqrt (v(k)));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_inv.m b/scripts/statistics/distributions/lognormal_inv.m
--- a/scripts/statistics/distributions/lognormal_inv.m
+++ b/scripts/statistics/distributions/lognormal_inv.m
@@ -9,69 +9,69 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  lognormal_inv (x [, a, v])
+## -*- texinfo -*-
+## @deftypefn {Function File} {} lognormal_inv (@var{x}, @var{a}, @var{v})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the lognormal distribution with parameters @var{a}
+## and @var{v}.  If a random variable follows this distribution, its
+## logarithm is normally distributed with mean @code{log (@var{a})} and
+## variance @var{v}.
 ##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the lognormal distribution with parameters a and v. If a
-## random variable follows this distribution, its logarithm is normally
-## distributed with mean log (a) and variance v.
-##
-## Default values are a = 1, v = 1.
+## Default values are @var{a} = 1, @var{v} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the log normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the log normal distribution
 
 function inv = lognormal_inv (x, a, v)
 
-  if !((nargin == 1) || (nargin == 3))
-    usage ("lognormal_inv (x [, a, v])");
+  if (! ((nargin == 1) || (nargin == 3)))
+    usage ("lognormal_inv (x, a, v)");
   endif
 
   if (nargin == 1)
     a = 1;
     v = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
   ## not work (because exp (Inf) -> NaN):
   ## inv = exp (normal_inv (x, log (a), v));
   ## Hence ...
 
   [retval, x, a, v] = common_size (x, a, v);
   if (retval > 0)
-    error (["lognormal_inv:  ", ...
-            "x, a and v must be of common size or scalars"]);
+    error ("lognormal_inv: x, a and v must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   inv = zeros (1, s);
 
-  k = find (!(x >= 0) | !(x <= 1) | !(a > 0) | !(a < Inf) ...
-      | !(v > 0) | !(v < Inf));
-  if any (k)
+  k = find (!(x >= 0) | !(x <= 1) | !(a > 0) | !(a < Inf)
+	    | !(v > 0) | !(v < Inf));
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
-  k = find ((x > 0) & (x < 1) & (a > 0) & (a < Inf) ...
-      & (v > 0) & (v < Inf));
-  if any (k)
+  k = find ((x > 0) & (x < 1) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
+  if (any (k))
     inv(k) = a(k) .* exp (sqrt (v(k)) .* stdnormal_inv (x(k)));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_pdf.m b/scripts/statistics/distributions/lognormal_pdf.m
--- a/scripts/statistics/distributions/lognormal_pdf.m
+++ b/scripts/statistics/distributions/lognormal_pdf.m
@@ -9,64 +9,63 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  lognormal_pdf (x [, a, v])
+## -*- texinfo -*-
+## @deftypefn {Function File} {} lognormal_pdf (@var{x}, @var{a}, @var{v})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the lognormal distribution with parameters
+## @var{a} and @var{v}.  If a random variable follows this distribution,
+## its logarithm is normally distributed with mean @code{log (@var{a})}
+## and variance @var{v}.
 ##
-## For each element of x, compute the probability density function (PDF)
-## at x of the lognormal distribution with parameters a and v. If a
-## random variable follows this distribution, its logarithm is normally
-## distributed with mean log (a) and variance v.
-##
-## Default values are a = 1, v = 1.
+## Default values are @var{a} = 1, @var{v} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the log normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the log normal distribution
 
 function pdf = lognormal_pdf (x, a, v)
 
-  if !((nargin == 1) || (nargin == 3))
-    usage ("lognormal_pdf (x [, a, v])");
+  if (! ((nargin == 1) || (nargin == 3)))
+    usage ("lognormal_pdf (x, a, v)");
   endif
 
   if (nargin == 1)
     a = 1;
     v = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
   ## not work for the special cases (Inf, ...)
   ## pdf = (x > 0) ./ x .* normal_pdf (log (x), log (a), v);
   ## Hence ...
 
   [retval, x, a, v] = common_size (x, a, v);
   if (retval > 0)
-    error (["lognormal_pdf:  ", ...
-            "x, a and v must be of common size or scalars"]);
+    error ("lognormal_pdf: x, a and v must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   pdf = zeros (1, s);
 
-  k = find (isnan (x) | !(a > 0) | !(a < Inf) ...
-      | !(v > 0) | !(v < Inf));
-  if any (k)
+  k = find (isnan (x) | !(a > 0) | !(a < Inf) | !(v > 0) | !(v < Inf));
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((x > 0) & (x < Inf) & (a > 0) & (a < Inf) ...
-      & (v > 0) & (v < Inf));
-  if any (k)
+  k = find ((x > 0) & (x < Inf) & (a > 0) & (a < Inf) & (v > 0) & (v < Inf));
+  if (any (k))
     pdf(k) = normal_pdf (log (x(k)), log (a(k)), v(k)) ./ x(k);
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_rnd.m b/scripts/statistics/distributions/lognormal_rnd.m
--- a/scripts/statistics/distributions/lognormal_rnd.m
+++ b/scripts/statistics/distributions/lognormal_rnd.m
@@ -9,65 +9,62 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  lognormal_rnd (a, v [, r, c])
-##
-## lognormal_rnd (a, v) returns a matrix of random samples from the
-## lognormal distribution with parameters a and v.  The size of the
-## matrix is the common size of a and v.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} lognormal_rnd (@var{a}, @var{v}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## lognormal distribution with parameters @var{a} and @var{v}. Both
+## @var{a} and @var{v} must be scalar or of size @var{r} by @var{c}.
 ##
-## lognormal_rnd (a, v, r, c) returns an r by c matrix of random samples
-## from the lognormal distribution with parameters a and v. Both a and v
-## must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{a} and @var{v}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the log normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the log normal distribution
 
 function rnd = lognormal_rnd (a, v, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("lognormal_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("lognormal_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("lognormal_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("lognormal_rnd: c must be a positive integer");
     endif
     [retval, a, v] = common_size (a, v, zeros (r, c));
     if (retval > 0)
-      error (strcat("lognormal_rnd:  ",
-                    "a and v must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("lognormal_rnd: a and v must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, v] = common_size (a, v);
     if (retval > 0)
-      error (strcat("lognormal_rnd:  ",
-                    "a and v must be of common size or scalar"));
+      error ("lognormal_rnd: a and v must be of common size or scalar");
     endif
   else
-    usage ("lognormal_rnd (a, v [, r, c])");
+    usage ("lognormal_rnd (a, v, r, c)");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   v = reshape (v, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(a > 0) | !(a < Inf) | !(v > 0) | !(v < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((a > 0) & (a < Inf) & (v > 0) & (v < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = a(k) .* exp (sqrt (v(k)) .* randn (1, length (k)));
   endif
 
   rnd = reshape (rnd, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/normal_cdf.m b/scripts/statistics/distributions/normal_cdf.m
--- a/scripts/statistics/distributions/normal_cdf.m
+++ b/scripts/statistics/distributions/normal_cdf.m
@@ -9,55 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  normal_cdf (x [, m, v])
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the normal distribution with mean m and variance v.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} normal_cdf (@var{x}, @var{m}, @var{v})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the normal distribution with mean
+## @var{m} and variance @var{v}.
 ##
-## Default values are m = 0, v = 1.
+## Default values are @var{m} = 0, @var{v} = 1.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  CDF of the normal distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: CDF of the normal distribution
 
 function cdf = normal_cdf (x, m, v)
 
-  if !((nargin == 1) || (nargin == 3))
-    usage ("normal_cdf (x [, m, v])");
+  if (! ((nargin == 1) || (nargin == 3)))
+    usage ("normal_cdf (x, m, v)");
   endif
 
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   [retval, x, m, v] = common_size (x, m, v);
   if (retval > 0)
-    error (["normal_cdf:  ", ...
-            "x, m and v must be of common size or scalars"]);
+    error ("normal_cdf: x, m and v must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   cdf = zeros (1, s);
 
   k = find (isinf (m) | isnan (m) | !(v >= 0) | !(v < Inf));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find (!isinf (m) & !isnan (m) & (v > 0) & (v < Inf));
-  if any (k)
+  if (any (k))
     cdf(k) = stdnormal_cdf ((x(k) - m(k)) ./ sqrt (v(k)));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/normal_inv.m b/scripts/statistics/distributions/normal_inv.m
--- a/scripts/statistics/distributions/normal_inv.m
+++ b/scripts/statistics/distributions/normal_inv.m
@@ -9,55 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  normal_inv (x [, m, v])
-##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the normal distribution with mean m and variance v.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} normal_inv (@var{x}, @var{m}, @var{v})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the normal distribution with mean @var{m} and
+## variance @var{v}.
 ##
-## Default values are m = 0, v = 1.
+## Default values are @var{m} = 0, @var{v} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the normal distribution
 
 function inv = normal_inv (x, m, v)
 
-  if !((nargin == 1) || (nargin == 3))
-    usage ("normal_inv (x [, m, v])");
+  if (! ((nargin == 1) || (nargin == 3)))
+    usage ("normal_inv (x, m, v)");
   endif
 
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   [retval, x, m, v] = common_size (x, m, v);
   if (retval > 0)
-    error (["normal_inv:  ", ...
-            "x, m and v must be of common size or scalars"]);
+    error ("normal_inv: x, m and v must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   inv = zeros (1, s);
 
   k = find (isinf (m) | isnan (m) | !(v >= 0) | !(v < Inf));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find (!isinf (m) & !isnan (m) & (v > 0) & (v < Inf));
-  if any (k)
+  if (any (k))
     inv(k) = m(k) + sqrt (v(k)) .* stdnormal_inv (x(k));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/normal_pdf.m b/scripts/statistics/distributions/normal_pdf.m
--- a/scripts/statistics/distributions/normal_pdf.m
+++ b/scripts/statistics/distributions/normal_pdf.m
@@ -9,56 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  normal_pdf (x [, m, v])
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the normal distribution with mean m and variance v.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} normal_pdf (@var{x}, @var{m}, @var{v})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the normal distribution with mean @var{m} and
+## variance @var{v}.
 ##
-## Default values are m = 0, v = 1.
+## Default values are @var{m} = 0, @var{v} = 1.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  PDF of the normal distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: PDF of the normal distribution
 
 function pdf = normal_pdf (x, m, v)
 
-  if !((nargin == 1) || (nargin == 3))
-    usage ("normal_pdf (x [, m, v])");
+  if (! ((nargin == 1) || (nargin == 3)))
+    usage ("normal_pdf (x, m, v)");
   endif
 
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   [retval, x, m, v] = common_size (x, m, v);
   if (retval > 0)
-    error (["normal_pdf:  ", ...
-            "x, m and v must be of common size or scalars"]);
+    error ("normal_pdf: x, m and v must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   pdf = zeros (1, s);
 
   k = find (isinf (m) | isnan (m) | !(v >= 0) | !(v < Inf));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find (!isinf (m) & !isnan (m) & (v > 0) & (v < Inf));
-  if any (k)
-    pdf(k) = stdnormal_pdf ((x(k) - m(k)) ./ sqrt (v(k))) ...
-        ./ sqrt (v(k));
+  if (any (k))
+    pdf(k) = stdnormal_pdf ((x(k) - m(k)) ./ sqrt (v(k))) ./ sqrt (v(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/normal_rnd.m b/scripts/statistics/distributions/normal_rnd.m
--- a/scripts/statistics/distributions/normal_rnd.m
+++ b/scripts/statistics/distributions/normal_rnd.m
@@ -9,64 +9,62 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  normal_rnd (m, v [, r, c])
-##
-## normal_rnd (m, v) returns a matrix of random samples from the normal
-## distribution with parameters m and v.  The size of the matrix is the
-## common size of m and v.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} normal_rnd (@var{m}, @var{v}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## normal distribution with parameters @var{m} and @var{v}.  Both
+## @var{m} and @var{v} must be scalar or of size @var{r} by @var{c}.
 ##
-## normal_rnd (m, v, r, c) returns an r by c matrix of random samples
-## from the normal distribution with parameters m and v.  Both m and v
-## must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{m} and @var{v}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the normal distribution
 
 function rnd = normal_rnd (m, v, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("normal_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("normal_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("normal_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("normal_rnd: c must be a positive integer");
     endif
     [retval, m, v] = common_size (m, v, zeros (r, c));
     if (retval > 0)
-      error (strcat("normal_rnd:  ",
-                    "m and v must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("normal_rnd: m and v must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, m, v] = common_size (m, v);
     if (retval > 0)
-      error ("normal_rnd:  m and v must be of common size or scalar");
+      error ("normal_rnd: m and v must be of common size or scalar");
     endif
   else
-    usage ("normal_rnd (m, v [, r, c])");
+    usage ("normal_rnd (m, v, r, c)");
   endif
 
   [r, c] = size (m);
   s = r * c;
   m = reshape (m, 1, s);
   v = reshape (v, 1, s);
   rnd = zeros (1, s);
 
   k = find (isnan (m) | isinf (m) | !(v > 0) | !(v < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((m > -Inf) & (m < Inf) & (v > 0) & (v < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = m(k) + sqrt (v(k)) .* randn (1, length (k));
   endif
 
   rnd = reshape (rnd, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/pascal_cdf.m b/scripts/statistics/distributions/pascal_cdf.m
--- a/scripts/statistics/distributions/pascal_cdf.m
+++ b/scripts/statistics/distributions/pascal_cdf.m
@@ -9,70 +9,71 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  pascal_cdf (x, n, p)
-##
-## For each element of x, compute the CDF at x of the Pascal (negative
-## binomial) distribution with parameters n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} pascal_cdf (@var{x}, @var{n}, @var{p})
+## For each element of @var{x}, compute the CDF at x of the Pascal
+## (negative binomial) distribution with parameters @var{n} and @var{p}.
 ##
 ## The number of failures in a Bernoulli experiment with success
-## probability p before the n-th success follows this distribution.
+## probability @var{p} before the @var{n}-th success follows this
+## distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Pascal (negative binomial) distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Pascal (negative binomial) distribution
 
 function cdf = pascal_cdf (x, n, p)
 
   if (nargin != 3)
     usage ("pascal_cdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
-    error (["pascal_cdf:  ", ...
-            "x, n and p must be of common size or scalar"]);
+    error ("pascal_cdf: x, n and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
-  k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n)) ...
-      | (p < 0) | (p > 1));
-  if any (k)
+  k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
+	    | (p < 0) | (p > 1));
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1));
-  if any (k)
+  k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n))
+	    & (p >= 0) & (p <= 1));
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0) ...
-      & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0)
+	    & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
+  if (any (k))
     ## Does anyone know a better way to do the summation?
     m = zeros (1, length (k));
     x = floor (x(k));
     n = n(k);
     p = p(k);
     y = cdf(k);
     while (1)
       l = find (m <= x);
-      if any (l)
+      if (any (l))
         y(l) = y(l) + pascal_pdf (m(l), n(l), p(l));
         m(l) = m(l) + 1;
       else
         break;
       endif
     endwhile
     cdf(k) = y;
   endif
diff --git a/scripts/statistics/distributions/pascal_inv.m b/scripts/statistics/distributions/pascal_inv.m
--- a/scripts/statistics/distributions/pascal_inv.m
+++ b/scripts/statistics/distributions/pascal_inv.m
@@ -9,69 +9,71 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  pascal_inv (x, n, p)
-##
-## For each element of x, compute the quantile at x of the Pascal
-## (negative binomial) distribution with parameters n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} pascal_inv (@var{x}, @var{n}, @var{p})
+## For each element of @var{x}, compute the quantile at @var{x} of the
+## Pascal (negative binomial) distribution with parameters @var{n} and
+## @var{p}.
 ##
 ## The number of failures in a Bernoulli experiment with success
-## probability p before the n-th success follows this distribution.
+## probability @var{p} before the @var{n}-th success follows this
+## distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Pascal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Pascal distribution
 
 function inv = pascal_inv (x, n, p)
 
   if (nargin != 3)
     usage ("pascal_inv (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
-    error (["pascal_inv:  ", ...
-            "x, n and p must be of common size or scalar"]);
+    error ("pascal_inv: x, n and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   inv = zeros (1, s);
 
-  k = find (isnan (x) | (x < 0) | (x > 1) | (n < 1) | (n == Inf) ...
-      | (n != round (n)) | (p < 0) | (p > 1));
-  if any (k)
+  k = find (isnan (x) | (x < 0) | (x > 1) | (n < 1) | (n == Inf)
+	    | (n != round (n)) | (p < 0) | (p > 1));
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((x == 1) & (n > 0) & (n < Inf) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1));
-  if any (k)
+  k = find ((x == 1) & (n > 0) & (n < Inf) & (n == round (n))
+	    & (p >= 0) & (p <= 1));
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x < 1) & (n > 0) & (n < Inf) ...
-      & (n == round (n)) & (p > 0) & (p <= 1));
-  if any (k)
+  k = find ((x >= 0) & (x < 1) & (n > 0) & (n < Inf)
+	    & (n == round (n)) & (p > 0) & (p <= 1));
+  if (any (k))
     x = x(k);
     n = n(k);
     p = p(k);
     m = zeros (1, length (k));
     s = p .^ n;
     while (1)
       l = find (s < x);
-      if any (l)
+      if (any (l))
         m(l) = m(l) + 1;
         s(l) = s(l) + pascal_pdf (m(l), n(l), p(l));
       else
         break;
       endif
     endwhile
     inv(k) = m;
   endif
diff --git a/scripts/statistics/distributions/pascal_pdf.m b/scripts/statistics/distributions/pascal_pdf.m
--- a/scripts/statistics/distributions/pascal_pdf.m
+++ b/scripts/statistics/distributions/pascal_pdf.m
@@ -9,62 +9,62 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  pascal_pdf (x, n, p)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the Pascal (negative binomial) distribution with parameters n
-## and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} pascal_pdf (@var{x}, @var{n}, @var{p})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the Pascal (negative binomial) distribution with
+## parameters @var{n} and @var{p}.
 ##
 ## The number of failures in a Bernoulli experiment with success
-## probability p before the n-th success follows this distribution.
+## probability @var{p} before the @var{n}-th success follows this
+## distribution. 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the Pascal (negative binomial) distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the Pascal (negative binomial) distribution
 
 function pdf = pascal_pdf (x, n, p)
 
   if (nargin != 3)
     usage ("pascal_pdf (x, n, p)");
   endif
 
   [retval, x, n, p] = common_size (x, n, p);
   if (retval > 0)
-    error (["pascal_pdf:  ", ...
-            "x, n and p must be of common size or scalar"]);
+    error ("pascal_pdf: x, n and p must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x   = reshape (x, 1, s);
   n   = reshape (n, 1, s);
   p   = reshape (p, 1, s);
   cdf = zeros (1, s);
 
-  k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n)) ...
-      | (p < 0) | (p > 1));
-  if any (k)
+  k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
+	    | (p < 0) | (p > 1));
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   ## Just for the fun of it ...
-  k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n)) ...
-      & (p == 0));
-  if any (k)
+  k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n))
+	    & (p == 0));
+  if (any (k))
     pdf(k) = ones (1, length (k));
   endif
 
-  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0) ...
-      & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
-  if any (k)
-    pdf(k) = bincoeff (-n(k), x(k)) .* (p(k) .^ n(k)) ...
-        .* ((p(k) - 1) .^ x(k));
+  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0)
+	    & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
+  if (any (k))
+    pdf(k) = bincoeff (-n(k), x(k)) .* (p(k) .^ n(k)) .* ((p(k) - 1) .^ x(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/pascal_rnd.m b/scripts/statistics/distributions/pascal_rnd.m
--- a/scripts/statistics/distributions/pascal_rnd.m
+++ b/scripts/statistics/distributions/pascal_rnd.m
@@ -9,67 +9,63 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  pascal_rnd (n, p [, r, c])
-##
-## pascal_rnd (n, p) returns a matrix of random samples from the Pascal
-## (negative binomial) distribution with parameters n and p. The size of
-## the matrix is the common size of n and p.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} pascal_rnd (@var{n}, @var{p}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the Pascal
+## (negative binomial) distribution with parameters @var{n} and @var{p}.
+## Both @var{n} and @var{p} must be scalar or of size @var{r} by @var{c}. 
 ##
-## pascal_rnd (n, p, r, c) returns an r by c matrix of random samples
-## from the Pascal distribution with parameters n and p. Both n and p
-## must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{n} and @var{p}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Pascal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Pascal distribution
 
 function rnd = pascal_rnd (n, p, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("pascal_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("pascal_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("pascal_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("pascal_rnd: c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
-      error (strcat("pascal_rnd:  ",
-                    "n and p must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("pascal_rnd: n and p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
     if (retval > 0)
-      error ("pascal_rnd:  n and p must be of common size or scalar");
+      error ("pascal_rnd: n and p must be of common size or scalar");
     endif
   else
-    usage ("pascal_rnd (n, p [, r, c])");
+    usage ("pascal_rnd (n, p, r, c)");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   p = reshape (p, 1, s);
   rnd = zeros (1, s);
 
-  k = find (!(n > 0) | !(n < Inf) | !(n == round (n)) ...
-      | !(p <= 0) | !(p >= 1));
+  k = find (!(n > 0) | !(n < Inf) | !(n == round (n)) | !(p <= 0) | !(p >= 1));
   if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
 
-  k = find ((n > 0) & (n < Inf) & (n == round (n)) ...
-      & (p >= 0) & (p <= 1));
+  k = find ((n > 0) & (n < Inf) & (n == round (n)) & (p >= 0) & (p <= 1));
   if (any (k))
     N = max (n(k));
     L = length (k);
     tmp = floor (log (rand (N, L)) ./ (ones (N, 1) * log (1 - p(k))));
     ind = (1 : N)' * ones (1, L);
     rnd(k) = sum (tmp .* (ind <= ones (N, 1) * n(k)));
   endif
 
diff --git a/scripts/statistics/distributions/poisson_cdf.m b/scripts/statistics/distributions/poisson_cdf.m
--- a/scripts/statistics/distributions/poisson_cdf.m
+++ b/scripts/statistics/distributions/poisson_cdf.m
@@ -9,23 +9,25 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  poisson_cdf (x, lambda)
-##
-## For each element of x, compute the cumulative distribution function
-## (CDF) at x of the Poisson distribution with parameter lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} poisson_cdf (@var{x}, @var{lambda})
+## For each element of @var{x}, compute the cumulative distribution
+## function (CDF) at @var{x} of the Poisson distribution with parameter
+## lambda.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Poisson distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Poisson distribution
 
 function cdf = poisson_cdf (x, l)
 
   if (nargin != 2)
     usage ("poisson_cdf (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
@@ -35,25 +37,25 @@ function cdf = poisson_cdf (x, l)
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(l > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == Inf) & (l > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x >= 0) & (x < Inf) & (l > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = 1 - gammai (floor (x(k)) + 1, l(k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/poisson_inv.m b/scripts/statistics/distributions/poisson_inv.m
--- a/scripts/statistics/distributions/poisson_inv.m
+++ b/scripts/statistics/distributions/poisson_inv.m
@@ -9,58 +9,59 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  poisson_inv (x, lambda)
-##
-## For each component of x, compute the quantile (the inverse of the
-## CDF) at x of the Poisson distribution with parameter lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} poisson_inv (@var{x}, @var{lambda})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the Poisson distribution with parameter
+## @var{lambda}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Poisson distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Poisson distribution
 
 function inv = poisson_inv (x, l)
 
   if (nargin != 2)
     usage ("poisson_inv (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
-    error (["poisson_inv:  ", ...
-            "x and lambda must be of common size or scalar"]);
+    error ("poisson_inv: x and lambda must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(l > 0));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (l > 0));
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & (l > 0));
-  if any (k)
+  if (any (k))
     cdf = exp (-l(k));
     while (1)
       m = find (cdf < x(k));
-      if any (m)
+      if (any (m))
         inv(k(m)) = inv(k(m)) + 1;
         cdf(m) = cdf(m) + poisson_pdf (inv(k(m)), l(k(m)));
       else
         break;
       endif
     endwhile
   endif
 
diff --git a/scripts/statistics/distributions/poisson_pdf.m b/scripts/statistics/distributions/poisson_pdf.m
--- a/scripts/statistics/distributions/poisson_pdf.m
+++ b/scripts/statistics/distributions/poisson_pdf.m
@@ -9,47 +9,47 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  poisson_pdf (x, lambda)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the poisson distribution with parameter lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} poisson_pdf (@var{x}, @var{lambda})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the poisson distribution with parameter @var{lambda}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the Poisson distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the Poisson distribution
 
 function pdf = poisson_pdf (x, l)
 
   if (nargin != 2)
     usage ("poisson_pdf (x, lambda)");
   endif
 
   [retval, x, l] = common_size (x, l);
   if (retval > 0)
-    error (["poisson_pdf:  ", ...
-            "x and lambda must be of common size or scalar"]);
+    error ("poisson_pdf: x and lambda must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   l = reshape (l, 1, s);
   pdf = zeros (1, s);
 
   k = find (!(l > 0) | isnan (x));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (l > 0));
-  if any (k)
+  if (any (k))
     pdf(k) = exp (x(k) .* log (l(k)) - l(k) - lgamma (x(k) + 1));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/poisson_rnd.m b/scripts/statistics/distributions/poisson_rnd.m
--- a/scripts/statistics/distributions/poisson_rnd.m
+++ b/scripts/statistics/distributions/poisson_rnd.m
@@ -9,46 +9,44 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  poisson_rnd (lambda [, r, c])
-##
-## poisson_rnd (lambda) returns a matrix of random samples from the
-## Poisson distribution with parameter lambda.  The size of the matrix
-## is the size of lambda.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} poisson_rnd (@var{lambda}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## Poisson distribution with parameter @var{lambda}, which must be a 
+## scalar or of size @var{r} by @var{c}.
 ##
-## poisson_rnd (lambda, r, c) returns an r by c matrix of random samples
-## from the Poisson distribution with parameter lambda, which must be a
-## scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the size of @var{lambda}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Poisson distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Poisson distribution
 
 function rnd = poisson_rnd (l, r, c)
 
   if (nargin == 3)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("poisson_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("poisson_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("poisson_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("poisson_rnd: c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
-      error (strcat("poisson_rnd:  ",
-                    "lambda must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("poisson_rnd: lambda must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
-    usage ("poisson_rnd (lambda [, r, c])");
+    usage ("poisson_rnd (lambda, r, c)");
   endif
 
   [r, c] = size (l);
   s = r * c;
   l = reshape (l, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(l > 0) | !(l < Inf));
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -9,33 +9,34 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  stdnormal_cdf (x)
-##
-## For each component of x, compute the CDF of the standard normal
-## distribution at x.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} stdnormal_cdf (@var{x})
+## For each component of @var{x}, compute the CDF of the standard normal
+## distribution at @var{x}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the standard normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the standard normal distribution
 
 function cdf = stdnormal_cdf (x)
 
   if (nargin != 1)
     usage ("stdnormal_cdf (x)");
   endif
 
   [r_x, c_x] = size (x);
   if (r_x * c_x == 0)
-    error ("stdnormal_cdf:  x must not be empty.");
+    error ("stdnormal_cdf: x must not be empty.");
   endif
 
   cdf = ( ones (r_x, c_x) + erf (x / sqrt(2)) ) / 2;
 
 endfunction
 
 
 
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -9,23 +9,24 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  stdnormal_inv (x)
-##
-## For each component of x, compute compute the quantile (the inverse of
-## the CDF) at x of the standard normal distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} stdnormal_inv (@var{x})
+## For each component of @var{x}, compute compute the quantile (the
+## inverse of the CDF) at @var{x} of the standard normal distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the standard normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the standard normal distribution
 
 function inv = stdnormal_inv (x)
 
   if (nargin != 1)
     usage ("stdnormal_inv (x)");
   endif
 
   inv = sqrt (2) * erfinv (2 * x - 1);
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -9,40 +9,41 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  stdnormal_pdf (x)
-##
-## For each element of x, compute the probability density function (PDF)
-## of the standard normal distribution at x.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} stdnormal_pdf (@var{x})
+## For each element of @var{x}, compute the probability density function
+## (PDF) of the standard normal distribution at @var{x}.
+## @end deftypefn
 
-## Author:  TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description:  PDF of the standard normal distribution
+## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
+## Description: PDF of the standard normal distribution
 
 function pdf = stdnormal_pdf (x)
 
   if (nargin != 1)
     usage ("stdnormal_pdf (x)");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find (!isinf (x));
-  if any (k)
+  if (any (k))
     pdf (k) = (2 * pi)^(- 1/2) * exp( - x(k) .^ 2 / 2);
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -9,32 +9,33 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  stdnormal_rnd (r, c)
-##
-## Return an r by c matrix of random numbers from the standard normal
-## distribution.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} stdnormal_rnd (@var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random numbers from the
+## standard normal distribution.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the standard normal distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the standard normal distribution
 
 function rnd = stdnormal_rnd (r, c)
 
   if (nargin != 2)
     usage ("stdnormal_rnd (r, c)");
   endif
 
-  if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-    error ("stdnormal_rnd:  r must be a positive integer");
+  if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    error ("stdnormal_rnd: r must be a positive integer");
   endif
-  if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-    error ("stdnormal_rnd:  c must be a positive integer");
+  if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    error ("stdnormal_rnd: c must be a positive integer");
   endif
 
   rnd = randn (r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/t_cdf.m b/scripts/statistics/distributions/t_cdf.m
--- a/scripts/statistics/distributions/t_cdf.m
+++ b/scripts/statistics/distributions/t_cdf.m
@@ -9,63 +9,64 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  t_cdf (x, n)
-##
-## For each element of x, compute the CDF at x of the Student (t)
-## distribution with n degrees of freedom, i.e., PROB( t(n) <= x ).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} t_cdf (@var{x}, @var{n})
+## For each element of @var{x}, compute the CDF at @var{x} of the
+## t (Student) distribution with @var{n} degrees of freedom, i.e.,
+## PROB (t(@var{n}) <= @var{x}).
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the t distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the t distribution
 
 function cdf = t_cdf (x, n)
 
   if (nargin != 2)
     usage ("t_cdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
-    error ("t_cdf:  x and n must be of common size or scalar");
+    error ("t_cdf: x and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   n = reshape (n, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(n > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == Inf) & (n > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x > -Inf) & (x < Inf) & (n > 0));
-  if any (k)
+  if (any (k))
     cdf(k) = betai (n(k) / 2, 1 / 2, 1 ./ (1 + x(k) .^ 2 ./ n(k))) / 2;
     ind = find (x(k) > 0);
-    if any (ind)
+    if (any (ind))
       cdf(k(ind)) = 1 - cdf(k(ind));
     endif
   endif
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  n should be positive integer\n");
+  if (any (k))
+    warning ("t_cdf: n should be positive integer");
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/t_inv.m b/scripts/statistics/distributions/t_inv.m
--- a/scripts/statistics/distributions/t_inv.m
+++ b/scripts/statistics/distributions/t_inv.m
@@ -9,75 +9,77 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  t_inv (x, n)
-##
-## For each component of x, compute the quantile (the inverse of the
-## CDF) at x of the t (Student) distribution with parameter n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} t_inv (@var{x}, @var{n})
+## For each component of @var{x}, compute the quantile (the inverse of
+## the CDF) at @var{x} of the t (Student) distribution with parameter
+## @var{n}.
+## @end deftypefn
 
 ## For very large n, the "correct" formula does not really work well,
 ## and the quantiles of the standard normal distribution are used
 ## directly.
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the t distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the t distribution
 
 function inv = t_inv (x, n)
 
   if (nargin != 2)
     usage ("t_inv (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
-    error ("t_inv:  x and n must be of common size or scalar");
+    error ("t_inv: x and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   n = reshape (n, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(n > 0));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x == 0) & (n > 0));
-  if any (k)
+  if (any (k))
     inv(k) = (-Inf) * ones (1, length (k));
   endif
 
   k = find ((x == 1) & (n > 0));
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & (n > 0) & (n < 10000));
-  if any (k)
-    inv(k) = sign (x(k) - 1/2) .* sqrt (n(k) .* (1 ...
-        ./ beta_inv (2 * min (x(k), 1 - x(k)), n(k) / 2, 1 / 2) - 1));
+  if (any (k))
+    inv(k) = (sign (x(k) - 1/2)
+	      .* sqrt (n(k) .* (1 ./ beta_inv (2*min (x(k), 1 - x(k)),
+					       n(k)/2, 1/2) - 1)));
   endif
 
   ## For large n, use the quantiles of the standard normal
   k = find ((x > 0) & (x < 1) & (n >= 10000));
-  if any (k)
+  if (any (k))
     inv(k) = stdnormal_inv (x(k));
   endif
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
-  if any (k)
-    fprintf (stderr, ...
-             "WARNING:  n should be positive integer\n");
+  if (any (k))
+    warning ("t_inv: n should be positive integer");
     inv(k) = NaN * ones (1, length (k));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/t_pdf.m b/scripts/statistics/distributions/t_pdf.m
--- a/scripts/statistics/distributions/t_pdf.m
+++ b/scripts/statistics/distributions/t_pdf.m
@@ -9,55 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  t_pdf (x, n)
-##
-## For each element of x, compute the probability density function (PDF)
-## at x of the t (Student) distribution with n degrees of freedom.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} t_pdf (@var{x}, @var{n})
+## For each element of @var{x}, compute the probability density function
+## (PDF) at @var{x} of the @var{t} (Student) distribution with @var{n}
+## degrees of freedom. 
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the t distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the t distribution
 
 function pdf = t_pdf (x, n)
 
   if (nargin != 2)
     usage ("t_pdf (x, n)");
   endif
 
   [retval, x, n] = common_size (x, n);
   if (retval > 0)
-    error ("t_pdf:  x and n must be of common size or scalar");
+    error ("t_pdf: x and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   n = reshape (n, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x) | !(n > 0) | !(n < Inf));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find (!isinf (x) & !isnan (x) & (n > 0) & (n < Inf));
-  if any (k)
-    pdf(k) = exp (- (n(k) + 1) .* log (1 + x(k) .^ 2 ./ n(k)) / 2) ...
-      ./ (sqrt (n(k)) .* beta (n(k) / 2, 1 / 2));
+  if (any (k))
+    pdf(k) = (exp (- (n(k) + 1) .* log (1 + x(k) .^ 2 ./ n(k))/2)
+	      ./ (sqrt (n(k)) .* beta (n(k)/2, 1/2)));
   endif
 
   ## should we really only allow for positive integer n?
   k = find (n != round (n));
-  if any (k)
-    fprintf (stderr, ...
-        "WARNING:  n should be positive integer\n");
+  if (any (k))
+    warning ("t_pdf: n should be positive integer");
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/t_rnd.m b/scripts/statistics/distributions/t_rnd.m
--- a/scripts/statistics/distributions/t_rnd.m
+++ b/scripts/statistics/distributions/t_rnd.m
@@ -9,58 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  t_rnd (n [, r, c])
-##
-## t_rnd (n) returns a matrix of random samples from the t (Student)
-## distribution with n degrees of freedom.  The size of the matrix is
-## the size of n.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} t_rnd (@var{n}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the t
+## (Student) distribution with @var{n} degrees of freedom.  @var{n} must
+## be a scalar or of size @var{r} by @var{c}.
 ##
-## t_rnd (n, r, c) returns an r by c matrix of random samples from the t
-## distribution with n degrees of freedom.  n must be a scalar or of
-## size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the size of @var{n}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the t distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the t distribution
 
 function rnd = t_rnd (n, r, c)
 
   if (nargin == 3)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("t_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("t_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("t_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("t_rnd: c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
-      error (strcat("t_rnd:  ",
-                    "n must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("t_rnd: n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
-    usage ("t_rnd (n [, r, c])");
+    usage ("t_rnd (n, r, c)");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n = reshape (n, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(n > 0) | !(n < Inf) | !(n == round (n)));
-  if any (k)
+  if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((n > 0) & (n < Inf) & (n == round (n)));
-  if any (k)
+  if (any (k))
     rnd(k) = t_inv (rand (1, length (k)), n(k));
   endif
 
   rnd = reshape (rnd, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/uniform_cdf.m b/scripts/statistics/distributions/uniform_cdf.m
--- a/scripts/statistics/distributions/uniform_cdf.m
+++ b/scripts/statistics/distributions/uniform_cdf.m
@@ -9,60 +9,60 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  uniform_cdf (x [, a, b])
-##
-## Returns the CDF at x of the uniform distribution on [a, b], i.e.,
-## PROB( uniform(a,b) <= x ).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} uniform_cdf (@var{x}, @var{a}, @var{b})
+## Return the CDF at @var{x} of the uniform distribution on [@var{a},
+## @var{b}], i.e., PROB (uniform (@var{a}, @var{b}) <= x).
 ##
-## Default values are a = 0, b = 1.
+## Default values are @var{a} = 0, @var{b} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the uniform distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the uniform distribution
 
 function cdf = uniform_cdf (x, a, b)
 
-  if !(nargin == 1 || nargin == 3)
-    usage ("uniform_cdf (x [, a, b])");
+  if (! (nargin == 1 || nargin == 3))
+    usage ("uniform_cdf (x, a, b)");
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error (["uniform_cdf:  ", ...
-            "x, a and b must be of common size or scalar"]);
+    error ("uniform_cdf: x, a and b must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   cdf = zeros (1, s);
 
   k = find (isnan (x) | !(a < b));
-  if any (k)
+  if (any (k))
     cdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x >= b) & (a < b));
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   k = find ((x > a) & (x < b));
-  if any (k)
+  if (any (k))
     cdf(k) = (x(k) < b(k)) .* (x(k) - a(k)) ./ (b(k) - a(k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/uniform_inv.m b/scripts/statistics/distributions/uniform_inv.m
--- a/scripts/statistics/distributions/uniform_inv.m
+++ b/scripts/statistics/distributions/uniform_inv.m
@@ -9,54 +9,55 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  uniform_inv (x [, a, b])
-##
-## For each element of x, compute the quantile (the inverse of the CDF)
-## at x of the uniform distribution on [a, b].
+## -*- texinfo -*-
+## @deftypefn {Function File} {} uniform_inv (@var{x}, @var{a}, @var{b})
+## For each element of @var{x}, compute the quantile (the inverse of the
+## CDF) at @var{x} of the uniform distribution on [@var{a}, @var{b}].
 ##
-## Default values are a = 0, b = 1.
+## Default values are @var{a} = 0, @var{b} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the uniform distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the uniform distribution
 
 function inv = uniform_inv (x, a, b)
 
-  if !(nargin == 1 || nargin == 3)
-    usage ("uniform_inv (x [, a, b])");
+  if (! (nargin == 1 || nargin == 3))
+    usage ("uniform_inv (x, a, b)");
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error ("uniform_inv:  x, a and b must be of common size or scalars");
+    error ("uniform_inv: x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s   = r * c;
   x   = reshape (x, 1, s);
   a   = reshape (a, 1, s);
   b   = reshape (b, 1, s);
   inv = zeros (1, s);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a < b));
-  if any (k)
+  if (any (k))
     inv(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x >= 0) & (x <= 1) & (a < b));
-  if any (k)
+  if (any (k))
     inv(k) = a(k) + x(k) .* (b(k) - a(k));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/uniform_pdf.m b/scripts/statistics/distributions/uniform_pdf.m
--- a/scripts/statistics/distributions/uniform_pdf.m
+++ b/scripts/statistics/distributions/uniform_pdf.m
@@ -9,55 +9,55 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  uniform_pdf (x [, a, b])
-##
-## For each element of x, compute the PDF at x of the uniform
-## distribution on [a, b].
+## -*- texinfo -*-
+## @deftypefn {Function File} {} uniform_pdf (@var{x}, @var{a}, @var{b})
+## For each element of @var{x}, compute the PDF at @var{x} of the uniform
+## distribution on [@var{a}, @var{b}].
 ##
-## Default values are a = 0, b = 1.
+## Default values are @var{a} = 0, @var{b} = 1.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the uniform distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the uniform distribution
 
 function pdf = uniform_pdf (x, a, b)
 
-  if !(nargin == 1 || nargin == 3)
-    usage ("uniform_pdf (x [, a, b])");
+  if (! (nargin == 1 || nargin == 3))
+    usage ("uniform_pdf (x, a, b)");
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   [retval, x, a, b] = common_size (x, a, b);
   if (retval > 0)
-    error (["uniform_pdf:  ", ...
-            "x, a and b must be of common size or scalars"]);
+    error ("uniform_pdf: x, a and b must be of common size or scalars");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   pdf = zeros (1, s);
 
   k = find (isnan (x) | !(a < b));
-  if any (k)
+  if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((x > a) & (x < b));
-  if any (k)
+  if (any (k))
     pdf(k) = 1 ./ (b(k) - a(k));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/uniform_rnd.m b/scripts/statistics/distributions/uniform_rnd.m
--- a/scripts/statistics/distributions/uniform_rnd.m
+++ b/scripts/statistics/distributions/uniform_rnd.m
@@ -9,64 +9,62 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  uniform_rnd (a, b [, r, c])
-##
-## uniform_rnd (a, b) returns a matrix of random samples from the
-## uniform distribution on [a, b].  The size of the matrix is the common
-## size of a and b.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} uniform_rnd (@var{a}, @var{b}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## uniform distribution on [@var{a}, @var{b}].  Both @var{a} and @var{b}
+## must be scalar or of size @var{r} by @var{c}.
 ##
-## uniform_rnd (a, b, r, c) returns an r by c matrix of random samples
-## from the uniform distribution on [a, b].  Both a and b must be scalar
-## or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{a} and @var{b}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the uniform distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the uniform distribution
 
 function rnd = uniform_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("uniform_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("uniform_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("uniform_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("uniform_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
-      error (strcat("uniform_rnd:  ",
-                    "a and b must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("uniform_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
-      error ("uniform_rnd:  a and b must be of common size or scalar");
+      error ("uniform_rnd: a and b must be of common size or scalar");
     endif
   else
-    usage ("uniform_rnd (a, b [, r, c])");
+    usage ("uniform_rnd (a, b, r, c)");
   endif
 
   [r, c] = size (a);
   s = r * c;
   a = reshape (a, 1, s);
   b = reshape (b, 1, s);
   rnd = zeros (1, s);
 
   k = find (!(-Inf < a) | !(a < b) | !(b < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = NaN * ones (1, length (k));
   endif
 
   k = find ((-Inf < a) & (a < b) & (b < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = a(k) + (b(k) - a(k)) .* rand (1, length (k));
   endif
 
   rnd = reshape (rnd, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/weibull_cdf.m b/scripts/statistics/distributions/weibull_cdf.m
--- a/scripts/statistics/distributions/weibull_cdf.m
+++ b/scripts/statistics/distributions/weibull_cdf.m
@@ -9,57 +9,64 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  weibull_cdf (x, alpha, sigma)
+## -*- texinfo -*-
+## @deftypefn {Function File} {} weibull_cdf (@var{x}, @var{alpha}, @var{sigma})
+## Compute the cumulative distribution function (CDF) at @var{x} of the
+## Weibull distribution with shape parameter @var{alpha} and scale
+## parameter @var{sigma}, which is
 ##
-## Compute the cumulative distribution function (CDF) at x of the
-## Weibull distribution with shape parameter alpha and scale parameter
-## sigma, which is 1 - exp(-(x/sigma)^alpha), x >= 0.
+## @example
+## 1 - exp(-(x/sigma)^alpha)
+## @end example
+##
+## @noindent
+## for @var{x} >= 0.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  CDF of the Weibull distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: CDF of the Weibull distribution
 
 function cdf = weibull_cdf (x, shape, scale)
 
   if (nargin != 3)
     usage ("weibull_cdf (x, alpha, sigma)");
   endif
 
   [retval, x, shape, scale] = common_size (x, shape, scale);
   if (retval > 0)
-    error (["weibull_cdf:  ", ...
-            "x, alpha and sigma must be of common size or scalar"]);
+    error ("weibull_cdf: x, alpha and sigma must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   cdf = NaN * ones (1, s);
 
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
 
   k = find ((x <= 0) & ok);
-  if any (k)
+  if (any (k))
     cdf(k) = zeros (1, length (k));
   endif
 
   k = find ((x > 0) & (x < Inf) & ok);
-  if any (k)
+  if (any (k))
     cdf(k) = 1 - exp (- (x(k) ./ scale(k)) .^ shape(k));
   endif
 
   k = find ((x == Inf) & ok);
-  if any (k)
+  if (any (k))
     cdf(k) = ones (1, length (k));
   endif
 
   cdf = reshape (cdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/weibull_inv.m b/scripts/statistics/distributions/weibull_inv.m
--- a/scripts/statistics/distributions/weibull_inv.m
+++ b/scripts/statistics/distributions/weibull_inv.m
@@ -9,55 +9,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  weibull_inv (x, lambda, alpha)
-##
-## Compute the quantile (the inverse of the CDF) at x of the Weibull
-## distribution with shape parameter alpha and scale parameter sigma.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} weibull_inv (@var{x}, @var{lambda}, @var{alpha})
+## Compute the quantile (the inverse of the CDF) at @var{x} of the
+## Weibull distribution with shape parameter @var{alpha} and scale
+## parameter @var{sigma}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Quantile function of the Weibull distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Quantile function of the Weibull distribution
 
 function inv = weibull_inv (x, shape, scale)
 
   if (nargin != 3)
     usage ("weibull_inv (x, alpha, sigma)");
   endif
 
   [retval, x, shape, scale] = common_size (x, shape, scale);
   if (retval > 0)
-    error (["weibull_inv:  ", ...
-            "x, alpha and sigma must be of common size or scalar"]);
+    error ("weibull_inv: x, alpha and sigma must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   inv = NaN * ones (1, s);
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
 
   k = find ((x == 0) & ok);
-  if any (k)
+  if (any (k))
     inv(k) = -Inf * ones (1, length (k));
   endif
 
   k = find ((x > 0) & (x < 1) & ok);
-  if any (k)
+  if (any (k))
     inv(k) = scale(k) .* (- log (1 - x(k))) .^ (1 ./ shape(k));
   endif
 
   k = find ((x == 1) & ok);
-  if any (k)
+  if (any (k))
     inv(k) = Inf * ones (1, length (k));
   endif
 
   inv = reshape (inv, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/weibull_pdf.m b/scripts/statistics/distributions/weibull_pdf.m
--- a/scripts/statistics/distributions/weibull_pdf.m
+++ b/scripts/statistics/distributions/weibull_pdf.m
@@ -9,55 +9,60 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  weibull_pdf (x, alpha, sigma)
+## -*- texinfo -*-
+## @deftypefn {Function File} {} weibull_pdf (@var{x}, @var{alpha}, @var{sigma})
+## Compute the probability density function (PDF) at @var{x} of the
+## Weibull distribution with shape parameter @var{alpha} and scale
+## parameter @var{sigma} which is given by
 ##
-## Compute the probability density function (PDF) at x of the Weibull
-## distribution with shape parameter alpha and scale parameter sigma
-## which is given by
+## @example
 ##    alpha * sigma^(-alpha) * x^(alpha-1) * exp(-(x/sigma)^alpha)
-## for x > 0.
+## @end example
+##
+## @noindent
+## for @var{x} > 0.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  PDF of the Weibull distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: PDF of the Weibull distribution
 
 function pdf = weibull_pdf (x, shape, scale)
 
   if (nargin != 3)
     usage ("weibull_pdf (x, alpha, sigma)");
   endif
 
   [retval, x, shape, scale] = common_size (x, shape, scale);
   if (retval > 0)
-    error (["weibull_pdf:  ", ...
-            "x, alpha and sigma must be of common size or scalar"]);
+    error ("weibull_pdf: x, alpha and sigma must be of common size or scalar");
   endif
 
   [r, c] = size (x);
   s = r * c;
   x = reshape (x, 1, s);
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   pdf = NaN * ones (1, s);
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
 
   k = find ((x > -Inf) & (x <= 0) & ok);
-  if any (k)
+  if (any (k))
     pdf(k) = zeros (1, length (k));
   endif
 
   k = find ((x > 0) & (x < Inf) & ok);
-  if any (k)
+  if (any (k))
     pdf(k) = (shape(k) .* (scale(k) .^ shape(k))
               .* (x(k) .^ (shape(k) - 1))
               .* exp(- (x(k) ./ scale(k)) .^ shape(k)));
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/weibull_rnd.m b/scripts/statistics/distributions/weibull_rnd.m
--- a/scripts/statistics/distributions/weibull_rnd.m
+++ b/scripts/statistics/distributions/weibull_rnd.m
@@ -9,61 +9,59 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  weibull_rnd (alpha, sigma [, r, c])
-##
-## weibull_rnd (alpha, sigma) returns a matrix of random samples from
-## the Weibull distribution with parameters alpha and sigma. The size of
-## the matrix is the common size of alpha and sigma.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} weibull_rnd (@var{alpha}, @var{sigma}, @var{r}, @var{c})
+## Return an @var{r} by @var{c} matrix of random samples from the
+## Weibull distribution with parameters @var{alpha} and @var{sigma}
+## which must be scalar or of size @var{r} by @var{c}.
 ##
-## weibull_rnd (alpha, sigma, r, c) returns an r by c matrix of random
-## samples from the Weibull distribution with parameters alpha and sigma
-## which must be scalar or of size r by c.
+## If @var{r} and @var{c} are omitted, the size of the result matrix is
+## the common size of @var{alpha} and @var{sigma}.
+## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Random deviates from the Weibull distribution
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Random deviates from the Weibull distribution
 
 function rnd = weibull_rnd (shape, scale, r, c)
 
   if (nargin == 4)
-    if ( !(is_scalar (r) && (r > 0) && (r == round (r))) )
-      error ("weibull_rnd:  r must be a positive integer");
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+      error ("weibull_rnd: r must be a positive integer");
     endif
-    if ( !(is_scalar (c) && (c > 0) && (c == round (c))) )
-      error ("weibull_rnd:  c must be a positive integer");
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+      error ("weibull_rnd: c must be a positive integer");
     endif
     [retval, shape, scale] = common_size (shape, scale, zeros (r, c));
     if (retval > 0)
-      error (strcat("weibull_rnd:  ",
-                    "alpha and sigma must be scalar or of size ",
-                    sprintf ("%d by %d", r, c)));
+      error ("weibull_rnd: alpha and sigma must be scalar or of size %d by %d",
+	     r, c);
     endif
   elseif (nargin == 2)
     [retval, shape, scale] = common_size (shape, scale);
     if (retval > 0)
-      error (strcat("weibull_rnd:  ",
-                    "alpha and sigma must be of common size or scalar"));
+      error ("weibull_rnd: alpha and sigma must be of common size or scalar");
     endif
   else
-    usage ("weibull_rnd (alpha, sigma [, r, c])");
+    usage ("weibull_rnd (alpha, sigma, r, c)");
   endif
 
   [r, c] = size (shape);
   s = r * c;
   shape = reshape (shape, 1, s);
   scale = reshape (scale, 1, s);
 
   rnd = NaN * ones (1, s);
   k = find ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
-  if any (k)
+  if (any (k))
     rnd(k) = (scale(k)
               .* (- log (1 - rand (1, length (k)))) .^ (1 ./ shape(k)));
   endif
 
   rnd = reshape (rnd, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/wiener_rnd.m b/scripts/statistics/distributions/wiener_rnd.m
--- a/scripts/statistics/distributions/wiener_rnd.m
+++ b/scripts/statistics/distributions/wiener_rnd.m
@@ -9,38 +9,40 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  wiener_rnd (t [, d [,n]])
-##
-## Returns a simulated realization of the d-dimensional Wiener Process
-## on the interval [0,t].  If d is omitted, d=1 is used. The first
-## column of the return matrix contains time, the remaining columns
-## contain the Wiener process.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} wiener_rnd (@var{t}, @var{d}, @var{n})
+## Return a simulated realization of the @var{d}-dimensional Wiener Process
+## on the interval [0,@var{t}].  If @var{d} is omitted, @var{d} = 1 is
+## used. The first column of the return matrix contains time, the
+## remaining columns contain the Wiener process.
 ##
-## The optional parameter n gives the number of summands used for
-## simulating the process over an interval of length 1.  If n is
-## omitted, n=1000 is used.
+## The optional parameter @var{n} gives the number of summands used for
+## simulating the process over an interval of length 1.  If @var{n} is
+## omitted, @var{n} = 1000 is used.
+## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Simulate a Wiener process
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Simulate a Wiener process
 
 function retval = wiener_rnd (t, d, n)
 
   if (nargin == 1)
     d = 1;
     n = 1000;
   elseif (nargin == 2)
     n = 1000;
   elseif (nargin > 3)
-    usage ("wiener_rnd (t [, d [,n]])");
+    usage ("wiener_rnd (t, d,n)");
   endif
 
   retval = randn (n * t, d);
   retval = cumsum (retval) / sqrt (n);
 
   retval = [((1: n*t)' / n), retval];
+
 endfunction
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -68,19 +68,19 @@
 ## @var{p} holds estimates for the conditional distribution of @var{y}
 ## given @var{x}.
 ## @end deftypefn
 
 ## Original for MATLAB written by Gordon K Smyth <gks@maths.uq.oz.au>,
 ## U of Queensland, Australia, on Nov 19, 1990.  Last revision Aug 3,
 ## 1992.
 
-## Author:  Gordon K Smyth <gks@maths.uq.oz.au>,
-## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Ordinal logistic regression
+## Author: Gordon K Smyth <gks@maths.uq.oz.au>,
+## Adapted-By: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Ordinal logistic regression
 
 ## Uses the auxiliary functions logistic_regression_derivatives and
 ## logistic_regression_likelihood.
 
 function [theta, beta, dev, dl, d2l, p] ...
   = logistic_regression (y, x, print, theta, beta)
 
   ## check input
@@ -156,18 +156,18 @@ function [theta, beta, dev, dl, d2l, p] 
 
   theta = tb (1 : nz, 1);
   beta  = tb ((nz + 1) : (nz + nx), 1);
 
   if (print >= 1)
     printf ("\n");
     printf ("Logistic Regression Results:\n");
     printf ("\n");
-    printf ("Number of Iterations:  %d\n", iter);
-    printf ("Deviance:              %f\n", dev);
+    printf ("Number of Iterations: %d\n", iter);
+    printf ("Deviance:             %f\n", dev);
     printf ("Parameter Estimates:\n");
     printf ("     Theta         S.E.\n");
     se = sqrt (diag (inv (-d2l)));
     for i = 1 : nz
       printf ("   %8.4f     %8.4f\n", tb (i), se (i));
     endfor
     if (nx > 0)
       printf ("      Beta         S.E.\n");
diff --git a/scripts/statistics/models/logistic_regression_derivatives.m b/scripts/statistics/models/logistic_regression_derivatives.m
--- a/scripts/statistics/models/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/logistic_regression_derivatives.m
@@ -15,19 +15,19 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{dl}, @var{d2l}] =} logistic_regression_derivatives (@var{x}, @var{z}, @var{z1}, @var{g}, @var{g1}, @var{p})
 ## Called by logistic_regression.  Calculates derivates of the
 ## log-likelihood for ordinal logistic regression model.
 ## @end deftypefn
 
-## Author:  Gordon K. Smyth <gks@maths.uq.oz.au>
-## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Derivates of log-likelihood in logistic regression
+## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
+## Adapted-By: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Derivates of log-likelihood in logistic regression
 
 function [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p)
 
   ## first derivative
   v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
   dlogp = [(dmult (v, z) - dmult (v1, z1)), (dmult (v - v1, x))];
   dl = sum (dlogp)';
 
diff --git a/scripts/statistics/models/logistic_regression_likelihood.m b/scripts/statistics/models/logistic_regression_likelihood.m
--- a/scripts/statistics/models/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/logistic_regression_likelihood.m
@@ -15,19 +15,19 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{g}, @var{g1}, @var{p}, @var{dev}] =} logistic_regression_likelihood (@var{y}, @var{x}, @var{beta}, @var{z}, @var{z1})
 ## Calculates likelihood for the ordinal logistic regression model.
 ## Called by logistic_regression.
 ## @end deftypefn
 
-## Author:  Gordon K. Smyth <gks@maths.uq.oz.au>
-## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Likelihood in logistic regression
+## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
+## Adapted-By: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Likelihood in logistic regression
 
 function [g, g1, p, dev] = logistic_regression_likelihood (y, x, beta, z, z1)
 
   e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
   g = max (y == max (y), g); g1 = min (y > min(y), g1);
 
   p = g - g1;
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -34,44 +34,43 @@
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{f}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the standard one-way ANOVA table is
 ## printed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  One-way analysis of variance (ANOVA)
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("anova (y [, g])");
+    usage ("anova (y, g)");
   elseif (nargin == 1)
     if (is_vector (y))
-      error ("anova:  for `anova (y)', y must not be a vector");
+      error ("anova: for `anova (y)', y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
     if (! is_vector (y))
-      error ("anova:  for `anova (y, g)', y must be a vector");
+      error ("anova: for `anova (y, g)', y must be a vector");
     endif
     n = length (y);
     if (! is_vector (g) || (length (g) != n))
-      error (["anova:  for `anova (y, g)', g must be a vector", ...
-                " of the same length y"]);
+      error ("anova: g must be a vector of the same length as y");
     endif
     s = sort (g);
     i = find (s (2 : n) > s(1 : (n-1)));
     k = length (i) + 1;
     if (k == 1)
-      error ("anova:  there should be at least 2 groups");
+      error ("anova: there should be at least 2 groups");
     else
       group_label = s ([1, (reshape (i, 1, k-1) + 1)]);
     endif
     for i = 1 : k;
       v = y (find (g == group_label (i)));
       group_count (i) = length (v);
       group_mean (i) = mean (v);
     endfor
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -24,42 +24,42 @@
 ## freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Bartlett test for homogeneity of variances
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Bartlett test for homogeneity of variances
 
 function [pval, chisq, df] = bartlett_test (...)
 
   k = nargin;
   if (k < 2)
     usage ("[pval, chisq, df] = bartlett_test (x1, ...)");
   endif
 
   f = zeros (k, 1);
   v = zeros (k, 1);
   va_start ();
   for i = 1 : k;
     x = va_arg ();
     if (! is_vector (x))
-      error ("bartlett_test:  all arguments must be vectors");
+      error ("bartlett_test: all arguments must be vectors");
     endif
     f(i) = length (x) - 1;
     v(i) = var (x);
   endfor
 
   f_tot = sum (f);
   v_tot = sum (f .* v) / f_tot;
   c     = 1 + (sum (1 ./ f) - 1 / f_tot) / (3 * (k - 1));
   chisq = (f_tot * log (v_tot) - sum (f .* log (v))) / c;
   df    = k;
   pval  = 1 - chisquare_cdf (chisq, df);
 
   if (nargout == 0)
-    printf("  pval:  %g\n", pval);
+    printf("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -26,41 +26,41 @@
 ## degrees of freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Chi-square test for homogeneity
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Chi-square test for homogeneity
 
 function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
 
   if (nargin != 3)
     usage ("[pval, chisq, df] = chisquare_test_homogeneity (x, y, c)");
   endif
 
   if (! (is_vector(x) && is_vector(y) && is_vector(c)))
     error ("chisquare_test_homogeneity: x, y and c must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
   if (any ( (c(2 : df) - c(1 : (df - 1))) <= 0))
-    error ("chisquare_test_homogeneity:  c must be increasing");
+    error ("chisquare_test_homogeneity: c must be increasing");
   endif
 
   c     = [(reshape (c, 1, df)), Inf];
   l_x   = length (x);
   x     = reshape (x, l_x, 1);
   n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
   l_y   = length (y);
   y     = reshape (y, l_y, 1);
   n_y   = sum(y * ones (1, df+1) < ones (l_y, 1) * c);
   chisq = l_x * l_y * sum ((n_x/l_x - n_y/l_y).^2 ./ (n_x + n_y));
   pval  = 1 - chisquare_cdf (chisq, df);
 
   if (nargout == 0)
-    printf("  pval:  %g\n", pval);
+    printf("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -22,30 +22,30 @@
 ## @var{df} degrees of freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at chisq) of the
 ## test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Chi-square test for independence
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Chi-square test for independence
 
 function [pval, chisq, df] = chisquare_test_independence (X)
 
   if (nargin != 1)
     usage ("chisquare_test_independence (X)");
   endif
 
   [r, s] = size (X);
   df = (r - 1) * (s - 1);
   n = sum (sum (X));
   Y = sum (X')' * sum (X) / n;
   X = (X - Y) .^2 ./ Y;
   chisq = sum (sum (X));
   pval  = 1 - chisquare_cdf (chisq, df);
 
   if (nargout == 0)
-    printf("  pval:  %g\n", pval);
+    printf("  pval: %g\n", pval);
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -49,40 +49,40 @@
 ## The alternative hypothesis.
 ## @item method
 ## The method used for testing.
 ## @end table
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Adapted-by:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Test for zero correlation
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Adapted-by: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Test for zero correlation
 
 function t = cor_test (X, Y, ALTERNATIVE, METHOD)
 
   if ((nargin < 2) || (nargin > 4))
-    usage ("cor_test (X, Y [, ALTERNATIVE [, METHOD]])")
+    usage ("cor_test (X, Y, ALTERNATIVE, METHOD)")
   endif
 
   if (!is_vector (X) || !is_vector (Y) || length (X) != length (Y))
-    error ("cor_test:  X and Y must be vectors of the same length")
+    error ("cor_test: X and Y must be vectors of the same length")
   endif
 
   if (nargin < 3)
     ALTERNATIVE = "!=";
   elseif !isstr (ALTERNATIVE)
-    error ("cor_test:  ALTERNATIVE must be a string");
+    error ("cor_test: ALTERNATIVE must be a string");
   endif
 
   if (nargin < 4)
     METHOD = "pearson";
   elseif !isstr (METHOD)
-    error ("cor_test:  METHOD must be a string");
+    error ("cor_test: METHOD must be a string");
   endif
 
   n = length (X);
   m = METHOD (1);
 
   if (m == "p")
     r = cor (X, Y);
     df = n - 2;
@@ -101,28 +101,28 @@ function t = cor_test (X, Y, ALTERNATIVE
   elseif (m == "s")
     rho = spearman (X, Y);
     t.method = "Spearman's rank correlation rho";
     t.params = [];
     t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   else
-    error ("cor_test:  method `%s' not recognized", METHOD)
+    error ("cor_test: method `%s' not recognized", METHOD)
   endif
 
   if (strcmp (ALTERNATIVE, "!=") || strcmp (ALTERNATIVE, "<>"))
     t.pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (ALTERNATIVE, ">"))
     t.pval = 1 - cdf;
   elseif (strcmp (ALTERNATIVE, "<"))
     t.pval = cdf;
   else
-    error ("cor_test:  alternative `%s' not recognized", ALTERNATIVE);
+    error ("cor_test: alternative `%s' not recognized", ALTERNATIVE);
   endif
 
   t.alternative = ALTERNATIVE;
 
   if (nargout == 0)
-    printf ("pval:  %g\n", t.pval);
+    printf ("pval: %g\n", t.pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -25,55 +25,53 @@
 ## The p-value (1 minus the CDF of this distribution at @var{f}) is
 ## returned in @var{pval}.
 ##
 ## If not given explicitly, @var{r} = 0.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Test linear hypotheses in linear regression model
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Test linear hypotheses in linear regression model
 
 function [pval, f, df_num, df_den] = f_test_regression (y, X, R, r)
 
   if (nargin < 3 || nargin > 4)
-    usage (["[pval, f, df_num, df_den] ", ...
-            "= f_test_regression (y, X, R [, r])"]);
+    usage ("[pval, f, df_num, df_den] = f_test_regression (y, X, R, r)");
   endif
 
   [T, k] = size (X);
   if !( is_vector (y) && (length (y) == T) )
-    error (["f_test_regression:  ", ...
-            "y must be a vector of length rows (X)."]);
+    error ("f_test_regression: y must be a vector of length rows (X)");
   endif
   y = reshape (y, T, 1);
 
   [q, c_R ] = size (R);
   if (c_R != k)
-    error (["f_test_regression:  ", ...
+    error (["f_test_regression: ", ...
             "R must have as many columns as X."]);
   endif
 
   if (nargin == 4)
     s_r = size (r);
     if ((min (s_r) != 1) || (max (s_r) != q))
-      error (["f_test_regression:  ", ...
+      error (["f_test_regression: ", ...
               "r must be a vector of length rows (R)."]);
     endif
     r = reshape (r, q, 1);
   else
     r = zeros (q, 1);
   endif
 
   df_num = q;
   df_den = T - k;
 
   [b, v] = ols (y, X);
   diff   = R * b - r;
   f      = diff' * inv (R * inv (X' * X) * R') * diff / ( q * v );
   pval  = 1 - f_cdf (f, df_num, df_den);
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -25,48 +25,46 @@
 ## @math{n-p} degrees of freedom, where @math{n} and @math{p} are the
 ## numbers of samples and variables, respectively.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Test for mean of a multivariate normal
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Test for mean of a multivariate normal
 
 function [pval, Tsq] = hotelling_test (x, m)
 
   if (nargin != 2)
     usage ("hotelling_test (x, m)");
   endif
 
   if (is_vector (x))
     if (! is_scalar (m))
-      error ("hotelling_test:  If x is a vector, m must be a scalar.");
+      error ("hotelling_test: If x is a vector, m must be a scalar.");
     endif
     n = length (x);
     p = 1;
   elseif (is_matrix (x))
     [n, p] = size (x);
     if (n <= p)
-      error ("hotelling_test:  x must have more rows than columns.");
+      error ("hotelling_test: x must have more rows than columns.");
     endif
     if (is_vector (m) && length (m) == p)
       m = reshape (m, 1, p);
     else
-      error (strcat ("hotelling_test:  ",
-                     "If x is a matrix, m must be a vector\n",
-                     "\tof length columns (x)"));
+      error ("hotelling_test: if x is a matrix, m must be a vector of length columns (x)");
     endif
   else
-    error ("hotelling_test:  x must be a matrix or vector");
+    error ("hotelling_test: x must be a matrix or vector");
   endif
 
   d    = mean (x) - m;
   Tsq  = n * d * (cov (x) \ d');
   pval = 1 - f_cdf ((n-p) * Tsq / (p * (n-1)), p, n-p);
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -32,47 +32,46 @@
 ## freedom, where @math{n_x} and @math{n_y} are the sample sizes and
 ## @math{p} is the number of variables.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compare means of two multivariate normals
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compare means of two multivariate normals
 
 function [pval, Tsq] = hotelling_test_2 (x, y)
 
   if (nargin != 2)
     usage ("hotelling_test_2 (x, y)");
   endif
 
   if (is_vector (x))
     n_x = length (x);
     if (! is_vector (y))
-      error ("hotelling_test_2:  If x is a vector, y must be too.");
+      error ("hotelling_test_2: If x is a vector, y must be too.");
     else
       n_y = length (y);
       p   = 1;
     endif
   elseif (is_matrix (x))
     [n_x, p] = size (x);
     [n_y, q] = size (y);
     if (p != q)
-      error (strcat ("hotelling_test_2:  ",
-                     "x and y must have the same number of columns"));
+      error ("hotelling_test_2: x and y must have the same number of columns");
     endif
   else
-    error ("hotelling_test_2:  x and y must be matrices (or vectors)");
+    error ("hotelling_test_2: x and y must be matrices (or vectors)");
   endif
 
   d    = mean (x) - mean (y);
   S    = ((n_x - 1) * cov (x) + (n_y - 1) * cov (y)) / (n_x + n_y - 2);
   Tsq  = (n_x * n_y / (n_x + n_y)) * d * (S \ d');
   pval = 1 - f_cdf ((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),
                     p, n_x + n_y - p - 1);
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -38,29 +38,27 @@
 ## In this case, the test statistic @var{ks} has a one-sided
 ## Kolmogorov-Smirnov distribution.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  One-sample Kolmogorov-Smirnov test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: One-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test (x, dist, ...)
 
   if (nargin < 2)
-    error (sprintf (["usage:\n\t", ...
-        "[pval, ks] = ", ...
-        "kolmogorov_smirnov_test (x, dist, [, params] [, alt])"]));
+    usage ("[pval, ks] = kolmogorov_smirnov_test (x, dist,, params, alt)");
   endif
 
   if (! is_vector (x))
-    error ("kolmogorov_smirnov_test:  x must be a vector.");
+    error ("kolmogorov_smirnov_test: x must be a vector.");
   endif
 
   n = length (x);
   s = sort (x);
   f = sprintf ("%s_cdf", dist);
 
   alt  = "!=";
 
@@ -75,26 +73,25 @@ function [pval, ks] = kolmogorov_smirnov
       else
         args = sprintf ("%s, %g", args, tmp);
       endif
     endfor
     z = reshape (eval (sprintf ("%s(s%s);", f, args)), 1, n);
   endif
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    ks   = sqrt(n) * max(max([abs(z - (0:(n-1))/n); abs(z - (1:n)/n)]));
+    ks   = sqrt (n) * max (max ([abs(z - (0:(n-1))/n); abs(z - (1:n)/n)]));
     pval = 1 - kolmogorov_smirnov_cdf (ks);
   elseif (strcmp (alt, ">"))
-    ks   = sqrt(n) * max (max ([z - (0:(n-1))/n; z - (1:n)/n]));
-    pval = exp(- 2 * ks^2);
+    ks   = sqrt (n) * max (max ([z - (0:(n-1))/n; z - (1:n)/n]));
+    pval = exp (- 2 * ks^2);
   elseif (strcmp (alt, "<"))
-    ks   = - sqrt(n) * min (min ([z - (0:(n-1))/n; z - (1:n)/n]));
-    pval = exp(- 2 * ks^2);
+    ks   = - sqrt (n) * min (min ([z - (0:(n-1))/n; z - (1:n)/n]));
+    pval = exp (- 2 * ks^2);
   else
-    error (sprintf (["kolmogorov_smirnov_test:  ", ...
-        "alternative %s not recognized"], alt));
+    error ("kolmogorov_smirnov_test: alternative %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("pval:  %g\n", pval);
+    printf ("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -31,35 +31,34 @@
 ## In this case, the test statistic @var{ks} has a one-sided
 ## Kolmogorov-Smirnov distribution.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Two-sample Kolmogorov-Smirnov test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Two-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test_2 (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
-    usage (strcat ("[pval, ks] = ",
-                   "kolmogorov_smirnov_test_2 (x, y [, tol])"));
+    usage ("[pval, ks] = kolmogorov_smirnov_test_2 (x, y, tol)");
   endif
 
   if !( is_vector (x) && is_vector (y))
-    error ("kolmogorov_smirnov_test_2:  both x and y must be vectors.");
+    error ("kolmogorov_smirnov_test_2: both x and y must be vectors.");
   endif
 
   if (nargin == 2)
     alt = "!=";
   else
     if (! isstr (alt))
-      error ("kolmogorov_smirnov_test_2:  alt must be a string.");
+      error ("kolmogorov_smirnov_test_2: alt must be a string.");
     endif
   endif
 
   n_x = length (x);
   n_y = length (y);
   n   = n_x * n_y / (n_x + n_y);
   x   = reshape (x, n_x, 1);
   y   = reshape (y, n_y, 1);
@@ -71,17 +70,16 @@ function [pval, ks] = kolmogorov_smirnov
     pval = 1 - kolmogorov_smirnov_cdf (ks);
   elseif (strcmp (alt, ">"))
     ks   = sqrt (n) * max (cumsum (count));
     pval = exp(- 2 * ks^2);
   elseif (strcmp(alt, "<"))
     ks   = - sqrt (n) * min (cumsum (count));
     pval = exp(- 2 * ks^2);
   else
-    error (sprintf (["kolmogorov_smirnov_test_2:  ", ...
-                     "option %s not recognized"], alt));
+    error ("kolmogorov_smirnov_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -27,33 +27,33 @@
 ## freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{k}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Kruskal-Wallis test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Kruskal-Wallis test
 
 function [pval, k, df] = kruskal_wallis_test (...)
 
   m = nargin;
   if (m < 2)
     usage ("[pval, k, df] = kruskal_wallis_test (x1, ...)");
   endif
 
   n = [];
   p = [];
   va_start;
   for i = 1 : m;
     x = va_arg ();
     if (! is_vector (x))
-      error ("kruskal_wallis_test:  all arguments must be vectors");
+      error ("kruskal_wallis_test: all arguments must be vectors");
     endif
     l = length (x);
     n = [n, l];
     p = [p, (reshape (x, 1, l))];
   endfor
 
   r = ranks (p);
 
@@ -65,14 +65,14 @@ function [pval, k, df] = kruskal_wallis_
   endfor
 
   n    = length (p);
   k    = 12 * k / (n * (n + 1)) - 3 * (n + 1);
   df   = m - 1;
   pval = 1 - chisquare_cdf (k, df);
 
   if (nargout == 0)
-    printf ("pval:  %g\n", pval);
+    printf ("pval: %g\n", pval);
   endif
 
 endfunction
 
 
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -29,42 +29,42 @@
 ## The LR test statistic (Wilks' Lambda) and approximate p-values are
 ## computed and displayed.
 ## @end deftypefn
 
 ## Three test statistics (Wilks, Hotelling-Lawley, and Pillai-Bartlett)
 ## and corresponding approximate p-values are calculated and displayed.
 ## (Currently NOT because the f_cdf respectively betai code is too bad.)
 
-## Author:  TF <Thomas.Fuereder@ci.tuwien.ac.at>
-## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  One-way multivariate analysis of variance (MANOVA)
+## Author: TF <Thomas.Fuereder@ci.tuwien.ac.at>
+## Adapted-By: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: One-way multivariate analysis of variance (MANOVA)
 
 function manova (Y, g)
 
   if (nargin != 2)
     usage ("manova (Y, g)");
   endif
 
   if (is_vector (Y))
-    error ("manova:  Y must not be a vector");
+    error ("manova: Y must not be a vector");
   endif
 
   [n, p] = size (Y);
 
   if (!is_vector (g) || (length (g) != n))
-    error ("manova:  g must be a vector of length rows (Y)");
+    error ("manova: g must be a vector of length rows (Y)");
   endif
 
   s = sort (g);
   i = find (s (2:n) > s(1:(n-1)));
   k = length (i) + 1;
 
   if (k == 1)
-    error ("manova:  there should be at least 2 groups");
+    error ("manova: there should be at least 2 groups");
   else
     group_label = s ([1, (reshape (i, 1, k - 1) + 1)]);
   endif
 
   Y = Y - ones (n, 1) * mean (Y);
   SST = Y' * Y;
 
   s = zeros (1, p);
@@ -137,18 +137,18 @@ function manova (Y, g)
     printf ("Pillai-Bartlett  %10.4f           %10.9f \n", PB, PB_pval);
     printf ("\n");
 
   endif
 
   printf ("\n");
   printf ("MANOVA Results:\n");
   printf ("\n");
-  printf ("# of groups:     %d\n", k);
-  printf ("# of samples:    %d\n", n);
-  printf ("# of variables:  %d\n", p);
+  printf ("# of groups:    %d\n", k);
+  printf ("# of samples:   %d\n", n);
+  printf ("# of variables: %d\n", p);
   printf ("\n");
-  printf ("Wilks' Lambda:   %5.4f\n", Lambda);
-  printf ("Approximate p:   %10.9f (chisquare approximation)\n", W_pval_1);
+  printf ("Wilks' Lambda:  %5.4f\n", Lambda);
+  printf ("Approximate p:  %10.9f (chisquare approximation)\n", W_pval_1);
   printf ("                 %10.9f (F approximation)\n", W_pval_2);
   printf ("\n");
 
 endfunction
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -24,44 +24,42 @@
 ## with @var{df} degrees of freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  McNemar's test for symmetry
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: McNemar's test for symmetry
 
 function [pval, chisq, df] = mcnemar_test (x)
 
   if (nargin != 1)
     usage ("mcnemar_test (x)");
   endif
 
   if (! (min (size (x)) > 1) && is_square (x))
-    error (strcat ("mcnemar_test:  ",
-                   "x must be a square matrix of size > 1."));
+    error ("mcnemar_test: x must be a square matrix of size > 1");
   elseif (! (all (all (x >= 0)) && all (all (x == round (x)))))
-    error (strcat ("mcnemar_test:  ",
-                   "all entries of x must be nonnegative integers."));
+    error ("mcnemar_test: all entries of x must be nonnegative integers");
   endif
 
   r = rows (x);
   df = r * (r - 1) / 2;
   if (r == 2)
     num = max (abs (x - x') - 1, 0) .^ 2;
   else
     num = abs (x - x') .^ 2;
   endif
 
   chisq = sum (sum (triu (num ./ (x + x'), 1)));
   pval = 1 - chisquare_cdf (chisq, df);
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
 
 
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -29,23 +29,23 @@
 ## alternative @var{p1} > @var{p2} is used, similarly for @code{"<"}.
 ## The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compare two proportions
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compare two proportions
 
 function [pval, z] = prop_test_2 (x1, n1, x2, n2, alt)
 
   if ((nargin < 4) || (nargin > 5))
-        usage ("[pval, z] = prop_test_2 (x1, n1, x2, n2 [, alt])");
+        usage ("[pval, z] = prop_test_2 (x1, n1, x2, n2, alt)");
   endif
 
   ## Could do sanity checking on x1, n1, x2, n2 here
 
   p1  = x1 / n1;
   p2  = x2 / n2;
   pc  = (x1 + x2) / (n1 + n2);
 
@@ -53,25 +53,25 @@ function [pval, z] = prop_test_2 (x1, n1
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt  = "!=";
   endif
 
   if !isstr (alt)
-    error ("prop_test_2:  alt must be a string");
+    error ("prop_test_2: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
-    error (sprintf ("prop_test_2:  option %s not recognized", alt));
+    error ("prop_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -20,18 +20,18 @@
 ## upward runs in the columns of @var{x}.  Can be used to test whether
 ## @var{x} contains independent data.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Run test for independence
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Run test for independence
 
 function [pval, chisq] = run_test (x)
 
   if (nargin != 1)
     usage ("run_test (x)");
   endif
 
   A = [4529.4,  9044.9, 13568,  18091,  22615,  27892;
@@ -45,12 +45,12 @@ function [pval, chisq] = run_test (x)
 
   n = rows (x);
   r = run_count (x, 6) - n * b * ones (1, columns(x));
 
   chisq = diag (r' * A * r)' / n;
   pval  = chisquare_cdf (chisq, 6);
 
   if (nargout == 0)
-    printf("pval:  %g\n", pval);
+    printf("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -30,50 +30,50 @@
 ## stochastically greater than y") is considered, similarly for @code{"<"}.
 ## The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Sign test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Sign test
 
 function [pval, b, n] = sign_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, b, n] = sign_test (x, y [, alt])");
+    usage ("[pval, b, n] = sign_test (x, y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
-    error ("sign_test:  x and y must be vectors of the same length");
+    error ("sign_test: x and y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
   y   = reshape (y, 1, n);
   n   = sum (x != y);
   b   = sum (x > y);
   cdf = binomial_cdf (b, n, 1/2);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
-    error ("sign_test:  alt must be a string");
+    error ("sign_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
-    error (sprintf ("sign_test:  option %s not recognized", alt));
+    error ("sign_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -29,51 +29,51 @@
 ## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered,
 ## similarly for @var{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Student's one-sample t test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Student's one-sample t test
 
 function [pval, t, df] = t_test (x, m, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, t, df] = t_test (x, m [, alt])");
+    usage ("[pval, t, df] = t_test (x, m, alt)");
   endif
 
   if (! is_vector (x))
-    error ("t_test:  x must be a vector.");
+    error ("t_test: x must be a vector.");
   endif
   if (! is_scalar (m))
-    error ("t_test:  m must be a scalar.");
+    error ("t_test: m must be a scalar.");
   endif
 
   n   = length (x);
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = t_cdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
-    error ("t_test:  alt must be a string");
+    error ("t_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
-    error (sprintf ("t_test:  option %s not recognized", alt));
+    error ("t_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -29,52 +29,52 @@
 ## the one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is
 ## used.  Similarly for @code{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Student's two-sample t test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Student's two-sample t test
 
 function [pval, t, df] = t_test_2 (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-        usage ("[pval, t, df] = t_test_2 (x, y [, alt])");
+        usage ("[pval, t, df] = t_test_2 (x, y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
-    error ("t_test_2:  both x and y must be vectors");
+    error ("t_test_2: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   df   = n_x + n_y - 2;
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v    = sumsq (x - mu_x) + sumsq (y - mu_y);
   t    = (mu_x - mu_y) * sqrt ( (n_x * n_y * df) / (v * (n_x + n_y)) );
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! isstr (alt))
-    error ("t_test_2:  alt must be a string");
+    error ("t_test_2: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
-    error (sprintf ("t_test_2:  option %s not recognized", alt));
+    error ("t_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -30,51 +30,48 @@
 ## one-sided alternative @code{@var{R} * @var{b} > @var{r}} is used.
 ## Similarly for @var{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Test one linear hypothesis in linear regression model
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Test one linear hypothesis in linear regression model
 
 function [pval, t, df] = t_test_regression (y, X, R, r, alt)
 
   if (nargin == 3)
     r   = 0;
     alt = "!=";
   elseif (nargin == 4)
     if (isstr (r))
       alt = r;
       r   = 0;
     else
       alt = "!=";
     endif
   elseif !(nargin == 5)
-    usage (["[pval, t, df] ", ...
-            "= t_test_regression (y, X, R [, r] [, alt]"]);
+    usage ("[pval, t, df] = t_test_regression (y, X, R, r, alt)");
   endif
 
   if (! is_scalar (r))
-    error ("t_test_regression:  r must be a scalar");
+    error ("t_test_regression: r must be a scalar");
   elseif (! isstr (alt))
-    error ("t_test_regression:  alt must be a string");
+    error ("t_test_regression: alt must be a string");
   endif
 
   [T, k] = size (X);
   if !(is_vector (y) && (length (y) == T))
-    error (["t_test_regression:  ", ...
-            "y must be a vector of length rows (X)"]);
+    error ("t_test_regression: y must be a vector of length rows (X)");
   endif
   s      = size (R);
   if !((max (s) == k) && (min (s) == 1))
-    error (["t_test_regression:  ", ...
-            "R must be a vector of length columns (X)"]);
+    error ("t_test_regression: R must be a vector of length columns (X)");
   endif
 
   R      = reshape (R, 1, k);
   y      = reshape (y, T, 1);
   [b, v] = ols (y, X);
   df     = T - k;
   t      = (R * b - r) / sqrt (v * R * inv (X' * X) * R');
   cdf    = t_cdf (t, df);
@@ -85,12 +82,12 @@ function [pval, t, df] = t_test_regressi
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
     error ("t_test_regression: the value `%s' for alt is not possible", alt);
   endif
 
   if (nargout == 0)
-    printf ("pval:  %g\n", pval);
+    printf ("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -32,51 +32,51 @@
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## This implementation is still incomplete---for small sample sizes,
 ## the normal approximation is rather bad ...
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Mann-Whitney U-test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Mann-Whitney U-test
 
 function [pval, z] = u_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, z] = u_test (x, y [, alt])");
+    usage ("[pval, z] = u_test (x, y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
-    error ("u_test:  both x and y must be vectors");
+    error ("u_test: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   r    = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
   z    = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
            / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
 
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
-    error("u_test:  alt must be a string");
+    error("u_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = cdf;
   elseif (strcmp (alt, "<"))
     pval = 1 - cdf;
   else
-    error (sprintf ("u_test:  option %s not recognized", alt));
+    error ("u_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -28,48 +28,48 @@
 ## the one-sided alternative @code{var (@var{x}) > var (@var{y})} is
 ## used, similarly for "<".  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  F test to compare two variances
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: F test to compare two variances
 
 function [pval, f, df_num, df_den] = var_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, f, df_num, df_den] = var_test (x, y [, alt])");
+    usage ("[pval, f, df_num, df_den] = var_test (x, y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
-    error ("var_test:  both x and y must be vectors");
+    error ("var_test: both x and y must be vectors");
   endif
 
   df_num = length (x) - 1;
   df_den = length (y) - 1;
   f      = var (x) / var (y);
   cdf    = f_cdf (f, df_num, df_den);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
-    error ("var_test:  alt must be a string");
+    error ("var_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
-    error (sprintf ("var_test:  option %s not recognized", alt));
+    error ("var_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("pval:  %g\n", pval);
+    printf ("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -29,27 +29,27 @@
 ## one-sided alternative mean(x) > m is considered, similarly for
 ## @code{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Welch two-sample t test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Welch two-sample t test
 
 function [pval, t, df] = welch_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, t, df] = welch_test (x, y [, alt])");
+    usage ("[pval, t, df] = welch_test (x, y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
-    error ("welch_test:  both x and y must be vectors");
+    error ("welch_test: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v_x  = sumsq (x - mu_x) / (n_x * (n_x - 1));
   v_y  = sumsq (x - mu_y) / (n_y * (n_y - 1));
@@ -58,25 +58,25 @@ function [pval, t, df] = welch_test (x, 
   t    = (mu_x - mu_y) / sqrt (v_x + v_y);
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
-    error ("welch_test:  alt must be a string");
+    error ("welch_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
-    error (sprintf ("welch_test:  option %s not recognized", alt));
+    error ("welch_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -28,27 +28,27 @@
 ## alternative PROB (@var{x} > @var{y}) > 1/2 is considered, similarly
 ## for @code{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Wilcoxon signed-rank test
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Wilcoxon signed-rank test
 
 function [pval, z] = wilcoxon_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, z] = wilcoxon_test (x, y [, alt])");
+    usage ("[pval, z] = wilcoxon_test (x, y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
-    error ("wilcoxon_test:  x and y must be vectors of the same length");
+    error ("wilcoxon_test: x and y must be vectors of the same length");
   endif
 
   n = length (x);
   x = reshape (x, 1, n);
   y = reshape (y, 1, n);
   d = x - y;
   d = d (find (d != 0));
   n = length (d);
@@ -62,24 +62,24 @@ function [pval, z] = wilcoxon_test (x, y
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! isstr (alt))
-    error("wilcoxon_test:  alt must be a string");
+    error("wilcoxon_test: alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
-    error (sprintf ("wilcoxon_test:  option %s not recognized", alt));
+    error ("wilcoxon_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval:  %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -29,53 +29,53 @@
 ## similarly for @code{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Test for mean of a normal sample with known variance
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Test for mean of a normal sample with known variance
 
 function [pval, z] = z_test (x, m, v, alt)
 
   if ((nargin < 3) || (nargin > 4))
-    usage ("[pval, z] = z_test (x, m, v [, alt])");
+    usage ("[pval, z] = z_test (x, m, v, alt)");
   endif
 
   if (! is_vector (x))
-    error ("z_test:  x must be a vector.");
+    error ("z_test: x must be a vector.");
   endif
   if (! is_scalar (m))
-    error ("z_test:  m must be a scalar.");
+    error ("z_test: m must be a scalar.");
   endif
   if (! (is_scalar (v) && (v > 0)))
-    error ("z_test:  v must be a positive scalar.");
+    error ("z_test: v must be a positive scalar.");
   endif
 
   n = length (x);
   z = sqrt (n/v) * (sum (x) / n - m);
   cdf = stdnormal_cdf (z);
 
   if (nargin == 3)
     alt = "!=";
   endif
 
   if (! isstr (alt))
-    error ("z_test:  alt must be a string");
+    error ("z_test: alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
-    error (sprintf ("z_test:  option %s not recognized", alt));
+    error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     s = strcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
                 "with known var(x) == %g:\n",
                 "  pval = %g\n");
     printf (s, m, alt, m, v, pval);
   endif
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -29,53 +29,53 @@
 ## similarly for @code{"<"}.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Compare means of two normal samples with known variances
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Compare means of two normal samples with known variances
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
 
   if ((nargin < 4) || (nargin > 5))
-    usage ("[pval, z] = z_test_2 (x, y, v_x, v_y [, alt])");
+    usage ("[pval, z] = z_test_2 (x, y, v_x, v_y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
-    error("z_test_2:  both x and y must be vectors");
+    error("z_test_2: both x and y must be vectors");
   elseif (! (is_scalar (v_x) && (v_x > 0)
              && is_scalar (v_y) && (v_y > 0)))
-    error ("z_test_2:  both v_x and v_y must be positive scalars.");
+    error ("z_test_2: both v_x and v_y must be positive scalars.");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt = "!=";
   endif
 
   if (! isstr (alt))
-    error ("z_test_2:  alt must be a string");
+    error ("z_test_2: alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
-    error (sprintf ("z_test_2:  option %s not recognized", alt));
+    error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     s = strcat ("Two-sample Z-test of mean(x) == mean(y) against ",
                 "mean(x) %s mean(y),\n",
                 "with known var(x) == %g and var(y) == %g:\n",
                 "  pval = %g\n");
     printf (s, alt, v_x, v_y, pval);
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -33,17 +33,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 function v = findstr (s, t, overlap)
 
   if (nargin < 2 || nargin > 3)
-    usage ("findstr (s, t [, overlap])");
+    usage ("findstr (s, t, overlap)");
   endif
 
   if (nargin == 2)
     overlap = 1;
   endif
 
   if (isstr (s) && isstr (t))
 
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 function t = substr (s, offset, len)
 
   if (nargin < 2 || nargin > 3)
-    usage ("substr (s, offset [, len])");
+    usage ("substr (s, offset, len)");
   endif
 
   if (isstr (s))
     nc = columns (s);
     if (abs (offset) > 0 && abs (offset) <= nc)
       if (offset > 0)
         beg = offset;
       else
