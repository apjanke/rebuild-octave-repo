# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1455584772 18000
#      Mon Feb 15 20:06:12 2016 -0500
# Node ID e69eaee287374979d7d9378cdde4f5e47bca5067
# Parent  f780d057a3ec550a8a0f4ff808a058359b36bfaf
make better use of templates for Schur decomposition

* liboctave/numeric/schur.h, liboctave/numeric/schur.cc:
New files generated from SCHUR.h, SCHUR.cc, CmplxSCHUR.h,
CmplxSCHUR.cc, dbleSCHUR.h, dbleSCHUR.cc, fCmplxSCHUR.h,
fCmplxSCHUR.cc, floatSCHUR.h, and floatSCHUR.cc and making them
templates.
* liboctave/numeric/module.mk: Update.
* libinterp/corefcn/schur.cc, sqrtm.cc, CMatrix.cc, dMatrix.cc,
fCMatrix.cc, fMatrix.cc, mx-defs.h, mx-ext.h: Use new template classes
and header file.

diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -21,20 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include <string>
 
-#include "CmplxSCHUR.h"
-#include "dbleSCHUR.h"
-#include "fCmplxSCHUR.h"
-#include "floatSCHUR.h"
+#include "schur.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 template <typename Matrix>
@@ -177,73 +174,73 @@ in control (see @code{are} and @code{dar
   if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (nargout <= 1)
             {
-              FloatSCHUR result (tmp, ord, false);
+              schur<FloatMatrix> result (tmp, ord, false);
               retval = ovl (result.schur_matrix ());
             }
           else
             {
-              FloatSCHUR result (tmp, ord, true);
+              schur<FloatMatrix> result (tmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             result.schur_matrix ());
             }
         }
       else
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           if (nargout <= 1)
             {
-              FloatComplexSCHUR result (ctmp, ord, false);
+              schur<FloatComplexMatrix> result (ctmp, ord, false);
               retval = ovl (mark_upper_triangular (result.schur_matrix ()));
             }
           else
             {
-              FloatComplexSCHUR result (ctmp, ord, true);
+              schur<FloatComplexMatrix> result (ctmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
   else
     {
       if (! force_complex && arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
           if (nargout <= 1)
             {
-              SCHUR result (tmp, ord, false);
+              schur<Matrix> result (tmp, ord, false);
               retval = ovl (result.schur_matrix ());
             }
           else
             {
-              SCHUR result (tmp, ord, true);
+              schur<Matrix> result (tmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             result.schur_matrix ());
             }
         }
       else
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           if (nargout <= 1)
             {
-              ComplexSCHUR result (ctmp, ord, false);
+              schur<ComplexMatrix> result (ctmp, ord, false);
               retval = ovl (mark_upper_triangular (result.schur_matrix ()));
             }
           else
             {
-              ComplexSCHUR result (ctmp, ord, true);
+              schur<ComplexMatrix> result (ctmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
 
   return retval;
 }
@@ -299,26 +296,27 @@ Note also that @var{U} and @var{T} are n
   if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rsf2csf: UR and TR must be real matrices");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       FloatMatrix u = args(0).float_matrix_value ();
       FloatMatrix t = args(1).float_matrix_value ();
 
-      FloatComplexSCHUR cs (FloatSCHUR (t, u));
+      schur<FloatComplexMatrix> cs
+        = rsf2csf<FloatComplexMatrix, FloatMatrix> (t, u);
 
       return ovl (cs.unitary_matrix (), cs.schur_matrix ());
     }
   else
     {
       Matrix u = args(0).matrix_value ();
       Matrix t = args(1).matrix_value ();
 
-      ComplexSCHUR cs (SCHUR (t, u));
+      schur<ComplexMatrix> cs = rsf2csf<ComplexMatrix, Matrix> (t, u);
 
       return ovl (cs.unitary_matrix (), cs.schur_matrix ());
     }
 }
 
 /*
 %!test
 %! A = [1, 1, 1, 2; 1, 2, 1, 1; 1, 1, 3, 1; -2, 1, 1, 1];
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -22,18 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include <float.h>
 
-#include "CmplxSCHUR.h"
-#include "fCmplxSCHUR.h"
+#include "schur.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-norm.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "utils.h"
@@ -172,19 +171,19 @@ do_sqrtm (const octave_value& arg)
           break;
 
         default:
           {
             ComplexMatrix u;
 
             do
               {
-                ComplexSCHUR schur (x, "", true);
-                x = schur.schur_matrix ();
-                u = schur.unitary_matrix ();
+                ComplexSCHUR schur_fact (x, "", true);
+                x = schur_fact.schur_matrix ();
+                u = schur_fact.unitary_matrix ();
               }
             while (0); // schur no longer needed.
 
             sqrtm_utri_inplace (x);
 
             x = u * x; // original x no longer needed.
             ComplexMatrix res = xgemm (x, u, blas_no_trans, blas_conj_trans);
 
@@ -231,20 +230,20 @@ Mathematics, Manchester, England, Januar
       //        sqrtm.  Should this return NaN instead of -1?
       retval(2) = -1.0;
     }
 
   if (arg.is_diag_matrix ())
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
-    retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix, FloatComplexSCHUR>
-                 (arg);
+    retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix,
+                         schur<FloatComplexMatrix> > (arg);
   else if (arg.is_numeric_type ())
-    retval(0) = do_sqrtm<Matrix, ComplexMatrix, ComplexSCHUR> (arg);
+    retval(0) = do_sqrtm<Matrix, ComplexMatrix, schur<ComplexMatrix> > (arg);
 
   if (nargout > 1)
     {
       // This corresponds to generic code
       //
       //   norm (s*s - x, "fro") / norm (x, "fro");
 
       octave_value s = retval(0);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CNDArray.h"
 #include "CRowVector.h"
 #include "dRowVector.h"
 #include "CDiagMatrix.h"
 #include "dDiagMatrix.h"
 #include "CmplxCHOL.h"
-#include "CmplxSCHUR.h"
+#include "schur.h"
 #include "CmplxSVD.h"
 #include "DET.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
@@ -3482,18 +3482,18 @@ Sylvester (const ComplexMatrix& a, const
            const ComplexMatrix& c)
 {
   ComplexMatrix retval;
 
   // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions
 
-  ComplexSCHUR as (a, "U");
-  ComplexSCHUR bs (b, "U");
+  schur<ComplexMatrix> as (a, "U");
+  schur<ComplexMatrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   ComplexMatrix ua = as.unitary_matrix ();
   ComplexMatrix sch_a = as.schur_matrix ();
 
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 #include "CMatrix.h"
 #include "dColVector.h"
 #include "dRowVector.h"
 #include "CColVector.h"
 #include "PermMatrix.h"
 #include "DET.h"
-#include "dbleSCHUR.h"
+#include "schur.h"
 #include "dbleSVD.h"
 #include "dbleCHOL.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
@@ -2948,18 +2948,18 @@ Matrix
 Sylvester (const Matrix& a, const Matrix& b, const Matrix& c)
 {
   Matrix retval;
 
   // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions.
 
-  SCHUR as (a, "U");
-  SCHUR bs (b, "U");
+  schur<Matrix> as (a, "U");
+  schur<Matrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   Matrix ua = as.unitary_matrix ();
   Matrix sch_a = as.schur_matrix ();
 
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "boolMatrix.h"
 #include "chMatrix.h"
 #include "fCMatrix.h"
 #include "fCNDArray.h"
 #include "fCDiagMatrix.h"
 #include "fCColVector.h"
 #include "fCRowVector.h"
 #include "fCmplxCHOL.h"
-#include "fCmplxSCHUR.h"
+#include "schur.h"
 #include "fCmplxSVD.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-fcm-fdm.h"
 #include "mx-fcm-fs.h"
@@ -3496,18 +3496,18 @@ Sylvester (const FloatComplexMatrix& a, 
 {
   FloatComplexMatrix retval;
 
   // FIXME: need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
-  FloatComplexSCHUR as (a, "U");
-  FloatComplexSCHUR bs (b, "U");
+  schur<FloatComplexMatrix> as (a, "U");
+  schur<FloatComplexMatrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   FloatComplexMatrix ua = as.unitary_matrix ();
   FloatComplexMatrix sch_a = as.schur_matrix ();
 
   FloatComplexMatrix ub = bs.unitary_matrix ();
   FloatComplexMatrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "fRowVector.h"
 #include "fCColVector.h"
 #include "PermMatrix.h"
 #include "DET.h"
 #include "byte-swap.h"
 #include "f77-fcn.h"
 #include "fMatrix.h"
 #include "floatCHOL.h"
-#include "floatSCHUR.h"
+#include "schur.h"
 #include "floatSVD.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-fdm-fm.h"
 #include "mx-fm-fdm.h"
@@ -2965,18 +2965,18 @@ FloatMatrix
 Sylvester (const FloatMatrix& a, const FloatMatrix& b, const FloatMatrix& c)
 {
   FloatMatrix retval;
 
   // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions.
 
-  FloatSCHUR as (a, "U");
-  FloatSCHUR bs (b, "U");
+  schur<FloatMatrix> as (a, "U");
+  schur<FloatMatrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   FloatMatrix ua = as.unitary_matrix ();
   FloatMatrix sch_a = as.schur_matrix ();
 
   FloatMatrix ub = bs.unitary_matrix ();
   FloatMatrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/numeric/CmplxSCHUR.cc b/liboctave/numeric/CmplxSCHUR.cc
deleted file mode 100644
--- a/liboctave/numeric/CmplxSCHUR.cc
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "CmplxSCHUR.h"
-#include "f77-fcn.h"
-#include "lo-error.h"
-#include "oct-locbuf.h"
-
-extern "C"
-{
-  F77_RET_T
-  F77_FUNC (zgeesx, ZGEESX) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL,
-                             ComplexSCHUR::select_function,
-                             F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, Complex*,
-                             const octave_idx_type&, octave_idx_type&,
-                             Complex*, Complex*, const octave_idx_type&,
-                             double&, double&, Complex*,
-                             const octave_idx_type&, double*,
-                             octave_idx_type*, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL
-                             F77_CHAR_ARG_LEN_DECL
-                             F77_CHAR_ARG_LEN_DECL);
-
-  F77_RET_T
-  F77_FUNC (zrsf2csf, ZRSF2CSF) (const octave_idx_type&, Complex *,
-                                 Complex *, double *, double *);
-}
-
-static octave_idx_type
-select_ana (const Complex& a)
-{
-  return a.real () < 0.0;
-}
-
-static octave_idx_type
-select_dig (const Complex& a)
-{
-  return (abs (a) < 1.0);
-}
-
-octave_idx_type
-ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord,
-                    bool calc_unitary)
-{
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("ComplexSCHUR requires square matrix");
-
-  if (a_nr == 0)
-    {
-      schur_mat.clear ();
-      unitary_mat.clear ();
-      return 0;
-    }
-
-  // Workspace requirements may need to be fixed if any of the
-  // following change.
-
-  char jobvs;
-  char sense = 'N';
-  char sort = 'N';
-
-  if (calc_unitary)
-    jobvs = 'V';
-  else
-    jobvs = 'N';
-
-  char ord_char = ord.empty () ? 'U' : ord[0];
-
-  if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
-    sort = 'S';
-
-  if (ord_char == 'A' || ord_char == 'a')
-    selector = select_ana;
-  else if (ord_char == 'D' || ord_char == 'd')
-    selector = select_dig;
-  else
-    selector = 0;
-
-  octave_idx_type n = a_nc;
-  octave_idx_type lwork = 8 * n;
-  octave_idx_type info;
-  octave_idx_type sdim;
-  double rconde;
-  double rcondv;
-
-  schur_mat = a;
-  if (calc_unitary)
-    unitary_mat.clear (n, n);
-
-  Complex *s = schur_mat.fortran_vec ();
-  Complex *q = unitary_mat.fortran_vec ();
-
-  Array<double> rwork (dim_vector (n, 1));
-  double *prwork = rwork.fortran_vec ();
-
-  Array<Complex> w (dim_vector (n, 1));
-  Complex *pw = w.fortran_vec ();
-
-  Array<Complex> work (dim_vector (lwork, 1));
-  Complex *pwork = work.fortran_vec ();
-
-  // BWORK is not referenced for non-ordered Schur.
-  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
-  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
-  octave_idx_type *pbwork = bwork.fortran_vec ();
-
-  F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-                             F77_CONST_CHAR_ARG2 (&sort, 1),
-                             selector,
-                             F77_CONST_CHAR_ARG2 (&sense, 1),
-                             n, s, n, sdim, pw, q, n, rconde, rcondv,
-                             pwork, lwork, prwork, pbwork, info
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)));
-
-  return info;
-}
-
-ComplexSCHUR::ComplexSCHUR (const ComplexMatrix& s, const ComplexMatrix& u)
-  : schur_mat (s), unitary_mat (u), selector (0)
-{
-  octave_idx_type n = s.rows ();
-  if (s.columns () != n || u.rows () != n || u.columns () != n)
-    (*current_liboctave_error_handler)
-      ("schur: inconsistent matrix dimensions");
-}
-
-ComplexSCHUR::ComplexSCHUR (const SCHUR& s)
-  : schur_mat (s.schur_matrix ()), unitary_mat (s.unitary_matrix ()),
-    selector (0)
-{
-  octave_idx_type n = schur_mat.rows ();
-  if (n > 0)
-    {
-      OCTAVE_LOCAL_BUFFER (double, c, n-1);
-      OCTAVE_LOCAL_BUFFER (double, sx, n-1);
-
-      F77_XFCN (zrsf2csf, ZRSF2CSF, (n, schur_mat.fortran_vec (),
-                                     unitary_mat.fortran_vec (), c, sx));
-    }
-}
diff --git a/liboctave/numeric/CmplxSCHUR.h b/liboctave/numeric/CmplxSCHUR.h
deleted file mode 100644
--- a/liboctave/numeric/CmplxSCHUR.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_CmplxSCHUR_h)
-#define octave_CmplxSCHUR_h 1
-
-#include "octave-config.h"
-
-#include <iosfwd>
-#include <string>
-
-#include "CMatrix.h"
-#include "dbleSCHUR.h"
-
-class
-OCTAVE_API
-ComplexSCHUR
-{
-public:
-
-  ComplexSCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
-
-  ComplexSCHUR (const ComplexMatrix& a, const std::string& ord,
-                bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
-  {
-    init (a, ord, calc_unitary);
-  }
-
-  ComplexSCHUR (const ComplexMatrix& a, const std::string& ord,
-                octave_idx_type& info,
-                bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
-  {
-    info = init (a, ord, calc_unitary);
-  }
-
-  ComplexSCHUR (const ComplexSCHUR& a)
-    : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-  { }
-
-  ComplexSCHUR (const ComplexMatrix& s, const ComplexMatrix& u);
-
-  ComplexSCHUR (const SCHUR& s);
-
-  ComplexSCHUR& operator = (const ComplexSCHUR& a)
-  {
-    if (this != &a)
-      {
-        schur_mat = a.schur_mat;
-        unitary_mat = a.unitary_mat;
-      }
-    return *this;
-  }
-
-  ~ComplexSCHUR (void) { }
-
-  ComplexMatrix schur_matrix (void) const { return schur_mat; }
-
-  ComplexMatrix unitary_matrix (void) const { return unitary_mat; }
-
-  friend std::ostream& operator << (std::ostream& os, const ComplexSCHUR& a);
-
-  typedef octave_idx_type (*select_function) (const Complex&);
-
-private:
-
-  ComplexMatrix schur_mat;
-  ComplexMatrix unitary_mat;
-
-  select_function selector;
-
-  octave_idx_type init (const ComplexMatrix& a, const std::string& ord,
-                        bool calc_unitary);
-};
-
-#endif
diff --git a/liboctave/numeric/fCmplxSCHUR.cc b/liboctave/numeric/fCmplxSCHUR.cc
deleted file mode 100644
--- a/liboctave/numeric/fCmplxSCHUR.cc
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "fCmplxSCHUR.h"
-#include "f77-fcn.h"
-#include "lo-error.h"
-#include "oct-locbuf.h"
-
-extern "C"
-{
-  F77_RET_T
-  F77_FUNC (cgeesx, CGEESX) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL,
-                             FloatComplexSCHUR::select_function,
-                             F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, octave_idx_type&,
-                             FloatComplex*, FloatComplex*,
-                             const octave_idx_type&, float&, float&,
-                             FloatComplex*, const octave_idx_type&,
-                             float*, octave_idx_type*, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL
-                             F77_CHAR_ARG_LEN_DECL
-                             F77_CHAR_ARG_LEN_DECL);
-  F77_RET_T
-  F77_FUNC (crsf2csf, CRSF2CSF) (const octave_idx_type&, FloatComplex *,
-                                 FloatComplex *, float *, float *);
-}
-
-static octave_idx_type
-select_ana (const FloatComplex& a)
-{
-  return a.real () < 0.0;
-}
-
-static octave_idx_type
-select_dig (const FloatComplex& a)
-{
-  return (abs (a) < 1.0);
-}
-
-octave_idx_type
-FloatComplexSCHUR::init (const FloatComplexMatrix& a, const std::string& ord,
-                         bool calc_unitary)
-{
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (a_nr != a_nc)
-    (*current_liboctave_error_handler)
-      ("FloatComplexSCHUR requires square matrix");
-
-  if (a_nr == 0)
-    {
-      schur_mat.clear ();
-      unitary_mat.clear ();
-      return 0;
-    }
-
-  // Workspace requirements may need to be fixed if any of the
-  // following change.
-
-  char jobvs;
-  char sense = 'N';
-  char sort = 'N';
-
-  if (calc_unitary)
-    jobvs = 'V';
-  else
-    jobvs = 'N';
-
-  char ord_char = ord.empty () ? 'U' : ord[0];
-
-  if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
-    sort = 'S';
-
-  if (ord_char == 'A' || ord_char == 'a')
-    selector = select_ana;
-  else if (ord_char == 'D' || ord_char == 'd')
-    selector = select_dig;
-  else
-    selector = 0;
-
-  octave_idx_type n = a_nc;
-  octave_idx_type lwork = 8 * n;
-  octave_idx_type info;
-  octave_idx_type sdim;
-  float rconde;
-  float rcondv;
-
-  schur_mat = a;
-  if (calc_unitary)
-    unitary_mat.clear (n, n);
-
-  FloatComplex *s = schur_mat.fortran_vec ();
-  FloatComplex *q = unitary_mat.fortran_vec ();
-
-  Array<float> rwork (dim_vector (n, 1));
-  float *prwork = rwork.fortran_vec ();
-
-  Array<FloatComplex> w (dim_vector (n, 1));
-  FloatComplex *pw = w.fortran_vec ();
-
-  Array<FloatComplex> work (dim_vector (lwork, 1));
-  FloatComplex *pwork = work.fortran_vec ();
-
-  // BWORK is not referenced for non-ordered Schur.
-  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
-  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
-  octave_idx_type *pbwork = bwork.fortran_vec ();
-
-  F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-                             F77_CONST_CHAR_ARG2 (&sort, 1),
-                             selector,
-                             F77_CONST_CHAR_ARG2 (&sense, 1),
-                             n, s, n, sdim, pw, q, n, rconde, rcondv,
-                             pwork, lwork, prwork, pbwork, info
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)));
-
-  return info;
-}
-
-FloatComplexSCHUR::FloatComplexSCHUR (const FloatComplexMatrix& s,
-                                      const FloatComplexMatrix& u)
-  : schur_mat (s), unitary_mat (u), selector (0)
-{
-  octave_idx_type n = s.rows ();
-  if (s.columns () != n || u.rows () != n || u.columns () != n)
-    (*current_liboctave_error_handler)
-      ("schur: inconsistent matrix dimensions");
-}
-
-FloatComplexSCHUR::FloatComplexSCHUR (const FloatSCHUR& s)
-  : schur_mat (s.schur_matrix ()), unitary_mat (s.unitary_matrix ()),
-    selector (0)
-{
-  octave_idx_type n = schur_mat.rows ();
-  if (n > 0)
-    {
-      OCTAVE_LOCAL_BUFFER (float, c, n-1);
-      OCTAVE_LOCAL_BUFFER (float, sx, n-1);
-
-      F77_XFCN (crsf2csf, CRSF2CSF, (n, schur_mat.fortran_vec (),
-                                     unitary_mat.fortran_vec (), c, sx));
-    }
-}
diff --git a/liboctave/numeric/fCmplxSCHUR.h b/liboctave/numeric/fCmplxSCHUR.h
deleted file mode 100644
--- a/liboctave/numeric/fCmplxSCHUR.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_fCmplxSCHUR_h)
-#define octave_fCmplxSCHUR_h 1
-
-#include "octave-config.h"
-
-#include <iosfwd>
-#include <string>
-
-#include "fCMatrix.h"
-#include "floatSCHUR.h"
-
-class
-OCTAVE_API
-FloatComplexSCHUR
-{
-public:
-
-  FloatComplexSCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
-
-  FloatComplexSCHUR (const FloatComplexMatrix& a, const std::string& ord,
-                     bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
-  {
-    init (a, ord, calc_unitary);
-  }
-
-  FloatComplexSCHUR (const FloatComplexMatrix& a, const std::string& ord,
-                     octave_idx_type& info, bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
-  {
-    info = init (a, ord, calc_unitary);
-  }
-
-  FloatComplexSCHUR (const FloatComplexSCHUR& a)
-    : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-  { }
-
-  FloatComplexSCHUR (const FloatComplexMatrix& s, const FloatComplexMatrix& u);
-
-  FloatComplexSCHUR (const FloatSCHUR& s);
-
-  FloatComplexSCHUR& operator = (const FloatComplexSCHUR& a)
-  {
-    if (this != &a)
-      {
-        schur_mat = a.schur_mat;
-        unitary_mat = a.unitary_mat;
-      }
-    return *this;
-  }
-
-  ~FloatComplexSCHUR (void) { }
-
-  FloatComplexMatrix schur_matrix (void) const { return schur_mat; }
-
-  FloatComplexMatrix unitary_matrix (void) const { return unitary_mat; }
-
-  friend std::ostream& operator << (std::ostream& os,
-                                    const FloatComplexSCHUR& a);
-
-  typedef octave_idx_type (*select_function) (const FloatComplex&);
-
-private:
-
-  FloatComplexMatrix schur_mat;
-  FloatComplexMatrix unitary_mat;
-
-  select_function selector;
-
-  octave_idx_type init (const FloatComplexMatrix& a, const std::string& ord,
-                        bool calc_unitary);
-};
-
-#endif
diff --git a/liboctave/numeric/floatSCHUR.cc b/liboctave/numeric/floatSCHUR.cc
deleted file mode 100644
--- a/liboctave/numeric/floatSCHUR.cc
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <iostream>
-
-#include "floatSCHUR.h"
-#include "f77-fcn.h"
-#include "lo-error.h"
-
-extern "C"
-{
-  F77_RET_T
-  F77_FUNC (sgeesx, SGEESX) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL,
-                             FloatSCHUR::select_function,
-                             F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, float*,
-                             const octave_idx_type&, octave_idx_type&,
-                             float*, float*, float*, const octave_idx_type&,
-                             float&, float&, float*, const octave_idx_type&,
-                             octave_idx_type*, const octave_idx_type&,
-                             octave_idx_type*, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL
-                             F77_CHAR_ARG_LEN_DECL
-                             F77_CHAR_ARG_LEN_DECL);
-}
-
-static octave_idx_type
-select_ana (const float& a, const float&)
-{
-  return (a < 0.0);
-}
-
-static octave_idx_type
-select_dig (const float& a, const float& b)
-{
-  return (hypot (a, b) < 1.0);
-}
-
-octave_idx_type
-FloatSCHUR::init (const FloatMatrix& a, const std::string& ord,
-                  bool calc_unitary)
-{
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("FloatSCHUR requires square matrix");
-
-  if (a_nr == 0)
-    {
-      schur_mat.clear ();
-      unitary_mat.clear ();
-      return 0;
-    }
-
-  // Workspace requirements may need to be fixed if any of the
-  // following change.
-
-  char jobvs;
-  char sense = 'N';
-  char sort = 'N';
-
-  if (calc_unitary)
-    jobvs = 'V';
-  else
-    jobvs = 'N';
-
-  char ord_char = ord.empty () ? 'U' : ord[0];
-
-  if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
-    sort = 'S';
-
-  if (ord_char == 'A' || ord_char == 'a')
-    selector = select_ana;
-  else if (ord_char == 'D' || ord_char == 'd')
-    selector = select_dig;
-  else
-    selector = 0;
-
-  octave_idx_type n = a_nc;
-  octave_idx_type lwork = 8 * n;
-  octave_idx_type liwork = 1;
-  octave_idx_type info;
-  octave_idx_type sdim;
-  float rconde;
-  float rcondv;
-
-  schur_mat = a;
-
-  if (calc_unitary)
-    unitary_mat.clear (n, n);
-
-  float *s = schur_mat.fortran_vec ();
-  float *q = unitary_mat.fortran_vec ();
-
-  Array<float> wr (dim_vector (n, 1));
-  float *pwr = wr.fortran_vec ();
-
-  Array<float> wi (dim_vector (n, 1));
-  float *pwi = wi.fortran_vec ();
-
-  Array<float> work (dim_vector (lwork, 1));
-  float *pwork = work.fortran_vec ();
-
-  // BWORK is not referenced for the non-ordered Schur routine.
-  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
-  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
-  octave_idx_type *pbwork = bwork.fortran_vec ();
-
-  Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-  octave_idx_type *piwork = iwork.fortran_vec ();
-
-  F77_XFCN (sgeesx, SGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-                             F77_CONST_CHAR_ARG2 (&sort, 1),
-                             selector,
-                             F77_CONST_CHAR_ARG2 (&sense, 1),
-                             n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
-                             pwork, lwork, piwork, liwork, pbwork, info
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)));
-
-  return info;
-}
-
-FloatSCHUR::FloatSCHUR (const FloatMatrix& s, const FloatMatrix& u)
-  : schur_mat (s), unitary_mat (u), selector (0)
-{
-  octave_idx_type n = s.rows ();
-  if (s.columns () != n || u.rows () != n || u.columns () != n)
-    (*current_liboctave_error_handler)
-      ("schur: inconsistent matrix dimensions");
-}
-
-std::ostream&
-operator << (std::ostream& os, const FloatSCHUR& a)
-{
-  os << a.schur_matrix () << "\n";
-  os << a.unitary_matrix () << "\n";
-
-  return os;
-}
diff --git a/liboctave/numeric/floatSCHUR.h b/liboctave/numeric/floatSCHUR.h
deleted file mode 100644
--- a/liboctave/numeric/floatSCHUR.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_floatSCHUR_h)
-#define octave_floatSCHUR_h 1
-
-#include "octave-config.h"
-
-#include <iosfwd>
-#include <string>
-
-#include "fMatrix.h"
-
-class
-OCTAVE_API
-FloatSCHUR
-{
-public:
-
-  FloatSCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
-
-  FloatSCHUR (const FloatMatrix& a, const std::string& ord,
-              bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
-  {
-    init (a, ord, calc_unitary);
-  }
-
-  FloatSCHUR (const FloatMatrix& a, const std::string& ord, int& info,
-              bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
-  {
-    info = init (a, ord, calc_unitary);
-  }
-
-  FloatSCHUR (const FloatSCHUR& a)
-    : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-  { }
-
-  FloatSCHUR (const FloatMatrix& s, const FloatMatrix& u);
-
-  FloatSCHUR& operator = (const FloatSCHUR& a)
-  {
-    if (this != &a)
-      {
-        schur_mat = a.schur_mat;
-        unitary_mat = a.unitary_mat;
-      }
-    return *this;
-  }
-
-  ~FloatSCHUR (void) { }
-
-  FloatMatrix schur_matrix (void) const { return schur_mat; }
-
-  FloatMatrix unitary_matrix (void) const { return unitary_mat; }
-
-  friend std::ostream& operator << (std::ostream& os, const FloatSCHUR& a);
-
-  typedef octave_idx_type (*select_function) (const float&, const float&);
-
-private:
-
-  FloatMatrix schur_mat;
-  FloatMatrix unitary_mat;
-
-  select_function selector;
-
-  octave_idx_type init (const FloatMatrix& a, const std::string& ord,
-                        bool calc_unitary);
-};
-
-#endif
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -10,17 +10,16 @@ LIBOCTAVE_OPT_IN = $(LIBOCTAVE_OPT_INC:.
 NUMERIC_INC = \
   liboctave/numeric/CmplxAEPBAL.h \
   liboctave/numeric/CmplxCHOL.h \
   liboctave/numeric/CmplxGEPBAL.h \
   liboctave/numeric/CmplxHESS.h \
   liboctave/numeric/CmplxLU.h \
   liboctave/numeric/CmplxQR.h \
   liboctave/numeric/CmplxQRP.h \
-  liboctave/numeric/CmplxSCHUR.h \
   liboctave/numeric/CmplxSVD.h \
   liboctave/numeric/CollocWt.h \
   liboctave/numeric/DAE.h \
   liboctave/numeric/DAEFunc.h \
   liboctave/numeric/DAERT.h \
   liboctave/numeric/DAERTFunc.h \
   liboctave/numeric/DASPK.h \
   liboctave/numeric/DASRT.h \
@@ -43,48 +42,46 @@ NUMERIC_INC = \
   liboctave/numeric/bsxfun.h \
   liboctave/numeric/dbleAEPBAL.h \
   liboctave/numeric/dbleCHOL.h \
   liboctave/numeric/dbleGEPBAL.h \
   liboctave/numeric/dbleHESS.h \
   liboctave/numeric/dbleLU.h \
   liboctave/numeric/dbleQR.h \
   liboctave/numeric/dbleQRP.h \
-  liboctave/numeric/dbleSCHUR.h \
   liboctave/numeric/dbleSVD.h \
   liboctave/numeric/eigs-base.h \
   liboctave/numeric/fCmplxAEPBAL.h \
   liboctave/numeric/fCmplxCHOL.h \
   liboctave/numeric/fCmplxGEPBAL.h \
   liboctave/numeric/fCmplxHESS.h \
   liboctave/numeric/fCmplxLU.h \
   liboctave/numeric/fCmplxQR.h \
   liboctave/numeric/fCmplxQRP.h \
-  liboctave/numeric/fCmplxSCHUR.h \
   liboctave/numeric/fCmplxSVD.h \
   liboctave/numeric/fEIG.h \
   liboctave/numeric/floatAEPBAL.h \
   liboctave/numeric/floatCHOL.h \
   liboctave/numeric/floatGEPBAL.h \
   liboctave/numeric/floatHESS.h \
   liboctave/numeric/floatLU.h \
   liboctave/numeric/floatQR.h \
   liboctave/numeric/floatQRP.h \
-  liboctave/numeric/floatSCHUR.h \
   liboctave/numeric/floatSVD.h \
   liboctave/numeric/lo-mappers.h \
   liboctave/numeric/lo-specfun.h \
   liboctave/numeric/oct-convn.h \
   liboctave/numeric/oct-fftw.h \
   liboctave/numeric/oct-norm.h \
   liboctave/numeric/oct-rand.h \
   liboctave/numeric/oct-spparms.h \
   liboctave/numeric/randgamma.h \
   liboctave/numeric/randmtzig.h \
   liboctave/numeric/randpoisson.h \
+  liboctave/numeric/schur.h \
   liboctave/numeric/sparse-chol.h \
   liboctave/numeric/sparse-dmsolve.h \
   liboctave/numeric/sparse-lu.h \
   liboctave/numeric/sparse-qr.h
 
 NUMERIC_C_SRC = \
   liboctave/numeric/randgamma.c \
   liboctave/numeric/randmtzig.c \
@@ -93,62 +90,59 @@ NUMERIC_C_SRC = \
 NUMERIC_SRC = \
   liboctave/numeric/CmplxAEPBAL.cc \
   liboctave/numeric/CmplxCHOL.cc \
   liboctave/numeric/CmplxGEPBAL.cc \
   liboctave/numeric/CmplxHESS.cc \
   liboctave/numeric/CmplxLU.cc \
   liboctave/numeric/CmplxQR.cc \
   liboctave/numeric/CmplxQRP.cc \
-  liboctave/numeric/CmplxSCHUR.cc \
   liboctave/numeric/CmplxSVD.cc \
   liboctave/numeric/CollocWt.cc \
   liboctave/numeric/DASPK.cc \
   liboctave/numeric/DASRT.cc \
   liboctave/numeric/DASSL.cc \
   liboctave/numeric/EIG.cc \
   liboctave/numeric/LSODE.cc \
   liboctave/numeric/ODES.cc \
   liboctave/numeric/Quad.cc \
   liboctave/numeric/dbleAEPBAL.cc \
   liboctave/numeric/dbleCHOL.cc \
   liboctave/numeric/dbleGEPBAL.cc \
   liboctave/numeric/dbleHESS.cc \
   liboctave/numeric/dbleLU.cc \
   liboctave/numeric/dbleQR.cc \
   liboctave/numeric/dbleQRP.cc \
-  liboctave/numeric/dbleSCHUR.cc \
   liboctave/numeric/dbleSVD.cc \
   liboctave/numeric/eigs-base.cc \
   liboctave/numeric/fCmplxAEPBAL.cc \
   liboctave/numeric/fCmplxCHOL.cc \
   liboctave/numeric/fCmplxGEPBAL.cc \
   liboctave/numeric/fCmplxHESS.cc \
   liboctave/numeric/fCmplxLU.cc \
   liboctave/numeric/fCmplxQR.cc \
   liboctave/numeric/fCmplxQRP.cc \
-  liboctave/numeric/fCmplxSCHUR.cc \
   liboctave/numeric/fCmplxSVD.cc \
   liboctave/numeric/fEIG.cc \
   liboctave/numeric/floatAEPBAL.cc \
   liboctave/numeric/floatCHOL.cc \
   liboctave/numeric/floatGEPBAL.cc \
   liboctave/numeric/floatHESS.cc \
   liboctave/numeric/floatLU.cc \
   liboctave/numeric/floatQR.cc \
   liboctave/numeric/floatQRP.cc \
-  liboctave/numeric/floatSCHUR.cc \
   liboctave/numeric/floatSVD.cc \
   liboctave/numeric/lo-mappers.cc \
   liboctave/numeric/lo-specfun.cc \
   liboctave/numeric/oct-convn.cc \
   liboctave/numeric/oct-fftw.cc \
   liboctave/numeric/oct-norm.cc \
   liboctave/numeric/oct-rand.cc \
   liboctave/numeric/oct-spparms.cc \
+  liboctave/numeric/schur.cc \
   liboctave/numeric/sparse-chol.cc \
   liboctave/numeric/sparse-dmsolve.cc \
   liboctave/numeric/sparse-lu.cc \
   liboctave/numeric/sparse-qr.cc \
   $(NUMERIC_C_SRC)
 
 LIBOCTAVE_TEMPLATE_SRC += \
   liboctave/numeric/base-lu.cc \
diff --git a/liboctave/numeric/dbleSCHUR.cc b/liboctave/numeric/schur.cc
rename from liboctave/numeric/dbleSCHUR.cc
rename to liboctave/numeric/schur.cc
--- a/liboctave/numeric/dbleSCHUR.cc
+++ b/liboctave/numeric/schur.cc
@@ -21,58 +21,140 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include <iostream>
 
-#include "dbleSCHUR.h"
+#include "CMatrix.h"
+#include "dMatrix.h"
 #include "f77-fcn.h"
+#include "fCMatrix.h"
+#include "fMatrix.h"
 #include "lo-error.h"
+#include "schur.h"
+
+typedef octave_idx_type (*double_selector) (const double&, const double&);
+typedef octave_idx_type (*float_selector) (const float&, const float&);
+typedef octave_idx_type (*complex_selector) (const Complex&);
+typedef octave_idx_type (*float_complex_selector) (const FloatComplex&);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeesx, DGEESX) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
-                             SCHUR::select_function,
+                             double_selector,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&,
                              double*, double*, double*, const octave_idx_type&,
                              double&, double&, double*, const octave_idx_type&,
                              octave_idx_type*, const octave_idx_type&,
                              octave_idx_type*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (sgeesx, SGEESX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             float_selector,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, float*,
+                             const octave_idx_type&, octave_idx_type&,
+                             float*, float*, float*, const octave_idx_type&,
+                             float&, float&, float*, const octave_idx_type&,
+                             octave_idx_type*, const octave_idx_type&,
+                             octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zgeesx, ZGEESX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             complex_selector,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type&,
+                             Complex*, Complex*, const octave_idx_type&,
+                             double&, double&, Complex*,
+                             const octave_idx_type&, double*,
+                             octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zrsf2csf, ZRSF2CSF) (const octave_idx_type&, Complex *,
+                                 Complex *, double *, double *);
+  F77_RET_T
+  F77_FUNC (cgeesx, CGEESX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             float_complex_selector,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, octave_idx_type&,
+                             FloatComplex*, FloatComplex*,
+                             const octave_idx_type&, float&, float&,
+                             FloatComplex*, const octave_idx_type&,
+                             float*, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (crsf2csf, CRSF2CSF) (const octave_idx_type&, FloatComplex *,
+                                 FloatComplex *, float *, float *);
 }
 
+// For real types.
+
+template <typename T>
 static octave_idx_type
-select_ana (const double& a, const double&)
+select_ana (const T& a, const T&)
 {
   return (a < 0.0);
 }
 
+template <typename T>
 static octave_idx_type
-select_dig (const double& a, const double& b)
+select_dig (const T& a, const T& b)
 {
   return (hypot (a, b) < 1.0);
 }
 
+// For complex types.
+
+template <typename T>
+static octave_idx_type
+select_ana (const T& a)
+{
+  return a.real () < 0.0;
+}
+
+template <typename T>
+static octave_idx_type
+select_dig (const T& a)
+{
+  return (abs (a) < 1.0);
+}
+
+template <>
 octave_idx_type
-SCHUR::init (const Matrix& a, const std::string& ord, bool calc_unitary)
+schur<Matrix>::init (const Matrix& a, const std::string& ord, bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("SCHUR requires square matrix");
+    (*current_liboctave_error_handler) ("schur: requires square matrix");
 
   if (a_nr == 0)
     {
       schur_mat.clear ();
       unitary_mat.clear ();
       return 0;
     }
 
@@ -88,20 +170,21 @@ SCHUR::init (const Matrix& a, const std:
   else
     jobvs = 'N';
 
   char ord_char = ord.empty () ? 'U' : ord[0];
 
   if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
     sort = 'S';
 
+  double_selector selector = 0;
   if (ord_char == 'A' || ord_char == 'a')
-    selector = select_ana;
+    selector = select_ana<double>;
   else if (ord_char == 'D' || ord_char == 'd')
-    selector = select_dig;
+    selector = select_dig<double>;
   else
     selector = 0;
 
   octave_idx_type n = a_nc;
   octave_idx_type lwork = 8 * n;
   octave_idx_type liwork = 1;
   octave_idx_type info;
   octave_idx_type sdim;
@@ -141,26 +224,350 @@ SCHUR::init (const Matrix& a, const std:
                              pwork, lwork, piwork, liwork, pbwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
+template <>
+octave_idx_type
+schur<FloatMatrix>::init (const FloatMatrix& a, const std::string& ord,
+                          bool calc_unitary)
+{
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+
+  if (a_nr != a_nc)
+    (*current_liboctave_error_handler) ("SCHUR requires square matrix");
+
+  if (a_nr == 0)
+    {
+      schur_mat.clear ();
+      unitary_mat.clear ();
+      return 0;
+    }
+
+  // Workspace requirements may need to be fixed if any of the
+  // following change.
+
+  char jobvs;
+  char sense = 'N';
+  char sort = 'N';
+
+  if (calc_unitary)
+    jobvs = 'V';
+  else
+    jobvs = 'N';
+
+  char ord_char = ord.empty () ? 'U' : ord[0];
+
+  if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
+    sort = 'S';
+
+  float_selector selector = 0;
+  if (ord_char == 'A' || ord_char == 'a')
+    selector = select_ana<float>;
+  else if (ord_char == 'D' || ord_char == 'd')
+    selector = select_dig<float>;
+  else
+    selector = 0;
+
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 8 * n;
+  octave_idx_type liwork = 1;
+  octave_idx_type info;
+  octave_idx_type sdim;
+  float rconde;
+  float rcondv;
+
+  schur_mat = a;
+
+  if (calc_unitary)
+    unitary_mat.clear (n, n);
+
+  float *s = schur_mat.fortran_vec ();
+  float *q = unitary_mat.fortran_vec ();
+
+  Array<float> wr (dim_vector (n, 1));
+  float *pwr = wr.fortran_vec ();
+
+  Array<float> wi (dim_vector (n, 1));
+  float *pwi = wi.fortran_vec ();
+
+  Array<float> work (dim_vector (lwork, 1));
+  float *pwork = work.fortran_vec ();
+
+  // BWORK is not referenced for the non-ordered Schur routine.
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
+  octave_idx_type *pbwork = bwork.fortran_vec ();
+
+  Array<octave_idx_type> iwork (dim_vector (liwork, 1));
+  octave_idx_type *piwork = iwork.fortran_vec ();
+
+  F77_XFCN (sgeesx, SGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
+                             pwork, lwork, piwork, liwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  return info;
+}
+
+template <>
+octave_idx_type
+schur<ComplexMatrix>::init (const ComplexMatrix& a, const std::string& ord,
+                            bool calc_unitary)
+{
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+
+  if (a_nr != a_nc)
+    (*current_liboctave_error_handler) ("SCHUR requires square matrix");
+
+  if (a_nr == 0)
+    {
+      schur_mat.clear ();
+      unitary_mat.clear ();
+      return 0;
+    }
+
+  // Workspace requirements may need to be fixed if any of the
+  // following change.
+
+  char jobvs;
+  char sense = 'N';
+  char sort = 'N';
+
+  if (calc_unitary)
+    jobvs = 'V';
+  else
+    jobvs = 'N';
+
+  char ord_char = ord.empty () ? 'U' : ord[0];
+
+  if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
+    sort = 'S';
+
+  complex_selector selector = 0;
+  if (ord_char == 'A' || ord_char == 'a')
+    selector = select_ana<Complex>;
+  else if (ord_char == 'D' || ord_char == 'd')
+    selector = select_dig<Complex>;
+  else
+    selector = 0;
+
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 8 * n;
+  octave_idx_type info;
+  octave_idx_type sdim;
+  double rconde;
+  double rcondv;
+
+  schur_mat = a;
+  if (calc_unitary)
+    unitary_mat.clear (n, n);
+
+  Complex *s = schur_mat.fortran_vec ();
+  Complex *q = unitary_mat.fortran_vec ();
+
+  Array<double> rwork (dim_vector (n, 1));
+  double *prwork = rwork.fortran_vec ();
+
+  Array<Complex> w (dim_vector (n, 1));
+  Complex *pw = w.fortran_vec ();
+
+  Array<Complex> work (dim_vector (lwork, 1));
+  Complex *pwork = work.fortran_vec ();
+
+  // BWORK is not referenced for non-ordered Schur.
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
+  octave_idx_type *pbwork = bwork.fortran_vec ();
+
+  F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pw, q, n, rconde, rcondv,
+                             pwork, lwork, prwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  return info;
+}
+
+template <>
+schur<ComplexMatrix>
+rsf2csf<ComplexMatrix, Matrix> (const Matrix& s_arg, const Matrix& u_arg)
+{
+  ComplexMatrix s (s_arg);
+  ComplexMatrix u (u_arg);
+
+  octave_idx_type n = s.rows ();
+
+  if (s.columns () != n || u.rows () != n || u.columns () != n)
+    (*current_liboctave_error_handler)
+      ("rsf2csf: inconsistent matrix dimensions");
+
+  if (n > 0)
+    {
+      OCTAVE_LOCAL_BUFFER (double, c, n-1);
+      OCTAVE_LOCAL_BUFFER (double, sx, n-1);
+
+      F77_XFCN (zrsf2csf, ZRSF2CSF, (n, s.fortran_vec (),
+                                     u.fortran_vec (), c, sx));
+    }
+
+  return schur<ComplexMatrix> (s, u);
+}
+
+template <>
+octave_idx_type
+schur<FloatComplexMatrix>::init (const FloatComplexMatrix& a,
+                                 const std::string& ord, bool calc_unitary)
+{
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+
+  if (a_nr != a_nc)
+    (*current_liboctave_error_handler) ("SCHUR requires square matrix");
+
+  if (a_nr == 0)
+    {
+      schur_mat.clear ();
+      unitary_mat.clear ();
+      return 0;
+    }
+
+  // Workspace requirements may need to be fixed if any of the
+  // following change.
+
+  char jobvs;
+  char sense = 'N';
+  char sort = 'N';
+
+  if (calc_unitary)
+    jobvs = 'V';
+  else
+    jobvs = 'N';
+
+  char ord_char = ord.empty () ? 'U' : ord[0];
+
+  if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
+    sort = 'S';
+
+  float_complex_selector selector = 0;
+  if (ord_char == 'A' || ord_char == 'a')
+    selector = select_ana<FloatComplex>;
+  else if (ord_char == 'D' || ord_char == 'd')
+    selector = select_dig<FloatComplex>;
+  else
+    selector = 0;
+
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 8 * n;
+  octave_idx_type info;
+  octave_idx_type sdim;
+  float rconde;
+  float rcondv;
+
+  schur_mat = a;
+  if (calc_unitary)
+    unitary_mat.clear (n, n);
+
+  FloatComplex *s = schur_mat.fortran_vec ();
+  FloatComplex *q = unitary_mat.fortran_vec ();
+
+  Array<float> rwork (dim_vector (n, 1));
+  float *prwork = rwork.fortran_vec ();
+
+  Array<FloatComplex> w (dim_vector (n, 1));
+  FloatComplex *pw = w.fortran_vec ();
+
+  Array<FloatComplex> work (dim_vector (lwork, 1));
+  FloatComplex *pwork = work.fortran_vec ();
+
+  // BWORK is not referenced for non-ordered Schur.
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
+  octave_idx_type *pbwork = bwork.fortran_vec ();
+
+  F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pw, q, n, rconde, rcondv,
+                             pwork, lwork, prwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  return info;
+}
+
+template <>
+schur<FloatComplexMatrix>
+rsf2csf<FloatComplexMatrix, FloatMatrix> (const FloatMatrix& s_arg, const FloatMatrix& u_arg)
+{
+  FloatComplexMatrix s (s_arg);
+  FloatComplexMatrix u (u_arg);
+
+  octave_idx_type n = s.rows ();
+
+  if (s.columns () != n || u.rows () != n || u.columns () != n)
+    (*current_liboctave_error_handler)
+      ("rsf2csf: inconsistent matrix dimensions");
+
+  if (n > 0)
+    {
+      OCTAVE_LOCAL_BUFFER (float, c, n-1);
+      OCTAVE_LOCAL_BUFFER (float, sx, n-1);
+
+      F77_XFCN (crsf2csf, CRSF2CSF, (n, s.fortran_vec (),
+                                     u.fortran_vec (), c, sx));
+    }
+
+  return schur<FloatComplexMatrix> (s, u);
+}
+
+template <typename T>
 std::ostream&
-operator << (std::ostream& os, const SCHUR& a)
+operator << (std::ostream& os, const schur<T>& a)
 {
   os << a.schur_matrix () << "\n";
   os << a.unitary_matrix () << "\n";
 
   return os;
 }
 
-SCHUR::SCHUR (const Matrix& s, const Matrix& u)
-  : schur_mat (s), unitary_mat (u), selector (0)
-{
-  octave_idx_type n = s.rows ();
-  if (s.columns () != n || u.rows () != n || u.columns () != n)
-    (*current_liboctave_error_handler)
-      ("schur: inconsistent matrix dimensions");
-}
+// Instantiations we need.
+
+template class schur<ComplexMatrix>;
+
+template class schur<FloatComplexMatrix>;
+
+template class schur<FloatMatrix>;
+
+template class schur<Matrix>;
 
+template <>
+std::ostream&
+operator << (std::ostream& os, const schur<Matrix>& a);
+
+template <>
+std::ostream&
+operator << (std::ostream& os, const schur<ComplexMatrix>& a);
+
+template <>
+std::ostream&
+operator << (std::ostream& os, const schur<FloatMatrix>& a);
+
+template <>
+std::ostream&
+operator << (std::ostream& os, const schur<FloatComplexMatrix>& a);
diff --git a/liboctave/numeric/dbleSCHUR.h b/liboctave/numeric/schur.h
rename from liboctave/numeric/dbleSCHUR.h
rename to liboctave/numeric/schur.h
--- a/liboctave/numeric/dbleSCHUR.h
+++ b/liboctave/numeric/schur.h
@@ -15,77 +15,91 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#if ! defined (octave_dbleSCHUR_h)
-#define octave_dbleSCHUR_h 1
+#if ! defined (octave_schur_h)
+#define octave_schur_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <string>
 
 #include "dMatrix.h"
+#include "CMatrix.h"
+#include "fMatrix.h"
+#include "fCMatrix.h"
 
+template <typename T> class schur;
+
+template <typename T>
 class
-OCTAVE_API
-SCHUR
+schur
 {
 public:
 
-  SCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
+  schur (void) : schur_mat (), unitary_mat () { }
 
-  SCHUR (const Matrix& a, const std::string& ord, bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
+  schur (const T& a, const std::string& ord, bool calc_unitary = true)
+    : schur_mat (), unitary_mat ()
   {
     init (a, ord, calc_unitary);
   }
 
-  SCHUR (const Matrix& a, const std::string& ord, int& info,
+  schur (const T& a, const std::string& ord, octave_idx_type& info,
          bool calc_unitary = true)
-    : schur_mat (), unitary_mat (), selector (0)
+    : schur_mat (), unitary_mat ()
   {
     info = init (a, ord, calc_unitary);
   }
 
-  SCHUR (const SCHUR& a)
-    : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
+  // This one should really be protected or private but we need it in
+  // rsf2csf and I don't see how to make that function a friend of
+  // this class.
+  schur (const T& s, const T& u) : schur_mat (s), unitary_mat (u) { }
+
+  schur (const schur& a)
+
+    : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat)
   { }
 
-  SCHUR (const Matrix& s, const Matrix& u);
-
-  SCHUR& operator = (const SCHUR& a)
+  schur& operator = (const schur& a)
   {
     if (this != &a)
       {
         schur_mat = a.schur_mat;
         unitary_mat = a.unitary_mat;
       }
+
     return *this;
   }
 
-  ~SCHUR (void) { }
+  ~schur (void) { }
 
-  Matrix schur_matrix (void) const { return schur_mat; }
+  T schur_matrix (void) const { return schur_mat; }
 
-  Matrix unitary_matrix (void) const { return unitary_mat; }
+  T unitary_matrix (void) const { return unitary_mat; }
 
-  friend std::ostream& operator << (std::ostream& os, const SCHUR& a);
-
-  typedef octave_idx_type (*select_function) (const double&, const double&);
+protected:
 
 private:
 
-  Matrix schur_mat;
-  Matrix unitary_mat;
+  T schur_mat;
+  T unitary_mat;
 
-  select_function selector;
-
-  octave_idx_type init (const Matrix& a, const std::string& ord,
-                        bool calc_unitary);
+  octave_idx_type
+  init (const T& a, const std::string& ord, bool calc_unitary);
 };
 
+template <typename RT, typename AT>
+extern schur<RT>
+rsf2csf (const AT& s, const AT& u);
+
+template <typename T>
+extern std::ostream&
+operator << (std::ostream& os, const schur<T>& a);
+
 #endif
diff --git a/liboctave/operators/mx-defs.h b/liboctave/operators/mx-defs.h
--- a/liboctave/operators/mx-defs.h
+++ b/liboctave/operators/mx-defs.h
@@ -75,20 +75,17 @@ class FloatComplexCHOL;
 
 class EIG;
 
 class HESS;
 class ComplexHESS;
 class FloatHESS;
 class FloatComplexHESS;
 
-class SCHUR;
-class ComplexSCHUR;
-class FloatSCHUR;
-class FloatComplexSCHUR;
+template <typename T> class schur;
 
 class SVD;
 class ComplexSVD;
 class FloatSVD;
 class FloatComplexSVD;
 
 class LU;
 class ComplexLU;
diff --git a/liboctave/operators/mx-ext.h b/liboctave/operators/mx-ext.h
--- a/liboctave/operators/mx-ext.h
+++ b/liboctave/operators/mx-ext.h
@@ -43,20 +43,17 @@ along with Octave; see the file COPYING.
 
 // Result of a Hessenberg Decomposition
 
 #include "dbleHESS.h"
 #include "CmplxHESS.h"
 
 // Result of a Schur Decomposition
 
-#include "dbleSCHUR.h"
-#include "CmplxSCHUR.h"
-#include "floatSCHUR.h"
-#include "fCmplxSCHUR.h"
+#include "schur.h"
 
 // Result of a Singular Value Decomposition.
 
 #include "dbleSVD.h"
 #include "CmplxSVD.h"
 #include "floatSVD.h"
 #include "fCmplxSVD.h"
 
