# HG changeset patch
# User jwe
# Date 1057885277 0
#      Fri Jul 11 01:01:17 2003 +0000
# Node ID abbf63293766e2394ca052dc424c81628fd58a2a
# Parent  c474333062d902739b026e303ab60442f270df7b
[project @ 2003-07-11 01:01:16 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,16 +1,18 @@
 2003-07-09  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* emacs/octave-mod.el (octave-variables): Include
 	DEFAULT_EXEC_PATH, DEFAULT_LOAD_PATH, crash_dumps_octave_core,
 	sighup_dumps_octave_core, sigterm_dumps_octave_core,
-	warn_imag_to_real, warn_num_to_str, and warn_str_to_num in the list.
-	Delete ok_to_lose_imaginary_part, implicit_num_to_str_ok, and
-	implicit_str_to_num_ok from the list.
+	warn_imag_to_real, warn_num_to_str, warn_str_to_num, and
+	warn_fortran_indexing in the list.
+	Delete ok_to_lose_imaginary_part, implicit_num_to_str_ok,
+	implicit_str_to_num_ok, prefer_column_vectors,
+	prefer_zero_one_indexing, and do_fortran_indexing from the list.
 
 2003-07-08  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makeconf.in (do-subst-default-vals): Substitute OCTAVE_API_VERSION.
 	* octave-config.in: Handle new variable OCTAVE_API_VERSION.
 
 	* octMakefile.in (DIRS_TO_MAKE): Delete undefined vars
 	$(localfcnfilepathdirs) and $(localoctfilepathdirs) from the list.
diff --git a/doc/faq/Octave-FAQ.texi b/doc/faq/Octave-FAQ.texi
--- a/doc/faq/Octave-FAQ.texi
+++ b/doc/faq/Octave-FAQ.texi
@@ -711,32 +711,31 @@ you can customize Octave's behavior to b
 to use Octave's new features.  To make Octave more @sc{Matlab}-compatible,
 put the following statements in your @file{~/.octaverc} file, or use the
 command line option @samp{--traditional}, which implies all of these
 settings.  Note that this list may not be complete, because some new
 variables may have been introduced since this document was last updated.
 
 @example
 @group
-  PS1 = ">> "
-  PS2 = ""
-  beep_on_error = 1.0
-  default_eval_print_flag = 0.0
-  default_save_format = "mat-binary"
-  define_all_return_values = 1.0
-  do_fortran_indexing = 1.0
-  empty_list_elements_ok = 1.0
-  fixed_point_format = 1.0
-  page_screen_output = 0.0
-  prefer_column_vectors = 0.0
-  prefer_zero_one_indexing = 1.0
-  print_empty_dimensions = 0.0
-  treat_neg_dim_as_zero = 1.0
-  warn_function_name_clash = 0.0
-  whitespace_in_literal_matrix = "traditional"
+  PS1                           = ">> "
+  PS2                           = ""
+  beep_on_error                 = true
+  crash_dumps_octave_core       = false
+  default_eval_print_flag       = false
+  default_global_variable_value = []
+  default_save_format           = "mat-binary"
+  define_all_return_values      = true
+  fixed_point_format            = true
+  initialize_global_variables   = true
+  page_screen_output            = false
+  print_empty_dimensions        = false
+  treat_neg_dim_as_zero         = true
+  warn_function_name_clash      = false
+  whitespace_in_literal_matrix  = "traditional"
 @end group
 @end example
 
 Some other known differences are:
 
 @itemize @bullet
 @item
 The Octave plotting functions are mostly compatible with the ones from
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -150,30 +150,33 @@ Don't print the usual greeting and versi
 @item --traditional
 @itemx --braindead
 @cindex @code{--traditional}
 @cindex @code{--braindead}
 Set initial values for user-preference variables to the following
 values for compatibility with @sc{Matlab}.
 
 @example
-PS1                           = ">> "
-PS2                           = ""
-beep_on_error                 = 1
-default_save_format           = "mat-binary"
-define_all_return_values      = 1
-do_fortran_indexing           = 1
-crash_dumps_octave_core       = 0
-empty_list_elements_ok        = 1
-page_screen_output            = 0
-prefer_column_vectors         = 0
-print_empty_dimensions        = 0
-treat_neg_dim_as_zero         = 1
-warn_function_name_clash      = 0
-whitespace_in_literal_matrix  = "traditional"
+@group
+  PS1                           = ">> "
+  PS2                           = ""
+  beep_on_error                 = true
+  crash_dumps_octave_core       = false
+  default_eval_print_flag       = false
+  default_global_variable_value = []
+  default_save_format           = "mat-binary"
+  define_all_return_values      = true
+  fixed_point_format            = true
+  initialize_global_variables   = true
+  page_screen_output            = false
+  print_empty_dimensions        = false
+  treat_neg_dim_as_zero         = true
+  warn_function_name_clash      = false
+  whitespace_in_literal_matrix  = "traditional"
+@end group
 @end example
 
 @item --verbose
 @itemx -V
 @cindex @code{--verbose}
 @cindex @code{-V}
 Turn on verbose output.
 
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -322,17 +322,17 @@ comments in @code{font-lock-comment-face
 @item
 the Octave reserved words (such as all block keywords) and the text
 functions (such as @samp{cd} or @samp{who}) which are also reserved
 using @code{font-lock-keyword-face}
 @item
 the builtin operators (@samp{&&}, @samp{<>}, @dots{}) using
 @code{font-lock-reference-face}
 @item
-the builtin variables (such as @samp{prefer_column_vectors}, @samp{NaN}
+the builtin variables (such as @samp{warn_fortran_indexing}, @samp{NaN}
 or @samp{LOADPATH}) in @code{font-lock-variable-name-face}
 @item
 and the function names in function declarations in
 @code{font-lock-function-name-face}.
 @end itemize
 
 There is also rudimentary support for Imenu (currently, function names
 can be indexed).
diff --git a/doc/interpreter/eos.txi b/doc/interpreter/eos.txi
--- a/doc/interpreter/eos.txi
+++ b/doc/interpreter/eos.txi
@@ -322,17 +322,17 @@ comments in @code{font-lock-comment-face
 @item
 the Octave reserved words (such as all block keywords) and the text
 functions (such as @samp{cd} or @samp{who}) which are also reserved
 using @code{font-lock-keyword-face}
 @item
 the builtin operators (@samp{&&}, @samp{<>}, @dots{}) using
 @code{font-lock-reference-face}
 @item
-the builtin variables (such as @samp{prefer_column_vectors}, @samp{NaN}
+the builtin variables (such as @samp{warn_fortran_indexing}, @samp{NaN}
 or @samp{LOADPATH}) in @code{font-lock-variable-name-face}
 @item
 and the function names in function declarations in
 @code{font-lock-function-name-face}.
 @end itemize
 
 There is also rudimentary support for Imenu (currently, function names
 can be indexed).
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -35,22 +35,22 @@ combinations of these with various opera
 @opindex )
 
 An @dfn{index expression} allows you to reference or extract selected
 elements of a matrix or vector.
 
 Indices may be scalars, vectors, ranges, or the special operator
 @samp{:}, which may be used to select entire rows or columns.
 
-Vectors are indexed using a single expression.  Matrices require two
-indices unless the value of the built-in variable
-@code{do_fortran_indexing} is nonzero, in which case matrices may
-also be indexed by a single expression.
+Vectors are indexed using a single expression.  Matrices may be
+indexed using one or two indices (a warning is issued if a single
+index is used unless the value of the built-in variable
+@code{warn_fortran_indexing} is zero).
 
-@DOCSTRING(do_fortran_indexing)
+@DOCSTRING(warn_fortran_indexing)
 
 Given the matrix
 
 @example
 a = [1, 2; 3, 4]
 @end example
 
 @noindent
@@ -162,18 +162,16 @@ a ([1, 1], [1, 1, 1])
 @noindent
 create a 2 by 3 matrix with all elements equal to 13.
 
 This is an obscure notation and should be avoided.  It is better to
 use the function @code{ones} to generate a matrix of the appropriate
 size whose elements are all one, and then to scale it to produce the
 desired result.  @xref{Special Utility Matrices}.
 
-@DOCSTRING(prefer_column_vectors)
-
 @DOCSTRING(resize_on_range_error)
 
 Note that it is quite inefficient to create a vector using a loop like
 the one shown in the example above.  In this particular case, it would
 have been much more efficient to use the expression
 
 @example
 a = sqrt (1:10);
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -662,32 +662,32 @@ end_unwind_protect
 
 @noindent
 Where @var{body} and @var{cleanup} are both optional and may contain any
 Octave expressions or commands.  The statements in @var{cleanup} are 
 guaranteed to be executed regardless of how control exits @var{body}.
 
 This is useful to protect temporary changes to global variables from
 possible errors.  For example, the following code will always restore
-the original value of the built-in variable @code{do_fortran_indexing}
+the original value of the built-in variable @code{warn_fortran_indexing}
 even if an error occurs while performing the indexing operation.
 
 @example
 @group
-save_do_fortran_indexing = do_fortran_indexing;
+save_warn_fortran_indexing = warn_fortran_indexing;
 unwind_protect
-  do_fortran_indexing = 1;
+  warn_fortran_indexing = 1;
   elt = a (idx)
 unwind_protect_cleanup
-  do_fortran_indexing = save_do_fortran_indexing;
+  warn_fortran_indexing = save_warn_fortran_indexing;
 end_unwind_protect
 @end group
 @end example
 
-Without @code{unwind_protect}, the value of @var{do_fortran_indexing}
+Without @code{unwind_protect}, the value of @var{warn_fortran_indexing}
 would not be restored if an error occurs while performing the indexing
 operation because evaluation would stop at the point of the error and
 the statement to restore the value would not be executed.
 
 @node The try Statement
 @section The @code{try} Statement
 @cindex @code{try} statement
 @cindex @code{catch}
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -251,21 +251,16 @@ Default value: 1.
 
 Default value: @code{[]}.
 
 @item default_save_format
 @xref{Simple File I/O}.
 
 Default value: @code{"ascii"}.
 
-@item do_fortran_indexing
-@xref{Index Expressions}.
-
-Default value: 0.
-
 @item crash_dumps_octave_core
 @xref{Simple File I/O}.
 
 Default value: 1.
 
 @item define_all_return_values
 @xref{Multiple Return Values}.
 
@@ -316,21 +311,16 @@ Default value: 10.
 
 Default value: 5.
 
 @item page_screen_output
 @xref{Input and Output}.
 
 Default value: 1.
 
-@item prefer_column_vectors
-@xref{Index Expressions}.
-
-Default value: 1.
-
 @item print_answer_id_name
 @xref{Terminal Output}.
 
 Default value: 1.
 
 @item print_empty_dimensions
 @xref{Empty Matrices}.
 
@@ -401,16 +391,21 @@ Default value: 1.
 
 Default value: 1.
 
 @item warn_divide_by_zero
 @xref{Arithmetic Ops}.
 
 Default value: 1.
 
+@item warn_fortran_indexing
+@xref{Index Expressions}.
+
+Default value: 0.
+
 @item warn_function_name_clash
 @xref{Function Files}.
 
 Default value: 1.
 
 @item warn_imag_to_real
 @xref{Special Utility Matrices}.
 
diff --git a/emacs/octave-mod.el b/emacs/octave-mod.el
--- a/emacs/octave-mod.el
+++ b/emacs/octave-mod.el
@@ -137,34 +137,33 @@ All Octave abbrevs start with a grave ac
     "__O_RDWR__" "__O_TRUNC__" "__O_WRONLY__" "__PWD__" "__SEEK_CUR__"
     "__SEEK_END__" "__SEEK_SET__" "__argv__" "__e__" "__eps__"
     "__error_text__" "__i__" "__inf__" "__j__" "__nan__" "__pi__"
     "__program_invocation_name__" "__program_name__" "__realmax__"
     "__realmin__" "__stderr__" "__stdin__" "__stdout__" "ans" "argv"
     "automatic_replot" "beep_on_error" "completion_append_char"
     "crash_dumps_octave_core"
     "default_return_value" "default_save_format"
-    "define_all_return_values" "do_fortran_indexing" "e"
+    "define_all_return_values" "e"
     "echo_executing_commands" "empty_list_elements_ok" "eps"
     "error_text" "gnuplot_binary" "history_file"
     "history_size" "ignore_function_time_stamp"
     "inf" "nan" "nargin"
     "output_max_field_width" "output_precision"
     "page_output_immediately" "page_screen_output" "pi"
-    "prefer_column_vectors" "prefer_zero_one_indexing"
     "print_answer_id_name" "print_empty_dimensions"
     "program_invocation_name" "program_name" "propagate_empty_matrices"
     "realmax" "realmin" "resize_on_range_error"
     "return_last_computed_value" "save_precision" "saving_history"
     "sighup_dumps_octave_core" "sigterm_dumps_octave_core"
     "silent_functions" "split_long_rows" "stderr" "stdin" "stdout"
     "string_fill_char" "struct_levels_to_print"
     "suppress_verbose_help_message" "treat_neg_dim_as_zero"
     "warn_assign_as_truth_value" "warn_comma_in_global_decl"
-    "warn_divide_by_zero" "warn_function_name_clash"
+    "warn_divide_by_zero" "warn_fortran_indexing" "warn_function_name_clash"
     "warn_imag_to_real" "warn_missing_semicolon"
      "warn_num_to_str" "warn_str_to_num" "whitespace_in_literal_matrix")
   "Builtin variables in Octave.")
 
 (defvar octave-function-header-regexp
   (concat "^\\s-*\\<\\(function\\)\\>"
 	  "\\([^=;\n]*=[ \t]*\\|[ \t]*\\)\\(\\w+\\)\\>")
   "Regexp to match an Octave function header.
diff --git a/liboctave/Array-flags.cc b/liboctave/Array-flags.cc
--- a/liboctave/Array-flags.cc
+++ b/liboctave/Array-flags.cc
@@ -25,18 +25,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "Array.h"
 
 // These have to be defined somewhere, but only once.
 
 #if defined (HEAVYWEIGHT_INDEXING)
 
-int liboctave_dfi_flag = 0;
-int liboctave_pcv_flag = 0;
+int liboctave_wfi_flag = 0;
 int liboctave_rre_flag = 0;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/Array-flags.h b/liboctave/Array-flags.h
--- a/liboctave/Array-flags.h
+++ b/liboctave/Array-flags.h
@@ -16,18 +16,17 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if defined (OCTAVE_SOURCE)
-extern int liboctave_dfi_flag;
-extern int liboctave_pcv_flag;
+extern int liboctave_wfi_flag;
 extern int liboctave_rre_flag;
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array2-idx.h b/liboctave/Array2-idx.h
--- a/liboctave/Array2-idx.h
+++ b/liboctave/Array2-idx.h
@@ -114,21 +114,24 @@ Array2<T>::index (idx_vector& idx_arg, i
 		retval = Array2<T> (tmp, 1, len);
 	      else
 		retval = Array2<T> (tmp, len, 1);
 	    }
 	  else
 	    retval = Array2<T> (tmp, idx_orig_rows, idx_orig_columns);
 	}
     }
-  else if (liboctave_dfi_flag
-	   || (idx_arg.one_zero_only ()
-	       && idx_orig_rows == nr
-	       && idx_orig_columns == nc))
+  else
     {
+      if (liboctave_wfi_flag
+	  && ! (idx_arg.one_zero_only ()
+		&& idx_orig_rows == nr
+		&& idx_orig_columns == nc))
+	(*current_liboctave_warning_handler) ("single index used for matrix");
+
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
       idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
 	{
 	  int result_nr = idx_orig_rows;
@@ -156,19 +159,16 @@ Array2<T>::index (idx_vector& idx_arg, i
 		      int fc = (ii - fr) / nr;
 		      retval.elem (i, j) = elem (fr, fc);
 		    }
 		}
 	    }
 	}
       // idx_vector::freeze() printed an error message for us.
     }
-  else
-    (*current_liboctave_error_handler)
-      ("single index only valid for row or column vector");
 
   return retval;
 }
 
 template <class T>
 Array2<T>
 Array2<T>::index (idx_vector& idx_i, idx_vector& idx_j, int resize_ok,
 		  const T& resize_fill_value) const
@@ -621,85 +621,50 @@ assign (Array2<LT>& lhs, const Array2<RT
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		{
 		  if (n != 0 && (lhs_nr != 0 || lhs_nc != 0))
 		    lhs.maybe_delete_elements (idx_i);
 		}
-	      else if (! liboctave_dfi_flag && lhs_is_empty
-		       && idx_i.is_colon ()
-		       && ! (rhs_nr == 1 || rhs_nc == 1))
-		{
-		  (*current_liboctave_error_handler)
-		    ("A(:) = X: X must be a vector");
-		}
 	      else
 		{
+		  if (liboctave_wfi_flag)
+		    {
+		      if (lhs_is_empty
+			  && idx_i.is_colon ()
+			  && ! (rhs_nr == 1 || rhs_nc == 1))
+			{
+			  (*current_liboctave_warning_handler)
+			    ("A(:) = X: X is not a vector or scalar");
+			}
+		      else
+			{
+			  int idx_nr = idx_i.orig_rows ();
+			  int idx_nc = idx_i.orig_columns ();
+
+			  if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
+			    (*current_liboctave_warning_handler)
+			      ("A(I) = X: X does not have same shape as I");
+			}
+		    }
+
 		  if (assign ((Array<LT>&) lhs, (Array<RT>&) rhs))
 		    {
 		      int len = lhs.length ();
 
 		      if (len > 0)
 			{
-			  int idx_nr = idx_i.orig_rows ();
-			  int idx_nc = idx_i.orig_columns ();
-
-			  // lhs_is_empty now means that lhs was
-			  // *originally* empty, and lhs_len is the
-			  // *original* length of the lhs.
+			  // The following behavior is much simplified
+			  // over previous versions of Octave.  It
+			  // seems to be compatible with Matlab.
 
-			  if (liboctave_dfi_flag
-			      || (idx_nr == 1 && idx_nc == 1)
-			      || (rhs_nr == 1 && rhs_nc == 1 && lhs_len == 1))
-			    {
-			      if (liboctave_pcv_flag)
-				{
-				  lhs.d1 = lhs.length ();
-				  lhs.d2 = 1;
-				}
-			      else
-				{
-				  lhs.d1 = 1;
-				  lhs.d2 = lhs.length ();
-				}
-			    }
-			  else if (lhs_is_empty && idx_i.is_colon ())
-			    {
-			      lhs.d1 = rhs.d1;
-			      lhs.d2 = rhs.d2;
-			    }
-			  else if (lhs_is_empty && idx_i.one_zero_only ())
-			    {
-			      lhs.d1 = idx_nr;
-			      lhs.d2 = idx_nc;
-			    }
-			  else if (rhs_nr == 1
-				   && (idx_nr == 1 || lhs_len == 1))
-			    {
-			      lhs.d1 = 1;
-			      lhs.d2 = lhs.length ();
-			    }
-			  else if (rhs_nc == 1
-				   && (idx_nc == 1 || lhs_len == 1))
-			    {
-			      lhs.d1 = lhs.length ();
-			      lhs.d2 = 1;
-			    }
-			  else if (idx_nr == 0 && idx_nc == 0)
-			    {
-			      if (! ((rhs.d1 == 1 && rhs.d2 == 1)
-				     || (rhs.d1 == 0 && rhs.d2 == 0)))
-				(*current_liboctave_error_handler)
-			  ("A([]) = X: X must be an empty matrix or scalar");
-			    }
-			  else
-			    (*current_liboctave_error_handler)
-      ("A(I) = X: X must be a scalar or a matrix with the same size as I");
+			  lhs.d1 = 1;
+			  lhs.d2 = lhs.length ();
 			}
 		      else
 			{
 			  lhs.d1 = 0;
 			  lhs.d2 = 0;
 			}
 		    }
 		  else
@@ -739,22 +704,26 @@ assign (Array2<LT>& lhs, const Array2<RT
 		  if (assign ((Array<LT>&) lhs, (Array<RT>&) rhs))
 		    lhs.d1 = lhs.length ();
 		  else
 		    retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
-      else if (liboctave_dfi_flag
-	       || idx_i.is_colon ()
-	       || (idx_i.one_zero_only ()
-		   && idx_i.orig_rows () == lhs_nr
-		   && idx_i.orig_columns () == lhs_nc))
+      else
 	{
+	  if (liboctave_wfi_flag
+	      && ! (idx_i.is_colon ()
+		    || (idx_i.one_zero_only ()
+			&& idx_i.orig_rows () == lhs_nr
+			&& idx_i.orig_columns () == lhs_nc)))
+	    (*current_liboctave_warning_handler)
+	      ("single index used for matrix");
+
 	  int len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
 
 	  if (idx_i)
 	    {
 	      if (len == 0)
 		{
 		  if (! ((rhs_nr == 1 && rhs_nc == 1)
 			 || (rhs_nr == 0 && rhs_nc == 0)))
@@ -792,23 +761,16 @@ assign (Array2<LT>& lhs, const Array2<RT
 		  (*current_liboctave_error_handler)
       ("A(I) = X: X must be a scalar or a matrix with the same size as I");
 
 		  retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
-      else
-	{
-	  (*current_liboctave_error_handler)
-	    ("single index only valid for row or column vector");
-
-	  retval = 0;
-	}
     }
   else
     {
       (*current_liboctave_error_handler)
 	("invalid number of indices for matrix expression");
 
       retval = 0;
     }
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,20 @@
+2003-07-09  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Array-flags.cc, Array-flags.h (liboctave_pcv_flag): Delete.
+
+	* Array2-idx.h (Array2<T>::index): Use liboctave_wfi_flag, not
+	liboctave_dfi_flag.
+	(assign): Likewise.  For indexed assignments like X(I) = RHS with
+	X undefined or empty, always create a row vector.
+
+	* Array-flags.cc (liboctave_wfi_flag): Rename from liboctave_dfi_flag.
+	* Array-flags.h (liboctave_wfi_flag): Ditto.
+
 2003-06-24  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Array2-idx.h (Array2<T>::index (idx_vector&, int, const T&)):
 	Magic colon indexing always produces an object with one column.
 
 2003-06-21  Paul Kienzle <pkienzle@users.sf.net>
 
 	* kpse-xfns.h (NAME_BEGINS_WITH_DEVICE): Arg is std::string, not char*.
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,20 +1,27 @@
 2003-07-09  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* general/reshape.m: Omit do_fortran_indexing from doc string (it
+	was not used in the code in any case).
+
+	* strings/strjust.m: Temporarily set warn_fortran_indexing, not
+	do_fortran_indexing.
+
 	* statistics/base/moment.m: Temporarily set warn_str_to_num, not
 	implict_str_to_num_ok.  Use unwind_protect block to do it.
 
 	* miscellaneous/dump_prefs.m: Include DEFAULT_EXEC_PATH,
 	DEFAULT_LOAD_PATH, crash_dumps_octave_core,
 	sighup_dumps_octave_core, sigterm_dumps_octave_core,
-	warn_imag_to_real, warn_num_to_str, and warn_str_to_num in the
-	list.
-	Delete ok_to_lose_imaginary_part, implicit_num_to_str_ok, and
-	implicit_str_to_num_ok from list.
+	warn_imag_to_real, warn_num_to_str, warn_str_to_num, and
+	warn_fortran_indexing in the list.
+	Delete ok_to_lose_imaginary_part, implicit_num_to_str_ok,
+	implicit_str_to_num_ok, do_fortran_indexing, and
+	prefer_column_vectors from list.
 
 2003-07-02  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (distclean, maintainer-clean): Also remove
 	gethelp$(BUILD_EXEEXT), $(DOCSTRINGS), and autom4te.cache
 	directory.
 
 2003-06-17  Aaron A. King <king@quercus.tiem.utk.edu>
diff --git a/scripts/general/reshape.m b/scripts/general/reshape.m
--- a/scripts/general/reshape.m
+++ b/scripts/general/reshape.m
@@ -29,32 +29,31 @@
 ## @example
 ## @group
 ## reshape ([1, 2, 3, 4], 2, 2)
 ##      @result{}  1  3
 ##          2  4
 ## @end group
 ## @end example
 ##
-## If the variable @code{do_fortran_indexing} is nonzero, the
-## @code{reshape} function is equivalent to
+## The @code{reshape} function is equivalent to
 ##
 ## @example
 ## @group
 ## retval = zeros (m, n);
 ## retval (:) = a;
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## but it is somewhat less cryptic to use @code{reshape} instead of the
 ## colon operator.  Note that the total number of elements in the original
 ## matrix must match the total number of elements in the new matrix.
 ## @end deftypefn
-## @seealso{`:' and do_fortran_indexing}
+## @seealso{`:'}
 
 ## Author: jwe
 
 function retval = reshape (a, m, n)
 
   if (nargin == 2 && prod (size (m)) == 2)
     n = m(2);
     m = m(1);
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -53,17 +53,16 @@ function dump_prefs (file)
               "beep_on_error";
               "completion_append_char";
               "crash_dumps_octave_core";
               "default_eval_print_flag";
               "default_global_variable_value";
               "default_return_value";
               "default_save_format";
               "define_all_return_values";
-              "do_fortran_indexing";
               "echo_executing_commands";
               "empty_list_elements_ok";
               "fixed_point_format";
               "gnuplot_binary";
               "gnuplot_command_end";
               "gnuplot_command_plot";
               "gnuplot_command_replot";
               "gnuplot_command_splot";
@@ -75,17 +74,16 @@ function dump_prefs (file)
               "history_size";
               "ignore_function_time_stamp";
               "initialize_global_variables";
               "max_recursion_depth";
               "output_max_field_width";
               "output_precision";
               "page_output_immediately";
               "page_screen_output";
-              "prefer_column_vectors";
               "print_answer_id_name";
               "print_empty_dimensions";
               "print_rhs_assign_val";
               "propagate_empty_matrices";
               "resize_on_range_error";
               "return_last_computed_value";
               "save_precision";
               "saving_history";
@@ -94,16 +92,17 @@ function dump_prefs (file)
               "silent_functions";
               "split_long_rows";
               "string_fill_char";
               "struct_levels_to_print";
               "suppress_verbose_help_message";
               "treat_neg_dim_as_zero";
               "warn_assign_as_truth_value";
               "warn_divide_by_zero";
+              "warn_fortran_indexing";
               "warn_function_name_clash";
               "warn_future_time_stamp";
               "warn_imag_to_real";
               "warn_missing_semicolon";
               "warn_num_to_str";
               "warn_str_to_num";
               "warn_variable_switch_label";
               "whitespace_in_literal_matrix"];
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -32,19 +32,19 @@ function x = strjust (x, just)
   endif
 
   if (nargin == 1)
     just = "right";
   endif
 
   just = tolower (just);
 
-  dfi = do_fortran_indexing;
+  wfi = warn_fortran_indexing;
   unwind_protect
-    do_fortran_indexing = 1;
+    warn_fortran_indexing = 0;
 
     ## convert nulls to blanks
     idx = find (toascii (x) == 0);
     if (! isempty (idx))
       x(idx) = " ";
     endif
 
     ## For all cases, left, right and center, the algorithm is the same.
@@ -63,12 +63,12 @@ function x = strjust (x, just)
       [N, hi] = max (cumsum (idx));
       [N, lo] = max (cumsum (flipud (idx)));
       shift = ceil (nc - (lo-hi)/2);
     endif
     idx = rem (ones(nr,1)*[0:nc-1] + shift'*ones(1,nc), nc);
     x = x (idx*nr + [1:nr]'*ones(1,nc));
 
   unwind_protect_cleanup
-    do_fortran_indexing = dfi;
+    warn_fortran_indexing = wfi;
   end_unwind_protect
 
 endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,44 @@
 2003-07-09  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* octave.cc (maximum_braindamage): Don't set prefer_column_vectors.
+
+	* ov.cc (Vprefer_column_vectors): Delete.
+	(prefer_column_vectors): Delete.
+	(symbols_of_ov): Delete DEFVAR for prefer_column_vectors.
+
+	* octave.cc (maximum_braindamage): Don't set do_fortran_indexing.
+
+	* ov-re-mat.cc (octave_matrix::double_value,
+	octave_matrix::complex_value): Use Vwarn_fortran_indexing, not
+	Vdo_fortran_indexing.
+	* ov-range.cc (octave_range::double_value,
+	octave_range::complex_value): Likewise.
+	* ov-cx-mat.cc (octave_complex_matrix::double_value,
+	octave_complex_matrix::complex_value): Likewise.
+	* ov-ch-mat.cc (octave_char_matrix::double_value,
+	octave_char_matrix::complex_value): Likewise.
+	* ov-bool-mat.cc (octave_bool_matrix::double_value,
+	octave_bool_matrix::complex_value): Likewise.
+
+	* ov.cc (Vwarn_fortran_indexing): New variable.
+	(warn_fortran_indexing): New function.
+	(symbols_of_ov): Add DEFVAR for warn_fortran_indexing.
+	(octave_value::vector_value, octave_value::int_vector_value,
+	(octave_value::complex_vector_value): Check
+	Vwarn_fortran_indexing, not Vdo_fortran_indexing.
+
+	* ov.h (Vwarn_fortran_indexing): Provide decl.
+
+	* ov.cc (Vdo_fortran_indexing): Delete unused variable.
+	(do_fortran_indexing): Delete unused function.
+	(symbols_of_ov): Delete DEFVAR for do_fortran_indexing.
+	* ov.h (Vdo_fortran_indexing): Delete decl.
+
 	* ov.cc (octave_value::convert_to_str): Call convert_to_str_internal.
 	(octave_value::convert_to_str_internal): New virtual function.
 	Rename all derived class convert_to_str functions to match.	
 
 	* variables.cc (generate_struct_completions): Set
 	discard_warning_messages, not Vwarning_option.  Also protect
 	warning_state.
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1093,18 +1093,17 @@ DEFUN (linspace, args, ,
 @deftypefn {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.  The number of elements, @var{n}, must be\n\
 greater than 1.  The @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
 value of 100 is used.\n\
 \n\
-The @code{linspace} function always returns a row vector, regardless of\n\
-the value of @code{prefer_column_vectors}.\n\
+The @code{linspace} function always returns a row vector.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   int npoints = 100;
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -345,21 +345,19 @@ maximum_braindamage (void)
   bind_builtin_variable ("PS1", ">> ");
   bind_builtin_variable ("PS2", "");
   bind_builtin_variable ("beep_on_error", true);
   bind_builtin_variable ("crash_dumps_octave_core", false);
   bind_builtin_variable ("default_eval_print_flag", false);
   bind_builtin_variable ("default_global_variable_value", Matrix ());
   bind_builtin_variable ("default_save_format", "mat-binary");
   bind_builtin_variable ("define_all_return_values", true);
-  bind_builtin_variable ("do_fortran_indexing", true);
   bind_builtin_variable ("fixed_point_format", true);
   bind_builtin_variable ("initialize_global_variables", true);
   bind_builtin_variable ("page_screen_output", false);
-  bind_builtin_variable ("prefer_column_vectors", false);
   bind_builtin_variable ("print_empty_dimensions", false);
   bind_builtin_variable ("treat_neg_dim_as_zero", true);
   bind_builtin_variable ("warn_function_name_clash", false);
   bind_builtin_variable ("whitespace_in_literal_matrix", "traditional");
 }
 
 // You guessed it.
 
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -85,35 +85,47 @@ octave_bool_matrix::valid_as_scalar_inde
   return false;
 }
 
 double
 octave_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("bool matrix", "real scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("bool matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("bool matrix", "complex scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -54,35 +54,47 @@ octave_char_matrix::valid_as_scalar_inde
   return retval;
 }
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("character matrix", "real scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("character matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_char_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("character matrix", "complex scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -130,19 +130,25 @@ octave_complex_matrix::valid_as_scalar_i
 double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion && Vwarn_imag_to_real)
     gripe_implicit_conversion ("complex matrix", "real scalar");
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = std::real (matrix (0, 0));
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("complex matrix", "real scalar");
+
+      retval = std::real (matrix (0, 0));
+    }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_complex_matrix::matrix_value (bool force_conversion) const
@@ -159,19 +165,25 @@ octave_complex_matrix::matrix_value (boo
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("complex matrix", "complex scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -128,18 +128,24 @@ octave_range::do_index_op (const octave_
 
 double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   int nel = range.nelem ();
 
-  if (nel == 1 || (nel > 1 && Vdo_fortran_indexing))
-    retval = range.base ();
+  if (nel > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("range", "real scalar");
+
+      retval = range.base ();
+    }
   else
     gripe_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
 
 octave_value
 octave_range::all (int dim) const
@@ -191,18 +197,24 @@ Complex
 octave_range::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   int nel = range.nelem ();
 
-  if (nel == 1 || (nel > 1 && Vdo_fortran_indexing))
-    retval = range.base ();
+  if (nel > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("range", "complex scalar");
+
+      retval = range.base ();
+    }
   else
     gripe_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
 
 octave_value
 octave_range::convert_to_str_internal (bool pad) const
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -81,35 +81,46 @@ octave_matrix::valid_as_scalar_index (vo
 }
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("real matrix", "real scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("real matrix", "complex scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
 octave_matrix::convert_to_str_internal (bool) const
diff --git a/src/ov-re-nd-array.cc b/src/ov-re-nd-array.cc
--- a/src/ov-re-nd-array.cc
+++ b/src/ov-re-nd-array.cc
@@ -111,35 +111,46 @@ octave_matrix::valid_as_scalar_index (vo
 }
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("real matrix", "real scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if ((rows () == 1 && columns () == 1)
-      || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
-    retval = matrix (0, 0);
+  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  if (rows () > 0 && columns () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("real matrix", "complex scalar");
+
+      retval = matrix (0, 0);
+    }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 #endif
 
 /*
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -70,45 +70,37 @@ Software Foundation, 59 Temple Place - S
 // We are likely to have a lot of octave_value objects to allocate, so
 // make the grow_size large.
 DEFINE_OCTAVE_ALLOCATOR2(octave_value, 1024);
 
 // If TRUE, turn off printing of results in functions (as if a
 // semicolon has been appended to each statement).
 static bool Vsilent_functions;
 
-// If TRUE, allow assignments like
+// If TRUE, print a warning for assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
-bool Vdo_fortran_indexing;
+bool Vwarn_fortran_indexing;
 
 // Should we warn about conversions from complex to real?
 int Vwarn_imag_to_real;
 
 // Should we print a warning when converting `[97, 98, 99, "123"]'
 // to a character string?
 bool Vwarn_num_to_str;
 
 // If TRUE, warn for operations like
 //
 //   octave> 'abc' + 0
 //   97 98 99
 //
 int Vwarn_str_to_num;
 
-// If TRUE, create column vectors when doing assignments like:
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// (for A undefined).  Only matters when resize_on_range_error is also
-// TRUE.
-static bool Vprefer_column_vectors;
-
 // If TRUE, print the name along with the value.
 bool Vprint_answer_id_name;
 
 // Should operations on empty matrices return empty matrices or an
 // error?  A positive value means yes.  A negative value means yes,
 // but print a warning message.  Zero means it should be considered an
 // error.
 int Vpropagate_empty_matrices;
@@ -964,19 +956,22 @@ octave_value::vector_value (bool force_s
 	retval (i) = m (0, i);
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
-  else if (nr > 0 && nc > 0
-	   && (Vdo_fortran_indexing || force_vector_conversion))
+  else if (nr > 0 && nc > 0)
     {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (! force_vector_conversion && Vwarn_fortran_indexing)
+	gripe_implicit_conversion (type_name (), "real vector");
+
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 
 	    retval (k++) = m (i, j);
@@ -1036,19 +1031,22 @@ octave_value::int_vector_value (bool for
 	    {
 	      error ("conversion to integer value failed");
 	      return retval;
 	    }
 
 	  retval (i) = static_cast<int> (d);
 	}
     }
-  else if (nr > 0 && nc > 0
-	   && (Vdo_fortran_indexing || force_vector_conversion))
+  else if (nr > 0 && nc > 0)
     {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (! force_vector_conversion && Vwarn_fortran_indexing)
+	gripe_implicit_conversion (type_name (), "real vector");
+
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 
@@ -1100,19 +1098,22 @@ octave_value::complex_vector_value (bool
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  retval (i) = m (i, 0);
 	}
     }
-  else if (nr > 0 && nc > 0
-	   && (Vdo_fortran_indexing || force_vector_conversion))
+  else if (nr > 0 && nc > 0)
     {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (! force_vector_conversion && Vwarn_fortran_indexing)
+	gripe_implicit_conversion (type_name (), "complex vector");
+
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    retval (k++) = m (i, j);
 	  }
@@ -1748,21 +1749,21 @@ install_types (void)
   octave_all_va_args::register_type ();
   octave_magic_colon::register_type ();
   octave_builtin::register_type ();
   octave_mapper::register_type ();
   octave_user_function::register_type ();
 }
 
 static int
-do_fortran_indexing (void)
+warn_fortran_indexing (void)
 {
-  Vdo_fortran_indexing = check_preference ("do_fortran_indexing");
+  Vwarn_fortran_indexing = check_preference ("warn_fortran_indexing");
 
-  liboctave_dfi_flag = Vdo_fortran_indexing;
+  liboctave_wfi_flag = Vwarn_fortran_indexing;
 
   return 0;
 }
 
 static int
 warn_imag_to_real (void)
 {
   Vwarn_imag_to_real = check_preference ("warn_imag_to_real");
@@ -1782,27 +1783,16 @@ static int
 warn_str_to_num (void)
 {
   Vwarn_str_to_num = check_preference ("warn_str_to_num");
 
   return 0;
 }
 
 static int
-prefer_column_vectors (void)
-{
-  Vprefer_column_vectors
-    = check_preference ("prefer_column_vectors");
-
-  liboctave_pcv_flag = Vprefer_column_vectors;
-
-  return 0;
-}
-
-static int
 print_answer_id_name (void)
 {
   Vprint_answer_id_name = check_preference ("print_answer_id_name");
 
   return 0;
 }
 
 static int
@@ -1855,45 +1845,16 @@ warn_divide_by_zero (void)
   Vwarn_divide_by_zero = check_preference ("warn_divide_by_zero");
 
   return 0;
 }
 
 void
 symbols_of_ov (void)
 {
-  DEFVAR (do_fortran_indexing, false, do_fortran_indexing,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} do_fortran_indexing\n\
-If the value of @code{do_fortran_indexing} is nonzero, Octave allows \n\
-you to select elements of a two-dimensional matrix using a single index\n\
-by treating the matrix as a single vector created from the columns of\n\
-the matrix.  The default value is 0. \n\
-@end defvr");
-
-  DEFVAR (prefer_column_vectors, true, prefer_column_vectors,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} prefer_column_vectors\n\
-If @code{prefer_column_vectors} is nonzero, operations like\n\
-\n\
-@example\n\
-for i = 1:10\n\
-  a (i) = i;\n\
-endfor\n\
-@end example\n\
-\n\
-@noindent\n\
-(for @code{a} previously  undefined) produce column vectors.  Otherwise, row\n\
-vectors are preferred.  The default value is 1.\n\
-\n\
-If a variable is already defined to be a vector (a matrix with a single\n\
-row or column), the original orientation is respected, regardless of the\n\
-value of @code{prefer_column_vectors}.\n\
-@end defvr");
-
   DEFVAR (print_answer_id_name, true, print_answer_id_name,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} print_answer_id_name\n\
 If the value of @code{print_answer_id_name} is nonzero, variable\n\
 names are printed along with the result.  Otherwise, only the result\n\
 values are printed.  The default value is 1.\n\
 @end defvr");
 
@@ -1956,16 +1917,24 @@ built-in variable @code{struct_levels_to
   DEFVAR (warn_divide_by_zero, true, warn_divide_by_zero,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_divide_by_zero\n\
 If the value of @code{warn_divide_by_zero} is nonzero, a warning\n\
 is issued when Octave encounters a division by zero.  If the value is\n\
 0, the warning is omitted.  The default value is 1.\n\
 @end defvr");
 
+  DEFVAR (warn_fortran_indexing, false, warn_fortran_indexing,
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} warn_fortran_indexing\n\
+If the value of @code{warn_fortran_indexing} is nonzero, a warning is\n\
+printed for expressions which select elements of a two-dimensional matrix\n\
+using a single index.  The default value is 0.\n\
+@end defvr");
+
   DEFVAR (warn_imag_to_real, false, warn_imag_to_real,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_imag_to_real\n\
 If the value of @code{warn_imag_to_real} is nonzero, a warning is\n\
 printed for implicit conversions of complex numbers to real numbers.\n\
 The default value is 0.\n\
 @end defvr");
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -713,22 +713,22 @@ OV_BINOP_FN (op_struct_ref)
   private: \
     static int t_id; \
     static const std::string t_name;
 
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n) \
   int t::t_id (-1); \
   const std::string t::t_name (n)
 
-// If TRUE, allow assignments like
+// If TRUE, print a warning for assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
-extern bool Vdo_fortran_indexing;
+extern bool Vwarn_fortran_indexing;
 
 // Should we print a warning when converting `[97, 98, 99, "123"]'
 // to a character string?
 extern bool Vwarn_num_to_str;
 
 // If TRUE, warn for operations like
 //
 //   octave> 'abc' + 0
