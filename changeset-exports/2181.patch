# HG changeset patch
# User jwe
# Date 832010782 0
#      Mon May 13 18:06:22 1996 +0000
# Node ID 138b3c98dc85841f446d8c65d1c874a128d2a555
# Parent  b087e5e62bec528c7cecbba7277a317146f6868c
[project @ 1996-05-13 18:02:31 by jwe]

diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -58,16 +58,17 @@ Free Software Foundation, Inc.
 #include "readline/readline.h"
 #include "readline/history.h"
 
 #include "str-vec.h"
 
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
+#include "gripes.h"
 #include "help.h"
 #include "input.h"
 #include "oct-map.h"
 #include "oct-hist.h"
 #include "toplev.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "parse.h"
@@ -75,16 +76,28 @@ Free Software Foundation, Inc.
 #include "pt-const.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "sysdep.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
+// Primary prompt string.
+static string Vps1;
+
+// Secondary prompt string.
+static string Vps2;
+
+// String printed before echoed input (enabled by --echo-input).
+string Vps4;
+
+// Character to append after successful command-line completion attempts.
+static char Vcompletion_append_char;
+
 // Global pointer for eval().
 string current_eval_string;
 
 // Nonzero means get input from current_eval_string.
 int get_input_from_eval_string = 0;
 
 // Nonzero means we're parsing a function file.
 int reading_fcn_file = 0;
@@ -366,22 +379,22 @@ do_input_echo (const string& input_strin
     (user_pref.echo_executing_commands & ECHO_SCRIPTS)
       : (user_pref.echo_executing_commands & ECHO_CMD_LINE);
 
   if (do_echo)
     {
       if (forced_interactive)
 	{
 	  if (promptflag > 0)
-	    octave_stdout << decode_prompt_string (user_pref.ps1);
+	    octave_stdout << decode_prompt_string (Vps1);
 	  else
-	    octave_stdout << decode_prompt_string (user_pref.ps2);
+	    octave_stdout << decode_prompt_string (Vps2);
 	}
       else
-	octave_stdout << decode_prompt_string (user_pref.ps4);
+	octave_stdout << decode_prompt_string (Vps4);
 
       if (! input_string.empty ())
 	{
 	  octave_stdout << input_string;
 
 	  if (input_string[input_string.length () - 1] != '\n')
 	    octave_stdout << "\n";
 	}
@@ -460,18 +473,18 @@ gnu_readline (const char *s)
 static char *
 octave_gets (void)
 {
   char *retval = 0;
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file || reading_script_file)))
     {
-      const char *ps = (promptflag > 0) ? user_pref.ps1.c_str () :
-	user_pref.ps2.c_str ();
+      const char *ps = (promptflag > 0) ? Vps1.c_str () :
+	Vps2.c_str ();
 
       string prompt = decode_prompt_string (ps);
 
       if (interactive)
 	{
 	  pipe_handler_error_count = 0;
 	  flush_octave_stdout ();
 	}
@@ -850,17 +863,17 @@ command_generator (const char *text, int
 		}
 	      else
 		strcpy (buf, name);
 
 	      if (matches == 1 && looks_like_struct (buf))
 		rl_completion_append_character = '.';
 	      else
 		rl_completion_append_character
-		  = user_pref.completion_append_char;
+		  = Vcompletion_append_char;
 
 	      return buf;
 	    }
 	}
     }
 
   return 0;
 }
@@ -1179,13 +1192,85 @@ Without any arguments, toggle the curren
     default:
       print_usage ("echo");
       break;
     }
 
   return retval;
 }
 
+static int
+ps1 (void)
+{
+  int status = 0;
+
+  Vps1 = builtin_string_variable ("PS1");
+
+  return status;
+}
+
+static int
+ps2 (void)
+{
+  int status = 0;
+
+  Vps2 = builtin_string_variable ("PS2");
+
+  return status;
+}
+
+static int
+ps4 (void)
+{
+  int status = 0;
+
+  Vps4 = builtin_string_variable ("PS4");
+
+  return status;
+}
+
+static int
+completion_append_char (void)
+{
+  int status = 0;
+
+  string s = builtin_string_variable ("completion_append_char");
+
+  switch (s.length ())
+    {
+    case 1:
+      Vcompletion_append_char = s[0];
+      break;
+
+    case 0:
+      Vcompletion_append_char = '\0';
+      break;
+
+    default:
+      warning ("completion_append_char must be a single character");
+      status = -1;
+      break;
+    }
+
+  return status;
+}
+
+void
+symbols_of_input (void)
+{
+  DEFVAR (PS1, "\\s:\\#> ", 0, ps1,
+    "primary prompt string");
+
+  DEFVAR (PS2, "> ", 0, ps2,
+    "secondary prompt string");
+
+  DEFVAR (PS4, "+ ", 0, ps4,
+    "string printed before echoed input (enabled by --echo-input)");
+
+  DEFVAR (completion_append_char, " ", 0, completion_append_char,
+    "the string to append after successful command-line completion attempts");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -64,15 +64,19 @@ extern int forced_interactive;
 // Should we issue a prompt?
 extern int promptflag;
 
 // A line of input.
 extern string current_input_line;
 
 char *gnu_readline (const char *s);
 
+extern string Vps4;
+
+extern void symbols_of_input (void);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -38,16 +38,17 @@ Software Foundation, 59 Temple Place - S
 #include "SLStack.h"
 
 // These would be alphabetical, but y.tab.h must be included before
 // oct-gperf.h and y.tab.h must be included after token.h and the tree
 // class declarations.  We can't include y.tab.h in oct-gperf.h
 // because it may not be protected to allow it to be included multiple
 // times.
 
+#include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "lex.h"
 #include "toplev.h"
 #include "parse.h"
 #include "symtab.h"
 #include "token.h"
 #include "pt-base.h"
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1761,18 +1761,18 @@ save_mat_binary_data (ostream& os, const
       Matrix m = ::real(m_cmplx);
       os.write (m.data (), 8 * len);
       m = ::imag(m_cmplx);
       os.write (m.data (), 8 * len);
     }
   else if (tc.is_string ())
     {
       begin_unwind_frame ("save_mat_binary_data");
-      unwind_protect_int (user_pref.implicit_str_to_num_ok);
-      user_pref.implicit_str_to_num_ok = 1;
+      unwind_protect_int (Vimplicit_str_to_num_ok);
+      Vimplicit_str_to_num_ok = 1;
       Matrix m = tc.matrix_value ();
       os.write (m.data (), 8 * len);
       run_unwind_frame ("save_mat_binary_data");
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -33,21 +33,24 @@ Software Foundation, 59 Temple Place - S
 
 #include <string>
 
 #include <fstream.h>
 #include <iostream.h>
 
 #include <SLList.h>
 
+#include "Array-flags.h"
+
 #include "mx-base.h"
 #include "Range.h"
 #include "str-vec.h"
 
 #include "arith-ops.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "idx-vector.h"
 #include "mappers.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "pr-output.h"
@@ -79,16 +82,66 @@ Software Foundation, 59 Temple Place - S
 // OCT_VAL_REP class.
 
 // Pointer to the blocks of memory we manage.
 static OCT_VAL_REP *tc_rep_newlist = 0;
 
 // Multiplier for allocating new blocks.
 static const int tc_rep_newlist_grow_size = 128;
 
+// If TRUE, allow assignments like
+//
+//   octave> A(1) = 3; A(2) = 5
+//
+// for A already defined and a matrix type.
+static bool Vdo_fortran_indexing;
+
+// Should we allow things like:
+//
+//   octave> 'abc' + 0
+//   97 98 99
+//
+// to happen?  A positive value means yes.  A negative value means
+// yes, but print a warning message.  Zero means it should be
+// considered an error.
+int Vimplicit_str_to_num_ok;
+
+// Should we allow silent conversion of complex to real when a real
+// type is what we're really looking for?  A positive value means yes.
+// A negative value means yes, but print a warning message.  Zero
+// means it should be considered an error.
+static int Vok_to_lose_imaginary_part;
+
+// If TRUE, create column vectors when doing assignments like:
+//
+//   octave> A(1) = 3; A(2) = 5
+//
+// (for A undefined).  Only matters when resize_on_range_error is also
+// TRUE.
+static bool Vprefer_column_vectors;
+
+// If TRUE, prefer logical (zore-one) indexing over normal indexing
+// when there is a conflice.  For example, given a = [2, 3], the
+// expression  a ([1, 1]) would return [2 3] (instead of [2 2], which
+// would be returned if prefer_zero_one_indxing were FALSE).
+static bool Vprefer_zero_one_indexing;
+
+// Should operations on empty matrices return empty matrices or an
+// error?  A positive value means yes.  A negative value means yes,
+// but print a warning message.  Zero means it should be considered an
+// error.
+int Vpropagate_empty_matrices;
+
+// If TRUE, resize matrices when performing and indexed assignment and
+// the indices are outside the current bounds.
+bool Vresize_on_range_error;
+
+// How many levels of structure elements should we print?
+static int Vstruct_levels_to_print;
+
 // Indentation level for structures.
 static int struct_indent = 0;
 
 static void
 increment_struct_indent (void)
 {
   struct_indent += 2;
 }
@@ -460,17 +513,17 @@ OCT_VAL_REP::octave_value_rep (const Row
   if (len == 1)
     {
       scalar = v.elem (0);
       type_tag = scalar_constant;
     }
   else
     {
       int pcv = (prefer_column_vector < 0)
-	? user_pref.prefer_column_vectors
+	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  Matrix m (len, 1);
 	  for (int i = 0; i < len; i++)
 	    m.elem (i, 0) = v.elem (i);
 	  matrix = new Matrix (m);
@@ -493,17 +546,17 @@ OCT_VAL_REP::octave_value_rep (const Col
   if (len == 1)
     {
       scalar = v.elem (0);
       type_tag = scalar_constant;
     }
   else
     {
       int pcv = (prefer_column_vector < 0)
-	? user_pref.prefer_column_vectors
+	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  Matrix m (len, 1);
 	  for (int i = 0; i < len; i++)
 	    m.elem (i, 0) = v.elem (i);
 	  matrix = new Matrix (m);
@@ -599,17 +652,17 @@ OCT_VAL_REP::octave_value_rep (const Com
 	{
 	  complex_scalar = new Complex (c);
 	  type_tag = complex_scalar_constant;
 	}
     }
   else
     {
       int pcv = (prefer_column_vector < 0)
-	? user_pref.prefer_column_vectors
+	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  ComplexMatrix m (len, 1);
 	  for (int i = 0; i < len; i++)
 	    m.elem (i, 0) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
@@ -643,17 +696,17 @@ OCT_VAL_REP::octave_value_rep (const Com
 	{
 	  complex_scalar = new Complex (c);
 	  type_tag = complex_scalar_constant;
 	}
     }
   else
     {
       int pcv = (prefer_column_vector < 0)
-	? user_pref.prefer_column_vectors
+	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  ComplexMatrix m (len, 1);
 	  for (int i = 0; i < len; i++)
 	    m.elem (i, 0) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
@@ -1147,38 +1200,38 @@ OCT_VAL_REP::double_value (bool force_st
   switch (type_tag)
     {
     case scalar_constant:
       retval = scalar;
       break;
 
     case matrix_constant:
       {
-	if (user_pref.do_fortran_indexing && rows () > 0 && columns () > 0)
+	if (Vdo_fortran_indexing && rows () > 0 && columns () > 0)
 	  retval = matrix->elem (0, 0);
 	else
 	  gripe_invalid_conversion ("real matrix", "real scalar");
       }
       break;
 
     case complex_matrix_constant:
     case complex_scalar_constant:
       {
-	int flag = user_pref.ok_to_lose_imaginary_part;
+	int flag = Vok_to_lose_imaginary_part;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("complex scalar", "real scalar");
 
 	if (flag)
 	  {
 	    if (type_tag == complex_scalar_constant)
 	      retval = ::real (*complex_scalar);
 	    else if (type_tag == complex_matrix_constant)
 	      {
-		if (user_pref.do_fortran_indexing
+		if (Vdo_fortran_indexing
 		    && rows () > 0 && columns () > 0)
 		  retval = ::real (complex_matrix->elem (0, 0));
 		else
 		  gripe_invalid_conversion ("complex matrix", "real scalar");
 	      }
 	    else
 	      panic_impossible ();
 	  }
@@ -1186,46 +1239,46 @@ OCT_VAL_REP::double_value (bool force_st
 	  gripe_invalid_conversion ("complex scalar", "real scalar");
       }
       break;
 
     case char_matrix_constant:
       {
 	int len = char_matrix->rows ();
 	if ((char_matrix->rows () == 1 && len == 1)
-	    || (len > 1 && user_pref.do_fortran_indexing))
+	    || (len > 1 && Vdo_fortran_indexing))
 	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "real scalar");
       }
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
-	  flag = user_pref.implicit_str_to_num_ok;
+	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real scalar");
 
 	int len = char_matrix->rows ();
 	if (flag
 	    && ((char_matrix->rows () == 1 && len == 1)
-		|| (len > 1 && user_pref.do_fortran_indexing)))
+		|| (len > 1 && Vdo_fortran_indexing)))
 	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "real scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
-	if (nel == 1 || (nel > 1 && user_pref.do_fortran_indexing))
+	if (nel == 1 || (nel > 1 && Vdo_fortran_indexing))
 	  retval = range->base ();
 	else
 	  gripe_invalid_conversion ("range", "real scalar");
       }
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "real scalar");
@@ -1248,17 +1301,17 @@ OCT_VAL_REP::matrix_value (bool force_st
 
     case matrix_constant:
       retval = *matrix;
       break;
 
     case complex_scalar_constant:
     case complex_matrix_constant:
       {
-	int flag = user_pref.ok_to_lose_imaginary_part;
+	int flag = Vok_to_lose_imaginary_part;
 	if (flag < 0)
 	  warn_implicit_conversion ("complex matrix", "real matrix");
 
 	if (flag)
 	  {
 	    if (type_tag == complex_scalar_constant)
 	      retval = Matrix (1, 1, ::real (*complex_scalar));
 	    else if (type_tag == complex_matrix_constant)
@@ -1274,17 +1327,17 @@ OCT_VAL_REP::matrix_value (bool force_st
     case char_matrix_constant:
       retval = Matrix (*char_matrix);
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
-	  flag = user_pref.implicit_str_to_num_ok;
+	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real matrix");
 
 	if (flag)
 	  retval = Matrix (*char_matrix);
 	else
 	  gripe_invalid_conversion ("string", "real matrix");
@@ -1316,62 +1369,62 @@ OCT_VAL_REP::complex_value (bool force_s
 
     case scalar_constant:
       retval = scalar;
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       {
-	if (user_pref.do_fortran_indexing && rows () > 0 && columns () > 0)
+	if (Vdo_fortran_indexing && rows () > 0 && columns () > 0)
 	  {
 	    if (type_tag == complex_matrix_constant)
 	      retval = complex_matrix->elem (0, 0);
 	    else
 	      retval = matrix->elem (0, 0);
 	  }
 	else
 	  gripe_invalid_conversion ("real matrix", "real scalar");
       }
       break;
 
     case char_matrix_constant:
       {
 	int len = char_matrix->cols ();
 	if ((char_matrix->rows () == 1 && len == 1)
-	    || (len > 1 && user_pref.do_fortran_indexing))
+	    || (len > 1 && Vdo_fortran_indexing))
 	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "complex scalar");
       }
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
-	  flag = user_pref.implicit_str_to_num_ok;
+	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex scalar");
 
 	int len = char_matrix->cols ();
 	if (flag
 	    && ((char_matrix->rows () == 1 && len == 1)
-		|| (len > 1 && user_pref.do_fortran_indexing)))
+		|| (len > 1 && Vdo_fortran_indexing)))
 	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "complex scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
-	if (nel == 1 || (nel > 1 && user_pref.do_fortran_indexing))
+	if (nel == 1 || (nel > 1 && Vdo_fortran_indexing))
 	  retval = range->base ();
 	else
 	  gripe_invalid_conversion ("range", "complex scalar");
       }
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "complex scalar");
@@ -1407,17 +1460,17 @@ OCT_VAL_REP::complex_matrix_value (bool 
     case char_matrix_constant:
       retval = ComplexMatrix (*char_matrix);
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
-	  flag = user_pref.implicit_str_to_num_ok;
+	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex matrix");
 
 	if (flag)
 	  retval = ComplexMatrix (*char_matrix);
 	else
 	  gripe_invalid_conversion ("complex", "real matrix");
@@ -1440,17 +1493,17 @@ OCT_VAL_REP::complex_matrix_value (bool 
 
 charMatrix
 OCT_VAL_REP::char_matrix_value (bool force_string_conv) const
 {
   charMatrix retval;
 
   int flag = force_string_conv;
   if (! flag)
-    flag = user_pref.implicit_str_to_num_ok;
+    flag = Vimplicit_str_to_num_ok;
 
   switch (type_tag)
     {
     case char_matrix_constant:
     case char_matrix_constant_str:
       retval = *char_matrix;
       break;
 
@@ -1548,17 +1601,17 @@ OCT_VAL_REP::vector_value (bool force_st
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	retval.elem (i) = m.elem (i, 0);
     }
   else if (nr > 0 && nc > 0
-	   && (user_pref.do_fortran_indexing || force_vector_conversion))
+	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  retval.elem (k++) = m.elem (i, j);
     }
   else
@@ -1592,17 +1645,17 @@ OCT_VAL_REP::complex_vector_value (bool 
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	retval.elem (i) = m.elem (i, 0);
     }
   else if (nr > 0 && nc > 0
-	   && (user_pref.do_fortran_indexing || force_vector_conversion))
+	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  retval.elem (k++) = m.elem (i, j);
     }
   else
@@ -1754,17 +1807,17 @@ OCT_VAL_REP::convert_to_row_or_column_ve
 
   int len = nr * nc;
 
   assert (len > 0);
 
   int new_nr = 1;
   int new_nc = 1;
 
-  if (user_pref.prefer_column_vectors)
+  if (Vprefer_column_vectors)
     new_nr = len;
   else
     new_nc = len;
 
   if (type_tag == matrix_constant)
     {
       Matrix *m = new Matrix (new_nr, new_nc);
 
@@ -1878,17 +1931,17 @@ OCT_VAL_REP::force_numeric (bool force_s
     case matrix_constant:
     case complex_scalar_constant:
     case complex_matrix_constant:
     case char_matrix_constant:
       break;
 
     case char_matrix_constant_str:
       {
-	if (! force_string_conv && ! user_pref.implicit_str_to_num_ok)
+	if (! force_string_conv && ! Vimplicit_str_to_num_ok)
 	  {
 	    ::error ("string to numeric conversion failed --\
  default conversion turned off");
 	    return;
 	  }
 
 	int nr = char_matrix->rows ();
 	int nc = char_matrix->cols ();
@@ -1982,17 +2035,17 @@ OCT_VAL_REP::make_numeric (bool force_st
     case char_matrix_constant:
       retval = *char_matrix;
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
-	  flag = user_pref.implicit_str_to_num_ok;
+	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "char matrix");
 
 	if (flag)
 	  {
 	    retval = *char_matrix;
 	    retval.force_numeric (force_string_conv);
@@ -2244,19 +2297,19 @@ OCT_VAL_REP::print (ostream& output_buf)
       {
 	// XXX FIXME XXX -- would be nice to print the output in some
 	// standard order.  Maybe all substructures first, maybe
 	// alphabetize entries, etc.
 
 	begin_unwind_frame ("OCT_VAL_REP_print");
 
 	unwind_protect_int (struct_indent);
-	unwind_protect_int (user_pref.struct_levels_to_print);
-
-	if (user_pref.struct_levels_to_print-- > 0)
+	unwind_protect_int (Vstruct_levels_to_print);
+
+	if (Vstruct_levels_to_print-- > 0)
 	  {
 	    output_buf.form ("\n%*s{\n", struct_indent, "");
 
 	    increment_struct_indent ();
 
 	    Pix p = a_map->first ();
 
 	    while (p)
@@ -2360,17 +2413,17 @@ do_binary_op (octave_value& a, octave_va
 {
   octave_value retval;
 
   bool first_empty = (a.rows () == 0 || a.columns () == 0);
   bool second_empty = (b.rows () == 0 || b.columns () == 0);
 
   if (first_empty || second_empty)
     {
-      int flag = user_pref.propagate_empty_matrices;
+      int flag = Vpropagate_empty_matrices;
       if (flag < 0)
 	warning ("binary operation on empty matrix");
       else if (flag == 0)
 	{
 	  ::error ("invalid binary operation on empty matrix");
 	  return retval;
 	}
     }
@@ -2538,17 +2591,17 @@ do_binary_op (octave_value& a, octave_va
 
 octave_value
 do_unary_op (octave_value& a, tree_expression::type t)
 {
   octave_value retval;
 
   if (a.rows () == 0 || a.columns () == 0)
     {
-      int flag = user_pref.propagate_empty_matrices;
+      int flag = Vpropagate_empty_matrices;
       if (flag < 0)
 	warning ("unary operation on empty matrix");
       else if (flag == 0)
 	{
 	  ::error ("invalid unary operation on empty matrix");
 	  return retval;
 	}
     }
@@ -2692,17 +2745,17 @@ OCT_VAL_REP::set_index (const ColumnVect
 
 void
 OCT_VAL_REP::set_index (const Matrix& m)
 {
   int nr = m.rows ();
   int nc = m.cols ();
 
   if (nr <= 1 || nc <= 1
-      || user_pref.do_fortran_indexing)
+      || Vdo_fortran_indexing)
     {
       switch (type_tag)
 	{
 	case matrix_constant:
 	  matrix->set_index (m);
 	  break;
 
 	case OCT_VAL_REP::complex_matrix_constant:
@@ -3102,13 +3155,124 @@ OCT_VAL_REP::print_as_scalar (void)
 }
 
 bool
 OCT_VAL_REP::print_as_structure (void)
 {
   return is_map ();
 }
 
+static int
+do_fortran_indexing (void)
+{
+  Vdo_fortran_indexing = check_preference ("do_fortran_indexing");
+
+  liboctave_dfi_flag = Vdo_fortran_indexing;
+
+  return 0;
+}
+
+static int
+implicit_str_to_num_ok (void)
+{
+  Vimplicit_str_to_num_ok = check_preference ("implicit_str_to_num_ok");
+
+  return 0;
+}
+
+static int
+ok_to_lose_imaginary_part (void)
+{
+  Vok_to_lose_imaginary_part = check_preference ("ok_to_lose_imaginary_part");
+
+  return 0;
+}
+
+static int
+prefer_column_vectors (void)
+{
+  Vprefer_column_vectors
+    = check_preference ("prefer_column_vectors");
+
+  liboctave_pcv_flag = Vprefer_column_vectors;
+
+  return 0;
+}
+
+static int
+prefer_zero_one_indexing (void)
+{
+  Vprefer_zero_one_indexing = check_preference ("prefer_zero_one_indexing");
+
+  liboctave_pzo_flag = Vprefer_zero_one_indexing;
+
+  return 0;
+}
+
+static int
+propagate_empty_matrices (void)
+{
+  Vpropagate_empty_matrices = check_preference ("propagate_empty_matrices");
+
+  return 0;
+}
+
+static int
+resize_on_range_error (void)
+{
+  Vresize_on_range_error = check_preference ("resize_on_range_error");
+
+  liboctave_rre_flag = Vresize_on_range_error;
+
+  return 0;
+}
+
+static int
+struct_levels_to_print (void)
+{
+  double val;
+  if (builtin_real_scalar_variable ("struct_levels_to_print", val)
+      && ! xisnan (val))
+    {
+      int ival = NINT (val);
+      if (ival >= 0 && (double) ival == val)
+	{
+	  Vstruct_levels_to_print = ival;
+	  return 0;
+	}
+    }
+  gripe_invalid_value_specified ("struct_levels_to_print");
+  return -1;
+}
+
+void
+symbols_of_pt_const (void)
+{
+  DEFVAR (do_fortran_indexing, 0.0, 0, do_fortran_indexing,
+    "allow single indices for matrices");
+
+  DEFVAR (implicit_str_to_num_ok, 0.0, 0, implicit_str_to_num_ok,
+    "allow implicit string to number conversion");
+
+  DEFVAR (ok_to_lose_imaginary_part, "warn", 0, ok_to_lose_imaginary_part,
+    "silently convert from complex to real by dropping imaginary part");
+
+  DEFVAR (prefer_column_vectors, 1.0, 0, prefer_column_vectors,
+    "prefer column/row vectors");
+
+  DEFVAR (prefer_zero_one_indexing, 0.0, 0, prefer_zero_one_indexing,
+    "when there is a conflict, prefer zero-one style indexing");
+
+  DEFVAR (propagate_empty_matrices, 1.0, 0, propagate_empty_matrices,
+    "operations on empty matrices return an empty matrix, not an error");
+
+  DEFVAR (resize_on_range_error, 1.0, 0, resize_on_range_error,
+    "enlarge matrices on assignment");
+
+  DEFVAR (struct_levels_to_print, 2.0, 0, struct_levels_to_print,
+    "number of levels of structure elements to print");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -686,17 +686,21 @@ private:
 	return rep->make_numeric (frc_str_conv);
     }
 
   bool print_as_scalar (void) { return rep->print_as_scalar (); }
 
   bool print_as_structure (void) { return rep->print_as_structure (); }
 };
 
-extern int Vresize_on_range_error;
+extern int Vimplicit_str_to_num_ok;
+
+extern int Vpropagate_empty_matrices;
+
+extern bool Vresize_on_range_error;
 
 void symbols_of_pt_const (void);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/user-prefs.cc b/src/user-prefs.cc
--- a/src/user-prefs.cc
+++ b/src/user-prefs.cc
@@ -23,18 +23,16 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
 
-#include "Array-flags.h"
-
 #include "error.h"
 #include "gripes.h"
 #include "mappers.h"
 #include "oct-hist.h"
 #include "sysdep.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
@@ -44,80 +42,45 @@ Software Foundation, 59 Temple Place - S
 // need to check a preference.
 user_preferences user_pref;
 
 // Initialize global user_pref structure.
 
 void
 init_user_prefs (void)
 {
-  user_pref.automatic_replot = 0;
-  user_pref.beep_on_error = 0;
-  user_pref.define_all_return_values = 0;
-  user_pref.do_fortran_indexing = 0;
-  user_pref.empty_list_elements_ok = 0;
-  user_pref.gnuplot_has_multiplot = 0;
   user_pref.history_size = 0;
   user_pref.ignore_function_time_stamp = 0;
-  user_pref.implicit_str_to_num_ok = 0;
-  user_pref.ok_to_lose_imaginary_part = 0;
-  user_pref.output_max_field_width = 0;
-  user_pref.output_precision = 0;
-  user_pref.page_output_immediately = 0;
-  user_pref.page_screen_output = 0;
-  user_pref.prefer_column_vectors = 0;
-  user_pref.prefer_zero_one_indexing = 0;
   user_pref.print_answer_id_name = 0;
-  user_pref.print_empty_dimensions = 0;
-  user_pref.propagate_empty_matrices = 0;
   user_pref.read_only_constants = 1;
-  user_pref.resize_on_range_error = 0;
-  user_pref.return_last_computed_value = 0;
   user_pref.save_precision = 0;
   user_pref.saving_history = 0;
-  user_pref.silent_functions = 0;
-  user_pref.split_long_rows = 0;
-  user_pref.struct_levels_to_print = 0;
   user_pref.suppress_verbose_help_message = 0;
   user_pref.treat_neg_dim_as_zero = 0;
-  user_pref.warn_assign_as_truth_value = 0;
-  user_pref.warn_comma_in_global_decl = 0;
   user_pref.warn_divide_by_zero = 0;
-  user_pref.warn_function_name_clash = 0;
-  user_pref.whitespace_in_literal_matrix = 0;
-
-  user_pref.completion_append_char = '\0';
 
   user_pref.default_save_format = string ();
   user_pref.editor = string ();
   user_pref.exec_path = string ();
-  user_pref.gnuplot_binary = string ();
   user_pref.history_file = string ();
   user_pref.imagepath = string ();
   user_pref.info_file = string ();
   user_pref.info_prog = string ();
   user_pref.loadpath = string ();
-  user_pref.pager_binary = string ();
-  user_pref.ps1 = string ();
-  user_pref.ps2 = string ();
-  user_pref.ps4 = string ();
   user_pref.pwd = string ();
 }
 
 // Check the value of a string variable to see if it it's ok to do
 // something.
 //
 //   return of  1 => always ok.
 //   return of  0 => never ok.
 //   return of -1 => ok, but give me warning (default).
 
-// XXX FIXME XXX -- should also allow zero to mean "false" and nonzero
-// to mean "true".
-
-static int
+int
 check_preference (const string& var)
 {
   int pref = -1;
 
   string val = builtin_string_variable (var);
 
   if (val.empty ())
     {
@@ -137,69 +100,16 @@ check_preference (const string& var)
     }
 
   return pref;
 }
 
 // XXX FIXME XXX -- some of these should do their own checking to be
 // able to provide more meaningful warning or error messages.
 
-// Should a replot command be generated automatically each time a plot
-// changes in some way?
-
-int
-automatic_replot (void)
-{
-  user_pref.automatic_replot = check_preference ("automatic_replot");
-
-  return 0;
-}
-
-
-// Should we beep obnoxiously before printing error messages?
-
-int
-beep_on_error (void)
-{
-  user_pref.beep_on_error = check_preference ("beep_on_error");
-
-  return 0;
-}
-
-
-// Should variables returned from functions have default values if
-// they are otherwise uninitialized?
-
-int
-define_all_return_values (void)
-{
-  user_pref.define_all_return_values
-    = check_preference ("define_all_return_values");
-
-  return 0;
-}
-
-
-// Should we allow assignments like:
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// for A already defined and a matrix type?
-
-int
-do_fortran_indexing (void)
-{
-  user_pref.do_fortran_indexing = check_preference ("do_fortran_indexing");
-
-  liboctave_dfi_flag = user_pref.do_fortran_indexing;
-
-  return 0;
-}
-
-
 // Echo commands as they are executed?
 //
 //   1  ==>  echo commands read from script files
 //   2  ==>  echo commands from functions
 //   4  ==>  echo commands read from command line
 //
 // more than one state can be active at once.
 
@@ -208,41 +118,16 @@ echo_executing_commands (void)
 {
   user_pref.echo_executing_commands
     = check_preference ("echo_executing_commands"); 
 
   return 0;
 }
 
 
-// Should ignore empty elements in a matrix list (i.e., is an
-//  expression like `[[], 1]' ok?
-
-int
-empty_list_elements_ok (void)
-{
-  user_pref.empty_list_elements_ok
-    = check_preference ("empty_list_elements_ok");
-
-  return 0;
-}
-
-
-// Does gnuplot appear to support multiplot?
-
-int
-gnuplot_has_multiplot (void)
-{
-  user_pref.gnuplot_has_multiplot
-    = check_preference ("gnuplot_has_multiplot");
-
-  return 0;
-}
-
-
 // How many lines of command history should we save?
 
 int
 history_size (void)
 {
   double val;
   if (builtin_real_scalar_variable ("history_size", val)
       && ! xisnan (val))
@@ -279,108 +164,16 @@ ignore_function_time_stamp (void)
     }
 
   user_pref.ignore_function_time_stamp = pref;
 
   return 0;
 }
 
 
-// Should we allow things like:
-//
-//   octave> 'abc' + 0
-//   97 98 99
-//
-// to happen?
-
-int
-implicit_str_to_num_ok (void)
-{
-  user_pref.implicit_str_to_num_ok
-    = check_preference ("implicit_str_to_num_ok");
-
-  return 0;
-}
-
-
-// Should we allow silent conversion of complex to real when a real
-// type is what we're really looking for?
-
-int
-ok_to_lose_imaginary_part (void)
-{
-  user_pref.ok_to_lose_imaginary_part
-    = check_preference ("ok_to_lose_imaginary_part");
-
-  return 0;
-}
-
-
-// If output is going to the pager, should we send it as soon as it is
-// available, or wait until we are ready to prompt for input?
-
-int
-page_output_immediately (void)
-{
-  user_pref.page_output_immediately
-    = check_preference ("page_output_immediately");
-
-  return 0;
-}
-
-
-// If possible, send all output intended for the screen through the
-// pager. 
-
-int
-page_screen_output (void)
-{
-  user_pref.page_screen_output = check_preference ("page_screen_output");
-
-  return 0;
-}
-
-
-// When doing assignments like:
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// (for A undefined) should we build column vectors?  Returning true
-// only matters when resize_on_range_error is also true.
-
-int
-prefer_column_vectors (void)
-{
-  user_pref.prefer_column_vectors
-    = check_preference ("prefer_column_vectors");
-
-  liboctave_pcv_flag = user_pref.prefer_column_vectors;
-
-  return 0;
-}
-
-
-// For things like
-//
-//   a = [2,3]; a([1,1])
-//
-// return [2 3] instead of [2 2].
-
-int
-prefer_zero_one_indexing (void)
-{
-  user_pref.prefer_zero_one_indexing
-    = check_preference ("prefer_zero_one_indexing");
-
-  liboctave_pzo_flag = user_pref.prefer_zero_one_indexing;
-
-  return 0;
-}
-
-
 // Should we print things like
 //
 //   octave> a = [1,2;3,4]
 //   a = 
 //
 //      1  2
 //      3  4
 
@@ -388,132 +181,38 @@ int
 print_answer_id_name (void)
 {
   user_pref.print_answer_id_name = check_preference ("print_answer_id_name");
 
   return 0;
 }
 
 
-// Should we also print the dimensions of empty matrices?
-
-int
-print_empty_dimensions (void)
-{
-  user_pref.print_empty_dimensions
-    = check_preference ("print_empty_dimensions");
-
-  return 0;
-}
-
-
-// Should operations on empty matrices return empty matrices or an
-// error?
-
-int
-propagate_empty_matrices (void)
-{
-  user_pref.propagate_empty_matrices
-    = check_preference ("propagate_empty_matrices");
-
-  return 0;
-}
-
 // Should built-in constants always be read only?
 
 int
 read_only_constants (void)
 {
   user_pref.read_only_constants = check_preference ("read_only_constants");
 
   return 0;
 }
 
-// When doing assignments, should we resize matrices if the indices
-// are outside the current bounds?
-
-int
-resize_on_range_error (void)
-{
-  user_pref.resize_on_range_error
-    = check_preference ("resize_on_range_error");
-
-  liboctave_rre_flag = user_pref.resize_on_range_error;
-
-  return 0;
-}
-
-
-// If a function does not return any values explicitly, return the
-// last computed value.
-
-int
-return_last_computed_value (void)
-{
-  user_pref.return_last_computed_value
-    = check_preference ("return_last_computed_value");
-
-  return 0;
-}
-
 
 // Should we save command history?
 
 int
 saving_history (void)
 {
   user_pref.saving_history = check_preference ("saving_history");
   octave_command_history.ignore_entries (! user_pref.saving_history);
   return 0;
 }
 
 
-// Suppress printing results in called functions.
-
-int
-silent_functions (void)
-{
-  user_pref.silent_functions = check_preference ("silent_functions");
-
-  return 0;
-}
-
-
-// Should should big matrices be split into smaller slices for output?
-
-int
-split_long_rows (void)
-{
-  user_pref.split_long_rows = check_preference ("split_long_rows");
-
-  return 0;
-}
-
-
-// How many levels of structure elements should we print?
-
-int
-struct_levels_to_print (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("struct_levels_to_print", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
-	{
-	  user_pref.struct_levels_to_print = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("struct_levels_to_print");
-  return -1;
-}
-
-
 // Suppress printing of additional help message in help and usage
 // functions?
 
 int
 suppress_verbose_help_message (void)
 {
   user_pref.suppress_verbose_help_message =
     check_preference ("suppress_verbose_help_message");
@@ -533,178 +232,26 @@ treat_neg_dim_as_zero (void)
 {
   user_pref.treat_neg_dim_as_zero
     = check_preference ("treat_neg_dim_as_zero");
 
   return 0;
 }
 
 
-// Generate a warning for the assignment in things like
-//
-//   octave> if (a = 2 < n)
-//
-// but not
-//
-//   octave> if ((a = 2) < n)
-
-int
-warn_assign_as_truth_value (void)
-{
-  user_pref.warn_assign_as_truth_value
-    = check_preference ("warn_assign_as_truth_value");
-
-  return 0;
-}
-
-
-// Generate a warning for the comma in things like
-//
-//   octave> global a, b = 2
-
-int
-warn_comma_in_global_decl (void)
-{
-  user_pref.warn_comma_in_global_decl
-    = check_preference ("warn_comma_in_global_decl");
-
-  return 0;
-}
-
-
 // On IEEE machines, allow divide by zero errors to be suppressed.
 
 int
 warn_divide_by_zero (void)
 {
   user_pref.warn_divide_by_zero = check_preference ("warn_divide_by_zero");
 
   return 0;
 }
 
-// Generate warning if declared function name disagrees with the name
-// of the file in which it is defined.
-
-int
-warn_function_name_clash (void)
-{
-  user_pref.warn_function_name_clash
-    = check_preference ("warn_function_name_clash");
-
-  return 0;
-}
-
-
-// Generate warning if a statement in a function is not terminated
-// with a semicolon.  Useful for checking functions that should only
-// produce output using explicit printing statements.
-
-int
-warn_missing_semicolon (void)
-{
-  user_pref.warn_missing_semicolon
-    = check_preference ("warn_missing_semicolon");
-
-  return 0;
-}
-
-
-// Should whitespace in a literal matrix list be automatically
-// converted to commas and semicolons?
-//
-//   user specifies   value of pref
-//   --------------   -------------
-//   "ignore"               2
-//   "traditional"          1
-//   anything else          0
-//
-// Octave will never insert a comma in a literal matrix list if the
-// user specifies "ignore".  For example, the statement [1 2] will
-// result in an error instead of being treated the same as [1, 2], and
-// the statement
-//
-//   [ 1, 2,
-//     3, 4 ]
-//
-// will result in the vector [1 2 3 4] instead of a matrix.
-//
-// Traditional behavior makes Octave convert spaces to a comma between
-// identifiers and `('.  For example, the statement
-//
-//   [eye (2)]
-//
-// will be parsed as
-//
-//   [eye, (2)]
-//
-// and will result in an error since the `eye' function will be
-// called with no arguments.  To get around this, you would have to
-// omit the space between `eye' and the `('.
-//
-// The default value is 0, which results in behavior that is the same
-// as traditional, except that Octave does not convert spaces to a
-// comma between identifiers and `('.  For example, the statement
-//
-//   [eye (2)]
-//
-// will result in a call to `eye' with the argument `2'. 
-
-int
-whitespace_in_literal_matrix (void)
-{
-  int pref = 0;
-  string val = builtin_string_variable ("whitespace_in_literal_matrix");
-  if (! val.empty ())
-    {
-      if (val.compare ("ignore", 0, 6) == 0)
-	pref = 2;
-      else if (val.compare ("traditional", 0, 11) == 0)
-	pref = 1;
-    }
-  user_pref.whitespace_in_literal_matrix = pref;
-  return 0;
-}
-
-
-int
-set_output_max_field_width (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("output_max_field_width", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival > 0 && (double) ival == val)
-	{
-	  user_pref.output_max_field_width = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("output_max_field_width");
-  return -1;
-}
-
-int
-set_output_precision (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("output_precision", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
-	{
-	  user_pref.output_precision = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("output_precision");
-  return -1;
-}
-
 int
 set_save_precision (void)
 {
   double val;
   if (builtin_real_scalar_variable ("save_precision", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
@@ -714,42 +261,16 @@ set_save_precision (void)
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("save_precision");
   return -1;
 }
 
 int
-sv_completion_append_char (void)
-{
-  int status = 0;
-
-  string s = builtin_string_variable ("completion_append_char");
-
-  switch (s.length ())
-    {
-    case 1:
-      user_pref.completion_append_char = s[0];
-      break;
-
-    case 0:
-      user_pref.completion_append_char = '\0';
-      break;
-
-    default:
-      warning ("completion_append_char must be a single character");
-      status = -1;
-      break;
-    }
-
-  return status;
-}
-
-int
 sv_default_save_format (void)
 {
   int status = 0;
 
   string s = builtin_string_variable ("default_save_format");
 
   if (s.empty ())
     {
@@ -858,34 +379,16 @@ sv_exec_path (void)
 
       putenv (putenv_cmd);
     }
 
   return status;
 }
 
 int
-sv_gnuplot_binary (void)
-{
-  int status = 0;
-
-  string s = builtin_string_variable ("gnuplot_binary");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("gnuplot_binary");
-      status = -1;
-    }
-  else
-    user_pref.gnuplot_binary = s;
-
-  return status;
-}
-
-int
 sv_history_file (void)
 {
   int status = 0;
 
   string s = builtin_string_variable ("history_file");
 
   if (s.empty ())
     {
@@ -969,64 +472,16 @@ sv_loadpath (void)
     }
   else
     user_pref.loadpath = maybe_add_default_load_path (s);
 
   return status;
 }
 
 int
-sv_pager_binary (void)
-{
-  int status = 0;
-
-  string s = builtin_string_variable ("PAGER");
-
-  if (s.empty ())
-    {
-      gripe_invalid_value_specified ("PAGER");
-      status = -1;
-    }
-  else
-    user_pref.pager_binary = s;
-
-  return status;
-}
-
-int
-sv_ps1 (void)
-{
-  int status = 0;
-
-  user_pref.ps1 = builtin_string_variable ("PS1");
-
-  return status;
-}
-
-int
-sv_ps2 (void)
-{
-  int status = 0;
-
-  user_pref.ps2 = builtin_string_variable ("PS2");
-
-  return status;
-}
-
-int
-sv_ps4 (void)
-{
-  int status = 0;
-
-  user_pref.ps4 = builtin_string_variable ("PS4");
-
-  return status;
-}
-
-int
 sv_pwd (void)
 {
   int status = 0;
 
   string s = builtin_string_variable ("PWD");
 
   if (s.empty ())
     {
diff --git a/src/user-prefs.h b/src/user-prefs.h
--- a/src/user-prefs.h
+++ b/src/user-prefs.h
@@ -22,137 +22,73 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_user_prefs_h)
 #define octave_user_prefs_h 1
 
 #include <string>
 
 struct user_preferences
 {
-  int automatic_replot;
-  int beep_on_error;
-  int define_all_return_values;
-  int do_fortran_indexing;
   int echo_executing_commands;
-  int empty_list_elements_ok;
-  int gnuplot_has_multiplot;
   int history_size;
   int ignore_function_time_stamp;
-  int implicit_str_to_num_ok;
-  int ok_to_lose_imaginary_part;
-  int output_max_field_width;
-  int output_precision;
-  int page_output_immediately;
-  int page_screen_output;
-  int prefer_column_vectors;
-  int prefer_zero_one_indexing;
   int print_answer_id_name;
-  int print_empty_dimensions;
-  int propagate_empty_matrices;
   int read_only_constants;
-  int resize_on_range_error;
-  int return_last_computed_value;
   int save_precision;
   int saving_history;
-  int silent_functions;
-  int split_long_rows;
-  int struct_levels_to_print;
   int suppress_verbose_help_message;
   int treat_neg_dim_as_zero;
-  int warn_assign_as_truth_value;
-  int warn_comma_in_global_decl;
   int warn_divide_by_zero;
-  int warn_missing_semicolon;
-  int warn_function_name_clash;
-  int whitespace_in_literal_matrix;
-
-  char completion_append_char;
 
   string default_save_format;
   string editor;
   string exec_path;
-  string gnuplot_binary;
   string history_file;
   string imagepath;
   string info_file;
   string info_prog;
   string loadpath;
-  string pager_binary;
-  string ps1;
-  string ps2;
-  string ps4;
   string pwd;
 };
 
 extern user_preferences user_pref;
 
 extern void init_user_prefs (void);
 
-extern int automatic_replot (void);
-extern int beep_on_error (void);
-extern int define_all_return_values (void);
-extern int do_fortran_indexing (void);
 extern int echo_executing_commands (void);
-extern int empty_list_elements_ok (void);
-extern int gnuplot_has_multiplot (void);
 extern int history_size (void);
 extern int ignore_function_time_stamp (void);
-extern int implicit_str_to_num_ok (void);
-extern int ok_to_lose_imaginary_part (void);
-extern int page_output_immediately (void);
-extern int page_screen_output (void);
-extern int prefer_column_vectors (void);
-extern int prefer_zero_one_indexing (void);
 extern int print_answer_id_name (void);
-extern int print_empty_dimensions (void);
-extern int propagate_empty_matrices (void);
 extern int read_only_constants (void);
-extern int resize_on_range_error (void);
-extern int return_last_computed_value (void);
 extern int saving_history (void);
-extern int silent_functions (void);
-extern int split_long_rows (void);
-extern int struct_levels_to_print (void);
 extern int suppress_verbose_help_message (void);
 extern int treat_neg_dim_as_zero (void);
-extern int warn_assign_as_truth_value (void);
-extern int warn_comma_in_global_decl (void);
 extern int warn_divide_by_zero (void);
-extern int warn_function_name_clash (void);
-extern int warn_missing_semicolon (void);
-extern int whitespace_in_literal_matrix (void);
 
-extern int set_output_max_field_width (void);
-extern int set_output_precision (void);
 extern int set_save_precision (void);
 
-extern int sv_completion_append_char (void);
-
 extern int sv_default_save_format (void);
 extern int sv_editor (void);
 extern int sv_exec_path (void);
-extern int sv_gnuplot_binary (void);
 extern int sv_history_file (void);
 extern int sv_imagepath (void);
 extern int sv_info_file (void);
 extern int sv_info_prog (void);
 extern int sv_loadpath (void);
-extern int sv_pager_binary (void);
-extern int sv_ps1 (void);
-extern int sv_ps2 (void);
-extern int sv_ps4 (void);
 extern int sv_pwd (void);
 
 enum echo_state
 {
   ECHO_OFF = 0,
   ECHO_SCRIPTS = 1,
   ECHO_FUNCTIONS = 2,
   ECHO_CMD_LINE = 4
 };
 
+extern int check_preference (const string& var);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -58,17 +58,21 @@ Software Foundation, 59 Temple Place - S
 #include "toplev.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "sysdep.h"
 #include "pt-const.h"
 #include "oct-obj.h"
 #include "pt-exp.h"
+#include "pt-fcn.h"
 #include "pt-fvc.h"
+#include "pt-mat.h"
+#include "pt-plot.h"
+#include "pr-output.h"
 #include "syscalls.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 
 // Symbol table for symbols at the top level.
@@ -1593,25 +1597,16 @@ install_builtin_variables_1 (void)
 }
 
 static void
 install_builtin_variables_2 (void)
 {
   DEFCONSTX ("OCTAVE_VERSION", SBV_OCTAVE_VERSION, OCTAVE_VERSION, 0, 0,
     "Octave version");
 
-  DEFVAR (PS1, "\\s:\\#> ", 0, sv_ps1,
-    "primary prompt string");
-
-  DEFVAR (PS2, "> ", 0, sv_ps2,
-    "secondary prompt string");
-
-  DEFVAR (PS4, "+ ", 0, sv_ps4,
-    "string printed before echoed input (enabled by --echo-input)");
-
   DEFCONST (PWD, get_working_directory ("initialize_globals"), 0, sv_pwd,
     "current working directory");
 
   DEFCONST (SEEK_SET, 0.0, 0, 0,
     "used with fseek to position file relative to the beginning");
 
   DEFCONST (SEEK_CUR, 1.0, 0, 0,
     "used with fseek to position file relative to the current position");
@@ -1624,194 +1619,116 @@ install_builtin_variables_2 (void)
 }
 
 static void
 install_builtin_variables_3 (void)
 {
   DEFCONST (argv, , 0, 0,
     "the command line arguments this program was invoked with");
 
-  DEFVAR (automatic_replot, 0.0, 0, automatic_replot,
-    "if true, auto-insert a replot command when a plot changes");
-
-  DEFVAR (beep_on_error, 0.0, 0, beep_on_error,
-    "if true, beep before printing error messages");
-
-  DEFVAR (completion_append_char, " ", 0, sv_completion_append_char,
-    "the string to append after successful command-line completion\n\
-attempts");
-
   DEFCONST (error_text, "", 0, 0,
     "the text of error messages that would have been printed in the
 body of the most recent unwind_protect statement or the TRY part of\n\
 the most recent eval() command.  Outside of unwind_protect and\n\
 eval(), or if no error has ocurred within them, the value of\n\
 __error_text__ is guaranteed to be the empty string.");
 
-  DEFVAR (default_return_value, Matrix (), 0, 0,
-    "the default for value for unitialized variables returned from\n\
-functions.  Only used if the variable initialize_return_values is\n\
-set to \"true\".");
-
   DEFVAR (default_save_format, "ascii", 0, sv_default_save_format,
     "default format for files created with save, may be one of\n\
 \"binary\", \"text\", or \"mat-binary\"");
 
-  DEFVAR (define_all_return_values, 0.0, 0, define_all_return_values,
-    "control whether values returned from functions should have a\n\
-value even if one has not been explicitly assigned.  See also\n\
-default_return_value");
-
-  DEFVAR (do_fortran_indexing, 0.0, 0, do_fortran_indexing,
-    "allow single indices for matrices");
-
   DEFVAR (echo_executing_commands, 0.0, 0, echo_executing_commands,
     "echo commands as they are executed");
 }
 
 static void
 install_builtin_variables_4 (void)
 {
 #if defined (M_E)
   double e_val = M_E;
 #else
   double e_val = exp (1.0);
 #endif
 
   DEFCONST (e, e_val, 0, 0,
     "exp (1)");
 
-  DEFVAR (empty_list_elements_ok, "warn", 0, empty_list_elements_ok,
-    "ignore the empty element in expressions like `a = [[], 1]'");
-
   DEFCONST (eps, DBL_EPSILON, 0, 0,
     "machine precision");
 
-  DEFVAR (gnuplot_binary, "gnuplot", 0, sv_gnuplot_binary,
-    "path to gnuplot binary");
-
-#ifdef GNUPLOT_HAS_MULTIPLOT
-  double with_multiplot = 1.0;
-#else
-  double with_multiplot = 0.0;
-#endif
-
-  DEFVAR (gnuplot_has_multiplot, with_multiplot, 0, gnuplot_has_multiplot,
-    "true if gnuplot supports multiplot, false otherwise");
-
   DEFVAR (history_file, default_history_file (), 0, sv_history_file,
     "name of command history file");
 
   DEFVAR (history_size, default_history_size (), 0, history_size,
     "number of commands to save in the history list");
 
   DEFCONST (i, Complex (0.0, 1.0), 1, 0,
     "sqrt (-1)");
 
   DEFVAR (ignore_function_time_stamp, "system", 0, ignore_function_time_stamp,
     "don't check to see if function files have changed since they were\n\
   last compiled.  Possible values are \"system\" and \"all\"");
-
-  DEFVAR (implicit_str_to_num_ok, 0.0, 0, implicit_str_to_num_ok,
-    "allow implicit string to number conversion");
 }
 
 static void
 install_builtin_variables_5 (void)
 {
   DEFCONST (inf, octave_Inf, 0, 0,
     "infinity");
 
   DEFCONST (j, Complex (0.0, 1.0), 1, 0,
     "sqrt (-1)");
 
   DEFCONST (nan, octave_NaN, 0, 0,
     "not a number");
 
-  DEFVAR (ok_to_lose_imaginary_part, "warn", 0, ok_to_lose_imaginary_part,
-    "silently convert from complex to real by dropping imaginary part");
-
-  DEFVAR (output_max_field_width, 10.0, 0, set_output_max_field_width,
-    "maximum width of an output field for numeric output");
-
-  DEFVAR (output_precision, 5.0, 0, set_output_precision,
-    "number of significant figures to display for numeric output");
-
 #if defined (M_PI)
   double pi_val = M_PI;
 #else
   double pi_val = 4.0 * atan (1.0);
 #endif
 
   DEFCONST (pi, pi_val, 0, 0,
     "ratio of the circumference of a circle to its diameter");
-
-  DEFVAR (prefer_column_vectors, 1.0, 0, prefer_column_vectors,
-    "prefer column/row vectors");
-
-  DEFVAR (prefer_zero_one_indexing, 0.0, 0, prefer_zero_one_indexing,
-    "when there is a conflict, prefer zero-one style indexing");
 }
 
 static void
 install_builtin_variables_6 (void)
 {
   DEFVAR (print_answer_id_name, 1.0, 0, print_answer_id_name,
     "set output style to print `var_name = ...'");
 
-  DEFVAR (print_empty_dimensions, 1.0, 0, print_empty_dimensions,
-    "also print dimensions of empty matrices");
-
   DEFCONST (program_invocation_name, raw_prog_name, 0, 0,
     "the full name of the current program or script, including the\n\
 directory specification");
 
   DEFCONST (program_name, prog_name, 0, 0,
     "the name of the current program or script");
 
-  DEFVAR (propagate_empty_matrices, 1.0, 0, propagate_empty_matrices,
-    "operations on empty matrices return an empty matrix, not an error");
-
 #if 0
   DEFVAR (read_only_constants, 1.0, 0, read_only_constants,
     "allow built-in constants to be modified");
 #endif
 
   DEFCONST (realmax, DBL_MAX, 0, 0,
     "realmax (): return largest representable floating point number");
 
   DEFCONST (realmin, DBL_MIN, 0, 0,
     "realmin (): return smallest representable floating point number");
-
-  DEFVAR (resize_on_range_error, 1.0, 0, resize_on_range_error,
-    "enlarge matrices on assignment");
-
-  DEFVAR (return_last_computed_value, 0.0, 0, return_last_computed_value,
-    "if a function does not return any values explicitly, return the\n\
-  last computed value");
 }
 
 static void
 install_builtin_variables_7 (void)
 {
   DEFVAR (save_precision, 15.0, 0, set_save_precision,
     "number of significant figures kept by the ASCII save command");
 
   DEFVAR (saving_history, 1.0, 0, saving_history,
     "save command history");
 
-  DEFVAR (silent_functions, 0.0, 0, silent_functions,
-    "suppress printing results in called functions");
-
-  DEFVAR (split_long_rows, 1.0, 0, split_long_rows,
-    "split long matrix rows instead of wrapping");
-
-  DEFVAR (struct_levels_to_print, 2.0, 0, struct_levels_to_print,
-    "number of levels of structure elements to print");
-
 #ifdef USE_GNU_INFO
   DEFVAR (suppress_verbose_help_message, 0.0, 0, suppress_verbose_help_message,
     "suppress printing of message pointing to additional help in the\n\
 help and usage functions");
 #endif
 
   DEFCONSTX ("stdin", SBV_stdin, 0.0, 0, 0,
     "file number of the standard input stream");
@@ -1824,49 +1741,42 @@ help and usage functions");
 
   DEFVAR (treat_neg_dim_as_zero, 0.0, 0, treat_neg_dim_as_zero,
     "convert negative dimensions to zero");
 }
 
 static void
 install_builtin_variables_8 (void)
 {
-  DEFVAR (warn_assign_as_truth_value, 1.0, 0, warn_assign_as_truth_value,
-    "produce warning for assignments used as truth values");
-
-  DEFVAR (warn_comma_in_global_decl, 1.0, 0, warn_comma_in_global_decl,
-    "produce warning for commas in global declarations");
-
   DEFVAR (warn_divide_by_zero, 1.0, 0, warn_divide_by_zero,
     "on IEEE machines, allow divide by zero errors to be suppressed");
-
-  DEFVAR (warn_function_name_clash, 1.0, 0, warn_function_name_clash,
-    "produce warning if function name conflicts with file name");
-
-  DEFVAR (warn_missing_semicolon, 0.0, 0, warn_missing_semicolon,
-    "produce a warning if a statement in a function file is not
-terminated with a semicolon");
-
-  DEFVAR (whitespace_in_literal_matrix, "", 0, whitespace_in_literal_matrix,
-    "control auto-insertion of commas and semicolons in literal matrices");
 }
 
 void
 install_builtin_variables (void)
 {
   install_builtin_variables_1 ();
   install_builtin_variables_2 ();
   install_builtin_variables_3 ();
   install_builtin_variables_4 ();
   install_builtin_variables_5 ();
   install_builtin_variables_6 ();
   install_builtin_variables_7 ();
   install_builtin_variables_8 ();
 
+  symbols_of_error ();
+  symbols_of_input ();
+  symbols_of_lex ();
   symbols_of_pager ();
+  symbols_of_parse ();
+  symbols_of_pr_output ();
+  symbols_of_pt_const ();
+  symbols_of_pt_fcn ();
+  symbols_of_pt_mat ();
+  symbols_of_pt_plot ();
   symbols_of_syscalls ();
 }
 
 // Deleting names from the symbol tables.
 
 DEFUN_TEXT (clear, args, ,
   "clear [-x] [name ...]\n\
 \n\
