# HG changeset patch
# User jwe
# Date 1194488964 0
#      Thu Nov 08 02:29:24 2007 +0000
# Node ID f084ba47812bd86e90d490180c7d1f62073168c7
# Parent  d07cb867891b6313a292444eb69f3667287b9318
[project @ 2007-11-08 02:29:23 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,41 @@
+2007-11-07  Muthiah Annamalai  <muthuspost@gmail.com>
+
+	* control/base/bode_bounds.m, control/base/dgram.m,
+	control/base/dlyap.m, control/base/freqchkw.m,
+	control/base/gram.m, control/base/place.m,
+	control/hinf/hinf_ctr.m, control/hinf/hinfsyn_chk.m,
+	control/hinf/hinfsyn_ric.m, control/system/is_sample.m,
+	control/system/is_signal_list.m, control/system/ss2tf.m,
+	control/system/sys2fir.m, control/system/sysgettsam.m,
+	control/system/sysgettype.m, control/system/sysreorder.m,
+	control/system/tf2sys.m, control/system/zp2tf.m,
+	control/util/axis2dlim.m, control/util/swap.m,
+	control/util/zgfmul.m, control/util/zgfslv.m,
+	control/util/zginit.m, control/util/zgreduce.m,
+	control/util/zgrownorm.m, control/util/zgscal.m,
+	control/util/zgsgiv.m, control/util/zgshsr.m, general/isa.m,
+	geometry/inpolygon.m, linear-algebra/housh.m,
+	miscellaneous/compare_versions.m, miscellaneous/inputname.m,
+	miscellaneous/run.m, quaternion/qconj.m,
+	quaternion/qcoordinate_plot.m, quaternion/qderiv.m,
+	quaternion/qderivmat.m, quaternion/qinv.m, quaternion/qmult.m,
+	quaternion/qtrans.m, quaternion/qtransvmat.m, signal/fractdiff.m,
+	signal/freqz_plot.m, signal/periodogram.m, signal/rectangle_lw.m,
+	signal/rectangle_sw.m, signal/sinc.m, signal/triangle_lw.m,
+	signal/triangle_sw.m, signal/yulewalker.m, sparse/colperm.m,
+	sparse/etreeplot.m, sparse/nonzeros.m, sparse/spalloc.m,
+	sparse/spones.m, sparse/spy.m, specfun/isprime.m,
+	statistics/distributions/empirical_cdf.m,
+	statistics/distributions/empirical_inv.m,
+	statistics/distributions/empirical_pdf.m,
+	statistics/models/logistic_regression_derivatives.m,
+	statistics/models/logistic_regression_likelihood.m: Check nargin.
+
 2007-11-07  David Bateman  <dbateman@free.fr>
 
 	* general/gradient.m: Correctly convert deltax and deltay scalar
 	values are scalars to vectors.
 
 	* plot/__go_draw_axes__.m: Fix surfaces for gnuplot 4.0 and for
 	the meshc.m function.
 	* plot/meshc.m: Also use the surface function.
diff --git a/scripts/control/base/bode_bounds.m b/scripts/control/base/bode_bounds.m
--- a/scripts/control/base/bode_bounds.m
+++ b/scripts/control/base/bode_bounds.m
@@ -31,53 +31,74 @@
 ## [10^@var{wmin}, 10^@var{wmax}]
 ## @end ifinfo
 ##
 ## Used internally in @command{__freqresp__} (@command{bode}, @command{nyquist})
 ## @end deftypefn
 
 function [wmin, wmax] = bode_bounds (zer, pol, DIGITAL, tsam)
 
+  if (nargin != 4)
+    print_usage ();
+  endif
+
   ## make sure zer,pol are row vectors
-  if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
-  if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
+  if (! isempty (pol))
+    pol = reshape (pol, 1, length (pol));
+  endif
+  if (! isempty (zer))
+    zer = reshape (zer, 1, length (zer));
+  endif
 
   ## check for natural frequencies away from omega = 0
   if (DIGITAL)
     ## The 2nd conditions prevents log(0) in the next log command
-    iiz = find(abs(zer - 1) > norm(zer) * eps && abs(zer) > norm(zer) * eps);
-    iip = find(abs(pol - 1) > norm(pol) * eps && abs(pol) > norm(pol) * eps);
+    iiz = find (abs(zer-1) > norm(zer)*eps && abs(zer) > norm(zer)*eps);
+    iip = find (abs(pol-1) > norm(pol)*eps && abs(pol) > norm(pol)*eps);
 
     ## avoid dividing empty matrices, it would work but looks nasty
-    if (!isempty(iiz)) czer = log(zer(iiz))/tsam;
-    else               czer = [];                 endif
+    if (! isempty (iiz))
+      czer = log (zer(iiz))/tsam;
+    else
+      czer = [];
+    endif
 
-    if (!isempty(iip)) cpol = log(pol(iip))/tsam;
-    else               cpol = [];                 endif
-
+    if (! isempty (iip))
+      cpol = log (pol(iip))/tsam;
+    else
+      cpol = [];
+    endif
   else
     ## continuous
-    iip = find((abs(pol)) > (norm(pol) * eps));
-    iiz = find((abs(zer)) > (norm(zer) * eps));
+    iip = find (abs(pol) > norm(pol)*eps));
+    iiz = find (abs(zer) > norm(zer)*eps));
 
-    if(!isempty(zer)) czer = zer(iiz);
-    else              czer = [];                endif
-    if(!isempty(pol)) cpol = pol(iip);
-    else              cpol = [];                endif
+    if (! isempty (zer))
+      czer = zer(iiz);
+    else
+      czer = [];
+    endif
+    if (! isempty (pol))
+      cpol = pol(iip);
+    else
+      cpol = [];
+    endif
   endif
   
   if (isempty (iip) && isempty (iiz))
     ## no poles/zeros away from omega = 0; pick defaults
     wmin = -1;
     wmax = 3;
   else
-    wmin = floor(log10(min(abs([cpol,czer]))));
-    wmax = ceil(log10(max(abs([cpol,czer]))));
+    wmin = floor (log10 (min (abs ([cpol, czer]))));
+    wmax = ceil (log10 (max (abs ([cpol, czer]))));
   endif
 
   ## expand to show the entirety of the "interesting" portion of the plot
   wmin--;
   wmax++;
 
   ## run digital frequency all the way to pi
-  if (DIGITAL) wmax = log10(pi/tsam); endif
+  if (DIGITAL)
+    wmax = log10 (pi/tsam);
+  endif
 
 endfunction
diff --git a/scripts/control/base/dgram.m b/scripts/control/base/dgram.m
--- a/scripts/control/base/dgram.m
+++ b/scripts/control/base/dgram.m
@@ -56,13 +56,17 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function m = dgram (a, b)
 
+  if (nargin != 2)
+    print_usage();
+  endif
+
   ## let dlyap do the error checking...
 
   m = dlyap (a, b*b');
 
 endfunction
diff --git a/scripts/control/base/dlyap.m b/scripts/control/base/dlyap.m
--- a/scripts/control/base/dlyap.m
+++ b/scripts/control/base/dlyap.m
@@ -85,16 +85,20 @@
 ## 2, pages 303--323 (1982).
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = dlyap (a, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   if ((n = issquare (a)) == 0)
     warning ("dlyap: a must be square");
   endif
 
   if ((m = issquare (b)) == 0)
     [n1, m] = size (b);
     if (n1 == n)
       b = b*b';
@@ -124,29 +128,29 @@ function x = dlyap (a, b)
       blksiz = 1;
     elseif (s (j, j-1) != 0)
       blksiz = 2;
       j = j - 1;
     else
       blksiz = 1;
     endif
 
-    Ajj = kron (s (j:j1, j:j1), s) - eye (blksiz*n);
+    Ajj = kron (s(j:j1,j:j1), s) - eye (blksiz*n);
 
-    rhs = reshape (b (:, j:j1), blksiz*n, 1);
+    rhs = reshape (b (:,j:j1), blksiz*n, 1);
 
     if (j1 < n)
-      rhs2 = s*(x (:, (j1+1):n) * s (j:j1, (j1+1):n)');
+      rhs2 = s*(x(:,(j1+1):n) * s(j:j1,(j1+1):n)');
       rhs = rhs + reshape (rhs2, blksiz*n, 1);
     endif
 
     v = - Ajj\rhs;
-    x (:, j) = v (1:n);
+    x(:,j) = v (1:n);
 
-    if(blksiz == 2)
+    if (blksiz == 2)
       x (:, j1) = v ((n+1):blksiz*n);
     endif
 
     j = j - 1;
 
   endwhile
 
   ## Back-transform to original coordinates.
diff --git a/scripts/control/base/freqchkw.m b/scripts/control/base/freqchkw.m
--- a/scripts/control/base/freqchkw.m
+++ b/scripts/control/base/freqchkw.m
@@ -24,16 +24,20 @@
 ## Returns boolean value.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function USEW = freqchkw (w)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (isempty (w))
     USEW = 0;
   elseif (! isvector (w))
     error ("w (%dx%d): must be [], a vector or a scalar",
 	   rows (w), columns (w));
   elseif (max (abs (imag(w))) != 0 && min (real (w)) <= 0)
     error ("w must have real positive entries");
   else
diff --git a/scripts/control/base/gram.m b/scripts/control/base/gram.m
--- a/scripts/control/base/gram.m
+++ b/scripts/control/base/gram.m
@@ -24,13 +24,17 @@
 ##
 ## @var{m} satisfies @math{a m + m a' + b b' = 0}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function m = gram (a, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   ## Let lyap do the error checking...
 
   m = lyap (a, b*b');
 
 endfunction
diff --git a/scripts/control/base/place.m b/scripts/control/base/place.m
--- a/scripts/control/base/place.m
+++ b/scripts/control/base/place.m
@@ -40,84 +40,87 @@
 ##
 ## Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
 ##
 ## code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
 ## toolbox
 
 function K = place (sys, P)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   ## check arguments
 
-  if(!isstruct(sys))
-    error("sys must be in system data structure format (see ss)");
+  if(! isstruct (sys))
+    error ("sys must be in system data structure format (see ss)");
   endif
-  sys = sysupdate(sys,"ss");    # make sure it has state space form up to date
-  if(!is_controllable(sys))
-    error("sys is not controllable.");
-  elseif( min(size(P)) != 1)
-    error("P must be a vector")
+  sys = sysupdate (sys, "ss");    # make sure it has state space form up to date
+  if (! is_controllable (sys))
+    error ("sys is not controllable");
+  elseif (min (size (P)) != 1)
+    error ("P must be a vector")
   else
-    P = reshape(P,length(P),1); # make P a column vector
+    P = P(:); # make P a column vector
   endif
   ## system must be purely continuous or discrete
-  is_digital(sys);
-  [n,nz,m,p] = sysdimensions(sys);
+  is_digital (sys);
+  [n, nz, m, p] = sysdimensions (sys);
   nx = n+nz;    # already checked that it's not a mixed system.
   if(m != 1)
-    error(["sys has ", num2str(m)," inputs; need only 1"]);
+    error ("sys has %d inputs; need only 1", m);
   endif
 
   ## takes the A and B matrix from the system representation
-  [A,B]=sys2ss(sys);
-  sp = length(P);
-  if(nx == 0)
-    error("place: A matrix is empty (0x0)");
-  elseif(nx != length(P))
-    error(["A=(",num2str(nx),"x",num2str(nx),", P has ", num2str(length(P)), ...
-	"entries."])
+  [A, B] = sys2ss (sys);
+  sp = length (P);
+  if (nx == 0)
+    error ("place: A matrix is empty (0x0)");
+  elseif (nx != length (P))
+    error ("A=(%dx%d), P has %d entries", nx, nx, length (P))
   endif
 
   ## arguments appear to be compatible; let's give it a try!
   ## The second step is the calculation of the characteristic polynomial ofA
-  PC=poly(A);
+  PC = poly (A);
 
   ## Third step: Calculate the transformation matrix T that transforms the state
   ## equation in the controllable canonical form.
 
   ## first we must calculate the controllability matrix M:
-  M=B;
-  AA=A;
+  M = B;
+  AA = A;
   for n = 2:nx
-    M(:,n)=AA*B;
-    AA=AA*A;
+    M(:,n) = AA*B;
+    AA = AA*A;
   endfor
 
   ## second, construct the matrix W
-  PCO=PC(nx:-1:1);
-  PC1=PCO;      # Matrix to shift and create W row by row
+  PCO = PC(nx:-1:1);
+  PC1 = PCO;      # Matrix to shift and create W row by row
 
   for n = 1:nx
     W(n,:) = PC1;
-    PC1=[PCO(n+1:nx),zeros(1,n)];
+    PC1 = [PCO(n+1:nx), zeros(1,n)];
   endfor
 
-  T=M*W;
+  T = M*W;
 
   ## finaly the matrix K is calculated
-  PD = poly(P); # The desired characteristic polynomial
+  PD = poly (P); # The desired characteristic polynomial
   PD = PD(nx+1:-1:2);
   PC = PC(nx+1:-1:2);
 
   K = (PD-PC)/T;
 
   ## Check if the eigenvalues of (A-BK) are the same specified in P
-  Pcalc = eig(A-B*K);
+  Pcalc = eig (A-B*K);
 
-  Pcalc = sortcom(Pcalc);
-  P = sortcom(P);
+  Pcalc = sortcom (Pcalc);
+  P = sortcom (P);
 
-  if(max( (abs(Pcalc)-abs(P))./abs(P) ) > 0.1)
-    disp("Place: Pole placed at more than 10% relative error from specified");
+  if (max ((abs(Pcalc)-abs(P))./abs(P) ) > 0.1)
+    warning ("place: Pole placed at more than 10% relative error from specified");
   endif
 
 endfunction
 
diff --git a/scripts/control/hinf/hinf_ctr.m b/scripts/control/hinf/hinf_ctr.m
--- a/scripts/control/hinf/hinf_ctr.m
+++ b/scripts/control/hinf/hinf_ctr.m
@@ -52,16 +52,20 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
 ## and non-singular transformations R (on u and y).
 
 function K = hinf_ctr (dgs, F, H, Z, g)
 
+  if (nargin != 5)
+    print_usage ();
+  endif
+
   nw = dgs.nw;
   nu = dgs.nu;
   nz = dgs.nz;
   ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
 
   B1  = dgs.Bw;
   B2  = dgs.Bu;
@@ -73,59 +77,59 @@ function K = hinf_ctr (dgs, F, H, Z, g)
   D21 = dgs.Dyw;
   D22 = dgs.Dyu;
   A = dgs.A;
   Ru = dgs.Ru;
   Ry = dgs.Ry;
 
   nout = nz + ny;
   nin = nw + nu;
-  nstates = size(A, 1);
+  nstates = size (A, 1);
 
   F11 = F(1:(nw-ny),:);
   F12 = F((nw-ny+1):nw,:);
   F2  = F((nw+1):nin,:);
   H11 = H(:,1:(nz-nu));
   H12 = H(:,(nz-nu+1):nz);
   H2  = H(:,(nz+1):nout);
 
   ## D11 partitions
   D1111 = D11(1:(nz-nu),1:(nw-ny));
   D1112 = D11(1:(nz-nu),(nw-ny+1):nw);
   D1121 = D11((nz-nu+1):nz,1:(nw-ny));
   D1122 = D11((nz-nu+1):nz,(nw-ny+1):nw);
 
   ## D11ik may be the empty matrix, don't calculate with empty matrices
-  [nd1111,md1111] = size(D1111);
-  md1112 = length(D1112);
-  md1121 = length(D1121);
+  [nd1111, md1111] = size (D1111);
+  md1112 = length (D1112);
+  md1121 = length (D1121);
 
-  if ((nd1111 == 0) || (md1112 == 0))
+  if (nd1111 == 0) || md1112 == 0)
     d11hat = -D1122;
   else
-    xx = inv(g*g*eye(nz-nu) - D1111*D1111');
+    xx = inv (g*g*eye(nz-nu) - D1111*D1111');
     d11hat = -D1121*D1111'*xx*D1112 - D1122;
   endif
   if (md1112 == 0)
-    d21hat = eye(ny);
+    d21hat = eye (ny);
   elseif (nd1111 == 0)
-    d21hat = chol(eye(ny) - D1112'*D1112/g/g);
+    d21hat = chol (eye(ny) - D1112'*D1112/g/g);
   else
-    xx = inv(g*g*eye(nz-nu) - D1111*D1111');
-    xx = eye(ny) - D1112'*xx*D1112;
-    d21hat = chol(xx);
+    xx = inv (g*g*eye(nz-nu) - D1111*D1111');
+    xx = eye (ny) - D1112'*xx*D1112;
+    d21hat = chol (xx);
   endif
   if (md1121 == 0)
-    d12hat = eye(nu);
+    d12hat = eye (nu);
   elseif (md1111 == 0)
-    d12hat = chol(eye(nu) - D1121*D1121'/g/g)';
+    d12hat = chol (eye(nu) - D1121*D1121'/g/g)';
   else
-    xx = inv(g*g*eye(nw-ny) - D1111'*D1111);
-    xx = eye(nu)-D1121*xx*D1121';
-    d12hat = chol(xx)';
+    xx = inv (g*g*eye(nw-ny) - D1111'*D1111);
+    xx = eye (nu)-D1121*xx*D1121';
+    d12hat = chol (xx)';
   endif
 
   b2hat = (B2+H12)*d12hat;
   c2hat = -d21hat*(C2+F12)*Z;
   b1hat = -H2 + (b2hat/d12hat)*d11hat;
   c1hat =  F2*Z + (d11hat/d21hat)*c2hat;
   ahat  =  A + H*C + (b2hat/d12hat)*c1hat;
 
@@ -133,25 +137,25 @@ function K = hinf_ctr (dgs, F, H, Z, g)
   b1hat = b1hat/Ry;
   c1hat = Ru\c1hat;
   bhat  = [b1hat, b2hat];
   chat  = [c1hat; c2hat];
   dhat  = [Ru\d11hat/Ry, Ru\d12hat; d21hat/Ry, 0*d11hat'];
 
   ## non-zero D22 is a special case
   if (d22nz)
-    if (rank(eye(nu) + d11hat*D22) < nu)
+    if (rank (eye(nu) + d11hat*D22) < nu)
       error(" *** cannot compute controller for D22 non-zero.");
     endif
 
     d22new = [D22, zeros(ny,ny); zeros(nu,nu), 0*D22'];
-    xx = inv(eye(nu+ny) + d22new*dhat);
-    mhat = inv(eye(nu+ny) + dhat*d22new);
+    xx = inv (eye(nu+ny) + d22new*dhat);
+    mhat = inv (eye(nu+ny) + dhat*d22new);
     ahat = ahat - bhat*((eye(nu+ny)-xx)/dhat)*chat;
     bhat = bhat*xx;
     chat = mhat*chat;
     dhat = dhat*xx;
 
   endif
 
-  K = ss(ahat,bhat(:,1:ny),chat(1:nu,:),dhat(1:nu,1:ny));
+  K = ss (ahat, bhat(:,1:ny), chat(1:nu,:), dhat(1:nu,1:ny));
 
 endfunction
diff --git a/scripts/control/hinf/hinfsyn_chk.m b/scripts/control/hinf/hinfsyn_chk.m
--- a/scripts/control/hinf/hinfsyn_chk.m
+++ b/scripts/control/hinf/hinfsyn_chk.m
@@ -75,57 +75,61 @@
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 
 function [retval, Pc, Pf] = hinfsyn_chk (A, B1, B2, C1, C2, D12, D21, g, ptol)
 
+  if (nargin != 9)
+    print_usage ();
+  endif
+
   Pc = Pf = [];
 
   ## Construct the two Hamiltonians
   g2 = 1/(g*g);
   Hc = [ A ,  g2*B1*B1' - B2*B2'; -C1'*C1 , -A'];
   Hf = [ A' , g2*C1'*C1 - C2'*C2; -B1*B1' , -A];
 
   ## check if Hc, Hf are in dom(Ric)
-  Hcminval = min(abs(real(eig(Hc))));
-  Hfminval = min(abs(real(eig(Hf))));
-  if(Hcminval < ptol);
-    disp("hinfsyn_chk: Hc is not in dom(Ric)");
+  Hcminval = min (abs (real (eig (Hc))));
+  Hfminval = min (abs (real (eig (Hf))));
+  if (Hcminval < ptol);
+    warning ("hinfsyn_chk: Hc is not in dom(Ric)");
     retval = 0;
     return
   endif
   if(Hfminval < ptol)
-    disp("hinfsyn_chk: Hf is not in dom(Ric)");
+    warning ("hinfsyn_chk: Hf is not in dom(Ric)");
     retval = 0;
     return
   endif
 
   ## Solve ARE's
-  Pc = are(A, B2*B2'-g2*B1*B1',C1'*C1);
-  Pf = are(A',C2'*C2-g2*C1'*C1,B1*B1');
+  Pc = are (A, B2*B2'-g2*B1*B1', C1'*C1);
+  Pf = are (A', C2'*C2-g2*C1'*C1, B1*B1');
 
-  Pceig = eig(Pc);
-  Pfeig = eig(Pf);
-  Pcfeig = eig(Pc*Pf);
+  Pceig = eig (Pc);
+  Pfeig = eig (Pf);
+  Pcfeig = eig (Pc*Pf);
 
-  if(min(Pceig) < -ptol)
-    disp("hinfsyn_chk: Pc is not >= 0");
+  if (min (Pceig) < -ptol)
+    warning ("hinfsyn_chk: Pc is not >= 0");
     retval = 0;
     return
   endif
-  if(min(Pfeig) < -ptol)
-    disp("hinfsyn_chk: Pf is not >= 0");
+  if (min (Pfeig) < -ptol)
+    warning ("hinfsyn_chk: Pf is not >= 0");
     retval = 0;
     return
   endif
-  if(max(abs(Pcfeig)) >= g*g)
-    disp("hinfsyn_chk: rho(Pf*Pc) is not < g^2");
+  if (max (abs (Pcfeig)) >= g*g)
+    warning ("hinfsyn_chk: rho(Pf*Pc) is not < g^2");
     retval = 0;
     return
   endif
 
   ## all conditions met.
   retval = 1;
 
 endfunction
diff --git a/scripts/control/hinf/hinfsyn_ric.m b/scripts/control/hinf/hinfsyn_ric.m
--- a/scripts/control/hinf/hinfsyn_ric.m
+++ b/scripts/control/hinf/hinfsyn_ric.m
@@ -42,47 +42,52 @@
 ## @var{xinf} not positive definite
 ## @item 6
 ## @var{r} is singular
 ## @end table
 ## @end deftypefn
 
 function [Xinf, x_ha_err] = hinfsyn_ric (A, BB, C1, d1dot, R, ptol)
 
+  if (nargin != 6)
+    print_usage ();
+  endif
+
   x_ha_err = 0;        # assume success
   Xinf = [];                 # default return value
-  n = issquare(A);
-  nw = issquare(R);
-  if(rank(R) != nw)    x_ha_err = 6;
+  n = issquare (A);
+  nw = issquare (R);
+  if (rank (R) != nw)
+    x_ha_err = 6;
   else                 # build hamiltonian Ha for X_inf
     xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
     Ha = [A, 0*A; -C1'*C1, -A'] - xx;
     x_ha_err = 0;
-    [d, Ha] = balance(Ha);
-    [u, s] = schur(Ha, "A");
-    rev = real(eig(s));
+    [d, Ha] = balance (Ha);
+    [u, s] = schur (Ha, "A");
+    rev = real (eig (s));
 
-    if (any(abs(rev) <= ptol))  # eigenvalues near the imaginary axis
+    if (any (abs (rev) <= ptol))  # eigenvalues near the imaginary axis
       x_ha_err = 1;
-    elseif (sum(rev > 0) != sum(rev < 0))
+    elseif (sum (rev > 0) != sum (rev < 0))
       ## unequal number of positive and negative eigenvalues
       x_ha_err = 2;
     else
       ## compute positive Riccati equation solution
       u = d * u;
       Xinf = u(n+1:2*n,1:n) / u(1:n,1:n);
-      if (!all(all(finite(Xinf))))
+      if (! all (all (finite (Xinf))))
         x_ha_err = 3;
-      elseif (norm(Xinf-Xinf') >= 10*ptol)
+      elseif (norm (Xinf-Xinf') >= 10*ptol)
         ## solution not symmetric
         x_ha_err = 4;
       else
         ## positive semidefinite?
         ## force symmetry (faster, avoids some convergence problems)
         Xinf = (Xinf + Xinf')/2;
-        rev = eig(Xinf);
-        if (any(rev <= -ptol))
+        rev = eig (Xinf);
+        if (any (rev <= -ptol))
           x_ha_err = 5;
         endif
       endif
     endif
   endif
 endfunction
diff --git a/scripts/control/system/is_sample.m b/scripts/control/system/is_sample.m
--- a/scripts/control/system/is_sample.m
+++ b/scripts/control/system/is_sample.m
@@ -23,11 +23,15 @@
 ## (real, scalar, > 0).
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function out = is_sample (Ts)
 
+  if (nargin != 1)
+    print_usage (); 
+  endif
+
   out = (isscalar (Ts) && (Ts == abs (Ts)) && (Ts != 0));
 
 endfunction
diff --git a/scripts/control/system/is_signal_list.m b/scripts/control/system/is_signal_list.m
--- a/scripts/control/system/is_signal_list.m
+++ b/scripts/control/system/is_signal_list.m
@@ -19,19 +19,23 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_signal_list (@var{mylist})
 ## Return true if @var{mylist} is a list of individual strings.
 ## @end deftypefn
 
 function flg = is_signal_list (mylist)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   flg = iscell (mylist);
-  if(flg)
-    flg = (rows(mylist) == 1 | columns(mylist) == 1);
+  if (flg)
+    flg = (rows (mylist) == 1 || columns (mylist) == 1);
   end
   if (flg)
     for ii = 1:length (mylist)
       if (! (ischar (mylist{ii}) && rows (mylist{ii}) == 1))
 	flg = 0;
       endif
     endfor
   endif
diff --git a/scripts/control/system/ss2tf.m b/scripts/control/system/ss2tf.m
--- a/scripts/control/system/ss2tf.m
+++ b/scripts/control/system/ss2tf.m
@@ -54,44 +54,48 @@
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 24, 1994
 ## a s hodel: modified to allow for pure gain blocks Aug 1996
 
 function [num, den] = ss2tf (a, b, c, d)
 
+  if (nargin != 4)
+    print_usage ();
+  endif
+
   ## Check args
-  [n,m,p] = abcddim(a,b,c,d);
+  [n, m, p] = abcddim (a, b, c, d);
   if (n == -1)
     num = [];
     den = [];
     error("ss2tf: Non compatible matrix arguments");
-  elseif ( (m != 1) | (p != 1))
+  elseif (m != 1 || p != 1)
     num = [];
     den = [];
-    error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
+    error ("ss2tf: not SISO system: m=%d, p=%d", m, p);
   endif
 
   if(n == 0)
     ## gain block only
     num = d;
     den = 1;
   else
     ## First, get the denominator coefficients
-    den = poly(a);
+    den = poly (a);
 
     ## Get the zeros of the system
-    [zz,g] = tzero(a,b,c,d);
+    [zz, g] = tzero (a, b, c, d);
 
     ## Form the Numerator (and include the gain)
-    if (!isempty(zz))
-      num = g * poly(zz);
+    if (! isempty (zz))
+      num = g * poly (zz);
     else
       num = g;
     endif
 
     ## the coefficients must be real
-    den = real(den);
-    num = real(num);
+    den = real (den);
+    num = real (num);
   endif
+
 endfunction
-
diff --git a/scripts/control/system/sys2fir.m b/scripts/control/system/sys2fir.m
--- a/scripts/control/system/sys2fir.m
+++ b/scripts/control/system/sys2fir.m
@@ -25,16 +25,20 @@
 ## @seealso{fir2sys}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function [c, tsam, inname, outname] = sys2fir (sys)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   ## let sys2tf do most of the work
 
   [num, den, tsam, inname, outname] = sys2tf (sys);
 
   alph = den(1);                        # scale to get monic denominator
   den /= alph;
   num /= alph;
   l = length (den);
diff --git a/scripts/control/system/sysgettsam.m b/scripts/control/system/sysgettsam.m
--- a/scripts/control/system/sysgettsam.m
+++ b/scripts/control/system/sysgettsam.m
@@ -19,15 +19,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sysgettsam (@var{sys})
 ## Return the sampling time of the system @var{sys}.
 ## @end deftypefn
 
 function T = sysgettsam (sys)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (! isstruct (sys))
-    print_usage ();
+    error ("sysgettsam: expecting argument to be system structure");
   endif
 
   T = sys.tsam;
 
 endfunction
diff --git a/scripts/control/system/sysgettype.m b/scripts/control/system/sysgettype.m
--- a/scripts/control/system/sysgettype.m
+++ b/scripts/control/system/sysgettype.m
@@ -34,16 +34,20 @@
 ## constructed. Values: @code{"ss"}, @code{"zp"}, or @code{"tf"}.
 ## @end table
 ##
 ## @acronym{FIR} initialized systems return @code{systype="tf"}.
 ## @end deftypefn
 
 function systype = sysgettype (sys)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (! isstruct (sys))
     error ("sysgettype: input sys is not a structure");
   endif
 
   typestr = {"tf", "zp", "ss"};
-  systype = typestr{ sys.sys(1) + 1};
+  systype = typestr{sys.sys(1) + 1};
 
 endfunction
diff --git a/scripts/control/system/sysreorder.m b/scripts/control/system/sysreorder.m
--- a/scripts/control/system/sysreorder.m
+++ b/scripts/control/system/sysreorder.m
@@ -39,16 +39,20 @@
 ## desired locations.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 
 function pv = sysreorder (vlen, list)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   ## disp('sysreorder: entry')
 
   pv = 1:vlen;
   ## make it a row vector
   list = reshape(list,1,length(list));
   A = pv'*ones(size(list));
   B = ones(size(pv'))*list;
   X = (A != B);
diff --git a/scripts/control/system/tf2sys.m b/scripts/control/system/tf2sys.m
--- a/scripts/control/system/tf2sys.m
+++ b/scripts/control/system/tf2sys.m
@@ -58,13 +58,13 @@
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 ## name changed to tf Feb 2004
 
 function outsys = tf2sys (varargin)
-  
+
   warning("tf2sys is deprecated.  Use tf() instead.");
   outsys = tf(varargin{:});
 
 endfunction
diff --git a/scripts/control/system/zp2tf.m b/scripts/control/system/zp2tf.m
--- a/scripts/control/system/zp2tf.m
+++ b/scripts/control/system/zp2tf.m
@@ -32,44 +32,54 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## (With help from students Ingram, McGowan.)
 
 function [num, den] = zp2tf (zer, pol, k)
 
+  if (nargin != 3)
+    print_usage ();
+  endif  
+
   ## Find out whether data was entered as a row or a column vector and
   ## convert to a column vector if necessary.
 
-  [rp,cp] = size(pol);
-  [rz,cz] = size(zer);
+  [rp, cp] = size (pol);
+  [rz, cz] = size (zer);
 
-  if(!(isvector(zer) | isempty(zer)) )
-    error(sprintf("zer(%dx%d) must be a vector",rz,cz));
-  elseif(!(isvector(pol) | isempty(pol)) )
-    error(sprintf("pol(%dx%d) must be a vector",rp,cp));
-  elseif(length(zer) > length(pol))
-    error(sprintf("zer(%dx%d) longer than pol(%dx%d)",rz,cz,rp,cp));
+  if (! (isvector (zer) || isempty (zer)))
+    error ("zer(%dx%d) must be a vector", rz, cz);
+  elseif(! (isvector (pol) || isempty (pol)))
+    error ("pol(%dx%d) must be a vector", rp, cp);
+  elseif (length (zer) > length (pol))
+    error ("zer(%dx%d) longer than pol(%dx%d)", rz, cz, rp, cp);
   endif
 
   ## initialize converted polynomials
 
   num = k;  den = 1;
 
   ## call __zp2ssg2__ if there are complex conjugate pairs left, otherwise
   ## construct real zeros one by one.  Repeat for poles.
 
-  while(!isempty(zer))
-    if( max(abs(imag(zer))) )     [poly, zer] = __zp2ssg2__ (zer);
-    else                          poly = [1, -zer(1)];
-                                  zer = zer(2:length(zer));      endif
-    num = conv(num,poly);
+  while(! isempty (zer))
+    if (max (abs (imag (zer))))
+      [poly, zer] = __zp2ssg2__ (zer);
+    else
+      poly = [1, -zer(1)];
+      zer = zer(2:length(zer));
+    endif
+    num = conv (num, poly);
   endwhile
 
-  while(!isempty(pol))
-    if( max(abs(imag(pol))) )     [poly, pol] = __zp2ssg2__ (pol);
-    else                          poly = [1, -pol(1)];
-                                  pol = pol(2:length(pol));      endif
-    den = conv(den,poly);
+  while (! isempty (pol))
+    if (max (abs (imag (pol))))
+      [poly, pol] = __zp2ssg2__ (pol);
+    else
+      poly = [1, -pol(1)];
+      pol = pol(2:length(pol));
+    endif
+    den = conv (den, poly);
   endwhile
 
 endfunction
diff --git a/scripts/control/util/axis2dlim.m b/scripts/control/util/axis2dlim.m
--- a/scripts/control/util/axis2dlim.m
+++ b/scripts/control/util/axis2dlim.m
@@ -34,23 +34,23 @@
 ## @table @var
 ## @item axvec
 ## Vector of axis limits appropriate for call to @command{axis} function.
 ## @end table
 ## @end deftypefn
 
 function axvec = axis2dlim (axdata)
 
-  if(isempty(axdata))
+  if (nargin < 1 || isempty (axdata))
     axdata = 0;
   endif
 
   ## compute axis limits
-  minv = min(axdata);
-  maxv = max(axdata);
+  minv = min (axdata);
+  maxv = max (axdata);
   delv = (maxv-minv)/2;      # breadth of the plot
   midv = (minv + maxv)/2;    # midpoint of the plot
   axmid = [midv(1), midv(1), midv(2), midv(2)];
   axdel = [-0.1, 0.1,-0.1,0.1];   # default plot width (if less than 2-d data)
   if(max(delv) == 0)
     if(midv(1) != 0)
       axdel(1:2) = [-0.1*midv(1),0.1*midv(1)];
     endif
diff --git a/scripts/control/util/swap.m b/scripts/control/util/swap.m
--- a/scripts/control/util/swap.m
+++ b/scripts/control/util/swap.m
@@ -26,13 +26,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
 function [a1, b1] = swap (a, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   a1 = b;
   b1 = a;
 
 endfunction
 
diff --git a/scripts/control/util/zgfmul.m b/scripts/control/util/zgfmul.m
--- a/scripts/control/util/zgfmul.m
+++ b/scripts/control/util/zgfmul.m
@@ -28,16 +28,20 @@
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Conversion to Octave July 3, 1994
 
 function y = zgfmul (a, b, c, d, x)
 
+  if (nargin != 5)
+    print_usage ();
+  endif 
+
   [n,m] = size(b);
   [p,m1] = size(c);
   nm = n+m;
   y = zeros(nm+p,1);
 
   ## construct F column by column
   for jj=1:n
     Fj = zeros(nm+p,1);
diff --git a/scripts/control/util/zgfslv.m b/scripts/control/util/zgfslv.m
--- a/scripts/control/util/zgfslv.m
+++ b/scripts/control/util/zgfslv.m
@@ -22,16 +22,20 @@
 ## Solve system of equations for dense zgep problem.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Converted to Octave by R Bruce Tenison, July 3, 1994
 
 function x = zgfslv (n, m, p, b)
 
+  if (nargin != 4)
+    print_usage ();
+  endif
+
   nmp = n+m+p;
   gam1 = (2*n)+m+p;    gam2 = n+p;     gam3 = n+m;
 
   G1 = givens(sqrt(m),-sqrt(p))';
   G2 = givens(m+p,sqrt(n*(m+p)))';
 
   x = b;
 
diff --git a/scripts/control/util/zginit.m b/scripts/control/util/zginit.m
--- a/scripts/control/util/zginit.m
+++ b/scripts/control/util/zginit.m
@@ -29,16 +29,20 @@
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison, July 3, 1994
 
 function zz = zginit (a, b, c, d)
 
+  if (nargin != 4)
+    print_usage ();
+  endif
+
   [nn,mm] = size(b);
   [pp,mm] = size(d);
 
   nmp = nn+mm+pp;
 
   ## set up log vector zz
   zz = zeros(nmp,1);
 
diff --git a/scripts/control/util/zgreduce.m b/scripts/control/util/zgreduce.m
--- a/scripts/control/util/zgreduce.m
+++ b/scripts/control/util/zgreduce.m
@@ -20,16 +20,20 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} zgreduce (@var{sys}, @var{meps})
 ## Implementation of procedure REDUCE in (Emami-Naeini and Van Dooren,
 ## Automatica, # 1982).
 ## @end deftypefn
 
 function retsys = zgreduce (Asys, meps)
 
+  if (nargin != 2)
+    print_usage ();
+  endif  
+
   ## SYS_INTERNAL accesses members of system data structure
 
   is_digital(Asys);             # make sure it's pure digital/continuous
 
   exit_1 = 0;                   # exit_1 = 1 or 2 on exit of loop
 
   if(Asys.n + Asys.nz == 0)
     exit_1 = 2;                 # there are no finite zeros
diff --git a/scripts/control/util/zgrownorm.m b/scripts/control/util/zgrownorm.m
--- a/scripts/control/util/zgrownorm.m
+++ b/scripts/control/util/zgrownorm.m
@@ -21,16 +21,20 @@
 ## @deftypefn {Function File} {[@var{nonz}, @var{zer}] =} zgrownorm (@var{mat}, @var{meps})
 ## Return @var{nonz} = number of rows of @var{mat} whose two norm
 ## exceeds @var{meps}, and @var{zer} = number of rows of mat whose two
 ## norm is less than @var{meps}.
 ## @end deftypefn
 
 function [sig, tau] = zgrownorm (mat, meps)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   rownorm = [];
   for ii = 1:rows (mat)
     rownorm(ii) = norm (mat(ii,:));
   endfor
   sig = sum (rownorm > meps);
   tau = sum (rownorm <= meps);
 
 endfunction
diff --git a/scripts/control/util/zgscal.m b/scripts/control/util/zgscal.m
--- a/scripts/control/util/zgscal.m
+++ b/scripts/control/util/zgscal.m
@@ -29,16 +29,20 @@
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave R. Bruce Tenison July 3, 1994
 
 function x = zgscal (a, b, c, d, z, n, m, p)
 
+  if (nargin != 8)
+    print_usage ();
+  endif
+
   ## initialize parameters:
   ## Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
 
   nmp = n+m+p;
 
   ## x_0 = x_{-1} = 0, r_0 = z
   x = zeros(nmp,1);
   xk1 = x;
diff --git a/scripts/control/util/zgsgiv.m b/scripts/control/util/zgsgiv.m
--- a/scripts/control/util/zgsgiv.m
+++ b/scripts/control/util/zgsgiv.m
@@ -25,14 +25,18 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 29, 1992
 ## Convertion to Octave by R. Bruce Tenison July 3, 1994
 
 function [a, b] = zgsgiv (c, s, a, b)
 
+  if (nargin != 4)
+    print_usage ();
+  endif
+
   t1 = c*a + s*b;
   t2 = -s*a + c*b;
   a = t1;
   b = t2;
 
 endfunction
diff --git a/scripts/control/util/zgshsr.m b/scripts/control/util/zgshsr.m
--- a/scripts/control/util/zgshsr.m
+++ b/scripts/control/util/zgshsr.m
@@ -33,18 +33,22 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
 function x = zgshsr (y)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (! isvector (y))
-    error (sprintf ("y(%dx%d) must be a vector", rows (y), columns (y)));
+    error ("y(%dx%d) must be a vector", rows (y), columns (y));
   endif
   x = vec (y);
   m = length (x);
   if (m > 1)
     beta = (1 + sqrt (m)) * x(1) + sum (x(2:m));
     beta /= (m + sqrt (m));
     x(1) -= (beta * (1 + sqrt (m)));
     x(2:m) -= (beta * ones (m-1,1));
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -20,10 +20,16 @@
 ## @deftypefn {Function File} {} isa (@var{x}, @var{class})
 ## Return true if @var{x} is a value from the class @var{class}.
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Adapted-by: jwe
 
 function retval = isa (x, cname)
+
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   retval = strcmp (class (x), cname);
+
 endfunction
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -33,25 +33,29 @@
 
 ## The method for determining if a point is in in a polygon is based on
 ## the algorithm shown on
 ## http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/ and is
 ## credited to Randolph Franklin.
 
 function [IN, ON] = inpolygon (X, Y, xv, yv)
 
-  if ( !(isreal(X) && isreal(Y) && ismatrix(Y) && ...
-	 ismatrix(Y) && size_equal(X,Y)) )
+  if (nargin != 4)
+    print_usage ();
+  endif
+
+  if (! (isreal (X) && isreal (Y) && ismatrix (Y) && ismatrix (Y)
+	 && size_equal (X, Y)))
     error ("inpolygon: first two arguments must be real matrices of same size");
-  elseif ( !(isreal(xv) && isreal(yv) && isvector(xv) && ...
-	     isvector(yv) && size_equal(xv,yv)) )
+  elseif (! (isreal (xv) && isreal (yv) && isvector (xv) && isvector (yv)
+	     && size_equal (xv, yv)))
     error ("inpolygon: last two arguments must be real vectors of same size");
   endif
 
-  npol = length(xv);
+  npol = length (xv);
   do_boundary = (nargout >= 2);
   
   IN = zeros (size(X), "logical");
   if (do_boundary) 
     ON = zeros (size(X), "logical"); 
   endif
   
   j = npol;
@@ -71,16 +75,17 @@ function [IN, ON] = inpolygon (X, Y, xv,
     if (do_boundary)
        idx2 = ((yv(i) <= Y & Y <= yv(j)) | (yv(j) <= Y & Y <= yv(i))) & ...
               ((xv(i) <= X & X <= xv(j)) | (xv(j) <= X & X <= xv(i))) & ...
               (0 == distance | !delta_xv);
        ON (idx2) = true;
     endif
     j = i;
   endfor
+
 endfunction
 
 %!demo
 %!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
 %!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
 %!       0.05840 ];
 %!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
 %!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -30,18 +30,22 @@
 ##   housv: householder vector
 ## @end deftypefn
 
 ## Author: A. S. Hodel
 ## Created: August 1995
 
 function [housv, beta, zer] = housh (x, j, z)
 
-  ## check for valid inputs
-  if (!isvector (x) && ! isscalar (x))
+  if (nargin != 3)
+    print_usage ();
+  endif
+
+  ## Check for valid inputs.
+  if (! isvector (x) && ! isscalar (x))
     error ("housh: first input must be a vector")
   elseif (! isscalar(j))
     error ("housh: second argment must be an integer scalar")
   else
     housv = x;
     m = max (abs (housv));
     if (m != 0.0)
       housv = housv / m;
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -65,16 +65,20 @@
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 ## TODO?: This allows a single equal sign "=" to indicate equality, do
 ## we want to require a double equal since that is the boolean operator?
 
 function out = compare_versions (v1, v2, operator)
 
+  if (nargin != 3)
+    print_usage ();
+  endif
+
   ## Make sure that the version numbers are valid.
   if (! (ischar (v1) && ischar (v2)))
     error ("compare_versions: both version numbers must be strings");
   elseif (size (v1, 1) != 1 || size (v2, 1) != 1)
     error ("compare_versions: version numbers must be a single row")
   endif
 
   ## check and make sure that the operator is valid
@@ -179,16 +183,17 @@ function out = compare_versions (v1, v2,
   else
     ## They're not correctly less than or greater than, and they're not
     ## equal.
     out = false;
   endif
 
   ## Reverse the output if not is given.
   out = xor (not_op, out);
+
 endfunction
 
 ## tests
 ## test both equality symbols
 %!assert(compare_versions("1", "1", "="), true)
 ## test arbitrarily long equality
 %!assert(compare_versions("1.1.0.0.0", "1.1", "=="), true)
 %!assert(compare_versions("1", "1.1", "<"), true)
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -20,17 +20,23 @@
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} inputname (@var{n})
 ## Return the text defining @var{n}-th input to the function.
 ## @end deftypefn
 
 function s = inputname (n)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   s = evalin ("caller", sprintf ("deblank (argn(%d,:));", n));
+
 endfunction
 
 ## Warning: heap big magic in the following tests!!!
 ## The test function builds a private context for each
 ## test, with only the specified values shared between
 ## them.  It does this using the following template:
 ##
 ##     function [<shared>] = testfn(<shared>)
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -24,16 +24,21 @@
 ## change the directory to the directory where @var{f} is found. @code{run}
 ## then executes the script, and returns to the original directory.
 ## @seealso{system}
 ## @end deftypefn
 
 ## PKG_ADD: mark_as_command run
 
 function run (s)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   [d, f, ext] = fileparts (s);
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
 	cd (d);
 	if (! exist (s, "file") ||  ! strcmp (ext, ".m"))
 	  error ("run: file must exist and be a valid Octave script file");
diff --git a/scripts/quaternion/qconj.m b/scripts/quaternion/qconj.m
--- a/scripts/quaternion/qconj.m
+++ b/scripts/quaternion/qconj.m
@@ -27,14 +27,18 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function retval = qconj (q)
 
+  if (nargin != 1 )
+    print_usage ();
+  endif
+
   [a, b, c, d] = quaternion (q);
 
   retval = quaternion (-a, -b, -c, d);
 
 endfunction
 
diff --git a/scripts/quaternion/qcoordinate_plot.m b/scripts/quaternion/qcoordinate_plot.m
--- a/scripts/quaternion/qcoordinate_plot.m
+++ b/scripts/quaternion/qcoordinate_plot.m
@@ -33,16 +33,20 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function qcoordinate_plot (qf, qb, qv)
 
+  if (nargin != 3 )
+    print_usage ();
+  endif
+
   degrees = pi / 180;
   d180 = 180 * degrees;
 
   ## construct coordinate transformation to view frame
 
   cm = qtransvmat(qv);
 
   p1 = [-1, -1,  1];
diff --git a/scripts/quaternion/qderiv.m b/scripts/quaternion/qderiv.m
--- a/scripts/quaternion/qderiv.m
+++ b/scripts/quaternion/qderiv.m
@@ -38,16 +38,20 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function Dmat = qderivmat (Omega)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   Omega = vec (Omega);
 
   if (length (Omega) != 3)
     error ("qderivmat: Omega must be a length 3 vector");
   endif
 
   Dmat = 0.5 * [      0.0,  Omega(3), -Omega(2),  Omega(1);
                 -Omega(3),       0.0,  Omega(1),  Omega(2);
diff --git a/scripts/quaternion/qderivmat.m b/scripts/quaternion/qderivmat.m
--- a/scripts/quaternion/qderivmat.m
+++ b/scripts/quaternion/qderivmat.m
@@ -38,16 +38,20 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function Dmat = qderivmat (Omega)
 
+  if (nargin != 1 )
+    print_usage ();
+  endif
+
   Omega = vec (Omega);
 
   if (length (Omega) != 3)
     error ("qderivmat: Omega must be a length 3 vector");
   endif
 
   Dmat = 0.5 * [      0.0,  Omega(3), -Omega(2),  Omega(1);
                 -Omega(3),       0.0,  Omega(1),  Omega(2);
diff --git a/scripts/quaternion/qinv.m b/scripts/quaternion/qinv.m
--- a/scripts/quaternion/qinv.m
+++ b/scripts/quaternion/qinv.m
@@ -27,15 +27,19 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function retval = qinv (q)
 
+  if (nargin !=  1)
+    print_usage ();
+  endif
+
   if (norm (q) != 0)
     retval = qconj (q) / sum (q .* q);
   else
     error ("qinv: zero quaternion passed!");
   endif
 
 endfunction
diff --git a/scripts/quaternion/qmult.m b/scripts/quaternion/qmult.m
--- a/scripts/quaternion/qmult.m
+++ b/scripts/quaternion/qmult.m
@@ -35,17 +35,21 @@
 ## ji = -k                ik = -j
 ## @end example
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function retval = qmult (a, b)
-  
+
+  if (nargin != 2 )
+    print_usage ();
+  endif
+
   [a1, b1, c1, d1] = quaternion (a);
   [a2, b2, c2, d2] = quaternion (b);
   
   ri = b1*c2 - c1*b2 + d1*a2 + a1*d2;
   rj = c1*a2 - a1*c2 + d1*b2 + b1*d2;
   rk = a1*b2 - b1*a2 + d1*c2 + c1*d2;
   rr = -(a1*a2 + b1*b2 + c1*c2) + d1*d2;
   
diff --git a/scripts/quaternion/qtrans.m b/scripts/quaternion/qtrans.m
--- a/scripts/quaternion/qtrans.m
+++ b/scripts/quaternion/qtrans.m
@@ -23,16 +23,20 @@
 ## Returns @code{@var{v} = @var{q}*@var{v}/@var{q}}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function v = qtrans (v, q)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   if (! isvector (v) || length (v) != 4)
     error ("qtrans: v(%d,%d) must be a quaternion", rows (v), columns (v));
   elseif (! isvector (q) || length (q) != 4)
     error ("qtrans: q(%d,%d) must be a quaternion", rows (q), columns (q));
   endif
 
   v = qmult (q, qmult (v, qinv (q)));
 
diff --git a/scripts/quaternion/qtransvmat.m b/scripts/quaternion/qtransvmat.m
--- a/scripts/quaternion/qtransvmat.m
+++ b/scripts/quaternion/qtransvmat.m
@@ -24,16 +24,20 @@
 ## @code{[@var{vv}, @var{th}] = quaternion (@var{qib})}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function Aib = qtransvmat (qib)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (! isvector(qib) || length (qib) != 4)
     error ("qtransvmat: q(%d,%d) must be a quaternion", rows (qib), \
 	   columns (qib));
   elseif (max (abs (imag (qib))) != 0)
     error ("qtransvmat: input values must be real");
   endif
 
 
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -23,16 +23,20 @@
 ## denotes the lag-operator and @math{d} is greater than -1.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute fractional differences
 
 function retval = fractdiff (x, d)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   N = 100;
 
   if (! isvector (x))
     error ("fractdiff: x must be a vector")
   endif
 
   if (! isscalar (d))
     error ("fractdiff: d must be a scalar")
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -20,43 +20,47 @@
 ## @deftypefn {Function File} {} freqz_plot (@var{w}, @var{h})
 ## Plot the pass band, stop band and phase response of @var{h}.
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function freqz_plot (w, h)
 
-    n = length (w);
+  if (nargin != 2)
+    print_usage ();
+  endif
 
-    ## ## exclude zero-frequency
-    ## h = h (2 : length (h));
-    ## w = w (2 : length (w));
-    ## n = n-1;
+  n = length (w);
 
-    mag = 20 * log10 (abs (h));
-    phase = unwrap (arg (h));
-    maxmag = max (mag);
+  ## ## exclude zero-frequency
+  ## h = h (2 : length (h));
+  ## w = w (2 : length (w));
+  ## n = n-1;
 
-    subplot (3, 1, 1);
-    plot (w, mag);
-    grid ("on");
-    legend("Pass band (dB)");
-    axis ([w(1), w(n), maxmag-3, maxmag], "labely");
+  mag = 20 * log10 (abs (h));
+  phase = unwrap (arg (h));
+  maxmag = max (mag);
 
-    subplot (3, 1, 2);
-    plot (w, mag);
-    grid ("on");
-    legend ("Stop band (dB)");
-    if (maxmag - min (mag) > 100)
-      axis ([w(1), w(n), maxmag-100, maxmag], "labely");
-    else
-      axis ("autoy", "labely");
-    endif
+  subplot (3, 1, 1);
+  plot (w, mag);
+  grid ("on");
+  legend("Pass band (dB)");
+  axis ([w(1), w(n), maxmag-3, maxmag], "labely");
 
-    subplot (3, 1, 3);
-    plot (w, phase*360/(2*pi));
-    grid ("on");
-    legend ("Phase (degrees)");
-    xlabel ("Frequency");
-    axis ([w(1), w(n)], "autoy", "label");
+  subplot (3, 1, 2);
+  plot (w, mag);
+  grid ("on");
+  legend ("Stop band (dB)");
+  if (maxmag - min (mag) > 100)
+    axis ([w(1), w(n), maxmag-100, maxmag], "labely");
+  else
+    axis ("autoy", "labely");
+  endif
+
+  subplot (3, 1, 3);
+  plot (w, phase*360/(2*pi));
+  grid ("on");
+  legend ("Phase (degrees)");
+  xlabel ("Frequency");
+  axis ([w(1), w(n)], "autoy", "label");
 
 endfunction
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -23,16 +23,20 @@
 ## periodogram.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute the periodogram
 
 function retval = periodogram (x)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   [r, c] = size(x);
 
   if (r == 1)
     r = c;
   endif
 
   retval = (abs (fft (x - mean (x)))) .^ 2 / r;
 
diff --git a/scripts/signal/rectangle_lw.m b/scripts/signal/rectangle_lw.m
--- a/scripts/signal/rectangle_lw.m
+++ b/scripts/signal/rectangle_lw.m
@@ -23,14 +23,18 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular lag window
 
 function retval = rectangle_lw (n, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   retval = zeros (n, 1);
   t = floor (1 / b);
 
   retval (1:t, 1) = ones (t, 1);
 
 endfunction
diff --git a/scripts/signal/rectangle_sw.m b/scripts/signal/rectangle_sw.m
--- a/scripts/signal/rectangle_sw.m
+++ b/scripts/signal/rectangle_sw.m
@@ -23,16 +23,20 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular spectral window
 
 function retval = rectangle_sw (n, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   retval = zeros (n, 1);
   retval(1) = 2 / b + 1;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = sin ((2/b + 1) * l / 2) ./ sin (l / 2);
 
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -29,16 +29,20 @@
 ##  sin(pi*x)/(pi*x).
 ## @end ifinfo
 ## @end deftypefn
 
 ## Author: jwe ???
 
 function result = sinc (x)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   result = ones (size (x));
 
   i = (x != 0);
 
   if (any (i(:)))
     t = pi * x(i);
     result(i) = sin (t) ./ t;
   endif
diff --git a/scripts/signal/triangle_lw.m b/scripts/signal/triangle_lw.m
--- a/scripts/signal/triangle_lw.m
+++ b/scripts/signal/triangle_lw.m
@@ -23,13 +23,17 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular lag window
 
 function retval = triangle_lw (n, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   retval = 1 - (0 : n-1)' * b;
   retval = max ([retval'; (zeros (1, n))])';
 
 endfunction
 
diff --git a/scripts/signal/triangle_sw.m b/scripts/signal/triangle_sw.m
--- a/scripts/signal/triangle_sw.m
+++ b/scripts/signal/triangle_sw.m
@@ -23,16 +23,20 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular spectral window
 
 function retval = triangle_sw (n, b)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   retval = zeros(n,1);
   retval(1) = 1 / b;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2)).^2;
 
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -26,16 +26,20 @@
 ## noise, @var{v}.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Fit AR model by Yule-Walker method
 
 function [a, v] = yulewalker (c)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   p = length (c) - 1;
 
   if (columns (c) > 1)
     c = c';
   endif
 
   cp = c(2 : p+1);
   CP = zeros(p, p);
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -21,12 +21,17 @@
 ## Returns the column permutations such that the columns of
 ## @code{@var{s} (:, @var{p})} are ordered in terms of increase number
 ## of non-zero elements. If @var{s} is symmetric, then @var{p} is chosen
 ## such that @code{@var{s} (@var{p}, @var{p})} orders the rows and
 ## columns with increasing number of non zeros elements.
 ## @end deftypefn
 
 function p = colperm (s)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   [i, j] = spfind (s);
   idx = find (diff ([j; Inf]) != 0);
   [dummy, p] = sort (idx - [0; idx(1:(end-1))]);
 endfunction
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -22,10 +22,15 @@
 ## Plot the elimination tree of the matrix @var{s} or
 ## @code{@var{s}+@var{s}'}  if @var{s} in non-symmetric.  The optional
 ## parameters @var{line_style} and @var{edge_style} define the output
 ## style.
 ## @seealso{treeplot, gplot}
 ## @end deftypefn
 
 function etreeplot (s, varargin)
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
   treeplot (etree (s+s'), varargin{:});
 endfunction
diff --git a/scripts/sparse/nonzeros.m b/scripts/sparse/nonzeros.m
--- a/scripts/sparse/nonzeros.m
+++ b/scripts/sparse/nonzeros.m
@@ -17,16 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nonzeros (@var{s})
 ## Returns a vector of the non-zero values of the sparse matrix @var{s}.
 ## @end deftypefn
 
 function t = nonzeros (s)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (issparse (s))
     [i, j, t] = spfind (s);
   else
     [i, j, t] = find (s);
   endif
 endfunction
 
 %!assert(nonzeros([1,2;3,0]),[1;3;2])
diff --git a/scripts/sparse/spalloc.m b/scripts/sparse/spalloc.m
--- a/scripts/sparse/spalloc.m
+++ b/scripts/sparse/spalloc.m
@@ -36,10 +36,15 @@
 ## @end example
 ##
 ## will reallocate memory at each step. It is therefore vitally important
 ## that code like this is vectorized as much as possible.
 ## @seealso{sparse, nzmax}
 ## @end deftypefn
 
 function s = spalloc (r, c, nz)
+
+  if (nargin < 2)
+    print_usage ();
+  endif
+
   s = sparse (r, c);
 endfunction
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -18,16 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spones (@var{x})
 ## Replace the non-zero entries of @var{x} with ones. This creates a
 ## sparse matrix with the same structure as @var{x}.
 ## @end deftypefn
 
 function s = spones (s)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   if (issparse (s))
     [i, j, v, m, n] = spfind (s);
   else
     [i, j, v] = find (s);
     [m, n] = size (s);
   end
   s = sparse (i, j, 1, m, n);
 endfunction
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -25,16 +25,20 @@
 ## @var{markersize} is given as an scalar value, it is used to determine the
 ## point size in the plot. If the string @var{LineSpec} is given it is
 ## passed to @code{plot} and determines the appearance of the plot.
 ## @seealso{plot}
 ## @end deftypefn
 
 function spy (S, varargin) 
 
+  if (nargin < 1)
+    print_usage ();
+  endif
+
   markersize = NaN;
   if (numel (i) < 1000)
     LineSpec = "*";
   else
     LineSpec = ".";
   endif
   for i = 1:length(varargin)
     if (ischar(varargin{i}))
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -30,16 +30,21 @@
 ##
 ## If max(n) is very large, then you should be using special purpose 
 ## factorization code.
 ##
 ## @seealso{primes, factor, gcd, lcm}
 ## @end deftypefn
 
 function t = isprime (n)
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
   if (! isscalar (n))
     nel = numel (n);
     t = n;
     for i = 1:nel
       t(i) = isprime (t(i));
     endfor
   elseif (n != fix (n) || n < 2)
     t = 0;
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -23,15 +23,19 @@
 ## the univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the empirical distribution
 
 function cdf = empirical_cdf (x, data)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   if (! isvector (data))
     error ("empirical_cdf: data must be a vector");
   endif
 
   cdf = discrete_cdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -23,15 +23,19 @@
 ## univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the empirical distribution
 
 function inv = empirical_inv (x, data)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   if (! isvector (data))
     error ("empirical_inv: data must be a vector");
   endif
 
   inv = discrete_inv (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -23,15 +23,19 @@
 ## univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the empirical distribution
 
 function pdf = empirical_pdf (x, data)
 
+  if (nargin != 2)
+    print_usage ();
+  endif
+
   if (! isvector (data))
     error ("empirical_pdf: data must be a vector");
   endif
 
   pdf = discrete_pdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/models/logistic_regression_derivatives.m b/scripts/statistics/models/logistic_regression_derivatives.m
--- a/scripts/statistics/models/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/logistic_regression_derivatives.m
@@ -24,19 +24,23 @@
 ## @end deftypefn
 
 ## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Derivates of log-likelihood in logistic regression
 
 function [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p)
 
+  if (nargin != 6)
+    print_usage ();
+  endif
+
   ## first derivative
   v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
   dlogp = [(dmult (v, z) - dmult (v1, z1)), (dmult (v - v1, x))];
   dl = sum (dlogp)';
 
   ## second derivative
   w = v .* (1 - 2 * g); w1 = v1 .* (1 - 2 * g1);
   d2l = [z, x]' * dmult (w, [z, x]) - [z1, x]' * dmult (w1, [z1, x]) ...
       - dlogp' * dlogp;
 
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/statistics/models/logistic_regression_likelihood.m b/scripts/statistics/models/logistic_regression_likelihood.m
--- a/scripts/statistics/models/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/logistic_regression_likelihood.m
@@ -24,16 +24,20 @@
 ## @end deftypefn
 
 ## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Likelihood in logistic regression
 
 function [g, g1, p, dev] = logistic_regression_likelihood (y, x, beta, z, z1)
 
+  if (nargin != 5)
+    print_usage ();
+  endif
+
   e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
   g = max (y == max (y), g); g1 = min (y > min(y), g1);
 
   p = g - g1;
   dev = -2 * sum (log (p));
 
 endfunction
