# HG changeset patch
# User jwe
# Date 1144933473 0
#      Thu Apr 13 13:04:33 2006 +0000
# Node ID ce79d238f142ec5a505636139cc0fd4b95ff7586
# Parent  65208d959bf1681c18fd3adec4f4f9daa1d74bf2
[project @ 2006-04-13 13:04:32 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2006-04-12  John W. Eaton  <jwe@octave.org>
+
+	* configure.in: If using g++, also add -Wold-style-cast to CXXFLAGS.
+
 2006-03-28  John W. Eaton  <jwe@octave.org>
 
 	* configure.in: Don't check for MPI libraries.
 
 2006-03-27  John W. Eaton  <jwe@octave.org>
 
 	* configure.in: Downcase ac_cv_header_mach_o_dyld_h.
 	From Martin Costabel <costabel@wanadoo.fr>.
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.505 $)
+AC_REVISION($Revision: 1.506 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1583,20 +1583,21 @@ if test -z "$EXTERN_CXXFLAGS"; then
     WARN_CXXFLAGS="$WARN_CXXFLAGS -Wall";
     AC_MSG_RESULT([adding -Wall to WARN_CXXFLAGS])])
   OCTAVE_CXX_FLAG(-W, [
     WARN_CXXFLAGS="$WARN_CXXFLAGS -W";
     AC_MSG_RESULT([adding -W to WARN_CXXFLAGS])])
   OCTAVE_CXX_FLAG(-Wshadow, [
     WARN_CXXFLAGS="$WARN_CXXFLAGS -Wshadow";
     AC_MSG_RESULT([adding -Wshadow to WARN_CXXFLAGS])])
+  OCTAVE_CXX_FLAG(-Wold-style-cast, [
+    WARN_CXXFLAGS="$WARN_CXXFLAGS -Wold-style-cast";
+    AC_MSG_RESULT([adding -Wold-style-cast to WARN_CXXFLAGS])])
 fi
 
-### Someday, maybe include -ansi and even -pedantic in this list...
-
 GCC_PICKY_FLAGS="-Wcast-align -Wcast-qual -Wmissing-prototypes \
   -Wpointer-arith -Wstrict-prototypes -Wwrite-strings"
 
 GXX_PICKY_FLAGS="-Wcast-align -Wcast-qual -Wpointer-arith \
   -Wwrite-strings -Weffc++ -Wenum-clash"
 
 AC_ARG_ENABLE(picky-flags,
   [  --enable-picky-flags    add picky options to CFLAGS, CXXFLAGS, FFLAGS],
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,39 +1,106 @@
-2006-04-12  John W. Eaton  <jwe@octave.org>
+2006-04-13  John W. Eaton  <jwe@octave.org>
+
+	* ov.h (OV_REP_TYPE): New macro.
+
+	* DLD-FUNCTIONS/sparse.cc (MINMAX_BODY): No need to cast arg1 to
+	const octave_sparse_matrix&.
+
+	* ov-base.cc (print_answer_id_name, warn_resize_on_range_error,
+	warn_num_to_str, silent_functions): Move here, from ov.cc.
+	(Vwarn_resize_on_range_error, Vsilent_functions): Likewise.
+	(Vprint_answer_id_name): Likewise.  Now static.
+	(symbols_of_ov_base): New function.  Move DEFVARs for
+	print_answer_id_name, warn_resize_on_range_error, warn_num_to_str,
+	and silent_functions here from symbols_of_ov in ov.cc.
+	* ov.h (Vprint_answer_id_name): Delete decl.
+	* ov-base.h (Vwarn_resize_on_range_error, Vwarn_num_to_str):	
+	Move decls here from ov.h.
 
 	* ov-str-mat.cc (warn_str_to_num): Move here, from ov.cc.
 	(Vwarn_str_to_num): Likewise.  Now static.
 	(symbols_of_ov_str_mat): New function.  Move DEFVAR for
 	warn_str_to_num here from symbols_of_ov in ov.cc.
 	* ov.h (Vwarn_str_to_num): Delete decl.
 
 	* ov-struct.cc (octave_struct::load_ascii): Pass loop counter, not
 	count, to read_ascii.
 	* ov-list.cc (octave_list::load_ascii): Likewise.
 
 	* ov-list.cc (octave_list::do_index_op): Allow index to extract
 	multiple items.  Result is always a list.
 
-	* ov-struct.cc (struct_levels_to_print): Move here from ov.cc.
-	(Vstruct-levels_to_print): Likewise.  Now static.
-	(symbols_of_ov_struct): New function.  Move DEFVAR for
-	struct_levels_to_print here from symbols_of_ov in ov.cc.
-
-	* ov.h (Vstruct-levels_to_print): Delete decl.
+	* pr-output.cc (struct_levels_to_print): Move here from ov.cc.
+	(Vstruct-levels_to_print): Likewise.
+	(symbols_of_pr_output): Move DEFVAR for struct_levels_to_print here
+	from symbols_of_ov in ov.cc.
+	* pr-output.h (Vstruct_levels_to_print): Nove decl here from ov.h.
 
 	* gripes.cc (warn_divide_by_zero): Move here from ov.cc.
 	(Vwarn_divide_by_zero): Likewise.  Now static.
 	(symbols_of_gripes): New function.  Move DEFVAR for
 	warn_divide_by_zero here from symbols_of_ov in ov.cc.
 	* ov.h (Vwarn_divide_by_zero): Delete decl.
 
 	* load-save.cc (do_load): Declare count octave_idx_type, not int.
 	* ls-oct-ascii.cc, ls-oct-ascii.h (read_ascii_data): Likewise.
 
+	Rearrange octave_value class hierarchy so that rep is a pointer
+	an octave_base_value object and the octave_base_value class
+	stores the reference count.  Virtualness now goes with the
+	octave_base_value class, not the octave_value class.
+
+	* ops.h, ov-base-int.cc, ov-base-int.h, ov-base-mat.h,
+	ov-base-scalar.h, ov-base-sparse.h, ov-base.cc, ov-base.h,
+	ov-bool-mat.cc, ov-bool-mat.h, ov-bool-sparse.cc,
+	ov-bool-sparse.h, ov-bool.cc, ov-bool.h, ov-cell.cc, ov-cell.h,
+	ov-ch-mat.h, ov-colon.h, ov-complex.cc, ov-complex.h,
+	ov-cs-list.h, ov-cx-mat.cc, ov-cx-mat.h, ov-cx-sparse.cc,
+	ov-cx-sparse.h, ov-fcn-handle.h, ov-fcn-inline.h, ov-fcn.cc,
+	ov-fcn.h, ov-intx.h, ov-list.cc, ov-list.h, ov-range.cc,
+	ov-range.h, ov-re-mat.cc, ov-re-mat.h, ov-re-sparse.cc,
+	ov-re-sparse.h, ov-scalar.h, ov-str-mat.cc, ov-str-mat.h,
+	ov-streamoff.h, ov-struct.cc, ov-struct.h, ov-type-conv.h,
+	ov-typeinfo.cc, ov-typeinfo.h, ov-va-args.h, ov.cc, ov.h,
+	variables.cc, DLD-FUNCTIONS/matrix_type.cc, DLD-FUNCTIONS/splu.cc,
+	OPERATORS/op-chm.cc: Cope with octave_value hierarchy changes
+	(apologies for the lack of detail).
+
+	* ov.cc (octave_value::nil_rep): Delete.
+	* ov.h (octave_value::nil_rep): Delete decl.
+
+	* ov-base.h (DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA,
+	DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA, 
+	DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2,
+	DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA):
+	Move macro definitions here from ov.h.
+	(struct_indent, increment_struct_indent, decrement_struct_indent,
+	list_indent, increment_list_indent, decrement_list_indent):
+	Delete decls.
+
+	* ov-base.cc. ov-base.h (do_index_op, ndims, all, any,
+	convert_to_str, print_with_name, numeric_assign,
+	reset_indent_level, increment_indent_level,
+	decrement_indent_level, current_print_indent_level, newline,
+	indent, reset): Move member functions here from octave_value class.
+	(count, curr_print_indent_level, beginning_of_line):
+	Move data members here from octave_value class.
+	(gripe_indexed_assignment, gripe_assign_conversion_failed,
+	gripe_no_conversion): Move here from ov.cc.
+
+	* ov.h (class octave_xvalue): Delete.
+	(octave_value::octave_value (const octave_xvalue&)): Delete.
+	(anonymous union): Delete.
+	(octave_value::rep): Now a pointer to octave_base_value instead of
+	octave_value.
+
+	(octave_value::internal_rep): Return pointer to octave_base_value,
+	not octave_value.
+	
 2006-04-11  John W. Eaton  <jwe@octave.org>
 
 	* pt-assign.cc (tree_simple_assignment::rvalue,
 	tree_multi_assignment::rvalue):
 	Error if RHS is a comma-separated list.
 
 2006-04-07  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -107,17 +107,17 @@ matrix type.\n\
     error ("matrix_type: incorrect number of arguments");
   else
     {
       if (args(0).is_sparse_type ())
 	{
 	  if (nargin == 1)
 	    {
 	      SparseType mattyp;
-	      const octave_value& rep = args(0).get_rep ();
+	      const octave_base_value& rep = args(0).get_rep ();
 
 	      if (args(0).type_name () == "sparse complex matrix" ) 
 		{
 		  mattyp = 
 		    ((const octave_sparse_complex_matrix &)rep).sparse_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -717,17 +717,17 @@ real.\n\
       break; \
  \
     default: \
       panic_impossible (); \
       break; \
     } \
  \
   int dim; \
-  dim_vector dv = ((const octave_sparse_matrix&) arg1) .dims (); \
+  dim_vector dv = arg1.dims (); \
   if (error_state) \
     { \
       gripe_wrong_type_arg (#FCN, arg1);  \
       return retval; \
     } \
  \
   if (nargin == 3) \
     { \
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -416,17 +416,17 @@ than @code{@var{y} = spinv (@var{a}) * @
 
   if (nargin != 1)
     {
       print_usage ("inv");
       return retval;
     }
 
   octave_value arg = args(0);
-  const octave_value& rep = arg.get_rep ();
+  const octave_base_value& rep = arg.get_rep ();
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("spinverse", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -143,17 +143,23 @@ extern void install_ops (void);
   t1 v1 = DYNAMIC_CAST (t1, a1); \
   t2 v2 = DYNAMIC_CAST (t2, a2)
 
 #define CAST_CONV_ARG(t) \
   t v = DYNAMIC_CAST (t, a)
 
 #define ASSIGNOPDECL(name) \
   static octave_value \
-  oct_assignop_ ## name (octave_value& a1, \
+  oct_assignop_ ## name (octave_base_value& a1, \
+			 const octave_value_list& idx, \
+			 const octave_base_value& a2)
+
+#define ASSIGNANYOPDECL(name) \
+  static octave_value \
+  oct_assignop_ ## name (octave_base_value& a1, \
 			 const octave_value_list& idx, \
 			 const octave_value& a2)
 
 #define DEFASSIGNOP(name, t1, t2) \
   ASSIGNOPDECL (name)
 
 #define DEFASSIGNOP_FN(name, t1, t2, f) \
   ASSIGNOPDECL (name) \
@@ -169,31 +175,31 @@ extern void install_ops (void);
   { \
     CAST_BINOP_ARGS (octave_ ## t1&, const octave_ ## t2&); \
  \
     v1.f (idx, v2.e ## _value ()); \
     return octave_value (); \
   }
 
 #define DEFASSIGNANYOP_FN(name, t1, f) \
-  ASSIGNOPDECL (name) \
+  ASSIGNANYOPDECL (name) \
   { \
     octave_ ## t1& v1 = DYNAMIC_CAST (octave_ ## t1&, a1); \
  \
     v1.f (idx, a2); \
     return octave_value (); \
   }
 
 #define CONVDECL(name) \
-  static octave_value * \
-  oct_conv_ ## name (const octave_value& a)
+  static octave_base_value * \
+  oct_conv_ ## name (const octave_base_value& a)
 
 #define CONVDECLX(name) \
-  static octave_value * \
-  oct_conv_ ## name (const octave_value&)
+  static octave_base_value * \
+  oct_conv_ ## name (const octave_base_value&)
 
 #define DEFCONV(name, a_dummy, b_dummy) \
   CONVDECL (name)
 
 #define DEFCONVFNX(name, tfrom, ovtto, tto, e) \
   CONVDECL (name) \
   { \
     CAST_CONV_ARG (const octave_ ## tfrom&); \
@@ -218,17 +224,17 @@ extern void install_ops (void);
 #define DEFCONVFN(name, tfrom, tto) \
   DEFCONVFNX (name, tfrom, tto ## _matrix, tto, )
 
 #define DEFCONVFN2(name, tfrom, sm, tto) \
   DEFCONVFNX (name, tfrom ## _ ## sm, tto ## _matrix, tto, tfrom ## _)
 
 #define UNOPDECL(name, a) \
   static octave_value \
-  oct_unop_ ## name (const octave_value& a)
+  oct_unop_ ## name (const octave_base_value& a)
 
 #define DEFUNOPX(name, t) \
   UNOPDECL (name, , )
 
 #define DEFUNOP(name, t) \
   UNOPDECL (name, a)
 
 #define DEFUNOP_OP(name, t, op) \
@@ -258,25 +264,25 @@ extern void install_ops (void);
   UNOPDECL (name, a) \
   { \
     CAST_UNOP_ARG (const octave_ ## t&); \
     return octave_value (f (v.e ## _value ())); \
   }
 
 #define DEFNCUNOP_METHOD(name, t, method) \
   static void \
-  oct_unop_ ## name (octave_value& a) \
+  oct_unop_ ## name (octave_base_value& a) \
   { \
     CAST_UNOP_ARG (octave_ ## t&); \
     v.method (); \
   }
 
 #define BINOPDECL(name, a1, a2) \
   static octave_value \
-  oct_binop_ ## name (const octave_value& a1, const octave_value& a2)
+  oct_binop_ ## name (const octave_base_value& a1, const octave_base_value& a2)
 
 #define DEFBINOPX(name, t1, t2) \
   BINOPDECL (name, , )
 
 #define DEFBINOP(name, t1, t2) \
   BINOPDECL (name, a1, a2)
 
 #define DEFBINOP_OP(name, t1, t2, op) \
@@ -314,17 +320,17 @@ extern void install_ops (void);
 #define BINOP_NONCONFORMANT(msg) \
   gripe_nonconformant (msg, \
 		       a1.rows (), a1.columns (), \
 		       a2.rows (), a2.columns ()); \
   return octave_value ()
 
 #define CATOPDECL(name, a1, a2)	\
   static octave_value \
-  oct_catop_ ## name (octave_value& a1, const octave_value& a2, \
+  oct_catop_ ## name (octave_base_value& a1, const octave_base_value& a2, \
 		      const Array<int>& ra_idx)
 
 #define DEFCATOPX(name, t1, t2)	\
   CATOPDECL (name, , )
 
 #define DEFCATOP(name, t1, t2)	\
   CATOPDECL (name, a1, a2)
 
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -52,20 +52,20 @@ 02110-1301, USA.
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-ascii.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 template <class T>
-octave_value *
+octave_base_value *
 octave_base_int_matrix<T>::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   if (this->matrix.nelem () == 1)
     retval = new typename octave_value_int_traits<T>::scalar_type (this->matrix (0));
 
   return retval;
 }
 
 template <class T>
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -49,20 +49,20 @@ octave_base_int_matrix : public octave_b
 public:
 
   octave_base_int_matrix (void) : octave_base_matrix<T> () { }
 
   octave_base_int_matrix (const T& nda) : octave_base_matrix<T> (nda) { }
 
   ~octave_base_int_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_base_int_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_base_int_matrix (); }
+  octave_base_value *clone (void) const { return new octave_base_int_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_base_int_matrix (); }
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { matrix += 1; }
 
   //  void decrement (void) { matrix -= 1; }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -93,20 +93,20 @@ octave_base_int_scalar : public octave_b
 public:
 
   octave_base_int_scalar (void) : octave_base_scalar<T> () { }
 
   octave_base_int_scalar (const T& s) : octave_base_scalar<T> (s) { }
 
   ~octave_base_int_scalar (void) { }
 
-  octave_value *clone (void) const { return new octave_base_int_scalar (*this); }
-  octave_value *empty_clone (void) const { return new octave_base_int_scalar (); }
+  octave_base_value *clone (void) const { return new octave_base_int_scalar (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_base_int_scalar (); }
 
-  octave_value *try_narrowing_conversion (void) { return 0; }
+  octave_base_value *try_narrowing_conversion (void) { return 0; }
 
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { scalar += 1; }
 
   //  void decrement (void) { scalar -= 1; }
 
   bool save_ascii (std::ostream& os, bool&, bool );
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -59,18 +59,18 @@ public:
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix) { }
 
   ~octave_base_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_base_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_base_matrix (); }
+  octave_base_value *clone (void) const { return new octave_base_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_base_matrix (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return MT (matrix.squeeze ()); }
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx);
 
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -51,18 +51,18 @@ public:
   octave_base_scalar (const ST& s)
     : octave_base_value (), scalar (s) { }
 
   octave_base_scalar (const octave_base_scalar& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_base_scalar (void) { }
 
-  octave_value *clone (void) const { return new octave_base_scalar (*this); }
-  octave_value *empty_clone (void) const { return new octave_base_scalar (); }
+  octave_base_value *clone (void) const { return new octave_base_scalar (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_base_scalar (); }
 
   octave_value squeeze (void) const { return scalar; }
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string&,
 			     const std::list<octave_value_list>&, int)
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -66,18 +66,18 @@ octave_base_sparse : public octave_base_
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_sparse (const octave_base_sparse& a) : 
     octave_base_value (), matrix (a.matrix), typ (a.typ) { }
 
   ~octave_base_sparse (void) { }
 
-  octave_value *clone (void) const { return new octave_base_sparse (*this); }
-  octave_value *empty_clone (void) const 
+  octave_base_value *clone (void) const { return new octave_base_sparse (*this); }
+  octave_base_value *empty_clone (void) const 
     { return new octave_base_sparse (); }
 
   octave_idx_type nnz (void) const { return matrix.nnz (); }
 
   octave_idx_type nzmax (void) const { return matrix.nzmax (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -24,20 +24,22 @@ 02110-1301, USA.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <climits>
 
 #include <iostream>
 
+#include "Array-flags.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "so-array.h"
 
+#include "defun.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-cell.h"
@@ -45,21 +47,38 @@ 02110-1301, USA.
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-list.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "ov-fcn-handle.h"
+#include "parse.h"
+#include "utils.h"
 #include "variables.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value,
 				     "<unknown type>", "unknown");
 
+// If TRUE, print the name along with the value.
+static bool Vprint_answer_id_name;
+
+// If TRUE, turn off printing of results in functions (as if a
+// semicolon has been appended to each statement).
+static bool Vsilent_functions;
+
+// Should we print a warning when converting `[97, 98, 99, "123"]'
+// to a character string?
+bool Vwarn_num_to_str;
+
+// If TRUE, print a warning when a matrix is resized by an indexed
+// assignment with indices outside the current bounds.
+bool Vwarn_resize_on_range_error;
+
 octave_value
 octave_base_value::squeeze (void) const
 {
   std::string nm = type_name ();
   error ("squeeze: invalid operation for %s type", nm.c_str ());
   return octave_value ();
 }
 
@@ -84,32 +103,63 @@ octave_base_value::subsref (const std::s
 octave_value
 octave_base_value::do_index_op (const octave_value_list&, int)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
+octave_value
+octave_base_value::do_index_op (const octave_value_list& idx)
+{
+  return do_index_op (idx, 0);
+}
+
 octave_value_list
 octave_base_value::do_multi_index_op (int, const octave_value_list&)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 idx_vector
 octave_base_value::index_vector (void) const
 {
   std::string nm = type_name ();
   error ("%s type invalid as index value", nm.c_str ());
   return idx_vector ();
 }
 
+int
+octave_base_value::ndims (void) const
+{
+  dim_vector dv = dims ();
+
+  int n_dims = dv.length ();
+     
+   // Remove trailing singleton dimensions.
+
+   for (int i = n_dims; i > 2; i--)
+     {
+       if (dv(i-1) == 1)
+	 n_dims--;
+       else
+	 break;
+     }
+   
+   // The result is always >= 2.
+
+   if (n_dims < 2)
+     n_dims = 2;
+
+   return n_dims;
+}
+
 octave_value
 octave_base_value::subsasgn (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     const octave_value& rhs)
 {
   octave_value retval;
 
   if (is_defined ())
@@ -204,16 +254,39 @@ octave_base_value::permute (const Array<
 octave_value
 octave_base_value::resize (const dim_vector&, bool) const
 {
   gripe_wrong_type_arg ("octave_base_value::resize ()", type_name ());
   return octave_value ();
 }
 
 octave_value
+octave_base_value::all (int) const
+{
+  return 0.0;
+}
+
+octave_value
+octave_base_value::any (int) const
+{
+  return 0.0;
+}
+
+octave_value
+octave_base_value::convert_to_str (bool pad, bool force, char type) const
+{
+  octave_value retval = convert_to_str_internal (pad, force, type);
+
+  if (! force && is_numeric_type () && Vwarn_num_to_str)
+    gripe_implicit_conversion (type_name (), retval.type_name ());
+
+  return retval;
+}
+
+octave_value
 octave_base_value::convert_to_str_internal (bool, bool, char) const
 {
   gripe_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
 			type_name ());
   return octave_value ();
 }
 
 void
@@ -252,16 +325,35 @@ octave_base_value::print_name_tag (std::
       newline (os);
       retval = true;
     }
 
   return retval;
 }
 
 void
+octave_base_value::print_with_name (std::ostream& output_buf,
+				    const std::string& name, 
+				    bool print_padding) const
+{
+  if (! (evaluating_function_body && Vsilent_functions))
+    {
+      bool pad_after = false;
+
+      if (Vprint_answer_id_name)
+	pad_after = print_name_tag (output_buf, name);
+
+      print (output_buf);
+
+      if (print_padding && pad_after)
+	newline (output_buf);
+    }
+}
+
+void
 octave_base_value::print_info (std::ostream& os,
 			       const std::string& /* prefix */) const
 {
   os << "no info for type: " << type_name () << "\n";
 }
 
 #define INT_CONV_METHOD(T, F, MIN_LIMIT, MAX_LIMIT) \
   T \
@@ -768,16 +860,203 @@ int
 octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
 			  int, oct_mach_info::float_format) const
 {
   gripe_wrong_type_arg ("octave_base_value::write()", type_name ());
 
   return false;
 }
 
+static void
+gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
+{
+  error ("assignment of `%s' to indexed `%s' not implemented",
+	 tn2.c_str (), tn1.c_str ());
+}
+
+static void
+gripe_assign_conversion_failed (const std::string& tn1,
+				const std::string& tn2)
+{
+  error ("type conversion for assignment of `%s' to indexed `%s' failed",
+	 tn2.c_str (), tn1.c_str ());
+}
+
+static void
+gripe_no_conversion (const std::string& on, const std::string& tn1,
+		     const std::string& tn2)
+{
+  error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
+	 on.c_str (), tn2.c_str (), tn1.c_str ());
+}
+
+octave_value
+octave_base_value::numeric_assign (const std::string& type,
+				   const std::list<octave_value_list>& idx,
+				   const octave_value& rhs)
+{
+  octave_value retval;
+
+  int t_lhs = type_id ();
+  int t_rhs = rhs.type_id ();
+
+  octave_value_typeinfo::assign_op_fcn f
+    = octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
+					       t_lhs, t_rhs);
+
+  bool done = false;
+
+  if (f)
+    {
+      f (*this, idx.front (), rhs.get_rep ());
+
+      done = (! error_state);
+    }
+
+  if (done)
+    {
+      count++;
+      retval = octave_value (this);
+    }
+  else
+    {
+      int t_result
+	= octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
+
+      if (t_result >= 0)
+	{
+	  octave_base_value::type_conv_fcn cf
+	    = octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
+
+	  if (cf)
+	    {
+	      octave_base_value *tmp (cf (*this));
+
+	      if (tmp)
+		{
+		  retval = tmp->subsasgn (type, idx, rhs);
+
+		  done = (! error_state);
+		}
+	      else
+		gripe_assign_conversion_failed (type_name (),
+						rhs.type_name ());
+	    }
+	  else
+	    gripe_indexed_assignment (type_name (), rhs.type_name ());
+	}
+
+      if (! (done || error_state))
+	{
+	  octave_value tmp_rhs;
+
+	  octave_base_value::type_conv_fcn cf_rhs
+	    = rhs.numeric_conversion_function ();
+
+	  if (cf_rhs)
+	    {
+	      octave_base_value *tmp = cf_rhs (rhs.get_rep ());
+
+	      if (tmp)
+		tmp_rhs = octave_value (tmp);
+	      else
+		{
+		  gripe_assign_conversion_failed (type_name (),
+						  rhs.type_name ());
+		  return octave_value ();
+		}
+	    }
+	  else
+	    tmp_rhs = rhs;
+
+	  octave_base_value::type_conv_fcn cf_this
+	    = numeric_conversion_function ();
+
+	  octave_base_value *tmp_lhs = this;
+
+	  if (cf_this)
+	    {
+	      octave_base_value *tmp = cf_this (*this);
+
+	      if (tmp)
+		tmp_lhs = tmp;
+	      else
+		{
+		  gripe_assign_conversion_failed (type_name (),
+						  rhs.type_name ());
+		  return octave_value ();
+		}
+	    }
+
+	  if (cf_this || cf_rhs)
+	    {
+	      retval = tmp_lhs->subsasgn (type, idx, tmp_rhs);
+
+	      done = (! error_state);
+	    }
+	  else
+	    gripe_no_conversion (octave_value::assign_op_as_string (octave_value::op_asn_eq),
+				 type_name (), rhs.type_name ());
+	}
+    }
+
+  // The assignment may have converted to a type that is wider than
+  // necessary.
+
+  retval.maybe_mutate ();
+
+  return retval;
+}
+
+// Current indentation.
+int octave_base_value::curr_print_indent_level = 0;
+
+// TRUE means we are at the beginning of a line.
+bool octave_base_value::beginning_of_line = true;
+
+// Each print() function should call this before printing anything.
+//
+// This doesn't need to be fast, but isn't there a better way?
+
+void
+octave_base_value::indent (std::ostream& os) const
+{
+  assert (curr_print_indent_level >= 0);
+ 
+  if (beginning_of_line)
+    {
+      // XXX FIXME XXX -- do we need this?
+      // os << prefix;
+
+      for (int i = 0; i < curr_print_indent_level; i++)
+	os << " ";
+
+      beginning_of_line = false;
+    }
+}
+
+// All print() functions should use this to print new lines.
+
+void
+octave_base_value::newline (std::ostream& os) const
+{
+  os << "\n";
+
+  beginning_of_line = true;
+}
+
+// For ressetting print state.
+
+void
+octave_base_value::reset (void) const
+{
+  beginning_of_line = true;
+  curr_print_indent_level = 0;
+}
+
 CONVDECLX (matrix_conv)
 {
   return new octave_matrix ();
 }
 
 CONVDECLX (complex_matrix_conv)
 {
   return new octave_complex_matrix ();
@@ -805,13 +1084,107 @@ install_base_type_conversions (void)
   INSTALL_ASSIGNCONV (octave_base_value, octave_cell, octave_cell);
 
   INSTALL_WIDENOP (octave_base_value, octave_matrix, matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_complex_matrix, complex_matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
+static int
+print_answer_id_name (void)
+{
+  Vprint_answer_id_name = check_preference ("print_answer_id_name");
+
+  return 0;
+}
+
+static int
+silent_functions (void)
+{
+  Vsilent_functions = check_preference ("silent_functions");
+
+  return 0;
+}
+
+static int
+warn_num_to_str (void)
+{
+  Vwarn_num_to_str = check_preference ("warn_num_to_str");
+
+  return 0;
+}
+
+static int
+warn_resize_on_range_error (void)
+{
+  Vwarn_resize_on_range_error
+    = check_preference ("warn_resize_on_range_error");
+
+  liboctave_wrore_flag = Vwarn_resize_on_range_error;
+
+  return 0;
+}
+
+void
+symbols_of_ov_base (void)
+{
+  DEFVAR (print_answer_id_name, true, print_answer_id_name,
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} print_answer_id_name\n\
+If the value of @code{print_answer_id_name} is nonzero, variable\n\
+names are printed along with the result.  Otherwise, only the result\n\
+values are printed.  The default value is 1.\n\
+@end defvr");
+
+  DEFVAR (silent_functions, false, silent_functions,
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} silent_functions\n\
+If the value of @code{silent_functions} is nonzero, internal output\n\
+from a function is suppressed.  Otherwise, the results of expressions\n\
+within a function body that are not terminated with a semicolon will\n\
+have their values printed.  The default value is 0.\n\
+\n\
+For example, if the function\n\
+\n\
+@example\n\
+function f ()\n\
+  2 + 2\n\
+endfunction\n\
+@end example\n\
+\n\
+@noindent\n\
+is executed, Octave will either print @samp{ans = 4} or nothing\n\
+depending on the value of @code{silent_functions}.\n\
+@end defvr");
+
+  DEFVAR (warn_num_to_str, true, warn_num_to_str,
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} warn_num_to_str\n\
+If the value of @code{warn_num_to_str} is nonzero, a warning is\n\
+printed for implicit conversions of numbers to their ASCII character\n\
+equivalents when strings are constructed using a mixture of strings and\n\
+numbers in matrix notation.  For example,\n\
+\n\
+@example\n\
+@group\n\
+[ \"f\", 111, 111 ]\n\
+     @result{} \"foo\"\n\
+@end group\n\
+@end example\n\
+elicits a warning if @code{warn_num_to_str} is nonzero.  The default\n\
+value is 1.\n\
+@end defvr");
+
+  DEFVAR (warn_resize_on_range_error, false, warn_resize_on_range_error,
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} warn_resize_on_range_error\n\
+If the value of @code{warn_resize_on_range_error} is nonzero, print a\n\
+warning when a matrix is resized by an indexed assignment with\n\
+indices outside the current bounds.  The default value is 0.\n\
+@end defvr");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -22,315 +22,440 @@ 02110-1301, USA.
 */
 
 #if !defined (octave_base_value_h)
 #define octave_base_value_h 1
 
 #include <cstdlib>
 
 #include <iostream>
+#include <list>
 #include <string>
 
+#if defined (HAVE_HDF5)
+#include <hdf5.h>
+#endif
+
+#include "Range.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
-#include "ov.h"
-#include "ov-typeinfo.h"
 
 class Cell;
+class streamoff_array;
 class Octave_map;
+class octave_value;
 class octave_value_list;
+class octave_stream;
+class octave_streamoff;
+class octave_function;
+class octave_user_function;
+class octave_fcn_handle;
+class octave_fcn_inline;
+class octave_value_list;
+class octave_lvalue;
 
 class tree_walker;
 
+// T_ID is the type id of struct objects, set by register_type().
+// T_NAME is the type name of struct objects.
+#define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2()
+
+#define DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA \
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2(virtual)
+
+#define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2(VIRTUAL) \
+  public: \
+    VIRTUAL int type_id (void) const { return t_id; } \
+    VIRTUAL std::string type_name (void) const { return t_name; } \
+    VIRTUAL std::string class_name (void) const { return c_name; } \
+    static int static_type_id (void) { return t_id; } \
+    static std::string static_type_name (void) { return t_name; } \
+    static std::string static_class_name (void) { return c_name; } \
+    static void register_type (void); \
+ \
+  private: \
+    static int t_id; \
+    static const std::string t_name; \
+    static const std::string c_name;
+
+
+#define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
+  int t::t_id (-1); \
+  const std::string t::t_name (n); \
+  const std::string t::c_name (c); \
+  void t::register_type (void) \
+    { \
+      t_id = octave_value_typeinfo::register_type (t::t_name, \
+						   t::c_name, \
+						   octave_value (new t ())); \
+    }
+
+// Should we print a warning when converting `[97, 98, 99, "123"]'
+// to a character string?
+extern bool Vwarn_num_to_str;
+
+// If TRUE, print a warning when a matrix is resized by an indexed
+// assignment with indices outside the current bounds.
+extern bool Vwarn_resize_on_range_error;
+
 // A base value type, so that derived types only have to redefine what
 // they need (if they are derived from octave_base_value instead of
 // octave_value).
 
 class
-octave_base_value : public octave_value
+octave_base_value
 {
 public:
 
-  octave_base_value (void)
-    : octave_value (octave_xvalue ()) { }
+  typedef octave_base_value * (*type_conv_fcn) (const octave_base_value&);
+
+  friend class octave_value;
 
-  octave_base_value (const octave_base_value&)
-    : octave_value (octave_xvalue ()) { }
+  octave_base_value (void) : count (1) { }
+
+  octave_base_value (const octave_base_value&) { }
 
-  ~octave_base_value (void) { }
+  virtual ~octave_base_value (void) { }
+
+  virtual octave_base_value *
+  clone (void) const { return new octave_base_value (*this); }
 
-  octave_value *clone (void) const { return new octave_base_value (*this); }
-  octave_value *empty_clone (void) const { return new octave_base_value (); }
+  virtual octave_base_value *
+  empty_clone (void) const { return new octave_base_value (); }
 
-  type_conv_fcn numeric_conversion_function (void) const
+  virtual type_conv_fcn
+  numeric_conversion_function (void) const
     { return static_cast<type_conv_fcn> (0); }
 
-  octave_value squeeze (void) const;
+  virtual octave_value squeeze (void) const;
+
+  virtual octave_base_value *try_narrowing_conversion (void) { return 0; }
 
-  octave_value *try_narrowing_conversion (void)
-    { return static_cast<octave_value *> (0); }
-
-  octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx);
+  virtual octave_value
+  subsref (const std::string& type,
+	   const std::list<octave_value_list>& idx);
 
-  octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
+  virtual octave_value_list
+  subsref (const std::string& type,
+	   const std::list<octave_value_list>& idx,
+	   int nargout);
 
-  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
+  virtual octave_value
+  do_index_op (const octave_value_list& idx, int resize_ok);
 
-  octave_value do_index_op (const octave_value_list& idx)
-    { return do_index_op (idx, 0); }
+  virtual octave_value
+  do_index_op (const octave_value_list& idx);
 
-  octave_value_list
+  virtual octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
-  idx_vector index_vector (void) const;
+  virtual octave_value
+  subsasgn (const std::string& type,
+	    const std::list<octave_value_list>& idx,
+	    const octave_value& rhs);
 
-  octave_value subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs);
+  virtual idx_vector index_vector (void) const;
 
-  dim_vector dims (void) const { return dim_vector (-1, -1); }
+  virtual dim_vector dims (void) const { return dim_vector (-1, -1); }
 
-  octave_idx_type numel (void) const { return dims ().numel (); }
-
-  octave_idx_type capacity (void) const { return numel (); }
+  octave_idx_type rows (void) const
+    {
+      dim_vector dv = dims ();
 
-  size_t byte_size (void) const { return 0; }
+      return (dv.length () > 0) ? dv(0) : -1;
+    }
 
-  octave_idx_type nnz (void) const;
+  octave_idx_type columns (void) const
+    {
+      dim_vector dv = dims ();
 
-  octave_idx_type nzmax (void) const;
+      return (dv.length () > 1) ? dv(1) : -1;
+    }
 
-  octave_value reshape (const dim_vector&) const;
+  virtual int ndims (void) const;
 
-  octave_value permute (const Array<int>& vec, bool = false) const;
+  virtual octave_idx_type numel (void) const { return dims ().numel (); }
 
-  octave_value resize (const dim_vector&, bool fill = false) const;
+  virtual octave_idx_type capacity (void) const { return numel (); }
+
+  virtual size_t byte_size (void) const { return 0; }
 
-  bool is_defined (void) const { return false; }
+  virtual octave_idx_type nnz (void) const;
 
-  bool is_cell (void) const { return false; }
+  virtual octave_idx_type nzmax (void) const;
+
+  virtual octave_value reshape (const dim_vector&) const;
 
-  bool is_real_scalar (void) const { return false; }
+  virtual octave_value permute (const Array<int>& vec, bool = false) const;
 
-  bool is_real_matrix (void) const { return false; }
+  virtual octave_value resize (const dim_vector&, bool fill = false) const;
 
-  bool is_real_nd_array (void) const { return false; }
+  virtual bool is_defined (void) const { return false; }
 
-  bool is_complex_scalar (void) const { return false; }
+  bool is_empty (void) const { return numel () == 0; }
 
-  bool is_complex_matrix (void) const { return false; }
+  virtual bool is_cell (void) const { return false; }
 
-  bool is_bool_matrix (void) const { return false; }
+  virtual bool is_real_scalar (void) const { return false; }
 
-  bool is_char_matrix (void) const { return false; }
+  virtual bool is_real_matrix (void) const { return false; }
+
+  virtual bool is_real_nd_array (void) const { return false; }
 
-  bool is_string (void) const { return false; }
+  virtual bool is_complex_scalar (void) const { return false; }
 
-  bool is_sq_string (void) const { return false; }
+  virtual bool is_complex_matrix (void) const { return false; }
+
+  virtual bool is_bool_matrix (void) const { return false; }
 
-  bool is_range (void) const { return false; }
+  virtual bool is_char_matrix (void) const { return false; }
 
-  bool is_map (void) const { return false; }
+  virtual bool is_string (void) const { return false; }
 
-  bool is_streamoff (void) const { return false; }
+  virtual bool is_sq_string (void) const { return false; }
 
-  bool is_cs_list (void) const { return false; }
+  virtual bool is_range (void) const { return false; }
 
-  bool is_list (void) const { return false; }
+  virtual bool is_map (void) const { return false; }
+
+  virtual bool is_streamoff (void) const { return false; }
 
-  bool is_magic_colon (void) const { return false; }
+  virtual bool is_cs_list (void) const { return false; }
 
-  bool is_all_va_args (void) const { return false; }
+  virtual bool is_list (void) const { return false; }
+
+  virtual bool is_magic_colon (void) const { return false; }
 
-  octave_value all (int = 0) const { return 0.0; }
+  virtual bool is_all_va_args (void) const { return false; }
 
-  octave_value any (int = 0) const { return 0.0; }
+  virtual octave_value all (int = 0) const;
+
+  virtual octave_value any (int = 0) const;
 
-  bool is_bool_type (void) const { return false; }
+  virtual bool is_bool_type (void) const { return false; }
 
-  bool is_real_type (void) const { return false; }
+  virtual bool is_real_type (void) const { return false; }
 
-  bool is_complex_type (void) const { return false; }
+  virtual bool is_complex_type (void) const { return false; }
 
   // Would be nice to get rid of the next four functions:
 
-  bool is_scalar_type (void) const { return false; }
+  virtual bool is_scalar_type (void) const { return false; }
 
-  bool is_matrix_type (void) const { return false; }
+  virtual bool is_matrix_type (void) const { return false; }
 
-  bool is_numeric_type (void) const { return false; }
+  virtual bool is_numeric_type (void) const { return false; }
 
-  bool is_sparse_type (void) const { return false; }
+  virtual bool is_sparse_type (void) const { return false; }
 
-  bool valid_as_scalar_index (void) const { return false; }
+  virtual bool valid_as_scalar_index (void) const { return false; }
 
-  bool valid_as_zero_index (void) const { return false; }
+  virtual bool valid_as_zero_index (void) const { return false; }
 
-  bool is_true (void) const { return false; }
+  virtual bool is_true (void) const { return false; }
+
+  virtual bool is_constant (void) const { return false; }
 
-  bool is_zero_by_zero (void) const
-    { return (rows () == 0 && columns () == 0); }
+  virtual bool is_function_handle (void) const { return false; }
 
-  bool is_constant (void) const { return false; }
+  virtual bool is_inline_function (void) const { return false; }
 
-  bool is_function_handle (void) const { return false; }
-
-  bool is_inline_function (void) const { return false; }
+  virtual bool is_function (void) const { return false; }
 
-  bool is_function (void) const { return false; }
+  virtual bool is_builtin_function (void) const { return false; }
 
-  bool is_builtin_function (void) const { return false; }
-
-  bool is_dld_function (void) const { return false; }
+  virtual bool is_dld_function (void) const { return false; }
 
-  short int short_value (bool = false, bool = false) const;
+  virtual short int short_value (bool = false, bool = false) const;
 
-  unsigned short int ushort_value (bool = false, bool = false) const;
+  virtual unsigned short int ushort_value (bool = false, bool = false) const;
 
-  int int_value (bool = false, bool = false) const;
+  virtual int int_value (bool = false, bool = false) const;
 
-  unsigned int uint_value (bool = false, bool = false) const;
+  virtual unsigned int uint_value (bool = false, bool = false) const;
 
-  int nint_value (bool = false) const;
+  virtual int nint_value (bool = false) const;
 
-  long int long_value (bool = false, bool = false) const;
+  virtual long int long_value (bool = false, bool = false) const;
 
-  unsigned long int ulong_value (bool = false, bool = false) const;
+  virtual unsigned long int ulong_value (bool = false, bool = false) const;
 
-  double double_value (bool = false) const;
+  virtual double double_value (bool = false) const;
 
-  double scalar_value (bool frc_str_conv = false) const
+  virtual double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
 
-  Cell cell_value (void) const;
+  virtual Cell cell_value (void) const;
 
-  Matrix matrix_value (bool = false) const;
+  virtual Matrix matrix_value (bool = false) const;
 
-  NDArray array_value (bool = false) const;
+  virtual NDArray array_value (bool = false) const;
 
-  Complex complex_value (bool = false) const;
+  virtual Complex complex_value (bool = false) const;
 
-  ComplexMatrix complex_matrix_value (bool = false) const;
+  virtual ComplexMatrix complex_matrix_value (bool = false) const;
 
-  ComplexNDArray complex_array_value (bool = false) const;
+  virtual ComplexNDArray complex_array_value (bool = false) const;
 
-  bool bool_value (void) const;
+  virtual bool bool_value (void) const;
 
-  boolMatrix bool_matrix_value (void) const;
+  virtual boolMatrix bool_matrix_value (void) const;
 
-  boolNDArray bool_array_value (void) const;
+  virtual boolNDArray bool_array_value (void) const;
 
-  charMatrix char_matrix_value (bool force = false) const;
+  virtual charMatrix char_matrix_value (bool force = false) const;
+
+  virtual charNDArray char_array_value (bool = false) const;
 
-  charNDArray char_array_value (bool = false) const;
+  virtual SparseMatrix sparse_matrix_value (bool = false) const;
 
-  SparseMatrix sparse_matrix_value (bool = false) const;
+  virtual SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
-  SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
+  virtual SparseBoolMatrix sparse_bool_matrix_value (bool = false) const;
 
-  SparseBoolMatrix sparse_bool_matrix_value (bool = false) const;
+  virtual octave_int8 int8_scalar_value (void) const;
 
-  octave_int8 int8_scalar_value (void) const;
+  virtual octave_int16 int16_scalar_value (void) const;
 
-  octave_int16 int16_scalar_value (void) const;
+  virtual octave_int32 int32_scalar_value (void) const;
+
+  virtual octave_int64 int64_scalar_value (void) const;
 
-  octave_int32 int32_scalar_value (void) const;
+  virtual octave_uint8 uint8_scalar_value (void) const;
 
-  octave_int64 int64_scalar_value (void) const;
+  virtual octave_uint16 uint16_scalar_value (void) const;
 
-  octave_uint8 uint8_scalar_value (void) const;
+  virtual octave_uint32 uint32_scalar_value (void) const;
 
-  octave_uint16 uint16_scalar_value (void) const;
+  virtual octave_uint64 uint64_scalar_value (void) const;
 
-  octave_uint32 uint32_scalar_value (void) const;
+  virtual int8NDArray int8_array_value (void) const;
 
-  octave_uint64 uint64_scalar_value (void) const;
+  virtual int16NDArray int16_array_value (void) const;
 
-  int8NDArray int8_array_value (void) const;
+  virtual int32NDArray int32_array_value (void) const;
 
-  int16NDArray int16_array_value (void) const;
+  virtual int64NDArray int64_array_value (void) const;
 
-  int32NDArray int32_array_value (void) const;
+  virtual uint8NDArray uint8_array_value (void) const;
 
-  int64NDArray int64_array_value (void) const;
+  virtual uint16NDArray uint16_array_value (void) const;
 
-  uint8NDArray uint8_array_value (void) const;
+  virtual uint32NDArray uint32_array_value (void) const;
 
-  uint16NDArray uint16_array_value (void) const;
+  virtual uint64NDArray uint64_array_value (void) const;
 
-  uint32NDArray uint32_array_value (void) const;
+  virtual string_vector all_strings (bool pad = false) const;
 
-  uint64NDArray uint64_array_value (void) const;
+  virtual std::string string_value (bool force = false) const;
 
-  string_vector all_strings (bool pad = false) const;
+  virtual Range range_value (void) const;
 
-  std::string string_value (bool force = false) const;
+  virtual Octave_map map_value (void) const;
 
-  Range range_value (void) const;
+  virtual string_vector map_keys (void) const;
 
-  Octave_map map_value (void) const;
+  virtual std::streamoff streamoff_value (void) const;
 
-  string_vector map_keys (void) const;
+  virtual streamoff_array streamoff_array_value (void) const;
+
+  virtual octave_function *function_value (bool silent = false);
 
-  std::streamoff streamoff_value (void) const;
+  virtual octave_user_function *user_function_value (bool silent = false);
 
-  streamoff_array streamoff_array_value (void) const;
+  virtual octave_fcn_handle *fcn_handle_value (bool silent = false);
 
-  octave_function *function_value (bool silent = false);
+  virtual octave_fcn_inline *fcn_inline_value (bool silent = false);
 
-  octave_user_function *user_function_value (bool silent = false);
-
-  octave_fcn_handle *fcn_handle_value (bool silent = false);
+  virtual octave_value_list list_value (void) const;
 
-  octave_fcn_inline *fcn_inline_value (bool silent = false);
+  virtual octave_value convert_to_str (bool pad = false, bool force = false,
+				       char type = '"') const;
+  virtual octave_value
+  convert_to_str_internal (bool pad, bool force, char type) const;
 
-  octave_value_list list_value (void) const;
+  virtual void convert_to_row_or_column_vector (void);
 
-  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
+  virtual bool print_as_scalar (void) const { return false; }
 
-  void convert_to_row_or_column_vector (void);
+  virtual void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_as_scalar (void) const { return false; }
+  virtual void
+  print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
+  virtual bool
+  print_name_tag (std::ostream& os, const std::string& name) const;
 
-  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
-
-  bool print_name_tag (std::ostream& os, const std::string& name) const;
+  virtual void
+  print_with_name (std::ostream& output_buf, const std::string& name, 
+		   bool print_padding = true) const;
 
-  void print_info (std::ostream& os, const std::string& prefix) const;
+  virtual void print_info (std::ostream& os, const std::string& prefix) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
+  virtual bool save_ascii (std::ostream& os, bool& infnan_warned,
 			   bool strip_nan_and_inf);
 
-  bool load_ascii (std::istream& is);
+  virtual bool load_ascii (std::istream& is);
 
-  bool save_binary (std::ostream& os, bool& save_as_floats);
+  virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
-		    oct_mach_info::float_format fmt);
+  virtual bool load_binary (std::istream& is, bool swap, 
+			    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  virtual bool
+  save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  virtual bool
+  load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
-  int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
-	     oct_mach_info::float_format flt_fmt) const;
+  virtual int
+  write (octave_stream& os, int block_size,
+	 oct_data_conv::data_type output_type, int skip,
+	 oct_mach_info::float_format flt_fmt) const;
+
+protected:
+
+  // This should only be called for derived types.
+
+  octave_value numeric_assign (const std::string& type,
+			       const std::list<octave_value_list>& idx,
+			       const octave_value& rhs);
+
+  void reset_indent_level (void) const
+    { curr_print_indent_level = 0; }
+
+  void increment_indent_level (void) const
+    { curr_print_indent_level += 2; }
+
+  void decrement_indent_level (void) const
+    { curr_print_indent_level -= 2; }
+
+  int current_print_indent_level (void) const
+    { return curr_print_indent_level; }
+
+  void indent (std::ostream& os) const;
+
+  void newline (std::ostream& os) const;
+
+  void reset (void) const;
+
+  // A reference count.
+  int count;
 
 private:
 
-  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+  static int curr_print_indent_level;
+  static bool beginning_of_line;
+
+  DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -49,34 +49,34 @@ 02110-1301, USA.
 
 template class octave_base_matrix<boolNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_bool_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool_matrix,
 				     "bool matrix", "logical");
 
-static octave_value *
-default_numeric_conversion_function (const octave_value& a)
+static octave_base_value *
+default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_bool_matrix&);
 
   return new octave_matrix (NDArray (v.bool_array_value ()));
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_bool_matrix::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
-octave_value *
+octave_base_value *
 octave_bool_matrix::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   if (matrix.ndims () == 2)
     {
       boolMatrix bm = matrix.matrix_value ();
 
       octave_idx_type nr = bm.rows ();
       octave_idx_type nc = bm.cols ();
 
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -62,22 +62,22 @@ public:
   octave_bool_matrix (const Array2<bool>& a)
     : octave_base_matrix<boolNDArray> (a) { }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   ~octave_bool_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_bool_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_bool_matrix (); }
+  octave_base_value *clone (void) const { return new octave_bool_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_bool_matrix (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -44,34 +44,34 @@ Boston, MA 02110-1301, USA.
 #include "ov-base-sparse.cc"
 
 template class octave_base_sparse<SparseBoolMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_sparse_bool_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_bool_matrix, "sparse bool matrix", "sparse");
 
-static octave_value *
-default_numeric_conversion_function (const octave_value& a)
+static octave_base_value *
+default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_sparse_bool_matrix&);
 
   return new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_sparse_bool_matrix::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
-octave_value *
+octave_base_value *
 octave_sparse_bool_matrix::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   // Don't use numel, since it can overflow for very large matrices
   // Note that for the second test, this means it becomes approximative
   // since it involves a cast to double to avoid issues of overflow
   if (matrix.rows () == 1 && matrix.cols () == 1)
     {
       // Const copy of the matrix, so the right version of () operator used
       const SparseBoolMatrix tmp (matrix);
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -71,22 +71,22 @@ public:
   octave_sparse_bool_matrix (const Sparse<bool>& a)
     : octave_base_sparse<SparseBoolMatrix> (a) { }
 
   octave_sparse_bool_matrix (const octave_sparse_bool_matrix& bm)
     : octave_base_sparse<SparseBoolMatrix> (bm) { }
 
   ~octave_sparse_bool_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_sparse_bool_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_sparse_bool_matrix (); }
+  octave_base_value *clone (void) const { return new octave_sparse_bool_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_sparse_bool_matrix (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   // XXX FIXME XXX Adapt idx_vector to allow sparse logical indexing!!
   idx_vector index_vector (void) const 
     { return idx_vector (bool_array_value ()); }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -45,25 +45,25 @@ 02110-1301, USA.
 #include "ls-hdf5.h"
 
 template class octave_base_scalar<bool>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_bool);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool, "bool", "logical");
 
-static octave_value *
-default_numeric_conversion_function (const octave_value& a)
+static octave_base_value *
+default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_bool&);
 
   return new octave_scalar (v.bool_value ());
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_bool::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
 static inline bool
 valid_scalar_indices (const octave_value_list& args)
 {
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -57,18 +57,18 @@ public:
   octave_bool (bool b)
     : octave_base_scalar<bool> (b) { }
 
   octave_bool (const octave_bool& s)
     : octave_base_scalar<bool> (s) { }
 
   ~octave_bool (void) { }
 
-  octave_value *clone (void) const { return new octave_bool (*this); }
-  octave_value *empty_clone (void) const { return new octave_bool (); }
+  octave_base_value *clone (void) const { return new octave_bool (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_bool (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   bool is_real_scalar (void) const { return true; }
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -208,27 +208,29 @@ octave_cell::subsasgn (const std::string
 	    if (t_rhs.is_cell ())
 	      octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
 	    else
 	      if (t_rhs.is_empty ())
 		octave_base_matrix<Cell>::assign (i, Cell());
 	      else
 		octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
-	    retval = octave_value (this, count + 1);
+	    count++;
+	    retval = octave_value (this);
 	  }
 	  break;
 
 	case '{':
 	  {
 	    octave_value_list i = idx.front ();
 
 	    octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
-	    retval = octave_value (this, count + 1);
+	    count++;
+	    retval = octave_value (this);
 	  }
 	  break;
 
 	case '.':
 	  {
 	    std::string nm = type_name ();
 	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
 	  }
@@ -509,17 +511,17 @@ octave_cell::load_ascii (std::istream& i
 
 	      for (octave_idx_type i = 0; i < dv.numel (); i++)
 		{
 		  octave_value t2;
 		  bool dummy;
 
 		  // recurse to read cell elements
 		  std::string nm = read_ascii_data (is, std::string (), 
-						    dummy, t2, count);
+						    dummy, t2, i);
 
 		  if (nm == CELL_ELT_TAG)
 		    {
 		      if (is)
 			tmp.elem (i) = t2;
 		    }
 		  else
 		    {
@@ -558,17 +560,17 @@ octave_cell::load_ascii (std::istream& i
 		    {
 		      for (octave_idx_type i = 0; i < nr; i++)
 			{
 			  octave_value t2;
 			  bool dummy;
 
 			  // recurse to read cell elements
 			  std::string nm = read_ascii_data (is, std::string (),
-							    dummy, t2, count);
+							    dummy, t2, i);
 
 			  if (nm == CELL_ELT_TAG)
 			    {
 			      if (is)
 				tmp.elem (i, j) = t2;
 			    }
 			  else
 			    {
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -58,21 +58,21 @@ public:
 
   octave_cell (const octave_cell& c)
     : octave_base_matrix<Cell> (c) { }
 
   ~octave_cell (void) { }
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
-  octave_value *clone (void) const { return new octave_cell (*this); }
-  octave_value *empty_clone (void) const { return new octave_cell (); }
+  octave_base_value *clone (void) const { return new octave_cell (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_cell (); }
 
 #if 0
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 #endif
 
   octave_value subsref (const std::string&,
 			const std::list<octave_value_list>&)
     {
       panic_impossible ();
       return octave_value_list ();
     }
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -72,18 +72,18 @@ public:
   octave_char_matrix (const string_vector& s)
     : octave_base_matrix<charNDArray> (s) { }
 
   octave_char_matrix (const octave_char_matrix& chm)
     : octave_base_matrix<charNDArray> (chm) { }
 
   ~octave_char_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_char_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_char_matrix (); }
+  octave_base_value *clone (void) const { return new octave_char_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_char_matrix (); }
 
   idx_vector index_vector (void) const
     { return idx_vector (array_value (true)); }
 
   bool is_char_matrix (void) const { return true; }
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -51,18 +51,18 @@ public:
   octave_magic_colon (void)
     : octave_base_value () { }
 
   octave_magic_colon (const octave_magic_colon&)
     : octave_base_value () { }
 
   ~octave_magic_colon (void) { }
 
-  octave_value *clone (void) const { return new octave_magic_colon (*this); }
-  octave_value *empty_clone (void) const { return new octave_magic_colon (); }
+  octave_base_value *clone (void) const { return new octave_magic_colon (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_magic_colon (); }
 
   idx_vector index_vector (void) const { return idx_vector (':'); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_magic_colon (void) const { return true; }
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -46,20 +46,20 @@ 02110-1301, USA.
 
 template class octave_base_scalar<Complex>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_complex);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex,
 				     "complex scalar", "double");
 
-octave_value *
+octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   double im = std::imag (scalar);
 
   if (im == 0.0 && ! lo_ieee_signbit (im))
     retval = new octave_scalar (real (scalar));
 
   return retval;
 }
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -59,26 +59,26 @@ public:
   octave_complex (const Complex& c)
     : octave_base_scalar<Complex> (c) { }
 
   octave_complex (const octave_complex& c)
     : octave_base_scalar<Complex> (c) { }
 
   ~octave_complex (void) { }
 
-  octave_value *clone (void) const { return new octave_complex (*this); }
+  octave_base_value *clone (void) const { return new octave_complex (*this); }
 
   // We return an octave_complex_matrix object here instead of an
   // octave_complex object so that in expressions like A(2,2,2) = 2
   // (for A previously undefined), A will be empty instead of a 1x1
   // object.
-  octave_value *empty_clone (void) const
+  octave_base_value *empty_clone (void) const
     { return new octave_complex_matrix (); }
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value any (int = 0) const
     {
       return (scalar != Complex (0, 0)
 	      && ! (lo_ieee_isnan (OCTAVE_STD::real (scalar))
 		    || lo_ieee_isnan (OCTAVE_STD::imag (scalar))));
diff --git a/src/ov-cs-list.h b/src/ov-cs-list.h
--- a/src/ov-cs-list.h
+++ b/src/ov-cs-list.h
@@ -52,22 +52,22 @@ public:
     : octave_base_value (), lst () { }
 
   octave_cs_list (const octave_value_list& l)
     : octave_base_value (), lst (l) { }
 
   octave_cs_list (const Cell& c);
 
   octave_cs_list (const octave_cs_list& l)
-    : octave_base_value (), lst (l) { }
+    : octave_base_value (), lst (l.lst) { }
 
   ~octave_cs_list (void) { }
 
-  octave_value *clone (void) const { return new octave_cs_list (*this); }
-  octave_value *empty_clone (void) const { return new octave_cs_list (); }
+  octave_base_value *clone (void) const { return new octave_cs_list (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_cs_list (); }
 
   dim_vector dims (void) const { return dim_vector (1, lst.length ()); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_cs_list (void) const { return true; }
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -53,20 +53,20 @@ 02110-1301, USA.
 
 template class octave_base_matrix<ComplexNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_complex_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_matrix,
 				     "complex matrix", "double");
 
-octave_value *
+octave_base_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   if (matrix.ndims () == 2)
     {
       ComplexMatrix cm = matrix.matrix_value ();
 
       octave_idx_type nr = cm.rows ();
       octave_idx_type nc = cm.cols ();
 
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -72,20 +72,20 @@ public:
   octave_complex_matrix (const ComplexColumnVector& v)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (v)) { }
 
   octave_complex_matrix (const octave_complex_matrix& cm)
     : octave_base_matrix<ComplexNDArray> (cm) { }
 
   ~octave_complex_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_complex_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_complex_matrix (); }
+  octave_base_value *clone (void) const { return new octave_complex_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_complex_matrix (); }
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   void assign (const octave_value_list& idx, const ComplexNDArray& rhs);
 
   void assign (const octave_value_list& idx, const NDArray& rhs);
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -43,20 +43,20 @@ Boston, MA 02110-1301, USA.
 #include "ov-bool-sparse.h"
 
 template class octave_base_sparse<SparseComplexMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_sparse_complex_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_complex_matrix, "sparse complex matrix", "sparse");
 
-octave_value *
+octave_base_value *
 octave_sparse_complex_matrix::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   int nr = matrix.rows ();
   int nc = matrix.cols ();
 
   // Don't use numel, since it can overflow for very large matrices
   // Note that for the tests on matrix size, they become approximative
   // since they involves a cast to double to avoid issues of overflow
   if (matrix.rows () == 1 && matrix.cols () == 1)
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -72,20 +72,20 @@ public:
   octave_sparse_complex_matrix (const MSparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
 
   ~octave_sparse_complex_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_sparse_complex_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_sparse_complex_matrix (); }
+  octave_base_value *clone (void) const { return new octave_sparse_complex_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_sparse_complex_matrix (); }
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   void assign (const octave_value_list& idx, const SparseComplexMatrix& rhs);
 
   void assign (const octave_value_list& idx, const SparseMatrix& rhs);
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -50,18 +50,18 @@ public:
     : warn_reload (true), fcn (f), nm (n) { }
 
   octave_fcn_handle (const octave_fcn_handle& fh)
     : octave_base_value (fh), warn_reload (fh.warn_reload),
       fcn (fh.fcn), nm (fh.nm) { }
 
   ~octave_fcn_handle (void) { }
 
-  octave_value *clone (void) const { return new octave_fcn_handle (*this); }
-  octave_value *empty_clone (void) const { return new octave_fcn_handle (); }
+  octave_base_value *clone (void) const { return new octave_fcn_handle (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_fcn_handle (); }
 
   octave_value subsref (const std::string&,
 			const std::list<octave_value_list>&)
     {
       panic_impossible ();
       return octave_value ();
     }
 
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -47,18 +47,18 @@ public:
   octave_fcn_inline (const std::string& f, const string_vector& a, 
 		     const std::string& n = std::string ());
 
   octave_fcn_inline (const octave_fcn_inline& fi)
     : octave_fcn_handle (fi), iftext (fi.iftext), ifargs (fi.ifargs) { }
 
   ~octave_fcn_inline (void) { }
 
-  octave_value *clone (void) const { return new octave_fcn_inline (*this); }
-  octave_value *empty_clone (void) const { return new octave_fcn_inline (); }
+  octave_base_value *clone (void) const { return new octave_fcn_inline (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_fcn_inline (); }
 
   bool is_inline_function (void) const { return true; }
 
   octave_fcn_inline *fcn_inline_value (bool = false) { return this; }
 
   std::string fcn_text (void) const { return iftext; }
 
   string_vector fcn_arg_names (void) const { return ifargs; }
diff --git a/src/ov-fcn.cc b/src/ov-fcn.cc
--- a/src/ov-fcn.cc
+++ b/src/ov-fcn.cc
@@ -26,24 +26,24 @@ 02110-1301, USA.
 #endif
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_function);
 
-octave_value *
+octave_base_value *
 octave_function::clone (void) const
 {
   panic_impossible ();
   return 0;
 }
 
-octave_value *
+octave_base_value *
 octave_function::empty_clone (void) const
 {
   panic_impossible ();
   return 0;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -42,18 +42,18 @@ class
 octave_function : public octave_base_value
 {
 public:
 
   octave_function (void) { }
 
   ~octave_function (void) { }
 
-  octave_value *clone (void) const;
-  octave_value *empty_clone (void) const;
+  octave_base_value *clone (void) const;
+  octave_base_value *empty_clone (void) const;
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_dynamically_loaded_function (void) const { return false; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -47,20 +47,20 @@ public:
   OCTAVE_VALUE_INT_MATRIX_T (void)
     : octave_base_int_matrix<OCTAVE_INT_NDARRAY_T> () { }
 
   OCTAVE_VALUE_INT_MATRIX_T (const OCTAVE_INT_NDARRAY_T& nda)
     : octave_base_int_matrix<OCTAVE_INT_NDARRAY_T> (nda) { }
 
   ~OCTAVE_VALUE_INT_MATRIX_T (void) { }
 
-  octave_value *clone (void) const
+  octave_base_value *clone (void) const
     { return new OCTAVE_VALUE_INT_MATRIX_T (*this); }
 
-  octave_value *empty_clone (void) const
+  octave_base_value *empty_clone (void) const
     { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (matrix); }
 
   int16NDArray
   int16_array_value (void) const { return int16NDArray (matrix); }
 
@@ -160,20 +160,20 @@ public:
   OCTAVE_VALUE_INT_SCALAR_T (void)
     : octave_base_int_scalar<OCTAVE_INT_T> () { }
 
   OCTAVE_VALUE_INT_SCALAR_T (const OCTAVE_INT_T& nda)
     : octave_base_int_scalar<OCTAVE_INT_T> (nda) { }
 
   ~OCTAVE_VALUE_INT_SCALAR_T (void) { }
 
-  octave_value *clone (void) const
+  octave_base_value *clone (void) const
     { return new OCTAVE_VALUE_INT_SCALAR_T (*this); }
 
-  octave_value *empty_clone (void) const
+  octave_base_value *empty_clone (void) const
     { return new OCTAVE_VALUE_INT_SCALAR_T (); }
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok)
     {
       octave_value retval;
 
       if (idx.valid_scalar_indices ())
 	retval = scalar;
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -126,19 +126,19 @@ octave_list::subsref (const std::string&
 
 octave_value
 octave_list::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (idx.length () == 1)
     {
-      idx_vector i = idx (0).index_vector ();
+      idx_vector iidx = idx (0).index_vector ();
 
-      Cell tcell = data.index (i, resize_ok);
+      Cell tcell = data.index (iidx, resize_ok);
 
       octave_value_list result;
 
       octave_idx_type n = tcell.numel ();
 
       result.resize (n);
 
       for (octave_idx_type i = 0; i < n; i++)
@@ -208,17 +208,18 @@ octave_list::subsasgn (const std::string
 
 	    octave_idx_type len = i.length ();
 
 	    for (octave_idx_type k = 0; k < len; k++)
 	      data.set_index (i(k).index_vector ());
 
 	    ::assign (data, Cell (t_rhs), Cell::resize_fill_value ());
 
-	    retval = octave_value (this, count + 1);
+	    count++;
+	    retval = octave_value (this);
 	  }
 	  break;
 
 	case '{':
 	case '.':
 	  {
 	    std::string nm = type_name ();
 	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -55,18 +55,18 @@ public:
 
   octave_list (const Cell& c);
 
   octave_list (const octave_list& l)
     : octave_base_value (), data (l.data) { }
 
   ~octave_list (void) { }
 
-  octave_value *clone (void) const { return new octave_list (*this); }
-  octave_value *empty_clone (void) const { return new octave_list (); }
+  octave_base_value *clone (void) const { return new octave_list (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_list (); }
 
   octave_value subsref (const std::string&,
 			const std::list<octave_value_list>&)
     {
       panic_impossible ();
       return octave_value_list ();
     }
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -41,34 +41,34 @@ 02110-1301, USA.
 #include "byte-swap.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_range);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_range, "range", "double");
 
-static octave_value *
-default_numeric_conversion_function (const octave_value& a)
+static octave_base_value *
+default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_range&);
 
   return new octave_matrix (v.matrix_value ());
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_range::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
-octave_value *
+octave_base_value *
 octave_range::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   switch (range.nelem ())
     {
     case 1:
       retval = new octave_scalar (range.base ());
       break;
 
     case 0:
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -71,22 +71,22 @@ public:
 	  ::error ("invalid range");
       }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range) { }
 
   ~octave_range (void) { }
 
-  octave_value *clone (void) const { return new octave_range (*this); }
-  octave_value *empty_clone (void) const { return new octave_range (); }
+  octave_base_value *clone (void) const { return new octave_range (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_range (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string&,
 			     const std::list<octave_value_list>&, int)
     {
       panic_impossible ();
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -62,20 +62,20 @@ 02110-1301, USA.
 #endif
 
 template class octave_base_matrix<NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_matrix, "matrix", "double");
 
-octave_value *
+octave_base_value *
 octave_matrix::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
     retval = new octave_scalar (matrix (0));
 
   return retval;
 }
 
 bool
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -73,20 +73,20 @@ public:
   octave_matrix (const ColumnVector& v)
     : octave_base_matrix<NDArray> (Matrix (v)) { }
 
   octave_matrix (const octave_matrix& m)
     : octave_base_matrix<NDArray> (m) { }
 
   ~octave_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_matrix (); }
+  octave_base_value *clone (void) const { return new octave_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const;
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -56,20 +56,20 @@ octave_sparse_matrix::index_vector (void
   else
     {
       std::string nm = type_name ();
       error ("%s type invalid as index value", nm.c_str ());
       return idx_vector ();
     }
 }
 
-octave_value *
+octave_base_value *
 octave_sparse_matrix::try_narrowing_conversion (void)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   // Don't use numel, since it can overflow for very large matrices
   // Note that for the second test, this means it becomes approximative
   // since it involves a cast to double to avoid issues of overflow
   if (matrix.rows () == 1 && matrix.cols () == 1)
     {
       // Const copy of the matrix, so the right version of () operator used
       const SparseMatrix tmp (matrix);
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -72,20 +72,20 @@ public:
   octave_sparse_matrix (const MSparse<double>& m)
     : octave_base_sparse<SparseMatrix> (m) { }
     
   octave_sparse_matrix (const octave_sparse_matrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
   ~octave_sparse_matrix (void) { }
 
-  octave_value *clone (void) const { return new octave_sparse_matrix (*this); }
-  octave_value *empty_clone (void) const { return new octave_sparse_matrix (); }
+  octave_base_value *clone (void) const { return new octave_sparse_matrix (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_sparse_matrix (); }
 
-  octave_value *try_narrowing_conversion (void);
+  octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const;
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const;
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -59,22 +59,22 @@ public:
   octave_scalar (double d)
     : octave_base_scalar<double> (d) { }
 
   octave_scalar (const octave_scalar& s)
     : octave_base_scalar<double> (s) { }
 
   ~octave_scalar (void) { }
 
-  octave_value *clone (void) const { return new octave_scalar (*this); }
+  octave_base_value *clone (void) const { return new octave_scalar (*this); }
 
   // We return an octave_matrix here instead of an octave_scalar so
   // that in expressions like A(2,2,2) = 2 (for A previously
   // undefined), A will be empty instead of a 1x1 object.
-  octave_value *empty_clone (void) const { return new octave_matrix (); }
+  octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   octave_value any (int = 0) const
     { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -55,39 +55,39 @@ DEFINE_OCTAVE_ALLOCATOR (octave_char_mat
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_str, "string", "char");
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string", "char");
 
 // If TRUE, warn for operations like
 //
 //   octave> 'abc' + 0
 //   97 98 99
 //
-static bool Vwarn_str_to_num;
+static int Vwarn_str_to_num;
 
-static octave_value *
-default_numeric_conversion_function (const octave_value& a)
+static octave_base_value *
+default_numeric_conversion_function (const octave_base_value& a)
 {
-  octave_value *retval = 0;
+  octave_base_value *retval = 0;
 
   CAST_CONV_ARG (const octave_char_matrix_str&);
 
   NDArray nda = v.array_value (true);
 
   if (! error_state)
     {
       if (nda.numel () == 1)
 	retval = new octave_scalar (nda(0));
       else
 	retval = new octave_matrix (nda);
     }
 
   return retval;
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_char_matrix_str::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
 octave_value
 octave_char_matrix_str::do_index_op_internal (const octave_value_list& idx,
 					      int resize_ok, char type)
@@ -787,14 +787,13 @@ For example,\n\
      @result{} 97 98 99\n\
 @end group\n\
 @end example\n\
 elicits a warning if @code{warn_str_to_num} is nonzero.  The default\n\
 value is 0.\n\
 @end defvr");
 }
 
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -75,18 +75,18 @@ public:
   octave_char_matrix_str (const octave_char_matrix& chm)
     : octave_char_matrix (chm) { }
 
   octave_char_matrix_str (const octave_char_matrix_str& chms)
     : octave_char_matrix (chms) { }
 
   ~octave_char_matrix_str (void) { }
 
-  octave_value *clone (void) const { return new octave_char_matrix_str (*this); }
-  octave_value *empty_clone (void) const { return new octave_char_matrix_str (); }
+  octave_base_value *clone (void) const { return new octave_char_matrix_str (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_char_matrix_str (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok)
     { return do_index_op_internal (idx, resize_ok); }
 
   void assign (const octave_value_list& idx, const charMatrix& rhs);
 
@@ -192,18 +192,18 @@ public:
   octave_char_matrix_sq_str (const octave_char_matrix_str& chm)
     : octave_char_matrix_str (chm) { }
 
   octave_char_matrix_sq_str (const octave_char_matrix_sq_str& chms)
     : octave_char_matrix_str (chms) { }
 
   ~octave_char_matrix_sq_str (void) { }
 
-  octave_value *clone (void) const { return new octave_char_matrix_sq_str (*this); }
-  octave_value *empty_clone (void) const { return new octave_char_matrix_sq_str (); }
+  octave_base_value *clone (void) const { return new octave_char_matrix_sq_str (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_char_matrix_sq_str (); }
 
   octave_value reshape (const dim_vector& new_dims) const
     { return octave_value (charNDArray (matrix.reshape (new_dims)), true, '\''); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
     { return octave_value (charNDArray (matrix.permute (vec, inv)), true, '\''); }
 
   octave_value resize (const dim_vector& dv) const
diff --git a/src/ov-streamoff.h b/src/ov-streamoff.h
--- a/src/ov-streamoff.h
+++ b/src/ov-streamoff.h
@@ -52,18 +52,18 @@ public:
   octave_streamoff (const streamoff_array& off)
     : octave_base_matrix<streamoff_array> (off) { }
 
   octave_streamoff (const octave_streamoff& off)
     : octave_base_matrix<streamoff_array> (off) { }
 
   ~octave_streamoff (void) { }
 
-  octave_value *clone (void) const { return new octave_streamoff (*this); }
-  octave_value *empty_clone (void) const { return new octave_streamoff (); }
+  octave_base_value *clone (void) const { return new octave_streamoff (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_streamoff (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_streamoff (void) const { return true; }
 
   std::streamoff streamoff_value (void) const;
 
   streamoff_array streamoff_array_value (void) const { return matrix; }
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -39,24 +39,22 @@ 02110-1301, USA.
 
 #include "Array-util.h"
 
 #include "byte-swap.h"
 #include "ls-oct-ascii.h"
 #include "ls-oct-binary.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
+#include "pr-output.h"
 
 DEFINE_OCTAVE_ALLOCATOR(octave_struct);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_struct, "struct", "struct");
 
-// How many levels of structure elements should we print?
-static int Vstruct_levels_to_print;
-
 Cell
 octave_struct::dotref (const octave_value_list& idx)
 {
   Cell retval;
 
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
@@ -299,17 +297,20 @@ octave_struct::subsasgn (const std::stri
 
 		std::string key = key_idx(0).string_value ();
 
 		if (! error_state)
 		  {
 		    map.assign (idx.front (), key, t_rhs);
 
 		    if (! error_state)
-		      retval = octave_value (this, count + 1);
+		      {
+			count++;
+			retval = octave_value (this);
+		      }
 		    else
 		      gripe_failed_assignment ();
 		  }
 		else
 		  gripe_failed_assignment ();
 	      }
 	    else
 	      {
@@ -317,31 +318,37 @@ octave_struct::subsasgn (const std::stri
 		  {
 		    Octave_map rhs_map = t_rhs.map_value ();
 
 		    if (! error_state)
 		      {
 			map.assign (idx.front (), rhs_map);
 
 			if (! error_state)
-			  retval = octave_value (this, count + 1);
+			  {
+			    count++;
+			    retval = octave_value (this);
+			  }
 			else
 			  gripe_failed_assignment ();
 		      }
 		    else
 		      error ("invalid structure assignment");
 		  }
 		else
 		  {
 		    if (t_rhs.is_empty()) 
 		      {
 			map.maybe_delete_elements (idx.front());
 
 			if (! error_state)
-			  retval = octave_value (this, count + 1);
+			  {
+			    count++;
+			    retval = octave_value (this);
+			  }
 			else
 			  gripe_failed_assignment ();
 		      }
 		    else
 		      error ("invalid structure assignment");
 		  }
 	      }
 	  }
@@ -353,17 +360,20 @@ octave_struct::subsasgn (const std::stri
 
 	    assert (key_idx.length () == 1);
 
 	    std::string key = key_idx(0).string_value ();
 
 	    map.assign (key, t_rhs);
 
 	    if (! error_state)
-	      retval = octave_value (this, count + 1);
+	      {
+		count++;
+		retval = octave_value (this);
+	      }
 	    else
 	      gripe_failed_assignment ();
 	  }
 	  break;
 
 	case '{':
 	  gripe_invalid_index_type (type_name (), type[0]);
 	  break;
@@ -1261,42 +1271,13 @@ octave_struct::load_hdf5 (hid_t loc_id, 
       retval = true;
     }
   
   return retval;
 }
 
 #endif
 
-static int
-struct_levels_to_print (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("struct_levels_to_print", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival == val)
-	{
-	  Vstruct_levels_to_print = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("struct_levels_to_print");
-  return -1;
-}
-
-void
-symbols_of_ov_struct (void)
-{
-  DEFVAR (struct_levels_to_print, 2.0, struct_levels_to_print,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} struct_levels_to_print\n\
-You can tell Octave how many structure levels to display by setting the\n\
-built-in variable @code{struct_levels_to_print}.  The default value is 2.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -56,18 +56,18 @@ public:
   octave_struct (const Octave_map& m)
     : octave_base_value (), map (m) { }
 
   octave_struct (const octave_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_struct (void) { }
 
-  octave_value *clone (void) const { return new octave_struct (*this); }
-  octave_value *empty_clone (void) const { return new octave_struct (); }
+  octave_base_value *clone (void) const { return new octave_struct (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_struct (); }
 
   Cell dotref (const octave_value_list& idx);
 
   octave_value subsref (const std::string&,
 			const std::list<octave_value_list>&)
     {
       panic_impossible ();
       return octave_value_list ();
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
--- a/src/ov-type-conv.h
+++ b/src/ov-type-conv.h
@@ -36,22 +36,22 @@ 02110-1301, USA.
       int t_result = MATRIX_RESULT_T::static_type_id (); \
  \
       if (t_arg == t_result || arg.class_name () == #NAME) \
 	{ \
 	  retval = arg; \
 	} \
       else \
         { \
-          type_conv_fcn cf \
+          octave_base_value::type_conv_fcn cf \
 	    = octave_value_typeinfo::lookup_type_conv_op (t_arg, t_result); \
  \
           if (cf) \
 	    { \
-	      octave_value *tmp (cf (*(arg.internal_rep ()))); \
+	      octave_base_value *tmp (cf (*(arg.internal_rep ()))); \
  \
 	      if (tmp) \
 		{ \
 		  retval = octave_value (tmp); \
  \
 		  retval.maybe_mutate (); \
 		} \
 	    } \
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -38,35 +38,35 @@ octave_value_typeinfo *
 octave_value_typeinfo::instance (0);
 
 #include <Array.h>
 #include <Array2.h>
 #include <Array3.h>
 
 #include <Array.cc>
 
-INSTANTIATE_ARRAY (unary_op_fcn);
-template class Array2<unary_op_fcn>;
+INSTANTIATE_ARRAY (octave_value_typeinfo::unary_op_fcn);
+template class Array2<octave_value_typeinfo::unary_op_fcn>;
 
-INSTANTIATE_ARRAY (non_const_unary_op_fcn);
-template class Array2<non_const_unary_op_fcn>;
+INSTANTIATE_ARRAY (octave_value_typeinfo::non_const_unary_op_fcn);
+template class Array2<octave_value_typeinfo::non_const_unary_op_fcn>;
 
-INSTANTIATE_ARRAY (binary_op_fcn);
-template class Array2<binary_op_fcn>;
-template class Array3<binary_op_fcn>;
+INSTANTIATE_ARRAY (octave_value_typeinfo::binary_op_fcn);
+template class Array2<octave_value_typeinfo::binary_op_fcn>;
+template class Array3<octave_value_typeinfo::binary_op_fcn>;
 
-INSTANTIATE_ARRAY (cat_op_fcn);
-template class Array2<cat_op_fcn>;
+INSTANTIATE_ARRAY (octave_value_typeinfo::cat_op_fcn);
+template class Array2<octave_value_typeinfo::cat_op_fcn>;
 
-INSTANTIATE_ARRAY (assign_op_fcn);
-template class Array2<assign_op_fcn>;
-template class Array3<assign_op_fcn>;
+INSTANTIATE_ARRAY (octave_value_typeinfo::assign_op_fcn);
+template class Array2<octave_value_typeinfo::assign_op_fcn>;
+template class Array3<octave_value_typeinfo::assign_op_fcn>;
 
-INSTANTIATE_ARRAY (type_conv_fcn);
-template class Array2<type_conv_fcn>;
+INSTANTIATE_ARRAY (octave_base_value::type_conv_fcn);
+template class Array2<octave_base_value::type_conv_fcn>;
 
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
   if (! instance)
     instance = new octave_value_typeinfo ();
 
@@ -86,83 +86,83 @@ octave_value_typeinfo::register_type (co
 				      const octave_value& val)
 {
   return (instance_ok ())
     ? instance->do_register_type (t_name, c_name, val) : -1;
 }
 
 bool
 octave_value_typeinfo::register_unary_op (octave_value::unary_op op,
-					   int t, unary_op_fcn f)
+					   int t, octave_value_typeinfo::unary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_unary_op (op, t, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_non_const_unary_op (octave_value::unary_op op,
 						    int t,
-						    non_const_unary_op_fcn f)
+						    octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_non_const_unary_op (op, t, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_op (octave_value::binary_op op,
 					   int t1, int t2,
-					   binary_op_fcn f)
+					   octave_value_typeinfo::binary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_binary_op (op, t1, t2, f) : false;
 }
 
 bool
-octave_value_typeinfo::register_cat_op (int t1, int t2, cat_op_fcn f)
+octave_value_typeinfo::register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_cat_op (t1, t2, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_assign_op (octave_value::assign_op op,
 					   int t_lhs, int t_rhs,
-					   assign_op_fcn f)
+					   octave_value_typeinfo::assign_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_assign_op (op, t_lhs, t_rhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_assignany_op (octave_value::assign_op op,
-					       int t_lhs, assign_op_fcn f)
+					      int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_assignany_op (op, t_lhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_pref_assign_conv (int t_lhs, int t_rhs,
 						  int t_result) 
 {
   return (instance_ok ())
     ? instance->do_register_pref_assign_conv (t_lhs, t_rhs, t_result) : false;
 }
 
 bool
 octave_value_typeinfo::register_type_conv_op (int t, int t_result,
-					      type_conv_fcn f)
+					      octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_type_conv_op (t, t_result, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_widening_op (int t, int t_result,
-					     type_conv_fcn f)
+					     octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_widening_op (t, t_result, f) : false;
 }
 
 // XXX FIXME XXX -- we should also store all class names and provide a
 // way to list them (calling class with nargin == 0?).
 
@@ -183,52 +183,52 @@ octave_value_typeinfo::do_register_type 
     {
       len *= 2;
 
       types.resize (len, std::string ());
 
       vals.resize (len, octave_value ());
 
       unary_ops.resize (static_cast<int> (octave_value::num_unary_ops),
-			len, static_cast<unary_op_fcn> (0));
+			len, static_cast<octave_value_typeinfo::unary_op_fcn> (0));
 
       non_const_unary_ops.resize
 	(static_cast<int> (octave_value::num_unary_ops),
-	 len, static_cast<non_const_unary_op_fcn> (0));
+	 len, static_cast<octave_value_typeinfo::non_const_unary_op_fcn> (0));
 
       binary_ops.resize (static_cast<int> (octave_value::num_binary_ops),
-			 len, len, static_cast<binary_op_fcn> (0));
+			 len, len, static_cast<octave_value_typeinfo::binary_op_fcn> (0));
 
-      cat_ops.resize (len, len, static_cast<cat_op_fcn> (0));
+      cat_ops.resize (len, len, static_cast<octave_value_typeinfo::cat_op_fcn> (0));
 
       assign_ops.resize (static_cast<int> (octave_value::num_assign_ops),
-			 len, len, static_cast<assign_op_fcn> (0));
+			 len, len, static_cast<octave_value_typeinfo::assign_op_fcn> (0));
 
       assignany_ops.resize (static_cast<int> (octave_value::num_assign_ops),
-			    len, static_cast<assign_op_fcn> (0));
+			    len, static_cast<octave_value_typeinfo::assignany_op_fcn> (0));
 
       pref_assign_conv.resize (len, len, -1);
 
-      type_conv_ops.resize (len, len, static_cast<type_conv_fcn> (0));
+      type_conv_ops.resize (len, len, static_cast<octave_base_value::type_conv_fcn> (0));
 
-      widening_ops.resize (len, len, static_cast<type_conv_fcn> (0));
+      widening_ops.resize (len, len, static_cast<octave_base_value::type_conv_fcn> (0));
     }
 
   types (i) = t_name;
 
   vals (i) = val;
 
   num_types++;
 
   return i;
 }
 
 bool
 octave_value_typeinfo::do_register_unary_op (octave_value::unary_op op,
-					     int t, unary_op_fcn f)
+					     int t, octave_value_typeinfo::unary_op_fcn f)
 {
   if (lookup_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
       warning ("duplicate unary operator `%s' for type `%s'",
 	       op_name.c_str (), type_name.c_str ());
@@ -236,17 +236,17 @@ octave_value_typeinfo::do_register_unary
 
   unary_ops.checkelem (static_cast<int> (op), t) = f;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_non_const_unary_op
-  (octave_value::unary_op op, int t, non_const_unary_op_fcn f)
+  (octave_value::unary_op op, int t, octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   if (lookup_non_const_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
       warning ("duplicate unary operator `%s' for type `%s'",
 	       op_name.c_str (), type_name.c_str ());
@@ -255,17 +255,17 @@ octave_value_typeinfo::do_register_non_c
   non_const_unary_ops.checkelem (static_cast<int> (op), t) = f;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_op (octave_value::binary_op op,
 					      int t1, int t2,
-					      binary_op_fcn f)
+					      octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate binary operator `%s' for types `%s' and `%s'",
@@ -273,17 +273,17 @@ octave_value_typeinfo::do_register_binar
     }
 
   binary_ops.checkelem (static_cast<int> (op), t1, t2) = f;
 
   return false;
 }
 
 bool
-octave_value_typeinfo::do_register_cat_op (int t1, int t2, cat_op_fcn f)
+octave_value_typeinfo::do_register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
 {
   if (lookup_cat_op (t1, t2))
     {
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate concatenation operator for types `%s' and `%s'",
 	       t1_name.c_str (), t1_name.c_str ());
@@ -292,17 +292,17 @@ octave_value_typeinfo::do_register_cat_o
   cat_ops.checkelem (t1, t2) = f;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_assign_op (octave_value::assign_op op,
 					      int t_lhs, int t_rhs,
-					      assign_op_fcn f)
+					      octave_value_typeinfo::assign_op_fcn f)
 {
   if (lookup_assign_op (op, t_lhs, t_rhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
       warning ("duplicate assignment operator `%s' for types `%s' and `%s'",
@@ -311,17 +311,17 @@ octave_value_typeinfo::do_register_assig
 
   assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs) = f;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_assignany_op (octave_value::assign_op op,
-						 int t_lhs, assign_op_fcn f)
+						 int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   if (lookup_assignany_op (op, t_lhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
 
       warning ("duplicate assignment operator `%s' for types `%s'",
 	       op_name.c_str (), t_lhs_name.c_str ());
@@ -347,17 +347,17 @@ octave_value_typeinfo::do_register_pref_
 
   pref_assign_conv.checkelem (t_lhs, t_rhs) = t_result;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_type_conv_op
-  (int t, int t_result, type_conv_fcn f)
+  (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_type_conv_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
       warning ("overriding type conversion op for `%s' to `%s'",
 	       t_name.c_str (), t_result_name.c_str ());
@@ -365,17 +365,17 @@ octave_value_typeinfo::do_register_type_
 
   type_conv_ops.checkelem (t, t_result) = f;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_widening_op
-  (int t, int t_result, type_conv_fcn f)
+  (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_widening_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
       warning ("overriding widening op for `%s' to `%s'",
 	       t_name.c_str (), t_result_name.c_str ());
@@ -399,69 +399,69 @@ octave_value_typeinfo::do_lookup_type (c
 	  retval.make_unique ();
 	  break;
 	}
     }
 
   return retval;
 }
 
-unary_op_fcn
+octave_value_typeinfo::unary_op_fcn
 octave_value_typeinfo::do_lookup_unary_op (octave_value::unary_op op, int t)
 {
   return unary_ops.checkelem (static_cast<int> (op), t);
 }
 
-non_const_unary_op_fcn
+octave_value_typeinfo::non_const_unary_op_fcn
 octave_value_typeinfo::do_lookup_non_const_unary_op
   (octave_value::unary_op op, int t)
 {
   return non_const_unary_ops.checkelem (static_cast<int> (op), t);
 }
 
-binary_op_fcn
+octave_value_typeinfo::binary_op_fcn
 octave_value_typeinfo::do_lookup_binary_op (octave_value::binary_op op,
 					    int t1, int t2)
 {
   return binary_ops.checkelem (static_cast<int> (op), t1, t2);
 }
 
-cat_op_fcn
+octave_value_typeinfo::cat_op_fcn
 octave_value_typeinfo::do_lookup_cat_op (int t1, int t2)
 {
   return cat_ops.checkelem (t1, t2);
 }
 
-assign_op_fcn
+octave_value_typeinfo::assign_op_fcn
 octave_value_typeinfo::do_lookup_assign_op (octave_value::assign_op op,
 					    int t_lhs, int t_rhs)
 {
   return assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs);
 }
 
-assign_op_fcn
+octave_value_typeinfo::assignany_op_fcn
 octave_value_typeinfo::do_lookup_assignany_op (octave_value::assign_op op,
 					       int t_lhs)
 {
   return assignany_ops.checkelem (static_cast<int> (op), t_lhs);
 }
 
 int
 octave_value_typeinfo::do_lookup_pref_assign_conv (int t_lhs, int t_rhs)
 {
   return pref_assign_conv.checkelem (t_lhs, t_rhs);
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_value_typeinfo::do_lookup_type_conv_op (int t, int t_result)
 {
   return type_conv_ops.checkelem (t, t_result);
 }
 
-type_conv_fcn
+octave_base_value::type_conv_fcn
 octave_value_typeinfo::do_lookup_widening_op (int t, int t_result)
 {
   return widening_ops.checkelem (t, t_result);
 }
 
 string_vector
 octave_value_typeinfo::do_installed_type_names (void)
 {
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -34,16 +34,32 @@ 02110-1301, USA.
 
 class string_vector;
 
 class
 octave_value_typeinfo
 {
 public:
 
+  typedef octave_value (*unary_op_fcn) (const octave_base_value&);
+
+  typedef void (*non_const_unary_op_fcn) (octave_base_value&);
+
+  typedef octave_value (*binary_op_fcn)
+    (const octave_base_value&, const octave_base_value&);
+
+  typedef octave_value (*cat_op_fcn)
+    (octave_base_value&, const octave_base_value&, const Array<int>& ra_idx);
+
+  typedef octave_value (*assign_op_fcn)
+    (octave_base_value&, const octave_value_list&, const octave_base_value&);
+
+  typedef octave_value (*assignany_op_fcn)
+    (octave_base_value&, const octave_value_list&, const octave_value&);
+
   static bool instance_ok (void);
 
   static int register_type (const std::string&, const std::string&,
 			    const octave_value&);
 
   static bool register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   static bool register_non_const_unary_op (octave_value::unary_op, int,
@@ -53,23 +69,25 @@ public:
 				  binary_op_fcn);
 
   static bool register_cat_op (int, int, cat_op_fcn);
 
   static bool register_assign_op (octave_value::assign_op, int, int,
 				  assign_op_fcn);
 
   static bool register_assignany_op (octave_value::assign_op, int,
-				     assign_op_fcn);
+				     assignany_op_fcn);
 
   static bool register_pref_assign_conv (int, int, int);
 
-  static bool register_type_conv_op (int, int, type_conv_fcn);
+  static bool
+  register_type_conv_op (int, int, octave_base_value::type_conv_fcn);
 
-  static bool register_widening_op (int, int, type_conv_fcn);
+  static bool
+  register_widening_op (int, int, octave_base_value::type_conv_fcn);
 
   static octave_value
   lookup_type (const std::string& nm)
   {
     return instance->do_lookup_type (nm);
   }
 
   static unary_op_fcn
@@ -97,35 +115,35 @@ public:
   }
 
   static assign_op_fcn
   lookup_assign_op (octave_value::assign_op op, int t_lhs, int t_rhs)
   {
     return instance->do_lookup_assign_op (op, t_lhs, t_rhs);
   }
 
-  static assign_op_fcn
+  static assignany_op_fcn
   lookup_assignany_op (octave_value::assign_op op, int t_lhs)
   {
     return instance->do_lookup_assignany_op (op, t_lhs);
   }
 
   static int
   lookup_pref_assign_conv (int t_lhs, int t_rhs)
   {
     return instance->do_lookup_pref_assign_conv (t_lhs, t_rhs);
   }
 
-  static type_conv_fcn
+  static octave_base_value::type_conv_fcn
   lookup_type_conv_op (int t, int t_result)
   {
     return instance->do_lookup_type_conv_op (t, t_result);
   }
 
-  static type_conv_fcn
+  static octave_base_value::type_conv_fcn
   lookup_widening_op (int t, int t_result)
   {
     return instance->do_lookup_widening_op (t, t_result);
   }
 
   static string_vector installed_type_names (void)
   {
     return instance->do_installed_type_names ();
@@ -141,20 +159,20 @@ protected:
       non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz,
 			   (non_const_unary_op_fcn) 0),
       binary_ops (octave_value::num_binary_ops, init_tab_sz,
 		  init_tab_sz, (binary_op_fcn) 0),
       cat_ops (init_tab_sz, init_tab_sz, (cat_op_fcn) 0),
       assign_ops (octave_value::num_assign_ops, init_tab_sz,
 		  init_tab_sz, (assign_op_fcn) 0),
       assignany_ops (octave_value::num_assign_ops, init_tab_sz,
-		     (assign_op_fcn) 0),
+		     (assignany_op_fcn) 0),
       pref_assign_conv (init_tab_sz, init_tab_sz, -1),
-      type_conv_ops (init_tab_sz, init_tab_sz, (type_conv_fcn) 0),
-      widening_ops (init_tab_sz, init_tab_sz, (type_conv_fcn) 0)  { }
+      type_conv_ops (init_tab_sz, init_tab_sz, (octave_base_value::type_conv_fcn) 0),
+      widening_ops (init_tab_sz, init_tab_sz, (octave_base_value::type_conv_fcn) 0)  { }
 
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
   int num_types;
@@ -168,23 +186,23 @@ private:
   Array2<non_const_unary_op_fcn> non_const_unary_ops;
 
   Array3<binary_op_fcn> binary_ops;
 
   Array2<cat_op_fcn> cat_ops;
 
   Array3<assign_op_fcn> assign_ops;
 
-  Array2<assign_op_fcn> assignany_ops;
+  Array2<assignany_op_fcn> assignany_ops;
 
   Array2<int> pref_assign_conv;
 
-  Array2<type_conv_fcn> type_conv_ops;
+  Array2<octave_base_value::type_conv_fcn> type_conv_ops;
 
-  Array2<type_conv_fcn> widening_ops;
+  Array2<octave_base_value::type_conv_fcn> widening_ops;
 
   int do_register_type (const std::string&, const std::string&,
 			const octave_value&);
 
   bool do_register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   bool do_register_non_const_unary_op (octave_value::unary_op, int,
 				       non_const_unary_op_fcn);
@@ -193,44 +211,44 @@ private:
 			      binary_op_fcn);
 
   bool do_register_cat_op (int, int, cat_op_fcn);
 
   bool do_register_assign_op (octave_value::assign_op, int, int,
 			      assign_op_fcn);
 
   bool do_register_assignany_op (octave_value::assign_op, int,
-				 assign_op_fcn);
+				 assignany_op_fcn);
 
   bool do_register_pref_assign_conv (int, int, int);
 
-  bool do_register_type_conv_op (int, int, type_conv_fcn);
+  bool do_register_type_conv_op (int, int, octave_base_value::type_conv_fcn);
 
-  bool do_register_widening_op (int, int, type_conv_fcn);
+  bool do_register_widening_op (int, int, octave_base_value::type_conv_fcn);
 
   octave_value do_lookup_type (const std::string& nm);
 
   unary_op_fcn do_lookup_unary_op (octave_value::unary_op, int);
 
   non_const_unary_op_fcn do_lookup_non_const_unary_op
     (octave_value::unary_op, int);
 
   binary_op_fcn do_lookup_binary_op (octave_value::binary_op, int, int);
 
   cat_op_fcn do_lookup_cat_op (int, int);
 
   assign_op_fcn do_lookup_assign_op (octave_value::assign_op, int, int);
 
-  assign_op_fcn do_lookup_assignany_op (octave_value::assign_op, int);
+  assignany_op_fcn do_lookup_assignany_op (octave_value::assign_op, int);
 
   int do_lookup_pref_assign_conv (int, int);
 
-  type_conv_fcn do_lookup_type_conv_op (int, int);
+  octave_base_value::type_conv_fcn do_lookup_type_conv_op (int, int);
 
-  type_conv_fcn do_lookup_widening_op (int, int);
+  octave_base_value::type_conv_fcn do_lookup_widening_op (int, int);
 
   string_vector do_installed_type_names (void);
 
   // No copying!
 
   octave_value_typeinfo (const octave_value_typeinfo&);
 
   octave_value_typeinfo& operator = (const octave_value_typeinfo&);
diff --git a/src/ov-va-args.h b/src/ov-va-args.h
--- a/src/ov-va-args.h
+++ b/src/ov-va-args.h
@@ -51,18 +51,18 @@ public:
   octave_all_va_args (void)
     : octave_base_value () { }
 
   octave_all_va_args (const octave_all_va_args&)
     : octave_base_value () { }
 
   ~octave_all_va_args (void) { }
 
-  octave_value *clone (void) const { return new octave_all_va_args (*this); }
-  octave_value *empty_clone (void) const { return new octave_all_va_args (); }
+  octave_base_value *clone (void) const { return new octave_all_va_args (*this); }
+  octave_base_value *empty_clone (void) const { return new octave_all_va_args (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_all_va_args (void) const { return true; }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -77,41 +77,26 @@ 02110-1301, USA.
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 // We are likely to have a lot of octave_value objects to allocate, so
 // make the grow_size large.
 DEFINE_OCTAVE_ALLOCATOR2(octave_value, 1024);
 
-// If TRUE, turn off printing of results in functions (as if a
-// semicolon has been appended to each statement).
-static bool Vsilent_functions;
-
 // If TRUE, print a warning for assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 bool Vwarn_fortran_indexing;
 
 // Should we warn about conversions from complex to real?
 int Vwarn_imag_to_real;
 
-// Should we print a warning when converting `[97, 98, 99, "123"]'
-// to a character string?
-bool Vwarn_num_to_str;
-
-// If TRUE, print the name along with the value.
-bool Vprint_answer_id_name;
-
-// If TRUE, print a warning when a matrix is resized by an indexed
-// assignment with indices outside the current bounds.
-bool Vwarn_resize_on_range_error;
-
 // XXX FIXME XXX
 
 // Octave's value type.
 
 std::string
 octave_value::unary_op_as_string (unary_op op)
 {
   std::string retval;
@@ -320,510 +305,433 @@ octave_value::assign_op_as_string (assig
 
     default:
       retval = "<unknown>";
     }
 
   return retval;
 }
 
-octave_value *
-octave_value::nil_rep (void) const
+octave_value::octave_value (void)
+  : rep (new octave_base_value ())
 {
-  static octave_base_value *nr = new octave_base_value ();
-  return nr;
-}
-
-octave_value::octave_value (void)
-  : rep (nil_rep ())
-{
-  rep->count++;
 }
 
 octave_value::octave_value (short int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (unsigned short int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (unsigned int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (long int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (unsigned long int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 
 #if defined (HAVE_LONG_LONG_INT)
 octave_value::octave_value (long long int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 #endif
 
 #if defined (HAVE_UNSIGNED_LONG_LONG_INT)
 octave_value::octave_value (unsigned long long int i)
   : rep (new octave_scalar (i))
 {
-  rep->count = 1;
 }
 #endif
 
 octave_value::octave_value (octave_time t)
   : rep (new octave_scalar (t))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (double d)
   : rep (new octave_scalar (d))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (const Cell& c, bool is_csl)
   : rep (is_csl
-	 ? dynamic_cast<octave_value *> (new octave_cs_list (c))
-	 : dynamic_cast<octave_value *> (new octave_cell (c)))
+	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (c))
+	 : dynamic_cast<octave_base_value *> (new octave_cell (c)))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (const ArrayN<octave_value>& a, bool is_csl)
   : rep (is_csl
-	 ? dynamic_cast<octave_value *> (new octave_cs_list (Cell (a)))
-	 : dynamic_cast<octave_value *> (new octave_cell (Cell (a))))
+	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (Cell (a)))
+	 : dynamic_cast<octave_base_value *> (new octave_cell (Cell (a))))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (const Matrix& m)
   : rep (new octave_matrix (m))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const NDArray& a)
   : rep (new octave_matrix (a))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ArrayN<double>& a)
   : rep (new octave_matrix (a))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const DiagMatrix& d)
   : rep (new octave_matrix (d))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const RowVector& v)
   : rep (new octave_matrix (v))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ColumnVector& v)
   : rep (new octave_matrix (v))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Complex& C)
   : rep (new octave_complex (C))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexMatrix& m)
   : rep (new octave_complex_matrix (m))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexNDArray& a)
   : rep (new octave_complex_matrix (a))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ArrayN<Complex>& a)
   : rep (new octave_complex_matrix (a))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexDiagMatrix& d)
   : rep (new octave_complex_matrix (d))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexRowVector& v)
   : rep (new octave_complex_matrix (v))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexColumnVector& v)
   : rep (new octave_complex_matrix (v))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (bool b)
   : rep (new octave_bool (b))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (const boolMatrix& bm)
   : rep (new octave_bool_matrix (bm))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const boolNDArray& bnda)
   : rep (new octave_bool_matrix (bnda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (char c, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (c)
 	 : new octave_char_matrix_sq_str (c))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const char *s, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (s)
 	 : new octave_char_matrix_sq_str (s))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const std::string& s, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (s)
 	 : new octave_char_matrix_sq_str (s))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const string_vector& s, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (s)
 	 : new octave_char_matrix_sq_str (s))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charMatrix& chm, bool is_str, char type)
   : rep (is_str
 	 ? (type == '"'
 	    ? new octave_char_matrix_dq_str (chm)
 	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charNDArray& chm, bool is_str, char type)
   : rep (is_str
 	 ? (type == '"'
 	    ? new octave_char_matrix_dq_str (chm)
 	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ArrayN<char>& chm, bool is_str, char type)
   : rep (is_str
 	 ? (type == '"'
 	    ? new octave_char_matrix_dq_str (chm)
 	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const SparseMatrix& m, const SparseType &t)
   : rep (new octave_sparse_matrix (m, t))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const SparseComplexMatrix& m, const SparseType &t)
   : rep (new octave_sparse_complex_matrix (m, t))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const SparseBoolMatrix& bm, const SparseType &t)
   : rep (new octave_sparse_bool_matrix (bm, t))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_int8& i)
   : rep (new octave_int8_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_uint8& i)
   : rep (new octave_uint8_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_int16& i)
   : rep (new octave_int16_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_uint16& i)
   : rep (new octave_uint16_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_int32& i)
   : rep (new octave_int32_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_uint32& i)
   : rep (new octave_uint32_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_int64& i)
   : rep (new octave_int64_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_uint64& i)
   : rep (new octave_uint64_scalar (i))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int8NDArray& inda)
   : rep (new octave_int8_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint8NDArray& inda)
   : rep (new octave_uint8_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int16NDArray& inda)
   : rep (new octave_int16_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint16NDArray& inda)
   : rep (new octave_uint16_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int32NDArray& inda)
   : rep (new octave_int32_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint32NDArray& inda)
   : rep (new octave_uint32_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int64NDArray& inda)
   : rep (new octave_int64_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint64NDArray& inda)
   : rep (new octave_uint64_matrix (inda))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (double base, double limit, double inc)
   : rep (new octave_range (base, limit, inc))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Range& r)
   : rep (new octave_range (r))
 {
-  rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Octave_map& m)
   : rep (new octave_struct (m))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (const streamoff_array& off)
   : rep (new octave_streamoff (off))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (const octave_value_list& l, bool is_csl)
   : rep (is_csl
-	 ? dynamic_cast<octave_value *> (new octave_cs_list (l))
-	 : dynamic_cast<octave_value *> (new octave_list (l)))
+	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (l))
+	 : dynamic_cast<octave_base_value *> (new octave_list (l)))
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (octave_value::magic_colon)
   : rep (new octave_magic_colon ())
 {
-  rep->count = 1;
 }
 
 octave_value::octave_value (octave_value::all_va_args)
   : rep (new octave_all_va_args ())
 {
-  rep->count = 1;
 }
 
-octave_value::octave_value (octave_value *new_rep, int cnt)
+octave_value::octave_value (octave_base_value *new_rep)
   : rep (new_rep)
 {
-  rep->count = cnt;
 }
 
 octave_value::~octave_value (void)
 {
 #if defined (MDEBUG)
-  if (rep)
-    std::cerr << "~octave_value: rep: " << rep
-	      << " rep->count: " << rep->count << std::endl;
-  else
-    std::cerr << "~octave_value: rep is 0!" << std::endl;
+  std::cerr << "~octave_value: rep: " << rep
+	    << " rep->count: " << rep->count << std::endl;
 #endif
 
-  if (rep && --rep->count == 0)
-    {
-      delete rep;
-      rep = 0;
-    }
+  if (--rep->count == 0)
+    delete rep;
 }
 
-octave_value *
+octave_base_value *
 octave_value::clone (void) const
 {
   panic_impossible ();
   return 0;
 }
 
 void
 octave_value::maybe_mutate (void)
 {
-  octave_value *tmp = rep->try_narrowing_conversion ();
+  octave_base_value *tmp = rep->try_narrowing_conversion ();
 
   if (tmp && tmp != rep)
     {
       if (--rep->count == 0)
 	delete rep;
 
       rep = tmp;
-      rep->count = 1;
     }    
 }
 
 octave_value
 octave_value::single_subsref (const std::string& type,
 			      const octave_value_list& idx)
 {
   std::list<octave_value_list> i;
@@ -876,24 +784,16 @@ octave_value::next_subsref (int nargout,
 }
 
 octave_value_list
 octave_value::do_multi_index_op (int nargout, const octave_value_list& idx)
 {
   return rep->do_multi_index_op (nargout, idx);
 }
 
-static void
-gripe_no_conversion (const std::string& on, const std::string& tn1,
-		     const std::string& tn2)
-{
-  error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
-	 on.c_str (), tn2.c_str (), tn1.c_str ());
-}
-
 #if 0
 static void
 gripe_assign_failed (const std::string& on, const std::string& tn1,
 		     const std::string& tn2)
 {
   error ("assignment failed for `%s %s %s'",
 	 tn1.c_str (), on.c_str (), tn2.c_str ());
 }
@@ -995,32 +895,16 @@ octave_value::assign (assign_op op, cons
 	gripe_assign_failed_or_no_method (assign_op_as_string (op),
 					  type_name (), rhs.type_name ());
     }
 
   return *this;
 }
 
 octave_idx_type
-octave_value::rows (void) const
-{
-  dim_vector dv = dims ();
-
-  return (dv.length () > 0) ? dv(0) : -1;
-}
-
-octave_idx_type
-octave_value::columns (void) const
-{
-  dim_vector dv = dims ();
-
-  return (dv.length () > 1) ? dv(1) : -1;
-}
-
-octave_idx_type
 octave_value::length (void) const
 {
   int retval = 0;
 
   dim_vector dv = dims ();
 
   for (int i = 0; i < dv.length (); i++)
     {
@@ -1038,41 +922,16 @@ octave_value::length (void) const
 
       if (dv(i) > retval)
 	retval = dv(i);
     }
 
   return retval;
 }
 
-int
-octave_value::ndims (void) const
-{
-  dim_vector dv = dims ();
-
-  int n_dims = dv.length ();
-     
-   // Remove trailing singleton dimensions.
-
-   for (int i = n_dims; i > 2; i--)
-     {
-       if (dv(i-1) == 1)
-	 n_dims--;
-       else
-	 break;
-     }
-   
-   // The result is always >= 2.
-
-   if (n_dims < 2)
-     n_dims = 2;
-
-   return n_dims;
-}
-
 Matrix
 octave_value::size (void) const
 {
   dim_vector dv = dims ();
 
   int n_dims = dv.length ();
 
   Matrix retval (1, n_dims);
@@ -1442,180 +1301,24 @@ octave_value::complex_vector_value (bool
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex vector");
     }
 
   return retval;
 }
 
-octave_value
-octave_value::convert_to_str (bool pad, bool force, char type) const
-{
-  octave_value retval = convert_to_str_internal (pad, force, type);
-
-  if (! force && is_numeric_type () && Vwarn_num_to_str)
-    gripe_implicit_conversion (type_name (), retval.type_name ());
-
-  return retval;
-}
-
-void
-octave_value::print_with_name (std::ostream& output_buf,
-			       const std::string& name, 
-			       bool print_padding) const
-{
-  if (! (evaluating_function_body && Vsilent_functions))
-    {
-      bool pad_after = false;
-
-      if (Vprint_answer_id_name)
-	pad_after = print_name_tag (output_buf, name);
-
-      print (output_buf);
-
-      if (print_padding && pad_after)
-	newline (output_buf);
-    }
-}
-
-static void
-gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
-{
-  error ("assignment of `%s' to indexed `%s' not implemented",
-	 tn2.c_str (), tn1.c_str ());
-}
-
-static void
-gripe_assign_conversion_failed (const std::string& tn1,
-				const std::string& tn2)
-{
-  error ("type conversion for assignment of `%s' to indexed `%s' failed",
-	 tn2.c_str (), tn1.c_str ());
-}
-
 int
 octave_value::write (octave_stream& os, int block_size,
 		     oct_data_conv::data_type output_type, int skip,
 		     oct_mach_info::float_format flt_fmt) const
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
-octave_value
-octave_value::numeric_assign (const std::string& type,
-			      const std::list<octave_value_list>& idx,
-			      const octave_value& rhs)
-{
-  octave_value retval;
-
-  int t_lhs = type_id ();
-  int t_rhs = rhs.type_id ();
-
-  assign_op_fcn f
-    = octave_value_typeinfo::lookup_assign_op (op_asn_eq, t_lhs, t_rhs);
-
-  bool done = false;
-
-  if (f)
-    {
-      f (*this, idx.front (), rhs.get_rep ());
-
-      done = (! error_state);
-    }
-
-  if (done)
-    retval = octave_value (this, count + 1);
-  else
-    {
-      int t_result
-	= octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
-
-      if (t_result >= 0)
-	{
-	  type_conv_fcn cf
-	    = octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
-
-	  if (cf)
-	    {
-	      octave_value *tmp (cf (*this));
-
-	      if (tmp)
-		{
-		  retval = tmp->subsasgn (type, idx, rhs);
-
-		  done = (! error_state);
-		}
-	      else
-		gripe_assign_conversion_failed (type_name (),
-						rhs.type_name ());
-	    }
-	  else
-	    gripe_indexed_assignment (type_name (), rhs.type_name ());
-	}
-
-      if (! (done || error_state))
-	{
-	  octave_value tmp_rhs;
-	  type_conv_fcn cf_rhs = rhs.numeric_conversion_function ();
-
-	  if (cf_rhs)
-	    {
-	      octave_value *tmp = cf_rhs (rhs.get_rep ());
-
-	      if (tmp)
-		tmp_rhs = octave_value (tmp);
-	      else
-		{
-		  gripe_assign_conversion_failed (type_name (),
-						  rhs.type_name ());
-		  return octave_value ();
-		}
-	    }
-	  else
-	    tmp_rhs = rhs;
-
-	  type_conv_fcn cf_this = numeric_conversion_function ();
-
-	  octave_value *tmp_lhs = this;
-
-	  if (cf_this)
-	    {
-	      octave_value *tmp = cf_this (*this);
-
-	      if (tmp)
-		tmp_lhs = tmp;
-	      else
-		{
-		  gripe_assign_conversion_failed (type_name (),
-						  rhs.type_name ());
-		  return octave_value ();
-		}
-	    }
-
-	  if (cf_this || cf_rhs)
-	    {
-	      retval = tmp_lhs->subsasgn (type, idx, tmp_rhs);
-
-	      done = (! error_state);
-	    }
-	  else
-	    gripe_no_conversion (assign_op_as_string (op_asn_eq),
-				 type_name (), rhs.type_name ());
-	}
-    }
-
-  // The assignment may have converted to a type that is wider than
-  // necessary.
-
-  retval.maybe_mutate ();
-
-  return retval;
-}
-
 static void
 gripe_binary_op (const std::string& on, const std::string& tn1,
 		 const std::string& tn2)
 {
   error ("binary operator `%s' not implemented for `%s' by `%s' operations",
 	 on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
@@ -1629,49 +1332,50 @@ octave_value
 do_binary_op (octave_value::binary_op op,
 	      const octave_value& v1, const octave_value& v2)
 {
   octave_value retval;
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
-  binary_op_fcn f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+  octave_value_typeinfo::binary_op_fcn f
+    = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
   if (f)
     retval = f (*v1.rep, *v2.rep);
   else
     {
       octave_value tv1;
-      type_conv_fcn cf1 = v1.numeric_conversion_function ();
+      octave_base_value::type_conv_fcn cf1 = v1.numeric_conversion_function ();
 
       if (cf1)
 	{
-	  octave_value *tmp = cf1 (*v1.rep);
+	  octave_base_value *tmp = cf1 (*v1.rep);
 
 	  if (tmp)
 	    {
 	      tv1 = octave_value (tmp);
 	      t1 = tv1.type_id ();
 	    }
 	  else
 	    {
 	      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
 	      return retval;
 	    }
 	}
       else
 	tv1 = v1;
 
       octave_value tv2;
-      type_conv_fcn cf2 = v2.numeric_conversion_function ();
+      octave_base_value::type_conv_fcn cf2 = v2.numeric_conversion_function ();
 
       if (cf2)
 	{
-	  octave_value *tmp = cf2 (*v2.rep);
+	  octave_base_value *tmp = cf2 (*v2.rep);
 
 	  if (tmp)
 	    {
 	      tv2 = octave_value (tmp);
 	      t2 = tv2.type_id ();
 	    }
 	  else
 	    {
@@ -1724,49 +1428,50 @@ do_cat_op (const octave_value& v1, const
   if (v1.all_zero_dims ())
     return v2;
   if (v2.all_zero_dims ())
     return v1;
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
-  cat_op_fcn f = octave_value_typeinfo::lookup_cat_op (t1, t2);
+  octave_value_typeinfo::cat_op_fcn f
+    = octave_value_typeinfo::lookup_cat_op (t1, t2);
 
   if (f)
     retval = f (*v1.rep, *v2.rep, ra_idx);
   else
     {
       octave_value tv1;
-      type_conv_fcn cf1 = v1.numeric_conversion_function ();
+      octave_base_value::type_conv_fcn cf1 = v1.numeric_conversion_function ();
 
       if (cf1)
 	{
-	  octave_value *tmp = cf1 (*v1.rep);
+	  octave_base_value *tmp = cf1 (*v1.rep);
 
 	  if (tmp)
 	    {
 	      tv1 = octave_value (tmp);
 	      t1 = tv1.type_id ();
 	    }
 	  else
 	    {
 	      gripe_cat_op_conv ();
 	      return retval;
 	    }
 	}
       else
 	tv1 = v1;
 
       octave_value tv2;
-      type_conv_fcn cf2 = v2.numeric_conversion_function ();
+      octave_base_value::type_conv_fcn cf2 = v2.numeric_conversion_function ();
 
       if (cf2)
 	{
-	  octave_value *tmp = cf2 (*v2.rep);
+	  octave_base_value *tmp = cf2 (*v2.rep);
 
 	  if (tmp)
 	    {
 	      tv2 = octave_value (tmp);
 	      t2 = tv2.type_id ();
 	    }
 	  else
 	    {
@@ -1818,28 +1523,29 @@ gripe_unary_op_conv (const std::string& 
 
 octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& v)
 {
   octave_value retval;
 
   int t = v.type_id ();
 
-  unary_op_fcn f = octave_value_typeinfo::lookup_unary_op (op, t);
+  octave_value_typeinfo::unary_op_fcn f
+    = octave_value_typeinfo::lookup_unary_op (op, t);
 
   if (f)
     retval = f (*v.rep);
   else
     {
       octave_value tv;
-      type_conv_fcn cf = v.numeric_conversion_function ();
+      octave_base_value::type_conv_fcn cf = v.numeric_conversion_function ();
 
       if (cf)
 	{
-	  octave_value *tmp = cf (*v.rep);
+	  octave_base_value *tmp = cf (*v.rep);
 
 	  if (tmp)
 	    {
 	      tv = octave_value (tmp);
 	      t = tv.type_id ();
 
 	      f = octave_value_typeinfo::lookup_unary_op (op, t);
 
@@ -1870,38 +1576,37 @@ gripe_unary_op_conversion_failed (const 
 
 const octave_value&
 octave_value::do_non_const_unary_op (unary_op op)
 {
   octave_value retval;
 
   int t = type_id ();
 
-  non_const_unary_op_fcn f
+  octave_value_typeinfo::non_const_unary_op_fcn f
     = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
   if (f)
     {
       make_unique ();
 
       f (*rep);
     }
   else
     {
-      type_conv_fcn cf = numeric_conversion_function ();
+      octave_base_value::type_conv_fcn cf = numeric_conversion_function ();
 
       if (cf)
 	{
-	  octave_value *tmp = cf (*rep);
+	  octave_base_value *tmp = cf (*rep);
 
 	  if (tmp)
 	    {
-	      octave_value *old_rep = rep;
+	      octave_base_value *old_rep = rep;
 	      rep = tmp;
-	      rep->count = 1;
 
 	      t = type_id ();
 
 	      f = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
 	      if (f)
 		{
 		  f (*rep);
@@ -1971,62 +1676,16 @@ octave_value::do_non_const_unary_op (una
       assign_op assop = unary_op_to_assign_op (op);
 
       retval = assign (assop, type, idx, 1.0);
     }
 
   return retval;
 }
 
-// Current indentation.
-int octave_value::curr_print_indent_level = 0;
-
-// TRUE means we are at the beginning of a line.
-bool octave_value::beginning_of_line = true;
-
-// Each print() function should call this before printing anything.
-//
-// This doesn't need to be fast, but isn't there a better way?
-
-void
-octave_value::indent (std::ostream& os) const
-{
-  assert (curr_print_indent_level >= 0);
- 
-  if (beginning_of_line)
-    {
-      // XXX FIXME XXX -- do we need this?
-      // os << prefix;
-
-      for (int i = 0; i < curr_print_indent_level; i++)
-	os << " ";
-
-      beginning_of_line = false;
-    }
-}
-
-// All print() functions should use this to print new lines.
-
-void
-octave_value::newline (std::ostream& os) const
-{
-  os << "\n";
-
-  beginning_of_line = true;
-}
-
-// For ressetting print state.
-
-void
-octave_value::reset (void) const
-{
-  beginning_of_line = true;
-  curr_print_indent_level = 0;
-}
-
 octave_value::assign_op
 octave_value::unary_op_to_assign_op (unary_op op)
 {
   assign_op binop = unknown_assign_op;
 
   switch (op)
     {
     case op_incr:
@@ -2252,124 +1911,33 @@ warn_fortran_indexing (void)
 static int
 warn_imag_to_real (void)
 {
   Vwarn_imag_to_real = check_preference ("warn_imag_to_real");
 
   return 0;
 }
 
-static int
-warn_num_to_str (void)
-{
-  Vwarn_num_to_str = check_preference ("warn_num_to_str");
-
-  return 0;
-}
-
-static int
-print_answer_id_name (void)
-{
-  Vprint_answer_id_name = check_preference ("print_answer_id_name");
-
-  return 0;
-}
-
-static int
-warn_resize_on_range_error (void)
-{
-  Vwarn_resize_on_range_error
-    = check_preference ("warn_resize_on_range_error");
-
-  liboctave_wrore_flag = Vwarn_resize_on_range_error;
-
-  return 0;
-}
-
-static int
-silent_functions (void)
-{
-  Vsilent_functions = check_preference ("silent_functions");
-
-  return 0;
-}
-
 void
 symbols_of_ov (void)
 {
-  DEFVAR (print_answer_id_name, true, print_answer_id_name,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} print_answer_id_name\n\
-If the value of @code{print_answer_id_name} is nonzero, variable\n\
-names are printed along with the result.  Otherwise, only the result\n\
-values are printed.  The default value is 1.\n\
-@end defvr");
-
-  DEFVAR (silent_functions, false, silent_functions,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} silent_functions\n\
-If the value of @code{silent_functions} is nonzero, internal output\n\
-from a function is suppressed.  Otherwise, the results of expressions\n\
-within a function body that are not terminated with a semicolon will\n\
-have their values printed.  The default value is 0.\n\
-\n\
-For example, if the function\n\
-\n\
-@example\n\
-function f ()\n\
-  2 + 2\n\
-endfunction\n\
-@end example\n\
-\n\
-@noindent\n\
-is executed, Octave will either print @samp{ans = 4} or nothing\n\
-depending on the value of @code{silent_functions}.\n\
-@end defvr");
-
   DEFVAR (warn_fortran_indexing, false, warn_fortran_indexing,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_fortran_indexing\n\
 If the value of @code{warn_fortran_indexing} is nonzero, a warning is\n\
 printed for expressions which select elements of a two-dimensional matrix\n\
 using a single index.  The default value is 0.\n\
 @end defvr");
 
   DEFVAR (warn_imag_to_real, false, warn_imag_to_real,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} warn_imag_to_real\n\
 If the value of @code{warn_imag_to_real} is nonzero, a warning is\n\
 printed for implicit conversions of complex numbers to real numbers.\n\
 The default value is 0.\n\
 @end defvr");
-
-  DEFVAR (warn_num_to_str, true, warn_num_to_str,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_num_to_str\n\
-If the value of @code{warn_num_to_str} is nonzero, a warning is\n\
-printed for implicit conversions of numbers to their ASCII character\n\
-equivalents when strings are constructed using a mixture of strings and\n\
-numbers in matrix notation.  For example,\n\
-\n\
-@example\n\
-@group\n\
-[ \"f\", 111, 111 ]\n\
-     @result{} \"foo\"\n\
-@end group\n\
-@end example\n\
-elicits a warning if @code{warn_num_to_str} is nonzero.  The default\n\
-value is 1.\n\
-@end defvr");
-
-  DEFVAR (warn_resize_on_range_error, false, warn_resize_on_range_error,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_resize_on_range_error\n\
-If the value of @code{warn_resize_on_range_error} is nonzero, print a\n\
-warning when a matrix is resized by an indexed assignment with\n\
-indices outside the current bounds.  The default value is 0.\n\
-@end defvr");
-
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -49,52 +49,22 @@ class octave_stream;
 class octave_streamoff;
 class octave_function;
 class octave_user_function;
 class octave_fcn_handle;
 class octave_fcn_inline;
 class octave_value_list;
 class octave_lvalue;
 
-// Constants.
-
-// This just provides a way to avoid infinite recursion when building
-// octave_value objects.
+#include "ov-base.h"
 
-class
-octave_xvalue
-{
-public:
-
-  octave_xvalue (void) { }
-};
+// Constants.
 
 class octave_value;
 
-// XXX FIXME XXX -- these should probably really be inside the scope
-// of the octave_value class, but the cygwin32 beta16 version of g++
-// can't handle that.
-
-typedef octave_value (*unary_op_fcn)
-  (const octave_value&);
-
-typedef void (*non_const_unary_op_fcn)
-  (octave_value&);
-
-typedef octave_value (*binary_op_fcn)
-  (const octave_value&, const octave_value&);
-
-typedef octave_value (*cat_op_fcn)
-  (octave_value&, const octave_value&, const Array<int>& ra_idx);
-
-typedef octave_value (*assign_op_fcn)
-  (octave_value&, const octave_value_list&, const octave_value&);
-
-typedef octave_value * (*type_conv_fcn) (const octave_value&);
-
 class
 octave_value
 {
 public:
 
   enum unary_op
   {
     op_not,
@@ -243,37 +213,37 @@ public:
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
   octave_value (const streamoff_array& off);
   octave_value (const octave_value_list& m, bool is_cs_list = false);
   octave_value (octave_value::magic_colon);
   octave_value (octave_value::all_va_args);
 
-  octave_value (octave_value *new_rep, int count = 1);
+  octave_value (octave_base_value *new_rep);
 
   // Copy constructor.
 
   octave_value (const octave_value& a)
     {
       rep = a.rep;
       rep->count++;
     }
 
   // This should only be called for derived types.
 
-  virtual octave_value *clone (void) const;
+  octave_base_value *clone (void) const;
 
-  virtual octave_value *empty_clone (void) const
+  octave_base_value *empty_clone (void) const
     { return rep->empty_clone (); }
 
   // Delete the representation of this constant if the count drops to
   // zero.
 
-  virtual ~octave_value (void);
+  ~octave_value (void);
 
   void make_unique (void)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
 	  rep = rep->clone ();
 	  rep->count = 1;
@@ -293,396 +263,396 @@ public:
 	  rep->count++;
 	}
 
       return *this;
     }
 
   int get_count (void) const { return rep->count; }
 
-  virtual type_conv_fcn numeric_conversion_function (void) const
+  octave_base_value::type_conv_fcn numeric_conversion_function (void) const
     { return rep->numeric_conversion_function (); }
 
   void maybe_mutate (void);
 
-  virtual octave_value squeeze (void) const
+  octave_value squeeze (void) const
     { return rep->squeeze (); }
 
-  virtual octave_value *try_narrowing_conversion (void)
+  octave_base_value *try_narrowing_conversion (void)
     { return rep->try_narrowing_conversion (); }
 
   octave_value single_subsref (const std::string& type,
 			       const octave_value_list& idx);
 
-  virtual octave_value subsref (const std::string& type,
+  octave_value subsref (const std::string& type,
 				const std::list<octave_value_list>& idx)
     { return rep->subsref (type, idx); }
 
-  virtual octave_value_list subsref (const std::string& type,
+  octave_value_list subsref (const std::string& type,
 				     const std::list<octave_value_list>& idx,
     				     int nargout);
 
   octave_value next_subsref (const std::string& type, const
 			     std::list<octave_value_list>& idx,
 			     size_t skip = 1);
 
   octave_value_list next_subsref (int nargout,
 				  const std::string& type, const
 				  std::list<octave_value_list>& idx,
 				  size_t skip = 1);
 
-  virtual octave_value do_index_op (const octave_value_list& idx,
+  octave_value do_index_op (const octave_value_list& idx,
 				    int resize_ok)
     { return rep->do_index_op (idx, resize_ok); }
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
-  virtual octave_value_list
+  octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
-  virtual octave_value subsasgn (const std::string& type,
+  octave_value subsasgn (const std::string& type,
 				 const std::list<octave_value_list>& idx,
 				 const octave_value& rhs);
 
   octave_value assign (assign_op op, const std::string& type,
 		       const std::list<octave_value_list>& idx,
 		       const octave_value& rhs);
 
   const octave_value& assign (assign_op, const octave_value& rhs);
 
-  virtual idx_vector index_vector (void) const
+  idx_vector index_vector (void) const
     { return rep->index_vector (); }
 
   // Size.
 
-  virtual dim_vector dims (void) const
+  dim_vector dims (void) const
     { return rep->dims (); }
 
-  octave_idx_type rows (void) const;
+  octave_idx_type rows (void) const { return rep->rows (); }
 
-  octave_idx_type columns (void) const;
+  octave_idx_type columns (void) const { return rep->columns (); }
 
   octave_idx_type length (void) const;
 
-  int ndims (void) const;
+  int ndims (void) const { return rep->ndims (); }
 
   bool all_zero_dims (void) const { return dims().all_zero (); }
 
-  virtual octave_idx_type numel (void) const
+  octave_idx_type numel (void) const
     { return rep->numel (); }
 
-  virtual octave_idx_type capacity (void) const
+  octave_idx_type capacity (void) const
     { return rep->capacity (); }
 
   Matrix size (void) const;
 
-  virtual size_t byte_size (void) const
+  size_t byte_size (void) const
     { return rep->byte_size (); }
 
-  virtual octave_idx_type nnz (void) const { return rep->nnz (); }
+  octave_idx_type nnz (void) const { return rep->nnz (); }
 
-  virtual octave_idx_type nzmax (void) const { return rep->nzmax (); }
+  octave_idx_type nzmax (void) const { return rep->nzmax (); }
 
-  virtual octave_value reshape (const dim_vector& dv) const
+  octave_value reshape (const dim_vector& dv) const
     { return rep->reshape (dv); }
 
-  virtual octave_value permute (const Array<int>& vec, bool inv = false) const
+  octave_value permute (const Array<int>& vec, bool inv = false) const
     { return rep->permute (vec, inv); }
 
   octave_value ipermute (const Array<int>& vec) const
     { return rep->permute (vec, true); }
 
-  virtual octave_value resize (const dim_vector& dv, bool fill = false) const
-     { return rep->resize (dv, fill);}
+  octave_value resize (const dim_vector& dv, bool fill = false) const
+    { return rep->resize (dv, fill);}
 
   // Does this constant have a type?  Both of these are provided since
   // it is sometimes more natural to write is_undefined() instead of
   // ! is_defined().
 
-  virtual bool is_defined (void) const
+  bool is_defined (void) const
     { return rep->is_defined (); }
 
   bool is_undefined (void) const
     { return ! is_defined (); }
 
   bool is_empty (void) const
-    { return numel () == 0; }
+    { return rep->is_empty (); }
 
-  virtual bool is_cell (void) const
+  bool is_cell (void) const
     { return rep->is_cell (); }
 
-  virtual bool is_real_scalar (void) const
+  bool is_real_scalar (void) const
     { return rep->is_real_scalar (); }
 
-  virtual bool is_real_matrix (void) const
+  bool is_real_matrix (void) const
     { return rep->is_real_matrix (); }
 
-  virtual bool is_real_nd_array (void) const
+  bool is_real_nd_array (void) const
     { return rep->is_real_nd_array (); }
 
-  virtual bool is_complex_scalar (void) const
+  bool is_complex_scalar (void) const
     { return rep->is_complex_scalar (); }
 
-  virtual bool is_complex_matrix (void) const
+  bool is_complex_matrix (void) const
     { return rep->is_complex_matrix (); }
 
-  virtual bool is_bool_matrix (void) const
+  bool is_bool_matrix (void) const
     { return rep->is_bool_matrix (); }
 
-  virtual bool is_char_matrix (void) const
+  bool is_char_matrix (void) const
     { return rep->is_char_matrix (); }
 
-  virtual bool is_string (void) const
+  bool is_string (void) const
     { return rep->is_string (); }
 
-  virtual bool is_sq_string (void) const
+  bool is_sq_string (void) const
     { return rep->is_sq_string (); }
 
   bool is_dq_string (void) const
     { return rep->is_string () && ! rep->is_sq_string (); }
 
-  virtual bool is_range (void) const
+  bool is_range (void) const
     { return rep->is_range (); }
 
-  virtual bool is_map (void) const
+  bool is_map (void) const
     { return rep->is_map (); }
 
-  virtual bool is_streamoff (void) const
+  bool is_streamoff (void) const
     { return rep->is_streamoff (); }
 
-  virtual bool is_cs_list (void) const
+  bool is_cs_list (void) const
     { return rep->is_cs_list (); }
 
-  virtual bool is_list (void) const
+  bool is_list (void) const
     { return rep->is_list (); }
 
-  virtual bool is_magic_colon (void) const
+  bool is_magic_colon (void) const
     { return rep->is_magic_colon (); }
 
-  virtual bool is_all_va_args (void) const
+  bool is_all_va_args (void) const
     { return rep->is_all_va_args (); }
 
   // Are any or all of the elements in this constant nonzero?
 
-  virtual octave_value all (int dim = 0) const
+  octave_value all (int dim = 0) const
     { return rep->all (dim); }
 
-  virtual octave_value any (int dim = 0) const
+  octave_value any (int dim = 0) const
     { return rep->any (dim); }
 
   // Other type stuff.
 
-  virtual bool is_bool_type (void) const
+  bool is_bool_type (void) const
     { return rep->is_bool_type (); }
 
-  virtual bool is_real_type (void) const
+  bool is_real_type (void) const
     { return rep->is_real_type (); }
 
-  virtual bool is_complex_type (void) const
+  bool is_complex_type (void) const
     { return rep->is_complex_type (); }
 
-  virtual bool is_scalar_type (void) const
+  bool is_scalar_type (void) const
     { return rep->is_scalar_type (); }
 
-  virtual bool is_matrix_type (void) const
+  bool is_matrix_type (void) const
     { return rep->is_matrix_type (); }
 
-  virtual bool is_numeric_type (void) const
+  bool is_numeric_type (void) const
     { return rep->is_numeric_type (); }
 
-  virtual bool is_sparse_type (void) const
+  bool is_sparse_type (void) const
     { return rep->is_sparse_type (); }
 
-  virtual bool valid_as_scalar_index (void) const
+  bool valid_as_scalar_index (void) const
     { return rep->valid_as_scalar_index (); }
 
-  virtual bool valid_as_zero_index (void) const
+  bool valid_as_zero_index (void) const
     { return rep->valid_as_zero_index (); }
 
   // Does this constant correspond to a truth value?
 
-  virtual bool is_true (void) const
+  bool is_true (void) const
     { return rep->is_true (); }
 
   // Are the dimensions of this constant zero by zero?
 
-  virtual bool is_zero_by_zero (void) const
-    { return rep->is_zero_by_zero (); }
+  bool is_zero_by_zero (void) const
+    { return (rows () == 0 && columns () == 0); }
 
-  virtual bool is_constant (void) const
+  bool is_constant (void) const
     { return rep->is_constant (); }
 
-  virtual bool is_function_handle (void) const
+  bool is_function_handle (void) const
     { return rep->is_function_handle (); }
 
-  virtual bool is_inline_function (void) const
+  bool is_inline_function (void) const
     { return rep->is_inline_function (); }
 
-  virtual bool is_function (void) const
+  bool is_function (void) const
     { return rep->is_function (); }
 
-  virtual bool is_builtin_function (void) const
+  bool is_builtin_function (void) const
     { return rep->is_builtin_function (); }
 
-  virtual bool is_dld_function (void) const
+  bool is_dld_function (void) const
     { return rep->is_dld_function (); }
 
   // Values.
 
   octave_value eval (void) { return *this; }
 
-  virtual short int
+  short int
   short_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->short_value (req_int, frc_str_conv); }
 
-  virtual unsigned short int
+  unsigned short int
   ushort_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->ushort_value (req_int, frc_str_conv); }
 
-  virtual int int_value (bool req_int = false, bool frc_str_conv = false) const
+  int int_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->int_value (req_int, frc_str_conv); }
 
-  virtual unsigned int
+  unsigned int
   uint_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->uint_value (req_int, frc_str_conv); }
 
-  virtual int nint_value (bool frc_str_conv = false) const
+  int nint_value (bool frc_str_conv = false) const
     { return rep->nint_value (frc_str_conv); }
 
-  virtual long int
+  long int
   long_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->long_value (req_int, frc_str_conv); }
 
-  virtual unsigned long int
+  unsigned long int
   ulong_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->ulong_value (req_int, frc_str_conv); }
 
-  virtual double double_value (bool frc_str_conv = false) const
+  double double_value (bool frc_str_conv = false) const
     { return rep->double_value (frc_str_conv); }
 
-  virtual double scalar_value (bool frc_str_conv = false) const
+  double scalar_value (bool frc_str_conv = false) const
     { return rep->scalar_value (frc_str_conv); }
 
-  virtual Cell cell_value (void) const;
+  Cell cell_value (void) const;
 
-  virtual Matrix matrix_value (bool frc_str_conv = false) const
+  Matrix matrix_value (bool frc_str_conv = false) const
     { return rep->matrix_value (frc_str_conv); }
 
-  virtual NDArray array_value (bool frc_str_conv = false) const
+  NDArray array_value (bool frc_str_conv = false) const
     { return rep->array_value (frc_str_conv); }
 
-  virtual Complex complex_value (bool frc_str_conv = false) const
+  Complex complex_value (bool frc_str_conv = false) const
     { return rep->complex_value (frc_str_conv); }
 
-  virtual ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const
+  ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const
     { return rep->complex_matrix_value (frc_str_conv); }
 
-  virtual ComplexNDArray complex_array_value (bool frc_str_conv = false) const
+  ComplexNDArray complex_array_value (bool frc_str_conv = false) const
     { return rep->complex_array_value (frc_str_conv); }
 
-  virtual bool bool_value (void) const
+  bool bool_value (void) const
     { return rep->bool_value (); }
 
-  virtual boolMatrix bool_matrix_value (void) const
+  boolMatrix bool_matrix_value (void) const
     { return rep->bool_matrix_value (); }
 
-  virtual boolNDArray bool_array_value (void) const
+  boolNDArray bool_array_value (void) const
     { return rep->bool_array_value (); }
 
-  virtual charMatrix char_matrix_value (bool frc_str_conv = false) const
+  charMatrix char_matrix_value (bool frc_str_conv = false) const
     { return rep->char_matrix_value (frc_str_conv); }
 
-  virtual charNDArray char_array_value (bool frc_str_conv = false) const
+  charNDArray char_array_value (bool frc_str_conv = false) const
     { return rep->char_array_value (frc_str_conv); }
 
-  virtual SparseMatrix sparse_matrix_value (bool frc_str_conv = false) const
-  { return rep->sparse_matrix_value (frc_str_conv); }
+  SparseMatrix sparse_matrix_value (bool frc_str_conv = false) const
+    { return rep->sparse_matrix_value (frc_str_conv); }
 
-  virtual SparseComplexMatrix sparse_complex_matrix_value (bool frc_str_conv = false) const
-  { return rep->sparse_complex_matrix_value (frc_str_conv); }
+  SparseComplexMatrix sparse_complex_matrix_value (bool frc_str_conv = false) const
+    { return rep->sparse_complex_matrix_value (frc_str_conv); }
 
-  virtual SparseBoolMatrix sparse_bool_matrix_value (bool frc_str_conv = false) const
-  { return rep->sparse_bool_matrix_value (frc_str_conv); }
+  SparseBoolMatrix sparse_bool_matrix_value (bool frc_str_conv = false) const
+    { return rep->sparse_bool_matrix_value (frc_str_conv); }
 
-  virtual octave_int8 int8_scalar_value (void) const
+  octave_int8 int8_scalar_value (void) const
     { return rep->int8_scalar_value (); }
 
-  virtual octave_int16 int16_scalar_value (void) const
+  octave_int16 int16_scalar_value (void) const
     { return rep->int16_scalar_value (); }
 
-  virtual octave_int32 int32_scalar_value (void) const
+  octave_int32 int32_scalar_value (void) const
     { return rep->int32_scalar_value (); }
 
-  virtual octave_int64 int64_scalar_value (void) const
+  octave_int64 int64_scalar_value (void) const
     { return rep->int64_scalar_value (); }
 
-  virtual octave_uint8 uint8_scalar_value (void) const
+  octave_uint8 uint8_scalar_value (void) const
     { return rep->uint8_scalar_value (); }
 
-  virtual octave_uint16 uint16_scalar_value (void) const
+  octave_uint16 uint16_scalar_value (void) const
     { return rep->uint16_scalar_value (); }
 
-  virtual octave_uint32 uint32_scalar_value (void) const
+  octave_uint32 uint32_scalar_value (void) const
     { return rep->uint32_scalar_value (); }
 
-  virtual octave_uint64 uint64_scalar_value (void) const
+  octave_uint64 uint64_scalar_value (void) const
     { return rep->uint64_scalar_value (); }
 
-  virtual int8NDArray int8_array_value (void) const
+  int8NDArray int8_array_value (void) const
     { return rep->int8_array_value (); }
 
-  virtual int16NDArray int16_array_value (void) const
+  int16NDArray int16_array_value (void) const
     { return rep->int16_array_value (); }
 
-  virtual int32NDArray int32_array_value (void) const
+  int32NDArray int32_array_value (void) const
     { return rep->int32_array_value (); }
 
-  virtual int64NDArray int64_array_value (void) const
+  int64NDArray int64_array_value (void) const
     { return rep->int64_array_value (); }
 
-  virtual uint8NDArray uint8_array_value (void) const
+  uint8NDArray uint8_array_value (void) const
     { return rep->uint8_array_value (); }
 
-  virtual uint16NDArray uint16_array_value (void) const
+  uint16NDArray uint16_array_value (void) const
     { return rep->uint16_array_value (); }
 
-  virtual uint32NDArray uint32_array_value (void) const
+  uint32NDArray uint32_array_value (void) const
     { return rep->uint32_array_value (); }
 
-  virtual uint64NDArray uint64_array_value (void) const
+  uint64NDArray uint64_array_value (void) const
     { return rep->uint64_array_value (); }
 
-  virtual string_vector all_strings (bool pad = false) const
+  string_vector all_strings (bool pad = false) const
     { return rep->all_strings (pad); }
 
-  virtual std::string string_value (bool force = false) const
+  std::string string_value (bool force = false) const
     { return rep->string_value (force); }
 
-  virtual Range range_value (void) const
+  Range range_value (void) const
     { return rep->range_value (); }
 
-  virtual Octave_map map_value (void) const;
+  Octave_map map_value (void) const;
 
-  virtual string_vector map_keys (void) const
+  string_vector map_keys (void) const
     { return rep->map_keys (); }
 
-  virtual std::streamoff streamoff_value (void) const;
+  std::streamoff streamoff_value (void) const;
 
-  virtual streamoff_array streamoff_array_value (void) const;
+  streamoff_array streamoff_array_value (void) const;
 
-  virtual octave_function *function_value (bool silent = false);
+  octave_function *function_value (bool silent = false);
 
-  virtual octave_user_function *user_function_value (bool silent = false);
+  octave_user_function *user_function_value (bool silent = false);
 
-  virtual octave_fcn_handle *fcn_handle_value (bool silent = false);
+  octave_fcn_handle *fcn_handle_value (bool silent = false);
 
-  virtual octave_fcn_inline *fcn_inline_value (bool silent = false);
+  octave_fcn_inline *fcn_inline_value (bool silent = false);
 
-  virtual octave_value_list list_value (void) const;
+  octave_value_list list_value (void) const;
 
   ColumnVector column_vector_value (bool frc_str_conv = false,
 			     bool frc_vec_conv = false) const;
 
   ComplexColumnVector
   complex_column_vector_value (bool frc_str_conv = false,
 			bool frc_vec_conv = false) const;
 
@@ -703,46 +673,48 @@ public:
   Array<Complex> complex_vector_value (bool frc_str_conv = false,
 				       bool frc_vec_conv = false) const;
 
   // Conversions.  These should probably be private.  If a user of this
   // class wants a certain kind of constant, he should simply ask for
   // it, and we should convert it if possible.
 
   octave_value convert_to_str (bool pad = false, bool force = false,
-			       char type = '"') const;
+			       char type = '"') const
+  { return rep->convert_to_str (pad, force, type); }
 
-  virtual octave_value
+  octave_value
   convert_to_str_internal (bool pad, bool force, char type) const
     { return rep->convert_to_str_internal (pad, force, type); }
 
-  virtual void convert_to_row_or_column_vector (void)
+  void convert_to_row_or_column_vector (void)
     { rep->convert_to_row_or_column_vector (); }
 
-  virtual bool print_as_scalar (void) const
+  bool print_as_scalar (void) const
     { return rep->print_as_scalar (); }
 
-  virtual void print (std::ostream& os, bool pr_as_read_syntax = false) const
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const
     { rep->print (os, pr_as_read_syntax); }
 
-  virtual void print_raw (std::ostream& os,
+  void print_raw (std::ostream& os,
 			  bool pr_as_read_syntax = false) const
     { rep->print_raw (os, pr_as_read_syntax); }
 
-  virtual bool print_name_tag (std::ostream& os, const std::string& name) const
+  bool print_name_tag (std::ostream& os, const std::string& name) const
     { return rep->print_name_tag (os, name); }
 
   void print_with_name (std::ostream& os, const std::string& name,
-			bool print_padding = true) const;
-
-  virtual int type_id (void) const { return rep->type_id (); }
+			bool print_padding = true) const
+    { rep->print_with_name (os, name, print_padding); }
 
-  virtual std::string type_name (void) const { return rep->type_name (); }
+  int type_id (void) const { return rep->type_id (); }
 
-  virtual std::string class_name (void) const { return rep->class_name (); }
+  std::string type_name (void) const { return rep->type_name (); }
+
+  std::string class_name (void) const { return rep->class_name (); }
 
   // Unary and binary operations.
 
   friend octave_value do_unary_op (unary_op op,
 				   const octave_value& a);
 
   const octave_value& do_non_const_unary_op (unary_op op);
 
@@ -754,96 +726,62 @@ public:
   friend octave_value do_binary_op (binary_op op,
 				    const octave_value& a,
 				    const octave_value& b);
 
   friend octave_value do_cat_op (const octave_value& a,
 				 const octave_value& b,
 				 const Array<int>& ra_idx);
 
-  const octave_value& get_rep (void) const { return *rep; }
+  const octave_base_value& get_rep (void) const { return *rep; }
 
-  virtual void print_info (std::ostream& os,
+  void print_info (std::ostream& os,
 			   const std::string& prefix = std::string ()) const;
 
-  virtual bool save_ascii (std::ostream& os, bool& infnan_warned,
+  bool save_ascii (std::ostream& os, bool& infnan_warned,
 			   bool strip_nan_and_inf) 
     { return rep->save_ascii (os, infnan_warned, strip_nan_and_inf); }
 
-  virtual bool load_ascii (std::istream& is)
+  bool load_ascii (std::istream& is)
     { return rep->load_ascii (is); }
 
-  virtual bool save_binary (std::ostream& os, bool& save_as_floats)
+  bool save_binary (std::ostream& os, bool& save_as_floats)
     { return rep->save_binary (os, save_as_floats); }
 
-  virtual bool load_binary (std::istream& is, bool swap,
+  bool load_binary (std::istream& is, bool swap,
 			    oct_mach_info::float_format fmt)
     { return rep->load_binary (is, swap, fmt); }
 
 #if defined (HAVE_HDF5)
-  virtual bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
+  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
     { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
-  virtual bool load_hdf5 (hid_t loc_id, const char *name,
+  bool load_hdf5 (hid_t loc_id, const char *name,
 			  bool have_h5giterate_bug)
     { return rep->load_hdf5 (loc_id, name, have_h5giterate_bug); }
 #endif
 
-  virtual int write (octave_stream& os, int block_size,
+  int write (octave_stream& os, int block_size,
 		     oct_data_conv::data_type output_type, int skip,
 		     oct_mach_info::float_format flt_fmt) const;
 
-  octave_value *internal_rep (void) const { return rep; }
+  octave_base_value *internal_rep (void) const { return rep; }
 
 protected:
 
-  octave_value (const octave_xvalue&) : rep (0) { }
-
-  // This should only be called for derived types.
-
-  octave_value numeric_assign (const std::string& type,
-			       const std::list<octave_value_list>& idx,
-			       const octave_value& rhs);
-
-  void reset_indent_level (void) const
-    { curr_print_indent_level = 0; }
-
-  void increment_indent_level (void) const
-    { curr_print_indent_level += 2; }
-
-  void decrement_indent_level (void) const
-    { curr_print_indent_level -= 2; }
-
-  int current_print_indent_level (void) const
-    { return curr_print_indent_level; }
-
-  void newline (std::ostream& os) const;
-
-  void indent (std::ostream& os) const;
-
-  void reset (void) const;
-
-  union
-    {
-      octave_value *rep;      // The real representation.
-      int count;              // A reference count.
-    };
+  // The real representation.
+  octave_base_value *rep;
 
 private:
 
-  static int curr_print_indent_level;
-  static bool beginning_of_line;
-
   assign_op unary_op_to_assign_op (unary_op op);
 
   binary_op op_eq_to_binary_op (assign_op op);
 
   DECLARE_OCTAVE_ALLOCATOR
-
-  octave_value *nil_rep (void) const;
 };
 
 // Publish externally used friend functions.
 
 extern octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& a);
 
 extern octave_value
@@ -918,77 +856,26 @@ OV_BINOP_FN (op_el_mul)
 OV_BINOP_FN (op_el_div)
 OV_BINOP_FN (op_el_pow)
 OV_BINOP_FN (op_el_ldiv)
 OV_BINOP_FN (op_el_and)
 OV_BINOP_FN (op_el_or)
 
 OV_BINOP_FN (op_struct_ref)
 
-// T_ID is the type id of struct objects, set by register_type().
-// T_NAME is the type name of struct objects.
-#define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
-  public: \
-    int type_id (void) const { return t_id; } \
-    std::string type_name (void) const { return t_name; } \
-    std::string class_name (void) const { return c_name; } \
-    static int static_type_id (void) { return t_id; } \
-    static std::string static_type_name (void) { return t_name; } \
-    static std::string static_class_name (void) { return c_name; } \
-    static void register_type (void); \
- \
-  private: \
-    static int t_id; \
-    static const std::string t_name; \
-    static const std::string c_name;
-
-#define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
-  int t::t_id (-1); \
-  const std::string t::t_name (n); \
-  const std::string t::c_name (c); \
-  void t::register_type (void) \
-    { \
-      t_id = octave_value_typeinfo::register_type (t::t_name, \
-						   t::c_name, \
-						   octave_value (new t ())); \
-    }
-
 // If TRUE, print a warning for assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 extern bool Vwarn_fortran_indexing;
 
-// Should we print a warning when converting `[97, 98, 99, "123"]'
-// to a character string?
-extern bool Vwarn_num_to_str;
-
 // Should we warn about conversions from complex to real?
 extern int Vwarn_imag_to_real;
 
-// If TRUE, print the name along with the value.
-extern bool Vprint_answer_id_name;
-
-// If TRUE, print a warning when a matrix is resized by an indexed
-// assignment with indices outside the current bounds.
-extern bool Vwarn_resize_on_range_error;
-
-// Indentation level for structures.
-extern int struct_indent;
-
-extern void increment_struct_indent (void);
-extern void decrement_struct_indent (void);
-
-// Indentation level for lists.
-extern int list_indent;
-
-extern void increment_list_indent (void);
-extern void decrement_list_indent (void);
-
 extern void install_types (void);
 
 // XXX FIXME XXX -- these trait classes probably belong somehwere else...
 
 template <typename T>
 class
 octave_type_traits
 {
@@ -1037,15 +924,21 @@ OCTAVE_ARRAY_TYPE_TRAIT (uint8NDArray, o
 OCTAVE_ARRAY_TYPE_TRAIT (int16NDArray, octave_int16);
 OCTAVE_ARRAY_TYPE_TRAIT (uint16NDArray, octave_uint16);
 OCTAVE_ARRAY_TYPE_TRAIT (int32NDArray, octave_int32);
 OCTAVE_ARRAY_TYPE_TRAIT (uint32NDArray, octave_uint32);
 OCTAVE_ARRAY_TYPE_TRAIT (int64NDArray, octave_int64);
 OCTAVE_ARRAY_TYPE_TRAIT (uint64NDArray, octave_uint64);
 OCTAVE_ARRAY_TYPE_TRAIT (NDArray, double);
 
+// This will eventually go away, but for now it can be used to
+// simplify the transition to the new octave_value class hierarchy,
+// which uses octave_base_value instead of octave_value for the type
+// of octave_value::rep.
+#define OV_REP_TYPE octave_base_value
+
 #endif
 
 /*
 ;; Local Variables: ***
 ;; mode: C++ ***
 ;; End: ***
 */
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -73,16 +73,19 @@ static int Voutput_precision;
 // TRUE means that the dimensions of empty objects should be printed
 // like this: x = [](2x0).
 bool Vprint_empty_dimensions;
 
 // TRUE means that the rows of big matrices should be split into
 // smaller slices that fit on the screen.
 static bool Vsplit_long_rows;
 
+// How many levels of structure elements should we print?
+int Vstruct_levels_to_print;
+
 // TRUE means don't do any fancy formatting.
 static bool free_format = false;
 
 // TRUE means print plus sign for nonzero, blank for zero.
 static bool plus_format = false;
 
 // First char for > 0, second for < 0, third for == 0.
 static std::string plus_format_chars = "+  ";
@@ -3014,16 +3017,34 @@ print_empty_dimensions (void)
 static int
 split_long_rows (void)
 {
   Vsplit_long_rows = check_preference ("split_long_rows");
 
   return 0;
 }
 
+static int
+struct_levels_to_print (void)
+{
+  double val;
+  if (builtin_real_scalar_variable ("struct_levels_to_print", val)
+      && ! xisnan (val))
+    {
+      int ival = NINT (val);
+      if (ival == val)
+	{
+	  Vstruct_levels_to_print = ival;
+	  return 0;
+	}
+    }
+  gripe_invalid_value_specified ("struct_levels_to_print");
+  return -1;
+}
+
 void
 symbols_of_pr_output (void)
 {
   DEFVAR (fixed_point_format, false, fixed_point_format,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} fixed_point_format\n\
 If the value of this variable is nonzero, Octave will scale all values\n\
 in a matrix so that the largest may be written with one leading digit.\n\
@@ -3114,15 +3135,22 @@ ans =\n\
   0.90174  0.11854  0.72313  0.73326\n\
   0.44672  0.94303  0.56564  0.82150\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @noindent\n\
 The default value of @code{split_long_rows} is nonzero.\n\
 @end defvr");
+
+  DEFVAR (struct_levels_to_print, 2.0, struct_levels_to_print,
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} struct_levels_to_print\n\
+You can tell Octave how many structure levels to display by setting the\n\
+built-in variable @code{struct_levels_to_print}.  The default value is 2.\n\
+@end defvr");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -124,15 +124,18 @@ octave_print_internal (std::ostream& os,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0,
 		       bool pr_as_string = false);
 
 // TRUE means that the dimensions of empty objects should be printed
 // like this: x = [](2x0).
 extern bool Vprint_empty_dimensions;
 
+// How many levels of structure elements should we print?
+extern int Vstruct_levels_to_print;
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -2549,20 +2549,20 @@ Print raw symbol table statistices.\n\
 	top_level_sym_tab->print_info (octave_stdout);
       else
 	{
 	  symbol_record *fsr = fbi_sym_tab->lookup (arg, true);
 
 	  if (fsr && fsr->is_user_function ())
 	    {
 	      octave_value tmp = fsr->def ();
-	      const octave_value& rep = tmp.get_rep ();
+	      const octave_base_value& rep = tmp.get_rep ();
 	      
 	      const octave_user_function& fcn
-		= static_cast<const octave_user_function&> (rep);
+		= dynamic_cast<const octave_user_function&> (rep);
 
 	      fcn.print_symtab_info (octave_stdout);
 	    }
 	  else
 	    error ("no user-defined function named %s", arg.c_str ());
 	}
     }
   else if (nargin == 0)
