# HG changeset patch
# User jwe
# Date 1191530613 0
#      Thu Oct 04 20:43:33 2007 +0000
# Node ID 47f4f4e881663872edd887934ac2a148ba6f1050
# Parent  a18c784ae599096c3caab6cc6d33872bf002c924
[project @ 2007-10-04 20:43:32 by jwe]

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.577 $)
+AC_REVISION($Revision: 1.578 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 OCTAVE_HOST_TYPE
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
@@ -1785,17 +1785,17 @@ OCTAVE_PROG_TEXI2PDF
 ### Even though we include config.h, we need to have the preprocessor
 ### defines available in a variable for the octave-bug script.  Use
 ### UGLY_DEFS for that.
 
 AC_OUTPUT_MAKE_DEFS
 
 ### We have to insert extra levels of backslash quoting here so that
 ### the right thing ends up in oct-conf.h.
-UGLY_DEFS=`echo $DEFS | $(SED) 's,\\",\\\\\\\\\\\\\\\\\\",g'`
+UGLY_DEFS=`echo $DEFS | $SED 's,\\",\\\\\\\\\\\\\\\\\\",g'`
 AC_MSG_NOTICE([defining UGLY_DEFS to be $UGLY_DEFS])
 AC_SUBST(UGLY_DEFS)
 
 ### Maybe add -Wall, -W, and -Wshadow to compiler flags now that we're
 ### done feature testing. 
 
 if test -z "$EXTERN_CFLAGS"; then
   OCTAVE_CC_FLAG(-Wall, [
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+2007-10-04  John W. Eaton  <jwe@octave.org>
+
+	* oct-sort.cc (octave_sort<T>::binarysort): Remove register
+	qualifiers on local variables.
+
 2007-10-04  Marco Caliari  <mcaliari@math.unipd.it>
 
 	* CMatrix.cc (ComplexMatrix::expm): Limit shift to values less
 	than log(realmax) to avoid issues with NaN.
 
 2007-10-01  John W. Eaton  <jwe@octave.org>
 
 	* oct-time.cc (octave_strptime::init): Call mktime to propertly
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -122,18 +122,18 @@ octave_sort<T>::reverse_slice(T *lo, T *
       --hi;
     }
 }
 
 template <class T>
 void
 octave_sort<T>::binarysort (T *lo, T *hi, T *start)
 {
-  register T *l, *p, *r;
-  register T pivot;
+  T *l, *p, *r;
+  T pivot;
 
   if (lo == start)
     ++start;
 
   for (; start < hi; ++start) 
     {
       /* set l to where *start belongs */
       l = lo;
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -351,63 +351,64 @@ randi54 (void)
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
+#if 0
+// FIXME -- this doesn't seem to be used anywhere; should it be removed?
 static uint64_t 
 randi64 (void)
 {
   const uint32_t lo = randi32();
   const uint32_t hi = randi32();
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
+#endif
 
+#ifdef ALLBITS
 /* generates a random number on (0,1)-real-interval */
 static double
 randu32 (void)
 {
   return ((double)randi32() + 0.5) * (1.0/4294967296.0); 
   /* divided by 2^32 */
 }
-
+#else
 /* generates a random number on (0,1) with 53-bit resolution */
 static double
 randu53 (void) 
 { 
   const uint32_t a=randi32()>>5;
   const uint32_t b=randi32()>>6; 
-  return(a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
+  return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
 } 
+#endif
 
 /* Determine mantissa for uniform doubles */
-#ifdef ALLBITS
 double
 oct_randu (void)
 {
-  return randu32();
-}
+#ifdef ALLBITS
+  return randu32 ();
 #else
-double
-oct_randu (void)
-{
-  return randu53();
+  return randu53 ();
+#endif
 }
-#endif
 
 /* ===== Ziggurat normal and exponential generators ===== */
 #ifdef ALLBITS
 # define ZIGINT uint32_t
 # define EMANTISSA 4294967296.0 /* 32 bit mantissa */
 # define ERANDI randi32() /* 32 bits for mantissa */
 # define NMANTISSA 2147483648.0 /* 31 bit mantissa */
 # define NRANDI randi32() /* 31 bits for mantissa + 1 bit sign */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,34 @@
 2007-10-04  John W. Eaton  <jwe@octave.org>
 
+	* DLD-FUNCTIONS/symrcm.cc: Move static functions to top of file to
+	avoid forward decls.
+	(Q_enq): Delete unused arg QH.  Change all uses.
+	(Q_deq): Delete unused arg QT.  Change all uses.
+	(find_starting_node): Delete unused local variable J.
+	(H_heapify_min, H_insert, find_starting_node, Fsymrcm):
+	Move local variable decls to point of first use.
+
+	* OPERATORS/op-streamoff.cc (STREAMOFF_COMP_OP):
+	Avoid control-reaches-end-of-non-void-function warning.
+
+	* pt-const.cc (tree_constant::dup): Avoid unused parameter warning.
+
+	* pr-output.cc (set_real_format, set_real_matrix_format,
+	set_complex_format, set_complex_matrix_format):
+	Delete unused arg, SIGN.  Change uses.
+
+	* oct-map.cc (Octave_map::Octave_map): Avoid shadow warning.
+
+	* load-save.cc (write_header): Use reinterpret_cast to avoid
+	old-style cast warning.
+
+	* data.cc (do_permute): Delete unused arg, FNAME.  Change all uses.
+
 	* sysdep.cc (w32_set_quiet_shutdown, MINGW_signal_cleanup): Now static.
 	(w32_set_octave_home, w32_set_quiet_shutdown, MINGW_signal_cleanup): 
 	Only define if defined (__WIN32__) && ! defined (_POSIX_VERSION).
 
 2007-10-04  Jason Riedy  <jason@acm.org>
 
         * ls-mat5.cc (read_mat5_binary_data): Map miUTF16 to miUINT16,
         miUTF32 to miUINT32.  The matfile format currently states that
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -85,16 +85,18 @@ maybe_update_column (octave_value& Ac, c
 	  Ac = Ac.single_subsref ("(", idx);
 	  return true;
 	}
       else
 	return false;
     }
 }
 
+#if 0
+// FIXME -- this function is not used; is it OK to delete it?
 static void
 update_index (octave_value_list& idx, const dim_vector& dv, octave_idx_type i)
 {
   octave_idx_type nd = dv.length ();
 
   if (i == 0)
     {
       for (octave_idx_type j = nd - 1; j > 0; j--)
@@ -105,31 +107,32 @@ update_index (octave_value_list& idx, co
     {
       for (octave_idx_type j = 1; j < nd; j++)
 	{
 	  idx (j) = octave_value (i % dv (j) + 1);
 	  i = i / dv (j);
 	}
     }
 }
+#endif
 
 static void
 update_index (Array<int>& idx, const dim_vector& dv, octave_idx_type i)
 {
   octave_idx_type nd = dv.length ();
 
   idx(0) = 0;
   for (octave_idx_type j = 1; j < nd; j++)
     {
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
-DEFUN_DLD (bsxfun, args, nargout,
+DEFUN_DLD (bsxfun, args, ,
   " -*- texinfo -*-\n\
 @deftypefn {Lodable Function} {} bsxfun (@var{f}, @var{a}, @var{b})\n\
 Applies a binary function @var{f} element-wise to two matrix arguments\n\
 @var{a} and @var{b}. The function @var{f} must be capable of accepting\n\
 two column vector arguments of equal length, or one column vector\n\
 argument and a scalar.\n\
 \n\
 The dimensions of @var{a} and @var{b} must be equal or singleton. The\n\
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -61,126 +61,128 @@ The input matrix of size [n, dim] contai
 If a second optional argument is given, it must be a string or cell array\n\
 of strings containing options for the underlying qhull command.  (See\n\
 the Qhull documentation for the available options.)  The default options\n\
 are \"s Qci Tcv\".\n\n\
 @seealso{convhull, delaunayn}\n\
 @end deftypefn")
 {
   octave_value_list retval;
+
 #ifdef HAVE_QHULL
   std::string options;
 
-  int nargin = args.length();
+  int nargin = args.length ();
   if (nargin < 1 || nargin > 2) 
     {
       print_usage ();
       return retval;
     }
 
   if (nargin == 2) 
     {
-      if (args (1).is_string () ) 
-	options = args (1).string_value();
-      else if (args (1).is_cell ())
+      if (args (1).is_string ()) 
+	options = args(1).string_value ();
+      else if (args(1).is_cell ())
 	{
-	  Cell c = args (1). cell_value ();
+	  Cell c = args(1).cell_value ();
 	  options = "";
-	  for (octave_idx_type i = 0; i < c.numel(); i++)
+	  for (octave_idx_type i = 0; i < c.numel (); i++)
 	    {
-	      if (!c.elem(i).is_string()) 
+	      if (! c.elem(i).is_string ())
 		{
 		  error ("convhulln: second argument must be a string or cell array of strings");
 		  return retval;
-	      }
+		}
 
 	      options = options + c.elem(i).string_value() + " ";
 	    }
 	}
       else
 	{
 	  error ("convhulln: second argument must be a string or cell array of strings");
 	  return retval;
 	}
     }
   else
     // turn on some consistency checks
     options = "s Qci Tcv";
 
-  Matrix p(args(0).matrix_value());
+  Matrix p (args(0).matrix_value ());
 
-  const octave_idx_type dim = p.columns();
-  const octave_idx_type n = p.rows();
-  p = p.transpose();
+  const octave_idx_type dim = p.columns ();
+  const octave_idx_type n = p.rows ();
+  p = p.transpose ();
 
-  double *pt_array = p.fortran_vec();
+  double *pt_array = p.fortran_vec ();
 
   boolT ismalloc = False;
 
-  OCTAVE_LOCAL_BUFFER(char, flags, 250);
+  OCTAVE_LOCAL_BUFFER (char, flags, 250);
 
   // hmm, lots of options for qhull here
   // QJ guarantees that the output will be triangles
-  snprintf(flags, 250, "qhull QJ %s", options.c_str());
+  snprintf (flags, 250, "qhull QJ %s", options.c_str ());
 
-  if (!qh_new_qhull (dim, n, pt_array, ismalloc, flags, NULL, stderr)) 
+  if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, NULL, stderr)) 
     {
       // If you want some debugging information replace the NULL
       // pointer with stdout
 
-      vertexT *vertex,**vertexp;
+      vertexT *vertex, **vertexp;
       facetT *facet;
       setT *vertices;
       unsigned int nf = qh num_facets;
 
-      Matrix idx(nf, dim);
+      Matrix idx (nf, dim);
 
       octave_idx_type j, i = 0;
       FORALLfacets 
 	{
 	  j = 0;
-	  if (!facet->simplicial)
+	  if (! facet->simplicial)
 	    // should never happen with QJ
-	    error("convhulln: non-simplicial facet");
+	    error ("convhulln: non-simplicial facet");
 
 	  if (dim == 3) 
 	    {
 	      vertices = qh_facet3vertex (facet);
-	      FOREACHvertex_(vertices)
+	      FOREACHvertex_ (vertices)
 		idx(i, j++) = 1 + qh_pointid(vertex->point);
-	      qh_settempfree(&vertices);
+	      qh_settempfree (&vertices);
 	    } 
 	  else 
 	    {
 	      if (facet->toporient ^ qh_ORIENTclock) 
 		{
-		  FOREACHvertex_(facet->vertices)
+		  FOREACHvertex_ (facet->vertices)
 		    idx(i, j++) = 1 + qh_pointid(vertex->point);
 		} 
 	      else 
 		{
-		  FOREACHvertexreverse12_(facet->vertices)
+		  FOREACHvertexreverse12_ (facet->vertices)
 		    idx(i, j++) = 1 + qh_pointid(vertex->point);
 		}
 	    }
 	  if (j < dim)
 	    // likewise but less fatal
-	    warning("facet %d only has %d vertices",i,j);
+	    warning ("facet %d only has %d vertices", i, j);
 	  i++;
 	}
-      retval(0) = octave_value(idx);
+      retval(0) = octave_value (idx);
     }
-  qh_freeqhull (!qh_ALL);
-  //free long memory
+
+  // free long memory
+  qh_freeqhull (! qh_ALL);
+
+  // free short memory and memory allocator
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
-  //free short memory and memory allocator
 
   if (curlong || totlong) 
-    {
-      warning("convhulln: did not free %d bytes of long memory (%d pieces)",
-	      totlong, curlong);
-    }
+    warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
+	    totlong, curlong);
 #else
   error ("convhulln: not available in this version of Octave");
 #endif
+
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -77,74 +77,347 @@ struct CMK_Node
   octave_idx_type dist;
 };
 
 // A simple queue.
 // Queues Q have a fixed maximum size N (rows,cols of the matrix) and are
 // stored in an array. qh and qt point to queue head and tail.
 
 // Enqueue operation (adds a node "o" at the tail)
+
 inline static void 
-Q_enq (CMK_Node *Q, octave_idx_type N, octave_idx_type& qh,
-       octave_idx_type& qt, const CMK_Node& o);	
+Q_enq (CMK_Node *Q, octave_idx_type N, octave_idx_type& qt, const CMK_Node& o)
+{	
+  Q[qt] = o;
+  qt = (qt + 1) % (N + 1);
+}
 
 // Dequeue operation (removes a node from the head)
+
 inline static CMK_Node 
-Q_deq(CMK_Node * Q, octave_idx_type N, octave_idx_type &qh,
-      octave_idx_type &qt);
+Q_deq (CMK_Node * Q, octave_idx_type N, octave_idx_type& qh)
+{
+  CMK_Node r = Q[qh];
+  qh = (qh + 1) % (N + 1);
+  return r;
+}
 
 // Predicate (queue empty)
 #define Q_empty(Q, N, qh, qt)	((qh) == (qt))
 
 // A simple, array-based binary heap (used as a priority queue for nodes)
 
 // the left descendant of entry i
 #define LEFT(i)		(((i) << 1) + 1)	// = (2*(i)+1)
 // the right descendant of entry i
 #define RIGHT(i)	(((i) << 1) + 2)	// = (2*(i)+2)
 // the parent of entry i
 #define PARENT(i)	(((i) - 1) >> 1)	// = floor(((i)-1)/2)
 
 // Builds a min-heap (the root contains the smallest element). A is an array
 // with the graph's nodes, i is a starting position, size is the length of A.
+
 static void 
-H_heapify_min(CMK_Node *A, octave_idx_type i, octave_idx_type size);
+H_heapify_min (CMK_Node *A, octave_idx_type i, octave_idx_type size)
+{
+  octave_idx_type j = i;
+  for (;;)
+    {
+      octave_idx_type l = LEFT(j);
+      octave_idx_type r = RIGHT(j);
+
+      octave_idx_type smallest;
+      if (l < size && A[l].deg < A[j].deg)
+	smallest = l;
+      else
+	smallest = j;
+
+      if (r < size && A[r].deg < A[smallest].deg)
+	smallest = r;
+
+      if (smallest != j)
+	{
+	  CMK_Node tmp = A[j];
+	  A[j] = A[smallest];
+	  A[smallest] = tmp;
+	  j = smallest;
+	}
+      else 
+	break;
+    }
+}
 
 // Heap operation insert. Running time is O(log(n))
+
 static void 
-H_insert(CMK_Node *H, octave_idx_type &h, const CMK_Node &o);
+H_insert (CMK_Node *H, octave_idx_type& h, const CMK_Node& o)
+{
+  octave_idx_type i = h++;
+
+  H[i] = o;
+
+  if (i == 0) 
+    return;
+  do
+    {
+      octave_idx_type p = PARENT(i);
+      if (H[i].deg < H[p].deg)
+	{
+	  CMK_Node tmp = H[i];
+	  H[i] = H[p];
+	  H[p] = tmp;
+
+	  i = p;
+	}
+      else 
+	break;
+    }
+  while (i > 0);
+}
 
 // Heap operation remove-min. Removes the smalles element in O(1) and
 // reorganizes the heap optionally in O(log(n))
+
 inline static CMK_Node 
-H_remove_min(CMK_Node *H, octave_idx_type &h, int reorg /*=1*/);
+H_remove_min (CMK_Node *H, octave_idx_type& h, int reorg/*=1*/)
+{
+  CMK_Node r = H[0];
+  H[0] = H[--h];
+  if (reorg) 
+    H_heapify_min(H, 0, h);
+  return r;
+}
 
 // Predicate (heap empty)
 #define H_empty(H, h)	((h) == 0)
 
 // Helper function for the Cuthill-McKee algorithm. Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
+
 static octave_idx_type 
-find_starting_node(octave_idx_type N, const octave_idx_type *ridx,
-		   const octave_idx_type *cidx, const octave_idx_type *ridx2,
-		   const octave_idx_type *cidx2, octave_idx_type *D, 
-		   octave_idx_type start);
+find_starting_node (octave_idx_type N, const octave_idx_type *ridx, 
+		    const octave_idx_type *cidx, const octave_idx_type *ridx2, 
+		    const octave_idx_type *cidx2, octave_idx_type *D, 
+		    octave_idx_type start)
+{
+  CMK_Node w;
+
+  OCTAVE_LOCAL_BUFFER (CMK_Node, Q, N+1);
+  boolNDArray btmp (dim_vector (1, N), false);
+  bool *visit = btmp.fortran_vec ();
+
+  octave_idx_type qh = 0;
+  octave_idx_type qt = 0;
+  CMK_Node x;
+  x.id = start;
+  x.deg = D[start];
+  x.dist = 0;
+  Q_enq (Q, N, qt, x);
+  visit[start] = true;
+
+  // distance level
+  octave_idx_type level = 0;
+  // current largest "eccentricity"
+  octave_idx_type max_dist = 0;
+
+  for (;;)
+    {
+      while (! Q_empty (Q, N, qh, qt))
+	{
+	  CMK_Node v = Q_deq (Q, N, qh);
+
+	  if (v.dist > x.dist || (v.id != x.id && v.deg > x.deg))
+	    x = v;
+
+	  octave_idx_type i = v.id;
+
+	  // add all unvisited neighbors to the queue
+	  octave_idx_type j1 = cidx[i];
+	  octave_idx_type j2 = cidx2[i];
+	  while (j1 < cidx[i+1] || j2 < cidx2[i+1])
+	    {
+	      OCTAVE_QUIT;
+
+	      if (j1 == cidx[i+1])
+		{
+		  octave_idx_type r2 = ridx2[j2++];
+		  if (! visit[r2])
+		    {
+		      // the distance of node j is dist(i)+1
+		      w.id = r2;
+		      w.deg = D[r2];
+		      w.dist = v.dist+1;
+		      Q_enq (Q, N, qt, w);
+		      visit[r2] = true;
+
+		      if (w.dist > level)
+			level = w.dist;
+		    }
+		}
+	      else if (j2 == cidx2[i+1])
+		{
+		  octave_idx_type r1 = ridx[j1++];
+		  if (! visit[r1])
+		    {
+		      // the distance of node j is dist(i)+1
+		      w.id = r1;
+		      w.deg = D[r1];
+		      w.dist = v.dist+1;
+		      Q_enq (Q, N, qt, w);
+		      visit[r1] = true;
+
+		      if (w.dist > level)
+			level = w.dist;
+		    }
+		}
+	      else
+		{
+		  octave_idx_type r1 = ridx[j1];
+		  octave_idx_type r2 = ridx2[j2];
+		  if (r1 <= r2)
+		    {
+		      if (! visit[r1])
+			{
+			  w.id = r1;
+			  w.deg = D[r1];
+			  w.dist = v.dist+1;
+			  Q_enq (Q, N, qt, w);
+			  visit[r1] = true;
+
+			  if (w.dist > level)
+			    level = w.dist;
+			}
+		      j1++;
+		      if (r1 == r2)
+			j2++;
+		    }
+		  else
+		    {
+		      if (! visit[r2])
+			{
+			  w.id = r2;
+			  w.deg = D[r2];
+			  w.dist = v.dist+1;
+			  Q_enq (Q, N, qt, w);
+			  visit[r2] = true;
+
+			  if (w.dist > level)
+			    level = w.dist;
+			}
+		      j2++;
+		    }
+		}
+	    }
+	} // finish of BFS
+
+      if (max_dist < x.dist)
+	{
+	  max_dist = x.dist;
+
+	  for (octave_idx_type i = 0; i < N; i++)
+	    visit[i] = false;
+
+	  visit[x.id] = true;
+	  x.dist = 0;
+	  qt = qh = 0;
+	  Q_enq (Q, N, qt, x);
+	}
+      else
+	break;
+    }
+  return x.id;
+}
 
 // Calculates the node's degrees. This means counting the non-zero elements
 // in the symmetric matrix' rows. This works for non-symmetric matrices 
 // as well.
-static octave_idx_type
-calc_degrees(octave_idx_type N, const octave_idx_type *ridx, 
-	     const octave_idx_type *cidx, octave_idx_type *D);
+
+static octave_idx_type 
+calc_degrees (octave_idx_type N, const octave_idx_type *ridx, 
+	      const octave_idx_type *cidx, octave_idx_type *D)
+{
+  octave_idx_type max_deg = 0;
+
+  for (octave_idx_type i = 0; i < N; i++) 
+    D[i] = 0;
+
+  for (octave_idx_type j = 0; j < N; j++)
+    {
+      for (octave_idx_type i = cidx[j]; i < cidx[j+1]; i++)
+	{
+	  OCTAVE_QUIT;
+	  octave_idx_type k = ridx[i];
+	  // there is a non-zero element (k,j)
+	  D[k]++;
+	  if (D[k] > max_deg) 
+	    max_deg = D[k];
+	  // if there is no element (j,k) there is one in
+	  // the symmetric matrix:
+	  if (k != j)
+	    {
+	      bool found = false;
+	      for (octave_idx_type l = cidx[k]; l < cidx[k + 1]; l++)
+		{
+		  OCTAVE_QUIT;
+
+		  if (ridx[l] == j)
+		    {
+		      found = true;
+		      break;
+		    }
+		  else if (ridx[l] > j)
+		    break;
+		}
+
+	      if (! found)
+		{
+		  // A(j,k) == 0
+		  D[j]++;
+		  if (D[j] > max_deg) 
+		    max_deg = D[j];
+		}
+	    }
+	}
+    }
+  return max_deg;
+}
 
 // Transpose of the structure of a square sparse matrix
+
 static void
 transpose (octave_idx_type N, const octave_idx_type *ridx, 
 	   const octave_idx_type *cidx, octave_idx_type *ridx2, 
-	   octave_idx_type *cidx2);
+	   octave_idx_type *cidx2)
+{
+  octave_idx_type nz = cidx[N];
+
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, w, N + 1);
+  for (octave_idx_type i = 0; i < N; i++)
+    w[i] = 0;
+  for (octave_idx_type i = 0; i < nz; i++)
+    w[ridx[i]]++;
+  nz = 0;
+  for (octave_idx_type i = 0; i < N; i++)
+    {
+      OCTAVE_QUIT;
+      cidx2[i] = nz;
+      nz += w[i];
+      w[i] = cidx2[i];
+    }
+  cidx2[N] = nz;
+  w[N] = nz;
+
+  for (octave_idx_type j = 0; j < N; j++)
+    for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
+      {
+	OCTAVE_QUIT;
+	octave_idx_type q = w [ridx[k]]++;
+	ridx2[q] = j;
+      }
+}
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} = } symrcm (@var{S})\n\
 Symmetric reverse Cuthill-McKee permutation of @var{S}.\n\
 Return a permutation vector @var{p} such that\n\
 @code{@var{S} (@var{p}, @var{p})} tends to have its diagonal elements\n\
@@ -163,154 +436,146 @@ 1969, Brandon Press, New Jersey.\n\
 Alan George, Joseph W. H. Liu: Computer Solution of Large Sparse\n\
 Positive Definite Systems, Prentice Hall Series in Computational\n\
 Mathematics, ISBN 0-13-165274-5, 1981.\n\
 \n\
 @seealso{colperm, colamd, symamd}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
-  octave_value arg = args (0);
+  octave_value arg = args(0);
 
   // the parameter of the matrix is converted into a sparse matrix 
   //(if necessary)
   octave_idx_type *cidx;
   octave_idx_type *ridx;
   SparseMatrix Ar;
   SparseComplexMatrix Ac;
 
   if (arg.is_real_type ())
     {
-      Ar = arg.sparse_matrix_value();
+      Ar = arg.sparse_matrix_value ();
       // Note cidx/ridx are const, so use xridx and xcidx...
       cidx = Ar.xcidx ();
       ridx = Ar.xridx ();
     }
   else
     {
-      Ac = arg.sparse_complex_matrix_value();
+      Ac = arg.sparse_complex_matrix_value ();
       cidx = Ac.xcidx ();
       ridx = Ac.xridx ();
     }
 
   if (error_state)
     return retval;
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
     {
-      gripe_square_matrix_required("symrcm");
+      gripe_square_matrix_required ("symrcm");
       return retval;
     }
 
   if (nr == 0 && nc == 0)
-    {
-      retval = NDArray (dim_vector (1, 0));
-      return retval;
-    }
-  
+    return octave_value (NDArray (dim_vector (1, 0)));
+
   // sizes of the heaps
   octave_idx_type s = 0;
+
   // head- and tail-indices for the queue
-  octave_idx_type qt=0, qh=0;
+  octave_idx_type qt = 0, qh = 0;
   CMK_Node v, w;
-  octave_idx_type c;
-  octave_idx_type i, j, max_deg;
-  // upper bound for the bandwidth (=quality of solution)
-  octave_idx_type B;
-  // lower bound for the bandwidth of a subgraph
-  octave_idx_type Bsub;
-  octave_idx_type level, level_N;
   // dimension of the matrix
-  octave_idx_type N;
-  
-  N = nr;
+  octave_idx_type N = nr;
+
   OCTAVE_LOCAL_BUFFER (octave_idx_type, cidx2, N + 1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, ridx2, cidx[N]);
   transpose (N, ridx, cidx, ridx2, cidx2);
 
   // the permutation vector
   NDArray P (dim_vector (1, N));
 
   // compute the node degrees
-  OCTAVE_LOCAL_BUFFER(octave_idx_type, D, N);
-  max_deg = calc_degrees(N, ridx, cidx, D);
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, D, N);
+  octave_idx_type max_deg = calc_degrees (N, ridx, cidx, D);
 
   // if none of the nodes has a degree > 0 (a matrix of zeros)
   // the return value corresponds to the identity permutation
   if (max_deg == 0)
     {
-      for (i = 0; i < N; i++) 
-	P (i) = i;
-      retval = P;
-      return retval;
+      for (octave_idx_type i = 0; i < N; i++) 
+	P(i) = i;
+      return octave_value (P);
     }
 
   // a heap for the a node's neighbors. The number of neighbors is
   // limited by the maximum degree max_deg:
-  OCTAVE_LOCAL_BUFFER(CMK_Node, S, max_deg);
+  OCTAVE_LOCAL_BUFFER (CMK_Node, S, max_deg);
 
   // a queue for the BFS. The array is always one element larger than
   // the number of entries that are stored.
-  OCTAVE_LOCAL_BUFFER(CMK_Node, Q, N+1);
+  OCTAVE_LOCAL_BUFFER (CMK_Node, Q, N+1);
 
   // a counter (for building the permutation)
-  c = -1;
+  octave_idx_type c = -1;
 
+  // upper bound for the bandwidth (=quality of solution)
   // initialize the bandwidth of the graph with 0. B contains the
   // the maximum of the theoretical lower limits of the subgraphs
   // bandwidths.
-  B = 0;
+  octave_idx_type B = 0;
 
   // mark all nodes as unvisited; with the exception of the nodes
   // that have degree==0 and build a CC of the graph.
 	
   boolNDArray btmp (dim_vector (1, N), false);
   bool *visit = btmp.fortran_vec ();
 
   do
     {
       // locate an unvisited starting node of the graph
+      octave_idx_type i;
       for (i = 0; i < N; i++)
 	if (! visit[i]) 
 	  break;
 
       // locate a probably better starting node
       v.id = find_starting_node (N, ridx, cidx, ridx2, cidx2, D, i);
 		
       // mark the node as visited and enqueue it (a starting node
       // for the BFS). Since the node will be a root of a spanning
       // tree, its dist is 0.
       v.deg = D[v.id];
       v.dist = 0;
       visit[v.id] = true;
-      Q_enq (Q, N, qh, qt, v);
+      Q_enq (Q, N, qt, v);
 
+      // lower bound for the bandwidth of a subgraph
       // keep a "level" in the spanning tree (= min. distance to the
       // root) for determining the bandwidth of the computed
       // permutation P
-      Bsub = 0;
+      octave_idx_type Bsub = 0;
       // min. dist. to the root is 0
-      level = 0;
+      octave_idx_type level = 0;
       // the root is the first/only node on level 0
-      level_N = 1;
+      octave_idx_type level_N = 1;
 	
       while (! Q_empty (Q, N, qh, qt))
 	{
-	  v = Q_deq (Q, N, qh, qt);
+	  v = Q_deq (Q, N, qh);
 	  i = v.id;
 
 	  c++;
 
 	  // for computing the inverse permutation P where
 	  // A(inv(P),inv(P)) or P'*A*P is banded
 	  //	     P(i) = c;
 			
@@ -381,17 +646,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
 			  visit[r2] = true;
 			}
 		      j2++;
 		    }
 		}
 	    }
 
 	  // add the neighbors to the queue (sorted by node degree)
-	  while (! H_empty(S, s))
+	  while (! H_empty (S, s))
 	    {
 	      OCTAVE_QUIT;
 
 	      // locate a neighbor of i with minimal degree in O(log(N))
 	      v = H_remove_min(S, s, 1);
 	
 	      // entered the BFS a new level?
 	      if (v.dist > level)
@@ -410,17 +675,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
 	      else
 		{
 		  // there is no new level but another node on
 		  // this level:
 		  level_N++;
 		}
 	
 	      // enqueue v in O(1)
-	      Q_enq (Q, N, qh, qt, v);
+	      Q_enq (Q, N, qt, v);
 	    }
 	
 	  // synchronize the bandwidth with level_N once again:
 	  if (Bsub < level_N)
 	    Bsub = level_N;
 	}
       // finish of BFS. If there are still unvisited nodes in the graph
       // then it is split into CCs. The computed bandwidth is the maximum
@@ -428,326 +693,18 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
       if (Bsub > B)
 	B = Bsub;
     }
   // are there any nodes left?
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
-  for (i = 0, j = N - 1; i <= s; i++, j--)
+  for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
     {
       double tmp = P.elem(i);
       P.elem(i) = P.elem(j);
       P.elem(j) = tmp;
     }
 
   // increment all indices, since Octave is not C
-  retval = P+1;
-  return retval;
-}
-
-//
-// implementatation of static functions
-//
-
-inline static void 
-Q_enq (CMK_Node *Q, octave_idx_type N, octave_idx_type& qh,
-       octave_idx_type& qt, const CMK_Node& o)
-{	
-  Q[qt] = o;
-  qt = (qt + 1) % (N + 1);
-}
-
-inline static CMK_Node 
-Q_deq(CMK_Node * Q, octave_idx_type N, octave_idx_type &qh,
-      octave_idx_type &qt)
-{
-  CMK_Node r = Q[qh];
-  qh = (qh + 1) % (N + 1);
-  return r;
-}
-
-static void 
-H_heapify_min(CMK_Node *A, octave_idx_type i, octave_idx_type size)
-{
-  octave_idx_type j, l, r;
-  octave_idx_type smallest;
-  CMK_Node tmp;
-
-  j = i;
-  for (;;)
-    {
-      l = LEFT(j);
-      r = RIGHT(j);
-
-      if (l<size && A[l].deg<A[j].deg)
-	smallest = l;
-      else
-	smallest = j;
-
-      if (r < size && A[r].deg < A[smallest].deg)
-	smallest = r;
-
-      if (smallest != j)
-	{
-	  tmp = A[j];
-	  A[j] = A[smallest];
-	  A[smallest] = tmp;
-	  j = smallest;
-	}
-      else 
-	break;
-    }
-}
-
-static void 
-H_insert(CMK_Node *H, octave_idx_type &h, const CMK_Node &o)
-{
-  octave_idx_type i = h++;
-  octave_idx_type p;
-  CMK_Node tmp;
-
-  H[i] = o;
-
-  if (i == 0) 
-    return;
-  do
-    {
-      p = PARENT(i);
-      if (H[i].deg < H[p].deg)
-	{
-	  tmp = H[i];
-	  H[i] = H[p];
-	  H[p] = tmp;
-
-	  i = p;
-	}
-      else 
-	break;
-    }
-  while (i > 0);
-}
-
-inline static CMK_Node 
-H_remove_min(CMK_Node *H, octave_idx_type &h, int reorg/*=1*/)
-{
-  CMK_Node r = H[0];
-  H[0] = H[--h];
-  if (reorg) 
-    H_heapify_min(H, 0, h);
-  return r;
+  return octave_value (P+1);
 }
-
-static octave_idx_type 
-find_starting_node(octave_idx_type N, const octave_idx_type *ridx, 
-		   const octave_idx_type *cidx,  const octave_idx_type *ridx2, 
-		   const octave_idx_type *cidx2, octave_idx_type *D, 
-		   octave_idx_type start)
-{
-  octave_idx_type i, j, qt, qh, level, max_dist;
-  CMK_Node v, w, x;
-
-  OCTAVE_LOCAL_BUFFER(CMK_Node, Q, N+1);
-  boolNDArray btmp (dim_vector (1, N), false);
-  bool * visit = btmp.fortran_vec ();
-
-  qh = qt = 0;
-  x.id = start;
-  x.deg = D[start];
-  x.dist = 0;
-  Q_enq (Q, N, qh, qt, x);
-  visit[start] = true;
-
-  // distance level
-  level = 0;
-  // current largest "eccentricity"
-  max_dist = 0;
-
-  for (;;)
-    {
-      while (! Q_empty(Q, N, qh, qt))
-	{
-	  v = Q_deq(Q, N, qh, qt);
-
-	  if (v.dist > x.dist || (v.id != x.id && v.deg > x.deg))
-	    x = v;
-
-	  i = v.id;
-
-	  // add all unvisited neighbors to the queue
-	  octave_idx_type j1 = cidx[i];
-	  octave_idx_type j2 = cidx2[i];
-	  while (j1 < cidx[i+1] || j2 < cidx2[i+1])
-	    {
-	      OCTAVE_QUIT;
-
-	      if (j1 == cidx[i+1])
-		{
-		  octave_idx_type r2 = ridx2[j2++];
-		  if (! visit[r2])
-		    {
-		      // the distance of node j is dist(i)+1
-		      w.id = r2;
-		      w.deg = D[r2];
-		      w.dist = v.dist+1;
-		      Q_enq(Q, N, qh, qt, w);
-		      visit[r2] = true;
-
-		      if (w.dist > level)
-			level = w.dist;
-		    }
-		}
-	      else if (j2 == cidx2[i+1])
-		{
-		  octave_idx_type r1 = ridx[j1++];
-		  if (! visit[r1])
-		    {
-		      // the distance of node j is dist(i)+1
-		      w.id = r1;
-		      w.deg = D[r1];
-		      w.dist = v.dist+1;
-		      Q_enq(Q, N, qh, qt, w);
-		      visit[r1] = true;
-
-		      if (w.dist > level)
-			level = w.dist;
-		    }
-		}
-	      else
-		{
-		  octave_idx_type r1 = ridx[j1];
-		  octave_idx_type r2 = ridx2[j2];
-		  if (r1 <= r2)
-		    {
-		      if (! visit[r1])
-			{
-			  w.id = r1;
-			  w.deg = D[r1];
-			  w.dist = v.dist+1;
-			  Q_enq(Q, N, qh, qt, w);
-			  visit[r1] = true;
-
-			  if (w.dist > level)
-			    level = w.dist;
-			}
-		      j1++;
-		      if (r1 == r2)
-			j2++;
-		    }
-		  else
-		    {
-		      if (! visit[r2])
-			{
-			  w.id = r2;
-			  w.deg = D[r2];
-			  w.dist = v.dist+1;
-			  Q_enq(Q, N, qh, qt, w);
-			  visit[r2] = true;
-
-			  if (w.dist > level)
-			    level = w.dist;
-			}
-		      j2++;
-		    }
-		}
-	    }
-	} // finish of BFS
-
-      if (max_dist < x.dist)
-	{
-	  max_dist = x.dist;
-
-	  for (i = 0; i < N; i++)
-	    visit[i] = false;
-
-	  visit[x.id] = true;
-	  x.dist = 0;
-	  qt = qh = 0;
-	  Q_enq (Q, N, qh, qt, x);
-	}
-      else
-	break;
-    }
-  return x.id;
-}
-
-static octave_idx_type 
-calc_degrees(octave_idx_type N, const octave_idx_type *ridx, 
-	     const octave_idx_type *cidx, octave_idx_type *D)
-{
-  octave_idx_type max_deg = 0;
-
-  for (octave_idx_type i = 0; i < N; i++) 
-    D[i] = 0;
-
-  for (octave_idx_type j = 0; j < N; j++)
-    {
-      for (octave_idx_type i = cidx[j]; i < cidx[j+1]; i++)
-	{
-	  OCTAVE_QUIT;
-	  octave_idx_type k = ridx[i];
-	  // there is a non-zero element (k,j)
-	  D[k]++;
-	  if (D[k] > max_deg) 
-	    max_deg = D[k];
-	  // if there is no element (j,k) there is one in
-	  // the symmetric matrix:
-	  if (k != j)
-	    {
-	      bool found = false;
-	      for (octave_idx_type l = cidx[k]; l < cidx[k + 1]; l++)
-		{
-		  OCTAVE_QUIT;
-
-		  if (ridx[l] == j)
-		    {
-		      found = true;
-		      break;
-		    }
-		  else if (ridx[l] > j)
-		    break;
-		}
-
-	      if (! found)
-		{
-		  // A(j,k) == 0
-		  D[j]++;
-		  if (D[j] > max_deg) 
-		    max_deg = D[j];
-		}
-	    }
-	}
-    }
-  return max_deg;
-}
-
-static void
-transpose (octave_idx_type N, const octave_idx_type *ridx, 
-	   const octave_idx_type *cidx, octave_idx_type *ridx2, 
-	   octave_idx_type *cidx2)
-{
-  octave_idx_type nz = cidx[N];
-
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, w, N + 1);
-  for (octave_idx_type i = 0; i < N; i++)
-    w[i] = 0;
-  for (octave_idx_type i = 0; i < nz; i++)
-    w[ridx[i]]++;
-  nz = 0;
-  for (octave_idx_type i = 0; i < N; i++)
-    {
-      OCTAVE_QUIT;
-      cidx2[i] = nz;
-      nz += w[i];
-      w[i] = cidx2[i];
-    }
-  cidx2[N] = nz;
-  w[N] = nz;
-
-  for (octave_idx_type j = 0; j < N; j++)
-    for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
-      {
-	OCTAVE_QUIT;
-	octave_idx_type q = w [ridx[k]]++;
-	ridx2[q] = j;
-      }
-}
diff --git a/src/OPERATORS/op-streamoff.cc b/src/OPERATORS/op-streamoff.cc
--- a/src/OPERATORS/op-streamoff.cc
+++ b/src/OPERATORS/op-streamoff.cc
@@ -90,18 +90,18 @@ DEFNDBINOP_OP (sub_s_so, scalar, streamo
 	    if (cm2.rows () == 1 && cm2.columns () == 1) \
 	      MX_SC_BOOL_OP (streamoff_array, m, cm1, std::streamoff, \
 			     c, cm2(0,0), c OP m(i,j), 0.0); \
 	    else \
 	      MX_MX_BOOL_OP (streamoff_array, m1, cm1, streamoff_array, \
 			     m2, cm2, m1(i,j) OP m2(i,j), #OP, 0.0, 1.0); \
 	  } \
       } \
-    else \
-      return octave_value (); \
+ \
+    return boolMatrix (); \
   }
 
 STREAMOFF_COMP_OP (eq, ==, streamoff, streamoff);
 STREAMOFF_COMP_OP (ne, !=, streamoff, streamoff);
 
 STREAMOFF_COMP_OP (eq_so_m, ==, streamoff, matrix);
 STREAMOFF_COMP_OP (ne_so_m, !=, streamoff, matrix);
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -883,17 +883,17 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, "cat");
 }
 
 static octave_value
-do_permute (const octave_value_list& args, bool inv, const std::string& fname)
+do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
     {
       Array<int> vec = args(1).int_vector_value ();
 
       // FIXME -- maybe we should create an idx_vector object
@@ -919,32 +919,32 @@ DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})\n\
 Return the generalized transpose for an N-d array object @var{a}.\n\
 The permutation vector @var{perm} must contain the elements\n\
 @code{1:ndims(a)} (in any order, but each element must appear just once).\n\
 @seealso{ipermute}\n\
 @end deftypefn")
 {
-  return do_permute (args, false, "permute");
+  return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
 ipermute (permute (a, perm), perm)\n\
 @end example\n\
 returns the original array @var{a}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
-  return do_permute (args, true, "ipermute");
+  return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
 Return the `length' of the object @var{a}.  For matrix objects, the\n\
 length is the number of rows or columns, whichever is greater (this\n\
 odd definition is used for compatibility with @sc{Matlab}).\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -832,17 +832,17 @@ location of the error. Typically @var{er
 @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length();
 
   if (nargin != 1)
-    print_usage();
+    print_usage ();
   else
     {
       Octave_map err = args(0).map_value ();
 
       if (! error_state)
 	{
 	  if (err.contains ("message") && err.contains ("identifier"))
 	    {
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1242,17 +1242,17 @@ write_header (std::ostream& os, load_sav
 	os.write (&tmp, 1);
       }
       break;
 
     case LS_MAT5_BINARY:
     case LS_MAT7_BINARY:
       {
 	char const * versionmagic;
-	int16_t number = *(int16_t *)"\x00\x01";
+	int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
 	struct tm bdt;
 	time_t now;
 	char headertext[128];
 
 	time (&now);
 	bdt = *gmtime (&now);
 	memset (headertext, ' ', 124);
 	// ISO 8601 format date
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -26,26 +26,26 @@ 02110-1301, USA.
 #endif
 
 #include "error.h"
 #include "str-vec.h"
 
 #include "oct-map.h"
 #include "utils.h"
 
-Octave_map::Octave_map (const dim_vector& dv, const Cell& keys)
+Octave_map::Octave_map (const dim_vector& dv, const Cell& key_vals)
   : map (), key_list (), dimensions (dv)
 {
   Cell c (dv);
 
-  if (keys.is_cellstr ())
+  if (key_vals.is_cellstr ())
     {
-      for (octave_idx_type i = 0; i < keys.numel (); i++)
+      for (octave_idx_type i = 0; i < key_vals.numel (); i++)
 	{
-	  std::string k = keys(i).string_value ();
+	  std::string k = key_vals(i).string_value ();
 	  map[k] = c;
 	  key_list.push_back (k);
 	}
     }
   else
     error ("Octave_map: expecting keys to be cellstr");
 }
 
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -42,17 +42,17 @@ Octave_map
   typedef std::map<std::string, Cell>::const_iterator const_iterator;
 
   typedef std::list<std::string>::iterator key_list_iterator;
   typedef std::list<std::string>::const_iterator const_key_list_iterator;
 
   // Warning!  You should always use at least two dimensions.
 
   Octave_map (const dim_vector& dv = dim_vector (0, 0),
-	      const Cell& keys = Cell ());
+	      const Cell& key_vals = Cell ());
 
   Octave_map (const std::string& k, const octave_value& value)
     : map (), key_list (), dimensions (1, 1)
   {
     map[k] = value;
     key_list.push_back (k);
   }
 
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -83,25 +83,25 @@ octave_base_int_matrix<T>::convert_to_st
   for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
 
       typename T::elt_type tmp = this->matrix(i);
 
       typename T::elt_type::val_type ival = tmp.value ();
 
+      
       if (ival < 0 || ival > UCHAR_MAX)
 	{
 	  // FIXME -- is there something better we could do?
 
 	  ival = 0;
 
 	  if (! warned)
 	    {
-
 	      ::warning ("range error for conversion to character value");
 	      warned = true;
 	    }
 	}
       else
 	chm (i) = static_cast<char> (ival);
     }
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -421,18 +421,17 @@ pr_min_internal (const Matrix& m)
 
   return result;
 }
 
 // FIXME -- it would be nice to share more code among these
 // functions,..
 
 static void
-set_real_format (bool sign, int digits, bool inf_or_nan, bool int_only,
-		 int &fw)
+set_real_format (int digits, bool inf_or_nan, bool int_only, int &fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
   if (rat_format)
@@ -517,40 +516,38 @@ static void
 set_format (double d, int& fw)
 {
   curr_real_fmt = 0;
   curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
-  bool sign = (d < 0.0);
-
   bool inf_or_nan = (xisinf (d) || xisnan (d));
 
   bool int_only = (! inf_or_nan && D_NINT (d) == d);
 
   double d_abs = d < 0.0 ? -d : d;
 
   int digits = (inf_or_nan || d_abs == 0.0)
     ? 0 : static_cast<int> (floor (log10 (d_abs) + 1.0));
 
-  set_real_format (sign, digits, inf_or_nan, int_only, fw);
+  set_real_format (digits, inf_or_nan, int_only, fw);
 }
 
 static inline void
 set_format (double d)
 {
   int fw;
   set_format (d, fw);
 }
 
 static void
-set_real_matrix_format (bool sign, int x_max, int x_min,
-			bool inf_or_nan, int int_or_inf_or_nan, int& fw)
+set_real_matrix_format (int x_max, int x_min, bool inf_or_nan,
+			int int_or_inf_or_nan, int& fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
   if (rat_format)
@@ -664,49 +661,46 @@ static void
 set_format (const Matrix& m, int& fw, double& scale)
 {
   curr_real_fmt = 0;
   curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
-  bool sign = m.any_element_is_negative (true);
-
   bool inf_or_nan = m.any_element_is_inf_or_nan ();
 
   bool int_or_inf_or_nan = m.all_elements_are_int_or_inf_or_nan ();
 
   Matrix m_abs = m.abs ();
   double max_abs = pr_max_internal (m_abs);
   double min_abs = pr_min_internal (m_abs);
 
   int x_max = max_abs == 0.0
     ? 0 : static_cast<int> (floor (log10 (max_abs) + 1.0));
 
   int x_min = min_abs == 0.0
     ? 0 : static_cast<int> (floor (log10 (min_abs) + 1.0));
 
   scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0 : std::pow (10.0, x_max - 1);
 
-  set_real_matrix_format (sign, x_max, x_min, inf_or_nan,
-			  int_or_inf_or_nan, fw);
+  set_real_matrix_format (x_max, x_min, inf_or_nan, int_or_inf_or_nan, fw);
 }
 
 static inline void
 set_format (const Matrix& m)
 {
   int fw;
   double scale;
   set_format (m, fw, scale);
 }
 
 static void
-set_complex_format (bool sign, int x_max, int x_min, int r_x,
-		    bool inf_or_nan, int int_only, int& r_fw, int& i_fw)
+set_complex_format (int x_max, int x_min, int r_x, bool inf_or_nan,
+		    int int_only, int& r_fw, int& i_fw)
 {
   static float_format r_fmt;
   static float_format i_fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
@@ -845,18 +839,16 @@ set_format (const Complex& c, int& r_fw,
   curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   double rp = c.real ();
   double ip = c.imag ();
 
-  bool sign = (rp < 0.0);
-
   bool inf_or_nan = (xisinf (c) || xisnan (c));
 
   bool int_only = (D_NINT (rp) == rp && D_NINT (ip) == ip);
 
   double r_abs = rp < 0.0 ? -rp : rp;
   double i_abs = ip < 0.0 ? -ip : ip;
 
   int r_x = r_abs == 0.0
@@ -873,30 +865,29 @@ set_format (const Complex& c, int& r_fw,
       x_min = i_x;
     }
   else
     {
       x_max = i_x;
       x_min = r_x;
     }
 
-  set_complex_format (sign, x_max, x_min, r_x, inf_or_nan, int_only,
-		      r_fw, i_fw);
+  set_complex_format (x_max, x_min, r_x, inf_or_nan, int_only, r_fw, i_fw);
 }
 
 static inline void
 set_format (const Complex& c)
 {
   int r_fw, i_fw;
   set_format (c, r_fw, i_fw);
 }
 
 static void
-set_complex_matrix_format (bool sign, int x_max, int x_min,
-			   int r_x_max, int r_x_min, bool inf_or_nan,
+set_complex_matrix_format (int x_max, int x_min, int r_x_max,
+			   int r_x_min, bool inf_or_nan,
 			   int int_or_inf_or_nan, int& r_fw, int& i_fw)
 {
   static float_format r_fmt;
   static float_format i_fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
@@ -1049,18 +1040,16 @@ set_format (const ComplexMatrix& cm, int
   curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   Matrix rp = real (cm);
   Matrix ip = imag (cm);
 
-  bool sign = rp.any_element_is_negative (true);
-
   bool inf_or_nan = cm.any_element_is_inf_or_nan ();
 
   bool int_or_inf_or_nan = (rp.all_elements_are_int_or_inf_or_nan ()
 			    && ip.all_elements_are_int_or_inf_or_nan ());
 
   Matrix r_m_abs = rp.abs ();
   double r_max_abs = pr_max_internal (r_m_abs);
   double r_min_abs = pr_min_internal (r_m_abs);
@@ -1081,18 +1070,18 @@ set_format (const ComplexMatrix& cm, int
   int i_x_min = i_min_abs == 0.0
     ? 0 : static_cast<int> (floor (log10 (i_min_abs) + 1.0));
 
   int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
   int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
 
   scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0 : std::pow (10.0, x_max - 1);
 
-  set_complex_matrix_format (sign, x_max, x_min, r_x_max, r_x_min,
-			     inf_or_nan, int_or_inf_or_nan, r_fw, i_fw);
+  set_complex_matrix_format (x_max, x_min, r_x_max, r_x_min, inf_or_nan,
+			     int_or_inf_or_nan, r_fw, i_fw);
 }
 
 static inline void
 set_format (const ComplexMatrix& cm)
 {
   int r_fw, i_fw;
   double scale;
   set_format (cm, r_fw, i_fw, scale);
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -66,17 +66,17 @@ tree_constant::rvalue (int nargout)
     error ("invalid number of output arguments for constant expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_constant::dup (symbol_table *sym_tab)
+tree_constant::dup (symbol_table *)
 {
   tree_constant *new_tc
     = new tree_constant (val, orig_text, line (), column ());
 
   new_tc->copy_base (*this);
 
   return new_tc;
 }
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -155,17 +155,18 @@ gzfilebuf::close()
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Convert int open mode to mode string
 bool
 gzfilebuf::open_mode(std::ios_base::openmode mode,
                      char* c_mode) const
 {
-  bool testb = mode & std::ios_base::binary;
+  // FIXME -- do we need testb?
+  // bool testb = mode & std::ios_base::binary;
   bool testi = mode & std::ios_base::in;
   bool testo = mode & std::ios_base::out;
   bool testt = mode & std::ios_base::trunc;
   bool testa = mode & std::ios_base::app;
 
   // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
   // Original zfstream hardcoded the compression level to maximum here...
   // Double the time for less than 1% size improvement seems
