# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1447441826 18000
#      Fri Nov 13 14:10:26 2015 -0500
# Node ID 68e3a747ca0283a98d349de300207bb63a2e3374
# Parent  e15b7963746bb10d12ed1312c69682c476315b97
rename octave_value value extractors that accept error message args

* ov.h, ov.cc (octave_value::xcell_value, octave_value::xstring_value,
octave_value::xcellstr_value): Rename functions that accept error
message args.  Handle error directly.  Only forward to functions that
don't attempt type conversion.  Change all uses.
* ov-base.h, ov-base.cc (octave_base_value::xstring_value): Don't do
type conversion.
(octave_base_value::cell_value, octave_base_value::cellstr_value):
Delete versions that accept error message args.
* ov-str-mat.h, ov-str-mat.cc (octave_char_matrix_str::string_value,
octave_char_matrix_str::cell_value): Delete.

diff --git a/libinterp/corefcn/__dispatch__.cc b/libinterp/corefcn/__dispatch__.cc
--- a/libinterp/corefcn/__dispatch__.cc
+++ b/libinterp/corefcn/__dispatch__.cc
@@ -45,23 +45,23 @@ DEFUN (__dispatch__, args, nargout,
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 4)
     {
       std::string f, r, t;
 
-      f = args(0).string_value ("__dispatch__: first argument must be a function name");
+      f = args(0).xstring_value ("__dispatch__: first argument must be a function name");
 
       if (nargin > 1)
-        r = args(1).string_value ("__dispatch__: second argument must be a function name");
+        r = args(1).xstring_value ("__dispatch__: second argument must be a function name");
 
       if (nargin > 2)
-        t = args(2).string_value ("__dispatch__: third argument must be a type name");
+        t = args(2).xstring_value ("__dispatch__: third argument must be a type name");
 
       if (nargin == 1)
         {
           if (nargout > 0)
             {
               symbol_table::fcn_info::dispatch_map_type dm
                 = symbol_table::get_dispatch (f);
 
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -239,17 +239,17 @@ Generalized eigenvalue problem balancing
       std::string bal_job;
       if (nargout == 1)
         warning ("balance: used GEP, should have two output arguments");
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
         bal_job = "B";
       else
-        bal_job = args(2).string_value ("balance: OPT argument must be a string");
+        bal_job = args(2).xstring_value ("balance: OPT argument must be a string");
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
         {
           gripe_nonconformant ();
           return retval;
         }
 
       Matrix bb;
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -2458,17 +2458,17 @@ endfor\n\
 @end example\n\
 @seealso{cellslices, cellfun}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () >= 1)
     {
-      const Cell x = args(0).cell_value ("cellindexmat: X must be a cell");
+      const Cell x = args(0).xcell_value ("cellindexmat: X must be a cell");
       NoAlias<Cell> y(x.dims ());
       octave_idx_type nel = x.numel ();
       octave_value_list idx = args.slice (1, args.length () - 1);
 
       for (octave_idx_type i = 0; i < nel; i++)
         {
           octave_quit ();
 
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -75,17 +75,17 @@ Reference: @nospell{J. Villadsen}, @nosp
     }
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
-      std::string s = args(i).string_value ("colloc: expecting string argument \"left\" or \"right\"");
+      std::string s = args(i).xstring_value ("colloc: expecting string argument \"left\" or \"right\"");
 
       if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
           || s == "right")
         {
           right = 1;
         }
       else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
                || s == "left")
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -324,17 +324,17 @@ The size of the result is @code{max (siz
   convn_type ct;
 
   if (nargin < 2 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
   else if (nargin == 3)
-    shape = args(2).string_value ("convn: SHAPE must be a string");
+    shape = args(2).xstring_value ("convn: SHAPE must be a string");
 
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -6656,17 +6656,17 @@ ordered lists.\n\
   if (nargin > 2)
     {
       if (args(1).is_string ())
         {
           print_usage ();
           return retval;
         }
 
-      std::string mode = args(2).string_value ("sort: MODE must be a string");
+      std::string mode = args(2).xstring_value ("sort: MODE must be a string");
 
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
           error ("sort: MODE must be either \"ascend\" or \"descend\"");
@@ -6935,17 +6935,17 @@ Undocumented internal function.\n\
 static sortmode
 get_sort_mode_option (const octave_value& arg, const char *argn)
 {
   // FIXME: we initialize to UNSORTED here to avoid a GCC warning
   // about possibly using sortmode uninitialized.
   // FIXME: shouldn't these modes be scoped inside a class?
   sortmode smode = UNSORTED;
 
-  std::string mode = arg.string_value ("issorted: expecting %s argument to be a string", argn);
+  std::string mode = arg.xstring_value ("issorted: expecting %s argument to be a string", argn);
 
   if (mode == "ascending")
     smode = ASCENDING;
   else if (mode == "descending")
     smode = DESCENDING;
   else if (mode == "either")
     smode = UNSORTED;
   else
@@ -6990,17 +6990,17 @@ This function does not support sparse ma
 
   if (nargin > 1)
     {
       octave_value mode_arg;
 
       if (nargin == 3)
         smode = get_sort_mode_option (args(2), "third");
 
-      std::string tmp = args(1).string_value ("issorted: second argument must be a string");
+      std::string tmp = args(1).xstring_value ("issorted: second argument must be a string");
       if (tmp == "rows")
         by_rows = true;
       else
         smode = get_sort_mode_option (args(1), "second");
     }
 
   octave_value arg = args(0);
 
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1384,17 +1384,17 @@ function returns.\n\
   if (Vdebugging)
     {
       int nargin = args.length ();
 
       if (nargin > 1)
         print_usage ();
       else if (nargin == 1)
         {
-          std::string arg = args(0).string_value ("dbstep: input argument must be a string");
+          std::string arg = args(0).xstring_value ("dbstep: input argument must be a string");
 
           if (arg == "in")
             {
               Vdebugging = false;
 
               tree_evaluator::dbstep_flag = -1;
             }
           else if (arg == "out")
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -179,17 +179,17 @@ error message.\n\
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = Cell ();
 
   if (args.length () == 1)
     {
-      std::string dirname = args(0).string_value ("readdir: DIR must be a string");
+      std::string dirname = args(0).xstring_value ("readdir: DIR must be a string");
 
       dir_entry dir (dirname);
 
       if (dir)
         {
           string_vector dirlist = dir.read ();
           retval(1) = 0.0;
           retval(0) = Cell (dirlist.sort ());
@@ -235,23 +235,23 @@ When creating a directory permissions wi
   retval(0) = false;
 
   int nargin = args.length ();
 
   std::string dirname;
 
   if (nargin == 2)
     {
-      std::string parent = args(0).string_value ("mkdir: PARENT must be a string");
-      std::string dir = args(1).string_value ("mkdir: DIR must be a string");
+      std::string parent = args(0).xstring_value ("mkdir: PARENT must be a string");
+      std::string dir = args(1).xstring_value ("mkdir: DIR must be a string");
 
       dirname = file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
-    dirname = args(0).string_value ("mkdir: DIR must be a string");
+    dirname = args(0).xstring_value ("mkdir: DIR must be a string");
 
   if (nargin == 1 || nargin == 2)
     {
       std::string msg;
 
       dirname = file_ops::tilde_expand (dirname);
 
       file_stat fs (dirname);
@@ -307,17 +307,17 @@ identifier.\n\
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string dirname = args(0).string_value ("rmdir: DIR must be a string");
+      std::string dirname = args(0).xstring_value ("rmdir: DIR must be a string");
 
       std::string fulldir = file_ops::tilde_expand (dirname);
       int status = -1;
       std::string msg;
 
       if (nargin == 2)
         {
           if (args(1).string_value () == "s")
@@ -370,18 +370,18 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      std::string from = args(0).string_value ("link: OLD must be a string");
-      std::string to = args(1).string_value ("link: NEW must be a string");
+      std::string from = args(0).xstring_value ("link: OLD must be a string");
+      std::string to = args(1).xstring_value ("link: NEW must be a string");
 
       std::string msg;
 
       int status = octave_link (from, to, msg);
 
       if (status < 0)
         retval(1) = msg;
 
@@ -407,18 +407,18 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      std::string from = args(0).string_value ("symlink: OLD must be a string");
-      std::string to = args(1).string_value ("symlink: NEW must be a string");
+      std::string from = args(0).xstring_value ("symlink: OLD must be a string");
+      std::string to = args(1).xstring_value ("symlink: NEW must be a string");
 
       std::string msg;
 
       int status = octave_symlink (from, to, msg);
 
       if (status < 0)
         retval(1) = msg;
 
@@ -446,17 +446,17 @@ error message.\n\
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = std::string ();
 
   if (args.length () == 1)
     {
-      std::string symlink = args(0).string_value ("readlink: SYMLINK must be a string");
+      std::string symlink = args(0).xstring_value ("readlink: SYMLINK must be a string");
 
       std::string result;
       std::string msg;
 
       int status = octave_readlink (symlink, result, msg);
 
       if (status < 0)
         retval(2) = msg;
@@ -484,18 +484,18 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      std::string from = args(0).string_value ("rename: OLD must be a string");
-      std::string to = args(1).string_value ("rename: NEW must be a string");
+      std::string from = args(0).xstring_value ("rename: OLD must be a string");
+      std::string to = args(1).xstring_value ("rename: NEW must be a string");
 
       std::string msg;
 
       int status = octave_rename (from, to, msg);
 
       if (status < 0)
         retval(1) = msg;
 
@@ -654,17 +654,17 @@ It is @samp{/} (forward slash) under UNI
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = file_ops::dir_sep_str ();
   else if (args.length () == 1)
     {
-      std::string s = args(0).string_value ("filesep: argument must be a string");
+      std::string s = args(0).xstring_value ("filesep: argument must be a string");
       if (s == "all")
         retval = file_ops::dir_sep_chars ();
       else
         error ("filesep: argument must be \"all\"");
     }
   else
     print_usage ();
 
@@ -683,17 +683,17 @@ Query or set the character used to separ
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = dir_path::path_sep_str ();
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ("pathsep: argument must be a single character");
+      std::string sval = args(0).xstring_value ("pathsep: argument must be a single character");
 
       switch (sval.length ())
         {
         case 1:
           dir_path::path_sep_char (sval[0]);
           break;
 
         case 0:
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -533,19 +533,19 @@ do_stream_open (const std::string& name,
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
                 const octave_value& tc_arch, const char *fcn, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
-  std::string name = tc_name.string_value ("%s: file name must be a string", fcn);
-  std::string mode = tc_mode.string_value ("%s: file mode must be a string", fcn);
-  std::string arch = tc_arch.string_value ("%s: architecture type must be a string", fcn);
+  std::string name = tc_name.xstring_value ("%s: file name must be a string", fcn);
+  std::string mode = tc_mode.xstring_value ("%s: file mode must be a string", fcn);
+  std::string arch = tc_arch.xstring_value ("%s: architecture type must be a string", fcn);
 
   retval = do_stream_open (name, mode, arch, fid);
 
   return retval;
 }
 
 DEFUN (fopen, args, nargout,
        "-*- texinfo -*-\n\
@@ -1320,32 +1320,32 @@ do_fread (octave_stream& os, const octav
   octave_value retval;
 
   count = -1;
 
   Array<double> size = size_arg.vector_value ();
 
   if (! error_state)
     {
-      std::string prec = prec_arg.string_value ("fread: PRECISION must be a string");
+      std::string prec = prec_arg.xstring_value ("fread: PRECISION must be a string");
 
       int block_size = 1;
       oct_data_conv::data_type input_type;
       oct_data_conv::data_type output_type;
 
       oct_data_conv::string_to_data_type (prec, block_size,
                                           input_type, output_type);
 
       if (! error_state)
         {
           int skip = skip_arg.int_value (true);
 
           if (! error_state)
             {
-              std::string arch = arch_arg.string_value ("fread: ARCH architecture type must be a string");
+              std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
 
               oct_mach_info::float_format flt_fmt
                 = oct_mach_info::string_to_float_format (arch);
 
               retval = os.read (size, block_size, input_type,
                                 output_type, skip, flt_fmt, count);
             }
           else
@@ -1581,30 +1581,30 @@ The optional return value @var{count} co
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
 {
   int retval = -1;
 
-  std::string prec = prec_arg.string_value ("fwrite: PRECISION must be a string");
+  std::string prec = prec_arg.xstring_value ("fwrite: PRECISION must be a string");
 
   int block_size = 1;
   oct_data_conv::data_type output_type;
 
   oct_data_conv::string_to_data_type (prec, block_size, output_type);
 
   if (! error_state)
     {
       int skip = skip_arg.int_value (true);
 
       if (! error_state)
         {
-          std::string arch = arch_arg.string_value ("fwrite: ARCH architecture type must be a string");
+          std::string arch = arch_arg.xstring_value ("fwrite: ARCH architecture type must be a string");
 
           oct_mach_info::float_format flt_fmt
             = oct_mach_info::string_to_float_format (arch);
 
           retval = os.write (data, block_size, output_type,
                              skip, flt_fmt);
         }
       else
@@ -1796,18 +1796,18 @@ endwhile\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      std::string name = args(0).string_value ("popen: COMMAND must be a string");
-      std::string mode = args(1).string_value ("popen: MODE must be a string");
+      std::string name = args(0).xstring_value ("popen: COMMAND must be a string");
+      std::string mode = args(1).xstring_value ("popen: MODE must be a string");
 
       if (mode == "r")
         {
           octave_stream ips = octave_iprocstream::create (name);
 
           retval = octave_stream_list::insert (ips);
         }
       else if (mode == "w")
@@ -1870,22 +1870,22 @@ see @code{tmpfile}.\n\
 
   int len = args.length ();
 
   if (len < 3)
     {
       std::string dir;
 
       if (len > 0)
-        dir = args(0).string_value ("tempname: DIR must be a string");
+        dir = args(0).xstring_value ("tempname: DIR must be a string");
 
       std::string pfx ("oct-");
 
       if (len > 1)
-        pfx = args(1).string_value ("tempname: PREFIX must be a string");
+        pfx = args(1).xstring_value ("tempname: PREFIX must be a string");
 
       retval = octave_tempnam (dir, pfx);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -2018,17 +2018,17 @@ file, and @var{msg} is an empty string. 
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string tmpl8 = args(0).string_value ("mkstemp: TEMPLATE argument must be a string");
+      std::string tmpl8 = args(0).xstring_value ("mkstemp: TEMPLATE argument must be a string");
 
       OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
       strcpy (tmp, tmpl8.c_str ());
 
       int fd = gnulib::mkostemp (tmp, O_BINARY);
 
       if (fd < 0)
         {
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -80,17 +80,17 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
 {
   octave_value retval;
   bool lower = true;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
-      std::string s = args(2).string_value ("gammainc: third argument must be \"lower\" or \"upper\"");
+      std::string s = args(2).xstring_value ("gammainc: third argument must be \"lower\" or \"upper\"");
 
       std::transform (s.begin (), s.end (), s.begin (), tolower);
 
       if (s == "upper")
         lower = false;
       else if (s != "lower")
         error ("gammainc: third argument must be \"lower\" or \"upper\"");
     }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1668,17 +1668,17 @@ property::create (const std::string& nam
       retval = property (new any_property (name, h, ov));
     }
   else if (type.compare ("radio"))
     {
       if (args.length () < 1)
         error ("addproperty: missing possible values for radio property");
       else
         {
-          std::string sv = args(0).string_value ("addproperty: invalid argument for radio property, expected a string value");
+          std::string sv = args(0).xstring_value ("addproperty: invalid argument for radio property, expected a string value");
 
           retval = property (new radio_property (name, h, sv));
 
           if (args.length () > 1)
             retval.set (args(1));
         }
     }
   else if (type.compare ("double"))
@@ -2146,17 +2146,17 @@ graphics_object::set (const octave_value
   if (nargin == 0)
     error ("graphics_object::set: Nothing to set");
   else if (nargin % 2 != 0)
     error ("set: invalid number of arguments");
   else
     {
       for (int i = 0; i < nargin; i += 2)
         {
-          caseless_str pname = args(i).string_value ("set: expecting argument %d to be a property name", i);
+          caseless_str pname = args(i).xstring_value ("set: expecting argument %d to be a property name", i);
 
           octave_value val = args(i+1);
 
           set_value_or_default (pname, val);
         }
     }
 }
 
@@ -10019,17 +10019,17 @@ lists respectively.\n\
                       error ("get: vector of handles must all have same type");
                       break;
                     }
                 }
             }
 
           if (nargin > 1 && args(1).is_cellstr ())
             {
-              Array<std::string> plist = args(1).cellstr_value ("get: expecting property name or cell array of property names as second argument");
+              Array<std::string> plist = args(1).xcellstr_value ("get: expecting property name or cell array of property names as second argument");
 
               octave_idx_type plen = plist.numel ();
 
               use_cell_format = true;
 
               vals.resize (dim_vector (len, plen));
 
               for (octave_idx_type n = 0; n < len; n++)
@@ -10052,17 +10052,17 @@ lists respectively.\n\
                     }
                 }
             }
           else
             {
               caseless_str property;
 
               if (nargin > 1)
-                property = args(1).string_value ("get: expecting property name or cell array of property names as second argument");
+                property = args(1).xstring_value ("get: expecting property name or cell array of property names as second argument");
 
               vals.resize (dim_vector (len, 1));
 
               for (octave_idx_type n = 0; n < len; n++)
                 {
                   graphics_object go = gh_manager::get_object (hcv(n));
 
                   if (go)
@@ -10676,17 +10676,17 @@ Undocumented internal function.\n\
       double val = args(0).double_value ();
 
       if (! error_state)
         {
           graphics_handle h = gh_manager::lookup (val);
 
           if (h.ok ())
             {
-              std::string name = args(1).string_value ("__go_execute_callback__: invalid callback name");
+              std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
 
               if (nargin == 2)
                 gh_manager::execute_callback (h, name);
               else
                 gh_manager::execute_callback (h, name, args(2));
             }
           else
             error ("__go_execute_callback__: invalid graphics object (= %g)",
@@ -10850,17 +10850,17 @@ List @var{toolkit} as an available graph
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("register_graphics_toolkit: TOOLKIT must be a string");
+      std::string name = args(0).xstring_value ("register_graphics_toolkit: TOOLKIT must be a string");
 
       gtk_manager::register_toolkit (name);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -10964,19 +10964,19 @@ undocumented.\n\
               gh_manager::lock ();
             }
         }
       else if (args.length () >= 2 && args.length () <= 4)
         {
           std::string term, file, debug_file;
           bool mono;
 
-          term = args(0).string_value ("drawnow: invalid terminal TERM, expected a string value");
-
-          file = args(1).string_value ("drawnow: invalid FILE, expected a string value");
+          term = args(0).xstring_value ("drawnow: invalid terminal TERM, expected a string value");
+
+          file = args(1).xstring_value ("drawnow: invalid FILE, expected a string value");
 
           size_t pos_p = file.find_first_of ("|");
           size_t pos_c = file.find_first_not_of ("| ");
 
           if (pos_p == std::string::npos &&
               pos_c == std::string::npos)
             {
               error ("drawnow: empty output ''");
@@ -11019,17 +11019,17 @@ undocumented.\n\
                     }
                 }
             }
 
           mono = (args.length () >= 3 ? args(2).bool_value () : false);
 
           if (! error_state)
             {
-              debug_file = (args.length () > 3 ? args(3).string_value ("drawnow: invalid DEBUG_FILE, expected a string value") : "");
+              debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: invalid DEBUG_FILE, expected a string value") : "");
 
               graphics_handle h = gcf ();
 
               if (h.ok ())
                 {
                   graphics_object go = gh_manager::get_object (h);
 
                   gh_manager::unlock ();
@@ -11094,17 +11094,17 @@ addlistener (gcf, \"position\", @{@@my_l
   octave_value retval;
 
   if (args.length () >= 3 && args.length () <= 4)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
         {
-          std::string pname = args(1).string_value ("addlistener: invalid property name, expected a string value");
+          std::string pname = args(1).xstring_value ("addlistener: invalid property name, expected a string value");
 
           graphics_handle gh = gh_manager::lookup (h);
 
           if (gh.ok ())
             {
               graphics_object go = gh_manager::get_object (gh);
 
               go.add_property_listener (pname, args(2), POSTSET);
@@ -11161,17 +11161,17 @@ dellistener (gcf, \"position\", c);\n\
   octave_value retval;
 
   if (args.length () == 3 || args.length () == 2)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
         {
-          std::string pname = args(1).string_value ("dellistener: invalid property name, expected a string value");
+          std::string pname = args(1).xstring_value ("dellistener: invalid property name, expected a string value");
 
           graphics_handle gh = gh_manager::lookup (h);
 
           if (gh.ok ())
             {
               graphics_object go = gh_manager::get_object (gh);
 
               if (args.length () == 2)
@@ -11275,29 +11275,29 @@ addproperty (\"my_style\", gcf, \"lineli
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
-      std::string name = args(0).string_value ("addproperty: invalid property NAME, expected a string value");
+      std::string name = args(0).xstring_value ("addproperty: invalid property NAME, expected a string value");
 
       double h = args(1).double_value ();
 
       if (! error_state)
         {
           graphics_handle gh = gh_manager::lookup (h);
 
           if (gh.ok ())
             {
               graphics_object go = gh_manager::get_object (gh);
 
-              std::string type = args(2).string_value ("addproperty: invalid property TYPE, expected a string value");
+              std::string type = args(2).xstring_value ("addproperty: invalid property TYPE, expected a string value");
 
               if (! go.get_properties ().has_property (name))
                 {
                   property p = property::create (name, gh, type,
                                                  args.splice (0, 3));
 
                   go.get_properties ().insert_property (name, p);
                 }
diff --git a/libinterp/corefcn/gripes.cc b/libinterp/corefcn/gripes.cc
--- a/libinterp/corefcn/gripes.cc
+++ b/libinterp/corefcn/gripes.cc
@@ -158,16 +158,39 @@ gripe_wrong_type_arg (const char *name, 
 void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
                       bool is_error)
 {
   gripe_wrong_type_arg (name.c_str (), tc, is_error);
 }
 
 void
+gripe_wrong_type_arg (const char *s, bool is_error)
+{
+  if (is_error)
+    error ("wrong type argument '%s'", s);
+  else
+    warning ("wrong type argument '%s'", s);
+}
+
+void
+gripe_wrong_type_arg (const std::string& s, bool is_error)
+{
+  gripe_wrong_type_arg (s.c_str (), is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_value& tc, bool is_error)
+{
+  std::string type = tc.type_name ();
+
+  gripe_wrong_type_arg (type, is_error);
+}
+
+void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
   error ("invalid operand '%s' for unary operator", type.c_str ());
 }
 
 void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op)
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -90,16 +90,25 @@ extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
                       bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
                       bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const char *s, bool is_error = true);
+
+extern OCTINTERP_API void
+gripe_wrong_type_arg (const std::string& s, bool is_error = true);
+
+extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_value& tc, bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const char *id, const char *from, const char *to);
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1088,17 +1088,17 @@ The format is a string which is one of @
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text_from_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      const std::string name = args(0).string_value ("get_help_text: NAME must be a string");
+      const std::string name = args(0).xstring_value ("get_help_text: NAME must be a string");
 
       std::string text;
       std::string format;
 
       do_get_help_text (name, text, format);
 
       retval(1) = format;
       retval(0) = text;
@@ -1153,17 +1153,17 @@ The format is a string which is one of @
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      const std::string fname = args(0).string_value ("get_help_text_from_file: NAME must be a string");
+      const std::string fname = args(0).xstring_value ("get_help_text_from_file: NAME must be a string");
 
       std::string text;
       std::string format;
 
       do_get_help_text_from_file (fname, text, format);
 
       retval(1) = format;
       retval(0) = text;
@@ -1365,17 +1365,17 @@ Undocumented internal function.\n\
   // Get list of functions
   string_vector ffl = load_path::fcn_names ();
   string_vector afl = autoloaded_functions ();
 
   if (args.length () == 0)
     retval = Cell (ffl.append (afl));
   else
     {
-      std::string dir = args(0).string_value ("__list_functions__: DIRECTORY argument must be a string");
+      std::string dir = args(0).xstring_value ("__list_functions__: DIRECTORY argument must be a string");
 
       string_vector fl = load_path::files (dir, true);
 
       // Return a sorted list with unique entries (in case of
       // .m and .oct versions of the same function in a given
       // directory, for example).
       fl.sort (true);
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -688,17 +688,17 @@ get_user_input (const octave_value_list&
 
   int nargin = args.length ();
 
   int read_as_string = 0;
 
   if (nargin == 2)
     read_as_string++;
 
-  std::string prompt = args(0).string_value ("input: unrecognized argument");
+  std::string prompt = args(0).xstring_value ("input: unrecognized argument");
 
   flush_octave_stdout ();
 
   octave_pager_stream::reset ();
   octave_diary_stream::reset ();
 
   octave_diary << prompt;
 
@@ -831,17 +831,17 @@ string @samp{(yes or no) } to it.  The u
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
       std::string prompt;
 
       if (nargin == 1)
-        prompt = args(0).string_value ("yes_or_no: PROMPT must be a string");
+        prompt = args(0).xstring_value ("yes_or_no: PROMPT must be a string");
 
       retval = octave_yes_or_no (prompt);
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2234,28 +2234,28 @@ directories with those names.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_idx_type nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string dirname = args(0).string_value ("genpath: DIR must be a string");
+      std::string dirname = args(0).xstring_value ("genpath: DIR must be a string");
 
       retval = genpath (dirname);
     }
   else if (nargin > 1)
     {
-      std::string dirname = args(0).string_value ("genpath: all arguments must be strings");
+      std::string dirname = args(0).xstring_value ("genpath: all arguments must be strings");
 
       string_vector skip (nargin - 1);
 
       for (octave_idx_type i = 1; i < nargin; i++)
-        skip[i-1] = args(i).string_value ("genpath: all arguments must be strings");
+        skip[i-1] = args(i).xstring_value ("genpath: all arguments must be strings");
 
       retval = genpath (dirname, skip);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -2450,17 +2450,17 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
               return retval;
             }
         }
 
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
         {
-          std::string arg = args(i).string_value ("addpath: all arguments must be strings");
+          std::string arg = args(i).xstring_value ("addpath: all arguments must be strings");
 
           std::list<std::string> dir_elts = split_path (arg);
 
           if (! append)
             std::reverse (dir_elts.begin (), dir_elts.end ());
 
           for (std::list<std::string>::const_iterator p = dir_elts.begin ();
                p != dir_elts.end ();
@@ -2514,17 +2514,17 @@ rmpath (\"dir1:/dir2:~/dir3\")\n\
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
         {
-          std::string arg = args(i).string_value ("rmpath: all arguments must be strings");
+          std::string arg = args(i).xstring_value ("rmpath: all arguments must be strings");
           std::list<std::string> dir_elts = split_path (arg);
 
           for (std::list<std::string>::const_iterator p = dir_elts.begin ();
                p != dir_elts.end ();
                p++)
             {
               std::string dir = *p;
 
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -210,17 +210,17 @@ LU@tie{}factorization.  Once the matrix 
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
 
-              std::string str_typ = args(1).string_value ("matrix_type: TYPE must be a string");
+              std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
 
               // FIXME: why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType ();
 
               octave_idx_type nl = 0;
               octave_idx_type nu = 0;
 
               // Use STL function to convert to lower case
@@ -388,17 +388,17 @@ LU@tie{}factorization.  Once the matrix 
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
 
-              std::string str_typ = args(1).string_value ("matrix_type: TYPE must be a string");
+              std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
 
               // FIXME: why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
 
               // Use STL function to convert to lower case
               std::transform (str_typ.begin (), str_typ.end (),
                               str_typ.begin (), tolower);
 
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -167,17 +167,17 @@ do_history (const octave_value_list& arg
         }
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < nargin - 1)
             {
               std::string fname
-                = args(++i).string_value ("history: expecting file name for %s option",
+                = args(++i).xstring_value ("history: expecting file name for %s option",
                                           option.c_str ());
 
               command_history::set_file (fname);
             }
           else
             command_history::set_file (default_history_file ());
 
           if (option == "-a")
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -117,25 +117,25 @@ DEFUN (__octave_link_edit_file__, args, 
 @deftypefn {Built-in Function} {} __octave_link_edit_file__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string file = args(0).string_value ("expecting file name as argument");
+      std::string file = args(0).xstring_value ("expecting file name as argument");
 
       flush_octave_stdout ();
 
       retval = octave_link::edit_file (file);
     }
   else if (args.length () == 2)
     {
-      std::string file = args(0).string_value ("expecting file name as first argument");
+      std::string file = args(0).xstring_value ("expecting file name as first argument");
 
       flush_octave_stdout ();
 
       retval = octave_link::prompt_new_edit_file (file);
     }
 
   return retval;
 }
@@ -145,19 +145,19 @@ DEFUN (__octave_link_message_dialog__, a
 @deftypefn {Built-in Function} {} __octave_link_message_dialog__ (@var{dlg}, @var{msg}, @var{title})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
-      std::string dlg = args(0).string_value ("invalid arguments");
-      std::string msg = args(1).string_value ("invalid arguments");
-      std::string title = args(2).string_value ("invalid arguments");
+      std::string dlg = args(0).xstring_value ("invalid arguments");
+      std::string msg = args(1).xstring_value ("invalid arguments");
+      std::string title = args(2).xstring_value ("invalid arguments");
 
       flush_octave_stdout ();
 
       retval = octave_link::message_dialog (dlg, msg, title);
     }
 
   return retval;
 }
@@ -167,22 +167,22 @@ DEFUN (__octave_link_question_dialog__, 
 @deftypefn {Built-in Function} {} __octave_link_question_dialog__ (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{btn3}, @var{default})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 6)
     {
-      std::string msg = args(0).string_value ("invalid arguments");
-      std::string title = args(1).string_value ("invalid arguments");
-      std::string btn1 = args(2).string_value ("invalid arguments");
-      std::string btn2 = args(3).string_value ("invalid arguments");
-      std::string btn3 = args(4).string_value ("invalid arguments");
-      std::string btndef = args(5).string_value ("invalid arguments");
+      std::string msg = args(0).xstring_value ("invalid arguments");
+      std::string title = args(1).xstring_value ("invalid arguments");
+      std::string btn1 = args(2).xstring_value ("invalid arguments");
+      std::string btn2 = args(3).xstring_value ("invalid arguments");
+      std::string btn3 = args(4).xstring_value ("invalid arguments");
+      std::string btndef = args(5).xstring_value ("invalid arguments");
 
       flush_octave_stdout ();
 
       retval = octave_link::question_dialog (msg, title, btn1, btn2, btn3,
                                              btndef);
     }
 
   return retval;
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -400,17 +400,17 @@ compatibility with @sc{matlab}.\n\
   // Determine ordering option.
   volatile char ord_job = 0;
   static double safmin;
 
   if (nargin == 2)
     ord_job = 'N';
   else
     {
-      std::string tmp = args(2).string_value ("qz: OPT must be a string");
+      std::string tmp = args(2).xstring_value ("qz: OPT must be a string");
 
       if (! tmp.empty ())
         ord_job = tmp[0];
 
       if (! (ord_job == 'N' || ord_job == 'n'
              || ord_job == 'S' || ord_job == 's'
              || ord_job == 'B' || ord_job == 'b'
              || ord_job == '+' || ord_job == '-'))
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -283,17 +283,17 @@ parse_options (regexp::opts& options, co
   int nargin = args.length ();
 
   extra_args = false;
 
   for (int i = skip; i < nargin; i++)
     {
       std::string str;
 
-      str = args(i).string_value ("%s: optional arguments must be strings", who.c_str ());
+      str = args(i).xstring_value ("%s: optional arguments must be strings", who.c_str ());
 
       std::transform (str.begin (), str.end (), str.begin (), tolower);
 
       if (str.find ("once", 0) == 0)
         options.once (true);
       else if (str.find ("matchcase", 0) == 0)
         options.case_insensitive (false);
       else if (str.find ("ignorecase", 0) == 0)
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -138,17 +138,17 @@ in control (see @code{are} and @code{dar
       return retval;
     }
 
   octave_value arg = args(0);
 
   std::string ord;
 
   if (nargin == 2)
-    ord = args(1).string_value ("schur: second argument must be a string");
+    ord = args(1).xstring_value ("schur: second argument must be a string");
 
   bool force_complex = false;
 
   if (ord == "real")
     {
       ord = std::string ();
     }
   else if (ord == "complex")
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -162,17 +162,17 @@ longer running time.\n\
           else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
             error ("spparms: too many elements in vector VALS");
           else
             octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
-      std::string str = args(0).string_value ("spparms: first argument must be a string");
+      std::string str = args(0).xstring_value ("spparms: first argument must be a string");
 
       double val = args(1).double_value ();
 
       if (error_state)
         error ("spparms: second argument must be a real scalar");
       else if (str == "umfpack")
         warning ("spparms: request to disable umfpack solvers ignored");
       else if (!octave_sparse_params::set_key (str, val))
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -918,17 +918,17 @@ whos ans\n\
           error ("list_in_columns: WIDTH must be an integer");
           return retval;
         }
     }
 
   std::string prefix;
 
   if (nargin > 2)
-    prefix = args(2).string_value ("list_in_columns: PREFIX must be a string");
+    prefix = args(2).xstring_value ("list_in_columns: PREFIX must be a string");
 
   std::ostringstream buf;
 
   s.list_in_columns (buf, width, prefix);
 
   retval = buf.str ();
 
   return retval;
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1683,17 +1683,17 @@ determine whether functions defined in f
         default:
           retval = "none";
           break;
         }
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ("ignore_function_time_stamp: expecting argument to be a string");
+      std::string sval = args(0).xstring_value ("ignore_function_time_stamp: expecting argument to be a string");
 
       if (sval == "all")
         Vignore_function_time_stamp = 2;
       else if (sval == "system")
         Vignore_function_time_stamp = 1;
       else if (sval == "none")
         Vignore_function_time_stamp = 0;
       else
@@ -1814,17 +1814,17 @@ DEFUN (__get_cmdline_fcn_txt__, args, ,
 @deftypefn  {Built-in Function} {} __get_cmdline_fcn_txt__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("__get_cmd_line_function_text__: expecting function name");
+      std::string name = args(0).xstring_value ("__get_cmd_line_function_text__: expecting function name");
 
       octave_value ov = symbol_table::find_cmdline_function (name);
 
       octave_user_function *f = ov.user_function_value ();
 
       if (f)
         {
           std::ostringstream buf;
@@ -1847,33 +1847,33 @@ Undocumented internal function.\n\
 // FIXME: should we have functions like this in Octave?
 
 DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      std::string name = args(0).string_value ("set_variable: expecting variable name as first argument");
+      std::string name = args(0).xstring_value ("set_variable: expecting variable name as first argument");
 
       symbol_table::assign (name, args(1));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (variable_value, args, , "VALUE = variable_value (NAME)")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("variable_value: expecting variable name as first argument");
+      std::string name = args(0).xstring_value ("variable_value: expecting variable name as first argument");
 
       retval = symbol_table::varval (name);
 
       if (retval.is_undefined ())
         error ("variable_value: '%s' is not a variable in the current scope",
                name.c_str ());
     }
   else
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -184,17 +184,17 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string exec_file = args(0).string_value ("exec: FILE must be a string");
+      std::string exec_file = args(0).xstring_value ("exec: FILE must be a string");
 
       string_vector exec_args;
 
       if (nargin == 2)
         {
           string_vector tmp = args(1).all_strings ();
 
           if (! error_state)
@@ -288,17 +288,17 @@ exit status, it will linger until Octave
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
-      std::string exec_file = args(0).string_value ("popen2: COMMAND argument must be a string");
+      std::string exec_file = args(0).xstring_value ("popen2: COMMAND argument must be a string");
 
       string_vector arg_list;
 
       if (nargin >= 2)
         {
           string_vector tmp = args(1).all_strings ();
 
           if (! error_state)
@@ -771,17 +771,17 @@ Return a structure @var{info} containing
 The function outputs are described in the documentation for @code{stat}.\n\
 @seealso{stat, symlink}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string fname = args(0).string_value ("lstat: NAME must be a string");
+      std::string fname = args(0).xstring_value ("lstat: NAME must be a string");
 
       file_stat fs (fname, false);
 
       retval = mk_stat_result (fs);
     }
   else
     print_usage ();
 
@@ -838,17 +838,17 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      std::string name = args(0).string_value ("mkfifo: FILE must be a string");
+      std::string name = args(0).xstring_value ("mkfifo: FILE must be a string");
 
       int octal_mode = args(1).int_value ();
 
       if (! error_state)
         {
           if (octal_mode < 0)
             error ("mkfifo: MODE must be a positive integer value");
           else
@@ -1047,17 +1047,17 @@ For example:\n\
           int fid = octave_stream_list::get_file_number (args(0));
 
           file_fstat fs (fid);
 
           retval = mk_stat_result (fs);
         }
       else
         {
-          std::string fname = args(0).string_value ("stat: NAME must be a string");
+          std::string fname = args(0).xstring_value ("stat: NAME must be a string");
 
           file_stat fs (fname);
 
           retval = mk_stat_result (fs);
         }
     }
   else
     print_usage ();
@@ -1327,17 +1327,17 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string name = args(0).string_value ("unlink: FILE must be a string");
+      std::string name = args(0).xstring_value ("unlink: FILE must be a string");
 
       std::string msg;
 
       int status = octave_unlink (name, msg);
 
       retval(1) = msg;
       retval(0) = status;
     }
@@ -1643,17 +1643,17 @@ Return the canonical name of file @var{f
 If the file does not exist the empty string (\"\") is returned.\n\
 @seealso{make_absolute_filename, is_absolute_filename, is_rooted_relative_filename}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("canonicalize_file_name: NAME must be a string");
+      std::string name = args(0).xstring_value ("canonicalize_file_name: NAME must be a string");
       std::string msg;
 
       std::string result = octave_canonicalize_file_name (name, msg);
 
       retval(2) = msg;
       retval(1) = msg.empty () ? 0 : -1;
       retval(0) = result;
     }
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -190,17 +190,17 @@ DEFUN (__open_with_system_app__, args, ,
 @deftypefn {Loadable Function} {} __open_with_system_app__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string file = args(0).string_value ("__open_with_system_app__: argument must be a file name");
+      std::string file = args(0).xstring_value ("__open_with_system_app__: argument must be a file name");
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
       HINSTANCE status = ShellExecute (0, 0, file.c_str (), 0, 0,
                                        SW_SHOWNORMAL);
 
       // ShellExecute returns a value greater than 32 if successful.
       retval = (reinterpret_cast<ptrdiff_t> (status) > 32);
 #else
@@ -640,20 +640,20 @@ string.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 1)
     {
-      std::string var = args(0).string_value ("setenv: VAR must be a string");
+      std::string var = args(0).xstring_value ("setenv: VAR must be a string");
 
       std::string val = (nargin == 2
-                         ? args(1).string_value ("setenv: VALUE must be a string")
+                         ? args(1).xstring_value ("setenv: VALUE must be a string")
                          : std::string ());
 
       octave_env::putenv (var, val);
     }
   else
     print_usage ();
 
   return retval;
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -468,17 +468,17 @@ Year (1970-).\n\
 @end table\n\
 @seealso{strptime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      std::string fmt = args(0).string_value ("strftime: FMT must be a string");
+      std::string fmt = args(0).xstring_value ("strftime: FMT must be a string");
 
       octave_scalar_map map = args(1).scalar_map_value ();
 
       if (! error_state)
         {
           octave_base_tm tm = extract_tm (map);
 
           if (! error_state)
@@ -519,19 +519,19 @@ position of last matched character plus 
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2)
     {
-      std::string str = args(0).string_value ("strptime: argument STR must be a string");
+      std::string str = args(0).xstring_value ("strptime: argument STR must be a string");
 
-      std::string fmt = args(1).string_value ("strptime: FMT must be a string");
+      std::string fmt = args(1).xstring_value ("strptime: FMT must be a string");
 
       octave_strptime t (str, fmt);
 
       retval(1) = t.characters_converted ();
       retval(0) = octave_value (mk_tm_map (t));
     }
   else
     print_usage ();
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1033,17 +1033,17 @@ command shell that is started to run the
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargin == 1 && nargout > 1);
 
       system_exec_type type = et_sync;
 
       if (nargin == 3)
         {
-          std::string type_str = args(2).string_value ("system: TYPE must be a string");
+          std::string type_str = args(2).xstring_value ("system: TYPE must be a string");
 
           if (type_str == "sync")
             type = et_sync;
           else if (type_str == "async")
             type = et_async;
           else
             {
               error ("system: TYPE must be \"sync\" or \"async\"");
@@ -1063,17 +1063,17 @@ command shell that is started to run the
         }
 
       if (return_output && type == et_async)
         {
           error ("system: can't return output from commands run asynchronously");
           return retval;
         }
 
-      std::string cmd_str = args(0).string_value ("system: expecting string as first argument");
+      std::string cmd_str = args(0).xstring_value ("system: expecting string as first argument");
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
       // Work around weird double-quote handling on Windows systems.
       if (type == et_sync)
         cmd_str = "\"" + cmd_str + "\"";
 #endif
 
       if (type == et_async)
@@ -1218,17 +1218,17 @@ from the list, so if a function was plac
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string arg = args(0).string_value ("atexit: FCN argument must be a string");
+      std::string arg = args(0).xstring_value ("atexit: FCN argument must be a string");
 
       bool add_mode = true;
 
       if (nargin == 2)
         {
           add_mode = args(1).bool_value ();
 
           if (error_state)
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -340,35 +340,35 @@ urlwrite (\"http://www.google.com/search
 
   // verify arguments
   if (nargin != 2 && nargin != 4)
     {
       print_usage ();
       return retval;
     }
 
-  std::string url = args(0).string_value ("urlwrite: URL must be a string");
+  std::string url = args(0).xstring_value ("urlwrite: URL must be a string");
 
   // name to store the file if download is succesful
-  std::string filename = args(1).string_value ("urlwrite: LOCALFILE must be a string");
+  std::string filename = args(1).xstring_value ("urlwrite: LOCALFILE must be a string");
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 4)
     {
-      method = args(2).string_value ("urlwrite: METHOD must be a string");
+      method = args(2).xstring_value ("urlwrite: METHOD must be a string");
 
       if (method != "get" && method != "post")
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(3).cellstr_value ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of strings");
+      param = args(3).xcellstr_value ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of strings");
 
       if (param.numel () % 2 == 1)
         {
           error ("urlwrite: number of elements in PARAM must be even");
           return retval;
         }
     }
 
@@ -477,32 +477,32 @@ s = urlread (\"http://www.google.com/sea
 
   // verify arguments
   if (nargin != 1 && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
-  std::string url = args(0).string_value ("urlread: URL must be a string");
+  std::string url = args(0).xstring_value ("urlread: URL must be a string");
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 3)
     {
-      method = args(1).string_value ("urlread: METHOD must be a string");
+      method = args(1).xstring_value ("urlread: METHOD must be a string");
 
       if (method != "get" && method != "post")
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(2).cellstr_value ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of strings");
+      param = args(2).xcellstr_value ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of strings");
 
       if (param.numel () % 2 == 1)
         {
           error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
     }
 
@@ -547,23 +547,23 @@ Undocumented internal function\n\
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
   else
     {
-      host = args(0).string_value ("__ftp__: HOST must be a string");
+      host = args(0).xstring_value ("__ftp__: HOST must be a string");
 
       if (nargin > 1)
-        user = args(1).string_value ("__ftp__: USER must be a string");
+        user = args(1).xstring_value ("__ftp__: USER must be a string");
 
       if (nargin > 2)
-        passwd = args(2).string_value ("__ftp__: PASSWD must be a string");
+        passwd = args(2).xstring_value ("__ftp__: PASSWD must be a string");
 
       curl_handle ch
         = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
       retval = ch.value ();
     }
 
   return retval;
@@ -610,17 +610,17 @@ Undocumented internal function\n\
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string path = "";
 
           if (nargin > 1)
-            path = args(1).string_value ("__ftp_cwd__: PATH must be a string");
+            path = args(1).xstring_value ("__ftp_cwd__: PATH must be a string");
 
           curl.cwd (path);
         }
       else
         error ("__ftp_cwd__: invalid ftp handle");
     }
 
   return retval;
@@ -817,17 +817,17 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("__ftp_delete__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
-          std::string file = args(1).string_value ("__ftp_delete__: FILE must be a string");
+          std::string file = args(1).xstring_value ("__ftp_delete__: FILE must be a string");
 
           curl.del (file);
         }
       else
         error ("__ftp_delete__: invalid ftp handle");
     }
 
   return retval;
@@ -846,17 +846,17 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
-          std::string dir = args(1).string_value ("__ftp_rmdir__: DIR must be a string");
+          std::string dir = args(1).xstring_value ("__ftp_rmdir__: DIR must be a string");
 
           curl.rmdir (dir);
         }
       else
         error ("__ftp_rmdir__: invalid ftp handle");
     }
 
   return retval;
@@ -875,17 +875,17 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
-          std::string dir = args(1).string_value ("__ftp_mkdir__: DIR must be a string");
+          std::string dir = args(1).xstring_value ("__ftp_mkdir__: DIR must be a string");
 
           curl.mkdir (dir);
         }
       else
         error ("__ftp_mkdir__: invalid ftp handle");
     }
 
   return retval;
@@ -904,18 +904,18 @@ Undocumented internal function\n\
   if (nargin != 3)
     error ("__ftp_rename__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
-          std::string oldname = args(1).string_value ("__ftp_rename__: OLDNAME must be a string");
-          std::string newname = args(2).string_value ("__ftp_rename__: NEWNAME must be a string");
+          std::string oldname = args(1).xstring_value ("__ftp_rename__: OLDNAME must be a string");
+          std::string newname = args(2).xstring_value ("__ftp_rename__: NEWNAME must be a string");
 
           curl.rename (oldname, newname);
         }
       else
         error ("__ftp_rename__: invalid ftp handle");
     }
 
   return retval;
@@ -934,17 +934,17 @@ Undocumented internal function\n\
   if (nargin != 2)
     error ("__ftp_mput__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
-          std::string pat = args(1).string_value ("__ftp_mput__: PATTERN must be a string");
+          std::string pat = args(1).xstring_value ("__ftp_mput__: PATTERN must be a string");
 
           string_vector file_list;
 
           glob_match pattern (file_ops::tilde_expand (pat));
           string_vector files = pattern.glob ();
 
           for (octave_idx_type i = 0; i < files.numel (); i++)
             {
@@ -1018,21 +1018,21 @@ Undocumented internal function\n\
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
-          std::string file = args(1).string_value ("__ftp_mget__: PATTERN must be a string");
+          std::string file = args(1).xstring_value ("__ftp_mget__: PATTERN must be a string");
           std::string target;
 
           if (nargin == 3)
-            target = args(2).string_value ("__ftp_mget__: TARGET must be a string") + file_ops::dir_sep_str ();
+            target = args(2).xstring_value ("__ftp_mget__: TARGET must be a string") + file_ops::dir_sep_str ();
 
           string_vector sv = curl.list ();
           octave_idx_type n = 0;
           glob_match pattern (file);
 
 
           for (octave_idx_type i = 0; i < sv.numel (); i++)
             {
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -388,17 +388,17 @@ If no files are found, return an empty c
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
-      std::string path = args(0).string_value ("file_in_path: PATH must be a string");
+      std::string path = args(0).xstring_value ("file_in_path: PATH must be a string");
 
       string_vector names = args(1).all_strings ();
 
       if (! error_state && names.numel () > 0)
         {
           if (nargin == 2)
             retval = search_path_for_file (path, names);
           else if (nargin == 3)
@@ -751,17 +751,17 @@ Escape sequences begin with a leading ba
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string str = args(0).string_value ("do_string_escapes: STRING argument must be of type string");
+      std::string str = args(0).xstring_value ("do_string_escapes: STRING argument must be of type string");
 
       retval = do_string_escapes (str);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -894,17 +894,17 @@ replaces the unprintable alert character
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string str = args(0).string_value ("undo_string_escapes: S argument must be a string");
+      std::string str = args(0).xstring_value ("undo_string_escapes: S argument must be a string");
 
       retval = undo_string_escapes (str);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -990,17 +990,17 @@ system.\n\
 No check is done for the existence of @var{file}.\n\
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
   if (args.length () == 1)
     {
-      std::string nm = args(0).string_value ("make_absolute_filename: FILE argument must be a file name");
+      std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a file name");
 
       retval = octave_env::make_absolute (nm);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -1032,17 +1032,17 @@ all name matches rather than just the fi
   octave_value retval = std::string ();
 
   int nargin = args.length ();
 
   std::string dir;
 
   if (nargin == 1 || nargin == 2)
     {
-      dir = args(0).string_value ("dir_in_loadpath: DIR must be a directory name");
+      dir = args(0).xstring_value ("dir_in_loadpath: DIR must be a directory name");
 
       if (nargin == 1)
         retval = load_path::find_dir (dir);
       else if (nargin == 2)
         retval = Cell (load_path::find_matching_dirs (dir));
     }
   else
     print_usage ();
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -142,17 +142,17 @@ extract_function (const octave_value& ar
                   const std::string& trailer)
 {
   octave_function *retval = 0;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
-      std::string s = arg.string_value ("%s: expecting first argument to be a string",
+      std::string s = arg.xstring_value ("%s: expecting first argument to be a string",
                                         warn_for.c_str ());
 
       std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       int parse_status;
 
@@ -585,21 +585,21 @@ not on the search path you should use so
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string name = args(0).string_value ("exist: NAME must be a string");
+      std::string name = args(0).xstring_value ("exist: NAME must be a string");
 
       if (nargin == 2)
         {
-          std::string type = args(1).string_value ("exist: TYPE must be a string");
+          std::string type = args(1).xstring_value ("exist: TYPE must be a string");
 
           if (type == "class")
             warning ("exist: \"class\" type argument is not implemented");
 
           retval = symbol_exist (name, type);
         }
       else
         retval = symbol_exist (name);
@@ -806,17 +806,17 @@ set_internal_variable (char& var, const 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ("%s: argument must be a single character", nm);
+      std::string sval = args(0).xstring_value ("%s: argument must be a single character", nm);
 
       switch (sval.length ())
         {
         case 1:
           var = sval[0];
           break;
 
         case 0:
@@ -929,17 +929,17 @@ set_internal_variable (std::string& var,
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ("%s: first argument must be a string", nm);
+      std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
 
       if (empty_ok || ! sval.empty ())
         var = sval;
       else
         error ("%s: value must not be empty", nm);
     }
   else if (nargin > 1)
     print_usage ();
@@ -965,17 +965,17 @@ set_internal_variable (int& var, const o
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ("%s: first argument must be a string", nm);
+      std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
 
       int i = 0;
       for (; i < nchoices; i++)
         {
           if (sval == choices[i])
             {
               var = i;
               break;
@@ -2058,17 +2058,17 @@ Unlock the named function @var{fcn}.\n\
 If no function is named then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("munlock: FCN must be a string");
+      std::string name = args(0).xstring_value ("munlock: FCN must be a string");
 
       munlock (name);
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
@@ -2092,17 +2092,17 @@ Return true if the named function @var{f
 If no function is named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("mislocked: FCN must be a string");
+      std::string name = args(0).xstring_value ("mislocked: FCN must be a string");
 
       retval = mislocked (name);
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
@@ -2669,17 +2669,17 @@ DEFUN (__varval__, args, ,
 @deftypefn {Built-in Function} {} __varval__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("__varval__: expecting argument to be variable name");
+      std::string name = args(0).xstring_value ("__varval__: expecting argument to be variable name");
 
       retval = symbol_table::varval (args(0).string_value ());
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -82,17 +82,17 @@ DEFUN_DLD (__voronoi__, args, ,
 @deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  std::string caller = args(0).string_value ("__voronoi__: CALLER must be a string");
+  std::string caller = args(0).xstring_value ("__voronoi__: CALLER must be a string");
 
 #if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 2 || nargin > 3)
     {
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -157,17 +157,17 @@ sparse matrices.\n\
     {
       print_usage ();
       return retval;
     }
 
   int n = 1;
   while (n < nargin)
     {
-      std::string tmp = args(n++).string_value ("chol: expecting trailing string arguments");
+      std::string tmp = args(n++).xstring_value ("chol: expecting trailing string arguments");
 
       if (tmp.compare ("vector") == 0)
         vecout = true;
       else if (tmp.compare ("lower") == 0)
         LLt = true;
       else if (tmp.compare ("upper") == 0)
         LLt = false;
       else
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -700,17 +700,17 @@ permutations on the tree.\n\
       else
         {
           error ("etree: S must be a sparse matrix");
           return retval;
         }
 
       if (nargin == 2)
         {
-          std::string str = args(1).string_value ("etree: TYP must be a string");
+          std::string str = args(1).xstring_value ("etree: TYP must be a string");
           if (str.find ("C") == 0 || str.find ("c") == 0)
             is_sym = false;
         }
 
       // column elimination tree post-ordering (reuse variables)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
       if (is_sym)
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -138,27 +138,27 @@ used per default.\n\
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
 #if defined (HAVE_FFTW)
-  std::string arg0 = args(0).string_value ("fftw: first argument must be a string");
+  std::string arg0 = args(0).xstring_value ("fftw: first argument must be a string");
 
   if (arg0 == "planner")
     {
       if (nargin == 2)  //planner setter
         {
           // Use STL function to convert to lower case
           std::transform (arg0.begin (), arg0.end (), arg0.begin (),
                           tolower);
 
-          std::string arg1 = args(1).string_value ("fftw: planner expects a string value as METHOD");
+          std::string arg1 = args(1).xstring_value ("fftw: planner expects a string value as METHOD");
 
           std::transform (arg1.begin (), arg1.end (),
                           arg1.begin (), tolower);
           octave_fftw_planner::FftwMethod meth
             = octave_fftw_planner::UNKNOWN;
           octave_float_fftw_planner::FftwMethod methf
             = octave_float_fftw_planner::UNKNOWN;
 
@@ -224,17 +224,17 @@ used per default.\n\
   else if (arg0 == "dwisdom")
     {
       if (nargin == 2)  //dwisdom setter
         {
           // Use STL function to convert to lower case
           std::transform (arg0.begin (), arg0.end (), arg0.begin (),
                           tolower);
 
-          std::string arg1 = args(1).string_value ("fftw: WISDOM must be a string");
+          std::string arg1 = args(1).xstring_value ("fftw: WISDOM must be a string");
 
           char *str = fftw_export_wisdom_to_string ();
 
           if (arg1.length () < 1)
             fftw_forget_wisdom ();
           else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
             error ("fftw: could not import supplied WISDOM");
 
@@ -258,17 +258,17 @@ used per default.\n\
     {
       //swisdom uses fftwf_ functions (float), dwisdom fftw_ (real)
       if (nargin == 2)  //swisdom setter
         {
           // Use STL function to convert to lower case
           std::transform (arg0.begin (), arg0.end (), arg0.begin (),
                           tolower);
 
-          std::string arg1 = args(1).string_value ("fftw: WISDOM must be a string");
+          std::string arg1 = args(1).xstring_value ("fftw: WISDOM must be a string");
 
           char *str = fftwf_export_wisdom_to_string ();
 
           if (arg1.length () < 1)
             fftwf_forget_wisdom ();
           else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
             error ("fftw: could not import supplied WISDOM");
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -51,40 +51,16 @@ along with Octave; see the file COPYING.
 #include "ov-str-mat.h"
 #include "ov-fcn-handle.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "toplev.h"
 #include "variables.h"
 
-static void
-gripe_wrong_type_arg_with_msg (const char *name, const std::string& type,
-                               const char *fmt, va_list args)
-{
-  // Note that this method does not need to be particularly efficient
-  // since it is already an error to end up here.
-
-  // FIXME: do we want both the wrong-type-argument error and any custom
-  // error message, or just the custom error message, or should that
-  // behavior be optional in some way?
-
-  try
-    {
-      gripe_wrong_type_arg (name, type);
-    }
-  catch (const octave_execution_exception&)
-    {
-      if (fmt)
-        verror (fmt, args);
-
-      throw;
-    }
-}
-
 builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y)
 {
   builtin_type_t retval = btyp_unknown;
 
   if (x == btyp_bool)
     x = btyp_double;
   if (y == btyp_bool)
     y = btyp_double;
@@ -556,24 +532,16 @@ octave_base_value::float_value (bool) co
 Cell
 octave_base_value::cell_value () const
 {
   Cell retval;
   gripe_wrong_type_arg ("octave_base_value::cell_value()", type_name ());
   return retval;
 }
 
-Cell
-octave_base_value::cell_value (const char *fmt, va_list args) const
-{
-  gripe_wrong_type_arg_with_msg ("cell value", type_name (), fmt, args);
-
-  return Cell ();
-}
-
 Matrix
 octave_base_value::matrix_value (bool) const
 {
   Matrix retval;
   gripe_wrong_type_arg ("octave_base_value::matrix_value()", type_name ());
   return retval;
 }
 
@@ -938,40 +906,32 @@ octave_base_value::string_value (bool fo
   octave_value tmp = convert_to_str (force);
 
   retval = tmp.string_value ();
 
   return retval;
 }
 
 std::string
-octave_base_value::string_value (const char *fmt, va_list args) const
+octave_base_value::xstring_value (void) const
 {
-  gripe_wrong_type_arg_with_msg ("string value", type_name (), fmt, args);
-
-  return std::string ();
+  std::string retval;
+  wrong_type_arg_error ();
+  return retval;
 }
 
 Array<std::string>
 octave_base_value::cellstr_value (void) const
 {
   Array<std::string> retval;
   gripe_wrong_type_arg ("octave_base_value::cellstr_value()",
                         type_name ());
   return retval;
 }
 
-Array<std::string>
-octave_base_value::cellstr_value (const char *fmt, va_list args) const
-{
-  gripe_wrong_type_arg_with_msg ("cellstr value", type_name (), fmt, args);
-
-  return Array<std::string> ();
-}
-
 Range
 octave_base_value::range_value (void) const
 {
   Range retval;
   gripe_wrong_type_arg ("octave_base_value::range_value()", type_name ());
   return retval;
 }
 
@@ -1311,16 +1271,22 @@ void
 octave_base_value::gripe_save (const char *type) const
 {
   warning_with_id
     ("Octave:load-save-unavailable",
      "%s: saving %s files not available in this version of Octave",
      t_name.c_str (), type);
 }
 
+void
+octave_base_value::wrong_type_arg_error (void) const
+{
+  gripe_wrong_type_arg (type_name ());
+}
+
 octave_value
 octave_base_value::map (unary_mapper_t umap) const
 {
   error ("%s: not defined for %s", get_umap_name (umap), type_name ().c_str ());
   return octave_value ();
 }
 
 void
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -476,18 +476,16 @@ public:
   virtual double scalar_value (bool frc_str_conv = false) const
   { return double_value (frc_str_conv); }
 
   virtual float float_scalar_value (bool frc_str_conv = false) const
   { return float_value (frc_str_conv); }
 
   virtual Cell cell_value (void) const;
 
-  virtual Cell cell_value (const char *fmt, va_list args) const;
-
   virtual Matrix matrix_value (bool = false) const;
 
   virtual FloatMatrix float_matrix_value (bool = false) const;
 
   virtual NDArray array_value (bool = false) const;
 
   virtual FloatNDArray float_array_value (bool = false) const;
 
@@ -561,23 +559,18 @@ public:
   virtual uint32NDArray uint32_array_value (void) const;
 
   virtual uint64NDArray uint64_array_value (void) const;
 
   virtual string_vector all_strings (bool pad = false) const;
 
   virtual std::string string_value (bool force = false) const;
 
-  virtual std::string string_value (const char *fmt, va_list args) const;
-
   virtual Array<std::string> cellstr_value (void) const;
 
-  virtual Array<std::string>
-  cellstr_value (const char *fmt, va_list args) const;
-
   virtual Range range_value (void) const;
 
   virtual octave_map map_value (void) const;
 
   virtual octave_scalar_map scalar_map_value (void) const;
 
   virtual string_vector map_keys (void) const;
 
@@ -612,16 +605,21 @@ public:
 
   virtual octave_value convert_to_str (bool pad = false, bool force = false,
                                        char type = '\'') const;
   virtual octave_value
   convert_to_str_internal (bool pad, bool force, char type) const;
 
   virtual void convert_to_row_or_column_vector (void);
 
+  // The following extractor functions don't perform any implicit type
+  // conversions.
+
+  virtual std::string xstring_value () const;
+
   virtual bool print_as_scalar (void) const { return false; }
 
   virtual void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   virtual void
   print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   virtual bool
@@ -827,16 +825,18 @@ protected:
 
   static const char *get_umap_name (unary_mapper_t);
 
   void gripe_load (const char *type) const;
   void gripe_save (const char *type) const;
 
 private:
 
+  void wrong_type_arg_error (void) const;
+
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // TRUE means to perform automatic sparse to real mutation if there
 // is memory to be saved
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -475,73 +475,88 @@ octave_cell::byte_size (void) const
   return retval;
 }
 
 octave_value
 octave_cell::sort (octave_idx_type dim, sortmode mode) const
 {
   octave_value retval;
 
-  Array<std::string> tmp = cellstr_value ("sort: only cell arrays of character strings may be sorted");
+  if (! is_cellstr ())
+    error ("sort: only cell arrays of character strings may be sorted");
+
+  Array<std::string> tmp = cellstr_value ();
 
   tmp = tmp.sort (dim, mode);
 
   // We already have the cache.
   retval = new octave_cell (tmp);
 
   return retval;
 }
 
 octave_value
 octave_cell::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                    sortmode mode) const
 {
   octave_value retval;
 
-  Array<std::string> tmp = cellstr_value ("sort: only cell arrays of character strings may be sorted");
+  if (! is_cellstr ())
+    error ("sort: only cell arrays of character strings may be sorted");
+
+  Array<std::string> tmp = cellstr_value ();
 
   tmp = tmp.sort (sidx, dim, mode);
 
   // We already have the cache.
   retval = new octave_cell (tmp);
 
   return retval;
 }
 
 sortmode
 octave_cell::is_sorted (sortmode mode) const
 {
   sortmode retval = UNSORTED;
 
-  Array<std::string> tmp = cellstr_value ("issorted: A is not a cell array of strings");
+  if (! is_cellstr ())
+    error ("issorted: A is not a cell array of strings");
+
+  Array<std::string> tmp = cellstr_value ();
 
   retval = tmp.is_sorted (mode);
 
   return retval;
 }
 
 
 Array<octave_idx_type>
 octave_cell::sort_rows_idx (sortmode mode) const
 {
   Array<octave_idx_type> retval;
 
-  Array<std::string> tmp = cellstr_value ("sortrows: only cell arrays of character strings may be sorted");
+  if (! is_cellstr ())
+    error ("sortrows: only cell arrays of character strings may be sorted");
+
+  Array<std::string> tmp = cellstr_value ();
 
   retval = tmp.sort_rows_idx (mode);
 
   return retval;
 }
 
 sortmode
 octave_cell::is_sorted_rows (sortmode mode) const
 {
   sortmode retval = UNSORTED;
 
-  Array<std::string> tmp = cellstr_value ("issorted: A is not a cell array of strings");
+  if (! is_cellstr ())
+    error ("issorted: A is not a cell array of strings");
+
+  Array<std::string> tmp = cellstr_value ();
 
   retval = tmp.is_sorted_rows (mode);
 
   return retval;
 }
 
 bool
 octave_cell::is_true (void) const
@@ -631,59 +646,16 @@ octave_cell::cellstr_value (void) const
       return *cellstr_cache;
     }
   else
     error ("invalid conversion from cell array to array of strings");
 
   return retval;
 }
 
-Array<std::string>
-octave_cell::cellstr_value (const char *fmt, ...) const
-{
-  Array<std::string> retval;
-  va_list args;
-  retval = cellstr_value (fmt, args);
-  va_end (args);
-  return retval;
-}
-
-Array<std::string>
-octave_cell::cellstr_value (const char *fmt, va_list args) const
-{
-  Array<std::string> retval;
-
-  if (! fmt)
-    return cellstr_value ();
-
-  bool conversion_error = false;
-
-  if (is_cellstr ())
-    {
-      try
-        {
-          if (cellstr_cache->is_empty ())
-            *cellstr_cache = matrix.cellstr_value ();
-
-          retval = *cellstr_cache;
-        }
-      catch (const octave_execution_exception&)
-        {
-          conversion_error = true;
-        }
-    }
-  else
-    conversion_error = true;
-
-  if (conversion_error)
-    verror (fmt, args);
-
-  return retval;
-}
-
 bool
 octave_cell::print_as_scalar (void) const
 {
   return true;
 }
 
 void
 octave_cell::print (std::ostream& os, bool)
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -130,31 +130,27 @@ public:
   builtin_type_t builtin_type (void) const { return btyp_cell; }
 
   bool is_cellstr (void) const;
 
   bool is_true (void) const;
 
   Cell cell_value (void) const { return matrix; }
 
-  Cell cell_value (const char *, va_list) const { return matrix; }
-
   octave_value_list list_value (void) const;
 
   octave_value convert_to_str_internal (bool pad, bool, char type) const
   { return octave_value (all_strings (pad), type); }
 
   string_vector all_strings (bool pad = false) const;
 
   Array<std::string> cellstr_value (void) const;
 
   Array<std::string> cellstr_value (const char *fmt, ...) const;
 
-  Array<std::string> cellstr_value (const char *fmt, va_list args) const;
-
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void short_disp (std::ostream& os) const;
 
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -284,17 +284,17 @@ octave_class::dotref (const octave_value
   if (obvp == 0)
     {
       error ("malformed class");
       return retval;
     }
 
   octave_map my_map = (obvp != this) ? obvp->map_value () : map;
 
-  std::string nm = idx(0).string_value ("invalid index for class");
+  std::string nm = idx(0).xstring_value ("invalid index for class");
 
   octave_map::const_iterator p = my_map.seek (nm);
 
   if (p != my_map.end ())
     retval = my_map.contents (p);
   else
     error ("class has no member '%s'", nm.c_str ());
 
@@ -645,17 +645,17 @@ octave_class::subsasgn_common (const oct
               {
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list t_idx = *p;
 
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
-                std::string key = key_idx(0).string_value ("invalid index for class assignment");
+                std::string key = key_idx(0).xstring_value ("invalid index for class assignment");
 
                 octave_value u;
 
                 if (! map.contains (key))
                   u = octave_value::empty_conv (type.substr (2), rhs);
                 else
                   {
                     Cell map_val = map.contents (key);
@@ -742,17 +742,17 @@ octave_class::subsasgn_common (const oct
           {
             if (n > 1 && type[1] == '.')
               {
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
-                std::string key = key_idx(0).string_value ("assignment to class element failed");
+                std::string key = key_idx(0).xstring_value ("assignment to class element failed");
 
                 map.assign (idx.front (), key, t_rhs);
 
                 if (! error_state)
                   {
                     count++;
                     retval = octave_value (this);
                   }
@@ -1281,17 +1281,17 @@ octave_class::load_ascii (std::istream& 
 
                   // recurse to read cell elements
                   std::string nm
                     = read_text_data (is, std::string (), dummy, t2, j);
 
                   if (! is)
                     break;
 
-                  Cell tcell = t2.is_cell () ? t2.cell_value ("load: internal error loading class elements") : Cell (t2);
+                  Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
                   m.assign (nm, tcell);
                 }
 
               if (is)
                 {
                   c_name = classname;
                   reconstruct_exemplar ();
@@ -1418,17 +1418,17 @@ octave_class::load_binary (std::istream&
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
-          Cell tcell = t2.is_cell () ? t2.cell_value ("load: internal error loading class elements") : Cell (t2);
+          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
           m.assign (nm, tcell);
         }
 
       if (is)
         {
           map = m;
 
@@ -1652,17 +1652,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = H5Giterate (group_hid, name, &current_item,
                                    hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
-      Cell tcell = t2.is_cell () ? t2.cell_value ("load: internal error loading class elements") : Cell (t2);
+      Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
       m.assign (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
@@ -1818,17 +1818,17 @@ is derived.\n\
   else if (nargin == 1)
     // Called for class of object
     retval = args(0).class_name ();
   else
     {
       // Called as class constructor
       octave_function *fcn = octave_call_stack::caller ();
 
-      std::string id = args(1).string_value ("class: ID (class name) must be a string");
+      std::string id = args(1).xstring_value ("class: ID (class name) must be a string");
 
       if (fcn)
         {
           if (fcn->is_class_constructor (id) || fcn->is_class_method (id))
             {
               octave_map m = args(0).map_value ();
 
               if (! error_state)
@@ -1912,17 +1912,17 @@ belongs to.\n\
   if (args.length () != 2)
     {
       print_usage ();
       return retval;
     }
 
   octave_value obj = args(0);  // not const because of find_parent_class ()
   std::string obj_cls = obj.class_name ();
-  Array<std::string> clsnames = args(1).cellstr_value ("isa: CLASSNAME must be a string or cell array of strings");
+  Array<std::string> clsnames = args(1).xcellstr_value ("isa: CLASSNAME must be a string or cell array of strings");
 
   boolNDArray matches (clsnames.dims (), false);
   for (octave_idx_type idx = 0; idx < clsnames.numel (); idx++)
     {
       std::string cls = clsnames(idx);
       if (obj_cls == cls
           || (cls == "float"   && obj.is_float_type   ())
           || (cls == "integer" && obj.is_integer_type ())
@@ -2139,17 +2139,17 @@ This function may only be called from a 
   if ((! fcn) || (! fcn->is_class_constructor ()))
     {
       error ("superiorto: invalid call from outside class constructor");
       return retval;
     }
 
   for (int i = 0; i < args.length (); i++)
     {
-      std::string inf_class = args(i).string_value ("superiorto: expecting argument to be class name");
+      std::string inf_class = args(i).xstring_value ("superiorto: expecting argument to be class name");
 
       // User defined classes always have higher precedence
       // than built-in classes
       if (is_built_in_class (inf_class))
         break;
 
       std::string sup_class = fcn->name ();
       if (! symbol_table::set_class_relationship (sup_class, inf_class))
@@ -2180,17 +2180,17 @@ This function may only be called from a 
   if ((! fcn) || (! fcn->is_class_constructor ()))
     {
       error ("inferiorto: invalid call from outside class constructor");
       return retval;
     }
 
   for (int i = 0; i < args.length (); i++)
     {
-      std::string sup_class = args(i).string_value ("inferiorto: expecting argument to be class name");
+      std::string sup_class = args(i).xstring_value ("inferiorto: expecting argument to be class name");
 
       if (is_built_in_class (sup_class))
         {
           error ("inferiorto: cannot give user-defined class lower "
                  "precedence than built-in class");
           break;
         }
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -517,17 +517,17 @@ class_get_inferiorclasses (const octave_
 
 static octave_value_list
 class_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("fromName: invalid class name, expected a string value");
+      std::string name = args(0).xstring_value ("fromName: invalid class name, expected a string value");
 
       retval(0) = to_ov (lookup_class (name));
     }
   else
     error ("fromName: invalid number of parameters");
 
   return retval;
 }
@@ -538,17 +538,17 @@ class_fevalStatic (const octave_value_li
   octave_value_list retval;
 
   if (args.length () > 1 && args(0).type_name () == "object")
     {
       cdef_class cls (to_cdef (args(0)));
 
       if (! error_state)
         {
-          std::string meth_name = args(1).string_value ("fevalStatic: invalid method name, expected a string value");
+          std::string meth_name = args(1).xstring_value ("fevalStatic: invalid method name, expected a string value");
 
           cdef_method meth = cls.find_method (meth_name);
 
           if (meth.ok ())
             {
               if (meth.is_static ())
                 retval = meth.execute (args.splice (0, 2), nargout,
                                        true, "fevalStatic");
@@ -575,17 +575,17 @@ class_getConstant (const octave_value_li
 
   if (args.length () == 2 && args(0).type_name () == "object"
       && args(0).class_name () == "meta.class")
     {
       cdef_class cls = to_cdef (args(0));
 
       if (! error_state)
         {
-          std::string prop_name = args(1).string_value ("getConstant: invalid property name, expected a string value");
+          std::string prop_name = args(1).xstring_value ("getConstant: invalid property name, expected a string value");
 
           cdef_property prop = cls.find_property (prop_name);
 
           if (prop.ok ())
             {
               if (prop.is_constant ())
                 retval(0) = prop.get_value (true, "getConstant");
               else
@@ -2389,17 +2389,17 @@ cdef_class::cdef_class_rep::meta_subsref
       // Static method, constant (or property?)
 
 #if DEBUG_TRACE
       std::cerr << "static method/property" << std::endl;
 #endif
 
       if (idx.front ().length () == 1)
         {
-          std::string nm = idx.front ()(0).string_value ("invalid meta.class indexing, expected a method or property name");
+          std::string nm = idx.front ()(0).xstring_value ("invalid meta.class indexing, expected a method or property name");
 
           cdef_method meth = find_method (nm);
 
           if (meth.ok ())
             {
               if (meth.is_static ())
                 {
                   octave_value_list args;
@@ -3276,17 +3276,17 @@ lookup_package (const std::string& name)
 
 static octave_value_list
 package_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ("fromName: invalid package name, expected a string value");
+      std::string name = args(0).xstring_value ("fromName: invalid package name, expected a string value");
 
       retval(0) = to_ov (lookup_package (name));
     }
   else
     error ("fromName: invalid number of parameters");
 
   return retval;
 }
@@ -3433,17 +3433,17 @@ cdef_package::cdef_package_rep::meta_sub
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '.':
       if (idx.front ().length () == 1)
         {
-          std::string nm = idx.front ()(0).string_value ("invalid meta.package indexing, expected a symbol name");
+          std::string nm = idx.front ()(0).xstring_value ("invalid meta.package indexing, expected a symbol name");
 
 #if DEBUG_TRACE
           std::cerr << "meta.package query: " << nm << std::endl;
 #endif
 
           octave_value o = find (nm);
 
           if (o.is_defined ())
@@ -3818,17 +3818,17 @@ cdef_manager::do_find_package_symbol (co
 //----------------------------------------------------------------------------
 
 DEFUN (__meta_get_package__, args, , "")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string cname = args(0).string_value ("invalid package name, expected a string value");
+      std::string cname = args(0).xstring_value ("invalid package name, expected a string value");
 
       retval = to_ov (lookup_package (cname));
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -3853,17 +3853,17 @@ Undocumented internal function.\n\
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
             << args(0).string_value () << ")"
             << std::endl;
 #endif
 
   if (args.length () == 1)
     {
-      std::string cls = args(0).string_value ("invalid class name, expected a string value");
+      std::string cls = args(0).xstring_value ("invalid class name, expected a string value");
 
       retval = to_ov (lookup_class (cls));
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1854,17 +1854,17 @@ functions are ignored in the lookup.\n\
 @seealso{func2str, inline}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string nm = args(0).string_value ("str2func: FCN_NAME must be a string");
+      std::string nm = args(0).xstring_value ("str2func: FCN_NAME must be a string");
 
       if (nm[0] == '@')
         {
           int parse_status;
           octave_value anon_fcn_handle =
             eval_string (nm, true, parse_status);
 
           if (parse_status == 0)
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -676,17 +676,17 @@ functions from strings is through the us
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
-      std::string fun = args(0).string_value ("inline: STR argument must be a string");
+      std::string fun = args(0).xstring_value ("inline: STR argument must be a string");
 
       string_vector fargs;
 
       if (nargin == 1)
         {
           bool is_arg = false;
           bool in_string = false;
           std::string tmp_arg;
@@ -814,17 +814,17 @@ functions from strings is through the us
             }
         }
       else
         {
           fargs.resize (nargin - 1);
 
           for (int i = 1; i < nargin; i++)
             {
-              std::string s = args(i).string_value ("inline: expecting string arguments");
+              std::string s = args(i).xstring_value ("inline: expecting string arguments");
               fargs(i-1) = s;
             }
         }
 
       retval = octave_value (new octave_fcn_inline (fun, fargs));
     }
   else
     print_usage ();
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -247,48 +247,16 @@ octave_char_matrix_str::string_value (bo
       retval = chm.row_as_string (0);  // FIXME?
     }
   else
     error ("invalid conversion of charNDArray to string");
 
   return retval;
 }
 
-std::string
-octave_char_matrix_str::string_value (const char *fmt, va_list args) const
-{
-  std::string retval;
-
-  if (! fmt)
-    return string_value ();
-
-  bool conversion_error = false;
-
-  if (matrix.ndims () == 2)
-    {
-      charMatrix chm (matrix);
-
-      try
-        {
-          retval = chm.row_as_string (0);  // FIXME?
-        }
-      catch (const octave_execution_exception&)
-        {
-          conversion_error = true;
-        }
-    }
-  else
-    conversion_error = true;
-
-  if (conversion_error)
-    verror (fmt, args);
-
-  return retval;
-}
-
 Array<std::string>
 octave_char_matrix_str::cellstr_value (void) const
 {
   Array<std::string> retval;
 
   if (matrix.ndims () == 2)
     {
       const charMatrix chm (matrix);
@@ -298,51 +266,16 @@ octave_char_matrix_str::cellstr_value (v
         retval.xelem (i) = chm.row_as_string (i);
     }
   else
     error ("cellstr: cannot convert multidimensional arrays");
 
   return retval;
 }
 
-Array<std::string>
-octave_char_matrix_str::cellstr_value (const char *fmt, va_list args) const
-{
-  Array<std::string> retval;
-
-  if (! fmt)
-    return cellstr_value ();
-
-  bool conversion_error = false;
-
-  if (matrix.ndims () == 2)
-    {
-      const charMatrix chm (matrix);
-      octave_idx_type nr = chm.rows ();
-      retval.clear (nr, 1);
-
-      try
-        {
-          for (octave_idx_type i = 0; i < nr; i++)
-            retval.xelem (i) = chm.row_as_string (i);
-        }
-      catch (const octave_execution_exception&)
-        {
-          conversion_error = true;
-        }
-    }
-  else
-    conversion_error = true;
-
-  if (conversion_error)
-    verror (fmt, args);
-
-  return retval;
-}
-
 void
 octave_char_matrix_str::print_raw (std::ostream& os,
                                    bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level (), true);
 }
 
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -124,22 +124,20 @@ public:
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   string_vector all_strings (bool pad = false) const;
 
   std::string string_value (bool force = false) const;
 
-  std::string string_value (const char *fmt, va_list args) const;
+  std::string xstring_value (void) const { return string_value (); }
 
   Array<std::string> cellstr_value (void) const;
 
-  Array<std::string> cellstr_value (const char *fmt, va_list args) const;
-
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
   { return octave_value (matrix.sort (dim, mode)); }
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
   { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   bool print_as_scalar (void) const { return (rows () <= 1); }
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -798,17 +798,17 @@ octave_struct::load_ascii (std::istream&
 
               // recurse to read cell elements
               std::string nm
                 = read_text_data (is, std::string (), dummy, t2, j);
 
               if (!is)
                 break;
 
-              Cell tcell = t2.is_cell () ? t2.cell_value ("load: internal error loading struct elements") : Cell (t2);
+              Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
               m.setfield (nm, tcell);
             }
 
           if (is)
             map = m;
           else
             {
@@ -920,17 +920,17 @@ octave_struct::load_binary (std::istream
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
           if (!is)
             break;
 
-          Cell tcell = t2.is_cell () ? t2.cell_value ("load: internal error loading struct elements") : Cell (t2);
+          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
           m.setfield (nm, tcell);
         }
 
       if (is)
         map = m;
       else
         {
@@ -1017,17 +1017,17 @@ octave_struct::load_hdf5 (octave_hdf5_id
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = H5Giterate (loc_id, name, &current_item,
                                    hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
-      Cell tcell = t2.is_cell () ? t2.cell_value ("load: internal error loading struct elements") : Cell (t2);
+      Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
       m.setfield (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
@@ -1809,17 +1809,17 @@ produces a struct @strong{array}.\n\
 
   if ((nargin == 1 || nargin == 2)
       && args(0).is_empty () && args(0).is_real_matrix ())
     {
       Cell fields;
 
       if (nargin == 2)
         {
-          Array<std::string> cstr = args(1).cellstr_value ("struct: expecting cell array of field names as second argument");
+          Array<std::string> cstr = args(1).xcellstr_value ("struct: expecting cell array of field names as second argument");
 
           retval = octave_map (args(0).dims (), cstr);
         }
       else
         retval = octave_map (args(0).dims ());
 
       return retval;
     }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -630,17 +630,17 @@ octave_user_function::do_multi_index_op 
 
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
           octave_value varargout_varval = symbol_table::varval ("varargout");
 
           if (varargout_varval.is_defined ())
-            varargout = varargout_varval.cell_value ("expecting varargout to be a cell array object");
+            varargout = varargout_varval.xcell_value ("expecting varargout to be a cell array object");
         }
 
       retval = ret_list->convert_to_const_vector (nargout, varargout);
     }
 
   return retval;
 }
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1545,27 +1545,16 @@ octave_value::is_equal (const octave_val
 }
 
 Cell
 octave_value::cell_value (void) const
 {
   return rep->cell_value ();
 }
 
-Cell
-octave_value::cell_value (const char *fmt, ...) const
-{
-  Cell retval;
-  va_list args;
-  va_start (args,fmt);
-  retval = rep->cell_value (fmt, args);
-  va_end (args);
-  return retval;
-}
-
 // Define the idx_type_value function here instead of in ov.h to avoid
 // needing definitions for the SIZEOF_X macros in ov.h.
 
 octave_idx_type
 octave_value::idx_type_value (bool req_int, bool frc_str_conv) const
 {
 #if defined (USE_64_BIT_IDX_T)
   return int64_value (req_int, frc_str_conv);
@@ -1890,16 +1879,52 @@ octave_value::float_complex_vector_value
 {
   Array<FloatComplex> retval = float_complex_array_value (force_string_conv);
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "complex vector"));
 }
 
+// NAME can't always be "x ## FCN" because some of the original
+// value extraction functions perform implicit type conversions that we
+// wish to avoid for these functions.
+
+#define XVALUE_EXTRACTOR(TYPE, NAME, FCN) \
+  TYPE \
+  octave_value::NAME (const char *fmt, ...) const \
+  { \
+    TYPE retval; \
+ \
+    try \
+      { \
+        retval = FCN (); \
+      } \
+    catch (const octave_execution_exception&) \
+      { \
+        if (fmt) \
+          { \
+            va_list args; \
+            va_start (args, fmt); \
+            verror (fmt, args); \
+            va_end (args); \
+          } \
+ \
+        throw; \
+      } \
+ \
+    return retval; \
+  }
+
+XVALUE_EXTRACTOR (Cell, xcell_value, cell_value)
+XVALUE_EXTRACTOR (std::string, xstring_value, rep->xstring_value)
+XVALUE_EXTRACTOR (Array<std::string>, xcellstr_value, cellstr_value)
+
+#undef XVALUE_EXTRACTOR
+
 octave_value
 octave_value::storable_value (void) const
 {
   octave_value retval = *this;
   if (is_null_value ())
     retval = octave_value (rep->empty_clone ());
   else
     retval.maybe_economize ();
@@ -2840,17 +2865,17 @@ decode_subscripts (const char* name, con
       if (nel == 0)
         return;
 
       const Cell type = m.contents ("type");
       const Cell subs = m.contents ("subs");
 
       for (int k = 0; k < nel; k++)
         {
-          std::string item = type(k).string_value ("%s: type(%d) must be a string", name, k+1);
+          std::string item = type(k).xstring_value ("%s: type(%d) must be a string", name, k+1);
 
           if (item == "{}")
             type_string[k] = '{';
           else if (item == "()")
             type_string[k] = '(';
           else if (item == ".")
             type_string[k] = '.';
           else
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -765,18 +765,16 @@ public:
   double scalar_value (bool frc_str_conv = false) const
   { return rep->scalar_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
   { return rep->float_scalar_value (frc_str_conv); }
 
   Cell cell_value (void) const;
 
-  Cell cell_value (const char *fmt, ...) const;
-
   Matrix matrix_value (bool frc_str_conv = false) const
   { return rep->matrix_value (frc_str_conv); }
 
   FloatMatrix float_matrix_value (bool frc_str_conv = false) const
   { return rep->float_matrix_value (frc_str_conv); }
 
   NDArray array_value (bool frc_str_conv = false) const
   { return rep->array_value (frc_str_conv); }
@@ -894,39 +892,19 @@ public:
   { return rep->uint64_array_value (); }
 
   string_vector all_strings (bool pad = false) const
   { return rep->all_strings (pad); }
 
   std::string string_value (bool force = false) const
   { return rep->string_value (force); }
 
-  std::string string_value (const char *fmt, ...) const
-  {
-    std::string retval;
-    va_list args;
-    va_start (args,fmt);
-    retval = rep->string_value (fmt, args);
-    va_end (args);
-    return retval;
-  }
-
   Array<std::string> cellstr_value (void) const
   { return rep->cellstr_value (); }
 
-  Array<std::string> cellstr_value (const char *fmt, ...) const
-  {
-    Array<std::string> retval;
-    va_list args;
-    va_start (args,fmt);
-    retval = rep->cellstr_value (fmt, args);
-    va_end (args);
-    return retval;
-  }
-
   Range range_value (void) const
   { return rep->range_value (); }
 
   octave_map map_value (void) const;
 
   octave_scalar_map scalar_map_value (void) const;
 
   string_vector map_keys (void) const
@@ -1011,16 +989,31 @@ public:
 
   Array<float> float_vector_value (bool frc_str_conv = false,
                                    bool frc_vec_conv = false) const;
 
   Array<FloatComplex>
   float_complex_vector_value (bool frc_str_conv = false,
                               bool frc_vec_conv = false) const;
 
+  // Extract values of specific types without any implicit type
+  // conversions.  Throw an error if an object is the wrong type for
+  // the requested value extraction.
+  //
+  // These functions are intended to provide a simple way to extract
+  // values of specific types and display error messages that are more
+  // meaningful than the generic "error: wrong type argument 'cell'"
+  // message.
+
+  Cell xcell_value (const char *fmt, ...) const;
+
+  std::string xstring_value (const char *fmt, ...) const;
+
+  Array<std::string> xcellstr_value (const char *fmt, ...) const;
+
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
   { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
   // struct component, or a return value of a function.
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4543,17 +4543,17 @@ the file name and the extension.\n\
     {
       print_usage ();
       return retval;
     }
 
   std::string arg;
 
   if (nargin == 1)
-    arg = args(0).string_value ("mfilename: expecting argument to be a character string");
+    arg = args(0).xstring_value ("mfilename: expecting argument to be a character string");
 
   std::string fname;
 
   octave_user_code *fcn = octave_call_stack::caller_user_code ();
 
   if (fcn)
     {
       fname = fcn->fcn_file_name ();
@@ -4594,22 +4594,22 @@ requiring the file to be named @file{@va
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string file_name = args(0).string_value ("source: expecting file name as argument");
+      std::string file_name = args(0).xstring_value ("source: expecting file name as argument");
 
       std::string context;
 
       if (nargin == 2)
-        context = args(1).string_value ("source: expecting context to be character string");
+        context = args(1).xstring_value ("source: expecting context to be character string");
 
       source_file (file_name, context);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -4780,17 +4780,17 @@ builtin (\"sin\", 0)\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
-      const std::string name (args(0).string_value ("builtin: function name (F) must be a string"));
+      const std::string name (args(0).xstring_value ("builtin: function name (F) must be a string"));
 
       octave_value fcn = symbol_table::builtin_find (name);
 
       if (fcn.is_defined ())
         retval = feval (fcn.function_value (), args.splice (0, 1), nargout);
       else
         error ("builtin: lookup for symbol '%s' failed", name.c_str ());
     }
@@ -4880,17 +4880,17 @@ eval_string (const std::string& eval_str
 
   return retval;
 }
 
 static octave_value_list
 eval_string (const octave_value& arg, bool silent, int& parse_status,
              int nargout)
 {
-  std::string s = arg.string_value ("eval: expecting std::string argument");
+  std::string s = arg.xstring_value ("eval: expecting std::string argument");
 
   return eval_string (s, silent, parse_status, nargout);
 }
 
 void
 cleanup_statement_list (tree_statement_list **lst)
 {
   if (*lst)
@@ -5046,30 +5046,30 @@ may be either @qcode{\"base\"} or @qcode
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
-      std::string context = args(0).string_value ("assignin: CONTEXT must be a string");
+      std::string context = args(0).xstring_value ("assignin: CONTEXT must be a string");
 
       unwind_protect frame;
 
       if (context == "caller")
         octave_call_stack::goto_caller_frame ();
       else if (context == "base")
         octave_call_stack::goto_base_frame ();
       else
         error ("assignin: CONTEXT must be \"caller\" or \"base\"");
 
       frame.add_fcn (octave_call_stack::pop);
 
-      std::string nm = args(1).string_value ("assignin: VARNAME must be a string");
+      std::string nm = args(1).xstring_value ("assignin: VARNAME must be a string");
 
       if (valid_identifier (nm))
         symbol_table::assign (nm, args(2));
       else
         error ("assignin: invalid variable name in argument VARNAME");
     }
   else
     print_usage ();
@@ -5087,17 +5087,17 @@ Like @code{eval}, except that the expres
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
-      std::string context = args(0).string_value ("evalin: CONTEXT must be a string");
+      std::string context = args(0).xstring_value ("evalin: CONTEXT must be a string");
 
       unwind_protect frame;
 
       if (context == "caller")
         octave_call_stack::goto_caller_frame ();
       else if (context == "base")
         octave_call_stack::goto_base_frame ();
       else
@@ -5187,17 +5187,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string file = args(0).string_value ("__parse_file__: expecting file name as argument");
+      std::string file = args(0).xstring_value ("__parse_file__: expecting file name as argument");
 
       std::string full_file = octave_env::make_absolute (file);
 
       size_t file_len = file.length ();
 
       if ((file_len > 4 && file.substr (file_len-4) == ".oct")
           || (file_len > 4 && file.substr (file_len-4) == ".mex")
           || (file_len > 2 && file.substr (file_len-2) == ".m"))
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -204,17 +204,17 @@ tree_index_expression::get_struct_index
   if (fn.empty ())
     {
       tree_expression *df = *p_dyn_field;
 
       if (df)
         {
           octave_value t = df->rvalue1 ();
 
-          fn = t.string_value ("dynamic structure field names must be strings");
+          fn = t.xstring_value ("dynamic structure field names must be strings");
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
 
