# HG changeset patch
# User Rik <rik@octave.org>
# Date 1484789796 28800
#      Wed Jan 18 17:36:36 2017 -0800
# Node ID bef714f45999083684066195af38e810970fda4a
# Parent  3fddb261d311ccccb029a7b879d7be64b5cbe999
maint: Use space after function name/before parenthesis in libgui.

* Backend.cc, ButtonControl.cc, ButtonGroup.cc, Canvas.cc, Container.cc,
EditControl.cc, GLCanvas.cc, ListBoxControl.cc, ListBoxControl.h,
PopupMenuControl.cc, QtHandlesUtils.cc, TextControl.cc, TextEdit.h,
annotation-dialog.cc, annotation-dialog.h, gl-select.cc, dialog.cc,
files-dock-widget.cc, find-files-dialog.cc, history-dock-widget.cc,
file-editor-tab.cc, file-editor.cc, file-editor.h, find-dialog.cc, marker.cc,
octave-qscintilla.cc, octave-qscintilla.h, main-window.cc,
octave-dock-widget.cc, octave-dock-widget.h, octave-gui.cc, parser.cc,
parser.h, webinfo.cc, settings-dialog.cc, shortcut-manager.cc,
welcome-wizard.cc, workspace-view.cc:
Use space after function name and before parenthesis.

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -96,17 +96,17 @@ namespace QtHandles
       {
         Logger::debug ("Backend::initialize %s from thread %08x",
                        go.type ().c_str (), QThread::currentThreadId ());
 
         ObjectProxy* proxy = new ObjectProxy ();
         graphics_object gObj (go);
 
         OCTAVE_PTR_TYPE tmp (reinterpret_cast<OCTAVE_INTPTR_TYPE> (proxy));
-        gObj.get_properties ().set(toolkitObjectProperty (go), tmp);
+        gObj.get_properties ().set (toolkitObjectProperty (go), tmp);
 
         emit createObject (go.get_handle ().value ());
 
         return true;
       }
 
     return false;
   }
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -121,18 +121,17 @@ namespace QtHandles
       {
         gh_manager::auto_lock lock;
 
         uicontrol::properties& up = properties<uicontrol> ();
 
         Matrix oldValue = up.get_value ().matrix_value ();
         double newValue = (checked ? up.get_max () : up.get_min ());
 
-        if (oldValue.numel() != 1
-            || (newValue != oldValue(0)))
+        if (oldValue.numel () != 1 || (newValue != oldValue(0)))
           gh_manager::post_set (m_handle, "value", newValue, false);
         gh_manager::post_callback (m_handle, "callback");
       }
   }
 
   void
   ButtonControl::clicked (void)
   {
diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -98,17 +98,17 @@ namespace QtHandles
     Object* parent = Object::parentObject (go);
 
     if (parent)
       {
         Container* container = parent->innerContainer ();
 
         if (container)
           {
-            QFrame* frame = new QFrame(container);
+            QFrame* frame = new QFrame (container);
             return new ButtonGroup (go, new QButtonGroup (frame), frame);
           }
       }
 
     return 0;
   }
 
   ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup,
@@ -430,68 +430,68 @@ namespace QtHandles
   {
     m_hiddenbutton->setChecked (true);
   }
 
 
   void
   ButtonGroup::addButton (QAbstractButton* btn)
   {
-    m_buttongroup->addButton(btn);
+    m_buttongroup->addButton (btn);
     connect (btn, SIGNAL (toggled (bool)), SLOT (buttonToggled (bool)));
   }
 
   void
   ButtonGroup::buttonToggled (bool toggled)
   {
     Q_UNUSED (toggled);
     if (! m_blockUpdates)
       {
         gh_manager::auto_lock lock;
         uibuttongroup::properties& bp = properties<uibuttongroup> ();
 
-        graphics_handle oldValue = bp.get_selectedobject();
+        graphics_handle oldValue = bp.get_selectedobject ();
 
-        QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
+        QAbstractButton* checkedBtn = m_buttongroup->checkedButton ();
 
         graphics_handle newValue = graphics_handle ();
         if (checkedBtn != m_hiddenbutton)
           {
-            Object* checkedObj = Object::fromQObject(checkedBtn);
+            Object* checkedObj = Object::fromQObject (checkedBtn);
             newValue = checkedObj->properties ().get___myhandle__ ();
           }
 
         if (oldValue != newValue)
           gh_manager::post_set (m_handle, "selectedobject", newValue.as_octave_value (),
                                 false);
       }
   }
 
   void
   ButtonGroup::buttonClicked (QAbstractButton* btn)
   {
-    Q_UNUSED(btn);
+    Q_UNUSED (btn);
 
     gh_manager::auto_lock lock;
     uibuttongroup::properties& bp = properties<uibuttongroup> ();
 
-    graphics_handle oldValue = bp.get_selectedobject();
+    graphics_handle oldValue = bp.get_selectedobject ();
 
-    QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
-    Object* checkedObj = Object::fromQObject(checkedBtn);
+    QAbstractButton* checkedBtn = m_buttongroup->checkedButton ();
+    Object* checkedObj = Object::fromQObject (checkedBtn);
     graphics_handle newValue = checkedObj->properties ().get___myhandle__ ();
 
     if (oldValue != newValue)
       {
         octave_scalar_map eventData;
         eventData.setfield ("OldValue", oldValue.as_octave_value ());
         eventData.setfield ("NewValue", newValue.as_octave_value ());
         eventData.setfield ("Source", bp.get___myhandle__ ().as_octave_value ());
         eventData.setfield ("EventName", "SelectionChanged");
         octave_value selectionChangedEventObject = octave_value (new octave_struct (
               eventData));
-        gh_manager::post_callback(m_handle, "selectionchangedfcn",
+        gh_manager::post_callback (m_handle, "selectionchangedfcn",
                                   selectionChangedEventObject);
       }
   }
 
 };
 
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -116,18 +116,18 @@ namespace QtHandles
   }
 
   /*
      Two updateCurrentPoint() routines are required:
      1) Used for QMouseEvents where cursor position data is in callback from Qt.
      2) Used for QKeyEvents where cursor position must be determined.
   */
   void
-  Canvas::updateCurrentPoint(const graphics_object& fig,
-                             const graphics_object& obj, QMouseEvent* event)
+  Canvas::updateCurrentPoint (const graphics_object& fig,
+                              const graphics_object& obj, QMouseEvent* event)
   {
     gh_manager::auto_lock lock;
 
     gh_manager::post_set (fig.get_handle (), "currentpoint",
                           Utils::figureCurrentPoint (fig, event), false);
 
     Matrix children = obj.get_properties ().get_children ();
     octave_idx_type num_children = children.numel ();
@@ -154,35 +154,35 @@ namespace QtHandles
 
             gh_manager::post_set (childObj.get_handle (), "currentpoint", cp,
                                   false);
           }
       }
   }
 
   void
-  Canvas::updateCurrentPoint(const graphics_object& fig,
-                             const graphics_object& obj)
+  Canvas::updateCurrentPoint (const graphics_object& fig,
+                              const graphics_object& obj)
   {
     gh_manager::auto_lock lock;
 
     gh_manager::post_set (fig.get_handle (), "currentpoint",
                           Utils::figureCurrentPoint (fig), false);
 
     Matrix children = obj.get_properties ().get_children ();
     octave_idx_type num_children = children.numel ();
 
     for (int i = 0; i < num_children; i++)
       {
         graphics_object childObj (gh_manager::get_object (children(i)));
 
         if (childObj.isa ("axes"))
           {
-            // FIXME: QCursor::pos() may give inaccurate results with asynchronous
-            //        window systems like X11 over ssh.
+            // FIXME: QCursor::pos() may give inaccurate results with
+            //        asynchronous window systems like X11 over ssh.
             QWidget *w = qWidget ();
             QPoint p = w->mapFromGlobal (QCursor::pos ());
             axes::properties& ap = Utils::properties<axes> (childObj);
             Matrix x_zlim = ap.get_transform_zlim ();
             graphics_xform x_form = ap.get_transform ();
 
             ColumnVector p1 = x_form.untransform (p.x (), p.y (), x_zlim(0));
             ColumnVector p2 = x_form.untransform (p.x (), p.y (), x_zlim(1));
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -53,17 +53,17 @@ namespace QtHandles
       {
         gh_manager::auto_lock lock;
         graphics_object go = gh_manager::get_object (gh);
 
         if (go)
           {
             graphics_object fig = go.get_ancestor ("figure");
 
-            m_canvas = Canvas::create (fig.get("renderer").string_value (),
+            m_canvas = Canvas::create (fig.get ("renderer").string_value (),
                                        this, gh);
 
             QWidget* canvasWidget = m_canvas->qWidget ();
 
             canvasWidget->lower ();
             canvasWidget->show ();
             canvasWidget->setGeometry (0, 0, width (), height ());
           }
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -100,17 +100,17 @@ namespace QtHandles
 
     m_multiLine = true;
     initCommon (edit);
 
     uicontrol::properties& up = properties<uicontrol> ();
 
     edit->setAcceptRichText (false);
     edit->setPlainText (Utils::fromStringVector (
-                          up.get_string_vector()).join("\n"));
+                          up.get_string_vector ()).join ("\n"));
 
     connect (edit, SIGNAL (textChanged (void)),
              SLOT (textChanged (void)));
     connect (edit, SIGNAL (editingFinished (void)),
              SLOT (editingFinished (void)));
     connect (edit, SIGNAL (returnPressed (void)),
              SLOT (returnPressed (void)));
   }
@@ -186,17 +186,17 @@ namespace QtHandles
   {
     uicontrol::properties& up = properties<uicontrol> ();
     TextEdit* edit = qWidget<TextEdit> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         edit->setPlainText (Utils::fromStringVector (
-                              up.get_string_vector()).join("\n"));
+                              up.get_string_vector ()).join ("\n"));
         return true;
 
       case uicontrol::properties::ID_MIN:
       case uicontrol::properties::ID_MAX:
         if ((up.get_max () - up.get_min ()) <= 1)
           {
             QWidget* container = edit->parentWidget ();
 
@@ -223,20 +223,21 @@ namespace QtHandles
   {
     QString txt = (m_multiLine
                    ? qWidget<TextEdit> ()->toPlainText ()
                    : qWidget<QLineEdit> ()->text ());
 
     if (m_textChanged)
       {
         if (m_multiLine)
-          gh_manager::post_set (m_handle, "string", Utils::toCellString(txt.split("\n")),
-                                false);
+          gh_manager::post_set (m_handle, "string",
+                                Utils::toCellString (txt.split ("\n")), false);
         else
-          gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
+          gh_manager::post_set (m_handle, "string",
+                                Utils::toStdString (txt), false);
 
         m_textChanged = false;
       }
 
     if (txt.length () > 0)
       gh_manager::post_callback (m_handle, "callback");
   }
 
@@ -244,20 +245,21 @@ namespace QtHandles
   EditControl::editingFinished (void)
   {
     if (m_textChanged)
       {
         QString txt = (m_multiLine
                        ? qWidget<TextEdit> ()->toPlainText ()
                        : qWidget<QLineEdit> ()->text ());
         if (m_multiLine)
-          gh_manager::post_set (m_handle, "string", Utils::toCellString(txt.split("\n")),
-                                false);
+          gh_manager::post_set (m_handle, "string",
+                                Utils::toCellString (txt.split ("\n")), false);
         else
-          gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
+          gh_manager::post_set (m_handle, "string",
+                                Utils::toStdString (txt), false);
         gh_manager::post_callback (m_handle, "callback");
 
         m_textChanged = false;
       }
   }
 
 }
 
diff --git a/libgui/graphics/GLCanvas.cc b/libgui/graphics/GLCanvas.cc
--- a/libgui/graphics/GLCanvas.cc
+++ b/libgui/graphics/GLCanvas.cc
@@ -41,34 +41,34 @@ namespace QtHandles
       Canvas (gh)
 #else
     : QGLWidget (QGLFormat (QGL::SampleBuffers | QGL::AlphaChannel),
                  xparent),
       Canvas (gh)
 #endif
   {
     setFocusPolicy (Qt::ClickFocus);
-    setFocus();
+    setFocus ();
   }
 
   GLCanvas::~GLCanvas (void)
   { }
 
   void
   GLCanvas::draw (const graphics_handle& gh)
   {
     gh_manager::auto_lock lock;
     graphics_object go = gh_manager::get_object (gh);
 
     if (go)
       {
         octave::opengl_renderer r;
 
         r.set_viewport (width (), height ());
-        r.draw(go);
+        r.draw (go);
       }
   }
 
   void
   GLCanvas::toggleAxes (const graphics_handle& gh)
   {
     canvasToggleAxes (gh);
   }
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -157,28 +157,28 @@ namespace QtHandles
 
       default:
         BaseControl::update (pId);
         break;
       }
   }
 
   void
-  ListBoxControl::sendSelectionChange()
+  ListBoxControl::sendSelectionChange ()
   {
     if (! m_blockCallback)
       {
         QListWidget* list = qWidget<QListWidget> ();
 
         QModelIndexList l = list->selectionModel ()->selectedIndexes ();
         Matrix value (dim_vector (1, l.size ()));
         int i = 0;
 
         foreach (const QModelIndex& idx, l)
-        value(i++) = (idx.row () + 1);
+          value(i++) = idx.row () + 1;
 
         gh_manager::post_set (m_handle, "value", octave_value (value), false);
         gh_manager::post_callback (m_handle, "callback");
       }
 
       m_selectionChanged = false;
   }
 
@@ -231,32 +231,32 @@ namespace QtHandles
             case QEvent::MouseButtonPress:
               {
                 QMouseEvent* m = dynamic_cast<QMouseEvent*> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
                 else
                   {
-                    if (! list->indexAt(m->pos()).isValid())
+                    if (! list->indexAt (m->pos ()).isValid ())
                       override_return = true;
                     m_selectionChanged = true;
                   }
                 break;
               }
             case QEvent::MouseButtonRelease:
               {
                 QMouseEvent* m = dynamic_cast<QMouseEvent*> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
 
-                else if (! list->indexAt(m->pos()).isValid())
+                else if (! list->indexAt (m->pos ()).isValid ())
                   {
-                    list->setCurrentRow(list->count()-1);
+                    list->setCurrentRow (list->count () - 1);
                     override_return = true;
                   }
 
                 if (m_selectionChanged)
                   sendSelectionChange ();
                 m_selectionChanged = false;
 
                 break;
diff --git a/libgui/graphics/ListBoxControl.h b/libgui/graphics/ListBoxControl.h
--- a/libgui/graphics/ListBoxControl.h
+++ b/libgui/graphics/ListBoxControl.h
@@ -40,17 +40,17 @@ namespace QtHandles
     ListBoxControl (const graphics_object& go, QListWidget* list);
     ~ListBoxControl (void);
 
     static ListBoxControl* create (const graphics_object& go);
 
   protected:
     void update (int pId);
     bool eventFilter (QObject* watched, QEvent* e);
-    void sendSelectionChange();
+    void sendSelectionChange ();
 
   private slots:
     void itemSelectionChanged (void);
     void itemActivated (const QModelIndex &);
     void itemPressed (QListWidgetItem*);
 
   private:
     bool m_blockCallback;
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -75,17 +75,17 @@ namespace QtHandles
       case uicontrol::properties::ID_STRING:
         m_blockUpdate = true;
         {
           int oldCurrent = box->currentIndex ();
 
           box->clear ();
           box->addItems (Utils::fromStdString
                          (up.get_string_string ()).split ('|'));
-          if (box->count() > 0
+          if (box->count () > 0
               && oldCurrent >= 0
               && oldCurrent < box->count ())
             {
               box->setCurrentIndex (oldCurrent);
             }
           else
             {
               gh_manager::post_set (m_handle, "value",
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -91,17 +91,17 @@ namespace QtHandles
       while ((tmp.length () > 0) && tmp.last ().isEmpty ())
         {
           tmp.removeLast ();
         }
       // no strings converts to a 1x1 cell with empty string
       if (tmp.isEmpty ())
         tmp += "";
 
-      Cell v(toStringVector (tmp));
+      Cell v (toStringVector (tmp));
       return v;
     }
 
     template <typename T>
     QFont
     computeFont (const typename T::properties& props, int height)
     {
       QFont f (fromStdString (props.get_fontname ()));
@@ -234,18 +234,18 @@ namespace QtHandles
       Object* tkFig = Backend::toolkitObject (fig);
 
       if (tkFig)
         {
           Container* c = tkFig->innerContainer ();
 
           if (c)
             {
-              // FIXME: QCursor::pos() may give inaccurate results with asynchronous
-              //        window systems like X11 over ssh.
+              // FIXME: QCursor::pos() may give inaccurate results with
+              //        asynchronous window systems like X11 over ssh.
               QPoint qp = c->mapFromGlobal (QCursor::pos ());
 
               return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
                      qp.y ());
             }
         }
 
       return Matrix (1, 2, 0.0);
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -54,32 +54,32 @@ namespace QtHandles
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     label->setAutoFillBackground (true);
     label->setTextFormat (Qt::PlainText);
     label->setWordWrap (false);
     label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
                          up.get_verticalalignment ()));
-    label->setText(Utils::fromStringVector (up.get_string_vector()).join("\n"));
+    label->setText (Utils::fromStringVector (up.get_string_vector ()).join ("\n"));
   }
 
   TextControl::~TextControl (void)
   { }
 
   void
   TextControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
     QLabel* label = qWidget<QLabel> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
-        label->setText(Utils::fromStringVector (up.get_string_vector()).join("\n"));
+        label->setText (Utils::fromStringVector (up.get_string_vector ()).join ("\n"));
         break;
 
       case uicontrol::properties::ID_HORIZONTALALIGNMENT:
       case uicontrol::properties::ID_VERTICALALIGNMENT:
         label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
                              up.get_verticalalignment ()));
         break;
 
diff --git a/libgui/graphics/TextEdit.h b/libgui/graphics/TextEdit.h
--- a/libgui/graphics/TextEdit.h
+++ b/libgui/graphics/TextEdit.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 namespace QtHandles
 {
 
   class TextEdit : public QTextEdit
   {
     Q_OBJECT
 
   public:
-    TextEdit (QWidget* xparent) : QTextEdit(xparent) { }
+    TextEdit (QWidget* xparent) : QTextEdit (xparent) { }
     ~TextEdit (void) = default;
 
   signals:
     void editingFinished (void);
     void returnPressed (void);
 
   protected:
     void focusOutEvent (QFocusEvent* event);
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -49,17 +49,17 @@ void
 annotation_dialog::init ()
 {
   ui->setupUi (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
   // restore last geometry
   if (settings)
-    restoreGeometry (settings->value("annotation/geometry").toByteArray ());
+    restoreGeometry (settings->value ("annotation/geometry").toByteArray ());
 
   // connect signals
   connect (ui->button_box, SIGNAL (clicked (QAbstractButton *)),
            this, SLOT (button_clicked (QAbstractButton *)));
 
   connect (ui->edit_string, SIGNAL (textChanged (const QString&)),
            this, SLOT (edit_string_changed (const QString&)));
 
@@ -69,18 +69,18 @@ annotation_dialog::init ()
   connect (ui->btn_background_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
   connect (ui->btn_edge_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
   // set gui element to default values
   ui->cb_fit_box_to_text->setChecked (true);
-  ui->cb_horz_align->setCurrentIndex (ui->cb_horz_align->findText("left"));
-  ui->cb_vert_align->setCurrentIndex (ui->cb_vert_align->findText("middle"));
+  ui->cb_horz_align->setCurrentIndex (ui->cb_horz_align->findText ("left"));
+  ui->cb_vert_align->setCurrentIndex (ui->cb_vert_align->findText ("middle"));
 
   // set gui elements to any values from input properties
   set_gui_props ();
 }
 
 annotation_dialog::~annotation_dialog ()
 {
   delete ui;
@@ -142,17 +142,17 @@ annotation_dialog::get_gui_props ()
   tmpstr = (ui->cb_horz_align->currentIndex () == 0 ? "left" :
             (ui->cb_horz_align->currentIndex () == 1 ? "center" : "right"));
   props.append (ovl ("horizontalalignment", tmpstr));
 
   tmpstr = (ui->cb_vert_align->currentIndex () == 0 ? "top" :
             (ui->cb_horz_align->currentIndex () == 1 ? "middle" : "bottom"));
   props.append (ovl ("verticalalignment", tmpstr));
 
-  tmpstr = ui->cb_font_name->currentText ().toStdString();
+  tmpstr = ui->cb_font_name->currentText ().toStdString ();
   props.append (ovl ("fontname", tmpstr));
 
   props.append (ovl ("fontsize", ui->sb_font_size->value ()));
   props.append (ovl ("fontweight",
                      ui->cb_font_bold->isChecked () ? "bold" : "normal"));
   props.append (ovl ("fontangle",
                      ui->cb_font_italic->isChecked () ? "italic" : "normal"));
   props.append (ovl ("color", Utils::toRgb (ui->btn_color->palette ().
@@ -171,17 +171,17 @@ annotation_dialog::set_gui_props ()
 
   for (int i=0; i<len/2; i++)
     {
       std::string name = props(i*2).string_value ();
 
       if (name == "textbox")
         {
           Matrix position = props(2*i +1).matrix_value ();
-          int nels = position.numel();
+          int nels = position.numel ();
           if (nels >= 2)
             {
               ui->sb_x->setValue (position(0));
               ui->sb_y->setValue (position(1));
             }
           else
             {
               ui->sb_x->setValue (0);
@@ -265,17 +265,17 @@ annotation_dialog::edit_string_changed (
 void
 annotation_dialog::prompt_for_color ()
 {
   QWidget *widg = dynamic_cast<QWidget*> (sender ());
   if (widg)
     {
       QColor color = widg->palette ().color (QPalette::Button);
 
-      color = QColorDialog::getColor(color, this);
+      color = QColorDialog::getColor (color, this);
 
       if (color.isValid ())
         {
           widg->setPalette (QPalette (color));
 
           QString css = QString ("background-color: %1; border: 1px solid %2;")
                         .arg (color.name ())
                         .arg ("#000000");
diff --git a/libgui/graphics/annotation-dialog.h b/libgui/graphics/annotation-dialog.h
--- a/libgui/graphics/annotation-dialog.h
+++ b/libgui/graphics/annotation-dialog.h
@@ -36,26 +36,26 @@ namespace Ui
 
 class annotation_dialog : public QDialog
 {
   Q_OBJECT
 public:
   explicit annotation_dialog (QWidget * parent, const octave_value_list &pr);
   ~annotation_dialog ();
 
-  octave_value_list get_properties() const;
+  octave_value_list get_properties () const;
 
 private slots:
   // slots for dialog's buttons
   void button_clicked (QAbstractButton *button);
   void edit_string_changed (const QString &str);
   void prompt_for_color ();
 
 private:
-  void init();
+  void init ();
 
   void get_gui_props ();
   void set_gui_props ();
 
   Ui::annotation_dialog * ui;
   octave_value_list props;
 };
 
diff --git a/libgui/graphics/gl-select.cc b/libgui/graphics/gl-select.cc
--- a/libgui/graphics/gl-select.cc
+++ b/libgui/graphics/gl-select.cc
@@ -191,17 +191,17 @@ namespace octave
                                 int halign, int valign, double rotation)
   {
     uint8NDArray pixels;
     Matrix bbox (1, 4, 0.0);
 
     // FIXME: probably more efficient to only compute bbox instead
     //        of doing full text rendering...
     text_to_pixels (txt, pixels, bbox, halign, valign, rotation);
-    fake_text(x, y, z, bbox, false);
+    fake_text (x, y, z, bbox, false);
 
     return bbox;
   }
 
   void
   opengl_selector::draw_image (const image::properties& props)
   {
     Matrix xd = props.get_xdata ().matrix_value ();
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -484,17 +484,17 @@ FileDialog::FileDialog (const QStringLis
            &uiwidget_creator,
            SLOT (filedialog_finished (const QStringList&, const QString&,
                                       int)));
   connect (this, SIGNAL (accepted ()), this, SLOT (acceptSelection ()));
   connect (this, SIGNAL (rejected ()), this, SLOT (rejectSelection ()));
 }
 
 void
-FileDialog::rejectSelection(void)
+FileDialog::rejectSelection (void)
 {
   QStringList empty;
   emit finish_input (empty, "", 0);
 }
 
 void FileDialog::acceptSelection (void)
 {
   QStringList string_result;
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -233,18 +233,18 @@ files_dock_widget::files_dock_widget (QW
            this, SLOT (item_double_clicked (const QModelIndex &)));
 
   // add context menu to tree_view
   _file_tree_view->setContextMenuPolicy (Qt::CustomContextMenu);
   connect (_file_tree_view,
            SIGNAL (customContextMenuRequested (const QPoint &)),
            this, SLOT (contextmenu_requested (const QPoint &)));
 
-  _file_tree_view->header()->setContextMenuPolicy (Qt::CustomContextMenu);
-  connect (_file_tree_view->header(),
+  _file_tree_view->header ()->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (_file_tree_view->header (),
            SIGNAL (customContextMenuRequested (const QPoint &)),
            this, SLOT (headercontextmenu_requested (const QPoint &)));
 
   // Layout the widgets vertically with the toolbar on top
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
   vbox_layout->setSpacing (0);
   vbox_layout->addWidget (_navigation_tool_bar);
   vbox_layout->addWidget (_file_tree_view);
@@ -384,17 +384,17 @@ files_dock_widget::display_directory (co
       else
         {
           QString abs_fname = fileInfo.absoluteFilePath ();
 
           QString suffix = fileInfo.suffix ().toLower ();
           QSettings *settings = resource_manager::get_settings ();
           QString ext = settings->value ("filesdockwidget/txt_file_extensions",
                                          "m;c;cc;cpp;h;txt").toString ();
-          QStringList extensions = ext.split(";", QString::SkipEmptyParts);
+          QStringList extensions = ext.split (";", QString::SkipEmptyParts);
 
           if (QFile::exists (abs_fname))
             {
               if (is_octave_data_file (abs_fname.toStdString ()))
                 emit load_file_signal (abs_fname);
               else if (extensions.contains (suffix))
                 emit open_file (fileInfo.absoluteFilePath ());
               else
@@ -451,17 +451,17 @@ files_dock_widget::headercontextmenu_req
   _sig_mapper = new QSignalMapper (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
   for (int i = 0; i < _columns_shown.size (); i++)
     {
       QAction *action = menu.addAction (_columns_shown.at (i),
                                         _sig_mapper, SLOT (map ()));
-      _sig_mapper->setMapping(action, i);
+      _sig_mapper->setMapping (action, i);
       action->setCheckable (true);
       action->setChecked (
             settings->value (_columns_shown_keys.at (i),true).toBool ());
     }
 
   connect (_sig_mapper, SIGNAL (mapped (int)),
            this, SLOT (toggle_header (int)));
 
@@ -482,20 +482,20 @@ files_dock_widget::contextmenu_requested
 
       QItemSelectionModel *m = _file_tree_view->selectionModel ();
       QModelIndexList sel = m->selectedRows ();
 
       // check if item at mouse position is seleccted
       if (! sel.contains (index))
         {
           // is not selected -> clear actual selection and select this item
-          m->setCurrentIndex(index,
-                             QItemSelectionModel::Clear
-                             | QItemSelectionModel::Select
-                             | QItemSelectionModel::Rows);
+          m->setCurrentIndex (index,
+                              QItemSelectionModel::Clear
+                              | QItemSelectionModel::Select
+                              | QItemSelectionModel::Rows);
         }
 
       // construct the context menu depending on item
       menu.addAction (resource_manager::icon ("document-open"), tr ("Open"),
                       this, SLOT (contextmenu_open (bool)));
 
       if (info.isDir ())
         {
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -309,17 +309,17 @@ find_files_dialog::stop_find ()
   _recurse_dirs_check->setEnabled (true);
   _include_dirs_check->setEnabled (true);
   _name_case_check->setEnabled (true);
   _contains_text_check->setEnabled (true);
   _content_case_check->setEnabled (true);
   _contains_text_edit->setEnabled (true);
 
   find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
-  QString res_str = QString (tr("%1 match(es)")).arg (m->rowCount ());
+  QString res_str = QString (tr ("%1 match (es)")).arg (m->rowCount ());
 
   _status_bar->showMessage (res_str);
 }
 
 void
 find_files_dialog::browse_folders ()
 {
   QString dir =
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -108,17 +108,17 @@ history_dock_widget::construct ()
 
   hist_layout->setMargin (2);
   widget ()->setLayout (hist_layout);
 
   // Init state of the filter
   QSettings *settings = resource_manager::get_settings ();
 
   _filter_shown
-    = settings->value ("history_dock_widget/filter_shown",true).toBool();
+    = settings->value ("history_dock_widget/filter_shown",true).toBool ();
   _filter_widget->setVisible (_filter_shown);
 
   _filter->addItems (settings->value ("history_dock_widget/mru_list").toStringList ());
 
   bool filter_state
     = settings->value ("history_dock_widget/filter_active", false).toBool ();
   _filter_checkbox->setChecked (filter_state);
   filter_activate (filter_state);
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -319,17 +319,17 @@ file_editor_tab::handle_context_menu_edi
     }
 
   if (pos_fct > -1)
     {
       // reg expr. found: it is an internal function
       _edit_area->setCursorPosition (line, pos_fct);
       _edit_area->SendScintilla (2232, line);     // SCI_ENSUREVISIBLE
                                                   // SCI_VISIBLEFROMDOCLINE
-      int vis_line = _edit_area->SendScintilla(2220, line);
+      int vis_line = _edit_area->SendScintilla (2220, line);
       _edit_area->SendScintilla (2613, vis_line); // SCI_SETFIRSTVISIBLELINE
       return;
     }
 
   emit edit_mfile_request (word_at_cursor, _file_name, _ced, -1);
 }
 
 // If "dbstop if ..." selected from context menu, create a conditional
@@ -584,31 +584,31 @@ file_editor_tab::update_lexer ()
           // other or no extension
           lexer = new octave_txt_lexer ();
         }
     }
 
   QSettings *settings = resource_manager::get_settings ();
 
   // build information for auto completion (APIs)
-  _lexer_apis = new QsciAPIs(lexer);
+  _lexer_apis = new QsciAPIs (lexer);
 
   if (_lexer_apis)
     {
       bool update_apis_file = false;  // flag, whether update of apis files
 
       // get path to prepared api info
 #if defined (HAVE_QT4)
       QString prep_apis_path
         = QDesktopServices::storageLocation (QDesktopServices::HomeLocation)
-          + "/.config/octave/"  + QString(OCTAVE_VERSION) + "/qsci/";
+          + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
 #else
       QString prep_apis_path
         = QStandardPaths::writableLocation (QStandardPaths::HomeLocation)
-          + "/.config/octave/"  + QString(OCTAVE_VERSION) + "/qsci/";
+          + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
 #endif
 
       // get settings which infos are used for octave
       bool octave_builtins = settings->value (
                   "editor/codeCompletion_octave_builtins", true).toBool ();
       bool octave_functions = settings->value (
                   "editor/codeCompletion_octave_functions", true).toBool ();
 
@@ -693,27 +693,27 @@ file_editor_tab::update_lexer ()
             }
           else
             {
 
               _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
 
               for (i=1; i<=3; i++) // test the first 5 keyword sets
                 {
-                  keyword = QString(lexer->keywords (i));           // get list
+                  keyword = QString (lexer->keywords (i));          // get list
                   keyword_list = keyword.split (QRegExp ("\\s+"));  // split
                   for (j = 0; j < keyword_list.size (); j++)        // add to API
                     _lexer_apis->add (keyword_list.at (j));
                 }
             }
 
           // dsiconnect slot for saving prepared info if already connected
           disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), 0, 0);
           // check whether path for prepared info exists or can be created
-          if (QDir("/").mkpath (prep_apis_path))
+          if (QDir ("/").mkpath (prep_apis_path))
             {
               // path exists, apis info can be saved there
               connect (_lexer_apis, SIGNAL (apiPreparationFinished ()),
                        this, SLOT (save_apis_info ()));
             }
           _lexer_apis->prepare ();  // prepare apis info
         }
     }
@@ -774,24 +774,24 @@ file_editor_tab::save_apis_info ()
 QString
 file_editor_tab::comment_string (const QString& lexer)
 {
   if (lexer == "octave" || lexer == "matlab")
     {
       QSettings *settings = resource_manager::get_settings ();
       int comment_index = settings->value ("editor/octave_comment_string", 0).toInt ();
       if (comment_index == 1)
-      	return QString("#");
+      	return QString ("#");
       else if (comment_index == 2)
-        return QString("%");
+        return QString ("%");
       else
-        return QString("##");  // default and for index 0
+        return QString ("##");  // default and for index 0
     }
   else if (lexer == "perl" || lexer == "bash" || lexer == "diff")
-    return QString("#");
+    return QString ("#");
   else if (lexer == "cpp")
     return ("//");
   else if (lexer == "batch")
     return ("REM ");
   else
     return ("%");  // should never happen
 }
 
@@ -1248,17 +1248,17 @@ file_editor_tab::find (const QWidget *ID
 
       _find_dialog->setWindowModality (Qt::NonModal);
       _find_dialog_geometry = _find_dialog->geometry ();
     }
   else if (! _find_dialog->isVisible ())
     {
       _find_dialog->setGeometry (_find_dialog_geometry);
       QPoint p = _find_dialog->pos ();
-      _find_dialog->move(p.x ()+10, p.y ()+10);
+      _find_dialog->move (p.x ()+10, p.y ()+10);
     }
 
   _find_dialog->show ();
   _find_dialog_is_visible = true;
   _find_dialog->activateWindow ();
   _find_dialog->init_search_text ();
 
 }
@@ -1601,34 +1601,34 @@ file_editor_tab::load_file (const QStrin
   QFile file (file_to_load);
   if (! file.open (QFile::ReadOnly))
     return file.errorString ();
 
   // read the file
   QTextStream in (&file);
   // set the desired codec
   QTextCodec *codec = QTextCodec::codecForName (_encoding.toLatin1 ());
-  in.setCodec(codec);
+  in.setCodec (codec);
 
   QApplication::setOverrideCursor (Qt::WaitCursor);
   _edit_area->setText (in.readAll ());
   _edit_area->setEolMode (detect_eol_mode ());
   QApplication::restoreOverrideCursor ();
 
   _copy_available = false;     // no selection yet available
   set_file_name (file_to_load);
   update_window_title (false); // window title (no modification)
   _edit_area->setModified (false); // loaded file is not modified yet
 
   update_eol_indicator ();
 
   // FIXME: (BREAKPOINTS) At this point it would be nice to put any set
   // breakpoints on the margin.  In order to do this, somehow the
   // "dbstatus" command needs to be accessed.  All it would require is a
-  // routine that does "res = feval("dbstatus") and signals that result
+  // routine that does "res = feval ("dbstatus") and signals that result
   // to some slot.
   //
   // See patch #8016 for a general way to get Octave results from
   // commands processed in the background.
 
 /*
   connect (octave_link, SIGNAL (fileSelected (QObject *, const QString&, const octave_value_list&)),
            this, SLOT (handle_feval_result (QObject *, const QString&, const octave_value_list&)));
@@ -1660,17 +1660,17 @@ file_editor_tab::detect_eol_mode ()
   int os_eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
   int os_eol_mode = QsciScintilla::EolMac;
 #else
   int os_eol_mode = QsciScintilla::EolUnix;
 #endif
   QSettings *settings = resource_manager::get_settings ();
   QsciScintilla::EolMode eol_mode = static_cast<QsciScintilla::EolMode> (
-        settings->value("editor/default_eol_mode",os_eol_mode).toInt ());
+        settings->value ("editor/default_eol_mode",os_eol_mode).toInt ());
 
   int count_max = 0;
 
   if (count_crlf > count_max)
     {
       eol_mode = QsciScintilla::EolWindows;
       count_max = count_crlf;
     }
@@ -1745,17 +1745,17 @@ file_editor_tab::new_file (const QString
   int eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
   int eol_mode = QsciScintilla::EolMac;
 #else
   int eol_mode = QsciScintilla::EolUnix;
 #endif
   _edit_area->setEolMode (
     static_cast<QsciScintilla::EolMode> (
-      settings->value("editor/default_eol_mode",eol_mode).toInt ()));
+      settings->value ("editor/default_eol_mode",eol_mode).toInt ()));
 
   update_eol_indicator ();
 
   update_lexer ();
 
   _edit_area->setText (commands);
   _edit_area->setModified (false); // new file is not modified yet
 }
@@ -1953,17 +1953,17 @@ file_editor_tab::save_file_as (bool remo
       fileDialog = new QFileDialog ();
     }
   else
     fileDialog = new QFileDialog (this);
 
   // Giving trouble under KDE (problem is related to Qt signal handling on unix,
   // see https://bugs.kde.org/show_bug.cgi?id=260719 ,
   // it had/has no effect on Windows, though)
-  fileDialog->setOption(QFileDialog::DontUseNativeDialog, true);
+  fileDialog->setOption (QFileDialog::DontUseNativeDialog, true);
 
   // define a new grid layout with the extra elements
   QGridLayout *extra = new QGridLayout (fileDialog);
   QFrame *separator = new QFrame (fileDialog);
   separator->setFrameShape (QFrame::HLine);   // horizontal line as separator
   separator->setFrameStyle (QFrame::Sunken);
 
   // combo box for choosing new line ending chars
@@ -2296,17 +2296,17 @@ file_editor_tab::notice_settings (const 
     if (settings->value ("editor/show_white_space_indent",false).toBool ())
       _edit_area->setWhitespaceVisibility (QsciScintilla::WsVisibleAfterIndent);
     else
       _edit_area->setWhitespaceVisibility (QsciScintilla::WsVisible);
   else
     _edit_area->setWhitespaceVisibility (QsciScintilla::WsInvisible);
 
   _edit_area->setEolVisibility (
-              settings->value("editor/show_eol_chars",false).toBool ());
+              settings->value ("editor/show_eol_chars",false).toBool ());
 
   if (settings->value ("editor/showLineNumbers", true).toBool ())
     {
       _edit_area->setMarginLineNumbers (2, true);
       auto_margin_width ();
       connect (_edit_area, SIGNAL (linesChanged ()),
                this, SLOT (auto_margin_width ()));
     }
@@ -2386,17 +2386,17 @@ file_editor_tab::change_editor_state (co
         }
       return;
     }
 
   if (_find_dialog && _find_dialog_is_visible)
     {
       _find_dialog->setGeometry (_find_dialog_geometry);
       QPoint p = _find_dialog->pos ();
-      _find_dialog->move(p.x ()+10, p.y ()+10);
+      _find_dialog->move (p.x ()+10, p.y ()+10);
       _find_dialog->show ();
     }
 
   emit editor_state_changed (_copy_available, _is_octave_file);
 }
 
 void
 file_editor_tab::file_name_query (const QWidget *ID)
@@ -2692,22 +2692,22 @@ file_editor_tab::get_function_name ()
   QRegExp rxfun3 ("^[\t ]*function[^=]+=[\t ]*([^\\s]+)[\t ]*$");
   QRegExp rxfun4 ("^[\t ]*function[\t ]+([^\\s]+)[\t ]*$");
 
   QStringList lines = _edit_area->text ().split ("\n");
 
   for (int i = 0; i < lines.count (); i++)
     {
       if (rxfun1.indexIn (lines.at (i)) != -1)
-        return rxfun1.cap (1).remove (QRegExp("[ \t]*"));
+        return rxfun1.cap (1).remove (QRegExp ("[ \t]*"));
       else if (rxfun2.indexIn (lines.at (i)) != -1)
-        return rxfun2.cap (1).remove (QRegExp("[ \t]*"));
+        return rxfun2.cap (1).remove (QRegExp ("[ \t]*"));
       else if (rxfun3.indexIn (lines.at (i)) != -1)
-        return rxfun3.cap (1).remove (QRegExp("[ \t]*"));
+        return rxfun3.cap (1).remove (QRegExp ("[ \t]*"));
       else if (rxfun4.indexIn (lines.at (i)) != -1)
-        return rxfun4.cap (1).remove (QRegExp("[ \t]*"));
+        return rxfun4.cap (1).remove (QRegExp ("[ \t]*"));
     }
 
   return QString ();
 }
 
 #endif
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -65,17 +65,17 @@ file_editor::file_editor (QWidget *p)
 
   construct ();
 
   // actions that should also be available in the find dialog
   _fetab_actions << _find_next_action;
   _fetab_actions << _find_previous_action;
 
   setVisible (false);
-  setAcceptDrops(true);
+  setAcceptDrops (true);
 
   _file_encoding = QString ();  // for selecting an encoding in open dialog
 }
 
 file_editor::~file_editor (void)
 {
   if (_mru_file_menu)
     delete _mru_file_menu;
@@ -266,17 +266,17 @@ file_editor::request_open_file (void)
 
   // Create a NonModal message.
   QFileDialog *fileDialog = new QFileDialog (this);
   fileDialog->setNameFilter (tr ("Octave Files (*.m);;All Files (*)"));
 
   // Giving trouble under KDE (problem is related to Qt signal handling on unix,
   // see https://bugs.kde.org/show_bug.cgi?id=260719 ,
   // it had/has no effect on Windows, though)
-  fileDialog->setOption(QFileDialog::DontUseNativeDialog, true);
+  fileDialog->setOption (QFileDialog::DontUseNativeDialog, true);
 
   // define a new grid layout with the extra elements
   QGridLayout *extra = new QGridLayout (fileDialog);
   QFrame *separator = new QFrame (fileDialog);
   separator->setFrameShape (QFrame::HLine);   // horizontal line as separator
   separator->setFrameStyle (QFrame::Sunken);
 
   // combo box for encoding
@@ -676,17 +676,17 @@ file_editor::handle_edit_mfile_request (
   QString type = QString::fromStdString (
                          map.contents ("type").data ()[0].string_value ());
   QString name = QString::fromStdString (
                          map.contents ("name").data ()[0].string_value ());
 
   QString message = QString ();
   QString filename = QString ();
 
-  if (type == QString("built-in function"))
+  if (type == QString ("built-in function"))
     {
       // built in function: can't edit
       message = tr ("%1 is a built-in function");
     }
   else if (type.isEmpty ())
     {
       // function not known to octave -> try directory of edited file
       // get directory
@@ -1497,19 +1497,19 @@ file_editor::add_action (QMenu *menu, co
   return a;
 }
 
 // function enabling/disabling the menu accelerators depending on the
 // focus of the editor
 void
 file_editor::enable_menu_shortcuts (bool enable)
 {
-  QHash<QMenu*, QStringList>::const_iterator i = _hash_menu_text.constBegin();
+  QHash<QMenu*, QStringList>::const_iterator i = _hash_menu_text.constBegin ();
 
-  while (i != _hash_menu_text.constEnd())
+  while (i != _hash_menu_text.constEnd ())
     {
       i.key ()->setTitle (i.value ().at (! enable));
       ++i;
     }
 
   // when editor loses focus, enable the actions, which are always active
   // in the main window due to missing info on selected text and undo actions
   if (! enable && _copy_action && _undo_action)
@@ -2346,17 +2346,17 @@ file_editor::handle_visibility (bool vis
     focus ();
 }
 
 void
 file_editor::dragEnterEvent (QDragEnterEvent *e)
 {
   if (e->mimeData ()->hasUrls ())
     {
-      e->acceptProposedAction();
+      e->acceptProposedAction ();
     }
 }
 
 void
 file_editor::dropEvent (QDropEvent *e)
 {
   if (e->mimeData ()->hasUrls ())
     {
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 // subclassed QTabWidget for usable tab-bar
 class tab_widget : public QTabWidget
 {
   Q_OBJECT
 
 public:
   tab_widget (QWidget *p) : QTabWidget (p) { }
   ~tab_widget () { }
-  QTabBar* tabBar() const { return (QTabWidget::tabBar()); }
+  QTabBar* tabBar () const { return (QTabWidget::tabBar ()); }
 };
 
 class file_editor : public file_editor_interface
 {
   Q_OBJECT
 
 public:
 
@@ -293,18 +293,18 @@ private slots:
   void move_tab_left ();
   void move_tab_right ();
 
   void create_context_menu (QMenu *);
   void edit_status_update (bool, bool);
 
 protected:
 
-  void dragEnterEvent(QDragEnterEvent *event);
-  void dropEvent(QDropEvent *event);
+  void dragEnterEvent (QDragEnterEvent *event);
+  void dropEvent (QDropEvent *event);
 
 private:
 
   bool is_editor_console_tabbed ();
   void construct (void);
   void add_file_editor_tab (file_editor_tab *f, const QString& fn);
   void save_file_as (QWidget *fetabID = 0);
   void mru_menu_update (void);
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -78,29 +78,29 @@ along with Octave; see the file COPYING.
 
 #include "find-dialog.h"
 
 find_dialog::find_dialog (QsciScintilla* edit_area,
                           QList<QAction *> find_actions, QWidget *p)
   : QDialog (p)
 {
   setWindowTitle (tr ("Find and Replace"));
-  setWindowIcon (QIcon(":/actions/icons/find.png"));
+  setWindowIcon (QIcon (":/actions/icons/find.png"));
 
   _search_label = new QLabel (tr ("Find &what:"));
   _search_line_edit = new QLineEdit;
   _search_label->setBuddy (_search_line_edit);
   _replace_label = new QLabel (tr ("Re&place with:"));
   _replace_line_edit = new QLineEdit;
   _replace_label->setBuddy (_replace_line_edit);
 
   _case_check_box = new QCheckBox (tr ("Match &case"));
   _from_start_check_box = new QCheckBox (tr ("Search from &start"));
   _wrap_check_box = new QCheckBox (tr ("&Wrap while searching"));
-  _wrap_check_box->setChecked(true);
+  _wrap_check_box->setChecked (true);
   _find_next_button = new QPushButton (tr ("&Find Next"));
   _find_prev_button = new QPushButton (tr ("Find &Previous"));
   _replace_button = new QPushButton (tr ("&Replace"));
   _replace_all_button = new QPushButton (tr ("Replace &All"));
 
   _more_button = new QPushButton (tr ("&More..."));
   _more_button->setCheckable (true);
   _more_button->setAutoDefault (false);
@@ -248,24 +248,24 @@ find_dialog::handle_selection_changed (b
 
 // initialize search text with selected text if this is in one single line
 void
 find_dialog::init_search_text ()
 {
   if (_edit_area->hasSelectedText ())
     {
       int lbeg, lend, cbeg, cend;
-      _edit_area->getSelection(&lbeg,&cbeg,&lend,&cend);
+      _edit_area->getSelection (&lbeg,&cbeg,&lend,&cend);
       if (lbeg == lend)
         _search_line_edit->setText (_edit_area->selectedText ());
     }
 
   // set focus to "Find what" and select all text
-  _search_line_edit->setFocus();
-  _search_line_edit->selectAll();
+  _search_line_edit->setFocus ();
+  _search_line_edit->selectAll ();
 
   // Default to "find" next time.
   // Otherwise, it defaults to the last action, which may be "replace all".
   _find_next_button->setDefault (true);
 }
 
 void
 find_dialog::find_next ()
@@ -320,21 +320,21 @@ find_dialog::find (bool forward)
         }
       else if (! do_forward)
         {
           // search from position before search characters text length
           // if search backward on existing results,
           _edit_area->getCursorPosition (&line,&col);
           if (_find_result_available && _edit_area->hasSelectedText ())
             {
-              int currpos = _edit_area->positionFromLineIndex(line,col);
+              int currpos = _edit_area->positionFromLineIndex (line,col);
               currpos -= (_search_line_edit->text ().length ());
               if (currpos < 0)
                 currpos = 0;
-              _edit_area->lineIndexFromPosition(currpos, &line,&col);
+              _edit_area->lineIndexFromPosition (currpos, &line,&col);
             }
         }
     }
 
   if (_edit_area)
     {
       if (_edit_area->hasSelectedText ()
           && _search_selection_check_box->isChecked ())
@@ -423,17 +423,17 @@ find_dialog::replace_all ()
       while (_find_result_available)   // while search string is found
         {
           do_replace ();
           _rep_all++;                                          // inc counter
           find_next ();                                        // find next
         }
 
       QMessageBox msg_box (QMessageBox::Information, tr ("Replace Result"),
-                           tr ("%1 items replaced").arg(_rep_all-1),
+                           tr ("%1 items replaced").arg (_rep_all-1),
                            QMessageBox::Ok, this);
       msg_box.exec ();
 
       _rep_all = 0;
       _find_result_available = false;
 
       if (! _search_selection_check_box->isChecked ())
         _edit_area->setCursorPosition (line,col);
diff --git a/libgui/src/m-editor/marker.cc b/libgui/src/m-editor/marker.cc
--- a/libgui/src/m-editor/marker.cc
+++ b/libgui/src/m-editor/marker.cc
@@ -60,17 +60,17 @@ marker::construct (QsciScintilla *area, 
 }
 
 
 void
 marker::handle_remove_via_original_linenr (int linenr)
 {
   if (_original_linenr == linenr)
     {
-      _edit_area->markerDeleteHandle(_mhandle);
+      _edit_area->markerDeleteHandle (_mhandle);
       delete this;
     }
 }
 
 
 void
 marker::handle_request_remove_via_editor_linenr (int linenr)
 {
@@ -146,17 +146,17 @@ marker::handle_marker_line_deleted (int 
   // of knowing this.  QsciScintilla will place the marker at a
   // different line rather than remove it from the margin.  I (DJS) will
   // lobby for such a signal.
   if (_mhandle == mhandle)
     {
       if (_marker_type == breakpoint || _marker_type == debugger_position)
         {
           int editor_linenr = _edit_area->markerLine (_mhandle);
-          _edit_area->markerDeleteHandle(_mhandle);
+          _edit_area->markerDeleteHandle (_mhandle);
           _marker_type = _marker_type == breakpoint ? unsure_breakpoint
                                                     : unsure_debugger_position;
           _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
         }
     }
 }
 
 
@@ -169,17 +169,17 @@ marker::handle_marker_line_undeleted (in
   // different line rather than remove it from the margin.  I (DJS) will
   // lobby for such a signal.
   if (_mhandle == mhandle)
     {
       if (_marker_type == unsure_breakpoint
           || _marker_type == unsure_debugger_position)
         {
           int editor_linenr = _edit_area->markerLine (_mhandle);
-          _edit_area->markerDeleteHandle(_mhandle);
+          _edit_area->markerDeleteHandle (_mhandle);
           _marker_type = _marker_type == unsure_breakpoint ? breakpoint
                                                            : debugger_position;
           _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
         }
     }
 }
 
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -291,30 +291,30 @@ void
 octave_qscintilla::contextmenu_edit (bool)
 {
   emit context_menu_edit_signal (_word_at_cursor);
 }
 
 void
 octave_qscintilla::contextmenu_run (bool)
 {
-  QStringList commands = selectedText ().split (QRegExp("[\r\n]"),
+  QStringList commands = selectedText ().split (QRegExp ("[\r\n]"),
                                                 QString::SkipEmptyParts);
   for (int i = 0; i < commands.size (); i++)
     emit execute_command_in_terminal_signal (commands.at (i));
 }
 
 // wrappers for dbstop related context menu items
 
 // FIXME: Why can't the data be sent as the argument to the function???
 void
 octave_qscintilla::contextmenu_break_condition (bool)
 {
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  QAction *action = qobject_cast<QAction *>(sender());
+  QAction *action = qobject_cast<QAction *>(sender ());
   QPoint local_pos = action->data ().value<QPoint> ();
 
   // pick point just right of margins, so lineAt doesn't give -1
   int margins = marginWidth (1) + marginWidth (2) + marginWidth (3);
   local_pos = QPoint (margins + 1, local_pos.y ());
 
   emit context_menu_break_condition_signal (lineAt (local_pos));
 #endif
@@ -330,17 +330,17 @@ octave_qscintilla::contextmenu_break_onc
 
 void
 octave_qscintilla::text_changed ()
 {
   emit status_update (isUndoAvailable (), isRedoAvailable ());
 }
 
 // when edit area gets focus update information on undo/redo actions
-void octave_qscintilla::focusInEvent(QFocusEvent *focusEvent)
+void octave_qscintilla::focusInEvent (QFocusEvent *focusEvent)
 {
   emit status_update (isUndoAvailable (), isRedoAvailable ());
 
-  QsciScintilla::focusInEvent(focusEvent);
+  QsciScintilla::focusInEvent (focusEvent);
 }
 
 #endif
 
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -67,17 +67,17 @@ private slots:
 
   void contextmenu_break_condition (bool);
   void contextmenu_break_once (const QPoint&);
 
   void text_changed (void);
 
 protected:
 
-  void focusInEvent(QFocusEvent *focusEvent);
+  void focusInEvent (QFocusEvent *focusEvent);
 
 private:
 
   QString _word_at_cursor;
 
 };
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -395,17 +395,17 @@ main_window::display_release_notes (void
       browser->setText (news);
 
       QVBoxLayout *vlayout = new QVBoxLayout;
       vlayout->addWidget (browser);
 
       release_notes_window->setLayout (vlayout);
       release_notes_window->setWindowTitle (tr ("Octave Release Notes"));
 
-      browser->document()->adjustSize ();
+      browser->document ()->adjustSize ();
 
       // center the window on the screen where octave is running
       QDesktopWidget *m_desktop = QApplication::desktop ();
       int screen = m_desktop->screenNumber (this);  // screen of the main window
       QRect screen_geo = m_desktop->availableGeometry (screen);
       int win_x = screen_geo.width ();        // width of the screen
       int win_y = screen_geo.height ();       // height of the screen
       int reln_x = std::min (720, win_x-80);  // desired width of release notes
@@ -1377,17 +1377,17 @@ main_window::construct (void)
                this, SLOT (prepare_to_exit ()));
       connect (qApp, SIGNAL (aboutToQuit ()),
                shortcut_manager::instance, SLOT (cleanup_instance ()));
       // QSettings are saved upon deletion (i.e., cleanup_instance)
       connect (qApp, SIGNAL (aboutToQuit ()),
                resource_manager::instance, SLOT (cleanup_instance ()));
 
       connect (qApp, SIGNAL (focusChanged (QWidget*, QWidget*)),
-               this, SLOT(focus_changed (QWidget*, QWidget*)));
+               this, SLOT (focus_changed (QWidget*, QWidget*)));
 
       connect (this, SIGNAL (settings_changed (const QSettings *)),
                this, SLOT (notice_settings (const QSettings *)));
 
       connect (this, SIGNAL (editor_focus_changed (bool)),
                this, SLOT (disable_menu_shortcuts (bool)));
 
       connect (this, SIGNAL (editor_focus_changed (bool)),
@@ -1676,19 +1676,19 @@ main_window::add_action (QMenu *menu, co
   addAction (a);  // important for shortcut context
   a->setShortcutContext (Qt::ApplicationShortcut);
   return a;
 }
 
 void
 main_window::disable_menu_shortcuts (bool disable)
 {
-  QHash<QMenu*, QStringList>::const_iterator i = _hash_menu_text.constBegin();
-
-  while (i != _hash_menu_text.constEnd())
+  QHash<QMenu*, QStringList>::const_iterator i = _hash_menu_text.constBegin ();
+
+  while (i != _hash_menu_text.constEnd ())
     {
       i.key ()->setTitle (i.value ().at (disable));
       ++i;
     }
 }
 
 QMenu*
 main_window::m_add_menu (QMenuBar *p, QString name)
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -457,17 +457,17 @@ octave_dock_widget::handle_settings (con
   else
     _icon_color_active = "";
 
   notice_settings (settings);  // call individual handler
 
   set_style (false);
 }
 
-bool octave_dock_widget::eventFilter(QObject *obj, QEvent *e)
+bool octave_dock_widget::eventFilter (QObject *obj, QEvent *e)
 {
   if (e->type () == QEvent::NonClientAreaMouseButtonDblClick)
     {
       e->ignore (); // ignore double clicks into window decoration elements
       return true;
     }
 
   return QDockWidget::eventFilter (obj,e);
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -96,17 +96,17 @@ protected slots:
   /** slots to handle copy & paste */
   virtual void copyClipboard () {  }
   virtual void pasteClipboard () {  }
   virtual void selectAll () {  }
   /** slots to handle undo */
   virtual void do_undo () {  }
 
   // event filter for double clicks into the window decoration elements
-  bool eventFilter(QObject *obj, QEvent *e);
+  bool eventFilter (QObject *obj, QEvent *e);
 
 private slots:
 
   void change_floating (bool);
   void change_visibility (bool);
 
 private:
 
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -160,17 +160,17 @@ namespace octave
 #endif
 
 #if defined (HAVE_QT4)
     QTextCodec::setCodecForCStrings (QTextCodec::codecForName ("UTF-8"));
 #endif
 
     // set windows style for windows
 #if defined (Q_OS_WIN32)
-    qt_app.setStyle(QStyleFactory::create("Windows"));
+    qt_app.setStyle (QStyleFactory::create ("Windows"));
 #endif
 
     bool start_gui = start_gui_p ();
 
     // Show welcome wizard if this is the first run.
 
     if (resource_manager::is_first_run () && start_gui)
       {
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "procstream.h"
 #include <QFileInfo>
 #include <QDir>
 #include <QFile>
 #include <QUrl>
 #include <QRegExp>
 #include <QBuffer>
 
-parser::parser(QObject *p)
+parser::parser (QObject *p)
   : QObject(p)
 {
   _compressors_map.insert ("bz2",  "bzip2 -dc \"%1\"");
   _compressors_map.insert ("gz",   "gzip -dc \"%1\"");
   _compressors_map.insert ("lzma", "lzma -dc \"%1\"");
   _compressors_map.insert ("xz",   "xz -dc \"%1\"");
   _compressors_map.insert ("Z",    "gunzip -c \"%1\"");
 }
@@ -173,17 +173,17 @@ parser::search_node (const QString& node
       if (! io)
         {
           return QString ();
         }
 
       seek (io, realPos);
 
       QString text = get_next_node (io);
-      if (! text.isEmpty())
+      if (! text.isEmpty ())
         {
           return text;
         }
 
       io->close ();
       delete io;
     }
 
@@ -223,17 +223,17 @@ parser::get_next_node (QIODevice *io)
           line = io->readLine ();
         }
       else
         {
           // 0 was read -> image -> text length changes
           line_buffer = io->readLine ();  // image tag that is not needed
           line = io->readLine ();         // firsts line of text message
           for (i=1; i<line_buffer.size ()+6; i++)  // correct the size
-            line.insert (line.size ()-1,QByteArray(" "));   // by adding blanks
+            line.insert (line.size ()-1,QByteArray (" "));  // by adding blanks
         }
 
       if (line.at (0) == '"' && line.size () == 5)  // end of image construct
         line = " ";
 
       if (line.at(0) == 31)
         {
           break;
@@ -314,36 +314,36 @@ replace_links (QString& text)
       QString url_link = re.cap (4);
       QString term     = re.cap (5);
 
       if (url_link.isEmpty ())
         {
           url_link = note;
         }
 
-      term.replace(":","");
-      note.replace(":","");
+      term.replace (":","");
+      note.replace (":","");
       note.replace (QRegExp ("`([^']+)'"),"\\1");   // no extra format in links
 
       QRegExp re_break ("(\n[ ]*)");
 
       if (note == "fig" || note == "tab")
-        url_link.prepend("#");
+        url_link.prepend ("#");
 
       QString href;
       if (type == "\n*")
         href="\n";
 
       if (re_break.indexIn (url_link) != -1)
         term += re_break.cap (1);
       else if (re_break.indexIn (re.cap (2)) != -1)
         href = re_break.cap (1) + " ";
       else if (re_break.indexIn (note) != -1)
         term += re_break.cap (1);
-      note.replace(re_break,"&nbsp;");
+      note.replace (re_break,"&nbsp;");
 
       url_link = url_link.trimmed ();
       url_link.replace ("\n"," ");
       url_link.replace (QRegExp ("  +")," ");
       url_link.replace ("<b>","");
       url_link.replace ("</b>","");
 
       href += "<font style=\"color:DarkGray; font-weight:bold;\">&raquo;</font>";
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -95,20 +95,20 @@ private:
   QString search_node (const QString& node, QIODevice * io);
   QString get_next_node (QIODevice * io);
   QString get_node_name (const QString& text);
   QString get_node_up (const QString& text);
   QString get_node_next (const QString& text);
   QString get_node_prev (const QString& text);
 
   /** Parses info files and gets map of node positions.*/
-  void parse_info_map();
+  void parse_info_map ();
 
   /** Open info files and uncompress them. */
-  QIODevice *open_file(QFileInfo & fileInfo);
+  QIODevice *open_file (QFileInfo & fileInfo);
 
   /** Calculates real position of nodes.
     * @param pos position from info file.
     * @param fileInfo returns file what contains that position.
     * @param realPos returns real position inside of fileInfo.
     */
   void real_position (int pos, QFileInfo & file_info, int & real_pos);
 
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -72,17 +72,17 @@ webinfo::webinfo (QWidget *p)
   hbox_layout->addWidget (_zoom_out_button);
 
   _stacked_widget = new QStackedWidget (this);
   vbox_layout->addWidget (_stacked_widget);
 
   hbox_layout = new QHBoxLayout ();
   vbox_layout->addLayout (hbox_layout);
 
-  _search_line_edit = new QLineEdit(this);
+  _search_line_edit = new QLineEdit (this);
 #if defined (HAVE_SETPLACEHOLDERTEXT)
   _search_line_edit->setPlaceholderText (
     tr ("Type here and press \'Return\' to search"));
 #endif
   hbox_layout->addWidget (_search_line_edit);
 
   _search_check_box = new QCheckBox (tr ("Global search"));
   hbox_layout->addWidget (_search_check_box);
@@ -102,17 +102,17 @@ webinfo::webinfo (QWidget *p)
       // Info file does not exist
       _search_check_box->setEnabled (false);
       _search_line_edit->setEnabled (false);
 
       QTextBrowser *msg = addNewTab (tr ("Error"));
       QString msg_text = QString (
           "<html><body><br><br><center><b>%1</b></center></body></html>").
           arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
-          arg(QString::fromStdString (Vinfo_file)));
+          arg (QString::fromStdString (Vinfo_file)));
       msg->setHtml (msg_text);
     }
 }
 
 bool
 webinfo::set_info_path (const QString& info_path)
 {
   if (_parser.set_info_path (info_path))
@@ -124,17 +124,17 @@ webinfo::set_info_path (const QString& i
     return false;
 }
 
 void
 webinfo::load_node (const QString& node_name)
 {
   // no XREF in the tabs
   QString tab_text = node_name;
-  tab_text.replace("XREF","");
+  tab_text.replace ("XREF","");
 
   //Check if node has been already opened.
   for (int i = 0; i < _tab_bar->count (); i++)
     {
       if (tab_text == _tab_bar->tabText (i))
         {
           _tab_bar->setCurrentIndex (i);
           return;
@@ -180,18 +180,18 @@ QTextBrowser *
 webinfo::addNewTab (const QString& name)
 {
   _text_browser = new QTextBrowser (this);
   _text_browser->setOpenLinks (false);
   _text_browser->show ();
 
   connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this,
            SLOT (link_clicked (const QUrl &)));
-  disconnect(_tab_bar, SIGNAL (currentChanged(int)), this,
-             SLOT (current_tab_changed (int)));
+  disconnect (_tab_bar, SIGNAL (currentChanged (int)), this,
+              SLOT (current_tab_changed (int)));
 
   int ns = _stacked_widget->addWidget (_text_browser);
   _stacked_widget->setCurrentIndex (ns);
 
   int nt = _tab_bar->addTab (name);
   _tab_bar->setCurrentIndex (nt);
   QVariant tab_data;
   tab_data.setValue (static_cast<void*> (_text_browser));
@@ -227,21 +227,21 @@ webinfo::load_ref (const QString &ref_na
   QString text = _parser.find_ref (ref_name);
   if (text.length () > 0)
     {
       load_node (text);
     }
   else
     {
       // not found
-      load_node("Top");
+      load_node ("Top");
     }
 
   if (_text_browser)
-    _text_browser->setFocus();
+    _text_browser->setFocus ();
 }
 
 void
 webinfo::search ()
 {
   if (_search_line_edit->text ().trimmed ().isEmpty ())
     return;   // do nothing if search field is empty or only has whitespaces
 
@@ -257,24 +257,24 @@ webinfo::search ()
       // Local search
       _text_browser->find (_search_line_edit->text ());
     }
 }
 
 void
 webinfo::zoom_in ()
 {
-  _font_web.setPointSize (_font_web.pointSize() + 1);
+  _font_web.setPointSize (_font_web.pointSize () + 1);
   _text_browser->setFont (_font_web);
 }
 
 void
 webinfo::zoom_out ()
 {
-  _font_web.setPointSize (_font_web.pointSize() - 1);
+  _font_web.setPointSize (_font_web.pointSize () - 1);
   _text_browser->setFont (_font_web);
 }
 
 void
 webinfo::copyClipboard ()
 {
   if (_search_line_edit->hasFocus () && _search_line_edit->hasSelectedText ())
     {
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -269,17 +269,17 @@ settings_dialog::settings_dialog (QWidge
       QMessageBox msgBox (QMessageBox::Warning, tr ("Octave Settings"),
                           tr ("Unable to save settings.  Missing settings "
                               "file or unknown directory."));
       msgBox.exec ();
       return;
     }
 
   // restore last geometry
-  restoreGeometry (settings->value("settings/geometry").toByteArray ());
+  restoreGeometry (settings->value ("settings/geometry").toByteArray ());
 
   // look for available language files and the actual settings
   QString qm_dir_name = resource_manager::get_gui_translation_dir ();
   QDir qm_dir (qm_dir_name);
   QFileInfoList qm_files = qm_dir.entryInfoList (QStringList ("*.qm"),
                                                  QDir::Files | QDir::Readable,
                                                  QDir::Name);
   for (int i = 0; i < qm_files.length (); i++)   // insert available languages
@@ -996,17 +996,17 @@ settings_dialog::button_clicked (QAbstra
   if (button_role == QDialogButtonBox::RejectRole ||
       button_role == QDialogButtonBox::AcceptRole)
     close ();
 }
 
 void
 settings_dialog::get_dir (QLineEdit *line_edit, const QString& title)
 {
-  QString dir = QFileDialog::getExistingDirectory(this,
+  QString dir = QFileDialog::getExistingDirectory (this,
                 title, line_edit->text (),
                 QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
   line_edit->setText (dir);
 }
 
 void
 settings_dialog::get_octave_dir ()
 {
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -419,17 +419,17 @@ shortcut_manager::do_fill_treewidget (QT
 
   connect (tree_view, SIGNAL (itemDoubleClicked (QTreeWidgetItem*, int)),
            this, SLOT (handle_double_clicked (QTreeWidgetItem*, int)));
 
   for (int i = 0; i < _sc.count (); i++)
     {
       shortcut_t sc = _sc.at (i);
 
-      QTreeWidgetItem* section = _level_hash[sc.settings_key.section(':',0,0)];
+      QTreeWidgetItem* section = _level_hash[sc.settings_key.section (':',0,0)];
       QTreeWidgetItem* tree_item = new QTreeWidgetItem (section);
 
       // set a slightly transparent foreground for default columns
       QColor fg = QColor (tree_item->foreground (1).color ());
       fg.setAlpha (128);
       tree_item->setForeground (1, QBrush (fg));
 
       // write the shortcuts
@@ -502,30 +502,30 @@ void
 shortcut_manager::shortcut_dialog (int index)
 {
   if (! _dialog)
     {
       _dialog = new QDialog (this);
 
       _dialog->setWindowTitle (tr ("Enter new Shortcut"));
 
-      QVBoxLayout *box = new QVBoxLayout(_dialog);
+      QVBoxLayout *box = new QVBoxLayout (_dialog);
 
       QLabel *help = new QLabel (tr ("Apply the desired shortcut or click "
                                      "on the right button to reset the "
                                      "shortcut to its default."));
       help->setWordWrap (true);
       box->addWidget (help);
 
       QCheckBox *direct = new QCheckBox (
         tr ("Enter shortcut directly by performing it"));
       direct->setCheckState (Qt::Checked);
       box->addWidget (direct);
 
-      QGridLayout *grid = new QGridLayout();
+      QGridLayout *grid = new QGridLayout ();
 
       QLabel *actual = new QLabel (tr ("Actual shortcut"));
       _edit_actual = new enter_shortcut (_dialog);
       _edit_actual->setAlignment (Qt::AlignHCenter);
       grid->addWidget (actual, 0, 0);
       grid->addWidget (_edit_actual, 0, 1);
 
       QLabel *def = new QLabel (tr ("Default shortcut"));
@@ -541,18 +541,18 @@ shortcut_manager::shortcut_dialog (int i
 
       box->addLayout (grid);
 
       QDialogButtonBox *button_box = new QDialogButtonBox (QDialogButtonBox::Ok
                                                    | QDialogButtonBox::Cancel);
       QList<QAbstractButton *> buttons = button_box->buttons ();
       for (int i = 0; i < buttons.count (); i++)
         buttons.at (i)->setShortcut (QKeySequence ());
-      connect(button_box, SIGNAL (accepted ()), _dialog, SLOT (accept ()));
-      connect(button_box, SIGNAL (rejected ()), _dialog, SLOT (reject ()));
+      connect (button_box, SIGNAL (accepted ()), _dialog, SLOT (accept ()));
+      connect (button_box, SIGNAL (rejected ()), _dialog, SLOT (reject ()));
       box->addWidget (button_box);
 
       _dialog->setLayout (box);
 
       connect (direct, SIGNAL (stateChanged (int)),
                _edit_actual, SLOT (handle_direct_shortcut (int)));
       connect (_dialog, SIGNAL (finished (int)),
                this, SLOT (shortcut_dialog_finished (int)));
@@ -570,26 +570,26 @@ shortcut_manager::shortcut_dialog (int i
 
 void
 shortcut_manager::shortcut_dialog_finished (int result)
 {
   if (result == QDialog::Rejected)
     return;
 
   // check for duplicate
-  int double_index = _shortcut_hash[_edit_actual->text()] - 1;
+  int double_index = _shortcut_hash[_edit_actual->text ()] - 1;
 
   if (double_index >= 0 && double_index != _handled_index)
     {
-      int ret = QMessageBox::warning(this, tr("Double Shortcut"),
+      int ret = QMessageBox::warning (this, tr ("Double Shortcut"),
                   tr ("The chosen shortcut\n  \"%1\"\n"
                       "is already used for the action\n  \"%2\".\n"
                       "Do you want to use the shortcut anyhow removing it "
                       "from the previous action?")
-                     .arg (_edit_actual->text())
+                     .arg (_edit_actual->text ())
                      .arg (_sc.at (double_index).description),
                   QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
 
       if (ret == QMessageBox::Yes)
         {
           shortcut_t double_shortcut = _sc.at (double_index);
           double_shortcut.actual_sc = QKeySequence ();
           _sc.replace (double_index, double_shortcut);
@@ -597,17 +597,17 @@ shortcut_manager::shortcut_dialog_finish
         }
       else
         return;
     }
 
   shortcut_t shortcut = _sc.at (_handled_index);
   if (! shortcut.actual_sc.isEmpty ())
     _shortcut_hash.remove (shortcut.actual_sc.toString ());
-  shortcut.actual_sc = _edit_actual->text();
+  shortcut.actual_sc = _edit_actual->text ();
   _sc.replace (_handled_index, shortcut);
 
   _index_item_hash[_handled_index]->setText (2, shortcut.actual_sc.toString ());
 
   if (! shortcut.actual_sc.isEmpty ())
     _shortcut_hash[shortcut.actual_sc.toString ()] = _handled_index + 1;
 }
 
@@ -643,24 +643,24 @@ shortcut_manager::import_shortcuts (QSet
 }
 
 // ask the user whether to save the current shortcut set;
 // returns true to proceed with import action, false to abort it
 bool
 shortcut_manager::overwrite_all_shortcuts ()
 {
   QMessageBox msg_box;
-  msg_box.setWindowTitle(tr ("Overwriting Shortcuts"));
+  msg_box.setWindowTitle (tr ("Overwriting Shortcuts"));
   msg_box.setIcon (QMessageBox::Warning);
-  msg_box.setText(tr ("You are about to overwrite all shortcuts.\n"
+  msg_box.setText (tr ("You are about to overwrite all shortcuts.\n"
      "Would you like to save the current shortcut set or cancel the action?"));
-  msg_box.setStandardButtons(QMessageBox::Save | QMessageBox::Cancel);
+  msg_box.setStandardButtons (QMessageBox::Save | QMessageBox::Cancel);
   QPushButton *discard = msg_box.addButton (tr ("Don't save"),
                                             QMessageBox::DestructiveRole);
-  msg_box.setDefaultButton(QMessageBox::Save);
+  msg_box.setDefaultButton (QMessageBox::Save);
 
   int ret = msg_box.exec ();
 
   if (msg_box.clickedButton () == discard)
     return true;  // do not save and go ahead
 
   if (ret == QMessageBox::Save)
     {
@@ -771,11 +771,11 @@ enter_shortcut::keyPressEvent (QKeyEvent
         key += Qt::SHIFT;
       if (modifiers & Qt::ControlModifier)
         key += Qt::CTRL;
       if (modifiers & Qt::AltModifier)
         key += Qt::ALT;
       if (modifiers & Qt::MetaModifier)
         key += Qt::META;
 
-      setText (QKeySequence(key).toString ());
+      setText (QKeySequence (key).toString ());
     }
 }
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -281,17 +281,17 @@ welcome_wizard::welcome_wizard (QWidget 
   setEnabled (true);
   resize (600, 480);
   setMinimumSize (QSize (600, 480));
 
   show_page ();
 
 #if defined (OCTAVE_USE_WINDOWS_API)
   // HACK to forceshow of dialog if started minimized
-  ShowWindow((HWND)winId(), SW_SHOWNORMAL);
+  ShowWindow ((HWND)winId (), SW_SHOWNORMAL);
 #endif
 }
 
 void
 welcome_wizard::handle_web_connect_option (int state)
 {
   allow_web_connect_state = state == Qt::Checked;
 }
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -89,17 +89,17 @@ workspace_view::workspace_view (QWidget 
   QVBoxLayout *ws_layout = new QVBoxLayout ();
   ws_layout->addWidget (_filter_widget);
   ws_layout->addWidget (view);
 
   QSettings *settings = resource_manager::get_settings ();
 
   if (settings)
     {
-      _filter_shown = settings->value ("workspaceview/filter_shown",true).toBool();
+      _filter_shown = settings->value ("workspaceview/filter_shown",true).toBool ();
       _filter_widget->setVisible (_filter_shown);
 
       ws_layout->setMargin (2);
 
       // Set the empty widget to have our layout.
       widget ()->setLayout (ws_layout);
 
       // Initialize collapse/expand state of the workspace subcategories.
@@ -260,17 +260,17 @@ workspace_view::header_contextmenu_reque
   _sig_mapper = new QSignalMapper (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
   for (int i = 0; i < _columns_shown.size (); i++)
     {
       QAction *action = menu.addAction (_columns_shown.at (i),
                                         _sig_mapper, SLOT (map ()));
-      _sig_mapper->setMapping(action, i);
+      _sig_mapper->setMapping (action, i);
       action->setCheckable (true);
       action->setChecked (
             settings->value (_columns_shown_keys.at (i),true).toBool ());
     }
 
   connect (_sig_mapper, SIGNAL (mapped (int)), this, SLOT (toggle_header (int)));
 
   menu.exec (view->mapToGlobal (mpos));
