# HG changeset patch
# User jwe
# Date 947752336 0
#      Thu Jan 13 08:32:16 2000 +0000
# Node ID 8625164a0a398808ce4851289f21313122ce1861
# Parent  61e40232a4e8cba6eddbd41ac9b0eed7888a17a0
[project @ 2000-01-13 08:31:37 by jwe]

diff --git a/scripts/control/DEMOcontrol.m b/scripts/control/DEMOcontrol.m
--- a/scripts/control/DEMOcontrol.m
+++ b/scripts/control/DEMOcontrol.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } DEMOcontrol 
+## @deftypefn {Function File} {} DEMOcontrol
 ## Octave Control Systems Toolbox demo/tutorial program.  The demo
 ## allows the user to select among several categories of OCST function:
 ## @example
 ## @group
 ## octave:1> DEMOcontrol
-##  O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X
+## O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X
 ## Octave Controls System Toolbox Demo
 ##
 ##   [ 1] System representation
-##   [ 2] Block diagram manipulations 
-##   [ 3] Frequency response functions 
-##   [ 4] State space analysis functions 
-##   [ 5] Root locus functions 
-##   [ 6] LQG/H2/Hinfinity functions 
+##   [ 2] Block diagram manipulations
+##   [ 3] Frequency response functions
+##   [ 4] State space analysis functions
+##   [ 5] Root locus functions
+##   [ 6] LQG/H2/Hinfinity functions
 ##   [ 7] End
 ## @end group
 ## @end example
 ## Command examples are interactively run for users to observe the use
 ## of OCST functions.
 ## @end deftypefn
-## @seealso{Demo Programs: bddemo.m, frdemo.m, analdemo.m, 
+## @seealso{Demo Programs: bddemo.m, frdemo.m, analdemo.m,
 ## moddmeo.m, rldemo.m}
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function DEMOcontrol ()
 
   puts ("O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X")
@@ -51,24 +51,24 @@ function DEMOcontrol ()
   while (1)
 
     clc ();
 
     k = 0;
 
     while (k > 8 || k < 1),
       k = menu ("Octave Controls System Toolbox Demo",
-		"System representation",
-    		"Block diagram manipulations",
-    		"Frequency response functions",
-    		"State space analysis functions",
-    		"System model manipulations",
-    		"Root locus functions",
-		"LQG/H2/Hinfinity functions",
-    		"End");
+                "System representation",
+                "Block diagram manipulations",
+                "Frequency response functions",
+                "State space analysis functions",
+                "System model manipulations",
+                "Root locus functions",
+                "LQG/H2/Hinfinity functions",
+                "End");
     endwhile
 
     switch (k)
       case (1) sysrepdemo ();
       case (2) bddemo ();
       case (3) frdemo ();
       case (4) analdemo ();
       case (5) moddemo ();
diff --git a/scripts/control/abcddim.m b/scripts/control/abcddim.m
--- a/scripts/control/abcddim.m
+++ b/scripts/control/abcddim.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{n}, @var{m}, @var{p}] =} abcddim (@var{a}, @var{b}, @var{c}, @var{d})
 ## Check for compatibility of the dimensions of the matrices defining
 ## the linear system
@@ -27,42 +27,42 @@
 ## \eqalign{
 ##  {dx\over dt} &= A x + B u\cr
 ##             y &= C x + D u}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## [A, B, C, D] corresponding to
-## 
+##
 ## @example
 ## dx/dt = a x + b u
 ## y = c x + d u
 ## @end example
-## 
+##
 ## @end ifinfo
 ## or a similar discrete-time system.
-## 
+##
 ## If the matrices are compatibly dimensioned, then @code{abcddim} returns
-## 
+##
 ## @table @var
 ## @item n
 ## The number of system states.
-## 
+##
 ## @item m
 ## The number of system inputs.
-## 
+##
 ## @item p
 ## The number of system outputs.
 ## @end table
-## 
+##
 ## Otherwise @code{abcddim} returns @var{n} = @var{m} = @var{p} = @minus{}1.
-## 
+##
 ## Note: n = 0 (pure gain block) is returned without warning.
-## 
+##
 ## @end deftypefn
 ## @seealso{is_abcd}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993.
 ## a s hodel: modified to accept pure-gain systems aug 1996
 
 function [n, m, p] = abcddim (a, b, c, d)
@@ -90,38 +90,38 @@ function [n, m, p] = abcddim (a, b, c, d
       " and b(",num2str(bn),"x",num2str(bm),") are not compatible"]);
     return
   endif
 
   if( (cn == 0) & (dn == 0 ) )
     warning("abcddim: no outputs");
   elseif (cm != an)
     warning (["abcddim: a(",num2str(an),"x",num2str(am), ...
-	" and c(",num2str(cn),"x",num2str(cm),") are not compatible"]);
+        " and c(",num2str(cn),"x",num2str(cm),") are not compatible"]);
     return
   endif
 
   have_connections = (bn*cn != 0);
 
   if( (dn == 0) & have_connections)
     warning("abcddim: empty d matrix passed; setting compatibly with b, c");
     [d,dn,dm] = abcddims(zeros(cn,bm));
   endif
 
   if(an > 0)
     [dn, dm] = size(d);
     if ( (cn != dn) & have_connections )
       warning (["abcddim: c(",num2str(cn),"x",num2str(cm), ...
-	" and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
+        " and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
       return
     endif
 
     if ( (bm != dm) & have_connections )
       warning (["abcddim: b(",num2str(bn),"x",num2str(bm), ...
-	  " and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
+          " and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
       return
     endif
 
     m = bm;
     p = cn;
   else
     [p,m] = size(d);
   endif
diff --git a/scripts/control/abcddims.m b/scripts/control/abcddims.m
--- a/scripts/control/abcddims.m
+++ b/scripts/control/abcddims.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1997 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{y}, @var{my}, @var{ny}] =} abcddims (@var{x})
-## 
-## Used internally in @code{abcddim}.  If @var{x} is a zero-size matrix, 
-## both dimensions are set to 0 in @var{y}.  
+## @deftypefn {Function File} {[@var{y}, @var{my}, @var{ny}] =} abcddims (@var{x})
+##
+## Used internally in @code{abcddim}.  If @var{x} is a zero-size matrix,
+## both dimensions are set to 0 in @var{y}.
 ## @var{my} and @var{ny} are the row and column dimensions of the result.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: February 1997
 
 function [y, my, ny] = abcddims (x)
 
diff --git a/scripts/control/analdemo.m b/scripts/control/analdemo.m
--- a/scripts/control/analdemo.m
+++ b/scripts/control/analdemo.m
@@ -1,57 +1,57 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } analdemo ( ) 
-##  Octave Controls toolbox demo: State Space analysis demo
+## @deftypefn {Function File} {} analdemo ()
+## Octave Controls toolbox demo: State Space analysis demo
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Updated by John Ingram December 1996
 
 function analdemo ()
-  
+
   while (1)
     clc
     k=0;
     while(k > 8 || k < 1)
       k = menu("Octave State Space Analysis Demo", ...
         "System grammians (gram, dgram)", ...
         "System zeros (tzero)", ...
         "Continuous => Discrete and Discrete => Continuous conversions (c2d,d2c)", ...
-	"Algebraic Riccati Equation (are, dare)", ...
-  	"Balanced realizations (balreal, dbalreal)", ...
-  	"Open loop truncations via Hankel singular values (balreal, dbalreal)", ...
+        "Algebraic Riccati Equation (are, dare)", ...
+        "Balanced realizations (balreal, dbalreal)", ...
+        "Open loop truncations via Hankel singular values (balreal, dbalreal)", ...
         "SISO pole placement", ...
         "Return to main demo menu");
     endwhile
     if (k == 1)
       clc
       help dgram
       prompt
 
-      clc 
+      clc
       disp("System Grammians: (see Moore, IEEE T-AC, 1981) \n");
       disp("Example #1, consider the discrete time state space system:\n");
       a=[1, 5, -8.4; 1.2, -3, 5; 1, 7, 9]
       b=[1, 5; 2, 6; -4.4, 5]
       c=[1, -1.5, 2; 6, -9.8, 1]
       d=0
       prompt
       disp("\nThe discrete controllability grammian is computed as follows:");
@@ -83,17 +83,17 @@ function analdemo ()
       grammian = gram(a,b)
       disp("Variable Description:\n");
       disp("grammian => continuous controllability grammian");
       disp("a, b => a and b matrices of continuous time system\n");
       disp("A dual approach may be used to compute the observability grammian.");
       prompt
       clc
 
-      
+
     elseif (k == 2)
       clc
       help tzero
       prompt
 
       disp("System zeros (tzero) example\n");
       disp("Example #1, consider the state space system:\n");
       a=[0, 1, 0; -10, -2, 0; -10, 0, -8]
@@ -233,11 +233,11 @@ function analdemo ()
       cmd = "[A,B] = sys2ss(sys);";
       run_cmd
       cmd = "poles=eig(A-B*K)";
       run_cmd
       prompt
     elseif (k == 8)
       return
     endif
-  endwhile  
+  endwhile
 endfunction
 
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} are (@var{a}, @var{b}, @var{c}, @var{opt})
 ## Solve the algebraic Riccati equation
 ## @iftex
@@ -26,58 +26,58 @@
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @example
 ## a' * x + x * a - x * b * x + c = 0
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @strong{Inputs}
 ## @noindent
-## for identically dimensioned square matrices 
+## for identically dimensioned square matrices
 ## @table @var
 ## @item a
 ## @var{n}x@var{n} matrix.
 ## @item b
 ##   @var{n}x@var{n} matrix or @var{n}x@var{m} matrix; in the latter case
 ##   @var{b} is replaced by @math{b:=b*b'}.
 ## @item c
 ##   @var{n}x@var{n} matrix or @var{p}x@var{m} matrix; in the latter case
 ##   @var{c} is replaced by @math{c:=c'*c}.
 ## @item opt
 ## (optional argument; default = @code{"B"}):
 ## String option passed to @code{balance} prior to ordered Schur decomposition.
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @var{x}: solution of the ARE.
-## 
+##
 ## @strong{Method}
 ## Laub's Schur method (IEEE Transactions on
 ## Automatic Control, 1979) is applied to the appropriate Hamiltonian
 ## matrix.
-## 
+##
 ## @end deftypefn
 ## @seealso{balance and dare}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = are (a, b, c, opt)
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
       if (! (strcmp (opt, "N") || strcmp (opt, "P") ...
-	     || strcmp (opt, "S") || strcmp (opt, "B") ...
-	     || strcmp (opt, "n") || strcmp (opt, "p") ...
-	     || strcmp (opt, "s") || strcmp (opt, "b")))
-	warning ("are: opt has an invalid value; setting to B");
-	opt = "B";
+             || strcmp (opt, "S") || strcmp (opt, "B") ...
+             || strcmp (opt, "n") || strcmp (opt, "p") ...
+             || strcmp (opt, "s") || strcmp (opt, "b")))
+        warning ("are: opt has an invalid value; setting to B");
+        opt = "B";
       endif
     else
       opt = "B";
     endif
     if ((n = is_square(a)) == 0)
       error ("are: a is not square");
     endif
 
@@ -98,17 +98,17 @@ function x = are (a, b, c, opt)
     if (n != m || n != p)
       error ("are: a, b, c not conformably dimensioned.");
     endif
 
 ## Should check for controllability/observability here
 ## use Boley-Golub (Syst. Contr. Letters, 1984) method, not the
 ##
 ##                     n-1
-## rank ([ B A*B ... A^   *B]) method 
+## rank ([ B A*B ... A^   *B]) method
 
     [d, h] = balance ([a, -b; -c, -a'], opt);
     [u, s] = schur (h, "A");
     u = d * u;
     n1 = n + 1;
     n2 = 2 * n;
     x = u (n1:n2, 1:n) / u (1:n, 1:n);
   else
diff --git a/scripts/control/axis2dlim.m b/scripts/control/axis2dlim.m
--- a/scripts/control/axis2dlim.m
+++ b/scripts/control/axis2dlim.m
@@ -1,37 +1,37 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn{Function File } { @var{axvec} =} axis2dlim (@var{axdata})
-##  determine axis limits for 2-d data(column vectors); leaves a 10% margin 
-##  around the plots.
-##  puts in margins of +/- 0.1 if data is one dimensional (or a single point)
-## 
+## @deftypefn{Function File} {@var{axvec} =} axis2dlim (@var{axdata})
+## determine axis limits for 2-d data(column vectors); leaves a 10% margin
+## around the plots.
+## puts in margins of +/- 0.1 if data is one dimensional (or a single point)
+##
 ## @strong{Inputs}
-##    @var{axdata} nx2 matrix of data [x,y]
-## 
+## @var{axdata} nx2 matrix of data [x,y]
+##
 ## @strong{Outputs}
-##    @var{axvec} vector of axis limits appropriate for call to axis() function
+## @var{axvec} vector of axis limits appropriate for call to axis() function
 ## @end deftypefn
 
 function axvec = axis2dlim (axdata)
 
   if(isempty(axdata))
     axdata = 0;
   endif
 
@@ -53,11 +53,11 @@ function axvec = axis2dlim (axdata)
     ## they're at least one-dimensional
     if(delv(1) != 0)
       axdel(1:2) = 1.1*[-delv(1),delv(1)];
     endif
     if(delv(2) != 0)
       axdel(3:4) = 1.1*[-delv(2),delv(2)];
     endif
   endif
-  axvec = axmid + axdel; 
+  axvec = axmid + axdel;
 endfunction
 
diff --git a/scripts/control/bddemo.m b/scripts/control/bddemo.m
--- a/scripts/control/bddemo.m
+++ b/scripts/control/bddemo.m
@@ -1,59 +1,59 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} bddemo ( inputs ) 
-##  Octave Controls toolbox demo: Block Diagram Manipulations demo
+## @deftypefn {Function File} {@var{outputs} =} bddemo (@var{inputs})
+## Octave Controls toolbox demo: Block Diagram Manipulations demo
 ## @end deftypefn
- 
+
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Modified by A S Hodel Summer-Fall 1996
 
 function bddemo ()
 
   sav_page = page_screen_output;
   page_screen_output = 1;
 
   while (1)
     clc
     k=0;
     while(k > 14 || k < 1)
       k = menu("Octave Block Diagram Manipulations Demo", ...
-  	"sysadd/syssub: F(s) = G(s) +/- H(s)", ...
- 	"sysappend: add new inputs/outputs", ...
-	"syssetsignals: change names of inputs, outputs, and/or states", ...
-	"sysconnect: connect specified system inputs/outputs", ...
-	"syscont/sysdisc: extract the continuous (discrete) part of a system", ...
-	"sysdup: duplicate specified inputs/outputs", ...
-	"sysgroup: group two systems into a single system,", ...
-	"sysmult: F(s) = G(s)*H(s) (series connection)", ...
-	"sysprune: keep only specified inputs/outputs", ...
-	"sysscale: scale inputs/outputs by specified gain matrices", ...
-	"parallel: parallel connection of two systems", ...
-	"buildssic: the combination of all", ...
-	"Design examples:", ...
-	"Return to main demo menu");
+        "sysadd/syssub: F(s) = G(s) +/- H(s)", ...
+        "sysappend: add new inputs/outputs", ...
+        "syssetsignals: change names of inputs, outputs, and/or states", ...
+        "sysconnect: connect specified system inputs/outputs", ...
+        "syscont/sysdisc: extract the continuous (discrete) part of a system", ...
+        "sysdup: duplicate specified inputs/outputs", ...
+        "sysgroup: group two systems into a single system,", ...
+        "sysmult: F(s) = G(s)*H(s) (series connection)", ...
+        "sysprune: keep only specified inputs/outputs", ...
+        "sysscale: scale inputs/outputs by specified gain matrices", ...
+        "parallel: parallel connection of two systems", ...
+        "buildssic: the combination of all", ...
+        "Design examples:", ...
+        "Return to main demo menu");
     endwhile
     if (k == 1)
       clc
       disp("sysadd: add two systems together")
       disp("syssub: subtract F = G - H")
       prompt
       help sysadd
       prompt
@@ -169,17 +169,17 @@ function bddemo ()
       sysout(dsys);
       disp("sysdisc returns dsys=empty since sys has no discrete outputs.");
       prompt
       disp("Example block diagram 2:")
       sys1 = tf2sys([1, 2],[1, 2, 1], 1,"u_in","y_disc");
       sys2 = tf2sys([1, 0],[1, -3, -2],0,"c_in","y_out");
       disp("             ---------------------")
       disp(" u_in -->o-->| Discrete system   | --------> y_disc")
-      disp("         ^   ---------------------    |")  
+      disp("         ^   ---------------------    |")
       disp("         |                            | ");
       disp("         -----------------------------|---")
       disp("                                      |  |")
       disp("         ------------------------------  |")
       disp("         |                               |")
       disp("         v   ---------------------       |")
       disp(" c_in -->o-->| continuous system | --------> y_out")
       disp("             ---------------------")
@@ -295,17 +295,17 @@ function bddemo ()
       sys1 = ss2sys([-1, 0; 0, -2],eye(2),eye(2),[]);
       sys2 = ss2sys([-2, 0; 0, -4],eye(2),eye(2),[]);
 
       sys1 = syssetsignals(sys1,"in",in1);
       sys1 = syssetsignals(sys1,"out",out1);
 
       sys2 = syssetsignals(sys2,"in",in2);
       sys2 = syssetsignals(sys2,"out",out2);
-     
+
       disp("sys1=")
       sysout(sys1);
       disp("sys2=")
       sysout(sys2);
       cmd = "sysp = parallel(sys1,sys2);";
       run_cmd
       disp("sysp=")
       sysout(sysp);
@@ -388,21 +388,21 @@ function bddemo ()
         disp("   step 3: connect y to inverted summing connection")
         disp("   step 4: prune the desired i/o connections")
         disp("The third method uses buildssic:")
         disp("   step 1: GW = buildssic(...,K,P)")
         disp(" ")
         disp("Other design examples are in dgkfdemo (controldemo option 7)")
         disp(" ")
         meth = menu("Select design example method", ...
-		"Method 1 ", ...
-		"Method 1 (w/o algebraic loop warning)", ...
-		"Method 2", ...
-		"Method 3", ...
-		"Exit design examples");
+                "Method 1 ", ...
+                "Method 1 (w/o algebraic loop warning)", ...
+                "Method 2", ...
+                "Method 3", ...
+                "Exit design examples");
         if(meth == 1)
           disp(" * * * Method 1 * * *")
           disp(" ")
           disp("         +          --------    --------");
           disp("  r(t) ---> (+) --->| K(s) |--->| P(s) | ----> y(t)");
           disp("            -^      --------    --------  |");
           disp("             |                            |");
           disp("             ------------------------------");
@@ -453,20 +453,20 @@ function bddemo ()
           prompt
           disp("Step 4: connect:")
           disp("   y(t) (output 1) to the negative sum junction (input 3)")
           disp("   u(t) (output 2) to plant input (input 1)")
           disp("and prune extraneous inputs/outputs (retain input 2, output 1)")
           prompt
           out_connect = [1, 2]
           in_connect = [3, 1]
-          cmd = "PK0 = sysconnect(PK,out_connect,in_connect);"; 
+          cmd = "PK0 = sysconnect(PK,out_connect,in_connect);";
           run_cmd
           prompt
-          disp("Notice that sysconnect detects the possibility of algebraic") 
+          disp("Notice that sysconnect detects the possibility of algebraic")
           disp("connections when connecting inputs.  Option 2 (Method 1 ")
           disp("without algebraic loops) shows how to avoid this warning")
           disp("by performing connections one at a time.")
           prompt
           disp("PK0=")
           sysout(PK0);
           disp("Notice that the connected inputs now have stars on their")
           disp("names.  This is how the Octave controls toolbox reminds you")
@@ -493,34 +493,34 @@ function bddemo ()
           disp("         +          --------    --------");
           disp("  r(t) ---> (+) --->| K(s) |--->| P(s) | ----> y(t)");
           disp("  u2        -^      --------    --------    |  y1");
           disp("          u3 |                              |");
           disp("             --------------------------------");
           disp(" ")
           disp("Recall that sysconnect checks for algebraic loops.  Although")
           disp("Design option 1 gets a warning message about a possible");
- 	  disp("algebraic loop, such a loop does not exist.")
+          disp("algebraic loop, such a loop does not exist.")
           disp("This can be seen by performing the connections one at a time");
           cmd = "PK = sysgroup(P,K);";
           run_cmd
           disp("PK=")
           sysout(PK);
           disp("Create an additial inverted input to the controller.")
           cmd = "PK = sysdup(PK,[],2);";
           run_cmd
           cmd = "PK = sysscale(PK,[],diag([1,1,-1]));";
           run_cmd
           disp("PK=")
           sysout(PK);
           disp("Connect controller to plant:")
-          cmd = "PK0 = sysconnect(PK,2,1);"; 
+          cmd = "PK0 = sysconnect(PK,2,1);";
           run_cmd
           disp("Plant output to negative control input")
-          cmd = "PK0 = sysconnect(PK0,1,3);"; 
+          cmd = "PK0 = sysconnect(PK0,1,3);";
           run_cmd
           disp("Only keep plant output (output 1) and r(t) (input 2)")
           cmd = "PK0 = sysprune(PK0,1,2);";
           run_cmd
           disp("PK0=")
           sysout(PK0);
           prompt
           disp("The transfer function form of PK0 is:")
@@ -597,16 +597,16 @@ function bddemo ()
       disp("The transfer function form of PKcl is:")
       sysout(PKcl,"tf");
       disp("You can check this: PKcl = PK / (1 + PK), as expected")
       prompt
       elseif(meth != 5)
         disp("Illegal selection")
      endif
     endwhile
-      
+
     elseif (k == 14)
       return
     endif
-  endwhile  
+  endwhile
   implict_str_to_num_ok = str_sav;
   page_screen_output = sav_page;
 endfunction
diff --git a/scripts/control/bode.m b/scripts/control/bode.m
--- a/scripts/control/bode.m
+++ b/scripts/control/bode.m
@@ -1,101 +1,101 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{mag}, @var{phase}, @var{w}] =} bode(@var{sys}@{,@var{w}, @var{out_idx}, @var{in_idx}@})
+## @deftypefn {Function File} {[@var{mag}, @var{phase}, @var{w}] =} bode(@var{sys}@{,@var{w}, @var{out_idx}, @var{in_idx}@})
 ## If no output arguments are given: produce Bode plots of a system; otherwise,
 ## compute the frequency response of a system data structure
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
-##  a system data structure (must be either purely continuous or discrete;
-## 	 see is_digital)
+## a system data structure (must be either purely continuous or discrete;
+## see is_digital)
 ## @item   w
-##  frequency values for evaluation.
-## 
+## frequency values for evaluation.
+##
 ## if @var{sys} is continuous, then bode evaluates @math{G(jw)} where
 ## @math{G(s)} is the system transfer function.
-## 
-## if @var{sys} is discrete, then bode evaluates G(@code{exp}(jwT)), where 
+##
+## if @var{sys} is discrete, then bode evaluates G(@code{exp}(jwT)), where
 ## @itemize @bullet
 ## @item @var{T}=@code{sysgettsam(@var{sys})} (the system sampling time) and
 ## @item @math{G(z)} is the system transfer function.
 ## @end itemize
-## 
+##
 ## @strong{ Default} the default frequency range is selected as follows: (These
-##         steps are NOT performed if @var{w} is specified)
+## steps are NOT performed if @var{w} is specified)
 ## @enumerate
 ## @item via routine bodquist, isolate all poles and zeros away from
 ## @var{w}=0 (@var{jw}=0 or @math{@code{exp}(jwT)}=1) and select the frequency
 ## range based on the breakpoint locations of the frequencies.
 ## @item if @var{sys} is discrete time, the frequency range is limited
-##               to @math{jwT} in 
+##               to @math{jwT} in
 ## @ifinfo
 ## [0,2 pi /T]
 ## @end ifinfo
 ## @iftex
-## @tex 
+## @tex
 ## $[0,2\pi/T]$
 ## @end tex
 ## @end iftex
 ## @item A "smoothing" routine is used to ensure that the plot phase does
-##               not change excessively from point to point and that singular
-##               points (e.g., crossovers from +/- 180) are accurately shown.
-## 
+## not change excessively from point to point and that singular
+## points (e.g., crossovers from +/- 180) are accurately shown.
+##
 ## @end enumerate
 ## @item out_idx
 ## @itemx in_idx
-##  the indices of the output(s) and input(s) to be used in
-##      the frequency response; see @code{sysprune}.
+## the indices of the output(s) and input(s) to be used in
+## the frequency response; see @code{sysprune}.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item mag
 ## @itemx phase
-##  the magnitude and phase of the frequency response
-##        @math{G(jw)} or @math{G(@code{exp}(jwT))} at the selected frequency values.
+## the magnitude and phase of the frequency response @math{G(jw)} or
+## @math{G(@code{exp}(jwT))} at the selected frequency values.
 ## @item w
 ## the vector of frequency values used
 ## @end table
-## 
+##
 ## @strong{Notes}
 ## @enumerate
 ## @item If no output arguments are given, e.g.,
 ## @example
 ## bode(sys);
 ## @end example
-## bode plots the results to the 
-## screen.  Descriptive labels are automatically placed. 
-## 
+## bode plots the results to the screen.  Descriptive labels are
+## automatically placed.
+##
 ## Failure to include a concluding semicolon will yield some garbage
 ## being printed to the screen (@code{ans = []}).
-## 
+##
 ## @item If the requested plot is for an MIMO system, mag is set to
-##  @math{||G(jw)||} or @math{||G(@code{exp}(jwT))||}
+## @math{||G(jw)||} or @math{||G(@code{exp}(jwT))||}
 ## and phase information is not computed.
 ## @end enumerate
-## @end deftypefn 
+## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 10, 1996
 ## Based on previous code by R. Bruce Tenison, July 13, 1994
 ## Modified by David Clem November 13, 1994
 ## again by A. S. Hodel July 1995 (smart plot range, etc.)
 ## Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
 
@@ -157,19 +157,19 @@ function [mag_r, phase_r, w_r] = bode (s
     if(is_siso(sys))
       if (gnuplot_has_multiplot)
         subplot(2,1,1);
       endif
       title(["|[Y/U]",tistr,"|, u=", nth(inname,1),", y=",nth(outname,1)]);
     else
       title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
       disp("MIMO plot from")
-      disp(outlist(inname,"	"));
+      disp(outlist(inname,"     "));
       disp("to")
-      disp(outlist(outname,"	"));
+      disp(outlist(outname,"    "));
     endif
     wv = [min(w), max(w)];
     if(do_db_plot && max(mag) > 0)
       ylabel("Gain in dB");
       md = 20*log10(mag);
       axvec = axis2dlim([vec(w),vec(md)]);
       axvec(1:2) = wv;
       axis(axvec);
@@ -191,17 +191,17 @@ function [mag_r, phase_r, w_r] = bode (s
         prompt("Press any key for phase plot");
       endif
       axvec = axis2dlim([vec(w),vec(phase)]);
       axvec(1:2) = wv;
       axis(axvec);
       xlabel(xlstr);
       ylabel("Phase in deg");
       title([ "phase([Y/U]", tistr, ...
-	 "), u=", nth(inname,1),", y=",nth(outname,1)]);
+         "), u=", nth(inname,1),", y=",nth(outname,1)]);
       grid("on");
       semilogx(w,phase);
       ## This should be the default for subsequent plot commands.
       if(gnuplot_has_multiplot)
         oneplot();
       endif
     endif
   else
diff --git a/scripts/control/bode_bounds.m b/scripts/control/bode_bounds.m
--- a/scripts/control/bode_bounds.m
+++ b/scripts/control/bode_bounds.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{wmin}, @var{wmax}] =} bode_bounds (@var{zer}, @var{pol}, @var{dflg}@{, @var{tsam} @})
+## @deftypefn {Function File} {[@var{wmin}, @var{wmax}] =} bode_bounds (@var{zer}, @var{pol}, @var{dflg}@{, @var{tsam} @})
 ## Get default range of frequencies based on cutoff frequencies of system
 ## poles and zeros.
 ## Frequency range is the interval [10^wmin,10^wmax]
-## 
+##
 ## Used internally in freqresp (@code{bode}, @code{nyquist})
 ## @end deftypefn
- 
+
 function [wmin, wmax] = bode_bounds (zer, pol, DIGITAL, tsam)
 
   ## make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
   ## check for natural frequencies away from omega = 0
   if (DIGITAL)
@@ -37,17 +37,17 @@ function [wmin, wmax] = bode_bounds (zer
     iiz = find(abs(zer - 1) > norm(zer) * eps && abs(zer) > norm(zer) * eps);
     iip = find(abs(pol - 1) > norm(pol) * eps && abs(pol) > norm(pol) * eps);
 
     ## avoid dividing empty matrices, it would work but looks nasty
     if (!isempty(iiz)) czer = log(zer(iiz))/tsam;
     else               czer = [];                 endif
 
     if (!isempty(iip)) cpol = log(pol(iip))/tsam;
-    else 	       cpol = [];                 endif
+    else               cpol = [];                 endif
 
   else
     ## continuous
     iip = find((abs(pol)) > (norm(pol) * eps));
     iiz = find((abs(zer)) > (norm(zer) * eps));
 
     if(!isempty(zer)) czer = zer(iiz);
     else              czer = [];                endif
diff --git a/scripts/control/bodquist.m b/scripts/control/bodquist.m
--- a/scripts/control/bodquist.m
+++ b/scripts/control/bodquist.m
@@ -1,125 +1,125 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{f}, @var{w}] =} bodquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
-##  used internally by bode, nyquist; compute system frequency response.
-## 
+## @deftypefn {Function File} {[@var{f}, @var{w}] =} bodquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
+## used internally by bode, nyquist; compute system frequency response.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## input system structure
 ## @item w
 ## range of frequencies; empty if user wants default
 ## @item out_idx
 ## list of outputs; empty if user wants all
 ## @item in_idx
 ## list of inputs; empty if user wants all
 ## @item rname
 ## name of routine that called bodquist ("bode" or "nyquist")
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item w
-##  list of frequencies 
+## list of frequencies
 ## @item f
-##  frequency response of sys; @math{f(ii) = f(omega(ii))}
+## frequency response of sys; @math{f(ii) = f(omega(ii))}
 ## @end table
 ## @strong{Note} bodquist could easily be incorporated into a Nichols
 ## plot function; this is in a "to do" list.
 ##
-## Both bode and nyquist share the same introduction, so the common parts are 
-## in bodquist.  It contains the part that finds the number of arguments, 
-## determines whether or not the system is SISO, and computes the frequency 
-## response.  Only the way the response is plotted is different between the 
+## Both bode and nyquist share the same introduction, so the common parts are
+## in bodquist.  It contains the part that finds the number of arguments,
+## determines whether or not the system is SISO, and computes the frequency
+## response.  Only the way the response is plotted is different between the
 ## two functions.
 ## @end deftypefn
- 
+
 function [f, w] = bodquist (sys, w, outputs, inputs, rname)
 
   ## check number of input arguments given
   if (nargin != 5)
     usage("[f,w] = bodquist(sys,w,outputs,inputs,rname)");
   endif
 
   ## check each argument to see if it's in the correct form
   if (!is_struct(sys))
     error("sys must be a system data structure");
   endif
-	
+
   ## let freqresp determine w if it's not already given
   USEW = freqchkw(w);
 
   ## get initial dimensions (revised below if sysprune is called)
   [nn,nz,mm,pp ] = sysdimensions(sys);
 
   ## check for an output vector and to see whether it`s correct
   if (!isempty(outputs))
     if (isempty(inputs))
-      inputs = 1:mm;			# use all inputs
+      inputs = 1:mm;                    # use all inputs
       warning([rname,": outputs specified but not inputs"]);
     endif
     sys = sysprune(sys,outputs,inputs);
     [nn,nz,mm,pp ] = sysdimensions(sys);
   endif
 
-  ## for speed in computation, convert local copy of 
+  ## for speed in computation, convert local copy of
   ## SISO state space systems to zero-pole  form
   if( is_siso(sys) & strcmp( sysgettype(sys), "ss") )
     [zer,pol,k,tsam,inname,outname] = sys2zp(sys);
     sys = zp2sys(zer,pol,k,tsam,inname,outname);
   endif
 
   ## get system frequency response
-  [f,w] = freqresp(sys,USEW,w);   
+  [f,w] = freqresp(sys,USEW,w);
 
   phase = arg(f)*180.0/pi;
 
   if(!USEW)
     ## smooth plots
-    pcnt = 5;		# max number of refinement steps
-    dphase = 5;		# desired max change in phase
-    dmag = 0.2;		# desired max change in magnitude
+    pcnt = 5;           # max number of refinement steps
+    dphase = 5;         # desired max change in phase
+    dmag = 0.2;         # desired max change in magnitude
     while(pcnt)
-      pd = abs(diff(phase));			# phase variation
+      pd = abs(diff(phase));                    # phase variation
       pdbig = vec(find(pd > dphase));
 
-      lp = length(f);  lp1 = lp-1;		# relative variation
+      lp = length(f);  lp1 = lp-1;              # relative variation
       fd = abs(diff(f));
       fm = max(abs([f(1:lp1); f(2:lp)]));
       fdbig = vec(find(fd > fm/10));
 
       bigpts = union(fdbig, pdbig);
 
       if(isempty(bigpts) )
         pcnt = 0;
       else
         pcnt = pcnt - 1;
         wnew = [];
         crossover_points = find ( phase(1:lp1).*phase(2:lp) < 0);
         pd(crossover_points) = abs(359.99+dphase - pd(crossover_points));
-        np_pts = max(3,ceil(pd/dphase)+2);		# phase points
-        nm_pts = max(3,ceil(log(fd./fm)/log(dmag))+2); 	# magnitude points
+        np_pts = max(3,ceil(pd/dphase)+2);              # phase points
+        nm_pts = max(3,ceil(log(fd./fm)/log(dmag))+2);  # magnitude points
         npts = min(5,max(np_pts, nm_pts));
 
         w1 = log10(w(1:lp1));
         w2 = log10(w(2:lp));
         for ii=bigpts
           if(npts(ii))
             wtmp = logspace(w1(ii),w2(ii),npts(ii));
             wseg(ii,1:(npts(ii)-2)) = wtmp(2:(npts(ii)-1));
@@ -128,29 +128,29 @@ function [f, w] = bodquist (sys, w, outp
         wnew = vec(wseg)'; # make a row vector
         wnew = wnew(find(wnew != 0));
         wnew = sort(wnew);
         wnew = create_set(wnew);
         if(isempty(wnew))   # all small crossovers
           pcnt = 0;
         else
           [fnew,wnew] = freqresp(sys,1,wnew);    # get new freq resp points
-          w = [w,wnew];			# combine with old freq resp
+          w = [w,wnew];                 # combine with old freq resp
           f = [f,fnew];
-          [w,idx] = sort(w);		# sort into order
+          [w,idx] = sort(w);            # sort into order
           f = f(idx);
           phase = arg(f)*180.0/pi;
         endif
       endif
     endwhile
   endif
 
   ## ensure unique frequency values
   [w,idx] = sort(w);
   f = f(idx);
 
   w_diff = diff(w);
   w_dup = find(w_diff == 0);
   w_idx = complement(w_dup,1:length(w));
   w = w(w_idx);
   f = f(w_idx);
-    
+
 endfunction
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -1,125 +1,125 @@
 ## Copyright (C) 1998 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{sys} =} buildssic(@var{Clst}, @var{Ulst}, @var{Olst}, @var{Ilst}, @var{s1}, @var{s2}, @var{s3}, @var{s4}, @var{s5}, @var{s6}, @var{s7}, @var{s8})
-## 
-##  Form an arbitrary complex (open or closed loop) system in
-##  state-space form from several systems. "@code{buildssic}" can
-##  easily (despite it's cryptic syntax) integrate transfer functions
-##  from a complex block diagram into a single system with one call.
-##  This function is especially useful for building open loop
-##  interconnections for H_infinity and H2 designs or for closing
-##  loops with these controllers.
-## 
-##  Although this function is general purpose, the use of "@code{sysgroup}"
-##  "@code{sysmult}", "@code{sysconnect}" and the like is recommended for standard
-##  operations since they can handle mixed discrete and continuous
-##  systems and also the names of inputs, outputs, and states.
-##  
-##  The parameters consist of 4 lists that describe the connections
-##  outputs and inputs and up to 8 systems s1-s8.
-##  Format of the lists:
+## @deftypefn {Function File} {@var{sys} =} buildssic(@var{Clst}, @var{Ulst}, @var{Olst}, @var{Ilst}, @var{s1}, @var{s2}, @var{s3}, @var{s4}, @var{s5}, @var{s6}, @var{s7}, @var{s8})
+##
+## Form an arbitrary complex (open or closed loop) system in
+## state-space form from several systems. "@code{buildssic}" can
+## easily (despite it's cryptic syntax) integrate transfer functions
+## from a complex block diagram into a single system with one call.
+## This function is especially useful for building open loop
+## interconnections for H_infinity and H2 designs or for closing
+## loops with these controllers.
+##
+## Although this function is general purpose, the use of "@code{sysgroup}"
+## "@code{sysmult}", "@code{sysconnect}" and the like is recommended for
+## standard operations since they can handle mixed discrete and continuous
+## systems and also the names of inputs, outputs, and states.
+##
+## The parameters consist of 4 lists that describe the connections
+## outputs and inputs and up to 8 systems s1-s8.
+## Format of the lists:
 ## @table @var
 ## @item      Clst
 ## connection list, describes the input signal of
 ## each system. The maximum number of rows of Clst is
 ## equal to the sum of all inputs of s1-s8.
-## 
+##
 ## Example:
 ## @code{[1 2 -1; 2 1 0]} ==> new input 1 is old inpout 1
 ## + output 2 - output 1, new input 2 is old input 2
 ## + output 1. The order of rows is arbitrary.
-## 
+##
 ## @item     Ulst
-##  if not empty the old inputs in vector Ulst will
-##            be appended to the outputs. You need this if you
-##            want to "pull out" the input of a system. Elements
-##            are input numbers of s1-s8.
-## 
+## if not empty the old inputs in vector Ulst will
+## be appended to the outputs. You need this if you
+## want to "pull out" the input of a system. Elements
+## are input numbers of s1-s8.
+##
 ## @item     Olst
-##  output list, specifiy the outputs of the resulting
-##            systems. Elements are output numbers of s1-s8.
-##            The numbers are alowed to be negative and may
-##            appear in any order. An empty matrix means
-##            all outputs.
-## 
+## output list, specifiy the outputs of the resulting
+## systems. Elements are output numbers of s1-s8.
+## The numbers are alowed to be negative and may
+## appear in any order. An empty matrix means
+## all outputs.
+##
 ## @item     Ilst
-##  input list, specifiy the inputs of the resulting
-##            systems. Elements are input numbers of s1-s8.
-##            The numbers are alowed to be negative and may
-##            appear in any order. An empty matrix means
-##            all inputs.
+## input list, specifiy the inputs of the resulting
+## systems. Elements are input numbers of s1-s8.
+## The numbers are alowed to be negative and may
+## appear in any order. An empty matrix means
+## all inputs.
 ## @end table
-## 
-##  Example:  Very simple closed loop system.
+##
+## Example:  Very simple closed loop system.
 ## @example
 ## @group
 ## w        e  +-----+   u  +-----+
 ##  --->o--*-->|  K  |--*-->|  G  |--*---> y
 ##      ^  |   +-----+  |   +-----+  |
 ##    - |  |            |            |
 ##      |  |            +----------------> u
 ##      |  |                         |
 ##      |  +-------------------------|---> e
 ##      |                            |
 ##      +----------------------------+
 ## @end group
 ## @end example
-## 
+##
 ## The closed loop system GW can be optained by
 ## @example
 ## GW = buildssic([1 2; 2 -1], 2, [1 2 3], 2, G, K);
 ## @end example
 ## @table @var
 ## @item Clst
 ## (1. row) connect input 1 (G) with output 2 (K).
 ## (2. row) connect input 2 (K) with neg. output 1 (G).
 ## @item Ulst
 ## append input of (2) K to the number of outputs.
 ## @item Olst
 ## Outputs are output of 1 (G), 2 (K) and appended output 3 (from Ulst).
 ## @item Ilst
 ## the only input is 2 (K).
 ## @end table
-## 
+##
 ## Here is a real example:
 ## @example
 ## @group
 ##                          +----+
 ##     -------------------->| W1 |---> v1
 ## z   |                    +----+
 ## ----|-------------+                   || GW   ||     => min.
 ##     |             |                        vz   infty
 ##     |    +---+    v      +----+
 ##     *--->| G |--->O--*-->| W2 |---> v2
 ##     |    +---+       |   +----+
 ##     |                |
 ##     |                v
 ##    u                  y
 ## @end group
 ## @end example
-## 
+##
 ## The closed loop system GW from [z; u]' to [v1; v2; y]' can be
 ## obtained by (all SISO systems):
 ## @example
 ## GW = buildssic([1, 4; 2, 4; 3, 1], 3, [2, 3, 5],
 ##                [3, 4], G, W1, W2, One);
 ## @end example
 ## where "One" is a unity gain (auxillary) function with order 0.
 ## (e.g. @code{One = ugain(1);})
@@ -156,20 +156,20 @@ function sys = buildssic (Clst, Ulst, Ol
     endif
     ss = sysupdate(ss, "ss");
     [n1, nz1, m1, p1] = sysdimensions(ss);
     if (n1 && nz1)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
     if (D_SYS)
       if (n1)
-      	error("---> cannot handle mixed cont. and discr. systems.");
+        error("---> cannot handle mixed cont. and discr. systems.");
       endif
       if (tsam != sysgettsam(ss))
-	error("---> sampling time of all systems must match.");
+        error("---> sampling time of all systems must match.");
       endif
     endif
     [as,bs,cs,ds] = sys2ss(ss);
     nt1 = n1 + nz1;
     if (!nt1)
       ## pure gain (pad B, C with zeros)
       B = [B, zeros(nt,m1)];
       C = [C; zeros(p1,nt)];
@@ -224,19 +224,19 @@ function sys = buildssic (Clst, Ulst, Ol
     endif
     if (inp_used(iu))
       error("---> Input specified more than once.");
     endif
     inp_used(iu) = 1;
     for kk = 2:mx
       it = xx(kk);
       if (abs(it) > p)
-      	error("---> Illegal row value in Clst.");
+        error("---> Illegal row value in Clst.");
       elseif (it)
-	K(iu,abs(it)) = sign(it);
+        K(iu,abs(it)) = sign(it);
       endif
     endfor
   endfor
 
   ## form the "closed loop", i.e replace u in
   ## .
   ## x = Ax + Bu
   ##                            ~
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -1,74 +1,75 @@
 ## Copyright (C) 1993, 1994, 1995 John W. Eaton
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{dsys} =} c2d (@var{sys}@{, @var{opt}, @var{T}@})
-## @deftypefnx {Function File } { @var{dsys} =} c2d (@var{sys}@{, @var{T}@})
-## 
+## @deftypefn {Function File} {@var{dsys} =} c2d (@var{sys}@{, @var{opt}, @var{T}@})
+## @deftypefnx {Function File} {@var{dsys} =} c2d (@var{sys}@{, @var{T}@})
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
-##  system data structure (may have both continuous time and discrete time subsystems)
+## system data structure (may have both continuous time and discrete
+## time subsystems)
 ## @item opt
-## string argument; conversion option (optional argument; 
-## may be omitted as shown above) 
+## string argument; conversion option (optional argument;
+## may be omitted as shown above)
 ## @table @code
-## @item "ex" 
+## @item "ex"
 ## use the matrix exponential (default)
-## @item "bi" 
+## @item "bi"
 ## use the bilinear transformation
 ## @end table
 ## @example
 ##     2(z-1)
 ## s = -----
 ##     T(z+1)
 ## @end example
-## FIXME: This option exits with an error if @var{sys} is not purely 
+## FIXME: This option exits with an error if @var{sys} is not purely
 ## continuous. (The @code{ex} option can handle mixed systems.)
 ## @item @var{T}
 ## sampling time; required if sys is purely continuous.
-## 
+##
 ## @strong{Note} If the 2nd argument is not a string, @code{c2d} assumes that
 ## the 2nd argument is @var{T} and performs appropriate argument checks.
 ## @end table
-## 
+##
 ## @strong{Outputs}
-## @var{dsys} discrete time equivalent via zero-order hold, 
+## @var{dsys} discrete time equivalent via zero-order hold,
 ## sample each @var{T} sec.
-## 
+##
 ## converts the system data structure describing
 ## @example
 ## .
 ## x = Ac x + Bc u
 ## @end example
 ## into a discrete time equivalent model
 ## @example
 ## x[n+1] = Ad x[n] + Bd u[n]
 ## @end example
 ## via the matrix exponential or bilinear transform
-## 
+##
 ## @strong{Note} This function adds the suffix  @code{_d}
-## to the names of the new discrete states.   
+## to the names of the new discrete states.
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: October 1993
 ## Updated by John Ingram for system data structure August 1996
 
 function dsys = c2d (sys, opt, T)
   ## parse input arguments
@@ -105,31 +106,31 @@ function dsys = c2d (sys, opt, T)
   sys = sysupdate(sys,"ss");
   [n,nz,m,p] = sysdimensions(sys);
   if(n == 0)
     dsys = syssetsignals(sys,"yd",ones(1:p));
   elseif(strcmp(opt,"ex"));
     [aa,bb,cc,dd] = sys2ss(sys);
     crng= 1:n;
     drng = n+(1:nz);
-  
+
     ## partition state equations into continuous, imaginary subsystems
     Ac = aa(crng,crng);
     Bc = bb(crng,:);
     if(nz == 0)
       Acd = Adc = Add = Bd = 0;
     else
       Acd = aa(crng,drng);
       Adc = aa(drng,crng);
       Add = aa(drng,drng);
       Bd  = bb(drng,:);
       Bc  = [Bc, Acd];   ## append discrete states as inputs to cont system
     endif
-    
-    ## convert state equations 
+
+    ## convert state equations
     mat = [Ac, Bc; zeros(m+nz,n+nz+m)];
     matexp = expm(mat * T);
 
     ## replace Ac
     aa(crng,crng) = matexp(crng,crng);    ## discretized homegenous diff eqn
 
     ## replace Bc
     bb(crng,:)    = matexp(crng,n+(1:m));
@@ -139,17 +140,17 @@ function dsys = c2d (sys, opt, T)
       aa(crng,drng) = matexp(crng,n+m+(1:nz));
     end
 
     stnames = sysgetsignals(sys,"st");   ## continuous states renamed below
     innames = sysgetsignals(sys,"in");
     outnames = sysgetsignals(sys,"out");
     outlist = 1:p;
     dsys = ss2sys(aa,bb,cc,dd,T,0,n+nz,stnames,innames, ...
-  	outnames,outlist);
+        outnames,outlist);
     ## rename states
     for ii=1:n
       strval = sprintf("%s_d",sysgetsignals(dsys,"st",ii,1));
       dsys = syssetsignals(dsys,"st",strval,ii);
     endfor
 
   elseif(strcmp(opt,"bi"))
     if(is_digital(sys))
@@ -165,10 +166,10 @@ function dsys = c2d (sys, opt, T)
       C = tk*(c/(IT-a));
       D = d + (c*iab);
       stnamed = strappend(stname,"_d");
       dsys = ss2sys(A,B,C,D,T,0,rows(A),stnamed,inname,outname);
     endif
   else
     error(["Bad option=",opt])
   endif
-  
+
 endfunction
diff --git a/scripts/control/com2str.m b/scripts/control/com2str.m
--- a/scripts/control/com2str.m
+++ b/scripts/control/com2str.m
@@ -1,50 +1,50 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} com2str(@var{zz}[,@var{flg}])
-##  
+##
 ## convert complex number to a string
 ## @strong{Inputs}
 ## @table @var
 ## @item zz
-##      complex number
+## complex number
 ## @item flg
-##      format flag
-##      0 (default):            -1, 0, 1,   1i,   1 + 0.5i
-##      1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
+## format flag
+## 0 (default):            -1, 0, 1,   1i,   1 + 0.5i
+## 1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
 ## @end table
 ## @end deftypefn
 
 function retval = com2str (zz, flg)
 
   if (nargin < 1 | nargin > 2)
     usage("com2str(zz{,flg})");
   endif
   if(nargin == 1)
     flg = 0;
   endif
- 
+
   if( !(is_scalar(zz) & is_scalar(flg) ) )
     error("com2str: arguments must be a scalar.");
   endif
 
   if(flg != 0 & flg != 1)
     error(["Illegal flg value: ",num2str(flg)]);
   endif
 
@@ -73,10 +73,10 @@ function retval = com2str (zz, flg)
     ## strictly an imaginary number
     switch(flg)
     case(0)
       retval = [num2str(rz)," ",com2str(i*iz,1)];
     case(1)
       retval = [ sgns(1+(rz< 0))," ", num2str(abs(rz))," ",com2str(i*iz,1)];
     endswitch
   endif
-  
+
 endfunction
diff --git a/scripts/control/controldemo.m b/scripts/control/controldemo.m
--- a/scripts/control/controldemo.m
+++ b/scripts/control/controldemo.m
@@ -1,31 +1,30 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} { } controldemo
+## @deftypefn {Function File} {} controldemo ()
 ## Controls toolbox demo.
-## @end deftypefn  
-## @seealso{Demo programs: bddemo.m, frdemo.m, analdemo.m, 
-## moddmeo.m, rldemo.m
+## @end deftypefn
+## @seealso{Demo programs: bddemo, frdemo, analdemo, moddmeo, rldemo}
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function controldemo ()
   DEMOcontrol ();
 endfunction
diff --git a/scripts/control/ctrb.m b/scripts/control/ctrb.m
--- a/scripts/control/ctrb.m
+++ b/scripts/control/ctrb.m
@@ -1,40 +1,40 @@
 ## Copyright (C) 1997 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{Qs} =} ctrb(@var{sys} @{, @var{b}@})
-## @deftypefnx {Function File } {@var{Qs} =} ctrb(@var{A}, @var{B})
+## @deftypefn {Function File} {@var{Qs} =} ctrb(@var{sys} @{, @var{b}@})
+## @deftypefnx {Function File} {@var{Qs} =} ctrb(@var{A}, @var{B})
 ## Build controllability matrix
 ## @example
 ##              2       n-1
 ## Qs = [ B AB A B ... A   B ]
 ## @end example
-## 
-##  of a system data structure or the pair (@var{A}, @var{B}).
-## 
+##
+## of a system data structure or the pair (@var{A}, @var{B}).
+##
 ## @strong{Note} @code{ctrb} forms the controllability matrix.
-##        The numerical properties of @code{is_controllable}
-##        are much better for controllability tests.
+## The numerical properties of @code{is_controllable}
+## are much better for controllability tests.
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function Qs = ctrb (sys, b)
 
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -1,64 +1,64 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{csys} =} d2c (@var{sys}@{,@var{tol}@})
-## @deftypefnx {Function File } {@var{csys} =} d2c (@var{sys}, @var{opt})
+## @deftypefn {Function File} {@var{csys} =} d2c (@var{sys}@{,@var{tol}@})
+## @deftypefnx {Function File} {@var{csys} =} d2c (@var{sys}, @var{opt})
 ## Convert discrete (sub)system to a purely continuous system.  Sampling
 ## time used is @code{sysgettsam(@var{sys})}
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
-##  system data structure with discrete components
+## system data structure with discrete components
 ## @item   tol
 ## Scalar value.
-##  tolerance for convergence of default @code{"log"} option (see below)
+## tolerance for convergence of default @code{"log"} option (see below)
 ## @item   opt
-##  conversion option.  Choose from:
+## conversion option.  Choose from:
 ## @table @code
 ## @item         "log"
-##  (default) Conversion is performed via a matrix logarithm.
+## (default) Conversion is performed via a matrix logarithm.
 ## Due to some problems with this computation, it is
-## followed by a steepest descent algorithm to identify continuous time 
-## @var{A}, @var{B}, to get a better fit to the original data.  
-## 
-## If called as @code{d2c}(@var{sys},@var{tol}), @var{tol=}positive scalar, 
-## 	the @code{"log"} option is used.  The default value for @var{tol} is 
-## 	@code{1e-8}.
+## followed by a steepest descent algorithm to identify continuous time
+## @var{A}, @var{B}, to get a better fit to the original data.
+##
+## If called as @code{d2c}(@var{sys},@var{tol}), @var{tol=}positive scalar,
+## the @code{"log"} option is used.  The default value for @var{tol} is
+## @code{1e-8}.
 ## @item        "bi"
-##  Conversion is performed via bilinear transform 
-## @math{z = (1 + s T / 2)/(1 - s T / 2)} where @var{T} is the 
+## Conversion is performed via bilinear transform
+## @math{z = (1 + s T / 2)/(1 - s T / 2)} where @var{T} is the
 ## system sampling time (see @code{sysgettsam}).
-## 
-## FIXME: bilinear option exits with an error if @var{sys} is not purely discrete
-## 
+##
+## FIXME: bilinear option exits with an error if @var{sys} is not purely
+## discrete
 ## @end table
 ## @end table
 ## @strong{Outputs} @var{csys} continuous time system (same dimensions and
 ## signal names as in @var{sys}).
 ## @end deftypefn
- 
+
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: August 23, 1994
 ## Updated by John Ingram for system data structure  August 1996
 
 function csys = d2c (sys, opt)
 
   ## SYS_INTERNAL accesses members of system data structure
 
@@ -73,17 +73,17 @@ function csys = d2c (sys, opt)
     tol = 1e-12;
     if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
       error(["d2c: illegal opt passed=",opt]);
     endif
   elseif(!is_sample(opt))
     error("tol must be a postive scalar")
   elseif(opt > 1e-2)
     warning(["d2c: ridiculous error tolerance passed=",num2str(opt); ...
-	", intended c2d call?"])
+        ", intended c2d call?"])
   else
     tol = opt;
     opt = "log";
   endif
   T = sysgettsam(sys);
 
   if(strcmp(opt,"bi"))
     ## bilinear transform
@@ -105,117 +105,117 @@ function csys = d2c (sys, opt)
     B = tk*iab;
     C = tk*(c/(I+a));
     D = d- (c*iab);
     stnamec = strappend(stname,"_c");
     csys = ss2sys(A,B,C,D,0,rows(A),0,stnamec,inname,outname);
   elseif(strcmp(opt,"log"))
     sys = sysupdate(sys,"ss");
     [n,nz,m,p] = sysdimensions(sys);
-  
+
     if(nz == 0)
       warning("d2c: all states continuous; setting outputs to agree");
       csys = syssetsignals(sys,"yd",zeros(1,1:p));
       return;
     elseif(n != 0)
       warning(["d2c: n=",num2str(n),">0; performing c2d first"]);
       sys = c2d(sys,T);
     endif
     [a,b] = sys2ss(sys);
-  
+
     [ma,na] = size(a);
     [mb,nb] = size(b);
-  
+
     if(isempty(b) )
       warning("d2c: empty b matrix");
       Amat = a;
     else
       Amat = [a, b; zeros(nb,na), eye(nb)];
     endif
-  
+
     poles = eig(a);
     if( find(abs(poles) < 200*(n+nz)*eps) )
       warning("d2c: some poles very close to zero.  logm not performed");
       Mtop = zeros(ma, na+nb);
     elseif( find(abs(poles-1) < 200*(n+nz)*eps) )
       warning("d2c: some poles very close to one.  May get bad results.");
       logmat = real(logm(Amat)/T);
       Mtop = logmat(1:na,:);
     else
       logmat = real(logm(Amat)/T);
       Mtop = logmat(1:na,:);
     endif
-  
+
     ## perform simplistic, stupid optimization approach.
     ## should re-write with a Davidson-Fletcher CG approach
     mxthresh = norm(Mtop);
     if(mxthresh == 0)
       mxthresh = 1;
     endif
-    eps1 = mxthresh;	#gradient descent step size
-    cnt = max(20,(n*nz)*4);	#max number of iterations
-    newgrad=1;	#signal for new gradient
+    eps1 = mxthresh;    #gradient descent step size
+    cnt = max(20,(n*nz)*4);     #max number of iterations
+    newgrad=1;  #signal for new gradient
     while( (eps1/mxthresh > tol) & cnt)
       cnt = cnt-1;
       ## calculate the gradient of error with respect to Amat...
       geps = norm(Mtop)*1e-8;
       if(geps == 0)
         geps = 1e-8;
       endif
       DMtop = Mtop;
       if(isempty(b))
         Mall = Mtop;
         DMall = DMtop;
       else
         Mall = [Mtop; zeros(nb,na+nb)];
         DMall = [DMtop; zeros(nb,na+nb) ];
       endif
-  
+
       if(newgrad)
         GrMall = zeros(size(Mall));
         for ii=1:rows(Mtop)
           for jj=1:columns(Mtop)
-  	  DMall(ii,jj) = Mall(ii,jj) + geps;
+          DMall(ii,jj) = Mall(ii,jj) + geps;
             GrMall(ii,jj) = norm (Amat - expm (DMall*T), "fro") ...
-  		- norm (Amat - expm (Mall*T), "fro");
-      	  DMall(ii,jj) = Mall(ii,jj);
+                - norm (Amat - expm (Mall*T), "fro");
+          DMall(ii,jj) = Mall(ii,jj);
           endfor
         endfor
         GrMall = GrMall/norm(GrMall,1);
         newgrad = 0;
       endif
-  
+
       ## got a gradient, now try to use it
       DMall = Mall-eps1*GrMall;
-  
+
       FMall = expm(Mall*T);
       FDMall = expm(DMall*T);
       FmallErr = norm(Amat - FMall);
       FdmallErr = norm(Amat - FDMall);
       if( FdmallErr < FmallErr)
         Mtop = DMall(1:na,:);
         eps1 = min(eps1*2,1e12);
         newgrad = 1;
       else
         eps1 = eps1/2;
       endif
-  
+
       if(FmallErr == 0)
         eps1 = 0;
       endif
-      
+
     endwhile
-  
+
     [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
     aa = Mall(1:na,1:na);
     if(!isempty(b))
       bb = Mall(1:na,(na+1):(na+nb));
     endif
     csys = ss2sys(aa,bb,cc,dd,0,na,0,stnam,innam,outnam);
-    
+
     ## update names
     nn = sysdimensions(sys);
     for ii = (nn+1):na
       strval = sprintf("%s_c",sysgetsignals(csys,"st",ii,1));
       csys = syssetsignals(csys,"st",strval,ii);
     endfor
   endif
 
diff --git a/scripts/control/damp.m b/scripts/control/damp.m
--- a/scripts/control/damp.m
+++ b/scripts/control/damp.m
@@ -1,35 +1,34 @@
 ## Copyright (C) 1993, 1994, 1995 John W. Eaton
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {} damp(@var{p}@{, @var{tsam}@})
-##       Displays eigenvalues, natural frequencies and damping ratios
-##       of the eigenvalues of a matrix @var{p} or the @var{A}-matrix of a
-##       system @var{p}, respectively.
-##       If @var{p} is a system, @var{tsam} must not be specified.
-##       If @var{p} is a matrix and @var{tsam} is specified, eigenvalues
-##       of @var{p} are assumed to be in @var{z}-domain.
-## 
+## @deftypefn {Function File} {} damp(@var{p}@{, @var{tsam}@})
+## Displays eigenvalues, natural frequencies and damping ratios
+## of the eigenvalues of a matrix @var{p} or the @var{A}-matrix of a
+## system @var{p}, respectively.
+## If @var{p} is a system, @var{tsam} must not be specified.
+## If @var{p} is a matrix and @var{tsam} is specified, eigenvalues
+## of @var{p} are assumed to be in @var{z}-domain.
 ## @end deftypefn
 ## @seealso{eig}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 29, 1997.
 
 function damp (p, tsam)
 
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -14,78 +14,78 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dare (@var{a}, @var{b}, @var{c}, @var{r}, @var{opt})
-## 
+##
 ## Return the solution, @var{x} of the discrete-time algebraic Riccati
 ## equation
 ## @iftex
 ## @tex
 ## $$
 ## A^TXA - X + A^TXB (R + B^TXB)^{-1} B^TXA + C = 0
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @example
 ## a' x a - x + a' x b (r + b' x b)^(-1) b' x a + c = 0
 ## @end example
 ## @end ifinfo
 ## @noindent
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @var{n} by @var{n}.
-## 
+##
 ## @item b
 ## @var{n} by @var{m}.
-## 
+##
 ## @item c
 ## @var{n} by @var{n}, symmetric positive semidefinite, or @var{p} by @var{n}.
 ## In the latter case @math{c:=c'*c} is used.
-## 
+##
 ## @item r
 ## @var{m} by @var{m}, symmetric positive definite (invertible).
-## 
+##
 ## @item opt
 ## (optional argument; default = @code{"B"}):
 ## String option passed to @code{balance} prior to ordered @var{QZ} decomposition.
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @var{x} solution of DARE.
-## 
+##
 ## @strong{Method}
 ## Generalized eigenvalue approach (Van Dooren; SIAM J.
 ##  Sci. Stat. Comput., Vol 2) applied  to the appropriate symplectic pencil.
-## 
+##
 ##  See also: Ran and Rodman, "Stable Hermitian Solutions of Discrete
 ##  Algebraic Riccati Equations," Mathematics of Control, Signals and
 ##  Systems, Vol 5, no 2 (1992)  pp 165-194.
-## 
+##
 ## @end deftypefn
 ## @seealso{balance and are}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function x = dare (a, b, c, r, opt)
 
   if (nargin == 4 | nargin == 5)
     if (nargin == 5)
       if (opt != "N" || opt != "P" || opt != "S" || opt != "B")
-	warning ("dare: opt has an invalid value -- setting to B");
-	opt = "B";
+        warning ("dare: opt has an invalid value -- setting to B");
+        opt = "B";
       endif
     else
       opt = "B";
     endif
 
     ## dimension checks are done in is_controllable, is_observable
     if (is_controllable (a, b) == 0)
       warning ("dare: a,b are not controllable");
diff --git a/scripts/control/dcgain.m b/scripts/control/dcgain.m
--- a/scripts/control/dcgain.m
+++ b/scripts/control/dcgain.m
@@ -1,32 +1,32 @@
 ## Copyright (C) 1993, 1994, 1995 John W. Eaton
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{gm} =} dcgain(@var{sys}@{, tol@})
-##       Returns dc-gain matrix. If dc-gain is infinite
-##       an empty matrix is returned.
-##       The argument @var{tol} is an optional tolerance for the condition
-##       number of @var{A}-Matrix in @var{sys} (default @var{tol} = 1.0e-10)
+## @deftypefn {Function File} {@var{gm} =} dcgain (@var{sys}@{, tol@})
+## Returns dc-gain matrix. If dc-gain is infinite
+## an empty matrix is returned.
+## The argument @var{tol} is an optional tolerance for the condition
+## number of @var{A}-Matrix in @var{sys} (default @var{tol} = 1.0e-10)
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 1, 1997
 
 function gm = dcgain (sys, tol)
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
diff --git a/scripts/control/demomarsyas.m b/scripts/control/demomarsyas.m
--- a/scripts/control/demomarsyas.m
+++ b/scripts/control/demomarsyas.m
@@ -1,38 +1,38 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 page_screen_output = 1;
 opt = 0;
 QUITOPT = 7;
 while (opt != QUITOPT)
   opt = menu("Marsyas interface update demo:", ...
-	"run Marsyas on the magnetically suspended ball example", ...
+        "run Marsyas on the magnetically suspended ball example", ...
         "load continuous time marsyas example system", ...
-	"load discrete-time marsyas example system", ...
-	"bode plot of loaded system (MIMO)", ...
+        "load discrete-time marsyas example system", ...
+        "bode plot of loaded system (MIMO)", ...
         "bode plot of loaded system (SISO)", ...
-	"Design example", ...
-	"Quit");
+        "Design example", ...
+        "Quit");
 
   if(opt == 1)
     cmd = "system(""marsyas mag1d.mar"")";
     run_cmd
     cmd = "system(""marplot -i"")";
     run_cmd
   elseif(opt == 2)
     cmd = "ballsys = margetsys();";
@@ -83,34 +83,34 @@ while (opt != QUITOPT)
       disp("State and input penalties:")
       Q = eye(2)
       R = 1
       disp("Controlled input is input 1");
       cmd="Ksys = lqg(ballsys1,Sigw,Sigv,Q,R,1);";
       run_cmd
       disp("sysout(Ksys);");
       sysout(Ksys);
-      
+
       disp("marsyas conversion: output in scalar form:")
       cmd = "maroutsys(Ksys, ""ball_controller"",""scalar"");";
       run_cmd
       disp("here's the output file:")
       prompt
       system("more ball_controller.mar");
-      
+
       disp("marsyas conversion: output in state space form: (default option;")
       disp("the ""ss"" in the command below is not needed)")
       cmd = "maroutsys(Ksys, ""ball_controller_ss"",""ss"");";
       run_cmd
       disp("here's the output file:")
       prompt
       system("more ball_controller_ss.mar");
-      
+
       disp("marsyas conversion: output in transfer function form:")
       cmd = "maroutsys(Ksys, ""ball_controller_tf"",""tf"")"
       run_cmd
       disp("here's the output file:")
       prompt
       system("more ball_controller_tf.mar");
-  
+
     endif
   endif
 endwhile
diff --git a/scripts/control/dezero.m b/scripts/control/dezero.m
--- a/scripts/control/dezero.m
+++ b/scripts/control/dezero.m
@@ -12,27 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Functin File} {@var{t} =} dezero (@var{s})
 ## Remove trailing blank entries and all zero entries from the string s.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 
 ## Adapted from deblank by A. S. Hodel (a.s.hodel@eng.auburn.edu)
-## 	(the name dezero is a reference to the Fermilab D0 experiment,
-##      where my sister did her PhD research) 
+##      (the name dezero is a reference to the Fermilab D0 experiment,
+##      where my sister did her PhD research)
 
 function t = dezero (s)
 
   ## delete the next line if you're stubbornly going to use dezero.
   error("dezero is no longer supported.");
 
   if (nargin != 1)
     usage ("dezero (s)");
diff --git a/scripts/control/dgkfdemo.m b/scripts/control/dgkfdemo.m
--- a/scripts/control/dgkfdemo.m
+++ b/scripts/control/dgkfdemo.m
@@ -1,53 +1,53 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File } { } dgkfdemo ( ) 
+## @deftypefn {Function File} {} dgkfdemo ()
 ## Octave Controls toolbox demo: H2/Hinfinity options demos
-##@end deftypefn
- 
+## @end deftypefn
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function dgkfdemo ()
- 
+
   save_val = page_screen_output;
   page_screen_output = 1;
   while (1)
     clc
     sel = 0;
     while (sel > 10 || sel < 1)
       sel = menu ("Octave H2/Hinfinity options demo",
-		  "LQ regulator",
-		  "LG state estimator",
-		  "LQG optimal control design",
-		  "H2 gain of a system",
-		  "H2 optimal controller of a system",
-		  "Hinf gain of a system",
-		  "Hinf optimal controller of a SISO system",
-		  "Hinf optimal controller of a MIMO system",
-		  "Discrete-time Hinf optimal control by bilinear transform",
-		  "Return to main demo menu");
+                  "LQ regulator",
+                  "LG state estimator",
+                  "LQG optimal control design",
+                  "H2 gain of a system",
+                  "H2 optimal controller of a system",
+                  "Hinf gain of a system",
+                  "Hinf optimal controller of a SISO system",
+                  "Hinf optimal controller of a MIMO system",
+                  "Discrete-time Hinf optimal control by bilinear transform",
+                  "Return to main demo menu");
     endwhile
     if (sel == 1)
       disp("Linear/Quadratic regulator design:")
       disp("Compute optimal state feedback via the lqr command...")
       help lqr
       disp(" ")
       disp("Example:")
       A = [0, 1; -2, -1]
@@ -94,17 +94,17 @@ function dgkfdemo ()
       help lqg
       disp("Example system")
       A = [0, 1; .5, .5];
       B = [0; 2];
       G = eye(2)
       C = [1, 1];
       sys = ss2sys(A, [B, G], C);
       sys = syssetsignals(sys,"in", ...
-		       ["control input"; "disturbance 1"; "disturbance 2"]);
+                       ["control input"; "disturbance 1"; "disturbance 2"]);
       sysout(sys)
       prompt
       disp("Filtering/estimator parameters:")
       SigW = eye(2)
       SigV = 1
       prompt
       disp("State space (LQR) parameters Q and R are:")
       Q = eye(2)
@@ -262,17 +262,17 @@ function dgkfdemo ()
       run_cmd
       disp("Check: look at max value of magntude Bode plot of Asys:");
       [M,P,w] = bode(Asys);
       xlabel("Omega")
       ylabel("|Asys(j omega)| ")
       grid();
       semilogx(w,M);
       disp(["Max magnitude is ",num2str(max(M)), ...
-	", compared with gmin=",num2str(gmin)," and gmax=", ...
+        ", compared with gmin=",num2str(gmin)," and gmax=", ...
         num2str(gmax),"."])
       prompt
       disp("Example 2: unstable plant")
       cmd = "A = [0, 1; 2, 1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
       disp("Pack into system format:")
       cmd = "Bsys = ss2sys(A,B,C);";
       run_cmd
@@ -343,12 +343,12 @@ function dgkfdemo ()
     elseif (sel == 9)
       disp("Discrete time H-infinity control via bilinear transform");
       prompt
       dhinfdemo
     elseif (sel == 10)
       return
     endif
     prompt
-  endwhile  
+  endwhile
   page_screen_output = save_val;
 
 endfunction
diff --git a/scripts/control/dgram.m b/scripts/control/dgram.m
--- a/scripts/control/dgram.m
+++ b/scripts/control/dgram.m
@@ -1,47 +1,46 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{m} =} dgram ( @var{a}, @var{b})
-##  Return controllability grammian of discrete time system
+## @deftypefn {Function File} {@var{m} =} dgram (@var{a}, @var{b})
+## Return controllability grammian of discrete time system
 ## @example
 ##   x(k+1) = a x(k) + b u(k)
 ## @end example
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @var{n} by @var{n} matrix
 ## @item b
 ## @var{n} by @var{m} matrix
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @var{m} (@var{n} by @var{n}) satisfies
 ## @example
-##  a m a' - m + b*b' = 0 
+##  a m a' - m + b*b' = 0
 ## @end example
-## 
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function m = dgram (a, b)
 
   ## let dlyap do the error checking...
diff --git a/scripts/control/dhinfdemo.m b/scripts/control/dhinfdemo.m
--- a/scripts/control/dhinfdemo.m
+++ b/scripts/control/dhinfdemo.m
@@ -25,53 +25,53 @@
 ##             This method works quite well if the sampling
 ##             period is "small" compared to the plant time
 ##             constants.
 ##
 ## This is a script file for OCTAVE.
 ## ------------------------------------------------------------
 ##
 ## continuous plant:
-##	             1
-##	G(s) = --------------
-##	       (s + 2)(s + 1)
+##                   1
+##      G(s) = --------------
+##             (s + 2)(s + 1)
 ##
 ## discretised plant with ZOH (Sampling period = Ts = 1 second)
 ##
-##	           0.39958z + 0.14700
-##	G(s) = --------------------------
-##	       (z - 0.36788)(z - 0.13533)
+##                 0.39958z + 0.14700
+##      G(s) = --------------------------
+##             (z - 0.36788)(z - 0.13533)
 ##
-##	                         +----+
-##	    -------------------->| W1 |---> v1
-##	z   |                    +----+
-##	----|-------------+                   || T   ||     => min.
-##	    |             |                       vz   infty
-##	    |    +---+    v      +----+
-##	    *--->| G |--->O--*-->| W2 |---> v2
-##	    |    +---+       |   +----+
-##	    |                |
-##	    |    +---+       |
-##	    -----| K |<-------
-##	         +---+
+##                               +----+
+##          -------------------->| W1 |---> v1
+##      z   |                    +----+
+##      ----|-------------+                   || T   ||     => min.
+##          |             |                       vz   infty
+##          |    +---+    v      +----+
+##          *--->| G |--->O--*-->| W2 |---> v2
+##          |    +---+       |   +----+
+##          |                |
+##          |    +---+       |
+##          -----| K |<-------
+##               +---+
 ##
-##	W1 and W2 are the robustness and performancs weighting
+##      W1 and W2 are the robustness and performancs weighting
 ##       functions
 
 ## K. Mueller, <mueller@ifr.ing.tu-bs.de>
 ## Technical University of Braunschweig, IfR
 
 echo off
 disp(" ");
 disp("    --------------------------------------------------");
 disp("    Discrete H_infinity optimal control for the plant:");
 disp(" ");
-disp("	                   0.39958z + 0.14700");
-disp("	        G(s) = --------------------------");
-disp("	               (z - 0.36788)(z - 0.13533)");
+disp("                     0.39958z + 0.14700");
+disp("          G(s) = --------------------------");
+disp("                 (z - 0.36788)(z - 0.13533)");
 disp("    --------------------------------------------------");
 disp(" ");
 
 disp("sampling time:")
 cmd = "Ts = 1.0;";
 disp(cmd);
 eval(cmd);
 disp("weighting on actuator value u");
diff --git a/scripts/control/dlqe.m b/scripts/control/dlqe.m
--- a/scripts/control/dlqe.m
+++ b/scripts/control/dlqe.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{l}, @var{m}, @var{p}, @var{e}] =} dlqe (@var{a}, @var{g}, @var{c}, @var{sigw}, @var{sigv}, @var{z})
 ## Construct the linear quadratic estimator (Kalman filter) for the
 ## discrete time system
@@ -26,67 +26,67 @@
 ##  x_{k+1} = A x_k + B u_k + G w_k
 ## $$
 ## $$
 ##  y_k = C x_k + D u_k + w_k
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## x[k+1] = A x[k] + B u[k] + G w[k]
 ##   y[k] = C x[k] + D u[k] + w[k]
 ## @end example
-## 
+##
 ## @end ifinfo
 ## where @var{w}, @var{v} are zero-mean gaussian noise processes with
 ## respective intensities @code{@var{sigw} = cov (@var{w}, @var{w})} and
 ## @code{@var{sigv} = cov (@var{v}, @var{v})}.
-## 
+##
 ## If specified, @var{z} is @code{cov (@var{w}, @var{v})}.  Otherwise
 ## @code{cov (@var{w}, @var{v}) = 0}.
-## 
+##
 ## The observer structure is
 ## @iftex
 ## @tex
 ## $$
 ##  z_{k+1} = A z_k + B u_k + k (y_k - C z_k - D u_k)
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## z[k+1] = A z[k] + B u[k] + k (y[k] - C z[k] - D u[k])
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## The following values are returned:
-## 
+##
 ## @table @var
 ## @item l
-## The observer gain, 
+## The observer gain,
 ## @iftex
 ## @tex
 ## $(A - ALC)$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{a}@var{l}@var{c}).
 ## @end ifinfo
 ## is stable.
-## 
+##
 ## @item m
 ## The Riccati equation solution.
-## 
+##
 ## @item p
 ## The estimate error covariance after the measurement update.
-## 
+##
 ## @item e
 ## The closed loop poles of
 ## @iftex
 ## @tex
 ## $(A - ALC)$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
diff --git a/scripts/control/dlqr.m b/scripts/control/dlqr.m
--- a/scripts/control/dlqr.m
+++ b/scripts/control/dlqr.m
@@ -1,110 +1,110 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{p}, @var{e}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{z})
 ## Construct the linear quadratic regulator for the discrete time system
 ## @iftex
 ## @tex
 ## $$
 ##  x_{k+1} = A x_k + B u_k
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## x[k+1] = A x[k] + B u[k]
 ## @end example
-## 
+##
 ## @end ifinfo
 ## to minimize the cost functional
 ## @iftex
 ## @tex
 ## $$
 ##  J = \sum x^T Q x + u^T R u
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## J = Sum (x' Q x + u' R u)
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## @var{z} omitted or
 ## @iftex
 ## @tex
 ## $$
 ##  J = \sum x^T Q x + u^T R u + 2 x^T Z u
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## J = Sum (x' Q x + u' R u + 2 x' Z u)
 ## @end example
-## 
+##
 ## @end ifinfo
 ## @var{z} included.
-## 
+##
 ## The following values are returned:
-## 
+##
 ## @table @var
 ## @item k
 ## The state feedback gain,
 ## @iftex
 ## @tex
 ## $(A - B K)$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{b}@var{k})
 ## @end ifinfo
 ## is stable.
-## 
+##
 ## @item p
 ## The solution of algebraic Riccati equation.
-## 
+##
 ## @item e
 ## The closed loop poles of
 ## @iftex
 ## @tex
 ## $(A - B K)$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{b}@var{k}).
 ## @end ifinfo
 ## @end table
 ## @strong{References}
 ## @enumerate
 ## @item Anderson and Moore, Optimal Control: Linear Quadratic Methods,
 ##      Prentice-Hall, 1990, pp. 56-58
-## @item  Kuo, Digital Control Systems, Harcourt Brace Jovanovich, 1992, 
+## @item  Kuo, Digital Control Systems, Harcourt Brace Jovanovich, 1992,
 ##      section 11-5-2.
 ## @end enumerate
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Converted to discrete time by R. B. Tenison
 ## (btenison@eng.auburn.edu) October 1993
diff --git a/scripts/control/dlyap.m b/scripts/control/dlyap.m
--- a/scripts/control/dlyap.m
+++ b/scripts/control/dlyap.m
@@ -1,70 +1,69 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{x} = } dlyap (@var{a}, @var{b})
+## @deftypefn {Function File} {@var{x} =} dlyap (@var{a}, @var{b})
 ## Solve the discrete-time Lyapunov equation
-## 
-##   @strong{Inputs}
-##   @table @var
-##     @item a
-##     @var{n} by @var{n} matrix
-##     @item b
-##     Matrix: @var{n} by @var{n}, @var{n} by @var{m}, or @var{p} by @var{n}.
-##   @end table
-## 
-##   @strong{Outputs}
-##   @var{x}: matrix satisfying appropriate discrete time Lyapunov equation.
-##   Options:
-##   @itemize @bullet
-##     @item @var{b} is square: solve @code{a x a' - x + b = 0}
-##     @item @var{b} is not square: @var{x} satisfies either
-##       @example
-##       a x a' - x + b b' = 0
-##       @end example
-##       @noindent
-##       or
-##       @example
-##  a' x a - x + b' b = 0,
-## 	@end example
-## 	@noindent
-##     whichever is appropriate.
-##   @end itemize
-##   
+##
+## @strong{Inputs}
+## @table @var
+##   @item a
+##   @var{n} by @var{n} matrix
+##   @item b
+##   Matrix: @var{n} by @var{n}, @var{n} by @var{m}, or @var{p} by @var{n}.
+## @end table
+##
+## @strong{Outputs}
+## @var{x}: matrix satisfying appropriate discrete time Lyapunov equation.
+## Options:
+## @itemize @bullet
+## @item @var{b} is square: solve @code{a x a' - x + b = 0}
+## @item @var{b} is not square: @var{x} satisfies either
+## @example
+## a x a' - x + b b' = 0
+## @end example
+## @noindent
+## or
+## @example
+## a' x a - x + b' b = 0,
+## @end example
+## @noindent
+## whichever is appropriate.
+## @end itemize
+##
 ## @strong{Method}
-##   Uses Schur decomposition method as in Kitagawa,
-##     @cite{An Algorithm for Solving the Matrix Equation @var{X} =
-##     @var{F}@var{X}@var{F}' + @var{S}},
-##   International Journal of Control, Volume 25, Number 5, pages 745--753
-##   (1977). 
-## 
+## Uses Schur decomposition method as in Kitagawa,
+## @cite{An Algorithm for Solving the Matrix Equation @var{X} =
+## @var{F}@var{X}@var{F}' + @var{S}},
+## International Journal of Control, Volume 25, Number 5, pages 745--753
+## (1977).
+##
 ## Column-by-column solution method as suggested in
-##   Hammarling, @cite{Numerical Solution of the Stable, Non-Negative
-##   Definite Lyapunov Equation}, IMA Journal of Numerical Analysis, Volume
-##   2, pages 303--323 (1982).
-## 
+## Hammarling, @cite{Numerical Solution of the Stable, Non-Negative
+## Definite Lyapunov Equation}, IMA Journal of Numerical Analysis, Volume
+## 2, pages 303--323 (1982).
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = dlyap (a, b)
 
   if ((n = is_square (a)) == 0)
     warning ("dlyap: a must be square");
   endif
diff --git a/scripts/control/dmr2d.m b/scripts/control/dmr2d.m
--- a/scripts/control/dmr2d.m
+++ b/scripts/control/dmr2d.m
@@ -1,78 +1,79 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{dsys}, @var{fidx}] =} dmr2d (@var{sys}, @var{idx}, @var{sprefix}, @var{Ts2} @{,@var{cuflg}@})
-##  convert a multirate digital system to a single rate digital system
-##  states specified by @var{idx}, @var{sprefix} are sampled at @var{Ts2}, all 
-##   others are assumed sampled at @var{Ts1} = @code{sysgettsam(@var{sys})}.
-## 
+## @deftypefn {Function File} {[@var{dsys}, @var{fidx}] =} dmr2d (@var{sys}, @var{idx}, @var{sprefix}, @var{Ts2} @{,@var{cuflg}@})
+## convert a multirate digital system to a single rate digital system
+## states specified by @var{idx}, @var{sprefix} are sampled at @var{Ts2}, all
+## others are assumed sampled at @var{Ts1} = @code{sysgettsam(@var{sys})}.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
 ## discrete time system;
 ## @code{dmr2d} exits with an error if @var{sys} is not discrete
 ## @item   idx
-## list of states with sampling time @code{sysgettsam(@var{sys})} (may be empty)
+## list of states with sampling time @code{sysgettsam(@var{sys})} (may
+## be empty)
 ## @item   sprefix
-## list of string prefixes of states with sampling time @code{sysgettsam(@var{sys})}
+## list of string prefixes of states with sampling time
+## @code{sysgettsam(@var{sys})}
 ## (may be empty)
 ## @item   Ts2
 ## sampling time of states not specified by @var{idx}, @var{sprefix}
 ## must be an integer multiple of @code{sysgettsam(@var{sys})}
 ## @item   cuflg
-## "constant u flag" if @var{cuflg} is nonzero then the system inputs are 
-##         assumed to be constant over the revised sampling interval @var{Ts2}.
-##         Otherwise, since the inputs can change during the interval
-##         @var{t} in @math{[k Ts2, (k+1) Ts2]}, an additional set of inputs is
-##         included in the revised B matrix so that these intersample inputs
-##         may be included in the single-rate system.
-##         default
-##  @var{cuflg} = 1.
+## "constant u flag" if @var{cuflg} is nonzero then the system inputs are
+## assumed to be constant over the revised sampling interval @var{Ts2}.
+## Otherwise, since the inputs can change during the interval
+## @var{t} in @math{[k Ts2, (k+1) Ts2]}, an additional set of inputs is
+## included in the revised B matrix so that these intersample inputs
+## may be included in the single-rate system.
+## default @var{cuflg} = 1.
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item   dsys
-##  equivalent discrete time system with sampling time @var{Ts2}.
-## 
-##          The sampling time of sys is updated to @var{Ts2}.
-## 
-##          if @var{cuflg}=0 then a set of additional inputs is added to
-##          the system with suffixes _d1, ..., _dn to indicate their
-##          delay from the starting time k @var{Ts2}, i.e.
-##          u = [u_1; u_1_d1; ..., u_1_dn] where u_1_dk is the input
-##              k*Ts1 units of time after u_1 is sampled. (Ts1 is
-##              the original sampling time of discrete time sys and
-##              @var{Ts2} = (n+1)*Ts1)
-## 
+## equivalent discrete time system with sampling time @var{Ts2}.
+##
+## The sampling time of sys is updated to @var{Ts2}.
+##
+## if @var{cuflg}=0 then a set of additional inputs is added to
+## the system with suffixes _d1, ..., _dn to indicate their
+## delay from the starting time k @var{Ts2}, i.e.
+## u = [u_1; u_1_d1; ..., u_1_dn] where u_1_dk is the input
+## k*Ts1 units of time after u_1 is sampled. (Ts1 is
+## the original sampling time of discrete time sys and
+## @var{Ts2} = (n+1)*Ts1)
+##
 ## @item   fidx
 ## indices of "formerly fast" states specified by @var{idx} and @var{sprefix};
 ## these states are updated to the new (slower) sampling interval @var{Ts2}.
 ## @end table
-## 
-## @strong{WARNING} Not thoroughly tested yet; especially when @var{cuflg} == 0.
-## 
+##
+## @strong{WARNING} Not thoroughly tested yet; especially when
+## @var{cuflg} == 0.
 ## @end deftypefn
 
 ## Adapted from c2d by a.s.hodel@eng.auburn.edu
 
 function [dsys, fidx] = dmr2d (sys, idx, sprefix, Ts2, cuflg)
 
   ## parse input arguments
   if(nargin != 4 | nargout > 2)
@@ -99,17 +100,17 @@ function [dsys, fidx] = dmr2d (sys, idx,
 
   elseif(!is_sample(Ts2))
     error(["Ts2=",num2str(Ts2),"; invalid sampling time"]);
 
   endif
 
   ## optional argument: cuflg
   if(nargin <= 4)
-    cuflg = 1;		# default: constant inputs over Ts2 sampling interv.
+    cuflg = 1;          # default: constant inputs over Ts2 sampling interv.
   elseif( !is_scalar(cuflg) )
     error("cuflg must be a scalar")
   elseif( cuflg != 0 | cuflg != 1)
     error(["cuflg = ",num2str(cuflg),", should be 0 or 1"]);
   endif
 
   ## extract  state space information
   [da,db,dc,dd,Ts1,nc,nz,stname,inname,outname,yd] = sys2ss(sys);
@@ -139,17 +140,17 @@ function [dsys, fidx] = dmr2d (sys, idx,
       spk = nth(sprefix,kk);  # get next prefix and length
       spl = length(spk);
 
       ## check each state name
       for ii=1:nz
         sti = nth(stname,ii);  # compare spk with this state name
         if(length(sti) >= spl)
           ## if the prefix matches and ii isn't already in the list, add ii
-          if(strcmp(sti(1:spl),spk) & !any(fidx == ii) ) 
+          if(strcmp(sti(1:spl),spk) & !any(fidx == ii) )
             fidx = sort([fidx,ii]);
           endif
         endif
       endfor
     endfor
   endif
 
   if(nstp == 0)
@@ -217,17 +218,17 @@ function [dsys, fidx] = dmr2d (sys, idx,
     if(oddv)
       a11h = a11h*a11p2;
     endif
     nstpw = (nstpw-oddv)/2;
     if(nstpw > 0.5)
       a11p2 = a11p2*a11p2;    # a11^(next power of 2)
     endif
   endwhile
-  
+
   ## FIXME: this part should probably also use squaring, but
   ## that would require exponentially growing memory.  What do do?
   for kk=2:nstp
     ## update a12 block to sum(a12 + ... + a11^(kk-1)*a12)
     a12w = a11*a12w;
     a12b = a12b + a12w;
 
     ## similar for b1 block (checking for cuflg first!)
diff --git a/scripts/control/dre.m b/scripts/control/dre.m
--- a/scripts/control/dre.m
+++ b/scripts/control/dre.m
@@ -15,86 +15,86 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{tvals},@var{Plist}] =} dre(@var{sys},@var{Q},@var{R},@var{Qf},@var{t0},@var{tf}[,@var{Ptol},@var{maxits}]);
 ## Solve the differential Riccati equation
 ## @ifinfo
-## @example 
+## @example
 ##   -d P/dt = A'P + P A - P B inv(R) B' P + Q
 ##   P(tf) = Qf
-## @example 
+## @example
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## \(-\frac{dP}{dt} = A^{T}P+PA-PBR^{-1}B^{T}P+Q\)
 ## @end tex
 ## @end iftex
 ## for the LTI system sys.  Solution of standard LTI
 ## state feedback optimization
 ##   min \int_{t_0}^{t_f} x' Q x + u' R u dt + x(t_f)' Qf x(t_f)
 ## optimal input is
 ##   u = - inv(R) B' P(t) x
 ## @strong{Inputs}
-## @table 
+## @table
 ## @item sys
-##     continuous time system data structure
+## continuous time system data structure
 ## @item Q
-##     state integral penalty
-## @item R 
-##     input integral penalty
+## state integral penalty
+## @item R
+## input integral penalty
 ## @item Qf
-##     state terminal penalty
+## state terminal penalty
 ## @item t0
 ## @itemx tf
-##     limits on the integral
+## limits on the integral
 ## @item Ptol
-##     tolerance (used to select time samples; see below); default = 0.1
-## @item maxits 
-##     number of refinement iterations (default=10)
+## tolerance (used to select time samples; see below); default = 0.1
+## @item maxits
+## number of refinement iterations (default=10)
 ## @end table
 ## @strong{Outputs}
-## @table 
+## @table
 ## @item tvals
-##     time values at which @var{P}(@var{t}) is computed
+## time values at which @var{P}(@var{t}) is computed
 ## @item Plist
-##     list values of @var{P}(@var{t}); nth(@var{Plist},@var{ii}) 
-##     is @var{P}(@var{tvals}(@var{ii})).
+## list values of @var{P}(@var{t}); nth(@var{Plist},@var{ii})
+## is @var{P}(@var{tvals}(@var{ii})).
 ##
-## @item tvals 
+## @item tvals
 ## @example
-##     is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || < Ptol
-##     for ii=2:length(tvals)
-## @end example 
+## is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || < Ptol
+## for ii=2:length(tvals)
+## @end example
 ## @end table
-## @end deftypefn 
+## @end deftypefn
 
 function [tvals, Plist] = dre (sys, Q, R, Qf, t0, tf, Ptol, maxits)
 
   if(nargin < 6 | nargin > 8 | nargout != 2)
     usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
   elseif(!is_struct(sys))
     error("sys must be a system data structure")
   elseif(is_digital(sys))
     error("sys must be a continuous time system")
   elseif(!is_matrix(Q) | !is_matrix(R) | !is_matrix(Qf))
     error("Q, R, and Qf must be matrices.");
   elseif(!is_scalar(t0) | !is_scalar(tf))
     error("t0 and tf must be scalars")
-  elseif(t0 >= tf)		error("t0=%e >= tf=%e",t0,tf);
-  elseif(nargin == 6)		Ptol = 0.1;
-  elseif(!is_scalar(Ptol))	error("Ptol must be a scalar");
-  elseif(Ptol <= 0)		error("Ptol must be positive");
+  elseif(t0 >= tf)              error("t0=%e >= tf=%e",t0,tf);
+  elseif(nargin == 6)           Ptol = 0.1;
+  elseif(!is_scalar(Ptol))      error("Ptol must be a scalar");
+  elseif(Ptol <= 0)             error("Ptol must be positive");
   endif
 
   if(nargin < 8) maxits = 10;
-  elseif(!is_scalar(maxits))	error("maxits must be a scalar");
-  elseif(maxits <= 0)		error("maxits must be positive");
+  elseif(!is_scalar(maxits))    error("maxits must be a scalar");
+  elseif(maxits <= 0)           error("maxits must be positive");
   endif
   maxits = ceil(maxits);
 
   [aa,bb] = sys2ss(sys);
   nn = sysdimensions(sys,"cst");
   mm = sysdimensions(sys,"in");
   pp = sysdimensions(sys,"out");
 
@@ -131,25 +131,25 @@ function [tvals, Plist] = dre (sys, Q, R
       delta_t = tvals(ii-1) - tvals(ii);
       uv = expm(-H*delta_t)*uv_i_minus_1;
       Qi = uv(n1:n2,1:nn)/uv(1:nn,1:nn);
       Plist(ii) = (Qi+Qi')/2;
       ## check error
       Perr = norm(nth(Plist,ii) - nth(Plist,ii-1))/norm(nth(Plist,ii));
       maxerr = max(maxerr,Perr);
       if(Perr > Ptol)
-	new_t = mean(tvals([ii,ii-1]));
-	tvals = [tvals, new_t];
-	done = 0;
+        new_t = mean(tvals([ii,ii-1]));
+        tvals = [tvals, new_t];
+        done = 0;
       endif
     endfor
 
     ## check number of iterations
     maxits = maxits - 1;
     done = done+(maxits==0);
   endwhile
   if(maxerr > Ptol)
     warning("dre: \n\texiting with%4d points, max rel chg. =%e, Ptol=%e\n", ...
-	  tvlen,maxerr,Ptol);
+          tvlen,maxerr,Ptol);
     tvals = tvals(1:length(Plist));
   endif
 
 endfunction
diff --git a/scripts/control/fir2sys.m b/scripts/control/fir2sys.m
--- a/scripts/control/fir2sys.m
+++ b/scripts/control/fir2sys.m
@@ -1,77 +1,77 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =} fir2sys ( @var{num}@{, @var{tsam}, @var{inname}, @var{outname} @} )
-##  construct a system data structure from FIR description
-## 
+## @deftypefn {Function File} {@var{sys} =} fir2sys (@var{num}@{, @var{tsam}, @var{inname}, @var{outname} @})
+## construct a system data structure from FIR description
+##
 ## @strong{Inputs:}
 ## @table @var
 ## @item num
-##  vector of coefficients @math{[c_0 c_1 ... c_n]}
-## of the SISO FIR transfer function 
+## vector of coefficients @math{[c_0 c_1 ... c_n]}
+## of the SISO FIR transfer function
 ## @ifinfo
-## 
+##
 ## C(z) = c0 + c1*z^@{-1@} + c2*z^@{-2@} + ... + znz^@{-n@}
-## 
+##
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## $$C(z) = c0 + c1*z^{-1} + c2*z^{-2} + ... + znz^{-n}$$
 ## @end tex
 ## @end iftex
-## 
+##
 ## @item tsam
-##    sampling time (default: 1)
-## 
+## sampling time (default: 1)
+##
 ## @item inname
 ## name of input signal;  may be a string or a list with a single entry.
-## 
+##
 ## @item outname
-##  name of output signal; may be a string or a list with a single entry.
+## name of output signal; may be a string or a list with a single entry.
 ## @end table
-## 
+##
 ## @strong{Outputs}
-##   @var{sys} (system data structure)
-## 
+## @var{sys} (system data structure)
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys = fir2sys([1 -1 2 4],0.342,"A/D input","filter output");
 ## octave:2> sysout(sys)
 ## Input(s)
 ##         1: A/D input
-## 
+##
 ## Output(s):
 ##         1: filter output (discrete)
-## 
+##
 ## Sampling interval: 0.342
 ## transfer function form:
 ## 1*z^3 - 1*z^2 + 2*z^1 + 4
 ## -------------------------
 ## 1*z^3 + 0*z^2 + 0*z^1 + 0
 ## @end example
 ## @end deftypefn
- 
+
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 ## adapted from tf2sys july 1996
 
 function sys = fir2sys (num, tsam, inname, outname)
 
@@ -80,26 +80,26 @@ function sys = fir2sys (num, tsam, innam
     usage ("sys = fir2sys(num [, tsam, inname, outname])");
   endif
 
   ## let tf2sys do the argument checking
   den = [1,zeros(1,length(num)-1)];
 
   ## check sampling interval (if any)
   if (nargin <= 1)
-    tsam = 1;		# default 
+    tsam = 1;           # default
   elseif (isempty(tsam))
     tsam = 1;
   endif
 
   ## Set name of input
   if (nargin < 3)
     inname = sysdefioname (1, "u");
   endif
 
   ## Set name of output
   if (nargin < 4)
     outname = sysdefioname (1, "y");
   endif
 
   sys = tf2sys (num, den, tsam, inname, outname);
-  
+
 endfunction
diff --git a/scripts/control/frdemo.m b/scripts/control/frdemo.m
--- a/scripts/control/frdemo.m
+++ b/scripts/control/frdemo.m
@@ -1,75 +1,75 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-##  
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
-## @deftypefn {Function File } { } frdemo ( ) 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} frdemo ()
 ## Octave Controls toolbox demo: Frequency Response demo
 ## @end deftypefn
 
 ## Author: David Clem
-## Created: August 15, 1994 
+## Created: August 15, 1994
 ## a s hodel: updated to match new order of ss2zp outputs
 ## J Ingram:  updated for system data structure format August 1996
 
 function frdemo ()
 
   disp("")
   clc
   j = 0;
   while (j != 4)
     disp("");
     j = menu("Octave Controls Systems Toolbox Frequency Response Demo",
              "Bode analysis (bode)",
              "Nyquist analysis (nyquist)",
-	     "Nichols analysis (nichols)", 
+             "Nichols analysis (nichols)",
              "Return to main demo menu");
-   
+
     if (j == 1)
       k1 = 0;
       while (k1 != 4)
         disp("\n");
         clc
 
         k1 = menu("Bode analysis (bode)",
                   "Continuous system bode analysis",
                   "Discrete system bode analysis",
-                  "Bode command description", 
+                  "Bode command description",
                   "Return to frdemo menu");
-       
+
         if( k1 == 1 )
           disp(" ")
-          clc  
+          clc
           disp("\nContinuous system bode analysis\n");
           disp("Example #1:")
           disp("\nConsider the system sys1=");
           sys1=tf2sys([1, 1], [1, 0, -1]);
           sysout(sys1);
           disp("\nPole-zero form can be obtained as follows:")
           cmd = "sysout(sys1,""zp"");";
           run_cmd;
           disp("The systems bode plot is obtained as follows:");
           cmd = "bode(sys1);";
-          run_cmd;  
+          run_cmd;
           disp("\nNotice that bode automatically labels the plots according to")
           disp("the selected input/output combinations.")
           disp(" ")
           disp("If the frequency range is not specified, bode automatically")
           disp("selects a frequency range based on the natural frequencies of")
           disp("of all poles away from s=0 (or z=1 in discrete time).  Bode")
           disp("then checks to make sure that the phase plot is sufficiently")
           disp("smooth that relevant plot behavior is captured.")
@@ -88,49 +88,49 @@ function frdemo ()
           clc
           disp("Example #2, sys2=")
           cmd = "sys2=zp2sys(1, [-1, -5], 10);";
           eval(cmd);
           cmd = "sysout(sys2);";
           eval(cmd);
           disp("\nThe bode plot command is identical to the tf form:")
           cmd = "bode(sys2);";
-          run_cmd;  
+          run_cmd;
           disp("\nThe internal representation of the system is not important;")
           disp("bode automatically sorts it out internally.")
           prompt;
- 
+
           disp("")
           clc
           disp("Example #3, Consider the following state space system sys3=:\n");
           cmd = "sys3=ss2sys([0, 1; -1000, -1001], [0; 1], [0, -891], 1);";
           eval(cmd);
           cmd = "sysout(sys3);";
           eval(cmd);
           disp("\nOnce again, the bode plot command is the same:");
           cmd = "bode(sys3);";
           run_cmd;
           disp("\nSuppose the user is interested in the response of the system");
           disp("defined over the input frequency range of 1 - 1000 rad/s.\n");
           disp("First, a frequency vector is required.  It can be created");
           disp("with the command:\n");
           cmd = "wrange = logspace(log10(1),log10(1000),100);";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
           disp("\nThis creates a logarithmically scaled frequency vector with");
           disp("100 values between 1 and 1000 rad/s\n");
           disp("Then, the bode command includes wrange in the input arguments");
           disp("like this:");
           cmd = "bode(sys3,wrange);";
           run_cmd;
-          prompt; 
+          prompt;
 
           disp("")
           clc
-      	  disp("\nExample #4, The state-space system from example 3 will be");
+          disp("\nExample #4, The state-space system from example 3 will be");
           disp("grouped with the system from example 2 to form a MIMO system");
           disp("The commands to do this grouping are as follows (changing signal");
           disp("names for clarity):");
           cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
           disp(cmd);  eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
           disp(cmd);  eval(cmd);
           cmd = "nn = sysdimensions(sys2);";
@@ -141,128 +141,128 @@ function frdemo ()
           disp(cmd);  eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           disp("The resulting state-space system (after changing signal names");
           disp("in sys2) is");
           cmd = "sysout(sys_mimo)";
           eval(cmd);
           disp("\nNotice that there are now 2 inputs and 2 outputs, and that it did");
- 	  disp("not matter what form the two systems were in when they were grouped.");
+          disp("not matter what form the two systems were in when they were grouped.");
           disp(["\nTo view the system's bode plots, execute the",
-        	" following command:\n"])
+                " following command:\n"])
           cmd = "bode(sys_mimo);";
           run_cmd;
           prompt
           disp("\nTo view the bode plots for selected  channels, the command form changes:")
           cmd = "wrange = [];";
           disp(cmd)
           eval(cmd);
           cmd = "out = 1;";
           disp(cmd)
           eval(cmd);
           cmd = "in = 1;";
           disp(cmd)
           eval(cmd);
           cmd = "bode(sys_mimo,wrange,out,in);";
           run_cmd;
-          disp("\nNotice that this bode plot is the same as the plot from example 2.");         
+          disp("\nNotice that this bode plot is the same as the plot from example 2.");
           prompt
           closeplot
 
         elseif( k1 == 2 )
           disp("")
           clc
           disp("\nDiscrete system bode analysis\n");
           disp("Display bode plots of a discrete SISO system (dbode)\n")
-      	  disp("Example #1, Consider the following discrete transfer");
+          disp("Example #1, Consider the following discrete transfer");
           disp(" function:\n");
           cmd = "sys1 = tf2sys([0.00100502, -0.00099502], [1, -2, 1], 0.001);";
           disp(cmd);
           eval(cmd);
- 	  cmd = "sysout(sys1)";
+          cmd = "sysout(sys1)";
           disp(cmd);
           eval(cmd);
-      	  disp("\nTo examine open loop zeros and poles of the system,");
+          disp("\nTo examine open loop zeros and poles of the system,");
           disp("use the command:\n")
           cmd = "sysout(sys1,""zp"");";
-          run_cmd;	  
-       	  disp("\nTo view the system's bode plots, execute the following");
+          run_cmd;
+          disp("\nTo view the system's bode plots, execute the following");
           disp("command:\n")
-      	  cmd = "bode(sys1);";
+          cmd = "bode(sys1);";
           run_cmd;
           disp("\nNotice (1) the plot label uses exp(jwT) for its title axis. This")
           disp("           allows the user to determine what kind of system was")
           disp("           used to generate the bode plot");
           disp("       (2) the system poles are both at z=1, (break frequency at")
           disp("           jwT = 0); pure integrator poles like this are discarded")
           disp("           by Octave when computing the plot frequency range.")
 
           disp("\nIf magnitude, phase, and frequency data are also desired,");
-          disp(" perform the following command instead:\n"); 		
+          disp(" perform the following command instead:\n");
           disp("[M,P,w]=dbode(num,den,T,wrange).\n Where:");
           disp("M => Bode magnitude response data");
           disp("P => Bode phase response data");
           disp("w => frequencies that M and P were evaluated at");
           disp("sys1 => system data structure")
           disp("T => sample period")
           disp("wrange => optional vector of frequencies")
-          disp("          if wrange is entered in the argument list, the");  
-          disp("	  system will be evaluated at these specific"); 
-          disp(" 	  frequencies\n"); 
+          disp("          if wrange is entered in the argument list, the");
+          disp("          system will be evaluated at these specific");
+          disp("          frequencies\n");
 
           prompt
           disp("")
-          clc    
-          disp("Example #2, Consider the following set of discrete poles and"); 
+          clc
+          disp("Example #2, Consider the following set of discrete poles and");
           disp("zeros:\n")
- 	  cmd = "sys2 = zp2sys([0.99258;0.99745],[0.99961;0.99242],1,0.001);";
+          cmd = "sys2 = zp2sys([0.99258;0.99745],[0.99961;0.99242],1,0.001);";
           disp(cmd);
- 	  eval(cmd);
+          eval(cmd);
           cmd = "sysout(sys2)";
           disp(cmd);
- 	  eval(cmd);
+          eval(cmd);
           disp("\nTo view the system's bode plots, execute the following");
           disp("command:\n")
-      	  cmd = "bode(sys2);";
-          run_cmd;       	  
+          cmd = "bode(sys2);";
+          run_cmd;
           disp("Notice that the bode command is the same in both of the previous");
           disp("examples.  The bode command is also the same for the continuous case.");
           disp("The function, dbode, is no longer used.");
 
           prompt
           disp("")
           clc
           disp("\nExample #3, Now consider the following state space system:\n");
           cmd = "sys3 = ss2sys([.857, .0011; 0, .99930],[1;1],[-.6318, .0057096],5.2, .001);";
           disp(cmd);
           eval(cmd);
           cmd = "sysout(sys3);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's bode plots, execute the following command:\n")
-      	  cmd = "bode(sys3);";
-       	  run_cmd;
+          cmd = "bode(sys3);";
+          run_cmd;
           disp("\nAgain, notice that the bode command is the same regardless of the form");
           disp("of the system.");
           disp("\nSuppose the user is interested in the response of the system");
           disp("defined over the input frequency range of 1 - 1000 rad/s.\n");
           disp("First, a frequency vector is required.  It can be created");
           disp("with the command:\n");
           cmd = "wrange = logspace(log10(1),log10(1000),100);";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
           disp("\nThis creates a logrithmetically scaled frequency vector with");
           disp("100 values between 1 and 1000 rad/s\n");
           disp("Then, the bode command includes wrange in the input arguments");
           disp("like this:");
           cmd = "bode(sys3,wrange);";
           run_cmd;
-          prompt;	  
-          
+          prompt;
+
           disp("")
           clc
           disp("\nExample #4, We will now examine a MIMO state-space system.  Systems");
           disp("two and three will be grouped.");
           cmd = "[nn,nz] = sysdimensions(sys2);";
           disp(cmd); eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
           disp(cmd); eval(cmd);
@@ -271,33 +271,33 @@ function frdemo ()
           cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
           disp(cmd); eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           cmd = "sysout(sys_mimo);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's bode plots, execute the following command:\n")
-      	  cmd = "bode(sys_mimo);";
+          cmd = "bode(sys_mimo);";
           run_cmd;
           prompt
 
           disp("\nThe bode plot of a single channel is viewed as follows:")
           cmd = "wrange = [];";
           disp(cmd)
           eval(cmd);
           cmd = "out = 1;";
           disp(cmd)
           eval(cmd);
           cmd = "in = 1;";
           disp(cmd)
           eval(cmd);
           cmd = "bode(sys_mimo,wrange,out,in);";
           run_cmd;
-          disp("\nNotice that this bode plot is the same as the plot from example 2.");         
+          disp("\nNotice that this bode plot is the same as the plot from example 2.");
           prompt
           closeplot
 
         elseif( k1 == 3 )
           help bode
           prompt
         endif
       endwhile
@@ -308,109 +308,109 @@ function frdemo ()
         disp("\n");
         help nyquist
         prompt;
         disp("")
         clc;
 
         k2 = menu("Nyquist analysis (Nyquist)",
                   "Continuous system nyquist analysis",
-        	  "Discrete system nyquist analysis",
-        	  "Mixed system nyquist analysis",
+                  "Discrete system nyquist analysis",
+                  "Mixed system nyquist analysis",
                   "Return to frdemo menu");
 
         if( k2 == 1 )
           disp("")
           clc
- 	  disp("\nContinuous system nyquist analysis\n");
-      	  disp("Display Nyquist plots of a SISO system (nyquist)\n")
-      	  disp("Example #1, Consider the following transfer function:\n")
+          disp("\nContinuous system nyquist analysis\n");
+          disp("Display Nyquist plots of a SISO system (nyquist)\n")
+          disp("Example #1, Consider the following transfer function:\n")
           cmd = "sys1 = tf2sys(1, [1, 0.8, 1]);";
           disp(cmd);
           eval(cmd);
           disp("To examine the transfer function, use the command:");
           cmd = "sysout(sys1);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the open loop zeros and poles, use the command:");
           cmd = "sysout(sys1,""zp"");";
           run_cmd;
-      	  disp("\nTo view the system""s nyquist plot, execute the following"); 
+          disp("\nTo view the system""s nyquist plot, execute the following");
           disp("command:\n")
-      	  cmd = "nyquist(sys1);";
+          cmd = "nyquist(sys1);";
           run_cmd;
           disp("\nIf the real and imaginary parts of the response are desired,");
           disp("use the following command:");
-       	  disp("command: [R,I,w]=nyquist(sys1);\n");
-      	  disp("If the user desires to evaluate the response in a certain");
+          disp("command: [R,I,w]=nyquist(sys1);\n");
+          disp("If the user desires to evaluate the response in a certain");
           disp("frequency range, he may do so by entering the following:");
           disp("command: [M,P,w]=nyquist(num,den,wrange).\n")
-      	  disp("wrange is a vector of frequencies that spans the desired");
+          disp("wrange is a vector of frequencies that spans the desired");
           disp("viewing range.\n");
-      	  disp("This will be illustrated in the third nyquist example.\n")  
-       	  disp("Variable Description:\n")
-      	  disp("R => real part of response")
-      	  disp("I => imaginary part of response")
-      	  disp("w => frequencies that the transfer function was evaluated at")
-      	  disp("sys1 => system data structure")
-       	  disp("wrange => optional vector of frequencies")
+          disp("This will be illustrated in the third nyquist example.\n")
+          disp("Variable Description:\n")
+          disp("R => real part of response")
+          disp("I => imaginary part of response")
+          disp("w => frequencies that the transfer function was evaluated at")
+          disp("sys1 => system data structure")
+          disp("wrange => optional vector of frequencies")
           disp("          if wrange is entered in the argument list, the");
-          disp("	  system will be evaluated at these specific");
-          disp("          frequencies\n") 
-          prompt 
-          
+          disp("          system will be evaluated at these specific");
+          disp("          frequencies\n")
+          prompt
+
           disp("")
           clc
           disp("Example #2, Consider the following set of poles and zeros:\n")
           cmd = "sys2 = zp2sys([-1;-4],[-2+1.4142i;-2-1.4142i],1);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the poles and zeros, use the command:");
           cmd = "sysout(sys2)";
           disp(cmd);
           eval(cmd);
-      	  disp("\nTo view the system""s nyquist plot, execute the following");
+          disp("\nTo view the system""s nyquist plot, execute the following");
           disp("command:\n")
-      	  cmd = "nyquist(sys2);";
+          cmd = "nyquist(sys2);";
           run_cmd;
           prompt
 
           disp("")
           clc
           disp("\nExample #3, Consider the following state space system:\n")
           cmd = "sys3 = ss2sys([0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1; 0, 0, -20, -12],[0;0;0;1],[50, 100, 0, 0],0);";
           disp(cmd);
-          eval(cmd); 
+          eval(cmd);
           disp("\nTo examine the state-space system, use the command:");
           cmd = "sysout(sys3)";
           disp(cmd);
-          eval(cmd); 	 
+          eval(cmd);
           disp("\nTo examine the poles and zeros, use the command:");
           cmd = "sysout(sys3,""zp"")";
           run_cmd;
-      	  disp("\nTo view the system""s nyquist plot, execute the following");
+          disp("\nTo view the system""s nyquist plot, execute the following");
           disp("commands:\n")
-      	  cmd = "nyquist(sys3);";
+          cmd = "nyquist(sys3);";
           run_cmd;
-          prompt	 
-          
+          prompt
+
           disp("Example #3 (continued), If the user wishes to evaluate the");
           disp("system response over a desired frequency range, he must first");
           disp("create a frequency vector.\n")
-      	  disp("For example, suppose the user is interested in the response");
+          disp("For example, suppose the user is interested in the response");
           disp("of the system defined above over input frequency range of");
           disp("3 - 100 rad/s.\n")
-      	  disp("A frequency vector can be created using the command:\n");
-     	  cmd = "wrange = logspace(log10(3),log10(100),100);";
+          disp("A frequency vector can be created using the command:\n");
+          cmd = "wrange = logspace(log10(3),log10(100),100);";
           disp(cmd);
-          eval(cmd); 
+          eval(cmd);
           disp("\nNyquist can be run again using the frequency vector as");
           disp("follows:\n")
-       	  cmd = "nyquist(sys3,wrange);";
-          run_cmd;	  
+          cmd = "nyquist(sys3,wrange);";
+          run_cmd;
           prompt
 
           disp("")
           clc
           disp("Example #4,  Nyquist can be used for MIMO systems if the system has");
           disp("an equal number of inputs and outputs.  Otherwise, nyquist returns");
           disp("an error.  To examine a MIMO system, systems 2 and 3 will be grouped");
           cmd = "[nn,nz] = sysdimensions(sys2);";
@@ -422,180 +422,180 @@ function frdemo ()
           cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
           disp(cmd); eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           cmd = "sysout(sys_mimo);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot, execute the following command:\n")
-      	  cmd = "nyquist(sys_mimo);";
- 	  run_cmd;
+          cmd = "nyquist(sys_mimo);";
+          run_cmd;
           prompt
           disp("\nTo view the nyquist plots for selected  channels, the command form changes:")
           cmd = "nyquist(sys_mimo,[],1,1);";
           run_cmd;
-          disp("\nNotice that this bode plot is the same as the plot from example 2.");         
+          disp("\nNotice that this bode plot is the same as the plot from example 2.");
           prompt
           closeplot
 
 
 
         elseif( k2 == 2 )
           disp("")
-          clc 
+          clc
           disp("\nDiscrete system nyquist analysis\n");
-      	  disp("Display Nyquist plots of a discrete SISO system (nyquist)\n")
+          disp("Display Nyquist plots of a discrete SISO system (nyquist)\n")
           disp("We will first define a sampling time, T");
           cmd = "T = 0.01;";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
-      	  disp("\nExample #1, Consider the following transfer function:\n")
-      	  cmd = "sys1 = tf2sys([2, -3.4, 1.5],[1, -1.6, 0.8],T);";
-          disp(cmd); 
+          disp("\nExample #1, Consider the following transfer function:\n")
+          cmd = "sys1 = tf2sys([2, -3.4, 1.5],[1, -1.6, 0.8],T);";
+          disp(cmd);
           eval(cmd);
           disp("To examine the transfer function, use the command:");
           cmd = "sysout(sys1);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the open loop zeros and poles, use the command:");
           cmd = "sysout(sys1,""zp"")";
-          disp(cmd); 
-          eval(cmd); 
-      	  disp("\nTo view the system""s nyquist plot, execute the following"); 
+          disp(cmd);
+          eval(cmd);
+          disp("\nTo view the system""s nyquist plot, execute the following");
           disp("command:")
-      	  cmd = "nyquist(sys1);";
+          cmd = "nyquist(sys1);";
           run_cmd;
           disp("To change the range used for the frequency, a frequency");
           disp("is needed.  Suppose the user would like to examine the");
           disp("nyquist plot in the frequency range of 0.01 - 31.6 rad/s.");
           disp("\nThe frequency vector needed to do this is created with the");
           disp("command:");
           cmd = "wrange = logspace(-2,1.5,200);";
-          disp(cmd); 
-          eval(cmd);	
-          disp("\nNyquist can be run again with this frequency vector");     	
+          disp(cmd);
+          eval(cmd);
+          disp("\nNyquist can be run again with this frequency vector");
           cmd = "nyquist(sys1,wrange);";
           run_cmd;
-      	  disp("\nIf the real and imaginary parts of the response are desired,");
-          disp("perform the following command:\n"); 	
+          disp("\nIf the real and imaginary parts of the response are desired,");
+          disp("perform the following command:\n");
           disp("[R,I,w]=nyquist(sys,wrange)\n")
           disp("Variable Description:\n")
           disp("R => real part of response")
-     	  disp("I => imaginary part of response")
-      	  disp("w => frequencies that the transfer function was evaluated at")
+          disp("I => imaginary part of response")
+          disp("w => frequencies that the transfer function was evaluated at")
           disp("sys => The system data structure");
-      	  disp("wrange => optional vector of frequencies")
-      	  disp("          if wrange is entered in the argument list, the");
-          disp("	  system will be evaluated at these specific");
+          disp("wrange => optional vector of frequencies")
+          disp("          if wrange is entered in the argument list, the");
+          disp("          system will be evaluated at these specific");
           prompt
 
           disp("")
           clc
           disp("\nExample #2, Consider the following set of poles and zeros:\n")
-       	  cmd = "sys2 = zp2sys([0.98025 + 0.01397i; 0.98025 - 0.01397i],[0.96079;0.99005],1,T);";
-          disp(cmd); 
+          cmd = "sys2 = zp2sys([0.98025 + 0.01397i; 0.98025 - 0.01397i],[0.96079;0.99005],1,T);";
+          disp(cmd);
           eval(cmd);
           disp("\nTo examine the open loop zeros and poles, use the command:");
           cmd = "sysout(sys2)";
-          disp(cmd); 
-          eval(cmd); 
-      	  disp("\nTo view the system's nyquist plot between the frequencies");
+          disp(cmd);
+          eval(cmd);
+          disp("\nTo view the system's nyquist plot between the frequencies");
           disp("0.01 - 100 rad/s, execute the following commands:\n")
-      	  cmd = "wrange = logspace(-2,2,100);";
-          disp(cmd); 
+          cmd = "wrange = logspace(-2,2,100);";
+          disp(cmd);
           eval(cmd);
-  	  cmd = "nyquist(sys2,wrange);";
+          cmd = "nyquist(sys2,wrange);";
           run_cmd;
           prompt;
-        
+
           disp("")
           clc
           disp("\nExample #3, Consider the following discrete state space");
           disp("system:\n");
           disp("This example will use the same system used in the third");
           disp("example in the continuous nyquist demo.  First, that system");
           disp("will have to be re-entered useing the following commands:\n");
           cmd = "sys3 = ss2sys([0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1; 0, 0, -20, -12],[0;0;0;1],[50, 100, 0, 0],0);";
-          disp(cmd); 
-          eval(cmd); 
+          disp(cmd);
+          eval(cmd);
           disp("\nTo examine the state-space system, use the command:");
           cmd = "sysout(sys3)";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
           disp("\nTo examine the poles and zeros, use the command:");
           cmd = "sysout(sys3,""zp"")";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
           disp("\nTo convert the system to discrete time, we need a sampling");
           disp("time which can be entered like this:");
           cmd = "T = 0.01";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
           disp("\nNow the command, c2d, is used to convert the system from");
           disp("continuous to discrete time, with the following command");
           cmd = "dsys3 = c2d(sys3,T);";
           run_cmd;
           disp("\nTo examine the new discrete state-space system, use the");
           disp("command");
           cmd = "sysout(dsys3);";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
- 	  disp("\nTo examine the new discrete poles and zeros, use the command:");
+          disp("\nTo examine the new discrete poles and zeros, use the command:");
           cmd = "sysout(dsys3,""zp"")";
-          disp(cmd); 
+          disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot, execute the following");
           disp("commands:\n");
- 	  cmd = "gset xrange [-4:2];";
+          cmd = "gset xrange [-4:2];";
           disp(cmd); eval(cmd);
           cmd = "gset yrange [-2.5:2.5];";
           disp(cmd); eval(cmd);
           cmd = "nyquist(dsys3);";
-     	  run_cmd;
-	  disp("Notice that the asymptotes swamp out the behavior of the plot")
+          run_cmd;
+          disp("Notice that the asymptotes swamp out the behavior of the plot")
           disp("near the origin.  You may use interactive nyquist plots")
           disp("to \"zoom in\" on a plot as follows:")
 
           cmd = "atol = 1;";
           disp(cmd)
           eval(cmd)
           cmd = "nyquist(dsys3,[],[],[],atol);";
           run_cmd
           prompt
 
 
           disp("")
           clc
           disp("MIMO SYSTEM:  Nyquist cannot be used for discrete MIMO systems");
           disp("at this time.");
-	  ## cmd = "dsys_mimo = sysgroup(sys2,dsys3);";
-	  ## disp(cmd);
-	  ## eval(cmd);
-	  ## cmd = "sysout(dsys_mimo);";
-	  ## disp(cmd);
-	  ## eval(cmd);
-	  ## disp("\nTo view the system's nyquist plot, execute the following command:\n")
-	  ## cmd = "nyquist(dsys_mimo);";
-	  ## run_cmd; 	  
-	  ## prompt
-	  ## disp("\nTo view the nyquist plots for selected  channels, the command form changes:")
-	  ## cmd = "nyquist(dsys_mimo,[],1,1);";
-	  ## run_cmd;
-	  ## disp("\nNotice that this bode plot is the same as the plot from example 2.");         
+          ## cmd = "dsys_mimo = sysgroup(sys2,dsys3);";
+          ## disp(cmd);
+          ## eval(cmd);
+          ## cmd = "sysout(dsys_mimo);";
+          ## disp(cmd);
+          ## eval(cmd);
+          ## disp("\nTo view the system's nyquist plot, execute the following command:\n")
+          ## cmd = "nyquist(dsys_mimo);";
+          ## run_cmd;
+          ## prompt
+          ## disp("\nTo view the nyquist plots for selected  channels, the command form changes:")
+          ## cmd = "nyquist(dsys_mimo,[],1,1);";
+          ## run_cmd;
+          ## disp("\nNotice that this bode plot is the same as the plot from example 2.");
           prompt
           closeplot
 
-               
+
         elseif( k2 == 3 )
           disp("\nMixed system nyquist analysis\n");
           disp("Nyquist exits with an error if it is passed a ""mixed"" system (one")
           disp("with both continuous and discrete states).  Use c2d or d2c to")
           disp("convert the system to either pure digital or pure continuous form");
         endif
-      endwhile 
+      endwhile
     elseif (j == 3)
       help nichols
       prompt
     endif
   endwhile
 
 endfunction
diff --git a/scripts/control/freqchkw.m b/scripts/control/freqchkw.m
--- a/scripts/control/freqchkw.m
+++ b/scripts/control/freqchkw.m
@@ -1,29 +1,30 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retval} =} freqchkw ( @var{w} ) 
-## Used by @code{freqresp} to check that input frequency vector @var{w} is legal.
+## @deftypefn {Function File} {@var{retval} =} freqchkw (@var{w})
+## Used by @code{freqresp} to check that input frequency vector @var{w}
+## is valid.
 ## Returns boolean value.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function USEW = freqchkw (w)
 
diff --git a/scripts/control/freqresp.m b/scripts/control/freqresp.m
--- a/scripts/control/freqresp.m
+++ b/scripts/control/freqresp.m
@@ -1,46 +1,46 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{out} =} freqresp (@var{sys},@var{USEW}@{,@var{w}@});
-##  Frequency response function - used internally by @code{bode}, @code{nyquist}.
-##  minimal argument checking; "do not attempt to do this at home"
-## 
+## @deftypefn {Function File} {@var{out} =} freqresp (@var{sys}, @var{USEW}@{,@var{w}@});
+## Frequency response function - used internally by @code{bode}, @code{nyquist}.
+## minimal argument checking; "do not attempt to do this at home"
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure
 ## @item USEW
 ## returned by @code{freqchkw}
 ## @item optional
-##  must be present if @var{USEW} is true (nonzero)
+## must be present if @var{USEW} is true (nonzero)
 ## @end table
 ## @strong{Outputs}
 ## @table @var
-## @item @var{out} 
+## @item @var{out}
 ## vector of finite @math{G(j*w)} entries (or @math{||G(j*w)||} for MIMO)
-## @item w 
-## vector of corresponding frequencies 
+## @item w
+## vector of corresponding frequencies
 ## @end table
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 11, 1994
 
 function [ff, w] = freqresp (sys, USEW, w);
 
@@ -70,17 +70,17 @@ function [ff, w] = freqresp (sys, USEW, 
       zer = tzero(sys);
       pol = eig(sys2ss(sys));
     endif
 
     ## get default frequency range
     [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,sysgettsam(sys));
     w = logspace(wmin,wmax,50);
   else
-    w = reshape(w,1,length(w)); 	# make sure it's a row vector
+    w = reshape(w,1,length(w));         # make sure it's a row vector
   endif
 
   ## now get complex values of s or z
   if(DIGITAL)
     jw = exp(i*w*sysgettsam(sys));
   else
     jw = i*w;
   endif
@@ -99,34 +99,34 @@ function [ff, w] = freqresp (sys, USEW, 
 
     ## require proper  transfer function, so now just get poles.
     for ii=(l1+1):length(pol)
       ff = ff ./ (jw - pol(ii));
     endfor
     ff = ff*sysk;
 
   elseif (strcmp(sysgettype(sys),"tf"))
-    ## transfer function form 
+    ## transfer function form
     [num,den] = sys2tf(sys);
     ff = polyval(num,jw)./polyval(den,jw);
   elseif (mm==pp)
     ## The system is square; do state-space form bode plot
     [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
     n = sysn + sysnz;
     for ii=1:length(jw);
       ff(ii) = det(sysc*((jw(ii).*eye(n)-sysa)\sysb)+sysd);
     endfor;
   else
-    ## Must be state space... bode                            
+    ## Must be state space... bode
     [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
     n = sysn + sysnz;
     for ii=1:length(jw);
       ff(ii) = norm(sysc*((jw(ii)*eye(n)-sysa)\sysb)+sysd);
     endfor
-    
+
   endif
 
   w = reshape(w,1,length(w));
   ff = reshape(ff,1,length(ff));
 
   ## restore global variable
   empty_list_elements_ok = save_val;
 endfunction
diff --git a/scripts/control/gram.m b/scripts/control/gram.m
--- a/scripts/control/gram.m
+++ b/scripts/control/gram.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{m} =} gram (@var{a}, @var{b})
-##  Return controllability grammian @var{m} of the continuous time system
-## @math{ dx/dt = a x + b u}.  
-## 
+## @deftypefn {Function File} {@var{m} =} gram (@var{a}, @var{b})
+## Return controllability grammian @var{m} of the continuous time system
+## @math{ dx/dt = a x + b u}.
+##
 ## @var{m} satisfies @math{ a m + m a' + b b' = 0 }.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function m = gram (a, b)
 
   ## let lyap do the error checking...
diff --git a/scripts/control/h2norm.m b/scripts/control/h2norm.m
--- a/scripts/control/h2norm.m
+++ b/scripts/control/h2norm.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{retval} =} h2norm(@var{sys})
+## @deftypefn {Function Fil} {@var{retval} =} h2norm(@var{sys})
 ## Computes the H2 norm of a system data structure (continuous time only)
-## 
+##
 ## Reference:
-##  Doyle, Glover, Khargonekar, Francis, ``State Space Solutions to Standard
-##  H2 and Hinf Control Problems", IEEE TAC August 1989
+## Doyle, Glover, Khargonekar, Francis, ``State Space Solutions to Standard
+## H2 and Hinf Control Problems", IEEE TAC August 1989
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## updated for system data structure by John Ingram November 1996
 
 function h2gain = h2norm (sys)
 
diff --git a/scripts/control/h2syn.m b/scripts/control/h2syn.m
--- a/scripts/control/h2syn.m
+++ b/scripts/control/h2syn.m
@@ -1,68 +1,68 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[K}, @var{gain}, @var{Kc}, @var{Kf}, @var{Pc}, @var{Pf}] = h2syn(@var{Asys}, @var{nu}, @var{ny}, @var{tol})
-##  Design H2 optimal controller per procedure in 
-##  Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
-##  H2 and Hinf Control Problems", IEEE TAC August 1989
-## 
-##  Discrete time control per Zhou, Doyle, and Glover, ROBUST AND OPTIMAL
-##  CONTROL, Prentice-Hall, 1996
-## 
+## @deftypefn {Function File} {[K}, @var{gain}, @var{Kc}, @var{Kf}, @var{Pc}, @var{Pf}] = h2syn(@var{Asys}, @var{nu}, @var{ny}, @var{tol})
+## Design H2 optimal controller per procedure in
+## Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
+## H2 and Hinf Control Problems", IEEE TAC August 1989
+##
+## Discrete time control per Zhou, Doyle, and Glover, ROBUST AND OPTIMAL
+## CONTROL, Prentice-Hall, 1996
+##
 ## @strong{Inputs} input system is passed as either
 ## @table @var
 ## @item Asys
 ## system data structure (see ss2sys, sys2ss)
 ## @itemize @bullet
-## @item controller is implemented for continuous time systems 
-## @item controller is NOT implemented for discrete time systems 
+## @item controller is implemented for continuous time systems
+## @item controller is NOT implemented for discrete time systems
 ## @end itemize
 ## @item nu
 ## number of controlled inputs
 ## @item ny
 ## number of measured outputs
 ## @item tol
 ## threshhold for 0.  Default: 200*eps
 ## @end table
-##  
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item    K
 ## system controller
 ## @item    gain
 ## optimal closed loop gain
 ## @item    Kc
 ## full information control (packed)
 ## @item    Kf
 ## state estimator (packed)
 ## @item    Pc
 ## ARE solution matrix for regulator subproblem
 ## @item    Pf
 ## ARE solution matrix for filter subproblem
 ## @end table
 ## @end deftypefn
- 
+
 ## Updated for System structure December 1996 by John Ingram
 
 function [K, gain, Kc, Kf, Pc, Pf] = h2syn (Asys, nu, ny, tol)
 
   if ((nargin < 3) | (nargin > 4))
     usage("[K,gain, Kc, Kf, Pc, Pf] = h2syn(Asys,nu,ny[,tol])");
   elseif(nargin == 3 )
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny);
@@ -72,20 +72,20 @@ function [K, gain, Kc, Kf, Pc, Pf] = h2s
 
   if (!chkdgkf )
     disp("h2syn: system does not meet required assumptions")
     help is_dgkf
     error("h2syn: exit");
   endif
 
   ## extract dgs information
-  			nw = dgs.nw; 	nu = dgs.nu;
+                        nw = dgs.nw;    nu = dgs.nu;
   A = dgs.A;            Bw = dgs.Bw;    Bu = dgs.Bu;
-  Cz = dgs.Cz;          Dzw = dgs.Dzw;  Dzu = dgs.Dzu;	nz = dgs.nz;
-  Cy = dgs.Cy;          Dyw = dgs.Dyw;  Dyu = dgs.Dyu;	ny = dgs.ny;
+  Cz = dgs.Cz;          Dzw = dgs.Dzw;  Dzu = dgs.Dzu;  nz = dgs.nz;
+  Cy = dgs.Cy;          Dyw = dgs.Dyw;  Dyu = dgs.Dyu;  ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   dflg = dgs.dflg;
 
   if(norm(Dzw,Inf) > norm([Dzw, Dzu ; Dyw, Dyu],Inf)*1e-12)
     warning("h2syn: Dzw nonzero; feedforward not implemented")
     Dzw
     D = [Dzw, Dzu ; Dyw, Dyu]
   endif
@@ -94,17 +94,17 @@ function [K, gain, Kc, Kf, Pc, Pf] = h2s
   Ru = dgs.Ru;         Ry = dgs.Ry;
   [ncstates, ndstates, nout, nin] = sysdimensions(Asys);
   Atsam = sysgettsam(Asys);
   [Ast, Ain, Aout] = sysgetsignals(Asys);
 
   if(dgs.dflg == 0)
     Pc = are(A,Bu*Bu',Cz'*Cz);    # solve control, filtering ARE's
     Pf = are(A',Cy'*Cy,Bw*Bw');
-    F2 = -Bu'*Pc;		  # calculate feedback gains
+    F2 = -Bu'*Pc;                 # calculate feedback gains
     L2 = -Pf*Cy';
 
     AF2 = A + Bu*F2;
     AL2 = A + L2*Cy;
     CzF2 = Cz + (Dzu/Ru)*F2;
     BwL2 = Bw+L2*(Ry\Dyw);
 
   else
@@ -117,17 +117,17 @@ function [K, gain, Kc, Kf, Pc, Pf] = h2s
   nn = ncstates + ndstates;
   In = eye(nn);
   KA = A + Bu*F2 + L2*Cy;
   Kc1 = ss2sys(AF2,Bw,CzF2,zeros(nz,nw));
   Kf1 = ss2sys(AL2,BwL2,F2,zeros(nu,nw));
 
   g1 = h2norm(Kc1);
   g2 = h2norm(Kf1);
-  
+
   ## compute optimal closed loop gain
   gain = sqrt ( g1*g1 + g2*g2 );
 
   if(nargout)
     Kst = strappend(Ast,"_K");
     Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
     Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
 
@@ -136,25 +136,25 @@ function [K, gain, Kc, Kf, Pc, Pf] = h2s
   endif
 
   if (nargout > 2)
     ## system full information control state names
     stname2 = strappend(Ast,"_FI");
 
    ## system full information control input names
    inname2 = strappend(Ast,"_FI_in");
- 
+
     ## system full information control output names
     outname2 = strappend(Aout(1:(nout-ny)),"_FI_out");
 
     nz = rows (Cz);
     nw = columns (Bw);
 
     Kc = ss2sys(AF2, In, CzF2, zeros(nz,nn), Atsam, ...
-	ncstates, ndstates, stname2, inname2, outname2);
+        ncstates, ndstates, stname2, inname2, outname2);
   endif
 
   if (nargout >3)
     ## fix system state estimator state names
     stname3 = strappend(Ast,"_Kf");
 
     ## fix system state estimator input names
     inname3 = strappend(Ast,"_Kf_noise");
diff --git a/scripts/control/hinf_ctr.m b/scripts/control/hinf_ctr.m
--- a/scripts/control/hinf_ctr.m
+++ b/scripts/control/hinf_ctr.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{K} =} hinf_ctr(@var{dgs}, @var{F}, @var{H}, @var{Z}, @var{g})
 ## Called by @code{hinfsyn} to compute the H_inf optimal controller.
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item dgs
 ## data structure returned by @code{is_dgkf}
 ## @item F
 ## @itemx H
 ## feedback and filter gain (not partitioned)
 ## @item g
 ## final gamma value
 ## @end table
 ## @strong{Outputs}
 ## controller K (system data structure)
-## 
+##
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn
-  
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
 ## and non-singular transformations R (on u and y).
 
 function K = hinf_ctr (dgs, F, H, Z, g)
 
   nw = dgs.nw;
   nu = dgs.nu;
   nz = dgs.nz;
   ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
-  
+
   B1  = dgs.Bw;
   B2  = dgs.Bu;
   C1  = dgs.Cz;
   C2  = dgs.Cy;
   C = [C1; C2];
   D11 = dgs.Dzw;
   D12 = dgs.Dzu;
   D21 = dgs.Dyw;
diff --git a/scripts/control/hinfdemo.m b/scripts/control/hinfdemo.m
--- a/scripts/control/hinfdemo.m
+++ b/scripts/control/hinfdemo.m
@@ -27,36 +27,36 @@
 ## 4 deg, kappa = 50 deg).  Inputs: (1) thrust and (2) elevator angle
 ## outputs: (1) airspeed and (2) pitch angle. The discrete system is a
 ## stable and second order.
 ##
 ## @table @asis
 ## @item SISO plant
 ## @display
 ## @group
-##	           s - 2
-##	G(s) = --------------
-##	       (s + 2)(s - 1)
+##                 s - 2
+##      G(s) = --------------
+##             (s + 2)(s - 1)
 ##
-##	                         +----+
-##	    -------------------->| W1 |---> v1
-##	z   |                    +----+
-##	----|-------------+                   || T   ||     => min.
-##	    |             |                       vz   infty
-##	    |    +---+    v   y  +----+
-##	  u *--->| G |--->O--*-->| W2 |---> v2
-##	    |    +---+       |   +----+
-##	    |                |
-##	    |    +---+       |
-##	    -----| K |<-------
-##	         +---+
+##                               +----+
+##          -------------------->| W1 |---> v1
+##      z   |                    +----+
+##      ----|-------------+                   || T   ||     => min.
+##          |             |                       vz   infty
+##          |    +---+    v   y  +----+
+##        u *--->| G |--->O--*-->| W2 |---> v2
+##          |    +---+       |   +----+
+##          |                |
+##          |    +---+       |
+##          -----| K |<-------
+##               +---+
 ## @end group
 ## @end display
-##	W1 und W2 are the robustness and performance weighting
-##       functions
+## W1 und W2 are the robustness and performance weighting
+## functions
 ##
 ## @item MIMO plant
 ## The optimal controller minimizes the H_infinity norm of the
 ## augmented plant P (mixed-sensitivity problem):
 ## @display
 ## @group
 ##      w
 ##       1 -----------+
@@ -81,55 +81,55 @@
 ##                   | z  | = [ P ] * | w  |
 ##                   |  2 |           |  2 |
 ##                   | y  |           | u  |
 ##                   +    +           +    +
 ## @end group
 ## @end display
 ##
 ## @item DISCRETE SYSTEM
-##   This is not a true discrete design. The design is carried out
-##   in continuous time while the effect of sampling is described by
-##   a bilinear transformation of the sampled system.
-##   This method works quite well if the sampling period is "small"
-##   compared to the plant time constants.
+## This is not a true discrete design. The design is carried out
+## in continuous time while the effect of sampling is described by
+## a bilinear transformation of the sampled system.
+## This method works quite well if the sampling period is "small"
+## compared to the plant time constants.
 ##
 ## @item The continuous plant
 ## @display
 ## @group
-##	              1
-##	G (s) = --------------
-##	 k      (s + 2)(s + 1)
+##                    1
+##      G (s) = --------------
+##       k      (s + 2)(s + 1)
 ##
 ## @end group
 ## @end display
 ## is discretised with a ZOH (Sampling period = Ts = 1 second):
 ## @display
 ## @group
-## 
-##	          0.199788z + 0.073498
-##	G(s) = --------------------------
-##	       (z - 0.36788)(z - 0.13534)
+##
+##                0.199788z + 0.073498
+##      G(s) = --------------------------
+##             (z - 0.36788)(z - 0.13534)
 ##
-##	                         +----+
-##	    -------------------->| W1 |---> v1
-##	z   |                    +----+
-##	----|-------------+                   || T   ||     => min.
-##	    |             |                       vz   infty
-##	    |    +---+    v      +----+
-##	    *--->| G |--->O--*-->| W2 |---> v2
-##	    |    +---+       |   +----+
-##	    |                |
-##	    |    +---+       |
-##	    -----| K |<-------
-##	         +---+
+##                               +----+
+##          -------------------->| W1 |---> v1
+##      z   |                    +----+
+##      ----|-------------+                   || T   ||     => min.
+##          |             |                       vz   infty
+##          |    +---+    v      +----+
+##          *--->| G |--->O--*-->| W2 |---> v2
+##          |    +---+       |   +----+
+##          |                |
+##          |    +---+       |
+##          -----| K |<-------
+##               +---+
 ## @end group
 ## @end display
-##	W1 and W2 are the robustness and performancs weighting
-##       functions
+## W1 and W2 are the robustness and performancs weighting
+## functions
 ## @end table
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 30, 1998
 
 yn = [];
 while (length(yn) < 1)
@@ -150,19 +150,19 @@ echo off
 switch (sys_type)
 
   case (1)
     ## siso
     disp(" ");
     disp("    ----------------------------------------------");
     disp("    H_infinity optimal control for the SISO plant:");
     disp(" ");
-    disp("		            s - 2");
-    disp("		G(s) = --------------");
-    disp("		       (s + 2)(s - 1)");
+    disp("                          s - 2");
+    disp("              G(s) = --------------");
+    disp("                     (s + 2)(s - 1)");
     disp(" ");
     disp("    ----------------------------------------------");
     disp(" ");
 
     ## weighting on actuator u
     W1 = wgt1o(0.05, 100.0, 425.0);
     ## weighting on controlled variable y
     W2 = wgt1o(10.0, 0.05, 0.001);
@@ -183,20 +183,20 @@ switch (sys_type)
     damp(GW);
     ## disp(" o Testing H_infinity norm: (hinfnorm does not work)");
     ## hinfnorm(GW);
 
     disp(" ");
     yn = input(" * Plot closed loop step response? [n]: ","S");
     if (length(yn) >= 1)
       if ((yn(1) == "y") || (yn(1) == 'Y'))
-      	disp(" o step responses of T and KS...");
-      	GW = buildssic([1 2; 2 1], [], [1 2], [-2], G, K);
-      	figure(1);
-      	step(GW, 1, 10);
+        disp(" o step responses of T and KS...");
+        GW = buildssic([1 2; 2 1], [], [1 2], [-2], G, K);
+        figure(1);
+        step(GW, 1, 10);
       endif
     endif
 
   case (2)
     ## mimo
     disp(" ");
     disp("    -----------------------------------------------");
     disp("      H_inf optimal control for the jet707 plant");
@@ -222,50 +222,50 @@ switch (sys_type)
     disp(" ");
     disp(" o controller design...");
     K = hinfsyn(P, 2, 2, 0.25, 10.0, 0.005);
 
     disp(" ");
     yn = input(" * Plot closed loop step responses? [n]: ","S");
     if (length(yn) >= 1)
       if ((yn(1) == "y") || (yn(1) == 'Y'))
-      	disp(" o step responses of T and KS...");
-      	GW = buildssic([1 3;2 4;3 1;4 2],[],[1 2 3 4],[-3 -4],G,K);
+        disp(" o step responses of T and KS...");
+        GW = buildssic([1 3;2 4;3 1;4 2],[],[1 2 3 4],[-3 -4],G,K);
 
-      	disp(" ");
-      	disp("  FIGURE 1: speed refence => 1, pitch angle ref. => 0");
-      	disp("  ===================================================");
-      	disp("      y1:  speed                      (should be 1)");
-      	disp("      y2:  pitch            angle (should remain 0)");
-      	disp("      y3:  thrust      (should be a slow transient)");
-      	disp("      y6:  elevator  (should be a faster transient)");
-      	disp(" ");
-      	disp("  FIGURE 2: speed refence => 0, pitch angle ref. => 1");
-      	disp("  ===================================================");
-      	disp("      y1:  speed                  (should remain 0)");
-      	disp("      y2:  pitch                angle (should be 1)");
-      	disp("      y3:  thrust      (should be a slow transient)");
-      	disp("      y6:  elevator  (should be a faster transient)");
-      	disp(" ");
-      	figure(1)
-      	step(GW);
-      	figure(2)
-      	step(GW,2);
+        disp(" ");
+        disp("  FIGURE 1: speed refence => 1, pitch angle ref. => 0");
+        disp("  ===================================================");
+        disp("      y1:  speed                      (should be 1)");
+        disp("      y2:  pitch            angle (should remain 0)");
+        disp("      y3:  thrust      (should be a slow transient)");
+        disp("      y6:  elevator  (should be a faster transient)");
+        disp(" ");
+        disp("  FIGURE 2: speed refence => 0, pitch angle ref. => 1");
+        disp("  ===================================================");
+        disp("      y1:  speed                  (should remain 0)");
+        disp("      y2:  pitch                angle (should be 1)");
+        disp("      y3:  thrust      (should be a slow transient)");
+        disp("      y6:  elevator  (should be a faster transient)");
+        disp(" ");
+        figure(1)
+        step(GW);
+        figure(2)
+        step(GW,2);
       endif
     endif
 
   case (3)
     ## discrete
     disp(" ");
     disp("    --------------------------------------------------");
     disp("    Discrete H_infinity optimal control for the plant:");
     disp(" ");
-    disp("	                   0.199788z + 0.073498");
-    disp("	        G(s) = --------------------------");
-    disp("	               (z - 0.36788)(z - 0.13533)");
+    disp("                         0.199788z + 0.073498");
+    disp("              G(s) = --------------------------");
+    disp("                     (z - 0.36788)(z - 0.13533)");
     disp("    --------------------------------------------------");
     disp(" ");
 
     ## sampling time
     Ts = 1.0;
     ## weighting on actuator value u
     W1 = wgt1o(0.1, 200.0, 50.0);
     ## weighting on controlled variable y
@@ -289,42 +289,42 @@ switch (sys_type)
     disp(" o controller design...");
     [K, gfin, GWC] = hinfsyn(psys, 1, 1, 0.1, 10.0, 0.02);
 
     disp(" ");
     fig_n = 1;
     yn = input(" * Plot magnitudes of W1KS and W2S? [n]: ","S");
     if (length(yn) >= 1)
       if ((yn(1) == "y") || (yn(1) == 'Y'))
-    	disp(" o magnitudes of W1KS and W2S...");
-    	gwx = sysprune(GWC, 1, 1);
-    	mag1 = bode(gwx, ww);
-    	if (columns(mag1) > 1);  mag1 = mag1';  endif
-    	gwx = sysprune(GWC, 2, 1);
-    	mag2 = bode(gwx, ww);
-    	if (columns(mag2) > 1);  mag2 = mag2';  endif
-    	figure(fig_n)
-    	fig_n = fig_n + 1;
-    	gset grid
-    	loglog(ww, [mag1 mag2]);
+        disp(" o magnitudes of W1KS and W2S...");
+        gwx = sysprune(GWC, 1, 1);
+        mag1 = bode(gwx, ww);
+        if (columns(mag1) > 1);  mag1 = mag1';  endif
+        gwx = sysprune(GWC, 2, 1);
+        mag2 = bode(gwx, ww);
+        if (columns(mag2) > 1);  mag2 = mag2';  endif
+        figure(fig_n)
+        fig_n = fig_n + 1;
+        gset grid
+        loglog(ww, [mag1 mag2]);
       endif
     endif
 
     Kd = c2d(K, "bi", Ts);
     GG = buildssic([1 2; 2 1], [], [1 2], [-2], Gd, Kd);
     disp(" o closed loop poles...");
     damp(GG);
 
     disp(" ");
     yn = input(" * Plot closed loop step responses? [n]: ","S");
     if (length(yn) >= 1)
       if ((yn(1) == "y") || (yn(1) == 'Y'))
-    	disp(" o step responses of T and KS...");
-    	figure(fig_n)
-    	step(GG, 1, 10);
+        disp(" o step responses of T and KS...");
+        figure(fig_n)
+        step(GG, 1, 10);
       endif
     endif
 
 endswitch
 
 disp(" o hinfdemo terminated successfully.");
 
 ## KPM-hinfdemo/End
diff --git a/scripts/control/hinfnorm.m b/scripts/control/hinfnorm.m
--- a/scripts/control/hinfnorm.m
+++ b/scripts/control/hinfnorm.m
@@ -1,116 +1,115 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{g}, @var{gmin}, @var{gmax}] =} hinfnorm(@var{sys}@{, @var{tol}, @var{gmin}, @var{gmax}, @var{ptol}@})
+## @deftypefn {Function File} {[@var{g}, @var{gmin}, @var{gmax}] =} hinfnorm(@var{sys}@{, @var{tol}, @var{gmin}, @var{gmax}, @var{ptol}@})
 ##  Computes the H infinity norm of a system data structure.
-## 
+##
 ## @strong{Inputs}
 ## @table @var
-## @item sys 
+## @item sys
 ## system data structure
-## @item tol 
+## @item tol
 ## H infinity norm search tolerance (default: 0.001)
-## @item gmin 
+## @item gmin
 ## minimum value for norm search (default: 1e-9)
-## @item gmax 
+## @item gmax
 ## maximum value for norm search (default: 1e+9)
 ## @item ptol
-##  pole tolerance:
+## pole tolerance:
 ## @itemize @bullet
-## @item if sys is continuous, poles with 
+## @item if sys is continuous, poles with
 ## |real(pole)| < ptol*||H|| (H is appropriate Hamiltonian)
-## are considered to be on the imaginary axis.  
-## 
+## are considered to be on the imaginary axis.
+##
 ## @item if sys is discrete, poles with
 ## |abs(pole)-1| < ptol*||[s1,s2]|| (appropriate symplectic pencil)
 ## are considered to be on the unit circle
-## 
+##
 ## @item Default: 1e-9
 ## @end itemize
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item g
-## Computed gain, within @var{tol} of actual gain.  @var{g} is returned as Inf 
+## Computed gain, within @var{tol} of actual gain.  @var{g} is returned as Inf
 ## if the system is unstable.
 ## @item gmin
 ## @itemx gmax
 ## Actual system gain lies in the interval [@var{gmin}, @var{gmax}]
 ## @end table
-## 
-##  References:
-##  Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
-##     H2 and Hinf control problems", IEEE TAC August 1989
-##  Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
-##     Int. J. Control, vol 54, #5, 1991
-##  Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
-##  $Revision: 1.9 $
+##
+## References:
+## Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
+## H2 and Hinf control problems", IEEE TAC August 1989
+## Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
+## Int. J. Control, vol 54, #5, 1991
+## Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
 ## @end deftypefn
- 
+
 function [g, gmin, gmax] = hinfnorm (sys, tol, gmin, gmax, ptol)
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
   elseif(!is_struct(sys))
     error("Sys must be a system data structure");
   endif
 
   ## set defaults where applicable
   if(nargin < 5)
-    ptol = 1e-9;	# pole tolerance
+    ptol = 1e-9;        # pole tolerance
   endif
   if(nargin < 4)
-    gmax = 1e9;		# max gain value
+    gmax = 1e9;         # max gain value
   endif
 
   dflg = is_digital(sys);
   sys = sysupdate(sys,"ss");
   [A,B,C,D] = sys2ss(sys);
   [n,nz,m,p] = sysdimensions(sys);
 
   ## eigenvalues of A must all be stable
   if(!is_stable(sys))
     warning(["hinfnorm: unstable system (is_stable, ptol=",num2str(ptol), ...
       "), returning Inf"]);
     g = Inf;
   endif
 
   Dnrm = norm(D);
   if(nargin < 3)
-    gmin = max(1e-9,Dnrm); 	# min gain value
+    gmin = max(1e-9,Dnrm);      # min gain value
   elseif(gmin < Dnrm)
     warning(["hinfnorm: setting Gmin=||D||=",num2str(Dnrm)]);
   endif
 
   if(nargin < 2)
-    tol = 0.001;	# convergence measure for gmin, gmax
+    tol = 0.001;        # convergence measure for gmin, gmax
   endif
 
   ## check for scalar input arguments 2...5
-  if( ! (is_scalar(tol) && is_scalar(gmin) 
-	&& is_scalar(gmax) && is_scalar(ptol)) )
+  if( ! (is_scalar(tol) && is_scalar(gmin)
+        && is_scalar(gmax) && is_scalar(ptol)) )
     error("hinfnorm: tol, gmin, gmax, ptol must be scalars");
   endif
 
   In = eye(n+nz);
   Im = eye(m);
   Ip = eye(p);
   ## find the Hinf norm via binary search
   while((gmax/gmin - 1) > tol)
@@ -126,36 +125,36 @@ function [g, gmin, gmax] = hinfnorm (sys
       s1 = [Ak , zeros(nz) ; -Ck, In ];
       s2 = [In, -(B/Rg)*B' ; zeros(nz) , Ak' ];
 
       ## guard against roundoff again: zero out extremely small values
       ## prior to balancing
       s1 = s1 .* (abs(s1) > ptol*norm(s1,"inf"));
       s2 = s2 .* (abs(s2) > ptol*norm(s2,"inf"));
       [cc,dd,s1,s2] = balance(s1,s2);
-      [qza,qzb,zz,pls] = qz(s1,s2,"S");	# ordered qz decomposition
+      [qza,qzb,zz,pls] = qz(s1,s2,"S"); # ordered qz decomposition
       eigerr = abs(abs(pls)-1);
       normH = norm([s1,s2]);
       Hb = [s1, s2];
 
       ## check R - B' X B condition (Iglesias and Glover's paper)
       X = zz((nz+1):(2*nz),1:nz)/zz(1:nz,1:nz);
       dcondfailed = min(real( eig(Rg - B'*X*B)) < ptol);
     else
       Rinv = inv(g*g*Im - (D' * D));
       H = [A + B*Rinv*D'*C,        B*Rinv*B'; ...
            -C'*(Ip + D*Rinv*D')*C, -(A + B*Rinv*D'*C)'];
-      ## guard against roundoff: zero out extremely small values prior 
+      ## guard against roundoff: zero out extremely small values prior
       ## to balancing
       H = H .* (abs(H) > ptol*norm(H,"inf"));
       [DD,Hb] = balance(H);
       pls = eig(Hb);
       eigerr = abs(real(pls));
       normH = norm(H);
-      dcondfailed = 0;		# digital condition; doesn't apply here
+      dcondfailed = 0;          # digital condition; doesn't apply here
     endif
     if( (min(eigerr) <= ptol * normH) | dcondfailed)
       gmin = g;
     else
       gmax = g;
     endif
   endwhile
 endfunction
diff --git a/scripts/control/hinfsyn.m b/scripts/control/hinfsyn.m
--- a/scripts/control/hinfsyn.m
+++ b/scripts/control/hinfsyn.m
@@ -1,89 +1,89 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{K}, @var{g}, @var{GW}, @var{Xinf}, @var{Yinf}] =} hinfsyn(@var{Asys}, @var{nu}, @var{ny}, @var{gmin}, @var{gmax}, @var{gtol}@{, @var{ptol}, @var{tol}@})
-## 
+## @deftypefn {Function File} {[@var{K}, @var{g}, @var{GW}, @var{Xinf}, @var{Yinf}] =} hinfsyn(@var{Asys}, @var{nu}, @var{ny}, @var{gmin}, @var{gmax}, @var{gtol}@{, @var{ptol}, @var{tol}@})
+##
 ## @strong{Inputs} input system is passed as either
 ## @table @var
 ## @item Asys
 ## system data structure (see ss2sys, sys2ss)
 ## @itemize @bullet
-## @item controller is implemented for continuous time systems 
+## @item controller is implemented for continuous time systems
 ## @item controller is NOT implemented for discrete time systems  (see
 ## bilinear transforms in @code{c2d}, @code{d2c})
 ## @end itemize
 ## @item nu
 ## number of controlled inputs
 ## @item ny
 ## number of measured outputs
 ## @item gmin
 ## initial lower bound on H-infinity optimal gain
 ## @item gmax
 ## initial upper bound on H-infinity optimal gain
 ## @item gtol
 ## gain threshhold.  Routine quits when gmax/gmin < 1+tol
 ## @item ptol
 ## poles with abs(real(pole)) < ptol*||H|| (H is appropriate
-## Hamiltonian) are considered to be on the imaginary axis.  
+## Hamiltonian) are considered to be on the imaginary axis.
 ## Default: 1e-9
 ## @item tol
 ## threshhold for 0.  Default: 200*eps
-## 
+##
 ## @var{gmax}, @var{min}, @var{tol}, and @var{tol} must all be postive scalars.
-## @end table 
+## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item K
 ## system controller
 ## @item g
 ## designed gain value
 ## @item GW
 ## closed loop system
 ## @item Xinf
 ## ARE solution matrix for regulator subproblem
 ## @item Yinf
 ## ARE solution matrix for filter subproblem
 ## @end table
-## 
+##
 ## @enumerate
 ## @item Doyle, Glover, Khargonekar, Francis, "State Space Solutions
-##      to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
-## 
+## to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
+##
 ## @item Maciejowksi, J.M., "Multivariable feedback design,"
-##      Addison-Wesley, 1989, ISBN 0-201-18243-2
-## 
+## Addison-Wesley, 1989, ISBN 0-201-18243-2
+##
 ## @item Keith Glover and John C. Doyle, "State-space formulae for all
-##      stabilizing controllers that satisfy and h-infinity-norm bound
-##      and relations to risk sensitivity,"
-##      Systems & Control Letters 11, Oct. 1988, pp 167-172.
+## stabilizing controllers that satisfy and h-infinity-norm bound
+## and relations to risk sensitivity,"
+## Systems & Control Letters 11, Oct. 1988, pp 167-172.
 ## @end enumerate
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Updated for Packed system structures December 1996 by John Ingram
-## 
+##
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
 ## and non-singular transformations R (on u and y).
 
 function [K, g, GW, Xinf, Yinf] = hinfsyn (Asys, nu, ny, gmin, gmax, gtol, ptol, tol)
 
   if( (nargin < 1) | (nargin > 8) )
     usage("[K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)");
@@ -94,40 +94,40 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
   elseif(!is_sample(tol))
     error("tol must be a positive scalar.")
   endif
   if(nargin < 7)
     ptol = 1e-9;
   elseif(!is_sample(ptol))
     error("hinfsyn: ptol must be a positive scalar");
   endif
-    
+
   if(!is_sample(gmax) | !is_sample(gmin) | !is_sample(gtol) )
     error(["hinfsyn: gmax=",num2str(gmax),", gmin=",num2str(gmin), ...
       "gtol=",num2str(gtol), " must be positive scalars."])
   endif
 
   [chkdgkf,dgs] = is_dgkf(Asys,nu,ny,tol);
 
   if (! chkdgkf )
     disp("hinfsyn: system does not meet required assumptions")
     help is_dgkf
     error("hinfsyn: exit");
   endif
 
   ## extract dgs information
-  			nw = dgs.nw;	nu = dgs.nu;
-  A = dgs.A;		B1 = dgs.Bw;	B2 = dgs.Bu;
-  C1 = dgs.Cz;		D11 = dgs.Dzw;	D12 = dgs.Dzu;		nz = dgs.nz;
-  C2 = dgs.Cy;		D21 = dgs.Dyw;	D22 = dgs.Dyu;		ny = dgs.ny;
+                        nw = dgs.nw;    nu = dgs.nu;
+  A = dgs.A;            B1 = dgs.Bw;    B2 = dgs.Bu;
+  C1 = dgs.Cz;          D11 = dgs.Dzw;  D12 = dgs.Dzu;          nz = dgs.nz;
+  C2 = dgs.Cy;          D21 = dgs.Dyw;  D22 = dgs.Dyu;          ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   dflg = dgs.dflg;
 
   ## recover i/o transformations
-  R12 = dgs.Ru;		R21 = dgs.Ry;
+  R12 = dgs.Ru;         R21 = dgs.Ry;
   [ncstates, ndstates, nin, nout] = sysdimensions(Asys);
   Atsam = sysgettsam(Asys);
   [Ast, Ain, Aout] = sysgetsignals(Asys);
 
   BB = [B1, B2];
   CC = [C1 ; C2];
   DD = [D11, D12 ; D21,  D22];
 
@@ -143,17 +143,17 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
       disp(" *** D matrices indicate a greater value of gamma min.");
       fprintf("     gamma min (%f) superseeded by %f.", gmin, glo);
       glo = xx1;
     else
       glo = gmin;
     endif
     if (glo > ghi)
       fprintf(" *** lower bound of gamma greater than upper bound(%f)", ...
-	      glo, ghi);
+              glo, ghi);
       disp(" *** unable to continue, Goodbye.");
       return;
     endif
 
     de = ghi - glo;
     g = glo;
     search_state = 0;
     iteration_finished = 0;
@@ -167,46 +167,46 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
     printf(".Z. PASS REMARKS\n");
     printf("        ga iax nev ene sym pos iax nev ene sym pos ");
     printf("rho  y/n ======>\n");
     printf("----------------------------------------");
     printf("--------------------------------------\n");
 
     ## set up error messages
     errmesg = list(" o   o   o   o   o  ", ...
-	" #   -   -   -   -  ", ...
-	" o   #   -   -   -  ", ...
-	" o   o   #   -   -  ", ...
-	" o   o   o   #   -  ", ...
-	" o   o   o   o   #  ", ...
-	" -   -   -   -   -  ");
+        " #   -   -   -   -  ", ...
+        " o   #   -   -   -  ", ...
+        " o   o   #   -   -  ", ...
+        " o   o   o   #   -  ", ...
+        " o   o   o   o   #  ", ...
+        " -   -   -   -   -  ");
     errdesx = list("", ...
-	"X im eig.", ...
-	"Hx not Ham.", ...
-	"X inf.eig", ...
-	"X not symm.", ...
-	"X not pos", ...
-	"R singular");
+        "X im eig.", ...
+        "Hx not Ham.", ...
+        "X inf.eig", ...
+        "X not symm.", ...
+        "X not pos", ...
+        "R singular");
 
     errdesy = list(" ", ...
-	"Y im eig.", ...
-	"Hy not Ham.", ...
-	"Y inf.eig", ...
-	"Y not symm.", ...
-	"Y not pos", ...
-	"Rtilde singular");
+        "Y im eig.", ...
+        "Hy not Ham.", ...
+        "Y inf.eig", ...
+        "Y not symm.", ...
+        "Y not pos", ...
+        "Rtilde singular");
 
 
     ## now do the search
     while (!iteration_finished)
       switch (search_state)
-        case (0) 	g = ghi;
-        case (1) 	g = glo;
-        case (2) 	g = 0.5 * (ghi + glo);
-        otherwise 	error(" *** This should never happen!");
+        case (0)        g = ghi;
+        case (1)        g = glo;
+        case (2)        g = 0.5 * (ghi + glo);
+        otherwise       error(" *** This should never happen!");
       endswitch
       printf("%10.4f ", g);
 
       ## computing R and R~
       d1dot = [D11, D12];
       R = zeros(nin, nin);
       R(1:nw,1:nw) = -g*g*eye(nw);
       R = R + d1dot' * d1dot;
@@ -217,24 +217,24 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
 
       [Xinf,x_ha_err] = hinfsyn_ric(A,BB,C1,d1dot,R,ptol);
       [Yinf,y_ha_err] = hinfsyn_ric(A',CC',B1',ddot1',Rtilde,ptol);
 
       ## assume failure for this gamma
       passed = 0;
       rerr="";
       if (!x_ha_err && !y_ha_err)
-	## test spectral radius condition
-	rho = max(abs(eig(Xinf * Yinf)));
-	if (rho < g*g)
-	  ## spectral radius condition passed
-	  passed = 1;
+        ## test spectral radius condition
+        rho = max(abs(eig(Xinf * Yinf)));
+        if (rho < g*g)
+          ## spectral radius condition passed
+          passed = 1;
         else
           rerr = sprintf("rho=%f",rho);
-	endif
+        endif
       endif
 
       if(x_ha_err >= 0 & x_ha_err <= 6)
         printf("%s",nth(errmesg,x_ha_err+1));
         xerr = nth(errdesx,x_ha_err+1);
       else
         error(" *** Xinf fail: this should never happen!");
       endif
@@ -245,40 +245,40 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
       else
         error(" *** Yinf fail: this should never happen!");
       endif
 
       if(passed)  printf("  y all tests passed.\n");
       else        printf("  n %s/%s%s\n",xerr,yerr,rerr);          endif
 
       if (passed && (de/g < gtol))
-	search_state = 3;
+        search_state = 3;
       endif
 
       switch (search_state)
         case (0)
-	  if (!passed)
-	    ## upper bound must pass but did not
-	    fprintf(" *** the upper bound of gamma (%f) is too small.\n", g);
-	    iteration_finished = 2;
-	  else
+          if (!passed)
+            ## upper bound must pass but did not
+            fprintf(" *** the upper bound of gamma (%f) is too small.\n", g);
+            iteration_finished = 2;
+          else
             search_state = 1;
-	  endif
+          endif
         case (1)
-	  if (!passed)      search_state = 2;
-	  else
-	    ## lower bound must not pass but passed
-	    fprintf(" *** the lower bound of gamma (%f) passed.\n", g);
-	    iteration_finished = 3;
-	  endif
+          if (!passed)      search_state = 2;
+          else
+            ## lower bound must not pass but passed
+            fprintf(" *** the lower bound of gamma (%f) passed.\n", g);
+            iteration_finished = 3;
+          endif
         case (2)
           ## Normal case; must check that singular R, Rtilde wasn't the problem.
-	  if ((!passed) & (x_ha_err != 6) & (y_ha_err != 6) ) glo = g;
-	  else         ghi = g;        endif
-	  de = ghi - glo;
+          if ((!passed) & (x_ha_err != 6) & (y_ha_err != 6) ) glo = g;
+          else         ghi = g;        endif
+          de = ghi - glo;
         case (3)       iteration_finished = 1;        # done
         otherwise      error(" *** This should never happen!");
       endswitch
     endwhile
 
     printf("----------------------------------------");
     printf("--------------------------------------\n");
     if (iteration_finished != 1)
@@ -295,20 +295,20 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
       K = hinf_ctr(dgs,F,H,Z,g);
 
       Kst = strappend(Ast,"_K");
       Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
       Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
       [Ac, Bc, Cc, Dc] = sys2ss(K);
       K = ss2sys(Ac,Bc,Cc,Dc,Atsam,ncstates,ndstates,Kst,Kin,Kout);
       if (nargout >= 3)
-	GW = starp(Asys, K);
+        GW = starp(Asys, K);
       endif
     endif
-    
+
   elseif(ndstates)
 
     ## discrete time solution
     error("hinfsyn: discrete-time case not yet implemented")
 
   endif
 
 endfunction
diff --git a/scripts/control/hinfsyn_chk.m b/scripts/control/hinfsyn_chk.m
--- a/scripts/control/hinfsyn_chk.m
+++ b/scripts/control/hinfsyn_chk.m
@@ -1,54 +1,55 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retval}, @var{Pc}, @var{Pf}] =} hinfsyn_chk(@var{A}, @var{B1}, @var{B2}, @var{C1}, @var{C2}, @var{D12}, @var{D21}, @var{g}, @var{ptol})
-##  Called by @code{hinfsyn} to see if gain @var{g} satisfies conditions in 
+## Called by @code{hinfsyn} to see if gain @var{g} satisfies conditions in
 ## Theorem 3 of
-##  Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
-##  H2 and Hinf Control Problems", IEEE TAC August 1989
-##  
-## @strong{Warning} Do not attempt to use this at home; no argument checking performed.
-## 
+## Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
+## H2 and Hinf Control Problems", IEEE TAC August 1989
+##
+## @strong{Warning} Do not attempt to use this at home; no argument
+## checking performed.
+##
 ## @strong{Inputs} as returned by @code{is_dgkf}, except for:
 ## @table @var
-## @item g 
+## @item g
 ## candidate gain level
 ## @item ptol
 ##  as in @code{hinfsyn}
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item retval
 ##  1 if g exceeds optimal Hinf closed loop gain, else 0
 ## @item Pc
 ##  solution of "regulator" H-inf ARE
 ## @item Pf
 ##  solution of "filter" H-inf ARE
 ## @end table
 ## Do not attempt to use this at home; no argument checking performed.
-## @end deftypefn 
+## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 
 function [retval, Pc, Pf] = hinfsyn_chk (A, B1, B2, C1, C2, D12, D21, g, ptol)
 
   Pc = Pf = [];
 
@@ -89,13 +90,13 @@ function [retval, Pc, Pf] = hinfsyn_chk 
     retval = 0;
     return
   endif
   if(max(abs(Pcfeig)) >= g*g)
     disp("hinfsyn_chk: rho(Pf*Pc) is not < g^2");
     retval = 0;
     return
   endif
- 
+
   ## all conditions met.
   retval = 1;
 
 endfunction
diff --git a/scripts/control/hinfsyn_ric.m b/scripts/control/hinfsyn_ric.m
--- a/scripts/control/hinfsyn_ric.m
+++ b/scripts/control/hinfsyn_ric.m
@@ -13,67 +13,68 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{Xinf},@var{x_ha_err}] =} hinfsyn_ric(@var{A},@var{BB}.@var{C1},@var{d1dot},@var{R},@var{ptol})
-## @table 
+## @table
 ## @item forms
 ##        xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
 ##        Ha = [A 0*A; -C1'*C1 -A'] - xx;
-## @end table 
+## @end table
 ## and solves associated Riccati equation
 ## returns error code
 ## @table
 ## @item x_ha_err
 ##    0: successful
 ##    1: Xinf has imaginary eigenvalues
 ##    2: Hx not Hamiltonian
 ##    3: Xinf has inf. eigenvalues (numerical overflow)
 ##    4: Xinf not symmetric
 ##    5: Xinf not positive definite
 ##    6: R is singular
 ## @end table
-## @end deftypefn 
+## @end deftypefn
+
 function [Xinf, x_ha_err] = hinfsyn_ric (A, BB, C1, d1dot, R, ptol)
 
   x_ha_err = 0;        # assume success
-  Xinf = [];		     # default return value
+  Xinf = [];                 # default return value
   n = is_square(A);
   nw = is_square(R);
   if(rank(R) != nw)    x_ha_err = 6;
   else                 # build hamiltonian Ha for X_inf
     xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
     Ha = [A, 0*A; -C1'*C1, -A'] - xx;
     x_ha_err = 0;
     [d, Ha] = balance(Ha);
     [u, s] = schur(Ha, "A");
     rev = real(eig(s));
 
-    if (any(abs(rev) <= ptol))	# eigenvalues near the imaginary axis
+    if (any(abs(rev) <= ptol))  # eigenvalues near the imaginary axis
       x_ha_err = 1;
     elseif (sum(rev > 0) != sum(rev < 0))
       ## unequal number of positive and negative eigenvalues
       x_ha_err = 2;
     else
       ## compute positive Riccati equation solution
       u = d * u;
       Xinf = u(n+1:2*n,1:n) / u(1:n,1:n);
       if (!all(all(finite(Xinf))))
-	x_ha_err = 3;
+        x_ha_err = 3;
       elseif (norm(Xinf-Xinf') >= 10*ptol)
-	## solution not symmetric
-	x_ha_err = 4;
+        ## solution not symmetric
+        x_ha_err = 4;
       else
-	## positive semidefinite?
-	## force symmetry (faster, avoids some convergence problems)
-	Xinf = (Xinf + Xinf')/2;
-	rev = eig(Xinf);
-	if (any(rev <= -ptol))
-	  x_ha_err = 5;
-	endif
+        ## positive semidefinite?
+        ## force symmetry (faster, avoids some convergence problems)
+        Xinf = (Xinf + Xinf')/2;
+        rev = eig(Xinf);
+        if (any(rev <= -ptol))
+          x_ha_err = 5;
+        endif
       endif
     endif
   endif
 endfunction
diff --git a/scripts/control/impulse.m b/scripts/control/impulse.m
--- a/scripts/control/impulse.m
+++ b/scripts/control/impulse.m
@@ -1,47 +1,47 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{y}, @var{t}] =} impulse (@var{sys}@{, @var{inp},@var{tstop}, @var{n}@})
+## @deftypefn {Function File} {[@var{y}, @var{t}] =} impulse (@var{sys}@{, @var{inp},@var{tstop}, @var{n}@})
 ## Impulse response for a linear system.
-##        The system can be discrete or multivariable (or both).
+## The system can be discrete or multivariable (or both).
 ## If no output arguments are specified, @code{impulse}
-##  produces a plot or the impulse response data for system @var{sys}.
-## 
+## produces a plot or the impulse response data for system @var{sys}.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## System data structure.
 ## @item inp
 ## Index of input being excited
 ## @item tstop
-##  The argument @var{tstop} (scalar value) denotes the time when the
-##  simulation should end. 
+## The argument @var{tstop} (scalar value) denotes the time when the
+## simulation should end.
 ## @item n
 ## the number of data values.
-## 
-##  Both parameters @var{tstop} and @var{n} can be omitted and will be
-##  computed from the eigenvalues of the A-Matrix.
+##
+## Both parameters @var{tstop} and @var{n} can be omitted and will be
+## computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## @end deftypefn
 ## @seealso{step and stepimp}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
diff --git a/scripts/control/is_abcd.m b/scripts/control/is_abcd.m
--- a/scripts/control/is_abcd.m
+++ b/scripts/control/is_abcd.m
@@ -1,31 +1,32 @@
 ## Copyright (C) 1997 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retval} =} is_abcd( @var{a}@{, @var{b}, @var{c}, @var{d}@})
-##  Returns @var{retval} = 1 if the dimensions of @var{a}, @var{b}, @var{c}, @var{d}
-##  are compatible, otherwise @var{retval} = 0 with an appropriate diagnostic
-##  message printed to the screen.  The matrices b, c, or d may be omitted.
+## @deftypefn {Function File} {@var{retval} =} is_abcd (@var{a}@{, @var{b}, @var{c}, @var{d}@})
+##  Returns @var{retval} = 1 if the dimensions of @var{a}, @var{b},
+##  @var{c}, @var{d} are compatible, otherwise @var{retval} = 0 with an
+##  appropriate diagnostic message printed to the screen.  The matrices
+##  b, c, or d may be omitted.
 ## @end deftypefn
 ## @seealso{abcddim}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function retval = is_abcd (a, b, c, d)
@@ -38,59 +39,59 @@ function retval = is_abcd (a, b, c, d)
       if (na != ma)
         disp("Matrix A ist not square.")
       endif
     case (2)
       ## A, B only
       [na, ma] = size(a);  [nb, mb] = size(b);
       if (na != ma)
         disp("Matrix A ist not square.")
-	return;
+        return;
       endif
       if (na != nb)
         disp("A and B column dimension different.")
         return;
       endif
     case (3)
       ## A, B, C only
       [na, ma] = size(a);  [nb, mb] = size(b);  [nc, mc] = size(c);
       if (na != ma)
         disp("Matrix A ist not square.")
-	return;
+        return;
       endif
       if (na != nb)
         disp("A and B column dimensions not compatible.")
-	return;
+        return;
       endif
       if (ma != mc)
         disp("A and C row dimensions not compatible.")
-	return;
+        return;
       endif
     case (4)
       ## all matrices A, B, C, D
       [na, ma] = size(a);  [nb, mb] = size(b);
       [nc, mc] = size(c);  [nd, md] = size(d);
       if (na != ma)
         disp("Matrix A ist not square.")
-	return;
+        return;
       endif
       if (na != nb)
         disp("A and B column dimensions not compatible.")
-	return;
+        return;
       endif
       if (ma != mc)
         disp("A and C row dimensions not compatible.")
-	return;
+        return;
       endif
       if (mb != md)
         disp("B and D row dimensions not compatible.")
-	return;
+        return;
       endif
       if (nc != nd)
         disp("C and D column dimensions not compatible.")
-	return;
+        return;
       endif
     otherwise
       usage("retval = is_abcd(a [, b, c, d])")
   endswitch
   ## all tests passed, signal ok.
   retval = 1;
 endfunction
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -1,86 +1,85 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{retval}, @var{U}] =} is_controllable (@var{sys}@{, @var{tol}@})
-## @deftypefnx {Function File } {[@var{retval}, @var{U}] =} is_controllable (@var{a}@{, @var{b} ,@var{tol}@})
+## @deftypefn {Function File} {[@var{retval}, @var{U}] =} is_controllable (@var{sys}@{, @var{tol}@})
+## @deftypefnx {Function File} {[@var{retval}, @var{U}] =} is_controllable (@var{a}@{, @var{b}, @var{tol}@})
 ## Logical check for system controllability.
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure
 ## @item a
 ## @itemx b
 ## @var{n} by @var{n}, @var{n} by @var{m} matrices, respectively
 ## @item tol
 ## optional roundoff paramter.  default value: @code{10*eps}
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item retval
 ## Logical flag; returns true (1) if the system @var{sys} or the
 ## pair (@var{a},@var{b}) is controllable, whichever was passed as input
 ## arguments.
 ## @item U
-##  U is an orthogonal basis of the controllable subspace. 
+##  U is an orthogonal basis of the controllable subspace.
 ## @end table
-## 
+##
 ## @strong{Method}
 ## Controllability is determined by applying Arnoldi iteration with
 ## complete re-orthogonalization to obtain an orthogonal basis of the
 ## Krylov subspace
 ## @example
 ## span ([b,a*b,...,a^@{n-1@}*b]).
 ## @end example
 ## The Arnoldi iteration is executed with @code{krylov} if the system
 ## has a single input; otherwise a block Arnoldi iteration is performed
 ## with @code{krylovb}.
-## 
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
 ## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
-## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
+## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
 function [retval, U] = is_controllable (a, b, tol)
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
-    usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b ,tol})", ...
-	"is_controllable(sys{,tol})");
+    usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b, tol})", ...
+        "is_controllable(sys{,tol})");
   elseif(is_struct(a))
     ## system structure passed.
     sys = sysupdate(a,"ss");
     [a,bs] = sys2ss(sys);
     if(nargin > 2)
       usage("[retval,U] = is_controllable(sys{,tol})");
     elseif(nargin == 2)
-      tol = b;		% get tolerance
+      tol = b;          % get tolerance
       deftol = 0;
     endif
     b = bs;
   else
     ## a,b arguments sent directly.
     if(nargin < 2)
       usage("[retval,U] = is_controllable(a {, b ,tol})");
     else
@@ -89,17 +88,17 @@ function [retval, U] = is_controllable (
   endif
 
   ## check for default tolerance
   if(deftol) tol = 1000*eps; endif
 
   ## check tol dimensions
   if( !is_scalar(tol) )
     error("is_controllable: tol(%dx%d) must be a scalar", ...
-	rows(tol),columns(tol));
+        rows(tol),columns(tol));
   elseif( !is_sample(tol) )
     error("is_controllable: tol=%e must be positive",tol);
   endif
 
   ## check dimensions compatibility
   n = is_square (a);
   [nr, nc] = size (b);
 
diff --git a/scripts/control/is_detectable.m b/scripts/control/is_detectable.m
--- a/scripts/control/is_detectable.m
+++ b/scripts/control/is_detectable.m
@@ -1,50 +1,51 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{retval}, @var{U}] =} is_detectable (@var{a}, @var{c}@{, @var{tol}@})
-## @deftypefnx {Function File } { [@var{retval}, @var{U}] =} is_detectable (@var{sys}@{, @var{tol}@})
-## Test for detactability (observability of unstable modes) of (@var{a},@var{c}).  
-## 
-##  Returns 1 if the system @var{a} or the pair (@var{a},@var{c})is 
-##  detectable, 0 if not.
-## 
+## @deftypefn {Function File} {[@var{retval}, @var{U}] =} is_detectable (@var{a}, @var{c}@{, @var{tol}@})
+## @deftypefnx {Function File} {[@var{retval}, @var{U}] =} is_detectable (@var{sys}@{, @var{tol}@})
+## Test for detactability (observability of unstable modes) of
+## (@var{a},@var{c}).
+##
+## Returns 1 if the system @var{a} or the pair (@var{a},@var{c})is
+## detectable, 0 if not.
+##
 ## @strong{See} @code{is_stabilizable} for detailed description of
 ## arguments and computational method.
-## 
-##  Default: tol = 10*norm(a,'fro')*eps 
-## 
+##
+## Default: tol = 10*norm(a,'fro')*eps
+##
 ## @end deftypefn
 ## @seealso{is_stabilizable, size, rows, columns, length, is_matrix,
 ## is_scalar, and is_vector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_detectable (a, c, tol)
 
-  if( nargin < 1) 
+  if( nargin < 1)
     usage("[retval,U] = is_detectable(a , c {, tol})");
   elseif(is_struct(a))
     ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_detectable(sys {, tol})");
     endif
@@ -52,12 +53,12 @@ function [retval, U] = is_detectable (a,
   elseif(nargin > 3)
     usage("[retval,U] = is_detectable(a , c {, tol})");
   endif
   if(exist("tol"))
     [retval,U] = is_stabilizable (a', c', tol);
   else
     [retval,U] = is_stabilizable (a', c');
   endif
-  
+
 
 endfunction
 
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -1,146 +1,146 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{retval}, @var{dgkf_struct} ] =} is_dgkf (@var{Asys}, @var{nu}, @var{ny}, @var{tol} )
-##  Determine whether a continuous time state space system meets
-##  assumptions of DGKF algorithm.  
-##  Partitions system into: 
+## @deftypefn {Function File} {[@var{retval}, @var{dgkf_struct} ] =} is_dgkf (@var{Asys}, @var{nu}, @var{ny}, @var{tol} )
+## Determine whether a continuous time state space system meets
+## assumptions of DGKF algorithm.
+## Partitions system into:
 ## @example
-## [dx/dt] = [A  | Bw  Bu  ][w] 
+## [dx/dt] = [A  | Bw  Bu  ][w]
 ## [ z   ]   [Cz | Dzw Dzu ][u]
 ## [ y   ]   [Cy | Dyw Dyu ]
 ## @end example
 ## or similar discrete-time system.
 ## If necessary, orthogonal transformations @var{Qw}, @var{Qz} and nonsingular
-##  transformations @var{Ru}, @var{Ry} are applied to respective vectors 
-## @var{w}, @var{z}, @var{u}, @var{y} in order to satisfy DGKF assumptions.  
+## transformations @var{Ru}, @var{Ry} are applied to respective vectors
+## @var{w}, @var{z}, @var{u}, @var{y} in order to satisfy DGKF assumptions.
 ## Loop shifting is used if @var{Dyu} block is nonzero.
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item         Asys
 ## system data structure
 ## @item           nu
 ## number of controlled inputs
 ## @item        ny
-##  number of measured outputs
+## number of measured outputs
 ## @item        tol
-##  threshhold for 0.  Default: 200@var{eps}
+## threshhold for 0.  Default: 200@var{eps}
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    retval
-##  true(1) if system passes check, false(0) otherwise
+## true(1) if system passes check, false(0) otherwise
 ## @item    dgkf_struct
-##  data structure of @code{is_dgkf} results.  Entries:
+## data structure of @code{is_dgkf} results.  Entries:
 ## @table @var
 ## @item      nw
 ## @itemx     nz
-##  dimensions of @var{w}, @var{z}
+## dimensions of @var{w}, @var{z}
 ## @item      A
-##  system @var{A} matrix
+## system @var{A} matrix
 ## @item      Bw
-##  (@var{n} x @var{nw}) @var{Qw}-transformed disturbance input matrix
+## (@var{n} x @var{nw}) @var{Qw}-transformed disturbance input matrix
 ## @item      Bu
-##  (@var{n} x @var{nu}) @var{Ru}-transformed controlled input matrix;
-## 
-##           @strong{Note} @math{B = [Bw Bu] }
+## (@var{n} x @var{nu}) @var{Ru}-transformed controlled input matrix;
+##
+## @strong{Note} @math{B = [Bw Bu] }
 ## @item      Cz
-##  (@var{nz} x @var{n}) Qz-transformed error output matrix
+## (@var{nz} x @var{n}) Qz-transformed error output matrix
 ## @item      Cy
-##  (@var{ny} x @var{n}) @var{Ry}-transformed measured output matrix 
-## 
-##           @strong{Note} @math{C = [Cz; Cy] }
+## (@var{ny} x @var{n}) @var{Ry}-transformed measured output matrix
+##
+## @strong{Note} @math{C = [Cz; Cy] }
 ## @item      Dzu
 ## @item      Dyw
-##  off-diagonal blocks of transformed @var{D} matrix that enter 
+## off-diagonal blocks of transformed @var{D} matrix that enter
 ## @var{z}, @var{y} from @var{u}, @var{w} respectively
 ## @item      Ru
-##  controlled input transformation matrix 
+## controlled input transformation matrix
 ## @item      Ry
-##  observed output transformation matrix
+## observed output transformation matrix
 ## @item      Dyu_nz
-##  nonzero if the @var{Dyu} block is nonzero.
+## nonzero if the @var{Dyu} block is nonzero.
 ## @item      Dyu
-##  untransformed @var{Dyu} block
+## untransformed @var{Dyu} block
 ## @item      dflg
-##  nonzero if the system is discrete-time
-##   @end table
-## @end table 
-## @code{is_dgkf} exits with an error if the system is mixed discrete/continuous
-## 
+## nonzero if the system is discrete-time
+## @end table
+## @end table
+## @code{is_dgkf} exits with an error if the system is mixed
+## discrete/continuous
+##
 ## @strong{References}
 ## @table @strong
 ## @item [1]
-##  Doyle, Glover, Khargonekar, Francis, "State Space Solutions
-##      to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
+## Doyle, Glover, Khargonekar, Francis, "State Space Solutions
+## to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
 ## @item [2]
-##  Maciejowksi, J.M.: "Multivariable feedback design,"
+## Maciejowksi, J.M.: "Multivariable feedback design,"
 ## @end table
-## 
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Updated by John Ingram July 1996 to accept structured systems
 
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
 ## and non-singular transformations R (on u and y) such
 ## that the Dzu and Dyw matrices of the transformed plant
-## 
+##
 ##    ~
 ##    P  (the variable Asys here)
 ##
 ## become
 ##
 ##    ~            -1         T
 ##    D  = Q   D   R   = [ 0 I ]  or [ I ],
 ##     12   12  12  12
 ##
 ##    ~            T
 ##    D  = R   D   Q   = [ 0 I ] or [ I ].
 ##     21   21  21  21
 ##
 ## This transformation together with the algorithm in [1] solves
-## the general problem (see [2] for example). 
+## the general problem (see [2] for example).
 
 function [retval, dgkf_struct] = is_dgkf (Asys, nu, ny, tol)
 
   if (nargin < 3) | (nargin > 4)
     usage("[retval,dgkf_struct] = is_dgkf(Asys,nu,ny{,tol})");
   elseif (! is_scalar(nu) | ! is_scalar(ny) )
     error("is_dgkf: arguments 2 and 3 must be scalars")
   elseif (! is_struct(Asys) )
     error("Argument 1 must be a system data structure");
   endif
   if(nargin < 4)
     tol = 200*eps;
   elseif( !is_sample(tol) )
     error("is_dgkf: tol must be a positive scalar")
   endif
 
-  retval = 1;		# assume passes test
+  retval = 1;           # assume passes test
 
   dflg = is_digital(Asys);
   [Anc, Anz, nin, nout ] = sysdimensions(Asys);
 
   if( Anz == 0 & Anc == 0 )
     error("is_dgkf: no system states");
   elseif( nu >= nin )
     error("is_dgkf: insufficient number of disturbance inputs");
@@ -155,45 +155,45 @@ function [retval, dgkf_struct] = is_dgkf
   ## scale input/output for numerical reasons
   if(norm (C, "fro") * norm (B, "fro") == 0)
     error("||C||*||B|| = 0; no dynamic connnection from inputs to outputs");
   endif
   xx = sqrt(norm(B, Inf) / norm(C, Inf));
   B = B / xx;  C = C * xx;
 
   ## partition matrices
-  			Bw = B(:,1:nw);		Bu = B(:,nw1:nin);
-  Cz = C(1:nz,:);	Dzw = D(1:nz,1:nw);	Dzu = D(1:nz,nw1:nin);
-  Cy = C(nz1:nout,:);	Dyw = D(nz1:nout,1:nw);	Dyu = D(nz1:nout,nw1:nin);
+                        Bw = B(:,1:nw);         Bu = B(:,nw1:nin);
+  Cz = C(1:nz,:);       Dzw = D(1:nz,1:nw);     Dzu = D(1:nz,nw1:nin);
+  Cy = C(nz1:nout,:);   Dyw = D(nz1:nout,1:nw); Dyu = D(nz1:nout,nw1:nin);
 
   ## Check for loopo shifting
   Dyu_nz = (norm(Dyu,Inf) != 0);
   if (Dyu_nz)
     warning("is_dgkf: D22 nonzero; performing loop shifting");
   endif
 
   ## 12 - rank condition at w = 0
   xx =[A, Bu; Cz, Dzu];
   [nr, nc] = size(xx);
   irank = rank(xx);
   if (irank != nc)
     retval = 0;
     warning(sprintf("rank([A Bu; Cz Dzu]) = %d, need %d; n=%d, nz=%d, nu=%d", ...
-	irank,nc,(Anc+Anz),nz,nu));
+        irank,nc,(Anc+Anz),nz,nu));
     warning(" *** 12-rank condition violated at w = 0.");
   endif
 
   ## 21 - rank condition at w = 0
   xx =[A, Bw; Cy, Dyw];
   [nr, nc] = size(xx);
   irank = rank(xx);
   if (irank != nr)
     retval = 0;
     warning(sprintf("rank([A Bw; Cy Dyw]) = %d, need %d; n=%d, ny=%d, nw=%d", ...
-	irank,nr,(Anc+Anz),ny,nw));
+        irank,nr,(Anc+Anz),ny,nw));
     warning(" *** 21-rank condition violated at w = 0.");
   endif
 
   ## can Dzu be transformed to become [0 I]' or [I]?
   ## This ensures a normalized weight
   [Qz, Ru] = qr(Dzu);
   irank = rank(Ru);
   if (irank != nu)
@@ -232,27 +232,27 @@ function [retval, dgkf_struct] = is_dgkf
   Cz  = Qz*Cz;
   Cy  = Ry\Cy;
   C   = [Cz; Cy];
   Dzw = Qz*Dzw*Qw;
   Dzu = Qz*Dzu/Ru;
   Dyw = Ry\Dyw*Qw;
 
   ## pack the return structure
-  dgkf_struct.nw	= nw;
-  dgkf_struct.nu	= nu;
-  dgkf_struct.nz	= nz;
-  dgkf_struct.ny	= ny;
-  dgkf_struct.A		= A;
-  dgkf_struct.Bw	= Bw;
-  dgkf_struct.Bu	= Bu;
-  dgkf_struct.Cz	= Cz;
-  dgkf_struct.Cy	= Cy;
-  dgkf_struct.Dzw	= Dzw;
-  dgkf_struct.Dzu	= Dzu;
-  dgkf_struct.Dyw	= Dyw;
-  dgkf_struct.Dyu	= Dyu;
-  dgkf_struct.Ru	= Ru;
-  dgkf_struct.Ry	= Ry;
-  dgkf_struct.Dyu_nz	= Dyu_nz;
-  dgkf_struct.dflg	= dflg;
+  dgkf_struct.nw        = nw;
+  dgkf_struct.nu        = nu;
+  dgkf_struct.nz        = nz;
+  dgkf_struct.ny        = ny;
+  dgkf_struct.A         = A;
+  dgkf_struct.Bw        = Bw;
+  dgkf_struct.Bu        = Bu;
+  dgkf_struct.Cz        = Cz;
+  dgkf_struct.Cy        = Cy;
+  dgkf_struct.Dzw       = Dzw;
+  dgkf_struct.Dzu       = Dzu;
+  dgkf_struct.Dyw       = Dyw;
+  dgkf_struct.Dyu       = Dyu;
+  dgkf_struct.Ru        = Ru;
+  dgkf_struct.Ry        = Ry;
+  dgkf_struct.Dyu_nz    = Dyu_nz;
+  dgkf_struct.dflg      = dflg;
 
 endfunction
diff --git a/scripts/control/is_digital.m b/scripts/control/is_digital.m
--- a/scripts/control/is_digital.m
+++ b/scripts/control/is_digital.m
@@ -1,50 +1,50 @@
 ## Copyright (C) 1996, 1999 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retval} =} is_digital ( @var{sys})
+## @deftypefn {Function File} {@var{retval} =} is_digital (@var{sys})
 ## Return nonzero if system is digital;
-##  inputs:
-##    sys: system data structure
-##    eflg: 0 [default] exit with an error if system is mixed (continuous and
-##            discrete components)
-##        : 1 print a warning if system is mixed (continuous and discrete)
-##        : 2 silent operation
-##  outputs:
-##    DIGITAL:  0: system is purely continuous
-##           :  1: system is purely discrete
-##           : -1: system is mixed continuous and discrete
+## inputs:
+## sys: system data structure
+## eflg: 0 [default] exit with an error if system is mixed (continuous and
+## discrete components)
+##     : 1 print a warning if system is mixed (continuous and discrete)
+##     : 2 silent operation
+## outputs:
+## DIGITAL:  0: system is purely continuous
+##        :  1: system is purely discrete
+##        : -1: system is mixed continuous and discrete
 ## Exits with an error of sys is a mixed (continuous and discrete) system
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function DIGITAL = is_digital (sys, eflg)
 
   switch(nargin)
   case(1),  eflg = 0;
-  case(2),  
+  case(2),
     if( isempty(find(eflg == [0, 1, 2])) )
       error("Illegal value of eflg=%d (%e)",eflg,eflg);
     endif
   otherwise,
     usage("DIGITAL = is_digital(sys{,eflg})");
   endswitch
 
   ## checked for sampled data system (mixed)
@@ -64,10 +64,10 @@ function DIGITAL = is_digital (sys, eflg
      warning("is_digital: mixed continuous/discrete system");
    endswitch
    dig_sign = -1;
   else
    dig_sign = 1;
   endif
 
   DIGITAL = dig_sign*(tsam > 0);
- 
+
 endfunction
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -1,48 +1,48 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{retval},@var{U}] =} is_observable (@var{a}, @var{c}@{,@var{tol}@})
-## @deftypefnx {Function File } { [@var{retval},@var{U}] =} is_observable (@var{sys}@{, @var{tol}@})
-## Logical check for system observability.  
-##  
-##  Default: tol = 10*norm(a,'fro')*eps
-## 
-##  Returns 1 if the system @var{sys} or the pair (@var{a},@var{c}) is 
-##  observable, 0 if not.
-## 
+## @deftypefn {Function File} {[@var{retval},@var{U}] =} is_observable (@var{a}, @var{c}@{,@var{tol}@})
+## @deftypefnx {Function File} {[@var{retval},@var{U}] =} is_observable (@var{sys}@{, @var{tol}@})
+## Logical check for system observability.
+##
+## Default: tol = 10*norm(a,'fro')*eps
+##
+## Returns 1 if the system @var{sys} or the pair (@var{a},@var{c}) is
+## observable, 0 if not.
+##
 ## @strong{See} @code{is_controllable} for detailed description of arguments
 ## and default values.
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar, and is_vector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_observable (a, c, tol)
 
-  if( nargin < 1) 
+  if( nargin < 1)
     usage("[retval,U] = is_observable(a , c {, tol})");
   elseif(is_struct(a))
     ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_observable(sys {, tol})");
     endif
diff --git a/scripts/control/is_sample.m b/scripts/control/is_sample.m
--- a/scripts/control/is_sample.m
+++ b/scripts/control/is_sample.m
@@ -1,32 +1,32 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retval} =} is_sample (@var{Ts}) 
-##  return true if @var{Ts} is a legal sampling time
-##  (real,scalar, > 0)
+## @deftypefn {Function File} {@var{retval} =} is_sample (@var{Ts})
+## return true if @var{Ts} is a legal sampling time
+## (real,scalar, > 0)
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function out = is_sample (Ts)
 
   out = (is_scalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
 
 endfunction
diff --git a/scripts/control/is_signal_list.m b/scripts/control/is_signal_list.m
--- a/scripts/control/is_signal_list.m
+++ b/scripts/control/is_signal_list.m
@@ -14,17 +14,17 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function flg = is_signal_list(mylist)
 # function flg = is_signal_list(mylist)
 # returns true if mylist is a list of individual strings.
-# 
+#
 flg = is_list(mylist);
 if(flg)
   for ii=1:length(mylist)
     if(!(isstr(nth(mylist,ii)) & rows(nth(mylist,ii)) ==1) )
       flg = 0;
     endif
   endfor
 endif
diff --git a/scripts/control/is_siso.m b/scripts/control/is_siso.m
--- a/scripts/control/is_siso.m
+++ b/scripts/control/is_siso.m
@@ -1,32 +1,32 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retval} =} is_siso (@var{sys}) 
-## return nonzero if the system data structure 
+## @deftypefn {Function File} {@var{retval} =} is_siso (@var{sys})
+## return nonzero if the system data structure
 ## @var{sys} is single-input, single-output.
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996, 1998
 
 function  SISO = is_siso (sys)
 
   if(nargin != 1)
     usage("SISO = is_siso(sys)");
   elseif( !is_struct(sys))
diff --git a/scripts/control/is_stabilizable.m b/scripts/control/is_stabilizable.m
--- a/scripts/control/is_stabilizable.m
+++ b/scripts/control/is_stabilizable.m
@@ -1,54 +1,53 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{retval}, @var{U}] =} is_stabilizable (@var{sys}@{, @var{tol}@})
+## @deftypefn {Function File} {[@var{retval}, @var{U}] =} is_stabilizable (@var{sys}@{, @var{tol}@})
 ## @deftypefnx {Function File } {[@var{retval}, @var{U}] =} is_stabilizable (@var{a}@{, @var{b} ,@var{tol}@})
 ## Logical check for system stabilizability (i.e., all unstable modes are controllable).
-## 
-## 
+##
 ## Test for stabilizability is performed via an ordered Schur decomposition
 ## that reveals the unstable subspace of the system @var{A} matrix.
-##  
-## Returns @code{retval} = 1 if the system, @code{a}, is stabilizable, if the pair 
-## (@code{a}, @code{b}) is stabilizable, or 0 if not.
-##         @code{U} = orthogonal basis of controllable subspace.
-## 
+##
+## Returns @code{retval} = 1 if the system, @code{a}, is stabilizable,
+## if the pair  (@code{a}, @code{b}) is stabilizable, or 0 if not.
+## @code{U} = orthogonal basis of controllable subspace.
+##
 ## Controllable subspace is determined by applying Arnoldi iteration with
 ## complete re-orthogonalization to obtain an orthogonal basis of the
 ## Krylov subspace.
 ## @example
 ##   span ([b,a*b,...,a^   b]).
 ## @end example
 ## tol is a roundoff paramter, set to 200*eps if omitted.
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 ##     is_observable, is_stabilizable, is_detectable
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
-## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
+## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
 function [retval, U] = is_stabilizable (a, b, tol)
 
   if(nargin < 1)        usage("[retval,U] = is_stabilizable(a {, b ,tol})");
   elseif(is_struct(a))
     ## sustem passed.
     if(nargin == 2)
@@ -65,26 +64,26 @@ function [retval, U] = is_stabilizable (
   endif
 
   if(exist("tol"))
     [retval,U] = is_controllable(a,b,tol);
   else
     [retval,U] = is_controllable(a,b);
     tol = 1e2*rows(b)*eps;
   endif
-  
+
   if( !retval & columns(U) > 0)
     ## now use an ordered Schur decomposition to get an orthogonal
     ## basis of the unstable subspace...
     n = rows(a);
     [ua, s] = schur (-(a+eye(n)*tol), "A");
-    k = sum( real(eig(a)) >= 0 );	# count unstable poles 
+    k = sum( real(eig(a)) >= 0 );       # count unstable poles
 
     if( k > 0 )
       ua = ua(:,1:k);
       ## now see if span(ua) is contained in span(U)
       retval = (norm(ua - U*U'*ua) < tol);
     else
-      retval = 1;			# all poles stable
+      retval = 1;                       # all poles stable
     endif
   endif
 
 endfunction
diff --git a/scripts/control/is_stable.m b/scripts/control/is_stable.m
--- a/scripts/control/is_stable.m
+++ b/scripts/control/is_stable.m
@@ -1,42 +1,42 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retval} =} is_stable (@var{a}@{,@var{tol},@var{dflg}@})
-## @deftypefnx {Function File } { @var{retval} =} is_stable (@var{sys}@{,@var{tol}@})
-##  Returns retval = 1 if the matrix @var{a} or the system @var{sys}
+## @deftypefn {Function File} {@var{retval} =} is_stable (@var{a}@{,@var{tol},@var{dflg}@})
+## @deftypefnx {Function File} {@var{retval} =} is_stable (@var{sys}@{,@var{tol}@})
+## Returns retval = 1 if the matrix @var{a} or the system @var{sys}
 ## is stable, or 0 if not.
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item  tol
 ## is a roundoff paramter, set to 200*@var{eps} if omitted.
 ## @item dflg
 ## Digital system flag (not required for system data structure):
 ## @table @code
 ## @item @var{dflg} != 0
 ## stable if eig(a) in unit circle
-## 
+##
 ## @item @var{dflg} == 0
 ## stable if eig(a) in open LHP (default)
 ## @end table
 ## @end table
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
 ## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
@@ -45,32 +45,32 @@
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 ## Updated to simpler form by a.s.hodel 1998
 
 function retval = is_stable (a, tol, disc)
 
   if( (nargin < 1) | (nargin > 3) )   usage("is_stable(a {,tol,disc})");
   elseif(is_struct(a))
     ## system was passed
-    if(nargin < 3)			disc = is_digital(a);
+    if(nargin < 3)                      disc = is_digital(a);
     elseif(disc != is_digital(a))
       warning("is_stable: disc =%d does not match system",disc)
     endif
     sys = sysupdate(a,"ss");
     a = sys2ss(sys);
   else
-    if(nargin < 3)		disc = 0;		endif
+    if(nargin < 3)              disc = 0;               endif
     if(is_square(a) == 0)
       error("A(%dx%d) must be square",rows(A), columns(A));
     endif
   endif
 
-  if(nargin < 2)		tol = 200*eps;
+  if(nargin < 2)                tol = 200*eps;
   elseif( !is_scalar(tol) )
     error("is_stable: tol(%dx%d) must be a scalar",rows(tol),columns(tol));
   endif
- 
+
   l = eig(a);
-  if(disc)	nbad = sum(abs(l)*(1+tol) > 1);
-  else		nbad = sum(real(l)+tol > 0);		endif
-  retval = (nbad == 0);   
+  if(disc)      nbad = sum(abs(l)*(1+tol) > 1);
+  else          nbad = sum(real(l)+tol > 0);            endif
+  retval = (nbad == 0);
 
 endfunction
diff --git a/scripts/control/jet707.m b/scripts/control/jet707.m
--- a/scripts/control/jet707.m
+++ b/scripts/control/jet707.m
@@ -1,36 +1,36 @@
 ## Copyright (C) 1997 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{outsys}  =} jet707 ( ) 
-##  Creates linearized state space model of a Boeing 707-321 aircraft
-##  at v=80m/s. (M = 0.26, Ga0 = -3 deg, alpha0 = 4 deg, kappa = 50 deg)
-##  System inputs:   (1) thrust   and (2) elevator angle
-##  System outputs:  (1) airspeed and (2) pitch angle
-##  Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
+## @deftypefn {Function File} {@var{outsys}  =} jet707 ()
+## Creates linearized state space model of a Boeing 707-321 aircraft
+## at v=80m/s. (M = 0.26, Ga0 = -3 deg, alpha0 = 4 deg, kappa = 50 deg)
+## System inputs:   (1) thrust   and (2) elevator angle
+## System outputs:  (1) airspeed and (2) pitch angle
+## Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
 ## @end deftypefn
 ## @seealso{ord2}
- 
+
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = jet707 ()
 
   if (nargin != 0)
     usage("outsys = jet707()")
   endif
diff --git a/scripts/control/listidx.m b/scripts/control/listidx.m
--- a/scripts/control/listidx.m
+++ b/scripts/control/listidx.m
@@ -16,28 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## [idxvec, errmsg] = listidx(listvar, strlist)
 ## return indices of string entries in listvar that match strings in strlist
 ## Inputs:
 ##   listvar: list of strings to be searched
 ##   strlist: list of strings to be located in listvar.
-## Note: listvar, strlist may be passed as strings or string matrices; 
-##    in this case, each entry is processed by deblank() prior to searching 
+## Note: listvar, strlist may be passed as strings or string matrices;
+##    in this case, each entry is processed by deblank() prior to searching
 ##    for the entries of strlist in listvar.
 ## Outputs:
 ## idxvec
 ##    vector of indices in listvar;
 ##    listvar(idxvec(k)) == strlist(kk).
 ## errmsg
 ##    if strlist contains a string not in listvar, then
 ##    an error message is returned in errmsg.  If only one output
 ##    argument is requested, e.g., idxvec = listidx(listvar, strlist),
-##    then listidx prints errmsg to the screen and exits with 
+##    then listidx prints errmsg to the screen and exits with
 ##    an error.
 ##
 
 function [idxvec,errmsg]  = listidx(listvar,strlist)
 
 if(nargin != 2)
   usage("idxvec = listidx(listvar,strlist)");
 endif
@@ -64,17 +64,17 @@ idxvec = zeros(length(strlist),1);
 errmsg = "";
 if(!is_signal_list(listvar))
   errmsg = "listvar must be a list of strings";
 elseif(!is_signal_list(strlist))
   errmsg = "strlist must be a list of strings";
 endif
 
 if(length(errmsg))
-  if(nargout < 2) error(errmsg); 
+  if(nargout < 2) error(errmsg);
   else return;
   endif
 endif
 
 nsigs = length(listvar);
 for idx = 1:length(strlist)
   signame = nth(strlist,idx);
   for jdx = 1:nsigs
diff --git a/scripts/control/lqe.m b/scripts/control/lqe.m
--- a/scripts/control/lqe.m
+++ b/scripts/control/lqe.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{p}, @var{e}] =} lqe (@var{a}, @var{g}, @var{c}, @var{sigw}, @var{sigv}, @var{z})
 ## Construct the linear quadratic estimator (Kalman filter) for the
 ## continuous time system
@@ -26,58 +26,58 @@
 ##  {dx\over dt} = A x + B u
 ## $$
 ## $$
 ##  y = C x + D u
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## dx
 ## -- = a x + b u
 ## dt
-## 
+##
 ## y = c x + d u
 ## @end example
-## 
+##
 ## @end ifinfo
 ## where @var{w} and @var{v} are zero-mean gaussian noise processes with
 ## respective intensities
-## 
+##
 ## @example
 ## sigw = cov (w, w)
 ## sigv = cov (v, v)
 ## @end example
-## 
+##
 ## The optional argument @var{z} is the cross-covariance
 ## @code{cov (@var{w}, @var{v})}.  If it is omitted,
 ## @code{cov (@var{w}, @var{v}) = 0} is assumed.
-## 
+##
 ## Observer structure is @code{dz/dt = A z + B u + k (y - C z - D u)}
-## 
+##
 ## The following values are returned:
-## 
+##
 ## @table @var
 ## @item k
 ## The observer gain,
 ## @iftex
 ## @tex
 ## $(A - K C)$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{k}@var{c})
 ## @end ifinfo
 ## is stable.
-## 
+##
 ## @item p
 ## The solution of algebraic Riccati equation.
-## 
+##
 ## @item e
 ## The vector of closed loop poles of
 ## @iftex
 ## @tex
 ## $(A - K C)$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -1,54 +1,54 @@
 ## Copyright (C) 1996, 1997 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{K}, @var{Q}, @var{P}, @var{Ee}, @var{Er}] =} lqg(@var{sys}, @var{Sigw}, @var{Sigv}, @var{Q}, @var{R}, @var{in_idx})
+## @deftypefn {Function File} {[@var{K}, @var{Q}, @var{P}, @var{Ee}, @var{Er}] =} lqg(@var{sys}, @var{Sigw}, @var{Sigv}, @var{Q}, @var{R}, @var{in_idx})
 ## Design a linear-quadratic-gaussian optimal controller for the system
 ## @example
 ## dx/dt = A x + B u + G w       [w]=N(0,[Sigw 0    ])
 ##     y = C x + v               [v]  (    0   Sigv ])
 ## @end example
 ## or
-## @example 
+## @example
 ## x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
 ##   y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])
 ## @end example
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item  sys
 ## system data structure
 ## @item  Sigw
 ## @itemx  Sigv
 ## intensities of independent Gaussian noise processes (as above)
 ## @item  Q
 ## @itemx  R
 ## state, control weighting respectively.  Control ARE is
 ## @item  in_idx
 ## indices of controlled inputs
-## 
-##      default: last dim(R) inputs are assumed to be controlled inputs, all
-##               others are assumed to be noise inputs.
+##
+## default: last dim(R) inputs are assumed to be controlled inputs, all
+## others are assumed to be noise inputs.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    K
 ## system data structure format LQG optimal controller (Obtain A,B,C
 ## matrices with @code{sys2ss}, @code{sys2tf}, or @code{sys2zp} as
 ## appropriate)
 ## @item    P
@@ -84,24 +84,24 @@ function [K, Q1, P1, Ee, Er] = lqg (sys,
     input_list = (columns(Sigw)+1):nin;
   endif
 
   if( !(n+nz) )
       error(["lqg: 0 states in system"]);
 
   elseif(nin != columns(Sigw)+ columns(R))
     error(["lqg: sys has ",num2str(nin)," inputs, dim(Sigw)=", ...
-	  num2str(columns(Sigw)),", dim(u)=",num2str(columns(R))])
+          num2str(columns(Sigw)),", dim(u)=",num2str(columns(R))])
 
   elseif(nout != columns(Sigv))
     error(["lqg: sys has ",num2str(nout)," outputs, dim(Sigv)=", ...
-	  num2str(columns(Sigv)),")"])
+          num2str(columns(Sigv)),")"])
   elseif(length(input_list) != columns(R))
     error(["lqg: length(input_list)=",num2str(length(input_list)), ...
-	  ", columns(R)=", num2str(columns(R))]);
+          ", columns(R)=", num2str(columns(R))]);
   endif
 
   varname = list("Sigw","Sigv","Q","R");
   for kk=1:length(varname);
     eval(sprintf("chk = is_square(%s);",nth(varname,kk)));
     if(! chk ) error("lqg: %s is not square",nth(varname,kk)); endif
   endfor
 
diff --git a/scripts/control/lqr.m b/scripts/control/lqr.m
--- a/scripts/control/lqr.m
+++ b/scripts/control/lqr.m
@@ -1,117 +1,117 @@
 ## Copyright (C) 1993, 1994, 1995 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{p}, @var{e}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{z})
 ## construct the linear quadratic regulator for the continuous time system
 ## @iftex
 ## @tex
 ## $$
 ##  {dx\over dt} = A x + B u
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ## dx
 ## -- = A x + B u
 ## dt
 ## @end example
-## 
+##
 ## @end ifinfo
 ## to minimize the cost functional
 ## @iftex
 ## @tex
 ## $$
 ##  J = \int_0^\infty x^T Q x + u^T R u
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ##       infinity
 ##       /
 ##   J = |  x' Q x + u' R u
 ##      /
 ##     t=0
 ## @end example
 ## @end ifinfo
-## 
+##
 ## @noindent
 ## @var{z} omitted or
 ## @iftex
 ## @tex
 ## $$
 ##  J = \int_0^\infty x^T Q x + u^T R u + 2 x^T Z u
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
-## 
+##
 ## @example
 ##       infinity
 ##       /
 ##   J = |  x' Q x + u' R u + 2 x' Z u
 ##      /
 ##     t=0
 ## @end example
-## 
+##
 ## @end ifinfo
 ## @var{z} included.
-## 
+##
 ## The following values are returned:
-## 
+##
 ## @table @var
 ## @item k
 ## The state feedback gain,
 ## @iftex
 ## @tex
 ## $(A - B K)$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{b}@var{k})
 ## @end ifinfo
 ## is stable and minimizes the cost functional
-## 
+##
 ## @item p
 ## The stabilizing solution of appropriate algebraic Riccati equation.
-## 
+##
 ## @item e
 ## The vector of the closed loop poles of
 ## @iftex
 ## @tex
 ## $(A - B K)$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{b}@var{k}).
 ## @end ifinfo
 ## @end table
 ##
-## @strong{Reference} 
+## @strong{Reference}
 ## Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC METHODS,
 ## Prentice-Hall, 1990, pp. 56-58
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993.
 
 function [k, p, e] = lqr (a, b, q, r, s)
diff --git a/scripts/control/lsim.m b/scripts/control/lsim.m
--- a/scripts/control/lsim.m
+++ b/scripts/control/lsim.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } lsim (@var{sys}, @var{u}, @var{t}@{,@var{x0}@})
+## @deftypefn {Function File} {} lsim (@var{sys}, @var{u}, @var{t}@{,@var{x0}@})
 ## Produce output for a linear simulation of a system
-## 
+##
 ## Produces a plot for the output of the system, sys.
-## 
-## U is an array that contains the system's inputs.  Each column in u 
-## corresponds to a different time step.  Each row in u corresponds to a 
-## different input.  T is an array that contains the time index of the 
+##
+## U is an array that contains the system's inputs.  Each column in u
+## corresponds to a different time step.  Each row in u corresponds to a
+## different input.  T is an array that contains the time index of the
 ## system.  T should be regularly spaced.  If initial conditions are required
 ## on the system, the x0 vector should be added to the argument list.
-## 
+##
 ## When the lsim function is invoked with output parameters:
 ## [y,x] = lsim(sys,u,t,[x0])
 ## a plot is not displayed, however, the data is returned in y = system output
 ## and x = system states.
 ## @end deftypefn
- 
+
 ## Author: David Clem
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 ## modified by John Ingram for system format August 1996
 
 function [y, x] = lsim (sys, u, t, x0)
 
   if((nargin < 3)||(nargin > 4))
@@ -48,17 +48,17 @@ function [y, x] = lsim (sys, u, t, x0)
   if(!is_struct(sys))
     error("sys must be in system data structure");
   endif
 
   sys = sysupdate(sys,"ss");
 
   [ncstates, ndstates, nin, nout] = sysdimensions(sys);
   [a,b,c,d] = sys2ss(sys);
-  
+
   if (nargin == 3)     x0 = zeros(columns(a),1);        endif
 
   if(rows(u) ~= length(t))
     error("lsim: There should be an input value (row) for each time instant");
   endif
   if(columns(u) ~= columns(d))
     error("lsim: U and d should have the same number of inputs");
   endif
diff --git a/scripts/control/ltifr.m b/scripts/control/ltifr.m
--- a/scripts/control/ltifr.m
+++ b/scripts/control/ltifr.m
@@ -1,39 +1,39 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{out} =} ltifr (@var{A}, @var{B}, @var{w})
-## @deftypefnx {Function File } {@var{out} =} ltifr (@var{sys}, @var{w})
+## @deftypefn {Function File} {@var{out} =} ltifr (@var{A}, @var{B}, @var{w})
+## @deftypefnx {Function File} {@var{out} =} ltifr (@var{sys}, @var{w})
 ## Linear time invariant frequency response of single input systems
 ## @strong{Inputs}
 ## @table @var
 ## @item A
 ## @itemx B
 ## coefficient matrices of @math{dx/dt = A x + B u}
 ## @item sys
-##  system data structure
+## system data structure
 ## @item w
-##  vector of frequencies
+## vector of frequencies
 ## @end table
 ## @strong{Outputs}
 ## @var{out}
 ## @example
 ##                            -1
 ##             G(s) = (jw I-A) B
 ## @end example
 ## for complex frequencies @math{s = jw}.
@@ -56,34 +56,34 @@ function out = ltifr (a, b, w)
     w = b;
     if(!is_struct(sys))
       error("two arguments: 1st must be a system data structure");
     endif
 
     if (!is_vector(w))
       error("w must be a vector");
     endif
-    
+
     [nn,nz,mm,pp] = sysdimensions(sys);
     if(mm != 1)       error("sys has %d > 1 inputs",mm); endif
 
     [a,b] = sys2ss(sys);
 
-  else  
+  else
 
     if (columns(a) != rows(b)),
       error("ltifr:  A(%dx%d), B(%dx%d) not compatibly dimensioned", ...
-	rows(a), columns(a), rows(b), columns(b));
+        rows(a), columns(a), rows(b), columns(b));
     endif
 
     if(columns(b) != 1)
       error("ltifr: b(%dx%d) must be a single column vector", ...
-	rows(b),columns(b));
+        rows(b),columns(b));
     endif
-  
+
     if (!is_square(a))
       error("ltifr:  A(%dx$d) must be square.",rows(a),columns(a))
     endif
 
   endif
 
   if (!is_vector(w))
     error("w must be a vector");
diff --git a/scripts/control/lyap.m b/scripts/control/lyap.m
--- a/scripts/control/lyap.m
+++ b/scripts/control/lyap.m
@@ -15,68 +15,68 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lyap (@var{a}, @var{b}, @var{c})
 ## @deftypefnx {Function File} {} lyap (@var{a}, @var{b})
-##   Solve the Lyapunov (or Sylvester) equation via the Bartels-Stewart
-##   algorithm (Communications of the ACM, 1972).
-## 
-##   If @var{a}, @var{b}, and @var{c} are specified, then @code{lyap} returns
-##   the solution of the  Sylvester equation
-##   @iftex
-##     @tex
-##       $$ A X + X B + C = 0 $$
-##     @end tex
-##   @end iftex
-##   @ifinfo
-##     @example
-##       a x + x b + c = 0
-##     @end example
-##   @end ifinfo
-##   If only @code{(a, b)} are specified, then @code{lyap} returns the
-##   solution of the Lyapunov equation
-##   @iftex
-##     @tex
-##       $$ A^T X + X A + B = 0 $$
-##     @end tex
-##   @end iftex
-##   @ifinfo
-##     @example
-##       a' x + x a + b = 0
-##     @end example
-##   @end ifinfo
-##   If @var{b} is not square, then @code{lyap} returns the solution of either
-##   @iftex
-##     @tex
-##       $$ A^T X + X A + B^T B = 0 $$
-##     @end tex
-##   @end iftex
-##   @ifinfo
-##     @example
-##       a' x + x a + b' b = 0
-##     @end example
-##   @end ifinfo
-##   @noindent
-##   or
-##   @iftex
-##     @tex
-##       $$ A X + X A^T + B B^T = 0 $$
-##     @end tex
-##   @end iftex
-##   @ifinfo
-##     @example
-##       a x + x a' + b b' = 0
-##     @end example
-##   @end ifinfo
-##   @noindent
-##   whichever is appropriate.
+## Solve the Lyapunov (or Sylvester) equation via the Bartels-Stewart
+## algorithm (Communications of the ACM, 1972).
+##
+## If @var{a}, @var{b}, and @var{c} are specified, then @code{lyap} returns
+## the solution of the  Sylvester equation
+## @iftex
+## @tex
+##   $$ A X + X B + C = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+##     a x + x b + c = 0
+## @end example
+## @end ifinfo
+## If only @code{(a, b)} are specified, then @code{lyap} returns the
+## solution of the Lyapunov equation
+## @iftex
+## @tex
+##   $$ A^T X + X A + B = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+##     a' x + x a + b = 0
+## @end example
+## @end ifinfo
+## If @var{b} is not square, then @code{lyap} returns the solution of either
+## @iftex
+## @tex
+##   $$ A^T X + X A + B^T B = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+##     a' x + x a + b' b = 0
+## @end example
+## @end ifinfo
+## @noindent
+## or
+## @iftex
+## @tex
+##   $$ A X + X A^T + B B^T = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+##     a x + x a' + b b' = 0
+## @end example
+## @end ifinfo
+## @noindent
+## whichever is appropriate.
 ##
 ## Solves by using the Bartels-Stewart algorithm (1972).
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
@@ -92,30 +92,30 @@ function x = lyap (a, b, c)
 
   if (nargin == 2)
 
     ## Transform Lyapunov equation to Sylvester equation form.
 
     if ((m = is_square (b)) == 0)
       if ((m = rows (b)) == n)
 
-	## solve a x + x a' + b b' = 0
+        ## solve a x + x a' + b b' = 0
 
-	b = b * b';
-	a = a';
+        b = b * b';
+        a = a';
       else
 
-	## Try to solve a'x + x a + b' b = 0.
+        ## Try to solve a'x + x a + b' b = 0.
 
-	m = columns (b);
-	b = b' * b;
+        m = columns (b);
+        b = b' * b;
       endif
 
       if (m != n)
-	error ("lyap: a, b not conformably dimensioned");
+        error ("lyap: a, b not conformably dimensioned");
       endif
     endif
 
     ## Set up Sylvester equation.
 
     c = b;
     b = a;
     a = b';
diff --git a/scripts/control/moddemo.m b/scripts/control/moddemo.m
--- a/scripts/control/moddemo.m
+++ b/scripts/control/moddemo.m
@@ -1,35 +1,31 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} moddemo ( inputs ) 
-## @format
-##  Octave Controls toolbox demo: Model Manipulations demo
-##  Written by David Clem August 15, 1994
-## 
-## @end format
+## @deftypefn {Function File} {@var{outputs} =} moddemo (@var{inputs})
+## Octave Controls toolbox demo: Model Manipulations demo
 ## @end deftypefn
- 
+
 ## Author: David Clem
 ## Created: August 15, 1994
 ## a s hodel: updated to reflect updated output order in ss2zp
 
 function moddemo ()
 
   while (1)
     clc
@@ -180,30 +176,30 @@ function moddemo ()
       disp("Variable Description:\n")
       disp("zer,pol => zeros and poles of the transfer function")
       disp("num, den => numerator and denominator of transfer function\n")
       prompt
       clc
       disp("Convert from zero / pole to transfer function (zp2tf)\n")
       disp("Example #1, Consider the following set of zeros and poles:\n")
       zer
-      pol 
+      pol
       prompt
       disp("\nTo find an equivalent transfer function representation for this set")
       disp("of poles and zeros, use the following commands:\n")
       k=1
       disp("\n[num, den] = zp2tf(zer, pol, k)\n")
       prompt
       disp("Results:\n")
       [num, den] = zp2tf(zer, pol, k)
       disp("Variable Description:\n")
       disp("[num, den] => transfer function representation of desired set of zeros")
-      disp("              and poles") 
+      disp("              and poles")
       disp("a, b, c, d => state space system")
       disp("zer, pol => zeros and poles of desired state space system")
       disp("k => gain associated with the zeros\n")
       prompt
       clc
     elseif (k == 5)
       return
     endif
-  endwhile  
+  endwhile
 endfunction
diff --git a/scripts/control/nichols.m b/scripts/control/nichols.m
--- a/scripts/control/nichols.m
+++ b/scripts/control/nichols.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## [mag,phase,w] = nichols(sys[,w,outputs,inputs])
 ## Produce Nichols plot of a system
 ##
 ## Compute the frequency response of a system.
 ## inputs:
 ##   sys: system data structure (must be either purely continuous or discrete;
-##	 see is_digital)
+##       see is_digital)
 ##   w: frequency values for evaluation.
 ##      if sys is continuous, then nichols evaluates G(jw)
 ##      if sys is discrete, then nichols evaluates G(exp(jwT)), where T=sys.tsam
 ##         (the system sampling time)
 ##      default: the default frequency range is selected as follows: (These
 ##        steps are NOT performed if w is specified)
 ##          (1) via routine bodquist, isolate all poles and zeros away from
 ##              w=0 (jw=0 or exp(jwT)=1) and select the frequency
@@ -90,21 +90,21 @@ function [mag, phase, w] = nichols (sys,
     if(is_digital(sys))
       tistr = "(exp(jwT)) ";
     else
       tistr = "(jw)";
     endif
     xlabel("Phase (deg)");
     if(is_siso(sys))
       title(["Nichols plot of |[Y/U]",tistr,"|, u=", ...
-	sysgetsignals(sys,"in",1,1), ", y=",sysgetsignals(sys,"out",1,1)]);
+        sysgetsignals(sys,"in",1,1), ", y=",sysgetsignals(sys,"out",1,1)]);
     else
       title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
-      printf("MIMO plot from\n%s\nto\n%s\n",outlist(inname,"	"), ...
-        outlist(outname,"	"));
+      printf("MIMO plot from\n%s\nto\n%s\n",outlist(inname,"    "), ...
+        outlist(outname,"       "));
     endif
     if(max(mag) > 0)
       ylabel("Gain in dB");
       md = 20*log10(mag);
     else
       ylabel("Gain |Y/U|")
       md = mag;
     endif
diff --git a/scripts/control/nyquist.m b/scripts/control/nyquist.m
--- a/scripts/control/nyquist.m
+++ b/scripts/control/nyquist.m
@@ -1,103 +1,102 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{realp}, @var{imagp}, @var{w}] =} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
+## @deftypefn {Function File} {[@var{realp}, @var{imagp}, @var{w}] =} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
 ## @deftypefnx {Function File } {} nyquist (@var{sys}@{, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol}@})
 ## Produce Nyquist plots of a system; if no output arguments are given, Nyquist
 ## plot is printed to the screen.
-## 
+##
 ## Compute the frequency response of a system.
 ## @strong{Inputs} (pass as empty to get default values)
 ## @table @var
 ## @item sys
-##        system data structure (must be either purely continuous or discrete;
-##        see is_digital)
-## @item w 
-##      frequency values for evaluation.
-##      if sys is continuous, then bode evaluates @math{G(jw)}
-##      if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where 
-##         @math{@var{T}=sysgettsam(@var{sys})} (the system sampling time)
+## system data structure (must be either purely continuous or discrete;
+## see is_digital)
+## @item w
+## frequency values for evaluation.
+## if sys is continuous, then bode evaluates @math{G(jw)}
+## if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where
+## @math{@var{T}=sysgettsam(@var{sys})} (the system sampling time)
 ## @item default
-##      the default frequency range is selected as follows: (These
-##      steps are NOT performed if @var{w} is specified)
+## the default frequency range is selected as follows: (These
+## steps are NOT performed if @var{w} is specified)
 ## @end table
-## @enumerate 
-## @item via routine bodquist, isolate all poles and zeros away from 
+## @enumerate
+## @item via routine bodquist, isolate all poles and zeros away from
 ## @var{w}=0 (@var{jw}=0 or @math{exp(@var{jwT})=1}) and select the frequency
 ## range based on the breakpoint locations of the frequencies.
 ## @item if @var{sys} is discrete time, the frequency range is limited
-## to @var{jwT} in 
+## to @var{jwT} in
 ## @ifinfo
 ## [0,2p*pi]
 ## @end ifinfo
 ## @iftex
 ## $[0,2p*\pi]$
 ## @end iftex
 ## @item A "smoothing" routine is used to ensure that the plot phase does
-##              not change excessively from point to point and that singular
-##              points (e.g., crossovers from +/- 180) are accurately shown.
+## not change excessively from point to point and that singular
+## points (e.g., crossovers from +/- 180) are accurately shown.
 ## @end enumerate
-##   outputs, inputs: the indices of the output(s) and input(s) to be used in
-##     the frequency response; see sysprune.
-## 
+## outputs, inputs: the indices of the output(s) and input(s) to be used in
+## the frequency response; see sysprune.
+##
 ## @strong{Inputs} (pass as empty to get default values)
 ## @table @var
 ## @item   atol
-## for interactive nyquist plots: atol is a change-in-slope tolerance 
+## for interactive nyquist plots: atol is a change-in-slope tolerance
 ## for the of asymptotes (default = 0; 1e-2 is a good choice).  This allows
 ## the user to ``zoom in'' on portions of the Nyquist plot too small to be
 ## seen with large asymptotes.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    realp
 ## @itemx   imagp
 ## the real and imaginary parts of the frequency response
-##        @math{G(jw)} or @math{G(exp(jwT))} at the selected frequency values.
+## @math{G(jw)} or @math{G(exp(jwT))} at the selected frequency values.
 ## @item    w
-##  the vector of frequency values used
+## the vector of frequency values used
 ## @end table
-## 
-##  If no output arguments are given, nyquist plots the results to the screen.
-##  If @var{atol} != 0 and asymptotes are detected then the user is asked 
-##     interactively if they wish to zoom in (remove asymptotes)
-##  Descriptive labels are automatically placed.
-## 
-##  Note: if the requested plot is for an MIMO system, a warning message is
-##  presented; the returned information is of the magnitude 
-##  ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
-## 
+##
+## If no output arguments are given, nyquist plots the results to the screen.
+## If @var{atol} != 0 and asymptotes are detected then the user is asked
+## interactively if they wish to zoom in (remove asymptotes)
+## Descriptive labels are automatically placed.
+##
+## Note: if the requested plot is for an MIMO system, a warning message is
+## presented; the returned information is of the magnitude
+## ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
 ## @end deftypefn
- 
+
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 13, 1994
-## A. S. Hodel July 1995 (adaptive frequency spacing, 
+## A. S. Hodel July 1995 (adaptive frequency spacing,
 ##     remove acura parameter, etc.)
 ## Revised by John Ingram July 1996 for system format
 
 function [realp, imagp, w] = nyquist (sys, w, outputs, inputs, atol)
-   
+
   ## Both bode and nyquist share the same introduction, so the common
   ## parts are in a file called bodquist.m.  It contains the part that
   ## finds the number of arguments, determines whether or not the system
   ## is SISO, andd computes the frequency response.  Only the way the
   ## response is plotted is different between the two functions.
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 5)
@@ -114,17 +113,17 @@ function [realp, imagp, w] = nyquist (sy
   endif
   if(nargin < 5)
     atol = 0;
   elseif(!(is_sample(atol) | atol == 0))
     error("atol must be a nonnegative scalar.")
   endif
 
   ## signal to bodquist who's calling
-   
+
   [f,w] = bodquist(sys,w,outputs,inputs,"nyquist");
 
   ## Get the real and imaginary part of f.
   realp = real(f);
   imagp = imag(f);
 
   ## No output arguments, then display plot, otherwise return data.
   if (nargout == 0)
@@ -132,52 +131,52 @@ function [realp, imagp, w] = nyquist (sy
     while(!dnplot)
       if(gnuplot_has_multiplot)
         oneplot();
         gset key;
       endif
       clearplot();
       grid ("on");
       gset data style lines;
-  
+
       if(is_digital(sys))
         tstr = " G(e^{jw}) ";
       else
         tstr = " G(jw) ";
       endif
       xlabel(["Re(",tstr,")"]);
       ylabel(["Im(",tstr,")"]);
-  
+
       [stn, inn, outn] = sysgetsignals(sys);
       if(is_siso(sys))
         title(sprintf("Nyquist plot from %s to %s, w (rad/s) in [%e, %e]", ...
-	  nth(inn,1), nth(outn,1), w(1), w(length(w))) )
+          nth(inn,1), nth(outn,1), w(1), w(length(w))) )
       endif
-  
+
       gset nologscale xy;
 
       axis(axis2dlim([[vec(realp),vec(imagp)];[vec(realp),-vec(imagp)]]));
       plot(realp,imagp,"- ;+w;",realp,-imagp,"-@ ;-w;");
 
       ## check for interactive plots
       dnplot = 1; # assume done; will change later if atol is satisfied
       if(atol > 0 & length(f) > 2)
 
         ## check for asymptotes
         fmax = max(abs(f));
         fi = max(find(abs(f) == fmax));
-        
+
         ## compute angles from point to point
         df = diff(f);
         th = atan2(real(df),imag(df))*180/pi;
 
         ## get angle at fmax
         if(fi == length(f)) fi = fi-1; endif
         thm = th(fi);
-    
+
         ## now locate consecutive angles within atol of thm
         ith_same = find(abs(th - thm) < atol);
         ichk = union(fi,find(diff(ith_same) == 1));
 
         ## locate max, min consecutive indices in ichk
         loval = max(complement(ichk,1:fi));
         if(isempty(loval)) loval = fi;
         else               loval = loval + 1;   endif
diff --git a/scripts/control/obsv.m b/scripts/control/obsv.m
--- a/scripts/control/obsv.m
+++ b/scripts/control/obsv.m
@@ -1,44 +1,44 @@
 ## Copyright (C) 1997 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File } { @var{Qb} =} obsv (@var{sys}@{, @var{c}@})
+##@deftypefn {Function File} {@var{Qb} =} obsv (@var{sys}@{, @var{c}@})
 ## Build observability matrix
 ## @example
 ## @group
 ##      | C        |
 ##      | CA       |
 ## Qb = | CA^2     |
 ##      | ...      |
 ##      | CA^(n-1) |
 ## @end group
 ## @end example
 ## of a system data structure or the pair (A, C).
-## 
+##
 ## Note: @code{obsv()} forms the observability matrix.
-## 
-##        The numerical properties of is_observable()
-##        are much better for observability tests.
+##
+## The numerical properties of is_observable()
+## are much better for observability tests.
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 
 function Qb = obsv (sys, c)
 
   if (nargin == 2)
diff --git a/scripts/control/ord2.m b/scripts/control/ord2.m
--- a/scripts/control/ord2.m
+++ b/scripts/control/ord2.m
@@ -1,52 +1,51 @@
 ## Copyright (C) 1997 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{outsys} =} ord2 (@var{nfreq}, @var{damp}@{[, @var{gain}@})
-##  Creates a continuous 2nd order system with parameters:
+## @deftypefn {Function File} {@var{outsys} =} ord2 (@var{nfreq}, @var{damp}@{[, @var{gain}@})
+## Creates a continuous 2nd order system with parameters:
 ## @strong{Inputs}
 ## @table @var
 ## @item  nfreq:   natural frequency [Hz]. (not in rad/s)
 ## @item      damp:    damping coefficient
 ## @item      gain:    dc-gain
-##                This is steady state value only for damp > 0.
-##                gain is assumed to be 1.0 if ommitted.
+## This is steady state value only for damp > 0.
+## gain is assumed to be 1.0 if ommitted.
 ## @end table
 ## @strong{Outputs}
 ## @var{outsys}
-##       system data structure has representation with @math{w = 2 * pi * nfreq}:
+## system data structure has representation with @math{w = 2 * pi * nfreq}:
 ## @example
 ##     /                                        \
 ##     | / -2w*damp -w \  / w \                 |
 ## G = | |             |, |   |, [ 0  gain ], 0 |
 ##     | \   w       0 /  \ 0 /                 |
 ##     \                                        /
 ## @end example
-## @strong{See also} @code{jet707} (MIMO example, Boeing 707-321 aircraft model)
+## @strong{See also} @code{jet707} (MIMO example, Boeing 707-321
+## aircraft model)
 ## @end deftypefn
 
-## See also: jet707 (MIMO example, Boeing 707-321 aircraft model)
-
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = ord2 (nfreq, damp, gain)
 
   ## Updates
 
   if(nargin != 2 & nargin != 3)
diff --git a/scripts/control/outlist.m b/scripts/control/outlist.m
--- a/scripts/control/outlist.m
+++ b/scripts/control/outlist.m
@@ -1,50 +1,49 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
-## @deftypefn {Function File } { } outlist (@var{lmat}@{, @var{tabchar}, @var{yd}, @var{ilist} @})
-##  Prints an enumerated list of strings.
-##  internal use only; minimal argument checking performed
-## 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} outlist (@var{lmat}@{, @var{tabchar}, @var{yd}, @var{ilist} @})
+## Prints an enumerated list of strings.
+## internal use only; minimal argument checking performed
+##
 ## @strong{Inputs}
 ## @table @var
-## @item 	lmat
-##  list of strings
-## @item 	tabchar
-##  tab character (default: none)
+## @item        lmat
+## list of strings
+## @item        tabchar
+## tab character (default: none)
 ## @item   yd
-##  indices of strings to append with the string "(discrete)"
-##            (used by @var{sysout}; minimal checking of this argument)
-## 	   @math{yd = [] } indicates all outputs are continuous
+## indices of strings to append with the string "(discrete)"
+## (used by @var{sysout}; minimal checking of this argument)
+## @math{yd = [] } indicates all outputs are continuous
 ## @item ilist
-## index numbers to print with names.  
-## 
+## index numbers to print with names.
+##
 ## default: @code{1:rows(lmat)}
 ## @end table
-## 
+##
 ## @strong{Outputs}
-##    prints the list to the screen, numbering each string in order.
-## 
+## prints the list to the screen, numbering each string in order.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: December 1995
 
 function str_val = outlist (name_list, tabchar, yd, ilist)
 
   ## save for restore later
@@ -65,17 +64,17 @@ function str_val = outlist (name_list, t
   if(nargin < 3)             yd = zeros(1,m);
   elseif(isempty(yd))        yd = zeros(1,m);          endif
 
   str_val = "";
   dstr = list(""," (discrete)");
   if((m >= 1) && (is_list(name_list)))
     for ii=1:m
       str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
-	  nth(name_list,ii),nth(dstr,yd(ii)+1));
+          nth(name_list,ii),nth(dstr,yd(ii)+1));
     endfor
   else
     str_val = sprintf("%sNone",tabchar);
   endif
 
   empty_list_elements_ok = save_empty;
 
 endfunction
diff --git a/scripts/control/packedform.m b/scripts/control/packedform.m
--- a/scripts/control/packedform.m
+++ b/scripts/control/packedform.m
@@ -1,26 +1,26 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 save_var = page_screen_output;
 page_screen_output = 1;
 disp("Description of system data structure:")
 disp("A linear system is stored in a structure, and may be represented in")
 disp("ss (state space), tf (transfer function),  and/or zp (zero-pole-gain)")
 disp("form.")
 disp(" ")
 disp("variables in all representations:")
diff --git a/scripts/control/parallel.m b/scripts/control/parallel.m
--- a/scripts/control/parallel.m
+++ b/scripts/control/parallel.m
@@ -1,25 +1,25 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## function sysp = parallel(Asys,Bsys)
 ## Forms the parallel connection of two systems.
 ##
 ##              ____________________
 ##              |      ________    |
 ##     u  ----->|----> | Asys |--->|----> y1
 ##         |    |      --------    |
@@ -54,13 +54,13 @@ function sysp = parallel (Asys, Bsys)
   Ain = sysgetsignals(Asys,"in");
 
   ## change signal names to avoid warning messages from sysgroup
   Asys = syssetsignals(Asys,"in",sysdefioname(length(Ain),"Ain_u"));
   Bsys = syssetsignals(Bsys,"in",sysdefioname(length(Ain),"Bin_u"));
 
   sysp = sysgroup(Asys,Bsys);
   sysD = ss2sys([],[],[],[eye(mA);eye(mA)]);
-  
+
   sysp = sysmult(sysp,sysD);
   sysp = syssetsignals(sysp,"in",Ain);
-  
+
 endfunction
diff --git a/scripts/control/place.m b/scripts/control/place.m
--- a/scripts/control/place.m
+++ b/scripts/control/place.m
@@ -1,86 +1,86 @@
 ## Copyright (C) 1997 Jose Daniel Munoz Frias
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{K} =} place (@var{sys}, @var{P})
+## @deftypefn {Function File} {@var{K} =} place (@var{sys}, @var{P})
 ## Computes the matrix  K such that if the state
 ## is feedback with gain K, then the eigenvalues  of the closed loop
 ## system (i.e. A-BK) are those specified in the vector P.
-## 
+##
 ## Version: Beta (May-1997): If you have any comments, please let me know.
-## 			    (see the file place.m for my address)
+## (see the file place.m for my address)
 ## @end deftypefn
 
 ## Author: Jose Daniel Munoz Frias
- 
+
 ## Universidad Pontificia Comillas
 ## ICAIdea
 ## Alberto Aguilera, 23
 ## 28015 Madrid, Spain
 ##
 ## E-Mail: daniel@dea.icai.upco.es
 ##
 ## Phone: 34-1-5422800   Fax: 34-1-5596569
 ##
 ## Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
 ##
 ## code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
 ## toolbox
 
-function K = place (sys, P) 
+function K = place (sys, P)
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   ## check arguments
 
   if(!is_struct(sys))
     error("sys must be in system data structure format (see ss2sys)");
   endif
-  sys = sysupdate(sys,"ss");	# make sure it has state space form up to date
+  sys = sysupdate(sys,"ss");    # make sure it has state space form up to date
   if(!is_controllable(sys))
     error("sys is not controllable.");
   elseif( min(size(P)) != 1)
     error("P must be a vector")
   else
-    P = reshape(P,length(P),1);	# make P a column vector
+    P = reshape(P,length(P),1); # make P a column vector
   endif
   ## system must be purely continuous or discrete
   is_digital(sys);
   [n,nz,m,p] = sysdimensions(sys);
-  nx = n+nz;	# already checked that it's not a mixed system.
+  nx = n+nz;    # already checked that it's not a mixed system.
   if(m != 1)
     error(["sys has ", num2str(m)," inputs; need only 1"]);
   endif
 
   ## takes the A and B matrix from the system representation
   [A,B]=sys2ss(sys);
   sp = length(P);
   if(nx == 0)
     error("place: A matrix is empty (0x0)");
   elseif(nx != length(P))
     error(["A=(",num2str(nx),"x",num2str(nx),", P has ", num2str(length(P)), ...
-	"entries."])
+        "entries."])
   endif
 
   ## arguments appear to be compatible; let's give it a try!
   ## The second step is the calculation of the characteristic polynomial ofA
   PC=poly(A);
 
   ## Third step: Calculate the transformation matrix T that transforms the state
   ## equation in the controllable canonical form.
@@ -90,30 +90,30 @@ function K = place (sys, P)
   AA=A;
   for n = 2:nx
     M(:,n)=AA*B;
     AA=AA*A;
   endfor
 
   ## second, construct the matrix W
   PCO=PC(nx:-1:1);
-  PC1=PCO; 	# Matrix to shift and create W row by row
+  PC1=PCO;      # Matrix to shift and create W row by row
 
   for n = 1:nx
     W(n,:) = PC1;
     PC1=[PCO(n+1:nx),zeros(1,n)];
   endfor
 
   T=M*W;
 
-  ## finaly the matrix K is calculated 
+  ## finaly the matrix K is calculated
   PD = poly(P); # The desired characteristic polynomial
   PD = PD(nx+1:-1:2);
   PC = PC(nx+1:-1:2);
-  
+
   K = (PD-PC)/T;
 
   ## Check if the eigenvalues of (A-BK) are the same specified in P
   Pcalc = eig(A-B*K);
 
   Pcalc = sortcom(Pcalc);
   P = sortcom(P);
 
diff --git a/scripts/control/prompt.m b/scripts/control/prompt.m
--- a/scripts/control/prompt.m
+++ b/scripts/control/prompt.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} prompt ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} prompt (@var{inputs})
 ## @format
-##  function prompt([str])
-##  Prompt user to continue
-##  str: input string. Default value: "\n ---- Press a key to continue ---"
+## function prompt([str])
+## Prompt user to continue
+## str: input string. Default value: "\n ---- Press a key to continue ---"
 ## @end format
 ## @end deftypefn
- 
+
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Modified A. S. Hodel June 1995
 
 function prompt (str)
 
   if(nargin > 1)
     usage("prompt([str])");
diff --git a/scripts/control/pzmap.m b/scripts/control/pzmap.m
--- a/scripts/control/pzmap.m
+++ b/scripts/control/pzmap.m
@@ -1,46 +1,46 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{zer}, @var{pol}]=} pzmap (@var{sys})
-##  Plots the zeros and poles of a system in the complex plane.
+## @deftypefn {Function File} {[@var{zer}, @var{pol}]=} pzmap (@var{sys})
+## Plots the zeros and poles of a system in the complex plane.
 ## @strong{Inputs}
-##  @var{sys} system data structure
-## 
+## @var{sys} system data structure
+##
 ## @strong{Outputs}
 ## if omitted, the poles and zeros are plotted on the screen.
-##           otherwise, pol, zer are returned as the system poles and zeros.
-##           (see sys2zp for a preferable function call)
+## otherwise, pol, zer are returned as the system poles and zeros.
+## (see sys2zp for a preferable function call)
 ## @end deftypefn
- 
+
 function [zer, pol]=pzmap (sys)
 
   save_emp = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;
 
   if(nargin != 1)
-    usage("pzmap(sys) or [zer,pol] = pzmap(sys)"); 
+    usage("pzmap(sys) or [zer,pol] = pzmap(sys)");
   elseif (!is_struct(sys));
     error("sys must be in system format");
   endif
 
   [zer,pol] = sys2zp(sys);
 
   ## force to column vectors, split into real, imaginary parts
   zerdata = poldata = [];
diff --git a/scripts/control/rldemo.m b/scripts/control/rldemo.m
--- a/scripts/control/rldemo.m
+++ b/scripts/control/rldemo.m
@@ -1,45 +1,45 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File } { outputs =} rldemo ( inputs ) 
+##@deftypefn {Function File} {@var{outputs} =} rldemo (@var{inputs})
 ##Octave Controls toolbox demo: Root Locus demo
 ##@end deftypefn
- 
+
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Updated by John Ingram December 1996
 
 function rldemo ()
 
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
-    	"Display continuous system's open loop poles and zeros (pzmap)", ...
-    	"Display discrete system's open loop poles and zeros (pzmap)", ...
-    	"Display root locus diagram of SISO continuous system (rlocus)", ...
-    	"Display root locus diagram of SISO discrete system (rlocus)", ...	
-    	"Return to main demo menu");
+        "Display continuous system's open loop poles and zeros (pzmap)", ...
+        "Display discrete system's open loop poles and zeros (pzmap)", ...
+        "Display root locus diagram of SISO continuous system (rlocus)", ...
+        "Display root locus diagram of SISO discrete system (rlocus)", ...
+        "Return to main demo menu");
     gset autoscale
     if (k == 1)
       clc
       help pzmap
       prompt
 
       clc
       disp("Display continuous system's open loop poles and zeros (pzmap)\n");
@@ -48,21 +48,21 @@ function rldemo ()
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
-      eval(cmd);     
+      eval(cmd);
       disp("View the system's open loop poles and zeros with the command:")
       cmd = "pzmap(sys1);";
       run_cmd
-      prompt     
+      prompt
 
       clc
       disp("Example #2, Consider the following set of poles and zeros:");
       cmd = "sys2 = zp2sys([-1, 5, -23],[-1, -10, -7+5i, -7-5i],5);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys2);";
       disp(cmd);
@@ -72,33 +72,33 @@ function rldemo ()
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("pzmap automatically sorts it out internally.");
       prompt;
 
       clc
       disp("Example #3, Consider the following state space system:\n");
       cmd = "sys3=ss2sys([0, 1; -10, -11], [0; 1], [0, -2], 1);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
-      eval(cmd); 
+      eval(cmd);
       disp("\nOnce again, the pzmap command is the same:");
       cmd = "pzmap(sys3);";
       run_cmd;
       prompt;
 
       closeplot
       clc
-    
+
     elseif (k == 2)
       clc
       help pzmap
       prompt
 
       clc
       disp("\nDisplay discrete system's open loop poles and zeros (pzmap)\n");
       disp("First we must define a sampling time, as follows:\n");
@@ -109,21 +109,21 @@ function rldemo ()
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
-      eval(cmd);     
+      eval(cmd);
       disp("View the system's open loop poles and zeros with the command:")
       cmd = "pzmap(sys1);";
       run_cmd
-      prompt     
+      prompt
 
       clc
       disp("Example #2, Consider the following set of discrete poles and zeros:");
       cmd = "sys2 = zp2sys(-0.717, [1, -0.368], 3.68, Tsam);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys2);";
       disp(cmd);
@@ -133,25 +133,25 @@ function rldemo ()
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("pzmap automatically sorts it out internally.");
       prompt;
 
       clc
       disp("Example #3, Consider the following discrete state space system:\n");
       cmd = "sys3=ss2sys([1, 0.0952; 0, 0.905], [0.00484; 0.0952], [1, 0], 0, Tsam);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
-      eval(cmd); 
+      eval(cmd);
       disp("\nOnce again, the pzmap command is the same:");
       cmd = "pzmap(sys3);";
       run_cmd;
       prompt;
 
       closeplot
       clc
 
@@ -167,17 +167,17 @@ function rldemo ()
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
-      eval(cmd); 
+      eval(cmd);
       disp("\nWhen using rlocus, inital system poles are displayed as X's.")
       disp("Moving poles are displayed as diamonds.  Zeros are displayed as")
       disp("boxes.  The simplest form of the rlocus command is as follows:")
       cmd = "rlocus(sys1);";
       run_cmd
       disp("\nrlocus automatically selects the minimum and maximum gains based")
       disp("on the real-axis locus breakpoints.  The plot limits are chosen")
       disp("to be no more than 10 times the maximum magnitude of the open")
@@ -197,25 +197,25 @@ function rldemo ()
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("rlocus automatically sorts it out internally.");
       prompt;
 
       clc
       disp("Example #3, Consider the following state space system:\n");
       cmd = "sys3=ss2sys([0, 1; -10, -11], [0; 1], [0, -2], 0);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
-      eval(cmd); 
+      eval(cmd);
       disp("\nOnce again, the rlocus command is the same:");
       cmd = "rlocus(sys3);";
       run_cmd;
 
       disp("\nNo matter what form the system is in, the rlocus command works the");
       disp("the same.");
       prompt;
 
@@ -237,17 +237,17 @@ function rldemo ()
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
-      eval(cmd);     
+      eval(cmd);
       disp("\nWhen using rlocus, inital system poles are displayed as X's.")
       disp("Moving poles are displayed as diamonds.  Zeros are displayed as")
       disp("boxes.  The simplest form of the rlocus command is as follows:")
       cmd = "rlocus(sys1);";
       run_cmd
       disp("\nrlocus automatically selects the minimum and maximum gains based")
       disp("on the real-axis locus breakpoints.  The plot limits are chosen")
       disp("to be no more than 10 times the maximum magnitude of the open")
@@ -269,34 +269,34 @@ function rldemo ()
       disp("rlocus automatically sorts it out internally.  Also, it does not");
       disp("matter if the system is continuous or discrete.  rlocus also sorts");
       disp("this out automatically");
       prompt;
 
       clc
       disp("Example #3, Consider the following discrete state space system:\n");
       cmd = "sys3=ss2sys([1, 0.0952; 0, 0.905], [0.00484; 0.0952], [1, 0], 0, Tsam);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
-      disp(cmd); 
+      disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
-      eval(cmd); 
+      eval(cmd);
       disp("\nOnce again, the rlocus command is the same:");
       cmd = "rlocus(sys3);";
       run_cmd;
 
       disp("\nNo matter what form the system is in, the rlocus command works the");
       disp("the same.");
 
       prompt;
 
       closeplot
       clc
- 
+
     elseif (k == 5)
       return
     endif
-  endwhile  
+  endwhile
 endfunction
diff --git a/scripts/control/rlocus.m b/scripts/control/rlocus.m
--- a/scripts/control/rlocus.m
+++ b/scripts/control/rlocus.m
@@ -1,93 +1,91 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} rlocus ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} rlocus (@var{inputs})
 ## @format
-##  [rldata, k] = rlocus(sys[,increment,min_k,max_k])
-##  Displays root locus plot of the specified SISO system.
-##  
-##        -----   ---     -------- 
+## [rldata, k] = rlocus(sys[,increment,min_k,max_k])
+## Displays root locus plot of the specified SISO system.
+##
+##        -----   ---     --------
 ##    --->| + |---|k|---->| SISO |----------->
-##        -----   ---     --------        | 
-##        - ^                             | 
-##          |_____________________________|  
-## 
+##        -----   ---     --------        |
+##        - ^                             |
+##          |_____________________________|
+##
 ## inputs: sys = system data structure
-##         min_k, max_k,increment: minimum, maximum values of k and
-##                the increment used in computing gain values
-##  Outputs: plots the root locus to the screen.  
-##    rldata: Data points plotted column 1: real values, column 2: imaginary
-##            values)
-##    k: gains for real axis break points.
-## 
-## 
+## min_k, max_k,increment: minimum, maximum values of k and
+## the increment used in computing gain values
+## Outputs: plots the root locus to the screen.
+## rldata: Data points plotted column 1: real values, column 2: imaginary
+## values)
+## k: gains for real axis break points.
 ## @end format
 ## @end deftypefn
 
 ## Author: David Clem
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Updated by Kristi McGowan July 1996 for intelligent gain selection
 ## Updated by John Ingram July 1996 for systems
 
 function [rldata, k_break, rlpol, gvec, real_ax_pts] = rlocus (sys, increment, min_k, max_k)
-  
+
   if (nargin < 1) | (nargin > 4)
     usage("rlocus(sys[,inc,mink,maxk])");
   endif
 
   ## Convert the input to a transfer function if necessary
-  
-  [num,den] = sys2tf(sys)		# extract numerator/denom polyomials
+
+  [num,den] = sys2tf(sys)               # extract numerator/denom polyomials
   lnum = length(num);      lden = length(den);
   if(lden < 2)
     error(sprintf("length of derivative=%d, doesn't make sense",lden));
   elseif(lnum == 1)
     num = [0, num];     # so that derivative is shortened by one
   endif
 
   ## root locus plot axis limits
-  
+
   ## compute real axis locus breakpoints
-  ## compute the derivative of the numerator and the denominator 
+  ## compute the derivative of the numerator and the denominator
   dern=polyderiv(num);        derd=polyderiv(den);
-  
+
   ## compute real axis breakpoints
   real_ax_pol = conv(den,dern) - conv(num,derd);
   real_ax_pts = roots(real_ax_pol);
   if(isempty(real_ax_pts))
     k_break = [];
     maxk = 0;
   else
     ## compute gains that achieve the breakpoints
     c1 = polyval(num,real_ax_pts);
     c2 = polyval(den,real_ax_pts);
     k_break = -real(c2 ./ c1);
     maxk = max(max(k_break,0));
   endif
 
   ## compute gain ranges based on computed K values
-  if(maxk == 0)     maxk = 1; 
+  if(maxk == 0)     maxk = 1;
   else              maxk = 1.1*maxk;        endif
   mink = 0;
   ngain = 20;
 
   ## check for input arguments:
   if (nargin > 2)       mink = min_k;          endif
   if (nargin > 3)       maxk = max_k;          endif
   if (nargin > 1)
@@ -95,17 +93,17 @@ function [rldata, k_break, rlpol, gvec, 
     else
       ngain = (maxk-mink)/increment;
     endif
   endif
 
   ## vector of gains
   ngain = max(3,ngain);
   gvec = linspace(mink,maxk,ngain);
-  
+
   ## Find the open loop zeros and the initial poles
   rlzer = roots(num);
 
   ## update num to be the same length as den
   lnum = length(num);  if(lnum < lden) num = [zeros(1,lden - lnum),num];  endif
 
   ## compute preliminary pole sets
   nroots = lden-1;
@@ -119,41 +117,41 @@ function [rldata, k_break, rlpol, gvec, 
   real_axdat = union(real(rlzer), real(union(olpol,real_ax_pts)) );
   rmin = min(real_axdat);      rmax = max(real_axdat);
 
   rlpolv = [vec(rlpol); vec(real_axdat)];
   idx = find(real(rlpolv) >= rmin & real(rlpolv) <= rmax);
   axlim = axis2dlim([real(rlpolv(idx)),imag(rlpolv(idx))]);
   xmin = axlim(1);
   xmax = axlim(2);
-  
+
   ## set smoothing tolerance per axis limits
   smtol = 0.01*max(abs(axlim));
-  
+
   ## smooth poles if necessary, up to maximum of 1000 gain points
   ## only smooth points within the axis limit window
   ## smoothing done if max_k not specified as a command argument
   done=(nargin == 4);    # perform a smoothness check
   while((!done) & ngain < 1000)
     done = 1 ;      # assume done
     dp = abs(diff(rlpol'))';
     maxd = max(dp);
     ## search for poles in the real axis limits whose neighbors are distant
     idx = find(maxd > smtol);
     for ii=1:length(idx)
       i1 = idx(ii);      g1 = gvec(i1);       p1 = rlpol(:,i1);
       i2 = idx(ii)+1;    g2 = gvec(i2);       p2 = rlpol(:,i2);
-    
+
       ## isolate poles in p1, p2 that are inside the real axis limits
       bidx = find( (real(p1) >= xmin & real(p1) <= xmax)  ...
           | (real(p2) >= xmin & real(p2) <= xmax) );
       if(!isempty(bidx))
         p1 = p1(bidx);
         p2 = p2(bidx);
-        if( max(abs(p2-p1)) > smtol) 
+        if( max(abs(p2-p1)) > smtol)
           newg = linspace(g1,g2,5);
           newg = newg(2:4);
           if(isempty(newg))
             printf("rlocus: empty newg")
             g1
             g2
             i1
             i2
@@ -162,43 +160,43 @@ function [rldata, k_break, rlpol, gvec, 
             delta_vec_i1 = diff(gvec(i1:i2))
             prompt
           endif
           gvec =  [gvec,newg];
           done = 0;             # need to process new gains
         endif
       endif
     endfor
-    
+
     ## process new gain values
     ngain1 = length(gvec);
     for ii=(ngain+1):ngain1
       gain = gvec(ii);
       rlpol(1:nroots,ii)  = vec(sortcom(roots(den + gain*num)));
     endfor
 
     [gvec,idx] = sort(gvec);
     rlpol = rlpol(:,idx);
     ngain = length(gvec);
   endwhile
-   
+
   ## Plot the data
   if(nargout  == 0)
     rlpolv = vec(rlpol);
     idx = find(real(rlpolv) >= xmin & real(rlpolv) <= xmax);
     axdata = [real(rlpolv(idx)),imag(rlpolv(idx))];
     axlim = axis2dlim(axdata);
     axlim(1:2) = [xmin, xmax];
     gset nologscale xy;
     grid("on");
     rldata = [real(rlpolv), imag(rlpolv) ];
     axis(axlim);
     [stn,inname,outname] = sysgetsignals(sys);
     xlabel(sprintf("Root locus from %s to %s, gain=[%f,%f]: Real axis", ...
-	nth(inname,1),nth(outname,1),gvec(1),gvec(ngain)));
+        nth(inname,1),nth(outname,1),gvec(1),gvec(ngain)));
     ylabel("Imag. axis");
-	
+
     plot(real(rlpolv),imag(rlpolv),".1;locus points;", ...
-	real(olpol),imag(olpol),"x2;open loop poles;", ...
-	real(rlzer),imag(rlzer),"o3;zeros;");
+        real(olpol),imag(olpol),"x2;open loop poles;", ...
+        real(rlzer),imag(rlzer),"o3;zeros;");
     rldata = [];
   endif
 endfunction
diff --git a/scripts/control/rotg.m b/scripts/control/rotg.m
--- a/scripts/control/rotg.m
+++ b/scripts/control/rotg.m
@@ -1,26 +1,26 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## function [c,s] = rotg(a,b)
 ## givens rotation calculation
 ##
 ## NOTE: Use [c,s] = givens(a,b) instead.
 
 function [c, s] = rotg (a, b)
 
   [c,s] = givens(a,b);
diff --git a/scripts/control/sortcom.m b/scripts/control/sortcom.m
--- a/scripts/control/sortcom.m
+++ b/scripts/control/sortcom.m
@@ -1,42 +1,40 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} sortcom ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} sortcom (@var{inputs})
 ## @format
-##  [yy,idx] = sortcom(xx[,opt]): sort a complex vector
-##  xx: complex vector
-##  opt: sorting option:
-## 	"re": real part (default)
-## 	"mag": by magnitude
-## 	"im": by imaginary part
-## 
-##   if opt != "im" then complex conjugate pairs are grouped together,
-##      a - jb followed by a + jb.
-##  yy: sorted values
-##  idx: permutation vector: yy = xx(idx)
-## 
-## 
+## [yy,idx] = sortcom(xx[,opt]): sort a complex vector
+## xx: complex vector
+## opt: sorting option:
+##  "re": real part (default)
+##  "mag": by magnitude
+##  "im": by imaginary part
+##
+## if opt != "im" then complex conjugate pairs are grouped together,
+## a - jb followed by a + jb.
+## yy: sorted values
+## idx: permutation vector: yy = xx(idx)
 ## @end format
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function [yy, idx] = sortcom (xx, opt)
 
@@ -47,40 +45,40 @@ function [yy, idx] = sortcom (xx, opt)
   endif
 
   if(nargin == 1)         opt = "re";
   else
     if (!isstr(opt))
       error("sortcom: second argument must be a string");
     endif
   endif
- 
+
   if(isempty(xx))
     yy = idx = [];
   else
     if(strcmp(opt,"re"))        datavec = real(xx);
     elseif(strcmp(opt,"im"))    datavec = imag(xx);
     elseif(strcmp(opt,"mag"))   datavec = abs(xx);
     else                        error(["sortcom: illegal option = ", opt])
     endif
-  
+
     [datavec,idx] = sort(datavec);
     yy= xx(idx);
-    
+
     if(strcmp(opt,"re") | strcmp(opt,"mag"))
       ## sort so that complex conjugate pairs appear together
-      
+
       ddiff = diff(datavec);
       zidx = find(ddiff == 0);
-  
+
       ## sort common datavec values
       if(!isempty(zidx))
         for iv=create_set(datavec(zidx))
           vidx = find(datavec == iv);
           [vals,imidx] = sort(imag(yy(vidx)));
           yy(vidx)  = yy(vidx(imidx));
           idx(vidx) = idx(vidx(imidx));
         endfor
       endif
     endif
-  endif  
+  endif
 endfunction
-  
+
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -1,168 +1,168 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =} ss2sys  (@var{a},@var{b},@var{c}@{,@var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist}@})
-##  Create system structure from state-space data.   May be continous,
-##  discrete, or mixed (sampeled-data)
-## 
+## @deftypefn {Function File} {@var{sys} =} ss2sys (@var{a}, @var{b}, @var{c}@{,@var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist}@})
+## Create system structure from state-space data.   May be continous,
+## discrete, or mixed (sampeled-data)
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
-##  usual state space matrices.
-## 
-##                default: @var{d} = zero matrix
-## 
+## usual state space matrices.
+##
+## default: @var{d} = zero matrix
+##
 ## @item   tsam
-##  sampling rate.  Default: @math{tsam = 0} (continuous system)
-## 
+## sampling rate.  Default: @math{tsam = 0} (continuous system)
+##
 ## @item n
 ## @itemx nz
-##  number of continuous, discrete states in the system
-## 
+## number of continuous, discrete states in the system
+##
 ## If @var{tsam} is 0, @math{n = @code{rows}(@var{a})}, @math{nz = 0}.
-## 
+##
 ## If @var{tsam} is greater than zero, @math{n = 0},
-## @math{nz = @code{rows}(@var{a})} 
-## 
-##         see below for system partitioning
+## @math{nz = @code{rows}(@var{a})}
+##
+## see below for system partitioning
 ##
 ## @item  stname
-##  list of strings of state signal names
-## 
-##            default (@var{stname}=[] on input): @code{x_n} for continuous states,
+## list of strings of state signal names
+##
+## default (@var{stname}=[] on input): @code{x_n} for continuous states,
 ##                     @code{xd_n} for discrete states
-## 
+##
 ## @item inname
-##  list of strings of input signal names
-## 
-##            default (@var{inname} = [] on input): @code{u_n}
-## 
+## list of strings of input signal names
+##
+## default (@var{inname} = [] on input): @code{u_n}
+##
 ## @item outname
-##  list of strings of input signal names
-## 
-##            default (@var{outname} = [] on input): @code{y_n}
-## 
+## list of strings of input signal names
+##
+## default (@var{outname} = [] on input): @code{y_n}
+##
 ## @item   outlist
-## 
-##  list of indices of outputs y that are sampled
-## 
+##
+## list of indices of outputs y that are sampled
+##
 ## If @var{tsam} is 0, @math{outlist = []}.
 ##
 ## If @var{tsam} is greater than 0, @math{outlist = 1:@code{rows}(@var{c})}.
 ## @end table
-## 
+##
 ## Unlike states, discrete/continous outputs may appear in any order.
-## 
+##
 ## @strong{Note} @code{sys2ss} returns a vector @var{yd} where
 ## @var{yd}(@var{outlist}) = 1; all other entries of @var{yd} are 0.
-## 
+##
 ## @strong{Outputs}
 ## @var{outsys} = system data structure
-## 
+##
 ## @strong{System partitioning}
-## 
-##  Suppose for simplicity that outlist specified
-##   that the first several outputs were continuous and the remaining outputs
-##   were discrete.  Then the system is partitioned as
+##
+## Suppose for simplicity that outlist specified
+## that the first several outputs were continuous and the remaining outputs
+## were discrete.  Then the system is partitioned as
 ## @example
 ## @group
 ## x = [ xc ]  (n x 1)
 ##     [ xd ]  (nz x 1 discrete states)
 ## a = [ acc acd ]  b = [ bc ]
 ##     [ adc add ]      [ bd ]
 ## c = [ ccc ccd ]  d = [ dc ]
-##     [ cdc cdd ]      [ dd ]  
-## 
+##     [ cdc cdd ]      [ dd ]
+##
 ##     (cdc = c(outlist,1:n), etc.)
 ## @end group
 ## @end example
 ## with dynamic equations:
 ## @ifinfo
 ## @math{  d/dt xc(t)     = acc*xc(t)      + acd*xd(k*tsam) + bc*u(t)}
-## 
+##
 ## @math{  xd((k+1)*tsam) = adc*xc(k*tsam) + add*xd(k*tsam) + bd*u(k*tsam)}
-## 
+##
 ## @math{  yc(t)      = ccc*xc(t)      + ccd*xd(k*tsam) + dc*u(t)}
-## 
+##
 ## @math{  yd(k*tsam) = cdc*xc(k*tsam) + cdd*xd(k*tsam) + dd*u(k*tsam)}
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## $$\eqalign{
-## {d \over dt} x_c(t)  
+## {d \over dt} x_c(t)
 ##   & =   a_{cc} x_c(t)      + a_{cd} x_d(k*t_{sam}) + bc*u(t) \cr
-## x_d((k+1)*t_{sam}) 
+## x_d((k+1)*t_{sam})
 ##   & =   a_{dc} x_c(k t_{sam}) + a_{dd} x_d(k t_{sam}) + b_d u(k t_{sam}) \cr
 ## y_c(t)
 ##  & =  c_{cc} x_c(t) + c_{cd} x_d(k t_{sam}) + d_c u(t) \cr
-## y_d(k t_{sam}) 
+## y_d(k t_{sam})
 ##   & =  c_{dc} x_c(k t_{sam}) + c_{dd} x_d(k t_{sam}) + d_d u(k t_{sam})
 ## }$$
 ## @end tex
 ## @end iftex
-## 
+##
 ## @strong{Signal partitions}
 ## @example
 ## @group
 ##         | continuous      | discrete               |
 ## ----------------------------------------------------
 ## states  | stname(1:n,:)   | stname((n+1):(n+nz),:) |
 ## ----------------------------------------------------
 ## outputs | outname(cout,:) | outname(outlist,:)     |
 ## ----------------------------------------------------
 ## @end group
 ## @end example
-## where @math{cout} is the list of in 1:@code{rows}(@var{p}) 
+## where @math{cout} is the list of in 1:@code{rows}(@var{p})
 ## that are not contained in outlist. (Discrete/continuous outputs
 ## may be entered in any order desired by the user.)
-## 
+##
 ## @strong{Example}
 ## @example
-## octave:1> a = [1 2 3; 4 5 6; 7 8 10]; 
+## octave:1> a = [1 2 3; 4 5 6; 7 8 10];
 ## octave:2> b = [0 0 ; 0 1 ; 1 0];
 ## octave:3> c = eye(3);
 ## octave:4> sys = ss2sys(a,b,c,[],0,3,0,list("volts","amps","joules"));
 ## octave:5> sysout(sys);
 ## Input(s)
 ##         1: u_1
 ##         2: u_2
-## 
+##
 ## Output(s):
 ##         1: y_1
 ##         2: y_2
 ##         3: y_3
-## 
+##
 ## state-space form:
 ## 3 continuous states, 0 discrete states
 ## State(s):
 ##         1: volts
 ##         2: amps
 ##         3: joules
-## 
+##
 ## A matrix: 3 x 3
 ##    1   2   3
 ##    4   5   6
 ##    7   8  10
 ## B matrix: 3 x 2
 ##   0  0
 ##   0  1
 ##   1  0
@@ -170,20 +170,19 @@
 ##   1  0  0
 ##   0  1  0
 ##   0  0  1
 ## D matrix: 3 x 3
 ##   0  0
 ##   0  0
 ##   0  0
 ## @end example
-## Notice that the @var{D} matrix is constructed  by default to the 
+## Notice that the @var{D} matrix is constructed  by default to the
 ## correct dimensions.  Default input and output signals names were assigned
 ## since none were given.
-## 
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 20, 1996
 
 function retsys = ss2sys (a, b, c, d, tsam, n, nz, stname, inname, outname, outlist)
 
   ## Test for correct number of inputs
@@ -215,52 +214,52 @@ function retsys = ss2sys (a, b, c, d, ts
   ## check for continuous states
   if( (nargin < 6) & (tsam == 0) )               n = na;
   elseif(nargin < 6)                             n = 0;
   elseif((!is_matrix(n)) | isstr(n))
     error("Parameter n is not a numerical value.");
   elseif( (!is_scalar(n)) | (n < 0 ) | (n != round(n)) )
     if(is_scalar(n))     error("illegal value of n=%d,%e",n,n);
     else                 error("illegal value of n=(%dx%d)", ...
-			   rows(n), columns(n));		endif
+                           rows(n), columns(n));                endif
   endif
 
   ## check for num discrete states
-  if( (nargin < 7) & (tsam == 0)) 		nz = 0;
-  elseif(nargin < 7)				nz = na - n;
+  if( (nargin < 7) & (tsam == 0))               nz = 0;
+  elseif(nargin < 7)                            nz = na - n;
   elseif((!is_matrix(nz)) | isstr(nz))
     error("Parameter nz is not a numerical value.");
   elseif( (!is_scalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
     if(is_scalar(nz))
       error(["illegal value of nz=",num2str(nz)]);
     else
       error(["illegal value of nz=(",num2str(rows(nz)),"x", ...
-	num2str(columns(nz)),")"]);
+        num2str(columns(nz)),")"]);
     endif
   endif
 
   ## check for total number of states
   if( (n + nz) != na )
     error(["Illegal: a is ",num2str(na),"x",num2str(na),", n=", ...
-	num2str(n),", nz=",num2str(nz)]);
+        num2str(n),", nz=",num2str(nz)]);
   endif
 
   ## construct system with default names
   retsys.a = a;
-  retsys.b = b; 
-  retsys.c = c; 
+  retsys.b = b;
+  retsys.c = c;
   retsys.d = d;
 
   retsys.n = n;
   retsys.nz = nz;
   retsys.tsam = tsam;
   retsys.yd = zeros(1,p);     # default value entered below
 
   ## Set the system vector:  active = 2(ss), updated = [0 0 1];
-  retsys.sys = [2, 0, 0, 1]; 
+  retsys.sys = [2, 0, 0, 1];
 
   retsys.stname = sysdefstname(n,nz);
   retsys.inname = sysdefioname(m,"u");
   retsys.outname = sysdefioname(p,"y");
 
   ## check for state names
   if(nargin >= 8)
     if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
@@ -275,14 +274,14 @@ function retsys = ss2sys (a, b, c, d, ts
   if(nargin >= 10)
     if(!isempty(outname)) retsys = syssetsignals(retsys,"out",outname); endif
   endif
 
   ## set up yd
   if(nargin < 11)
     retsys = syssetsignals(retsys,"yd",ones(1,p)*(tsam > 0));
   else
-    if(!isempty(outlist)) 
+    if(!isempty(outlist))
       retsys = syssetsignals(retsys,"yd",ones(size(outlist)),outlist);
     endif
   endif
 
 endfunction
diff --git a/scripts/control/ss2tf.m b/scripts/control/ss2tf.m
--- a/scripts/control/ss2tf.m
+++ b/scripts/control/ss2tf.m
@@ -1,48 +1,46 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
-## @deftypefn {Function File } { outputs =} ss2tf ( inputs ) 
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{outputs} =} ss2tf (@var{inputs})
 ## @format
-##  [num,den] = ss2tf(a,b,c,d)
-##  Conversion from tranfer function to state-space.
-##  The state space system
-##       . 
+## [num,den] = ss2tf(a,b,c,d)
+## Conversion from tranfer function to state-space.
+## The state space system
+##       .
 ##       x = Ax + Bu
 ##       y = Cx + Du
-## 
-##  is converted to a transfer function
-## 
+##
+## is converted to a transfer function
+##
 ##                 num(s)
 ##           G(s)=-------
 ##                 den(s)
-## 
-##  used internally in system data structure format manipulations
-## 
-## 
+##
+## used internally in system data structure format manipulations
 ## @end format
 ## @end deftypefn
- 
+
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 24, 1994
 ## a s hodel: modified to allow for pure gain blocks Aug 1996
 
 function [num, den] = ss2tf (a, b, c, d)
 
   ## Check args
   [n,m,p] = abcddim(a,b,c,d);
@@ -50,33 +48,33 @@ function [num, den] = ss2tf (a, b, c, d)
     num = [];
     den = [];
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
     num = [];
     den = [];
     error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
   endif
-  
+
   if(n == 0)
     ## gain block only
     num = d;
     den = 1;
   else
     ## First, get the denominator coefficients
     den = poly(a);
-  
+
     ## Get the zeros of the system
     [zz,g] = tzero(a,b,c,d);
 
     ## Form the Numerator (and include the gain)
     if (!isempty(zz))
       num = g * poly(zz);
     else
       num = g;
     endif
-  
+
     ## the coefficients must be real
     den = real(den);
     num = real(num);
   endif
 endfunction
 
diff --git a/scripts/control/ss2zp.m b/scripts/control/ss2zp.m
--- a/scripts/control/ss2zp.m
+++ b/scripts/control/ss2zp.m
@@ -1,37 +1,35 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} ss2zp ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} ss2zp (@var{inputs})
 ## @format
-##  Converts a state space representation to a set of poles and zeros.
-## 
-##  [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space 
-##  system (a,b,c,d).  K is a gain associated with the zeros.
-## 
-##  used internally in system data structure format manipulations
-## 
-## 
+## Converts a state space representation to a set of poles and zeros.
+##
+## [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space
+## system (a,b,c,d).  K is a gain associated with the zeros.
+##
+## used internally in system data structure format manipulations
 ## @end format
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Hodel: changed order of output arguments to zer, pol, k. July 1996
 ## a s hodel: added argument checking, allow for pure gain blocks aug 1996
 
@@ -42,17 +40,17 @@ function [zer, pol, k] = ss2zp (a, b, c,
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
     error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
   endif
- 
+
   if(n == 0)
     ## gain block only
     k = d;
     zer = pol = [];
   else
     ## First, get the denominator coefficients
     [zer,k] = tzero(a,b,c,d);
     pol = eig(a);
diff --git a/scripts/control/starp.m b/scripts/control/starp.m
--- a/scripts/control/starp.m
+++ b/scripts/control/starp.m
@@ -1,56 +1,56 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} starp ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} starp (@var{inputs})
 ## @format
-## 
-##  sys = starp(P, K, ny, nu)
-## 
-##  Redheffer star product or upper/lower LFT, respectively.
-## 
-## 
+##
+## sys = starp(P, K, ny, nu)
+##
+## Redheffer star product or upper/lower LFT, respectively.
+##
+##
 ##                +-------+
-##      --------->|       |---------> 
+##      --------->|       |--------->
 ##                |   P   |
 ##           +--->|       |---+  ny
 ##           |    +-------+   |
 ##           +-------------------+
 ##                            |  |
 ##           +----------------+  |
 ##           |                   |
 ##           |    +-------+      |
-##           +--->|       |------+ nu 
+##           +--->|       |------+ nu
 ##                |   K   |
 ##      --------->|       |--------->
 ##                +-------+
-## 
-##  If ny and nu "consume" all inputs and outputs of K then the result
-##  is a lower fractional transformation. If ny and nu "consume" all
-##  inputs and outputs of P then the result is an upper fractional
-##  transformation.
-## 
-##  ny and/or nu may be negative (= negative feedback)
+##
+## If ny and nu "consume" all inputs and outputs of K then the result
+## is a lower fractional transformation. If ny and nu "consume" all
+## inputs and outputs of P then the result is an upper fractional
+## transformation.
+##
+## ny and/or nu may be negative (= negative feedback)
 ## @end format
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: May 1998
 
 function sys = starp (P, K, ny, nu);
 
diff --git a/scripts/control/step.m b/scripts/control/step.m
--- a/scripts/control/step.m
+++ b/scripts/control/step.m
@@ -1,52 +1,52 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{y}, @var{t}] =} step (@var{sys}@{, @var{inp},@var{tstop}, @var{n}@})
+## @deftypefn {Function File} {[@var{y}, @var{t}] =} step (@var{sys}@{, @var{inp},@var{tstop}, @var{n}@})
 ## Step response for a linear system.
-##        The system can be discrete or multivariable (or both).
+## The system can be discrete or multivariable (or both).
 ## If no output arguments are specified, @code{step}
-##  produces a plot or the step response data for system @var{sys}.
-## 
+## produces a plot or the step response data for system @var{sys}.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## System data structure.
 ## @item inp
 ## Index of input being excited
 ## @item tstop
-##  The argument @var{tstop} (scalar value) denotes the time when the
-##  simulation should end. 
+## The argument @var{tstop} (scalar value) denotes the time when the
+## simulation should end.
 ## @item n
 ## the number of data values.
-## 
-##  Both parameters @var{tstop} and @var{n} can be omitted and will be
-##  computed from the eigenvalues of the A-Matrix.
+##
+## Both parameters @var{tstop} and @var{n} can be omitted and will be
+## computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
-## 
-## When invoked with the output paramter y the plot is not displayed.  
+##
+## When invoked with the output paramter y the plot is not displayed.
 ## @end deftypefn
 ## @seealso{impulse and stepimp}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = step (sys, inp, tstop, n)
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -1,50 +1,49 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[y, t] = } stepimp(@var{sitype},@var{sys}[, @var{inp}, @var{tstop}, @var{n}]) 
+## @deftypefn {Function File} {[@var{y}, @var{t}] = } stepimp (@var{sitype}, @var{sys} [, @var{inp}, @var{tstop}, @var{n}])
 ## Impulse or step response for a linear system.
-##       The system can be discrete or multivariable (or both).
-##       This m-file contains the "common code" of step and impulse.
-## 
+## The system can be discrete or multivariable (or both).
+## This m-file contains the "common code" of step and impulse.
+##
 ## Produces a plot or the response data for system sys.
-## 
+##
 ## Limited argument checking; "do not attempt to do this at home".
 ## Used internally in @code{impulse}, @code{step}. Use @code{step}
 ## or @code{impulse} instead.
-## 
 ## @end deftypefn
 ## @seealso{step and impulse}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = stepimp (sitype, sys, inp, tstop, n)
 
   if (sitype == 1)         IMPULSE = 0;
   elseif (sitype == 2)     IMPULSE = 1;
-  else		   	   error("stepimp: illegal sitype argument.")
+  else                     error("stepimp: illegal sitype argument.")
   endif
   sys = sysupdate(sys,"ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
   N_MIN = 50;    # minimum number of points
   N_MAX = 2000;  # maximum number of points
   T_DEF = 10.0;  # default simulation time
 
@@ -69,21 +68,21 @@ function [y, t] = stepimp (sitype, sys, 
   if (nargin < 5)
     ## we have to compute the time when the system reaches steady state
     ## and the step size
     ev = eig(sys2ss(sys));
     if (DIGITAL)
       ## perform bilinear transformation on poles in z
       for i = 1:NSTATES
         pole = ev(i);
-	if (abs(pole + 1) < 1.0e-10)
-	  ev(i) = 0;
-	else
-	  ev(i) = 2 / TSAMPLE * (pole - 1) / (pole + 1);
-	endif
+        if (abs(pole + 1) < 1.0e-10)
+          ev(i) = 0;
+        else
+          ev(i) = 2 / TSAMPLE * (pole - 1) / (pole + 1);
+        endif
       endfor
     endif
     ## remove poles near zero from eigenvalue array ev
     nk = NSTATES;
     for i = 1:NSTATES
       if (abs(ev(i)) < 1.0e-10)
         ev(i) = 0;
         nk = nk - 1;
@@ -97,17 +96,17 @@ function [y, t] = stepimp (sitype, sys, 
       x = max(abs(ev));
       t_step = 0.2 * pi / x;
       x = min(abs(real(ev)));
       t_sim = 5.0 / x;
       ## round up
       yy = 10^(ceil(log10(t_sim)) - 1);
       t_sim = yy * ceil(t_sim / yy);
       ## printf("##STEPIMP-DEBUG: nk=%d   t_step=%f  t_sim=%f\n",
-      ##   nk, t_step, t_sim);  
+      ##   nk, t_step, t_sim);
     endif
   endif
 
   if (DIGITAL)
     ## ---- sampled system
     if (nargin == 5)
       n = round(n);
       if (n < 2)
@@ -122,20 +121,20 @@ function [y, t] = stepimp (sitype, sys, 
           tstop = (N_MIN - 1) * TSAMPLE;
         else
           tstop = t_sim;
         endif
       endif
       n = floor(tstop / TSAMPLE) + 1;
       if (n < 2)  n = 2;  endif
       if (n > N_MAX)
-	n = N_MAX;
-	printf("Hint: number of samples limited to %d by default.\n", \
-	       N_MAX);
-	printf("  ==> increase \"n\" parameter for longer simulations.\n");
+        n = N_MAX;
+        printf("Hint: number of samples limited to %d by default.\n", \
+               N_MAX);
+        printf("  ==> increase \"n\" parameter for longer simulations.\n");
       endif
     endif
     tstop = (n - 1) * TSAMPLE;
     t_step = TSAMPLE;
   else
     ## ---- continuous system
     if (nargin == 5)
       n = round(n);
@@ -143,39 +142,39 @@ function [y, t] = stepimp (sitype, sys, 
         error("step: n must not be less than 2.")
       endif
       t_step = tstop / (n - 1);
     else
       if (nargin == 4)
         ## only n in unknown
         if (USE_DEF)
           n = N_MIN;
-	  t_step = tstop / (n - 1);
+          t_step = tstop / (n - 1);
         else
           n = floor(tstop / t_step) + 1;
         endif
       else
         ## tstop and n are unknown
         if (USE_DEF)
           tstop = T_DEF;
-	  n = N_MIN;
-	  t_step = tstop / (n - 1);
+          n = N_MIN;
+          t_step = tstop / (n - 1);
         else
           tstop = t_sim;
           n = floor(tstop / t_step) + 1;
         endif
       endif
       if (n < N_MIN)
-	n = N_MIN;
+        n = N_MIN;
         t_step = tstop / (n - 1);
       endif
       if (n > N_MAX)
-    	tstop = (n - 1) * t_step;
-	t_step = tstop / (N_MAX - 1);
-	n = N_MAX;
+        tstop = (n - 1) * t_step;
+        t_step = tstop / (N_MAX - 1);
+        n = N_MAX;
       endif
     endif
     tstop = (n - 1) * t_step;
     [jnk,B] = sys2ss(sys);
     B = B(:,inp);
     sys = c2d(sys, t_step);
   endif
   ## printf("##STEPIMP-DEBUG: t_step=%f n=%d  tstop=%f\n", t_step, n, tstop);
@@ -217,64 +216,64 @@ function [y, t] = stepimp (sitype, sys, 
     gset nogrid
     gset nologscale
     gset autoscale
     gset nokey
     clearplot();
     if (gnuplot_has_multiplot)
       if (IMPULSE)
         gm = zeros(NOUT, 1);
-	tt = "impulse";
+        tt = "impulse";
       else
         ssys = ss2sys(F, G, C, D, t_step);
         gm = dcgain(ssys);
-	tt = "step";
+        tt = "step";
       endif
       ncols = floor(sqrt(NOUT));
       nrows = ceil(NOUT / ncols);
       for i = 1:NOUT
         subplot(nrows, ncols, i);
-	title(sprintf("%s: | %s -> %s", tt,sysgetsignals(sys,"in",inp,1), ...
-	  sysgetsignals(sys,"out",i,1)));
-	if (DIGITAL)
-	  [ts, ys] = stairs(t, y(i,:));
-	  ts = ts(1:2*n-2)';  ys = ys(1:2*n-2)';
-	  if (length(gm) > 0)
-	    yy = [ys; gm(i)*ones(size(ts))];
-	  else
-	    yy = ys;
-	  endif
-	  grid("on");
-	  xlabel("time [s]");
-	  ylabel("y(t)");
+        title(sprintf("%s: | %s -> %s", tt,sysgetsignals(sys,"in",inp,1), ...
+          sysgetsignals(sys,"out",i,1)));
+        if (DIGITAL)
+          [ts, ys] = stairs(t, y(i,:));
+          ts = ts(1:2*n-2)';  ys = ys(1:2*n-2)';
+          if (length(gm) > 0)
+            yy = [ys; gm(i)*ones(size(ts))];
+          else
+            yy = ys;
+          endif
+          grid("on");
+          xlabel("time [s]");
+          ylabel("y(t)");
           plot(ts, yy);
-	else
-	  if (length(gm) > 0)
-	    yy = [y(i,:); gm(i)*ones(size(t))];
-	  else
-	    yy = y(i,:);
-	  endif
-	  grid("on");
-	  xlabel("time [s]");
-	  ylabel("y(t)");
-	  plot(t, yy);
-	endif
+        else
+          if (length(gm) > 0)
+            yy = [y(i,:); gm(i)*ones(size(t))];
+          else
+            yy = y(i,:);
+          endif
+          grid("on");
+          xlabel("time [s]");
+          ylabel("y(t)");
+          plot(t, yy);
+        endif
       endfor
       ## leave gnuplot in multiplot mode is bad style
       oneplot();
     else
       ## plot everything in one diagram
       title([tt, " response | ", sysgetsignals(sys,"in",inp,1), ...
-	" -> all outputs"]);
+        " -> all outputs"]);
       if (DIGITAL)
         stairs(t, y(i,:));
       else
-	grid("on");
-	xlabel("time [s]");
-	ylabel("y(t)");
-	plot(t, y(i,:));
+        grid("on");
+        xlabel("time [s]");
+        ylabel("y(t)");
+        plot(t, y(i,:));
       endif
     endif
     y=[];
     t=[];
   endif
   ## printf("##STEPIMP-DEBUG: gratulations, successfull completion.\n");
 endfunction
diff --git a/scripts/control/strappend.m b/scripts/control/strappend.m
--- a/scripts/control/strappend.m
+++ b/scripts/control/strappend.m
@@ -1,29 +1,29 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## retval = strappend(strlist,suffix);
 ## append string suffix to each string in the list of strings strlist
-  
+
 function retval = strappend (strlist, suffix);
 
   if(nargin != 2 | nargout > 1)
     usage(" retval = strappend(strlist,suffix)");
   elseif(!is_signal_list(strlist))
     strlist
     error("strlist must be a list of strings (see is_signal_list)");
   elseif(!(isstr(suffix) & rows(suffix) == 1))
diff --git a/scripts/control/susball.m b/scripts/control/susball.m
--- a/scripts/control/susball.m
+++ b/scripts/control/susball.m
@@ -1,44 +1,42 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} susball ( inputs ) 
-## @format
-## @end format
+## @deftypefn {Function File} {@var{outputs} =} susball (@var{inputs})
 ## @end deftypefn
 
 cmd = "ballsys = margetsys(""disc"")";
 eval(cmd);
 
 disp("Design LQG controller");
 cmd = "sysout(ballsys)";
 run_cmd
 disp("add noise inputs to system...")
 
 disp("discrete system:")
 [nn,nz,mm,pp] = sysdimensions(ballsys);
 cmd = "ballsys = sysappend(ballsys,nz);";
-run_cmd 
+run_cmd
 
 cmd = "sysout(ballsys)";
 run_cmd
 
 disp("Notice the two additional inputs, u_2, and u_3.  These are the ");
 disp("""entry points"" for the gaussian noise disturbance.");
 disp(" ");
 disp("We'll design the controller to use only position feedback:")
diff --git a/scripts/control/swap.m b/scripts/control/swap.m
--- a/scripts/control/swap.m
+++ b/scripts/control/swap.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} swap ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} swap (@var{inputs})
 ## @format
-##  [a1,b1] = swap(a,b)
-##  interchange a and b
+## [a1,b1] = swap(a,b)
+## interchange a and b
 ## @end format
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
 function [a1, b1] = swap (a, b)
diff --git a/scripts/control/sys2fir.m b/scripts/control/sys2fir.m
--- a/scripts/control/sys2fir.m
+++ b/scripts/control/sys2fir.m
@@ -1,53 +1,52 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{c}, @var{tsam}, @var{input}, @var{output}] =} sys2fir (@var{sys})
-## 
+## @deftypefn {Function File} {[@var{c}, @var{tsam}, @var{input}, @var{output}] =} sys2fir (@var{sys})
+##
 ## Extract FIR data from system data structure; see @ref{fir2sys} for
 ## parameter descriptions.
-## 
 ## @end deftypefn
 ## @seealso{fir2sys}
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function [c, tsam, inname, outname] = sys2fir (sys)
 
   ## let sys2tf do most of the work
 
   [num,den,tsam,inname,outname] = sys2tf(sys);
 
-  alph = den(1);			# scale to get monic denominator
+  alph = den(1);                        # scale to get monic denominator
   den = den/alph;
   num = num/alph;
   l = length(den);
   m = length(num);
   if( norm(den(2:l)) )
     sysout(sys,"tf");
     error("denominator has poles away from origin");
   elseif( !is_digital(sys) )
     error("system must be discrete-time to be FIR");
   elseif(m != l)
     warning(["sys2fir: deg(num) - deg(den) = ",num2str(m-l), ...
-	"; coefficients must be shifted"]);
+        "; coefficients must be shifted"]);
   endif
   c = num;
 endfunction
 
diff --git a/scripts/control/sys2ss.m b/scripts/control/sys2ss.m
--- a/scripts/control/sys2ss.m
+++ b/scripts/control/sys2ss.m
@@ -1,78 +1,78 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{a},@var{b},@var{c},@var{d},@var{tsam},@var{n},@var{nz},@var{stname},@var{inname},@var{outname},@var{yd}] =} sys2ss (@var{sys})
-## Extract state space representation from system data structure.  
-## 
+## @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam},@var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{yd}] =} sys2ss (@var{sys})
+## Extract state space representation from system data structure.
+##
 ## @strong{Inputs}
 ## @var{sys} system data structure (@pxref{sysstruct})
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
-##  state space matrices for sys
-## 
+## state space matrices for sys
+##
 ## @item tsam
-##  sampling time of sys (0 if continuous)
-## 
+## sampling time of sys (0 if continuous)
+##
 ## @item n
 ## @itemx nz
-##  number of continuous, discrete states (discrete states come
-##           last in state vector @var{x})
-## 
+## number of continuous, discrete states (discrete states come
+## last in state vector @var{x})
+##
 ## @item stname
 ## @itemx inname
 ## @itemx outname
-##  signal names (lists of strings);  names of states,
-##           inputs, and outputs, respectively
-## 
+## signal names (lists of strings);  names of states,
+## inputs, and outputs, respectively
+##
 ## @item yd
-##  binary vector; @var{yd}(@var{ii}) is 1 if output @var{y}(@var{ii})$
-##  is discrete (sampled); otherwise  @var{yd}(@var{ii}) 0.
-##  
+## binary vector; @var{yd}(@var{ii}) is 1 if output @var{y}(@var{ii})$
+## is discrete (sampled); otherwise  @var{yd}(@var{ii}) 0.
+##
 ## @end table
 ## A warning massage is printed if the system is a mixed
 ## continuous and discrete system
-## 
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=tf2sys([1 2],[3 4 5]);
 ## octave:2> [a,b,c,d] = sys2ss(sys)
 ## a =
 ##    0.00000   1.00000
 ##   -1.66667  -1.33333
 ## b =
 ##   0
 ##   1
 ## c = 0.66667  0.33333
 ## d = 0
 ## @end example
 ## @end deftypefn
- 
+
 ## Author: David Clem
 ## Created: August 19, 1994
 ## Updates by John Ingram July 14, 1996
 
 function [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys)
 
   if(nargin != 1)
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
diff --git a/scripts/control/sys2tf.m b/scripts/control/sys2tf.m
--- a/scripts/control/sys2tf.m
+++ b/scripts/control/sys2tf.m
@@ -1,32 +1,32 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{num},@var{den},@var{tsam},@var{inname},@var{outname}] =} sys2tf (@var{sys})
+## @deftypefn {Function File} {[@var{num}, @var{den}, @var{tsam}, @var{inname}, @var{outname}] =} sys2tf (@var{sys})
 ## Extract transfer function data from a system data structure
-## 
+##
 ## See @ref{tf2sys} for parameter descriptions.
-## 
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [num,den] = sys2tf(sys)
 ## num = 1.0000  -3.0000
 ## den = 1.0000   1.1000  -4.3000
 ## @end example
 ## @end deftypefn
@@ -45,19 +45,19 @@ function [num, den, tsam, inname, outnam
   if( !is_struct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, zp2sys)");
   elseif (! is_siso(Asys) )
     [n, nz, m, p] = sysdimensions(Asys);
     error(["system is not SISO (",num2str(m)," inputs, ...
         ", num2str(p)," outputs"]);
   endif
 
-  Asys = sysupdate(Asys,"tf");		# just in case
+  Asys = sysupdate(Asys,"tf");          # just in case
 
   num = Asys.num;
   den = Asys.den;
-  
+
   tsam = sysgettsam(Asys);
   inname = sysgetsignals(Asys,"in");
   outname = sysgetsignals(Asys,"out");
 
 endfunction
 
diff --git a/scripts/control/sys2zp.m b/scripts/control/sys2zp.m
--- a/scripts/control/sys2zp.m
+++ b/scripts/control/sys2zp.m
@@ -1,58 +1,58 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File } {[@var{zer}, @var{pol}, @var{k}, @var{tsam}, @var{inname}, @var{outname}] =} sys2zp (@var{sys})
+##@deftypefn {Function File} {[@var{zer}, @var{pol}, @var{k}, @var{tsam}, @var{inname}, @var{outname}] =} sys2zp (@var{sys})
 ## Extract zero/pole/leading coefficient information from a system data
 ## structure
-## 
+##
 ## See @ref{zp2sys} for parameter descriptions.
-## 
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [zer,pol,k] = sys2zp(sys)
 ## zer = 3.0000
 ## pol =
 ##   -2.6953
 ##    1.5953
 ## k = 1
 ## @end example
 ## @end deftypefn
- 
+
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 15, 1996
 
 function [zer, pol, k, tsam, inname, outname] = sys2zp (sys)
 
   if(nargin != 1)
     usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
   elseif( !is_struct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
     [n, nz, m, p] = sysdimensions(sys);
     error(["system is not SISO (",num2str(m)," inputs, ...
-	", num2str(p)," outputs"]);
+        ", num2str(p)," outputs"]);
   endif
 
   ## update zero-pole form
   sys = sysupdate(sys,"zp");
 
   zer = sys.zer;
   pol = sys.pol;
   k = sys.k;
diff --git a/scripts/control/sysadd.m b/scripts/control/sysadd.m
--- a/scripts/control/sysadd.m
+++ b/scripts/control/sysadd.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1996, 1999 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =}  sysadd ( @var{Gsys},@var{Hsys})
-## returns @var{sys} = @var{Gsys} + @var{Hsys}.  
+## @deftypefn {Function File} {@var{sys} =}  sysadd (@var{Gsys}, @var{Hsys})
+## returns @var{sys} = @var{Gsys} + @var{Hsys}.
 ## @itemize @bullet
 ## @item Exits with
 ## an error if @var{Gsys} and @var{Hsys} are not compatibly dimensioned.
 ## @item Prints a warning message is system states have identical names;
-##   duplicate names are given a suffix to make them unique.
+## duplicate names are given a suffix to make them unique.
 ## @item @var{sys} input/output names are taken from @var{Gsys}.
 ## @end itemize
 ## @example
 ## @group
 ##           ________
 ##      ----|  Gsys  |---
-## u   |    ----------  +|         
+## u   |    ----------  +|
 ## -----                (_)----> y
 ##     |     ________   +|
 ##      ----|  Hsys  |---
 ##           --------
 ## @end group
 ## @end example
 ## @end deftypefn
- 
+
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## Updated for variable number of arguments July 1999 A. S. Hodel
 
 function sys = sysadd (...)
 
   if(nargin < 1)
     usage("sysadd: sys = sysysadd(Gsys{,Hsys, ...})");
@@ -83,34 +83,34 @@ function sys = sysadd (...)
       if(length(Hden) == length(Gden) )
         if( (Hden == Gden) & (HT == GT) )
           sys = tf2sys(Gnum+Hnum,Gden,GT,Gin,Gout);
           return
         endif
         ## if not, we go on and do the usual thing...
       endif
     endif
-  
+
     ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
-  
+
     ## change signal names to avoid warning messages from sysgroup
     Gsys = syssetsignals(Gsys,"in",sysdefioname(length(Gin),"Gin_u"));
     Gsys = syssetsignals(Gsys,"out",sysdefioname(length(Gout),"Gout_u"));
     Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
     Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
-    
+
     sys = sysgroup(Gsys,Hsys);
-  
+
     eyin = eye(mg);
     eyout = eye(pg);
-  
+
     sys = sysscale(sys,[eyout, eyout],[eyin;eyin],Gout,Gin);
-  
+
   else
     ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       sys = sysadd(sys,nth(arglist,kk));
     endfor
   endif
 
diff --git a/scripts/control/sysappend.m b/scripts/control/sysappend.m
--- a/scripts/control/sysappend.m
+++ b/scripts/control/sysappend.m
@@ -1,144 +1,142 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{retsys} =} sysappend (@var{sys},@var{b}@{, @var{c}, @var{d}, @var{outname}, @var{inname}, @var{yd}@})
+## @deftypefn {Function File} {@var{retsys} =} sysappend (@var{sys}, @var{b}@{, @var{c}, @var{d}, @var{outname}, @var{inname}, @var{yd}@})
 ## appends new inputs and/or outputs to a system
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure
-## 
+##
 ## @item b
 ## matrix to be appended to sys "B" matrix (empty if none)
-## 
+##
 ## @item c
 ## matrix to be appended to sys "C" matrix (empty if none)
-## 
+##
 ## @item d
 ## revised sys d matrix (can be passed as [] if the revised d is all zeros)
-## 
+##
 ## @item outname
 ## list of names for new outputs
-## 
+##
 ## @item inname
 ## list of names for new inputs
-## 
+##
 ## @item yd
 ## binary vector; @math{yd(ii)=0} indicates a continuous output;
 ## @math{yd(ii)=1} indicates a discrete output.
 ## @end table
-## 
+##
 ## @strong{Outputs} @var{sys}
 ## @example
 ## @group
 ##    sys.b := [sys.b , b]
 ##    sys.c := [sys.c  ]
 ##             [ c     ]
 ##    sys.d := [sys.d | D12 ]
 ##             [D21   | D22 ]
 ## @end group
 ## @end example
-## where @var{D12}, @var{D21}, and @var{D22} are the appropriate dimensioned 
-## blocks of the input parameter @var{d}.  
+## where @var{D12}, @var{D21}, and @var{D22} are the appropriate dimensioned
+## blocks of the input parameter @var{d}.
 ## @itemize @bullet
 ## @item The leading block @var{D11} of @var{d} is ignored.
-## @item If @var{inname} and @var{outname} are not given as arguments, 
-## 	the new inputs and outputs are be assigned default names.  
+## @item If @var{inname} and @var{outname} are not given as arguments,
+##      the new inputs and outputs are be assigned default names.
 ## @item @var{yd} is a binary vector of length rows(c) that indicates
-## 	continuous/sampled outputs.  Default value for @var{yd} is:
-## 
+##      continuous/sampled outputs.  Default value for @var{yd} is:
+##
 ## @item @var{sys} = continuous or mixed
 ## @var{yd} = @code{zeros(1,rows(c))}
-## 
+##
 ## @item @var{sys} = discrete
 ## @var{yd} = @code{ones(1,rows(c))}
-## 
 ## @end itemize
-## 
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
-  
+
 function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
   sav_empty_list_elements_ok = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;
-  
+
   ## check input arguments
   if ( (nargin < 2) | (nargin > 7) | (!is_struct(sys)))
     usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
   elseif(!is_struct(sys))
     error("sys must be a system data structure");
   endif
-  
+
   ## default system type must be state space form
   [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
   [Ann,Anz,Am,Ap] = sysdimensions(sys);
 
   ## default c
   if(nargin < 3)      c = [];                                endif
-  
+
   ## default d
   if(nargin < 4)     make_d = 1;
   elseif(isempty(d)) make_d = 1;
   else               make_d = 0;                             endif
   if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
 
   ## Append new input(s) if any
   Bm = max(columns(d),columns(b)+Am);
-  if(Bm != Am)    
+  if(Bm != Am)
     ## construct new signal names
     if(nargin >= 6)   # new names were passed
       if(!isstr(inname))
         error("inname must be a string");
       elseif(rows(inname) != (Bm - Am))
         error(sprintf("%d new inputs requested; inname(%dx%d)", ...
-	  (Bm-Am),rows(inname),columns(inname)));
+          (Bm-Am),rows(inname),columns(inname)));
       endif
     else
       inname = sysdefioname(Bm,"u",(Am+1));
     endif
     if(Am)   Ain = append(Ain,inname);
-    else     Ain = inname;		endif
+    else     Ain = inname;              endif
 
     ## default b matrix
-    if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));          
+    if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));
     elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
         error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
           (Ann+Anz), (Bm-Am)));
     endif
 
     ## append new b matrix
     Ab = [Ab,b];    # empty_list_elements_ok=1 makes this ok
   endif
 
   ## Append new output(s) if any
   Bp = max(rows(d),rows(c)+Ap);
-  if(Bp != Ap)  
+  if(Bp != Ap)
 
     ## construct new signal names, output classification
     if(nargin >= 5)  # new names were passed
       if(!isstr(outname))
         error("outname must be a string");
       elseif(rows(outname) != (Bp - Ap))
         error(sprintf("%d new outputs requested; outname(%dx%d)", ...
           (Bp-Ap),rows(outname),columns(outname)));
@@ -150,43 +148,43 @@ function retsys = sysappend (sys, b, c, 
     else     Aout = outname;                endif
 
     ## construct new yd entries
     if(nargin == 7)
       if(!is_vector(yd))
         error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
       elseif(rows(c) != length(yd) & rows(d) != length(yd))
         error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
-	  length(yd), rows(c), columns(c),rows(d),columns(d)));
+          length(yd), rows(c), columns(c),rows(d),columns(d)));
       endif
     else
       ## default yd values
       yd = ones(1,Bp)*( (Ats > 0) & (Ann == 0)  & isempty(find(Ayd == 0)) ) ;
     endif
     Ayd = [vec(Ayd);vec(yd)];
 
     ## default c matrix
-    if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);          
+    if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);
     elseif(columns(c) != Ann+Anz | rows(c) != (Bp-Ap))
         error(sprintf("c(%dx%d); should be (%dx%d)", rows(c), columns(c), ...
           (Bp-Ap), (Ann+Anz) ));
     endif
 
     ## append new c matrix
     Ac = [Ac;c];    # empty_list_elements_ok=1 makes this ok
   endif
 
   ## check d matrix
   if(isempty(d)) d = zeros(Bp,Bm);
   elseif(rows(d) != Bp | columns(d) != Bm)
     error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
   endif
 
-  ## Splice in original D matrix  
+  ## Splice in original D matrix
   if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
   Ad = d;
-  
+
   ## construct return system
   retsys = ss2sys(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
-  
+
   empty_list_elements_ok = sav_empty_list_elements_ok;
 
 endfunction
diff --git a/scripts/control/syschnamesl.m b/scripts/control/syschnamesl.m
--- a/scripts/control/syschnamesl.m
+++ b/scripts/control/syschnamesl.m
@@ -1,39 +1,39 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } syschnamesl 
-##  used internally in syschnames
-##  item olist: index list 
-##  old_names: original list names
-##  inames: new names
-##  listname: name of index list
-## 
-##  combines the two string lists old_names and inames
+## @deftypefn {Function File} {@var{old_names} =} syschnamesl (@var{olist}, @var{old_names}, @var{inames}, @var{listname})
+## used internally in syschnames
+## item olist: index list
+## old_names: original list names
+## inames: new names
+## listname: name of index list
+##
+## combines the two string lists old_names and inames
 ## @end deftypefn
- 
+
 function old_names = syschnamesl (olist, old_names, inames, listname)
-  
+
   probstr = [];
   if( max(olist) > rows(old_names) )
     probstr = ["index list value(s) exceed(s) number of signals (", ...
       num2str(rows(old_names)),")"];
 
   elseif( length(olist) > rows(inames) )
     probstr = ["index list dimension exceeds number of replacement names (", ...
       num2str(rows(inames)),")"];
@@ -41,56 +41,56 @@ function old_names = syschnamesl (olist,
   elseif(isempty(olist))
     probstr = [];    # do nothing, no changes
 
   elseif(min(size(olist)) != 1 )
     probstr = "index list must be either a vector or an empty matrix";
 
   elseif(max(olist) > rows(old_names))
     probstr = ["max(",listname,")=",num2str(max(olist))," > ", ...
-	num2str(rows(old_names)),", too big"];
+        num2str(rows(old_names)),", too big"];
 
   elseif(min(olist) < 1)
     probstr = ["min(",listname,")=",num2str(min(olist))," < 1, too small"];
 
   else
     if( length(olist)  == 1)
-	len_in = columns(inames);
-	len_out = columns(old_names);
+        len_in = columns(inames);
+        len_out = columns(old_names);
 
       if (len_in < len_out)
         inames(1,(len_in+1):(len_out)) = zeros(1,(len_out - len_in));
       endif
 
       old_names(olist,1:length(inames)) = inames;
     elseif(length(olist) > 1)
       for ii=1:length(olist)
         mystr = inames(ii,:);
-	len_my = columns(mystr);
+        len_my = columns(mystr);
         len_out = columns(old_names);
-       
+
         if (len_my < len_out)
           mystr(1,(len_my+1):(len_out)) = " "*ones(1,(len_out - len_my));
-	  len_my = len_out;
+          len_my = len_out;
         endif
 
         old_names(olist(ii),1:len_my) = mystr;
       endfor
     endif
   endif
   if(!isempty(probstr))
     ## the following lines are NOT debugging code!
     disp("Problem in syschnames: old names are")
-    outlist(old_names,"	")
+    outlist(old_names," ")
     disp("new names are")
-    outlist(inames,"	")
+    outlist(inames,"    ")
     disp("list indices are")
     disp(olist)
     error(sprintf("syschnames: \"%s\" dim=(%d x %d)--\n\t%s\n", ...
-	listname, rows(olist), columns(olist),probstr));
+        listname, rows(olist), columns(olist),probstr));
   endif
 
   ## change zeros  to blanks
   if( find(old_names == 0) )
     ## disp("syschnamesl: old_names contains zeros ")
     ## old_names
     ## disp("/syschnamesl");
 
@@ -103,14 +103,14 @@ function old_names = syschnamesl (olist,
     ## old_names
     ## disp("/syschnamesl");
   endif
 
   ## just in case it's not a string anymore
   if( !isstr(old_names) )
     old_names = setstr(old_names);
   endif
-  
+
   ## disp("syschnamesl: exit, old_names=")
   ## old_names
   ## disp("/syschnamesl: exiting")
-  
+
 endfunction
diff --git a/scripts/control/syschtsam.m b/scripts/control/syschtsam.m
--- a/scripts/control/syschtsam.m
+++ b/scripts/control/syschtsam.m
@@ -1,32 +1,32 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { retsys =} syschtsam ( sys,tsam ) 
+## @deftypefn {Function File} {@var{retsys} =} syschtsam (@var{sys}, @var{tsam})
 ## This function changes the sampling time (tsam) of the system.  Exits with
 ## an error if sys is purely continuous time.
 ## @end deftypefn
- 
+
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syschtsam (sys, tsam)
 
   if (nargin != 2)
     usage("retsys = syschtsam(sys,tsam)");
   elseif (!is_struct(sys))
@@ -39,12 +39,12 @@ function retsys = syschtsam (sys, tsam)
     error("tsam must be real, scalar, and greater than zero");
   elseif (sysgettsam(sys) == 0)
     [nc,nz,mm,pp] = sysdimensions(sys);
     warning("syschtsam: continuous system (nc=%d, nz=%d, mm=%d, pp=%d)", ...
       nc,nz,mm,pp);
     warning("syschtsam: The system is continuous, use c2d to make the system discrete");
   endif
 
-  retsys = sys;  
+  retsys = sys;
   retsys.tsam = tsam;
 
 endfunction
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -1,72 +1,71 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
-## @deftypefn {Function File } {@var{retsys} =} sysconnect (@var{sys}, @var{out_idx},@var{in_idx}@{,@var{order}, @var{tol}@})
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{retsys} =} sysconnect (@var{sys}, @var{out_idx},@var{in_idx}@{,@var{order}, @var{tol}@})
 ## Close the loop from specified outputs to respective specified inputs
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
 ## system data structure
 ## @item   out_idx
 ## @itemx  in_idx
 ## list of connections indices; @math{y(out_idx(ii))}
 ## is connected to @math{u(in_idx(ii))}.
 ## @item   order
 ## logical flag (default = 0)
 ## @table @code
-## @item	0
+## @item        0
 ## leave inputs and outputs in their original order
-## @item	1
+## @item        1
 ## permute inputs and outputs to the order shown in the diagram below
 ## @end table
 ## @item     tol
 ## tolerance for singularities in algebraic loops default: 200@var{eps}
 ## @end table
-## 
+##
 ## @strong{Outputs}
-##  @var{sys}: resulting closed loop system.
-## 
+## @var{sys}: resulting closed loop system.
+##
 ## @strong{Method}
 ## @code{sysconnect} internally permutes selected inputs, outputs as shown
-##  below, closes the loop, and then permutes inputs and outputs back to their
-##  original order
+## below, closes the loop, and then permutes inputs and outputs back to their
+## original order
 ## @example
 ## @group
 ##                  ____________________
 ##  u_1       ----->|                  |----> y_1
 ##                  |        sys       |
 ##          old u_2 |                  |
-## u_2* ---->(+)--->|                  |----->y_2 
+## u_2* ---->(+)--->|                  |----->y_2
 ## (in_idx)   ^     -------------------|    | (out_idx)
 ##            |                             |
 ##            -------------------------------
 ## @end group
 ## @end example
-## The input that has the summing junction added to it has an * added to the end 
-## of the input name.
-## 
+## The input that has the summing junction added to it has an * added to
+## the end  of the input name.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
 function sys = sysconnect (sys, output_list, input_list, order, tol)
 
@@ -82,49 +81,49 @@ function sys = sysconnect (sys, output_l
   endif
 
   if (nargin <= 4)
     tol = 200*eps;
   elseif( !is_sample(tol) )
     error("sysconnect: tol must be a positive scalar");
   elseif(tol > 1e2*sqrt(eps))
     warning(["sysconnect: tol set to large value=",num2str(tol), ...
-	", eps=",num2str(eps)])
+        ", eps=",num2str(eps)])
   endif
 
   ## verify sizes,format of input, output lists
   if( min(size(output_list))*min(size(input_list)) != 1)
     error("output_list and input_list must be vectors");
   else
     lo = length(output_list);
     li = length(input_list);
     if(lo != li)
       error("output_list and input_list must be of the same length")
     endif
-    
+
     if(is_duplicate_entry(output_list) | is_duplicate_entry(input_list) )
       error("duplicate entry in input_list and/or output_list");
     endif
   endif
-  
+
   [nc,nz,mm,pp] = sysdimensions(sys);
   nn = nc+nz;
 
   if( !is_struct(sys))
     error("sys must be in structured system form")
   elseif(pp < li)
     error(["length(output_list)=",num2str(li),", sys has only ", ...
-	num2str(pp),"system outputs"])
+        num2str(pp),"system outputs"])
   elseif(mm < li)
     error(["length(input_list)=",num2str(li),", sys has only ", ...
-	num2str(mm),"system inputs"])
+        num2str(mm),"system inputs"])
   endif
 
   ## check that there are enough inputs/outputs in the system for the lists
-  if(max(input_list) > mm) 
+  if(max(input_list) > mm)
     error("max(input_list) exceeds the number of inputs");
   elseif(max(output_list) > pp)
     error("max(output_list) exceeds the number of outputs");
   endif
 
   output_list = reshape(output_list,1,length(output_list));
 
   ## make sure we're in state space form
@@ -188,18 +187,18 @@ function sys = sysconnect (sys, output_l
   dyi = find(yd(p2:pp));
 
   ## disp("sysconnect: dyi=")
   ## dyi
   ## nc
   ## disp("/sysconnect");
 
   if( (nc > 0) & find(dyi > 0) )
-    B2con = B2(1:nc,dyi);	# connection to cont states
-    C2hd = C2h(dyi,1:nc);	# cont states -> outputs
+    B2con = B2(1:nc,dyi);       # connection to cont states
+    C2hd = C2h(dyi,1:nc);       # cont states -> outputs
   else
     B2con = C2hd = [];
   endif
 
   if(max(size(B2con)) & max(size(C2hd)) )
     if(norm(B2con*C2hd))
       warning("sysconnect: cont-state -> disc output -> cont state derivative");
       warning("    connection made; resulting system may not be meaningful");
@@ -235,17 +234,17 @@ function sys = sysconnect (sys, output_l
   if(m1*p1 > 0)
     Dc = [D11c,D12c; D21h,D22h];
   elseif(m1 > 0)
     Dc = [D21h, D22h];
   elseif(p1 > 0)
     Dc = [D12c; D22h];
   else
     Dc = D22h;
-  endif 
+  endif
 
   ## permute rows and columns of Bc, Cc, Dc back into original order
   Im = eye(mm,mm);
   Pi = Im(:,all_inputs);
   back_inputs = Pi*[1:mm]';
 
   Ip = eye(pp,pp);
   Po = Ip(:,all_outputs);
@@ -262,17 +261,17 @@ function sys = sysconnect (sys, output_l
   sys = ss2sys(Ac,Bc,Cc,Dc,Ts,nc,nz,stnam,innam,outnam,find(yd));
 
   ## update connected input names
   for ii = 1:length(input_list)
     idx = input_list(ii);
     strval = sprintf("%s*",nth(sysgetsignals(sys,"in",idx),1) );
     sys = syssetsignals(sys,"in",strval,idx);
   endfor
-  
+
   ## maintain original system type if it was SISO
   if (strcmp (sysgettype (sys), "tf"))
     sysupdate (sys, "tf");
   elseif (strcmp (sysgettype (sys),"zp"))
     sysupdate (sys, "zp");
   endif
 
 endfunction
diff --git a/scripts/control/syscont.m b/scripts/control/syscont.m
--- a/scripts/control/syscont.m
+++ b/scripts/control/syscont.m
@@ -1,63 +1,62 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} { [@var{csys}, @var{Acd}, @var{Ccd}] = } syscont (@var{sys})
+## @deftypefn {Function File} {[@var{csys}, @var{Acd}, @var{Ccd}] =} syscont (@var{sys})
 ## Extract the purely continuous subsystem of an input system.
-## 
+##
 ## @strong{Inputs}
 ## @var{sys} is a system data structure
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item csys
-##  is the purely continuous input/output connections of @var{sys}
+## is the purely continuous input/output connections of @var{sys}
 ## @item Acd
 ## @itemx Ccd
-##  connections from discrete states to continuous states,
-##                discrete states to continuous outputs, respectively.
-## 
-##  returns @var{csys} empty if no continuous/continous path exists
+## connections from discrete states to continuous states,
+## discrete states to continuous outputs, respectively.
+##
+## returns @var{csys} empty if no continuous/continous path exists
 ## @end table
-## 
 ## @end deftypefn
- 
+
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function [csys, Acd, Ccd] = syscont (sys)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate(sys,"ss");
-  [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);	# get ranges
+  [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
 
   if(isempty(st_c) & isempty(y_c))
     error("syscont: expecting continous states and/or continous outputs");
   elseif (isempty(st_c))
     warning("syscont: no continuous states");
@@ -76,14 +75,14 @@ function [csys, Acd, Ccd] = syscont (sys
     Acd = sys_a(st_c,st_d);
   else
     stname=[];
   endif
   outname = sys_outname(y_c);
   Dcc = sys_d(y_c,:);
   Ccd = sys_c(y_c,st_d);
   inname = sys_inname;
-  
+
   csys = ss2sys(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
 
   empty_list_elements_ok = save_empty;
- 
+
 endfunction
diff --git a/scripts/control/syscont_disc.m b/scripts/control/syscont_disc.m
--- a/scripts/control/syscont_disc.m
+++ b/scripts/control/syscont_disc.m
@@ -1,55 +1,54 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{n_tot}, @var{st_c}, @var{st_d}, @var{y_c}, @var{y_d}] =} syscont_disc(@var{sys})
+## @deftypefn {Function File} {[@var{n_tot}, @var{st_c}, @var{st_d}, @var{y_c}, @var{y_d}] =} syscont_disc(@var{sys})
 ## Used internally in syscont and sysdisc.
-## 
+##
 ## @strong{Inputs}
 ## @var{ sys} is a system data structure.
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item n_tot
 ## total number of states
 ## @item st_c
 ## vector of continuous state indices (empty if none)
 ## @item st_d
 ## vector of discrete state indices (empty if none)
 ## @item y_c
 ## vector of continuous output indices
 ## @item y_d
 ## vector of discrete output indices
 ## @end table
-## 
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: February 1997
 
 function [n_tot, st_c, st_d, y_c, y_d] = syscont_disc (sys)
 
   ## get ranges for discrete/continuous states and outputs
   [nn,nz,mm,pp,yd] = sysdimensions(sys);
   n_tot = nn + nz;
   st_c = 1:(nn);
   st_d = nn + (1:nz);
-  y_c = find(yd == 0);		# y_c, y_d will be empty if there are none.
+  y_c = find(yd == 0);          # y_c, y_d will be empty if there are none.
   y_d = find(yd == 1);
 
 endfunction
diff --git a/scripts/control/sysdefioname.m b/scripts/control/sysdefioname.m
--- a/scripts/control/sysdefioname.m
+++ b/scripts/control/sysdefioname.m
@@ -1,46 +1,46 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{ioname} =} sysdefioname (@var{n},@var{str} @{,@var{m}@})
+## @deftypefn {Function File} {@var{ioname} =} sysdefioname (@var{n},@var{str} @{,@var{m}@})
 ## return default input or output names given @var{n}, @var{str}, @var{m}.
-##  @var{n} is the final value, @var{str} is the string prefix, and @var{m}
+## @var{n} is the final value, @var{str} is the string prefix, and @var{m}
 ## is start value
-## 
-##  used internally, minimal argument checking
-## 
+##
+## used internally, minimal argument checking
+##
 ## @strong{Example} @code{ioname = sysdefioname(5,"u",3)}
 ## returns the list:
 ## @example
 ## ioname =
 ## (
 ##   [1] = u_3
 ##   [2] = u_4
 ##   [3] = u_5
 ## )
 ## @end example
 ## @end deftypefn
- 
+
 function ioname = sysdefioname (n, str, m)
 
   if (nargin < 2 | nargin > 3)
     usage("ioname = sysdefioname(n,str[,m])");
   endif
 
   if (nargin == 2)           m = min(1,n);            endif
 
diff --git a/scripts/control/sysdefstname.m b/scripts/control/sysdefstname.m
--- a/scripts/control/sysdefstname.m
+++ b/scripts/control/sysdefstname.m
@@ -1,42 +1,42 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
-## @deftypefn {Function File } { @var{stname} =} sysdefstname (@var{n}, @var{nz}) 
-##  return default state names given @var{n}, @var{nz}
-## 
-##  used internally, minimal argument checking
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{stname} =} sysdefstname (@var{n}, @var{nz})
+## return default state names given @var{n}, @var{nz}
+##
+## used internally, minimal argument checking
 ## @end deftypefn
 
 function stname = sysdefstname (n, nz)
 
   stname = list();
   if(n > 0)
     for ii = 1:n
       stname(ii) = sprintf("x_%d",ii);
     endfor
   endif
- 
+
   ## Set default names for discrete states
   if(nz > 0)
     for ii = (n+1):(n+nz)
       stname(ii) = sprintf("xd_%d",ii);
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/sysdimensions.m b/scripts/control/sysdimensions.m
--- a/scripts/control/sysdimensions.m
+++ b/scripts/control/sysdimensions.m
@@ -12,61 +12,61 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{n}, @var{nz}, @var{m}, @var{p},@var{yd}] =} sysdimensions (@var{sys}@{, @var{opt}@})
-##  return the number of states, inputs, and/or outputs in the system @var{sys}.
-## 
+## @deftypefn {Function File} {[@var{n}, @var{nz}, @var{m}, @var{p}, @var{yd}] =} sysdimensions (@var{sys}@{, @var{opt}@})
+## return the number of states, inputs, and/or outputs in the system
+## @var{sys}.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
-##  system data structure
-## 
+## system data structure
+##
 ## @item opt
 ## String indicating which dimensions are desired.  Values:
 ## @table @code
 ## @item "all"
 ## (default) return all parameters as specified under Outputs below.
-## 
-## @item "cst"  
+##
+## @item "cst"
 ## return @var{n}= number of continuous states
-## 
-## @item "dst"  
+##
+## @item "dst"
 ## return @var{n}= number of discrete states
-## 
+##
 ## @item "in"
 ## return @var{n}= number of inputs
-## 
+##
 ## @item "out"
 ## return @var{n}= number of outputs
 ## @end table
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item  n
 ##  number of continuous states (or individual requested dimension as specified
 ## by @var{opt}).
 ## @item  nz
 ##  number of discrete states
 ## @item  m
 ##  number of system inputs
 ## @item  p
 ##  number of system outputs
 ## @item  yd
 ##  binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
 ## @math{yd(ii) = 0} if output @var{ii} is continous
 ## @end table
-## 
 ## @end deftypefn
 ## @seealso{sysgetsignals and sysgettsam}
 
 function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 
   if(nargout > 5 | nargin < 1 | nargin > 2)
     usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
   elseif(!is_struct(sys))
@@ -84,17 +84,17 @@ function [n, nz, m, p, yd] = sysdimensio
   legal_values = list(n,n,nz,n+nz,m,p);
 
   legal_opt = 0;
   for ii=1:length(legal_options)
     if(strcmp(nth(legal_options,ii),opt))
       n = nth(legal_values,ii);
       legal_opt = 1;
       if(ii > 1 & nargout > 1)
-	warning("opt=%s, %d output arguments requested",opt,nargout);
+        warning("opt=%s, %d output arguments requested",opt,nargout);
       endif
     endif
   endfor
   if(!legal_opt)
     error("illegal option passed = %s",opt);
   endif
 
 endfunction
diff --git a/scripts/control/sysdisc.m b/scripts/control/sysdisc.m
--- a/scripts/control/sysdisc.m
+++ b/scripts/control/sysdisc.m
@@ -1,62 +1,61 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{dsys}, @var{Adc}, @var{Cdc}] =} sysdisc (@var{sys})
-## 
+## @deftypefn {Function File} {[@var{dsys}, @var{Adc}, @var{Cdc}] =} sysdisc (@var{sys})
+##
 ## @strong{Inputs}
 ## @var{sys} = system data structure
-## 
+##
 ## @strong{Outputs}
 ## @table @var
 ## @item dsys
-##  purely discrete portion of sys (returned empty if there is
-##           no purely discrete path from inputs to outputs)
+## purely discrete portion of sys (returned empty if there is
+## no purely discrete path from inputs to outputs)
 ## @item    Adc
 ## @itemx   Cdc
-##  connections from continuous states to discrete states and discrete
-##     outputs, respectively.
+## connections from continuous states to discrete states and discrete
+## outputs, respectively.
 ## @end table
-## 
 ## @end deftypefn
- 
+
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[dsys,Adc,Cdc] = sysdisc(sys)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate(sys,"ss");
-  [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);	# get ranges
+  [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
-  
+
   if(isempty(st_d) & isempty(y_d))
     error("sysdisc: expecting discrete states and/or continous outputs");
   elseif (isempty(st_d))
     warning("sysdisc: no discrete states");
   elseif(isempty(y_d))
     warning("sysdisc: no discrete outputs");
   endif
 
diff --git a/scripts/control/sysdup.m b/scripts/control/sysdup.m
--- a/scripts/control/sysdup.m
+++ b/scripts/control/sysdup.m
@@ -1,60 +1,59 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retsys} =} sysdup (@var{Asys}, @var{out_idx}, @var{in_idx})
-##  Duplicate specified input/output connections of a system
-## 
+## @deftypefn {Function File} {@var{retsys} =} sysdup (@var{Asys}, @var{out_idx}, @var{in_idx})
+## Duplicate specified input/output connections of a system
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item Asys
-##  system data structure (@pxref{ss2sys})
+## system data structure (@pxref{ss2sys})
 ## @item out_idx
 ## @itemx in_idx
-##  list of connections indices; 
-##  duplicates are made of @code{y(out_idx(ii))} and @code{u(in_idx(ii))}.
+## list of connections indices;
+## duplicates are made of @code{y(out_idx(ii))} and @code{u(in_idx(ii))}.
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @var{retsys}: resulting closed loop system:
-##     duplicated i/o names are appended with a @code{"+"} suffix.
-## 
-## 
+## duplicated i/o names are appended with a @code{"+"} suffix.
+##
+##
 ## @strong{Method}
 ## @code{sysdup} creates copies of selected inputs and outputs as
-##  shown below.  u1/y1 is the set of original inputs/outputs, and 
-##  u2,y2 is the set of duplicated inputs/outputs in the order specified
-##  in @var{in_idx}, @var{out_idx}, respectively
+## shown below.  u1/y1 is the set of original inputs/outputs, and
+## u2,y2 is the set of duplicated inputs/outputs in the order specified
+## in @var{in_idx}, @var{out_idx}, respectively
 ## @example
 ## @group
 ##           ____________________
 ## u1  ----->|                  |----> y1
 ##           |       Asys       |
-## u2 ------>|                  |----->y2 
+## u2 ------>|                  |----->y2
 ## (in_idx)  -------------------| (out_idx)
 ## @end group
 ## @end example
-## 
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
 function retsys = sysdup (Asys, output_list, input_list)
 
@@ -86,17 +85,17 @@ function retsys = sysdup (Asys, output_l
   if(osize == 1)
     for ii=1:length(output_list);
       cc(pp+ii,:) = cc(output_list(ii),:);
       dd(pp+ii,:) = dd(output_list(ii),:);
     end
   elseif(osize != 0)
     error("output_list must be a vector or empty");
   endif
-  
+
   [stnam,innam,outnam,yd] = sysgetsignals(Asys);
   tsam = sysgettsam(Asys);
 
   ## pack system and then rename signals
   retsys = ss2sys(aa,bb,cc,dd,tsam,nn,nz);
   retsys = syssetsignals(retsys,"in",innam,1:mm);
   retsys = syssetsignals(retsys,"out",outnam,1:pp);
   retsys = syssetsignals(retsys,"yd",yd,1:pp);
diff --git a/scripts/control/sysgetsignals.m b/scripts/control/sysgetsignals.m
--- a/scripts/control/sysgetsignals.m
+++ b/scripts/control/sysgetsignals.m
@@ -1,105 +1,105 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{stname}, @var{inname}, @var{outname}, @var{yd}] =} sysgetsignals (@var{sys})
-## @deftypefnx{Function File } { @var{siglist} =} sysgetsignals (@var{sys},@var{sigid})
-## @deftypefnx{Function File } { @var{signame} =} sysgetsignals (@var{sys},@var{sigid},@var{signum}@{, @var{strflg}@})
-##  Get signal names from a system
-## 
+## @deftypefn {Function File} {[@var{stname}, @var{inname}, @var{outname}, @var{yd}] =} sysgetsignals (@var{sys})
+## @deftypefnx{Function File} {@var{siglist} =} sysgetsignals (@var{sys},@var{sigid})
+## @deftypefnx{Function File} {@var{signame} =} sysgetsignals (@var{sys},@var{sigid},@var{signum}@{, @var{strflg}@})
+## Get signal names from a system
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
-##  system data structure for the state space system
-## 
+## system data structure for the state space system
+##
 ## @item sigid
 ## signal id.  String.  Must be one of
 ## @table @code
 ## @item "in"
 ## input signals
 ## @item "out"
 ## output signals
 ## @item "st"
 ## stage signals
 ## @item "yd"
-## value of logical vector @var{yd} 
+## value of logical vector @var{yd}
 ## @end table
-## 
+##
 ## @item signum
 ## Index of signal (or indices of signals if signum is a vector)
-## 
+##
 ## @item strflg
 ## flag to return a string instead of a list;  Values:
 ## @table @code
 ## @item 0
 ## (default) return a list (even if signum is a scalar)
-## 
+##
 ## @item 1
 ## return a string.  Exits with an error if signum is not a scalar.
 ## @end table
-## 
+##
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @table @bullet
 ## @item If @var{sigid} is not specified
 ## @table @var
 ## @item stname
 ## @itemx inname
 ## @itemx outname
-## 	 signal names (lists of strings);  names of states,
-##           inputs, and outputs, respectively
+## signal names (lists of strings);  names of states,
+## inputs, and outputs, respectively
 ## @item yd
-##  binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
+## binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
 ## @end table
-## 
+##
 ## @item If @var{sigid} is specified but @var{signum} is not specified, then
 ## @table @code
 ## @item sigid="in"
 ## @var{siglist} is set to the list of input names
-## 
+##
 ## @item sigid="out"
 ## @var{siglist} is set to the list of output names
-## 
+##
 ## @item sigid="st"
 ## @var{siglist} is set to the list of state names
-## 
+##
 ## stage signals
 ## @item sigid="yd"
 ## @var{siglist} is set to logical vector indicating discrete outputs;
 ## @var{siglist(ii) = 0} indicates that output @var{ii} is continuous
 ## (unsampled), otherwise it is discrete.
-## 
+##
 ## @end table
-## 
+##
 ## @item if the first three input arguments are specified, then @var{signame} is
 ## a list of the specified signal names (@var{sigid} is @code{"in"},
 ## @code{"out"}, or @code{"st"}), or else the logical flag
 ## indicating whether output(s) @var{signum} is(are) discrete (@var{sigval}=1)
 ## or continuous (@var{sigval}=0).
 ## @end table
-## 
+##
 ## @strong{Examples} (From @code{sysrepdemo})
 ## @example
 ## octave> sys=ss2sys(rand(4),rand(4,2),rand(3,4));
 ## octave> [Ast,Ain,Aout,Ayd] = sysgetsignals(sys) i  # get all signal names
 ## Ast =
 ## (
 ##   [1] = x_1
 ##   [2] = x_2
@@ -113,82 +113,81 @@
 ## )
 ## Aout =
 ## (
 ##   [1] = y_1
 ##   [2] = y_2
 ##   [3] = y_3
 ## )
 ## Ayd =
-## 
+##
 ##   0  0  0
 ## octave> Ain = sysgetsignals(sys,"in")   # get only input signal names
 ## Ain =
 ## (
 ##   [1] = u_1
 ##   [2] = u_2
 ## )
 ## octave> Aout = sysgetsignals(sys,"out",2)   # get name of output 2 (in list)
 ## Aout =
 ## (
 ##   [1] = y_2
 ## )
 ## octave> Aout = sysgetsignals(sys,"out",2,1)  # get name of output 2 (as string)
 ## Aout = y_2
 ## @end example
-## 
 ## @end deftypefn
 
 function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
   ## Adapted from ss2sys
 
   if(nargin < 1 | nargin > 4 | nargout > 4)
     usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
   elseif(nargin > 1 & nargout > 1)
     usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
   elseif( ! is_struct(sys) )
     error("input argument must be a system data structure");
   endif
   if(nargin < 4)  strflg = 0; endif
   if(nargin == 1)
-    sys = sysupdate(sys,"ss");		#make sure ss is up to date
+    sys = sysupdate(sys,"ss");          #make sure ss is up to date
     stname = sysgetsignals(sys,"st");
     inname = sysgetsignals(sys,"in");
     outname = sysgetsignals(sys,"out");
     yd = sysgetsignals(sys,"yd");
   elseif(!(isstr(sigid) & min(size(sigid)) == 1))
     error(sprintf("sigid(%dx%d) must be a string)",rows(sigid),columns(sigid)));
   else
     if(strcmp("st",sigid))         stname = sys.stname;
     elseif(strcmp("in",sigid))     stname = sys.inname;
     elseif(strcmp("out",sigid))    stname = sys.outname;
     elseif(strcmp("yd",sigid))     stname = vec(sys.yd)';
     else
       error(sprintf("sigid=%s must be \"st\", \"in\", \"out\", or \"yd\"", ...
-	sigid));
+        sigid));
     endif
     if(nargin >= 3)
       if(signum > length(stname))
         error(sprintf("sysgetsignals(sys,\"%s\",%d):only %d entries.\n", ...
-	  sigid,signum, rows(stname)));
+          sigid,signum, rows(stname)));
       else
-        if(!is_scalar(strflg)) 
+        if(!is_scalar(strflg))
           error("strflg must be a scalar");
         endif
         switch(strflg)
         case(0),
           stname = stname(signum);
         case(1),
           if(length(signum) > 1)
             error("strflg=1, length(signum) = %d",length(signum));
           endif
           stname = nth(stname,signum);
         otherwise,
           error("Illegal value of strflg=%e",strflg);
         endswitch
-        
+
       endif
     endif
   endif
 
 endfunction
 
diff --git a/scripts/control/sysgettype.m b/scripts/control/sysgettype.m
--- a/scripts/control/sysgettype.m
+++ b/scripts/control/sysgettype.m
@@ -1,42 +1,40 @@
 ## Copyright (C) 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{systype} =} sysgettype ( @var{sys} ) 
-##  return the initial system type of the system
-## 
+## @deftypefn {Function File} {@var{systype} =} sysgettype (@var{sys})
+## return the initial system type of the system
+##
 ## @strong{Inputs}
-##    @var{sys}: system data structure
-## 
+## @var{sys}: system data structure
+##
 ## @strong{Outputs}
-##    @var{systype}: string indicating how the structure was initially 
-##             constructed:
-##       values: @code{"ss"}, @code{"zp"}, or @code{"tf"}
-## 
+## @var{systype}: string indicating how the structure was initially
+## constructed:
+## values: @code{"ss"}, @code{"zp"}, or @code{"tf"}
+##
 ## @strong{Note} FIR initialized systems return @code{systype="tf"}.
-## 
-## 
-## @end deftypefn 
+## @end deftypefn
 
 function systype = sysgettype (sys)
 
   if(!is_struct(sys))
     error("sysgettype: input sys is not a structure");
   endif
 
   typestr = list("tf","zp","ss");
diff --git a/scripts/control/sysgroup.m b/scripts/control/sysgroup.m
--- a/scripts/control/sysgroup.m
+++ b/scripts/control/sysgroup.m
@@ -1,66 +1,65 @@
 ## Copyright (C) 1996, 1998, 1999 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =} sysgroup ( @var{Asys}, @var{Bsys})
+## @deftypefn {Function File} {@var{sys} =} sysgroup (@var{Asys}, @var{Bsys})
 ## Combines two systems into a single system
-## 
+##
 ## @strong{Inputs}
 ## @var{Asys}, @var{Bsys}: system data structures
-## 
+##
 ## @strong{Outputs}
-##  @math{sys = @r{block diag}(Asys,Bsys)}
+## @math{sys = @r{block diag}(Asys,Bsys)}
 ## @example
 ## @group
 ##          __________________
 ##          |    ________    |
 ## u1 ----->|--> | Asys |--->|----> y1
 ##          |    --------    |
 ##          |    ________    |
 ## u2 ----->|--> | Bsys |--->|----> y2
 ##          |    --------    |
 ##          ------------------
 ##               Ksys
 ## @end group
 ## @end example
 ## The function also rearranges the internal state-space realization of @var{sys}
 ## so that the
-##  continuous states come first and the discrete states come last.
-##  If there are duplicate names, the second name has a unique suffix appended
-##  on to the end of the name.
-## 
+## continuous states come first and the discrete states come last.
+## If there are duplicate names, the second name has a unique suffix appended
+## on to the end of the name.
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 ## A. S. Hodel: modified for variable number of arguments 1999
 
 function sys = sysgroup (...)
 
   save_emp = empty_list_elements_ok;
   empty_list_elements_ok = 1;
-    
+
   if(nargin < 1)
     usage("sys = sysgroup(Asys{,Bsys,...})");
   endif
 
   ## collect all arguments
   arglist = list();
   va_start();
   for kk=1:nargin
@@ -69,83 +68,83 @@ function sys = sysgroup (...)
       error("sysgroup: argument %d is not a data structure",kk);
     endif
   endfor
 
   if(nargin == 2)
     ## the usual case; group the two systems together
     Asys = nth(arglist,1);
     Bsys = nth(arglist,2);
-  
+
     ## extract information from Asys, Bsys to consruct sys
     Asys = sysupdate(Asys,"ss");
     Bsys = sysupdate(Bsys,"ss");
     [n1,nz1,m1,p1] = sysdimensions(Asys);
     [n2,nz2,m2,p2] = sysdimensions(Bsys);
     [Aa,Ab,Ac,Ad,Atsam,An,Anz,Ast,Ain,Aout,Ayd] = sys2ss(Asys);
     [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bst,Bin,Bout,Byd] = sys2ss(Bsys);
     nA = An + Anz;
     nB = Bn + Bnz;
-  
+
     if(p1*m1*p2*m2 == 0)
       error("sysgroup: argument lacks inputs and/or outputs");
-  
+
     elseif((Atsam + Btsam > 0) & (Atsam * Btsam == 0) )
       warning("sysgroup: creating combination of continuous and discrete systems")
-  
+
     elseif(Atsam != Btsam)
       error("sysgroup: Asys.tsam=%e, Bsys.tsam =%e", Atsam, Btsam);
     endif
-  
+
     A = [Aa,zeros(nA,nB); zeros(nB,nA),Ba];
     B = [Ab,zeros(nA,m2); zeros(nB,m1),Bb];
     C = [Ac,zeros(p1,nB); zeros(p2,nA),Bc];
     D = [Ad,zeros(p1,m2); zeros(p2,m1),Bd];
     tsam = max(Atsam,Btsam);
-  
+
     ## construct combined signal names; stnames must check for pure gain blocks
     if(isempty(Ast))
       stname = Bst;
     elseif(isempty(Bst))
       stname = Ast;
     else
       stname  = append(Ast, Bst);
     endif
     inname  = append(Ain, Bin);
     outname = append(Aout,Bout);
-  
+
     ## Sort states into continous first, then discrete
     dstates = ones(1,(nA+nB));
     if(An)
       dstates(1:(An)) = zeros(1,An);
     endif
     if(Bn)
       dstates((nA+1):(nA+Bn)) = zeros(1,Bn);
     endif
     [tmp,pv] = sort(dstates);
     A = A(pv,pv);
     B = B(pv,:);
     C = C(:,pv);
     stname = stname(pv);
-  
+
     ## check for duplicate signal names
     inname = sysgroupn(inname,"input");
     stname = sysgroupn(stname,"state");
     outname = sysgroupn(outname,"output");
-  
+
     ## mark discrete outputs
     outlist = find([Ayd, Byd]);
-  
+
     ## build new system
     sys = ss2sys(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
 
   else
     ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       printf("sysgroup: kk=%d\n",kk);
       sys = sysgroup(sys,nth(arglist,kk));
     endfor
   endif
-  
+
   empty_list_elements_ok = save_emp;
-    
+
 endfunction
diff --git a/scripts/control/sysgroupn.m b/scripts/control/sysgroupn.m
--- a/scripts/control/sysgroupn.m
+++ b/scripts/control/sysgroupn.m
@@ -1,55 +1,54 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{names} =} sysgroupn (@var{names})
+## @deftypefn {Function File} {@var{names} =} sysgroupn (@var{names})
 ## names = sysgroupn(names)
 ## Locate and mark duplicate names
 ## inputs:
-##   names: list of signal names
-##   kind: kind of signal name (used for diagnostic message purposes only)
+## names: list of signal names
+## kind: kind of signal name (used for diagnostic message purposes only)
 ## outputs:
-##   returns names with unique suffixes added; diagnostic warning
-##      message is printed to inform the user of the new signal name
+## returns names with unique suffixes added; diagnostic warning
+## message is printed to inform the user of the new signal name
 ##
-##  used internally in sysgroup and elsewhere. 
-## 
+## used internally in sysgroup and elsewhere.
 ## @end deftypefn
- 
+
 function names = sysgroupn (names, kind)
 
   ## check for duplicate names
   l = length(names);
   ii = 1;
   while(ii <= l-1)
     st1 = nth(names,ii);
     jj = ii+1;
     while ( jj <= l)
       st2 = nth(names,jj);
       if(strcmp(st1,st2))
         suffix = ["_",num2str(jj)];
         warning("sysgroup: %s name(%d) = %s name(%d) = %s", ...
-	  kind,ii,kind,jj,st1);
+          kind,ii,kind,jj,st1);
         strval = sprintf("%s%s",st2,suffix);
         names(jj) = strval;
         warning("sysgroup:     changed %s name %d to %s",kind,jj,strval);
         ## restart the check (just to be sure there's no further duplications)
         ii = 0; jj = l;
       endif
       jj = jj+1;
     endwhile
diff --git a/scripts/control/sysidx.m b/scripts/control/sysidx.m
--- a/scripts/control/sysidx.m
+++ b/scripts/control/sysidx.m
@@ -9,17 +9,17 @@ function idxvec = sysidx(sys,sigtype,sig
 #   idxvec: vector of signal indices (appropriate for use with sysprune)
 
 if(nargin != 3)
   usage("idxvec = sysidx(sys,sigtype,signamelist)");
 elseif(!is_struct(sys))
   error("sys must be a system data structure");
 elseif(!isstr(sigtype))
   error("sigtype must be a string");
-elseif(rows(sigtype) != 1) 
+elseif(rows(sigtype) != 1)
   error("sigtype (%d x %d) must be a single string", ...
     rows(sigtype),columns(sigtype));
 end
 
 # extract correct set of signal names values
 [idxvec,msg] = listidx( list("in","out","st","yd"), sigtype);
 if(msg)
   error("Illegal sigtype=%s",sigtype);
diff --git a/scripts/control/sysmin.m b/scripts/control/sysmin.m
--- a/scripts/control/sysmin.m
+++ b/scripts/control/sysmin.m
@@ -30,31 +30,31 @@
 ##   nc: number of controllable states in the returned system
 ##   no: number of observable states in the returned system
 ##   cflg: is_controllable(retsys)
 ##   oflg: is_observable(retsys)
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function [retsys, nc, no, cflg, oflg] = sysmin (sys, flg);
-  
+
   switch(nargin)
   case(1), flg = 0;
   case(2), jnk = flg;    # dummy operation
   otherwise,
     usage("[retsys,nc,no] = sysmin(sys{,flg})");
   endswitch
   dflg = is_digital(sys,2);
   [n,nz,m,p] = sysdimensions(sys);
   if(n*nz > 0)
     # both continuous and discrete states
     [aa,bb,cc,dd,tsam,n,nz,stnam,innam,outnam,yd] = sys2ss(sys);
     crng = 1:n;
     drng = n+(1:nz);
-    
+
     # get minimal realization of continuous part
     Ac  = aa(crng,crng);
     Acd = aa(crng,drng);
     Adc = aa(drng,crng);
     Ad  = aa(drng,drng);
     Bc  = bb(crng,:);
     Bd  = bb(drng,:);
     Cc  = cc(:,crng);
@@ -89,25 +89,25 @@ function [retsys, nc, no, cflg, oflg] = 
 
       # recombine to reduce discrete part of the system
       dinnam = append(innam,cstnam);
       doutnam = append(outnam,cstnam);
       dsys = ss2sys(Ad,[Bd,Adc],[Cd;Acd],[],tsam);
       dsys = syssetsignals(dsys,"st",dstnam);
       dsys = syssetsignals(dsys,"in",dinnam);
       dsys = syssetsignals(dsys,"out",doutnam);
-      
+
       # reduce discrete subsystem
       dsys = sysmin(dsys);
       [n1,nz] = sysdimensions(dsys);
       if(nz == 0)
         # discrete subsystem is not needed
         retsys = sysprune(csys,1:p,1:m);
       else
-        # combine discrete, continuous subsystems 
+        # combine discrete, continuous subsystems
         [Ad,dbb,dcc] = sys2ss(dsys);
         dstnam = sysgetsignals(dsys,"st");
         Bd  = dbb(:,1:m);
         Adc = dbb(:,m+(1:cn));
         Cd  = dcc(1:p,:);
         Acd = dcc(p+(1:cn),:);
         stnam = append(cstnam,dstnam);
         aa = [Ac, Acd; Adc, Ad];
@@ -118,17 +118,17 @@ function [retsys, nc, no, cflg, oflg] = 
       end
     endif
   else
     Ts = sysgettsam(sys);
     switch(flg)
     case(0),
       ## reduce to a minimal system
       [aa,bb,cc,dd] = sys2ss(sys);
-      [cflg,Uc] = is_controllable(aa,bb); 
+      [cflg,Uc] = is_controllable(aa,bb);
       if(!cflg)
         ## reduce to controllable states
         if(!isempty(Uc))
           aa = Uc'*aa*Uc;
           bb = Uc'*bb;
           cc = cc*Uc;
         else
           aa = bb = cc = [];
diff --git a/scripts/control/sysmult.m b/scripts/control/sysmult.m
--- a/scripts/control/sysmult.m
+++ b/scripts/control/sysmult.m
@@ -1,40 +1,40 @@
 ## Copyright (C) 1996, 1999 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## -*- texinfo -*- 
-## @deftypefn {Function File } { @var{sys} =} sysmult( @var{Asys}, @var{Bsys})
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{sys} =} sysmult (@var{Asys}, @var{Bsys})
 ## Compute @math{sys = Asys*Bsys} (series connection):
 ## @example
 ## @group
 ## u   ----------     ----------
 ## --->|  Bsys  |---->|  Asys  |--->
 ##     ----------     ----------
 ## @end group
 ## @end example
 ## A warning occurs if there is direct feed-through
-## from an input of Bsys or a continuous state of Bsys through a discrete 
-## output of Bsys to a continuous state or output in Asys (system data structure
-## does not recognize discrete inputs).
+## from an input of Bsys or a continuous state of Bsys through a discrete
+## output of Bsys to a continuous state or output in Asys (system data
+## structure does not recognize discrete inputs).
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable number of arguments by A. S. Hodel July 1999
 
 function sys = sysmult (...)
 
@@ -60,55 +60,55 @@ function sys = sysmult (...)
       error("arg %d has %d outputs; arg %d has vs %d inputs",kk,ph,kk-1,mg);
     endif
     [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,kk));   # for next iteration
   endfor
 
   ## perform the multiply
   if(nargin == 2)
     Asys = nth(arglist,1);   Bsys = nth(arglist,2);
- 
+
     [An,Anz,Am,Ap] = sysdimensions(Asys);
     [Bn,Bnz,Bm,Bp] = sysdimensions(Bsys);
 
     [Aa,Ab,Ac,Ad,Atsam,An,Anz,Astname,Ainname,Aoutname,Ayd] = sys2ss(Asys);
     [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bstname,Binname,Boutname,Byd] = sys2ss(Bsys);
-  
+
     if(Byd)
       ## check direct feed-through of inputs through discrete outputs
       alist = find(Byd);
       if(An)
-        bd = Ab(1:An)* Bd(alist,:);	
+        bd = Ab(1:An)* Bd(alist,:);
         if(norm(bd,1))
           warning("sysmult: inputs -> Bsys discrete outputs -> continous states of Asys");
         endif
       endif
       ## check direct feed-through of continuous state through discrete outputs
       if(Bn)
-        bc = Ab(1:An)* Bc(alist,1:(Bn));	
+        bc = Ab(1:An)* Bc(alist,1:(Bn));
         if( norm(bc,1) )
           warning("sysmult: Bsys states -> Bsys discrete outputs -> continuous states of Asys");
         endif
       endif
     endif
-  
+
     ## change signal names to avoid spurious warnings from sysgroup
     Asys = syssetsignals(Asys,"in",sysdefioname(Am,"A_sysmult_tmp_name"));
     Bsys = syssetsignals(Bsys,"out",sysdefioname(Bp,"B_sysmult_tmp_name"));
-  
+
     sys = sysgroup(Asys,Bsys);
-  
+
     ## connect outputs of B to inputs of A
     sys = sysconnect(sys,Ap+(1:Bp),1:Am);
-   
+
     ## now keep only  outputs of A and inputs of B
     sys = sysprune(sys,1:Ap,Am+(1:Bm));
 
   else
     ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       sys = sysmult(sys,nth(arglist,kk));
     endfor
   endif
 
-endfunction  
-  
+endfunction
+
diff --git a/scripts/control/sysout.m b/scripts/control/sysout.m
--- a/scripts/control/sysout.m
+++ b/scripts/control/sysout.m
@@ -1,49 +1,49 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } sysout ( @var{sys}@{, @var{opt}@}) 
-##  print out a system data structure in desired format
+## @deftypefn {Function File} {} sysout (@var{sys}@{, @var{opt}@})
+## print out a system data structure in desired format
 ## @table @var
 ## @item  sys
-##  system data structure
+## system data structure
 ## @item  opt
 ## Display option
 ## @table @code
 ## @item []
-##  primary system form (default); see @ref{sysgettype}.
+## primary system form (default); see @ref{sysgettype}.
 ## @item      "ss"
-##  state space form
+## state space form
 ## @item      "tf"
-##  transfer function form
+## transfer function form
 ## @item      "zp"
-##  zero-pole form
+## zero-pole form
 ## @item      "all"
-##  all of the above
+## all of the above
 ## @end table
 ## @end table
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: 1995-1996
 
 function retsys = sysout (sys, opt)
 
   if( (nargin < 1) || (nargin > 2) )
     usage("sysout(sys[,opt])");
   endif
@@ -67,85 +67,85 @@ function retsys = sysout (sys, opt)
       error("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
     endif
   endif
 
   ## now check output for each form:
   [nn,nz,mm,pp] = sysdimensions(sys);
   if( mm > 0)
     disp("Input(s)")
-    disp(outlist(sysgetsignals(sys,"in"),"	"));
+    disp(outlist(sysgetsignals(sys,"in"),"      "));
   else
     disp("Input(s): none");
   endif
   if (pp > 0)
     disp("Output(s):")
     disp(outlist(sysgetsignals(sys,"out"), ...
-	  "	",sysgetsignals(sys,"yd")) );
+          "     ",sysgetsignals(sys,"yd")) );
   else
     disp("Output(s): none");
   endif
   if(sysgettsam(sys) > 0)
     disp(["Sampling interval: ",num2str(sysgettsam(sys))]);
     str = "z";
   else
     str = "s";
   endif
 
   ## transfer function form
   if( strcmp(opt,"tf") + strcmp(opt,"all") )
-    sys = sysupdate(sys,"tf");		#make sure tf is up to date
+    sys = sysupdate(sys,"tf");          #make sure tf is up to date
     disp("transfer function form:")
     [num,den] = sys2tf(sys);
     tfout(num,den,str);
   endif
 
   if( strcmp(opt,"zp") + strcmp(opt,"all") )
-    sys = sysupdate(sys,"zp");		#make sure zp is up to date
+    sys = sysupdate(sys,"zp");          #make sure zp is up to date
     disp("zero-pole form:")
     [zer,pol,kk] = sys2zp(sys);
     zpout(zer, pol, kk,str)
   endif
 
   if( strcmp(opt,"ss") + strcmp(opt,"all") )
     sys = sysupdate(sys,"ss");
     disp("state-space form:");
     disp([num2str(nn)," continuous states, ", num2str(nz)," discrete states"]);
     if( nn+nz > 0)
       disp("State(s):")
       xi = (nn+1):(nn+nz);
       xd = zeros(1,nn+nz);
       if(!isempty(xi))
-	xd(xi) = 1;
+        xd(xi) = 1;
       endif
-      disp(outlist(sysgetsignals(sys,"st"),"	",xd));
+      disp(outlist(sysgetsignals(sys,"st"),"    ",xd));
     else
       disp("State(s): none");
     endif
 
     ## display matrix values?
     dmat = (max( [ (nn+nz), mm, pp ] ) <= 32);
 
     printf("A matrix: %d x %d\n",sysdimensions(sys,"st"),
-	   sysdimensions(sys,"st"));
+           sysdimensions(sys,"st"));
     [aa,bb,cc,dd] = sys2ss(sys);
-    if(dmat) 	disp(aa); 	endif
+    if(dmat)    disp(aa);       endif
 
     printf("B matrix: %d x %d\n",sysdimensions(sys,"st"),
-	   sysdimensions(sys,"in"));
+           sysdimensions(sys,"in"));
     if(dmat)     disp(bb);              endif
 
     printf("C matrix: %d x %d\n",sysdimensions(sys,"out"),
-	   sysdimensions(sys,"st"));
-    if(dmat) disp(cc);		endif
+           sysdimensions(sys,"st"));
+    if(dmat) disp(cc);          endif
 
     printf("D matrix: %d x %d\n",sysdimensions(sys,"out"),
-	   sysdimensions(sys,"in"));
+           sysdimensions(sys,"in"));
     if(dmat)       disp(dd);         endif
   endif
 
   if(nargout >= 1)
     retsys = sys;
-  endif 
+  endif
 
   ## restore global variable
 
 endfunction
diff --git a/scripts/control/sysprune.m b/scripts/control/sysprune.m
--- a/scripts/control/sysprune.m
+++ b/scripts/control/sysprune.m
@@ -1,56 +1,54 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{retsys} =} sysprune ( @var{Asys}, @var{out_idx}, @var{in_idx})
+## @deftypefn {Function File} {@var{retsys} =} sysprune (@var{Asys}, @var{out_idx}, @var{in_idx})
 ## Extract specified inputs/outputs from a system
-## 
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item   Asys
 ## system data structure
 ## @item out_idx
 ## @itemx in_idx
-##  list of connections indices; the new
-##        system has outputs y(out_idx(ii)) and inputs u(in_idx(ii)).
-##        May select as [] (empty matrix) to specify all outputs/inputs.
+## list of connections indices; the new
+## system has outputs y(out_idx(ii)) and inputs u(in_idx(ii)).
+## May select as [] (empty matrix) to specify all outputs/inputs.
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @var{retsys}: resulting system
 ## @example
 ## @group
 ##            ____________________
 ## u1 ------->|                  |----> y1
 ##  (in_idx)  |       Asys       | (out_idx)
 ## u2 ------->|                  |----| y2
-##   (deleted)-------------------- (deleted)   
+##   (deleted)-------------------- (deleted)
 ## @end group
 ## @end example
-## 
 ## @end deftypefn
-## 
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Updated by John Ingram 7-15-96
 
 function sys = sysprune (sys, output_idx, input_idx, state_idx)
 
   if( nargin < 3 | nargin > 4  )
     usage("retsys = sysprune(sys,output_idx,input_idx{,state_idx})");
@@ -61,99 +59,99 @@ function sys = sysprune (sys, output_idx
   ## default: no action
   [nn,nz,mm,pp] = sysdimensions(sys);
   if(isempty(output_idx)) output_idx = 1:pp; endif
   if(isempty(input_idx)) input_idx = 1:mm; endif
   if(isempty(state_idx)) state_idx = 1:(nn+nz); endif
 
   ## check dimensions
   if( !(is_vector(output_idx) | isempty(output_idx) )  )
-    if(!is_matrix(output_idx)) 
+    if(!is_matrix(output_idx))
       error("sysprune: bad argument passed for output_idx");
-    else 
+    else
       error("sysprune: output_idx (%d x %d) must be a vector or empty", ...
         rows(output_idx),columns(output_idx));
     endif
   elseif(is_duplicate_entry(output_idx))
      error("sysprune: duplicate entries found in output_idx");
   endif
 
   if( !(is_vector(input_idx) | isempty(input_idx) )  )
-    if(!is_matrix(input_idx)) 
+    if(!is_matrix(input_idx))
       error("sysprune: bad argument passed for input_idx");
-    else 
+    else
       error("sysprune: input_idx (%d x %d) must be a vector or empty", ...
         rows(input_idx),columns(input_idx));
     endif
   elseif(is_duplicate_entry(input_idx))
      error("sysprune: duplicate entries found in input_idx");
   endif
 
   if( !(is_vector(state_idx) | isempty(state_idx) )  )
-    if(!is_matrix(state_idx)) 
+    if(!is_matrix(state_idx))
       error("sysprune: bad argument passed for state_idx");
-    else 
+    else
       error("sysprune: state_idx (%d x %d) must be a vector or empty", ...
         rows(state_idx),columns(state_idx));
     endif
   elseif(nn+nz > 0)
     if(is_duplicate_entry(state_idx))
       error("sysprune: duplicate entries found in state_idx");
     endif
   endif
 
   lo = length(output_idx);
   li = length(input_idx);
   lst = length(state_idx);
-  
+
   if( !is_struct(sys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
   elseif(pp < lo)
     error([num2str(lo)," output_idx entries, system has only ", ...
-	num2str(pp)," outputs"]);
+        num2str(pp)," outputs"]);
   elseif(mm < li)
     error([num2str(li)," input_idx entries, system has only ", ...
-	num2str(mm)," inputs"]);
+        num2str(mm)," inputs"]);
   elseif(nn+nz < lst)
     error([num2str(lst)," state_idx entries, system has only ", ...
-	num2str(nn+nz)," states"]);
+        num2str(nn+nz)," states"]);
   endif
 
   [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
 
   ## check for legal state permutation
   if(nn & nz)
     c_idx = find(state_idx <= nn);
     if(!isempty(c_idx)) max_c = max(c_idx);
-    else	        max_c = 0;            endif
+    else                max_c = 0;            endif
     d_idx = find(state_idx > nn);
     if(!isempty(d_idx)) min_d = min(d_idx);
-    else	        min_d = nn+nz;            endif
+    else                min_d = nn+nz;            endif
     if(max_c > min_d)
       warning("sysprune: state_idx(%d)=%d (discrete) preceeds", ...
-	min_d,state_idx(min_d));
+        min_d,state_idx(min_d));
       warning("          state_idx(%d)=%d (continuous)",...
-	max_c,state_idx(max_c));
+        max_c,state_idx(max_c));
       warning("sysprune: sys has %d continuous states, %d discrete states", ...
-	nn,nz);
+        nn,nz);
       error("continuous/discrete state partition not preserved ; see ss2sys");
     endif
   endif
 
   idx = input_idx;
   odx = output_idx;
   if(isempty(state_idx))
     idx = [];
     odx = [];
   endif
   aa = aa(state_idx,state_idx);
   bb = bb(state_idx,idx);
   cc = cc(odx,state_idx);
   dd = dd(output_idx,input_idx);
-  yd = yd(output_idx); 
+  yd = yd(output_idx);
 
   innam  = innam(input_idx);
-  outnam = outnam(output_idx); 
+  outnam = outnam(output_idx);
   stnam = stnam(state_idx);
   nn1 = length(find(state_idx <= nn));
   nz1 = length(find(state_idx > nn));
   sys = ss2sys(aa,bb,cc,dd,tsam,nn1,nz1,stnam,innam,outnam,find(yd));
 endfunction
diff --git a/scripts/control/sysreorder.m b/scripts/control/sysreorder.m
--- a/scripts/control/sysreorder.m
+++ b/scripts/control/sysreorder.m
@@ -1,47 +1,47 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{pv} =} sysreorder( @var{vlen}, @{var{list})
-## 
+## @deftypefn {Function File} {@var{pv} =} sysreorder (@var{vlen}, @{var{list})
+##
 ## @strong{Inputs}
 ## @var{vlen}=vector length, @var{list}= a subset of @code{[1:vlen]},
-## 
+##
 ## @strong{Outputs}
-##  @var{pv}: a permutation vector to order elements of @code{[1:vlen]} in 
+## @var{pv}: a permutation vector to order elements of @code{[1:vlen]} in
 ## @code{list} to the end of a vector.
-## 
-##  Used internally by @code{sysconnect} to permute vector elements to their
-##  desired locations.  
+##
+## Used internally by @code{sysconnect} to permute vector elements to their
+## desired locations.
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
-  
+
 function pv = sysreorder (vlen, list)
 
   ## disp('sysreorder: entry')
-  
+
   pv = 1:vlen;
   ## make it a row vector
   list = reshape(list,1,length(list));
   A = pv'*ones(size(list));
   B = ones(size(pv'))*list;
   X = (A != B);
   if(!is_vector(X))
     y = min(X');
@@ -49,10 +49,10 @@ function pv = sysreorder (vlen, list)
    y = X';
   endif
   z = find(y == 1);
   if(!isempty(z))
     pv = [z, list];
   else
     pv = list;
   endif
-  
+
 endfunction
diff --git a/scripts/control/sysrepdemo.m b/scripts/control/sysrepdemo.m
--- a/scripts/control/sysrepdemo.m
+++ b/scripts/control/sysrepdemo.m
@@ -1,28 +1,28 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {} sysrepdemo 
+## @deftypefn {Function File} {} sysrepdemo
 ## Tutorial for the use of the system data structure functions.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 ## Revised Aug 1995 for system data structure format
 
 function sysrepdemo ()
@@ -87,54 +87,54 @@ function sysrepdemo ()
       disp(["These functions are discussed in in menu option ",num2str(ch_init)])
       disp("The data in a system may be extracted using ")
       disp("   sys2fir (FIR transfer function from system")
       disp("   sys2ss (state space matrices from system)")
       disp("   sys2tf (SISO transfer function from system)")
       disp("   sys2zp (SISO zero/pole/leading coefficient from system)")
       disp(" ")
       disp(["These functions are discussed in menu option ", ...
-	num2str(ch_extract)]);
+        num2str(ch_extract)]);
       disp("Other options discussed under this menu are updating the internal")
       disp("representation form of a system data structure with sysupdate and printing")
       disp("the description of a dynamic system to the screen with sysout.")
       disp(" ")
       disp("Once the user is familiar with these commands, the rest of the ")
       disp("OCST package will be quite easy to use.")
     elseif(syschoice == ch_init) % Initialize
       disp("Initialization of a system:");
       disp(" ");
       formopt = 0;
       while(formopt != 4)
       disp("Three data formats may be used to initialize a system:")
         formopt = menu("System data structure initialization menu", ...
-		"State space form       (ss2sys)", ...
-		"Transfer function form (tf2sys)", ...
-		"zero-pole form         (zp2sys)", ...
-	    	"Return to System representation menu");
+                "State space form       (ss2sys)", ...
+                "Transfer function form (tf2sys)", ...
+                "zero-pole form         (zp2sys)", ...
+                "Return to System representation menu");
         if(formopt == 1)
           disp("State space representation of a system is based on the usual")
           disp("multi-variable differential equations")
           disp(" ")
           disp("  . ")
           disp("  x = A x + B u      -or -   x(k+1) = A x(k) + B u(k) ")
           disp("  y = C x + D u                y(k) = C x(k) + D u(k) ")
           disp(" ")
           disp("for matrices A, B, C, D of appropriate dimension.")
           disp(" ")
           ssopt = 0;
           ssquit = 5;
           while(ssopt < ssquit)
             ssopt = menu("State space initialization examples", ...
-		"Double integrator example", ...
-		"Double delay (discrete-time) example", ...
-		"Summing junction (D-matrix only) example", ...
-		"ss2sys details (help ss2sys)", ...
-		"return to system initialization menu", ...
-		"return to system representation main menu");
+                "Double integrator example", ...
+                "Double delay (discrete-time) example", ...
+                "Summing junction (D-matrix only) example", ...
+                "ss2sys details (help ss2sys)", ...
+                "return to system initialization menu", ...
+                "return to system representation main menu");
             if(ssopt == 1)
               disp("Example: construct a system representation of a")
               disp("double integrator via state-space form")
               cmd = "a = [0, 1; 0, 0];";
               run_cmd
               cmd = "b = [0; 1];";
               run_cmd
               cmd = "c = [1, 0];";
@@ -163,92 +163,92 @@ function sysrepdemo ()
               cmd = "c = [1, 0];";
               run_cmd
               cmd = "sys=ss2sys(a,b,c,[],1e-3);";
               run_cmd
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that the D matrix was filled in automatically.")
               disp("This is done if D is input as the empty matrix.")
-	      disp(" ")
-	      disp("Notice also that the output y_1 is labelled as a discrete")
-	      disp("output.  The OCST data structure keeps track of states")
-	      disp("and output signals that are produced by the discrete-time")
-	      disp("portion of a system.  Discrete states and outputs are ")
-	      disp("implemented as shown in the block diagram below:")
-	      disp(" ")
-	      disp(" ")
-	      disp("       _________   ________ x(kT)  ________________")
-	      disp("f(t)-->|sampler|-->| delay |----->|zero order hold| -->")
-	      disp("       ---------   --------        ----------------")
-	      disp(" ")
-	      disp("        ___________    _______________")
-	      disp("f(t)-->| sampler |-->|zero-order hold| --> y(discrete)")
-	      disp("        -----------    ---------------")
-	      disp(" ")
-	      disp("where f(t) is an input signal to either the output or the")
-	      disp(" discrete state.")
-	      disp(" ")
-	      disp("The OCST does not implement samplers on inputs to continuous")
-	      disp("time states (i.e., there are no samplers implicit in the B")
-	      disp("or D matrices unless there are corresponding discrete")
+              disp(" ")
+              disp("Notice also that the output y_1 is labelled as a discrete")
+              disp("output.  The OCST data structure keeps track of states")
+              disp("and output signals that are produced by the discrete-time")
+              disp("portion of a system.  Discrete states and outputs are ")
+              disp("implemented as shown in the block diagram below:")
+              disp(" ")
+              disp(" ")
+              disp("       _________   ________ x(kT)  ________________")
+              disp("f(t)-->|sampler|-->| delay |----->|zero order hold| -->")
+              disp("       ---------   --------        ----------------")
+              disp(" ")
+              disp("        ___________    _______________")
+              disp("f(t)-->| sampler |-->|zero-order hold| --> y(discrete)")
+              disp("        -----------    ---------------")
+              disp(" ")
+              disp("where f(t) is an input signal to either the output or the")
+              disp(" discrete state.")
+              disp(" ")
+              disp("The OCST does not implement samplers on inputs to continuous")
+              disp("time states (i.e., there are no samplers implicit in the B")
+              disp("or D matrices unless there are corresponding discrete")
               disp("outputs or states.  The OCST provides warning messages when")
-	      disp("if this convention is violated.")
-	      prompt
+              disp("if this convention is violated.")
+              prompt
             elseif(ssopt == 3)
               disp("A summing junction that computes e(t) = r(t) - y(t) may be");
               disp("constructed as follows:");
               disp("First, we set the matrix D:")
               cmd = "D = [1, -1];";
               run_cmd
               disp("ss2sys allows the initialization of signal and state names")
               disp("(see option 4), so we initialize these as follows:")
               cmd = "inname = list(\"r(t)\",\"y(t)\");";
               run_cmd;
               cmd = "outname = \"e(t)\";";
-	      run_cmd
+              run_cmd
               disp("Since the system is continous time and without states,")
               disp("the ss2sys inputs tsam, n, and nz are all zero:")
               cmd = "sys = ss2sys([],[],[],D,0,0,0,[],inname,outname);";
               run_cmd
               disp("The resulting system is:")
               cmd = "sysout(sys)";
               run_cmd
               disp("A discrete-time summing block can be implemented by setting")
-	      disp("the sampling time positive:")
+              disp("the sampling time positive:")
               cmd = "sys = ss2sys([],[],[],D,1e-3,0,0,[],inname,outname);";
               run_cmd
               disp("The resulting system is:")
               cmd = "sysout(sys)";
               run_cmd
               prompt
             elseif(ssopt == 4)
               help ss2sys
-	      disp(" ")
-	      disp(" ")
+              disp(" ")
+              disp(" ")
               disp("Notice that state-space form allows a single system to have")
               disp("both continuous and discrete-time states and to have both continuous")
               disp("and discrete-time outputs.  Since it's fairly easy to make an")
               disp("error when mixing systems of this form, the Octave controls")
               disp("toolbox attempts to print warning messages whenever something")
               disp("questionable occurs.")
-	    elseif(ssopt == 6)
-	      formopt = 4;		# return to main menu
+            elseif(ssopt == 6)
+              formopt = 4;              # return to main menu
             endif
           endwhile
         elseif(formopt == 2)
-	  tfopt = 0;
+          tfopt = 0;
           while(tfopt < 5)
             tfopt = menu("Transfer function initialization menu", ...
-		"Continuous time initialization" , ...
-		"Discrete time initialization" , ...
-		"User specified signal names" , ...
-		"tf2sys details (help tf2sys)", ...
-		"Return to system initialization menu", ...
-		"Return to system representation main menu");
+                "Continuous time initialization" , ...
+                "Discrete time initialization" , ...
+                "User specified signal names" , ...
+                "tf2sys details (help tf2sys)", ...
+                "Return to system initialization menu", ...
+                "Return to system representation main menu");
             if(tfopt == 1) # continuous time
               disp("A transfer function is represented by vectors of the")
               disp("coefficients of the numerator and denominator polynomials");
               disp(" ")
               disp("For example: the transfer function");
               disp(" ");
               num = [5, -1];
               denom = [1, -2, 6];
@@ -256,205 +256,205 @@ function sysrepdemo ()
               disp(" ")
               disp("is generated by the following commands:")
               cmd = "num = [5, -1]";
               run_cmd
               cmd = "denom = [1, -2, 6]";
               run_cmd
               cmd = "sys = tf2sys(num,denom);";
               run_cmd
-	      disp("alternatively, the system can be generated in a single command:");
-	      cmd = "sys = tf2sys([5, -1], [1, -2, 6]);";
+              disp("alternatively, the system can be generated in a single command:");
+              cmd = "sys = tf2sys([5, -1], [1, -2, 6]);";
               run_cmd
               disp("Notice the output of sys: it is an Octave data structure.")
               disp("The details of its member variables are explained under")
               disp("System Representation Menu option 5 (the details of system form)")
-	      disp(" ");
+              disp(" ");
               disp("The data structure can be observed with the sysout command:")
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that Octave assigns names to inputs and outputs.")
-	      disp("The user may manually select input and output names; see option 3");
-	      prompt
+              disp("The user may manually select input and output names; see option 3");
+              prompt
             elseif(tfopt == 2) # discrete time
               disp("A transfer function is represented by vectors of the")
               disp("coefficients of the numerator and denominator polynomials");
               disp("Discrete-time transfer functions require ")
               disp("the additional parameter of a sampling period:")
               cmd = "sys=tf2sys([5, -1], [1, 2, -6], 1e-3);";
               run_cmd
               cmd = "sysout(sys)";
               run_cmd
-	      disp("The OCST recognizes discrete-time transfer functions and")
-	      disp("accordingly prints them with the frequency domain variable z.");
+              disp("The OCST recognizes discrete-time transfer functions and")
+              disp("accordingly prints them with the frequency domain variable z.");
               disp("Notice that Octave assigns names to inputs and outputs.")
-	      disp("The user may set input and output names; see option 3");
+              disp("The user may set input and output names; see option 3");
             elseif(tfopt == 3) # user specified names
               disp("The OCST requires all signals to have names.  The OCST assigned default");
-	      disp("names to the signals in the other examples.  We may initialize a transfer");
-	      disp("function with user-specified names as follows: Consider a simple ")
-	      disp("double-integrator model of aircraft roll dynamics with ")
-	      disp("input \"aileron angle\" and output \"theta\".  A ")
-	      disp("system for this model is generated by the command")
-	      cmd = "aircraft=tf2sys(1, [1, 0, 0], 0,\"aileron angle\",\"theta\");";	      run_cmd
-	      disp("The sampling  time parameter 0 indicates that the system")
-	      disp("is continuous time.  A positive sampling time indicates a")
-	      disp("discrete-time system (or sampled data system).")
-	      cmd = "sysout(aircraft)";
-	      run_cmd
-	      disp("Notice that the user-selected signal names are listed.")
-	      disp("These signal names are used in OCST plots and design functions.");
-	      disp("(Run the frequency response demo to see an example of the use of ");
-	      disp("signal names in plots.)")
-	      prompt
+              disp("names to the signals in the other examples.  We may initialize a transfer");
+              disp("function with user-specified names as follows: Consider a simple ")
+              disp("double-integrator model of aircraft roll dynamics with ")
+              disp("input \"aileron angle\" and output \"theta\".  A ")
+              disp("system for this model is generated by the command")
+              cmd = "aircraft=tf2sys(1, [1, 0, 0], 0,\"aileron angle\",\"theta\");";          run_cmd
+              disp("The sampling  time parameter 0 indicates that the system")
+              disp("is continuous time.  A positive sampling time indicates a")
+              disp("discrete-time system (or sampled data system).")
+              cmd = "sysout(aircraft)";
+              run_cmd
+              disp("Notice that the user-selected signal names are listed.")
+              disp("These signal names are used in OCST plots and design functions.");
+              disp("(Run the frequency response demo to see an example of the use of ");
+              disp("signal names in plots.)")
+              prompt
             elseif(tfopt == 4) # help
               help  tf2sys
-	      prompt
+              prompt
             elseif(tfopt == 6) # return to main menu
-	      formopt = 4;
+              formopt = 4;
             endif
           endwhile
         elseif (formopt == 3)
-	  zpopt = 0;
+          zpopt = 0;
           while(zpopt < 5)
             zpopt = menu("Zero-pole initialization menu", ...
-		"Continuous time initialization" , ...
-		"Discrete time initialization" , ...
-		"User specified signal names" , ...
-		"zp2sys details (help zp2sys)", ...
-		"Return to system initialization menu", ...
-		"Return to system representation main menu");
+                "Continuous time initialization" , ...
+                "Discrete time initialization" , ...
+                "User specified signal names" , ...
+                "zp2sys details (help zp2sys)", ...
+                "Return to system initialization menu", ...
+                "Return to system representation main menu");
             if(zpopt == 1) # continuous time
               disp("A zero-pole form representation of a system includes vectors")
               disp("of the system poles and zeros and a scalar leading coefficient.");
               disp(" ")
               disp("For example: the transfer function");
               disp(" ");
               k = 5;
               num = [5, -1];
               denom = [1, -2, 6];
               zpout(num,denom,k);
               disp(" ")
               disp("is generated by the following commands:")
               cmd = "num = [5, -1]";
               run_cmd
               cmd = "denom = [1, -2, 6]";
               run_cmd
-	      cmd = "k = 5";
-	      run_cmd
+              cmd = "k = 5";
+              run_cmd
               cmd = "sys = zp2sys(num,denom,k);";
               run_cmd
-	      disp("alternatively, the system can be generated in a single command:");
-	      cmd = "sys = zp2sys([5, -1],[1, -2, 6],5);";
+              disp("alternatively, the system can be generated in a single command:");
+              cmd = "sys = zp2sys([5, -1],[1, -2, 6],5);";
               run_cmd
               disp("Notice the output of sys: it is an Octave data structure.")
               disp("The details of its member variables are explained under")
               disp("System Representation Menu option 5 (the details of system form)")
-	      disp(" ");
+              disp(" ");
               disp("The data structure can be observed with the sysout command:")
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that Octave assigns names to inputs and outputs.")
-	      disp("The user may manually select input and output names; see option 3");
-	      prompt
+              disp("The user may manually select input and output names; see option 3");
+              prompt
             elseif(zpopt == 2) # discrete time
               disp("A zero-pole form representation of a system includes vectors")
               disp("of the system poles and zeros and a scalar leading coefficient.");
               disp(" ")
               disp("Discrete-time systems require the additional parameter of a sampling period:")
               cmd = "sys=zp2sys([5, -1],[1, 2, -6],5,1e-3);";
               run_cmd
               cmd = "sysout(sys)";
               run_cmd
-	      disp("The OCST recognizes discrete-time transfer functions and")
-	      disp("accordingly prints them with the frequency domain variable z.");
+              disp("The OCST recognizes discrete-time transfer functions and")
+              disp("accordingly prints them with the frequency domain variable z.");
               disp("Notice that Octave assigns names to inputs and outputs.")
-	      disp("The user may set input and output names; see option 3");
+              disp("The user may set input and output names; see option 3");
             elseif(zpopt == 3) # user specified names
               disp("The OCST requires all signals to have names.  The OCST assigned default");
-	      disp("names to the signals in the other examples.  We may initialize a transfer");
-	      disp("function with user-specified names as follows: Consider a simple ")
-	      disp("double-integrator model of aircraft roll dynamics with ")
-	      disp("input \"aileron angle\" and output \"theta\".  A ")
-	      disp("system for this model is generated by the command")
-	      cmd = "aircraft=zp2sys([],[0, 0],1,0,\"aileron angle\",\"theta\");";	      run_cmd
-	      disp("The sampling  time parameter 0 indicates that the system")
-	      disp("is continuous time.  A positive sampling time indicates a")
-	      disp("discrete-time system (or sampled data system).")
-	      cmd = "sysout(aircraft)";
-	      run_cmd
-	      disp("Notice that the user-selected signal names are listed.")
-	      disp("These signal names are used in OCST plots and design functions.");
-	      disp("(Run the frequency response demo to see an example of the use of ");
-	      disp("signal names in plots.)")
-	      prompt
+              disp("names to the signals in the other examples.  We may initialize a transfer");
+              disp("function with user-specified names as follows: Consider a simple ")
+              disp("double-integrator model of aircraft roll dynamics with ")
+              disp("input \"aileron angle\" and output \"theta\".  A ")
+              disp("system for this model is generated by the command")
+              cmd = "aircraft=zp2sys([],[0, 0],1,0,\"aileron angle\",\"theta\");";            run_cmd
+              disp("The sampling  time parameter 0 indicates that the system")
+              disp("is continuous time.  A positive sampling time indicates a")
+              disp("discrete-time system (or sampled data system).")
+              cmd = "sysout(aircraft)";
+              run_cmd
+              disp("Notice that the user-selected signal names are listed.")
+              disp("These signal names are used in OCST plots and design functions.");
+              disp("(Run the frequency response demo to see an example of the use of ");
+              disp("signal names in plots.)")
+              prompt
             elseif(zpopt == 4) # help
               help  zp2sys
-	      prompt
+              prompt
             elseif(zpopt == 6) # return to main menu
-	      formopt = 4;
+              formopt = 4;
             endif
           endwhile
         endif
       endwhile
     elseif(syschoice == ch_extract)  # extract system information
       disp("Extract information from a system data structure in a selected format:")
       disp("The actions of operations ss2sys, tf2sys, and zp2sys are reversed by")
       disp("respective functions sys2ss, sys2tf, and sys2zp.  The latter two");
       disp("functions are applicable only to SISO systems.")
       formopt = 0;
       while(formopt != 8)
         formopt = menu("Extract system information", ...
-		"in state space form       (sys2ss)", ...
-		"in transfer function form (sys2tf)", ...
-		"in zero pole form         (sys2zp)", ...
-		"signal names       (sysgetsignals,syssetsignals)", ...
-		"sampling time         (sysgettsam)", ...
-		"signal dimensions  (sysdimensions)", ...
-		"primary system type   (sysgettype)", ...
-		"Return to system representation menu");
+                "in state space form       (sys2ss)", ...
+                "in transfer function form (sys2tf)", ...
+                "in zero pole form         (sys2zp)", ...
+                "signal names       (sysgetsignals,syssetsignals)", ...
+                "sampling time         (sysgettsam)", ...
+                "signal dimensions  (sysdimensions)", ...
+                "primary system type   (sysgettype)", ...
+                "Return to system representation menu");
         if(formopt == 1)
-	  help sys2ss
-	elseif(formopt == 2)
-	  help sys2tf
-	elseif(formopt == 3)
-	  help sys2zp
+          help sys2ss
+        elseif(formopt == 2)
+          help sys2tf
+        elseif(formopt == 3)
+          help sys2zp
         elseif(formopt == 4)
           help sysgetsignals
           cmd="sys=ss2sys(rand(4),rand(4,2),rand(3,4));";
           run_cmd
           printf("Example: All signals names can be extracted by\n");
           cmd = "[Ast,Ain,Aout,Ayd] = sysgetsignals(sys)";
           run_cmd
           printf("Example: Input signal names can be extracted as\n");
           cmd = "Ain = sysgetsignals(sys,\"in\")";
           run_cmd
           printf("Example: The name of output signal 2 can be extracted as\n");
           cmd = "Aout = sysgetsignals(sys,\"out\",2)";
           run_cmd
           printf("\nNotice that Aout is returned as a list; the signal name\n");
           printf("itself is obtained by specifying the input parameter strflg\n");
           cmd = "Aout = sysgetsignals(sys,\"out\",2,1)";
-	  run_cmd
+          run_cmd
           prompt
           cmd = "help syssetsignals";
           run_cmd
           printf("Example: set input 2 name to \"motor voltage\"\n");
           cmd = "sys = syssetsignals(sys,\"in\",\"motor voltage\",2); sysout(sys)";
           run_cmd
-          
+
           printf("Other syssetsignals demos are in the Block diagram demo program bddemo\n");
         elseif(formopt == 5)
           help sysgettsam
         elseif(formopt == 6)
           help sysdimensions
         elseif(formopt == 7)
           help sysgettype
-	endif
-	prompt
+        endif
+        prompt
       endwhile
     elseif(syschoice== ch_update)
       disp("The OCST system data structure format will store a system in the same format")
       disp("as that with which it was initialized.  For example, consider the following:")
       cmd = "sys=zp2sys([1, 2],[3, 4, 5],6)";
       run_cmd
       disp(" ")
       disp("Notice the internal variables in the structure include zer, pol, and k,")
@@ -467,29 +467,29 @@ function sysrepdemo ()
       disp("the default state names stname.  sysupdate is usually used internally in")
       disp("the OCST, but can be used manually if desired.  A full description of")
       disp("sysupdate is as follows:")
       help sysupdate
       prompt
     elseif(syschoice == ch_view)
       disp("The sysout command can be used to view a system in any desired format.")
       disp("For example, consider the system created as follows:")
-      cmd = "aircraft=zp2sys(1,[0, 0],1,0,\"aileron angle\",\"theta\");";	      run_cmd
+      cmd = "aircraft=zp2sys(1,[0, 0],1,0,\"aileron angle\",\"theta\");";             run_cmd
       disp("The system may be viewed in its default format (zero-pole) as follows")
       cmd = "sysout(aircraft)";
       run_cmd
       disp(" ")
       disp("The system may be viewed in state-space or transfer function form as well:")
       cmd = "sysout(aircraft,\"ss\")";
       run_cmd
       cmd = "sysout(aircraft,\"tf\")";
       run_cmd
       disp("A complete description of sysout is below:")
       help sysout
       prompt
     elseif(syschoice == ch_details)
-      packedform   
+      packedform
     endif
 
   endwhile
   page_screen_output = save_val;
 endfunction
-    
+
diff --git a/scripts/control/sysscale.m b/scripts/control/sysscale.m
--- a/scripts/control/sysscale.m
+++ b/scripts/control/sysscale.m
@@ -1,68 +1,68 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{sys} =} sysscale (@var{sys}, @var{outscale}, @var{inscale}@{, @var{outname}, @var{inname}@})
+## @deftypefn {Function File} {@var{sys} =} sysscale (@var{sys}, @var{outscale}, @var{inscale}@{, @var{outname}, @var{inname}@})
 ## scale inputs/outputs of a system.
-## 
+##
 ## @strong{Inputs}
-##    sys: structured system
-##    outscale, inscale: constant matrices of appropriate dimension
-## 
+## sys: structured system
+## outscale, inscale: constant matrices of appropriate dimension
+##
 ## @strong{Outputs}
 ## @var{sys}: resulting open loop system:
 ## @example
 ##       -----------    -------    -----------
 ## u --->| inscale |--->| sys |--->| outscale |---> y
 ##       -----------    -------    -----------
 ## @end example
-##  If the input names and output names (each a list of strings)
+## If the input names and output names (each a list of strings)
 ## are not given and the scaling matrices
-##  are not square, then default names will be given to the inputs and/or
-##  outputs.
-## 
+## are not square, then default names will be given to the inputs and/or
+## outputs.
+##
 ## A warning message is printed if outscale attempts to add continuous
-## system outputs to discrete system outputs; otherwise @var{yd} is 
+## system outputs to discrete system outputs; otherwise @var{yd} is
 ## set appropriately in the returned value of @var{sys}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram 7-15-96
 
 function sys = sysscale (sys, outscale, inscale, outname, inname)
 
   if( (nargin < 3) || (nargin > 5)  )
     usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
   elseif (!is_struct(sys))
     error("sys must be a structured system");
   endif
 
   [nn,nz,mm,pp] = sysdimensions(sys);
- 
+
   ## check for omitted scales
-  if(isempty(outscale))    outscale = eye(pp);     endif 
-  if(isempty(inscale))     inscale = eye(mm);      endif 
+  if(isempty(outscale))    outscale = eye(pp);     endif
+  if(isempty(inscale))     inscale = eye(mm);      endif
 
   ## check dimensions of scaling matrices
   if(mm!=rows(inscale))
     error("inscale(%dx%d) should have %d rows(# system inputs)", ...
       rows(inscale),columns(inscale),mm);
   elseif( pp != columns(outscale) )
     error("outscale(%dx%d) should have %d columns(# system outputs)", ...
       rows(outscale), columns(outscale),pp);
@@ -129,11 +129,11 @@ function sys = sysscale (sys, outscale, 
       warning("sysscale:  using default input names");
       inname = sysdefioname(columns(sysb),"u");
     endif
   else
     inname = sysgetsignals(sys,"in");
   endif
 
   sys = ss2sys(sysa,sysb,sysc,sysd,systsam,nn,nz,sysstname, ...
-	inname,outname,find(sysyd==1));
+        inname,outname,find(sysyd==1));
 
 endfunction
diff --git a/scripts/control/syssetsignals.m b/scripts/control/syssetsignals.m
--- a/scripts/control/syssetsignals.m
+++ b/scripts/control/syssetsignals.m
@@ -1,68 +1,67 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {@var{retsys} =} syssetsignals (@var{sys}, @var{opt}, @var{names}@{, @var{sig_idx}@})
-##  change the names of selected inputs, outputs and states.
+## @deftypefn {Function File} {@var{retsys} =} syssetsignals (@var{sys}, @var{opt}, @var{names}@{, @var{sig_idx}@})
+## change the names of selected inputs, outputs and states.
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
-##  system data structure
-## 
+## system data structure
+##
 ## @item opt
 ## change default name (output)
-## 
+##
 ## @table @code
 ## @item "out"
-##  change selected output names
+## change selected output names
 ## @item "in"
-##  change selected input names
+## change selected input names
 ## @item "st"
-##  change selected state names   
+## change selected state names
 ## @item "yd"
-##  change selected outputs from discrete to continuous or 
-##                    from continuous to discrete.
+## change selected outputs from discrete to continuous or
+## from continuous to discrete.
 ## @end table
-## 
+##
 ## @item names
 ## @table @code
 ## @item opt = "out", "in", or "st"
-##  string or string array containing desired signal names or values.
+## string or string array containing desired signal names or values.
 ## @item opt = "yd"
 ## To desired output continuous/discrete flag.
 ## Set name to 0 for continuous, or 1 for discrete.
 ## @end table
 ## @item list
-##  vector of indices of outputs, yd, inputs, or
-##              states whose respective names should be changed.
-## 
-##              Default: replace entire list of names/entire yd vector.
+## vector of indices of outputs, yd, inputs, or
+## states whose respective names should be changed.
+##
+## Default: replace entire list of names/entire yd vector.
 ## @end table
 ## @strong{Outputs}
-##     @var{retsys=sys} with appropriate signal names changed 
-##             (or yd values, where appropriate)
-## 
-## 
+## @var{retsys=sys} with appropriate signal names changed
+## (or yd values, where appropriate)
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=ss2sys([1 2; 3 4],[5;6],[7 8]);
 ## octave:2> sys = syssetsignals(sys,"st",str2mat("Posx","Velx"));
 ## octave:3> sysout(sys)
 ## Input(s)
 ##         1: u_1
 ## Output(s):
@@ -78,17 +77,16 @@
 ## B matrix: 2 x 1
 ##   5
 ##   6
 ## C matrix: 1 x 2
 ##   7  8
 ## D matrix: 1 x 1
 ## 0
 ## @end example
-## 
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syssetsignals (sys, opt, names, sig_idx)
 
   if (nargin < 3 | nargin > 4)
@@ -180,42 +178,42 @@ function retsys = syssetsignals (sys, op
           error("opt=yd, sig_idx omitted: names(%d) should be length(%d)", ...
             length(names), nsigs);
         endif
         sig_idx = 1:nsigs;
       elseif(length(names) != length(sig_idx))
         error("opt=yd: length(names)=%d, length(sig_idx)=%d",length(names), ...
           length(sig_idx) );
       endif
-  
+
       badidx = find(names != 0 & names != 1);
       if(! isempty(badidx) )
         for ii=1:length(badidx)
           warning("syssetsignals: opt=yd: names(%d)=%e, must be 0 or 1", ...
             badidx(ii), names(badidx(ii)) );
         endfor
         error("opt=yd: illegal values in names");
       endif
-  
+
       for ii=1:length(sig_idx)
         jj = sig_idx(ii);
         if(jj < 1 | jj > nsigs | jj != floor(jj))
           error("sig_idx(%d)=%d, %e: must be an integer between 1 and %d", ...
             ii,jj, jj, nsigs);
         endif
         sig_vals(jj) = names(ii);
       endfor
       if(any(sig_vals == 1) & sysgettsam(sys) == 0)
         warning("Setting system sampling time to 1");
         printf("syssetsignals: original system sampling time=0 but output(s)\n");
         disp(find(sig_vals==1))
         printf("are digital\n");
         sys = syschtsam(sys,1);
       endif
-      
+
     endif
   endif
 
   if(strcmp(opt,"st"))
     sys.stname = sig_vals;
   elseif(strcmp(opt,"in"))
     sys.inname = sig_vals;
   elseif(strcmp(opt,"out"))
diff --git a/scripts/control/syssub.m b/scripts/control/syssub.m
--- a/scripts/control/syssub.m
+++ b/scripts/control/syssub.m
@@ -1,46 +1,48 @@
 ## Copyright (C) 1996, 1999 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =} syssub (@var{Gsys}, @var{Hsys})
-##  returns @math{sys = Gsys - Hsys}
-## 
-##  Method: @var{Gsys} and @var{Hsys} are connected in parallel
-##  The input vector is connected to both systems; the outputs are
-##  subtracted.  Returned system names are those of @var{Gsys}.
+## @deftypefn {Function File} {@var{sys} =} syssub (@var{Gsys}, @var{Hsys})
+## returns @math{sys = Gsys - Hsys}
+##
+## Method: @var{Gsys} and @var{Hsys} are connected in parallel
+## The input vector is connected to both systems; the outputs are
+## subtracted.  Returned system names are those of @var{Gsys}.
 ## @example
 ## @group
-##           ________
-##      ----|  Gsys  |---
-## u   |    ----------  +|         
-## -----                (_)----> y
-##     |     ________   -|
-##      ----|  Hsys  |---
-##           --------
+##          +--------+
+##     +--->|  Gsys  |---+
+##     |    +--------+   |
+##     |                +|
+## u --+                (_)--> y
+##     |                -|
+##     |    +--------+   |
+##     +--->|  Hsys  |---+
+##          +--------+
 ## @end group
 ## @end example
 ## @end deftypefn
- 
+
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable numbers of input arguments by July 1999 A. S. Hodel
 
 function sys = syssub (...)
 
   if(nargin < 1)
     usage("syssub: sys = syssub(Gsys{,Hsys,...})");
@@ -49,17 +51,17 @@ function sys = syssub (...)
   ## collect all arguments
   arglist = list();
   va_start();
   for kk=1:nargin
     arglist(kk) = va_arg();
     if(!is_struct(nth(arglist,kk)))
       error("syssub: argument %d is not a data structure",kk);
     endif
-  endfor           
+  endfor
 
   ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
     if(mg != mh)
       error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
     elseif(pg != ph)
@@ -80,35 +82,35 @@ function sys = syssub (...)
       if(length(Hden) == length(Gden) )
         if( (Hden == Gden) & (HT == GT) )
           sys = tf2sys(Gnum+Hnum,Gden,GT,Gin,Gout);
           return
         endif
         ## if not, we go on and do the usual thing...
       endif
     endif
-  
+
     ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
-  
+
     ## change signal names to avoid warning messages from sysgroup
     Gsys = syssetsignals(Gsys,"in",sysdefioname(length(Gin),"Gin_u"));
     Gsys = syssetsignals(Gsys,"out",sysdefioname(length(Gout),"Gout_u"));
     Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
     Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
-    
+
     sys = sysgroup(Gsys,Hsys);
-  
+
     eyin = eye(mg);
     eyout = eye(pg);
-  
+
     sys = sysscale (sys, [eyout, -eyout], [eyin; eyin], Gout, Gin);
-  
+
   else
     ## multiple systems (or a single system); combine together one by one
     sys = nth(arglist,1);
     for kk=2:length(arglist)
       sys = syssub(sys,nth(arglist,kk));
     endfor
   endif
-  
+
 endfunction
diff --git a/scripts/control/sysupdate.m b/scripts/control/sysupdate.m
--- a/scripts/control/sysupdate.m
+++ b/scripts/control/sysupdate.m
@@ -1,91 +1,91 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 0211
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =} sysupdate ( @var{sys}, @var{opt} ) 
-##  Update the internal representation of a system.
-## 
+## @deftypefn {Function File} {@var{sys} =} sysupdate (@var{sys}, @var{opt})
+## Update the internal representation of a system.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys:
 ## system data structure
 ## @item opt
-##  string:  
+## string:
 ## @table @code
 ## @item "tf"
 ## update transfer function form
-## @item "zp" 
+## @item "zp"
 ## update zero-pole form
-## @item "ss" 
+## @item "ss"
 ## update state space form
-## @item "all" 
+## @item "all"
 ## all of the above
 ## @end table
 ## @end table
-## 
+##
 ## @strong{Outputs}
 ## @var{retsys}: contains union of data in sys and requested data.
 ## If requested data in sys is already up to date then retsys=sys.
-## 
-## Conversion to @code{tf} or @code{zp} exits with an error if the system is 
-##  mixed continuous/digital.
+##
+## Conversion to @code{tf} or @code{zp} exits with an error if the system is
+## mixed continuous/digital.
 ## @end deftypefn
 ## @seealso{tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, and sys2zp}
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
-  ## check for correct number of inputs 
+  ## check for correct number of inputs
   if (nargin != 2)
     usage("newsys = sysupdate(sys,opt)");
   elseif(! is_struct(sys) )
    error("1st argument must be system data structure")
   elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
-	strcmp(opt,"ss") + strcmp(opt,"all")) )
+        strcmp(opt,"ss") + strcmp(opt,"all")) )
     error("2nd argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
   endif
 
   ## check to make sure not trying to make a SISO system out of a MIMO sys
   if ( (strcmp(opt,"tf") + strcmp(opt,"zp") + strcmp(opt,"all")) ...
-	& strcmp(sysgettype(sys),"ss") &  (! is_siso(sys) ) )
+        & strcmp(sysgettype(sys),"ss") &  (! is_siso(sys) ) )
     error("MIMO -> SISO update requested");
   endif
 
   ## update transfer function if desired
   if ( (strcmp(opt, "tf") + strcmp(opt,"all"))&&  (!sys.sys(2)))
     ## check to make sure the system is not discrete and continuous
     is_digital(sys);
 
     ## if original system zero-pole
     if strcmp(sysgettype(sys),"zp")
       [sys.num,sys.den] = zp2tf(sys.zer,sys.pol,sys.k);
       sys.sys(2) = 1;
     ## if original system is state-space
     elseif(sys.sys(1) == 2)
       [sys.num,sys.den] = ss2tf(sys.a,sys.b,sys.c,sys.d);
-      sys.sys(2) = 1; 
+      sys.sys(2) = 1;
     endif
   endif
 
 
   ## update zero-pole if desired
   if ( (strcmp(opt, "zp") + strcmp(opt,"all")) && (! sys.sys(3)) )
     ## check to make sure the system is not discrete and continuous
     is_digital(sys);
@@ -93,31 +93,31 @@ function sys = sysupdate (sys, opt)
     ## original system is transfer function
     if (sys.sys(1) == 0)
       [sys.zer,sys.pol,sys.k] = tf2zp(sys.num,sys.den);
       sys.sys(3) = 1;
     ## original system is state-space
 
     elseif(sys.sys(1) == 2)
       [sys.zer,sys.pol,sys.k] = ss2zp(sys.a,sys.b,sys.c,sys.d);
-      sys.sys(3) = 1; 
+      sys.sys(3) = 1;
     endif
 
   endif
 
   ## update state-space if desired
   if ( (strcmp(opt, "ss") + strcmp(opt,"all")) && (! sys.sys(4)) )
     ## original system is transfer function
     if (sys.sys(1) == 0)
       [sys.a,sys.b,sys.c,sys.d] = tf2ss(sys.num,sys.den);
       sys.sys(4) = 1;
     ## original system is zero-pole
     elseif(sys.sys(1) == 1)
       [sys.a,sys.b,sys.c,sys.d] = zp2ss(sys.zer,sys.pol,sys.k);
-      sys.sys(4) = 1; 
+      sys.sys(4) = 1;
     endif
 
     ## create new state names
     sys.stname = sysdefstname(sys.n, sys.nz);
   endif
-  
+
 
 endfunction
diff --git a/scripts/control/tf2ss.m b/scripts/control/tf2ss.m
--- a/scripts/control/tf2ss.m
+++ b/scripts/control/tf2ss.m
@@ -1,64 +1,64 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} tf2ss ( inputs ) 
+## @deftypefn {Function File} {@var{outputs} =} tf2ss (@var{inputs})
 ## @format
-##  Conversion from tranfer function to state-space.
-##  The state space system
+## Conversion from tranfer function to state-space.
+## The state space system
 ##       .
 ##       x = Ax + Bu
 ##       y = Cx + Du
-## 
-##  is obtained from a transfer function
-## 
+##
+## is obtained from a transfer function
+##
 ##                 num(s)
 ##           G(s)=-------
 ##                 den(s)
-## 
-##  via the function call [a,b,c,d] = tf2ss(num,den).
-##  The vector 'den' must contain only one row, whereas the vector 'num'
-##  may contain as many rows as there are outputs of the system 'y'.
-##  The state space system matrices obtained from this function will be
-##  in controllable canonical form as described in "Modern Control Theory",
-##  [Brogan, 1991].
-## 
-## 
+##
+## via the function call [a,b,c,d] = tf2ss(num,den).
+## The vector 'den' must contain only one row, whereas the vector 'num'
+## may contain as many rows as there are outputs of the system 'y'.
+## The state space system matrices obtained from this function will be
+## in controllable canonical form as described in "Modern Control Theory",
+## [Brogan, 1991].
+##
+##
 ## @end format
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 22, 1994
 ## mod A S Hodel July, Aug  1995
 
 function [a, b, c, d] = tf2ss (num, den)
 
   if(nargin != 2)        error("tf2ss: wrong number of input arguments")
   elseif(isempty(num))   error("tf2ss: empty numerator");
   elseif(isempty(den))   error("tf2ss: empy denominator");
-  elseif(!is_vector(num)) 
+  elseif(!is_vector(num))
     error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
-  elseif(!is_vector(den)) 
+  elseif(!is_vector(den))
     error(sprintf("den(%dx%d) must be a vector",rows(den),columns(den)));
   endif
 
   ## strip leading zeros from num, den
   nz = find(num != 0);
   if(isempty(nz)) num = 0;
   else num = num(nz(1):length(num));         endif
   nz = find(den != 0);
@@ -66,22 +66,22 @@ function [a, b, c, d] = tf2ss (num, den)
   else den = den(nz(1):length(den));         endif
 
   ## force num, den to be row vectors
   num = vec(num)';        den = vec(den)';
   nn = length(num);       nd = length(den);
   if(nn > nd) error(sprintf("deg(num)=%d > deg(den)= %d",nn,nd)); endif
 
    ## Check sizes
-   if (nd == 1)      a = []; b = []; c = []; d = num(:,1) / den(1); 
+   if (nd == 1)      a = []; b = []; c = []; d = num(:,1) / den(1);
    else
     ## Pad num so that length(num) = length(den)
     if (nd-nn > 0) num = [zeros(1,nd-nn), num]; endif
 
-    ## Normalize the numerator and denominator vector w.r.t. the leading 
+    ## Normalize the numerator and denominator vector w.r.t. the leading
     ## coefficient
     d1 = den(1);    num = num / d1;    den = den(2:nd)/d1;
     sw = nd-1:-1:1;
 
     ## Form the A matrix
     if(nd > 2)      a = [zeros(nd-2,1),eye(nd-2,nd-2);-den(sw)];
     else            a = -den(sw);                                endif
 
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -1,46 +1,46 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} = } tf2sys( @var{num}, @var{den} @{, @var{tsam}, @var{inname}, @var{outname} @})
-##  build system data structure from transfer function format data
-## 
+## @deftypefn {Function File} {@var{sys} =} tf2sys (@var{num}, @var{den} @{, @var{tsam}, @var{inname}, @var{outname} @})
+## build system data structure from transfer function format data
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item  num
 ## @itemx den
-##  coefficients of numerator/denominator polynomials
+## coefficients of numerator/denominator polynomials
 ## @item tsam
-##  sampling interval. default: 0 (continuous time)
+## sampling interval. default: 0 (continuous time)
 ## @item inname
 ## @itemx outname
-##  input/output signal names; may be a string or list with a single string
+## input/output signal names; may be a string or list with a single string
 ## entry.
 ## @end table
-## 
+##
 ## @strong{Outputs}
-##  @var{sys} = system data structure
-## 
+## @var{sys} = system data structure
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=tf2sys([2 1],[1 2 1],0.1);
 ## octave:2> sysout(sys)
 ## Input(s)
 ##         1: u_1
 ## Output(s):
 ##         1: y_1 (discrete)
@@ -60,50 +60,50 @@
 function outsys = tf2sys (num, den, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
     usage ("outsys = tf2sys (num, den [, tsam, inname, outname])");
     return
   endif
 
-  ## check input format 
+  ## check input format
   if( ! ( (is_vector(num) || is_scalar(num)) && ...
-	(is_vector(den) || is_scalar(den))) )
+        (is_vector(den) || is_scalar(den))) )
     error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
       ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
       ") must be vectors"])
   endif
-  
+
   ## strip leading zero coefficients
   num = tf2sysl(num);
   den = tf2sysl(den);
 
   if (length(num) >  length(den))
     error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
   endif
 
   ## check sampling interval (if any)
-  if(nargin <= 2)           tsam = 0;		# default
+  if(nargin <= 2)           tsam = 0;           # default
   elseif (isempty(tsam))    tsam = 0;           endif
   if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
     error("tsam must be a positive real scalar")
   endif
 
   outsys.num = num;
   outsys.den = den;
 
   ## Set the system vector:  active = 0(tf), updated = [1 0 0];
   outsys.sys = [0, 1, 0, 0];
 
   ## Set defaults
   outsys.tsam = tsam;
   outsys.n = length(den)-1;
   outsys.nz = 0;
-  outsys.yd = 0;	# assume discrete-time
+  outsys.yd = 0;        # assume discrete-time
   ## check discrete time
   if(tsam > 0)
     [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
     outsys.yd = 1;
   endif
 
   outsys.inname  = sysdefioname(1,"u");
   outsys.outname = sysdefioname(1,"y");
@@ -133,11 +133,11 @@ function outsys = tf2sys (num, den, tsam
         error("outname must be a string or a list of strings");
       endif
       if(length(outname) > 1)
         warning("tf2sys: %d output names provided; first used",length(outname));
         outname = outname(1);
       endif
       outsys = syssetsignals(outsys,"out",outname);
     endif
-  endif 
+  endif
 
 endfunction
diff --git a/scripts/control/tf2sysl.m b/scripts/control/tf2sysl.m
--- a/scripts/control/tf2sysl.m
+++ b/scripts/control/tf2sysl.m
@@ -1,30 +1,30 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{vec} = } tf2sysl (@var{vec})
-##  used internally in @ref{tf2sys}.
-##  strip leading zero coefficients to get the true polynomial length
+## @deftypefn {Function File} {@var{vec} =} tf2sysl (@var{vec})
+## used internally in @ref{tf2sys}.
+## strip leading zero coefficients to get the true polynomial length
 ## @end deftypefn
 
 function vec = tf2sysl (vec)
 
   while( (length(vec) > 1) & (vec(1) == 0) )
     vec = vec(2:length(vec));
   endwhile
 
diff --git a/scripts/control/tf2zp.m b/scripts/control/tf2zp.m
--- a/scripts/control/tf2zp.m
+++ b/scripts/control/tf2zp.m
@@ -1,36 +1,32 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { outputs =} tf2zp ( inputs ) 
-## @format
-##  Converts transfer functions to poles / zeros.
-## 
-##  [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
-##  defined by num/den.  K is a gain associated with the system zeros.
-## 
-## 
-## @end format
+## @deftypefn {Function File} {@var{outputs} =} tf2zp (@var{inputs})
+## Converts transfer functions to poles / zeros.
+##
+## [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
+## defined by num/den.  K is a gain associated with the system zeros.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function [zer, pol, k] = tf2zp (num, den)
 
   if(nargin == 2)
     if(length(den) > 1)          pol = roots(den);
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -1,50 +1,50 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } tfout (@var{num}, @var{denom}@{, @var{x}@})
+## @deftypefn {Function File} {} tfout (@var{num}, @var{denom}@{, @var{x}@})
 ## Print formatted transfer function @math{n(s)/d(s) } to the screen.
 ## @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue, 
+## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function tfout (num, denom, x)
-  
+
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
-  
-  if (nargin < 2 ) | (nargin > 3) | (nargout != 0 ) 
+
+  if (nargin < 2 ) | (nargin > 3) | (nargout != 0 )
     usage("tfout(num,denom[,x])");
   endif
 
   if ( (!is_vector(num)) | (!is_vector(denom)) )
     error("tfout: first two argument must be vectors");
   endif
-  
+
   if (nargin == 2)
     x = "s";
   elseif( ! isstr(x) )
     error("tfout: third argument must be a string");
   endif
 
   numstring = polyout(num,x);
   denomstring = polyout(denom,x);
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -1,30 +1,30 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ##  -*- texinfo -*-
 ## @deftypefn {Function File} {} tzero (@var{a}, @var{b}, @var{c}, @var{d}@{, @var{opt}@})
 ## @deftypefnx {Function File} {} tzero (@var{sys}@{,@var{opt}@})
-##  Compute transmission zeros of a continuous
+## Compute transmission zeros of a continuous
 ## @example
 ## .
 ## x = Ax + Bu
 ## y = Cx + Du
 ## @end example
 ## or discrete
 ## @example
 ## x(k+1) = A x(k) + B u(k)
@@ -59,19 +59,19 @@ function [zer, gain] = tzero (A, B, C, D
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   elseif(nargin != 1)
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   else
     Asys = A;
     [A,B,C,D] = sys2ss(Asys);
   endif
 
-  Ao = Asys;			# save for leading coefficient
+  Ao = Asys;                    # save for leading coefficient
   siso = is_siso(Asys);
-  digital = is_digital(Asys);	# check if it's mixed or not
+  digital = is_digital(Asys);   # check if it's mixed or not
 
   ## see if it's a gain block
   if(isempty(A))
     zer = [];
     gain = D;
     return;
   endif
 
@@ -84,17 +84,17 @@ function [zer, gain] = tzero (A, B, C, D
   if(!isempty(A))
     ## repeat with dual system
     Asys = ss2sys(A', C', B', D');   Asys = zgreduce(Asys,meps);
 
     ## transform back
     [A,B,C,D] = sys2ss(Asys);    Asys = ss2sys(A', C', B', D');
   endif
 
-  zer = [];			# assume none
+  zer = [];                     # assume none
   [A,B,C,D] = sys2ss(Asys);
   if( !isempty(C) )
     [W,r,Pi] = qr([C, D]');
     [nonz,ztmp] = zgrownorm(r,meps);
     if(nonz)
       ## We can now solve the generalized eigenvalue problem.
       [pp,mm] = size(D);
       nn = rows(A);
@@ -102,19 +102,19 @@ function [zer, gain] = tzero (A, B, C, D
       Bfm = [eye(nn), zeros(nn,mm); zeros(pp,nn+mm)]*W';
 
       jdx = (mm+1):(mm+nn);
       Af = Afm(1:nn,jdx);
       Bf = Bfm(1:nn,jdx);
       zer = qz(Af,Bf);
     endif
   endif
-  
+
   mz = length(zer);
-  [A,B,C,D] = sys2ss(Ao);		# recover original system
+  [A,B,C,D] = sys2ss(Ao);               # recover original system
   ## compute leading coefficient
   if ( (nargout == 2) && siso)
     n = rows(A);
     if ( mz == n)
       gain = D;
     elseif ( mz < n )
       gain = C*(A^(n-1-mz))*B;
     endif
diff --git a/scripts/control/tzero2.m b/scripts/control/tzero2.m
--- a/scripts/control/tzero2.m
+++ b/scripts/control/tzero2.m
@@ -1,35 +1,35 @@
 ## Copyright (C) 1993 Auburn University.  All rights reserved.
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File } { @var{zr} =} tzero2 (@var{a}, @var{b}, @var{c}, @var{d}, @var{bal})
-##Compute the transmission zeros of a, b, c, d.
+## @deftypefn {Function File} {@var{zr} =} tzero2 (@var{a}, @var{b}, @var{c}, @var{d}, @var{bal})
+## Compute the transmission zeros of a, b, c, d.
 ##
-##bal = balancing option (see balance); default is "B".
+## bal = balancing option (see balance); default is "B".
 ##
-##Needs to incorporate @code{mvzero} algorithm to isolate finite zeros; use
-##@code{tzero} instead.
-##@end deftypefn
+## Needs to incorporate @code{mvzero} algorithm to isolate finite zeros; use
+## @code{tzero} instead.
+## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function zr = tzero2 (a, b, c, d, bal)
 
   if (nargin == 4)
     bal = "B";
@@ -38,25 +38,25 @@ function zr = tzero2 (a, b, c, d, bal)
   endif
 
   [n, m, p] = abcddim (a, b, c, d);
 
   if (n > 0 && m > 0 && p > 0)
     if (m != p)
       fprintf (stderr, "tzero: number of inputs,outputs differ.  squaring up");
       if (p > m)
-	fprintf (stderr, "       by padding b and d with zeros.");
-	b = [b, (zeros (n, p-m))];
-	d = [d, (zeros (p, p-m))];
-	m = p;
+        fprintf (stderr, "       by padding b and d with zeros.");
+        b = [b, (zeros (n, p-m))];
+        d = [d, (zeros (p, p-m))];
+        m = p;
       else
-	fprintf (stderr, "       by padding c and d with zeros.");
-	c = [c; (zeros (m-p, n))];
-	d = [d; (zeros (m-p, m))];
-	p = m;
+        fprintf (stderr, "       by padding c and d with zeros.");
+        c = [c; (zeros (m-p, n))];
+        d = [d; (zeros (m-p, m))];
+        p = m;
       endif
       fprintf (stderr, "This is a kludge.  Try again with SISO system.");
     endif
     ab = [-a, -b; c, d];
     bb = [(eye (n)), (zeros (n, m)); (zeros (p, n)), (zeros (p, m))];
     [ab,bb] = balance (ab, bb);
     zr = -qz (ab, bb);
   else
diff --git a/scripts/control/ugain.m b/scripts/control/ugain.m
--- a/scripts/control/ugain.m
+++ b/scripts/control/ugain.m
@@ -1,33 +1,33 @@
 ## Copyright (C) 1997 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{outsys} =} ugain(n)
-##  Creates a system with unity gain, no states.
-##  This trivial system is sometimes needed to create arbitrary
-##  complex systems from simple systems with buildssic.
-##  Watch out if you are forming sampled systems since "ugain"
-##  does not contain a sampling period.  
+## @deftypefn {Function File} {@var{outsys} =} ugain (@var{n})
+## Creates a system with unity gain, no states.
+## This trivial system is sometimes needed to create arbitrary
+## complex systems from simple systems with buildssic.
+## Watch out if you are forming sampled systems since "ugain"
+## does not contain a sampling period.
 ## @end deftypefn
 ## @seealso{hinfdemo and jet707}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function outsys = ugain (n)
 
diff --git a/scripts/control/wgt1o.m b/scripts/control/wgt1o.m
--- a/scripts/control/wgt1o.m
+++ b/scripts/control/wgt1o.m
@@ -1,41 +1,41 @@
 ## Copyright (C) 1998 Kai P. Mueller
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{wsys} =} wgt1o (@var{vl}, @var{vh}, @var{fc})
+## @deftypefn {Function File} {@var{wsys} =} wgt1o (@var{vl}, @var{vh}, @var{fc})
 ## State space description of a first order weighting function.
-## 
-##  Weighting function are needed by the H2/H_infinity design procedure.
-##  These function are part of thye augmented plant P (see hinfdemo
-##  for an applicattion example).
-## 
-##  vl = Gain @@ low frequencies
-## 
-##  vh = Gain @@ high frequencies
-## 
-##  fc = Corner frequency (in Hz, *not* in rad/sec)
+##
+## Weighting function are needed by the H2/H_infinity design procedure.
+## These function are part of thye augmented plant P (see hinfdemo
+## for an applicattion example).
+##
+## vl = Gain at low frequencies
+##
+## vh = Gain at high frequencies
+##
+## fc = Corner frequency (in Hz, *not* in rad/sec)
 ## @end deftypefn
- 
+
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 
 function wsys = wgt1o (vl, vh, fc)
 
   if (nargin != 3)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
diff --git a/scripts/control/zgfmul.m b/scripts/control/zgfmul.m
--- a/scripts/control/zgfmul.m
+++ b/scripts/control/zgfmul.m
@@ -1,81 +1,81 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } @var{y} = zgfmul(@var{a},@var{b},@var{c},@var{d},@var{x})
-## 
+## @deftypefn {Function File} {@var{y} =} zgfmul (@var{a}, @var{b}, @var{c}, @var{d}, @var{x})
+##
 ## Compute product of zgep incidence matrix @var{F} with vector @var{x}.
 ## Used by zgepbal (in zgscal) as part of generalized conjugate gradient
 ## iteration.
 ## @end deftypefn
-   
+
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Conversion to Octave July 3, 1994
-  
+
 function y = zgfmul (a, b, c, d, x)
 
   [n,m] = size(b);
   [p,m1] = size(c);
   nm = n+m;
   y = zeros(nm+p,1);
 
   ## construct F column by column
   for jj=1:n
     Fj = zeros(nm+p,1);
 
     ## rows 1:n: F1
-    aridx = complement(jj,find(a(jj,:) != 0)); 
+    aridx = complement(jj,find(a(jj,:) != 0));
     acidx = complement(jj,find(a(:,jj) != 0));
     bidx = find(b(jj,:) != 0);
     cidx = find(c(:,jj) != 0);
 
     Fj(aridx) = Fj(aridx) - 1;      # off diagonal entries of F1
     Fj(acidx) = Fj(acidx) - 1;
     ## diagonal entry of F1
     Fj(jj) = length(aridx)+length(acidx) + length(bidx) + length(cidx);
-    
+
     if(!isempty(bidx)) Fj(n+bidx) = 1;     endif # B' incidence
     if(!isempty(cidx)) Fj(n+m+cidx) = -1;  endif # -C incidence
     y = y + x(jj)*Fj;   # multiply by corresponding entry of x
   endfor
 
   for jj=1:m
     Fj = zeros(nm+p,1);
-    bidx = find(b(:,jj) != 0);   
+    bidx = find(b(:,jj) != 0);
     if(!isempty(bidx)) Fj(bidx) = 1; endif     # B incidence
-    didx = find(d(:,jj) != 0);   
+    didx = find(d(:,jj) != 0);
     if(!isempty(didx)) Fj(n+m+didx) = 1; endif # D incidence
     Fj(n+jj) = length(bidx) + length(didx);         # F2 is diagonal
     y = y + x(n+jj)*Fj;   # multiply by corresponding entry of x
   endfor
 
   for jj=1:p
     Fj = zeros(nm+p,1);
-    cidx = find(c(jj,:) != 0);   
+    cidx = find(c(jj,:) != 0);
     if(!isempty(cidx)) Fj(cidx) = -1; endif  # -C' incidence
-    didx = find(d(jj,:) != 0);   
+    didx = find(d(jj,:) != 0);
     if(!isempty(didx)) Fj(n+didx) = 1;  endif # D' incidence
     Fj(n+m+jj) = length(cidx) + length(didx);     # F2 is diagonal
     y = y + x(n+m+jj)*Fj;   # multiply by corresponding entry of x
   endfor
 
 endfunction
diff --git a/scripts/control/zgfslv.m b/scripts/control/zgfslv.m
--- a/scripts/control/zgfslv.m
+++ b/scripts/control/zgfslv.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {x =} zgfslv(@var{n},@var{m},@var{p},@var{b})
-## solve system of equations for dense zgep problem
+## @deftypefn {Function File} {@var{x} =} zgfslv (@var{n}, @var{m}, @var{p}, @var{b})
+## Solve system of equations for dense zgep problem.
 ## @end deftypefn
- 
+
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Converted to Octave by R Bruce Tenison, July 3, 1994
 
 function x = zgfslv (n, m, p, b)
 
   nmp = n+m+p;
   gam1 = (2*n)+m+p;    gam2 = n+p;     gam3 = n+m;
 
@@ -44,18 +44,18 @@ function x = zgfslv (n, m, p, b)
 
   ## 4) Givens rotations to reduce stray non-zero elements
   idx1 = [n+1,n+m+1];     idx2 = [1,n+1];
   x(idx1) = G1'*x(idx1);
   x(idx2) = G2'*x(idx2);
 
   ## 6) Scale x, then back-transform to get x
   en = ones(n,1);  em = ones(m,1);   ep = ones(p,1);
-  lam = [gam1*en;gam2*em;gam3*ep]; 
-  lam(1) = n+m+p; 
+  lam = [gam1*en;gam2*em;gam3*ep];
+  lam(1) = n+m+p;
   lam(n+1) = 1;       # dummy value to avoid divide by zero
   lam(n+m+1)=n+m+p;
 
   x = x ./ lam;       x(n+1) = 0;  # minimum norm solution
 
   ## back transform now.
   x(idx2) = G2*x(idx2);
   x(idx1) = G1*x(idx1);
diff --git a/scripts/control/zginit.m b/scripts/control/zginit.m
--- a/scripts/control/zginit.m
+++ b/scripts/control/zginit.m
@@ -1,34 +1,32 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {zz =} zginit(@var{a},@var{b},@var{c},@var{d})
-## construct right hand side vector zz
+## @deftypefn {Function File} {@var{zz} =} zginit (@var{a}, @var{b}, @var{c}, @var{d})
+## Construct right hand side vector zz
 ## for the zero-computation generalized eigenvalue problem
-## balancing procedure
-## called by zgepbal
-## 
-## @end deftypefn 
+## balancing procedure.  Called by zgepbal.
+## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison, July 3, 1994
@@ -56,17 +54,17 @@ function zz = zginit (a, b, c, d)
 
     ## row of b
     bidx = find(b(i,:) != 0);
     b_row_i = b(i,bidx);
 
     ## column of c
     cidx = find(c(:,i) != 0);
     c_col_i = c(cidx,i);
-   
+
     ## sum the entries
     zz(i) = sum(log(abs(acnz))) - sum(log(abs(arnz))) ...
             - sum(log(abs(b_row_i))) + sum(log(abs(c_col_i)));
   endfor
 
   ## zz part 2:
   bd = [b;d];
   for i=1:mm
diff --git a/scripts/control/zgpbal.m b/scripts/control/zgpbal.m
--- a/scripts/control/zgpbal.m
+++ b/scripts/control/zgpbal.m
@@ -1,82 +1,81 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {retsys =} zgpbal(Asys)
+## @deftypefn {Function File} {@var{retsys} =} zgpbal (@var{Asys})
 ##
 ## used internally in @code{tzero}; minimal argument checking performed
 ##
-## implementation of zero computation generalized eigenvalue problem 
+## implementation of zero computation generalized eigenvalue problem
 ## balancing method (Hodel and Tiller, Allerton Conference, 1991)
 ## Based on Ward's balancing algorithm (SIAM J. Sci Stat. Comput., 1981)
 ##
-## zgpbal computes a state/input/output weighting that attempts to 
+## zgpbal computes a state/input/output weighting that attempts to
 ## reduced the range of the magnitudes of the nonzero elements of [a,b,c,d]
 ## The weighting uses scalar multiplication by powers of 2, so no roundoff
-## will occur.  
+## will occur.
 ##
 ## zgpbal should be followed by zgpred
-##
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
-function retsys = zgpbal (Asys)  
+function retsys = zgpbal (Asys)
 
   if( (nargin != 1) | (!is_struct(Asys)))
     usage("retsys = zgpbal(Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
   [nn,mm,pp] = abcddim(a,b,c,d);
-  
+
   np1 = nn+1;
   nmp = nn+mm+pp;
 
   ## set up log vector zz, incidence matrix ff
   zz = zginit(a,b,c,d);
 
   ## disp("zgpbal: zginit returns")
   ## zz
   ## disp("/zgpbal")
 
   if (norm(zz))
     ## generalized conjugate gradient approach
     xx = zgscal(a,b,c,d,zz,nn,mm,pp);
-    
+
     for i=1:nmp
       xx(i) = floor(xx(i)+0.5);
       xx(i) = 2.0^xx(i);
     endfor
-    
+
     ## now scale a
     ## block 1: a = sigma a inv(sigma)
     for i=1:nn
       a(i,1:nn) = a(i,1:nn)*xx(i);
       a(1:nn,i) = a(1:nn,i)/xx(i);
     endfor
     ## block 2: b= sigma a phi
     for j=1:mm
@@ -99,12 +98,12 @@ function retsys = zgpbal (Asys)
       j1 = j+nn;
       d(1:pp,j) = d(1:pp,j)*xx(j1);
     endfor
     for i=1:pp
       i1 = i + nn + mm;
       d(i,1:mm) = d(i,1:mm)*xx(i1);
     endfor
   endif
-  
+
   retsys = ss2sys(a,b,c,d);
 endfunction
 
diff --git a/scripts/control/zgreduce.m b/scripts/control/zgreduce.m
--- a/scripts/control/zgreduce.m
+++ b/scripts/control/zgreduce.m
@@ -1,64 +1,64 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { retsys = } zgreduce(@var{Asys},@var{meps})
-## Implementation of procedure REDUCE in (Emami-Naeini and Van Dooren, 
+## @deftypefn {Function File} {retsys =} zgreduce (@var{Asys}, @var{meps})
+## Implementation of procedure REDUCE in (Emami-Naeini and Van Dooren,
 ## Automatica, # 1982).
 ## @end deftypefn
- 
+
 function retsys = zgreduce (Asys, meps)
 
   ## SYS_INTERNAL accesses members of system data structure
 
-  is_digital(Asys);		# make sure it's pure digital/continuous
+  is_digital(Asys);             # make sure it's pure digital/continuous
 
-  exit_1 = 0;			# exit_1 = 1 or 2 on exit of loop
+  exit_1 = 0;                   # exit_1 = 1 or 2 on exit of loop
 
   if(Asys.n + Asys.nz == 0)
-    exit_1 = 2;			# there are no finite zeros
+    exit_1 = 2;                 # there are no finite zeros
   endif
 
   while (! exit_1)
-    [Q,R,Pi] = qr(Asys.d);		# compress rows of D
+    [Q,R,Pi] = qr(Asys.d);              # compress rows of D
     Asys.d = Q'*Asys.d;
     Asys.c = Q'*Asys.c;
 
     ## check row norms of Asys.d
     [sig,tau] = zgrownorm(Asys.d,meps);
 
     ## disp("=======================================")
     ## disp(["zgreduce: meps=",num2str(meps), ", sig=",num2str(sig), ...
-    ##	 ", tau=",num2str(tau)])
+    ##   ", tau=",num2str(tau)])
     ## sysout(Asys)
 
     if(tau == 0)
-      exit_1 = 1;		# exit_1 - reduction complete and correct
+      exit_1 = 1;               # exit_1 - reduction complete and correct
     else
       Cb = Db = [];
       if(sig)
-	Cb = Asys.c(1:sig,:);
-	Db = Asys.d(1:sig,:);
+        Cb = Asys.c(1:sig,:);
+        Db = Asys.d(1:sig,:);
       endif
       Ct =Asys.c(sig+(1:tau),:);
 
       ## compress columns of Ct
       [pp,nn] = size(Ct);
       rvec = nn:-1:1;
       [V,Sj,Pi] = qr(Ct');
       V = V(:,rvec);
@@ -66,64 +66,64 @@ function retsys = zgreduce (Asys, meps)
 
       ## disp(["zgreduce: rho=",num2str(rho),", gnu=",num2str(gnu)])
       ## Cb
       ## Db
       ## Ct
       ## Sj'
 
       if(rho == 0)
-	exit_1 = 1;	# exit_1 - reduction complete and correct
+        exit_1 = 1;     # exit_1 - reduction complete and correct
       elseif(gnu == 0)
-	exit_1 = 2;	# there are no zeros at all
+        exit_1 = 2;     # there are no zeros at all
       else
-	mu = rho + sig;
+        mu = rho + sig;
 
-	## update system with Q
-	M = [Asys.a , Asys.b ];
-	[nn,mm] = size(Asys.b);
+        ## update system with Q
+        M = [Asys.a , Asys.b ];
+        [nn,mm] = size(Asys.b);
 
-	pp = rows(Asys.d);
-	Vm =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
-	if(sig)
-	  M = [M; Cb, Db];
-	  Vs =[V',zeros(nn,sig) ; zeros(sig,nn), eye(sig)];
-	else
-	  Vs = V';
-	endif
-	## disp("zgreduce: before transform: M=");
-	## M
-	## Vs   
-	## Vm
+        pp = rows(Asys.d);
+        Vm =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
+        if(sig)
+          M = [M; Cb, Db];
+          Vs =[V',zeros(nn,sig) ; zeros(sig,nn), eye(sig)];
+        else
+          Vs = V';
+        endif
+        ## disp("zgreduce: before transform: M=");
+        ## M
+        ## Vs
+        ## Vm
 
-	M = Vs*M*Vm;
+        M = Vs*M*Vm;
 
-	## disp("zgreduce: after transform: M=");
-	## M
+        ## disp("zgreduce: after transform: M=");
+        ## M
 
-	## disp("debugging code:")
-	## Mtmp = [Asys.a Asys.b; Asys.c Asys.d]
-	## Vl = [V', zeros(nn,mm); zeros(mm,nn),Q]
-	## Vr =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
-	## Mtmpf = Vl*Mtmp*Vr
+        ## disp("debugging code:")
+        ## Mtmp = [Asys.a Asys.b; Asys.c Asys.d]
+        ## Vl = [V', zeros(nn,mm); zeros(mm,nn),Q]
+        ## Vr =[V,zeros(nn,mm) ; zeros(mm,nn), eye(mm)];
+        ## Mtmpf = Vl*Mtmp*Vr
 
-	idx = 1:gnu;
-	jdx = nn + (1:mm);
-	sdx = gnu + (1:mu);
+        idx = 1:gnu;
+        jdx = nn + (1:mm);
+        sdx = gnu + (1:mu);
 
-	Asys.a = M(idx,idx);
-	Asys.b = M(idx,jdx);
-	Asys.c = M(sdx,idx);
-	Asys.d = M(sdx,jdx);
+        Asys.a = M(idx,idx);
+        Asys.b = M(idx,jdx);
+        Asys.c = M(sdx,idx);
+        Asys.d = M(sdx,jdx);
 
-	## disp(["zgreduce: resulting system: nn =",num2str(nn)," mu=",num2str(mu)])
-	## sysout(Asys)
-	## idx
-	## jdx
-	## sdx
+        ## disp(["zgreduce: resulting system: nn =",num2str(nn)," mu=",num2str(mu)])
+        ## sysout(Asys)
+        ## idx
+        ## jdx
+        ## sdx
       endif
     endif
   endwhile
 
   ## disp(["zgreduce: while loop done: exit_1=",num2str(exit_1)]);
 
   if(exit_1 == 2)
     ## there are no zeros at all!
diff --git a/scripts/control/zgrownorm.m b/scripts/control/zgrownorm.m
--- a/scripts/control/zgrownorm.m
+++ b/scripts/control/zgrownorm.m
@@ -1,30 +1,31 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{nonz}, @var{zer}] =} zgrownorm (@var{mat}, @var{meps})
-## returns @var{nonz} = number of rows of @var{mat} whose two norm exceeds @var{meps}
-##         @var{zer} = number of rows of mat whose two norm is less than meps
+## @deftypefn {Function File} {[@var{nonz}, @var{zer}] =} zgrownorm (@var{mat}, @var{meps})
+## Return @var{nonz} = number of rows of @var{mat} whose two norm
+## exceeds @var{meps}, and @var{zer} = number of rows of mat whose two
+## norm is less than @var{meps}.
 ## @end deftypefn
 
 function [sig, tau] = zgrownorm (mat, meps)
 
   rownorm = [];
   for ii=1:rows(mat)
     rownorm(ii) = norm(mat(ii,:));
   endfor
diff --git a/scripts/control/zgscal.m b/scripts/control/zgscal.m
--- a/scripts/control/zgscal.m
+++ b/scripts/control/zgscal.m
@@ -1,30 +1,30 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
 ## -*- texinfo -*-
-## @deftypefn {Function File } { x =} zgscal (@var{f}, @var{z}, @var{n}, @var{m}, @var{p})
-## Generalized conjugate gradient iteration to 
-## solve zero-computation generalized eigenvalue problem balancing equation 
+## @deftypefn {Function File} {@var{x} =} zgscal (@var{f}, @var{z}, @var{n}, @var{m}, @var{p})
+## Generalized conjugate gradient iteration to
+## solve zero-computation generalized eigenvalue problem balancing equation
 ## @math{fx=z};
 ## called by @code{zgepbal}
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
@@ -33,47 +33,47 @@
 ## Conversion to Octave R. Bruce Tenison July 3, 1994
 
 function x = zgscal (a, b, c, d, z, n, m, p)
 
   ## initialize parameters:
   ## Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
 
   nmp = n+m+p;
-  
+
   ## x_0 = x_{-1} = 0, r_0 = z
   x = zeros(nmp,1);
   xk1 = x;
   xk2 = x;
   rk1 = z;
   k = 0;
 
   ## construct balancing least squares problem
   F = eye(nmp);
   for kk=1:nmp
     F(1:nmp,kk) = zgfmul(a,b,c,d,F(:,kk));
   endfor
 
   [U,H,k1] = krylov(F,z,nmp,1e-12,1);
   if(!is_square(H))
-    if(columns(H) != k1) 
+    if(columns(H) != k1)
       error("zgscal(tzero): k1=%d, columns(H)=%d",k1,columns(H));
     elseif(rows(H) != k1+1)
       error("zgscal: k1=%d, rows(H) = %d",k1,rows(H));
     elseif ( norm(H(k1+1,:)) > 1e-12*norm(H,"inf") )
       zgscal_last_row_of_H = H(k1+1,:)
       error("zgscal: last row of H nonzero (norm(H)=%e)",norm(H,"inf"))
     endif
     H = H(1:k1,1:k1);
     U = U(:,1:k1);
   endif
 
-  ## tridiagonal H can still be rank deficient, so do permuted qr 
+  ## tridiagonal H can still be rank deficient, so do permuted qr
   ## factorization
-  [qq,rr,pp] = qr(H);	# H = qq*rr*pp'
+  [qq,rr,pp] = qr(H);   # H = qq*rr*pp'
   nn = rank(rr);
   qq = qq(:,1:nn);
   rr = rr(1:nn,:);            # rr may not be square, but "\" does least
   xx = U*pp*(rr\qq'*(U'*z));  # squares solution, so this works
   ## xx1 = pinv(F)*z;
   ## zgscal_x_xx1_err = [xx,xx1,xx-xx1]
   return;
 
@@ -89,17 +89,17 @@ function x = zgscal (a, b, c, d, z, n, m
 
   ## dummy defines for MATHTOOLS compiler
   gamk2 = 0;      omega1 = 0;      ztmz2 = 0;
 
   ## do until small changes to x
   len_x = length(x);
   while ((k < 2*len_x) & (xnorm> 0.5) & (rnorm>fnorm))|(k == 0)
     k = k+1;
-    
+
     ## solve F_d z_{k-1} = r_{k-1}
     zk1= zgfslv(n,m,p,rk1);
 
     ## Generalized CG iteration
     ## gamk1 = (zk1'*F_d*zk1)/(zk1'*F*zk1);
     ztMz1 = zk1'*rk1;
     gamk1 = ztMz1/(zk1'*zgfmul(a,b,c,d,zk1));
 
@@ -125,17 +125,17 @@ function x = zgscal (a, b, c, d, z, n, m
     gamk2 = gamk1;
     omega1 = omega;
     ztmz2 = ztMz1;
     [xk1,xk2] = swap(xk1,xk2);
   endwhile
   x = xk2;
 
   ## check convergence
-  if (xnorm> 0.5 & rnorm>fnorm) 
+  if (xnorm> 0.5 & rnorm>fnorm)
     warning("zgscal(tzero): GCG iteration failed; solving with pinv");
 
     ## perform brute force least squares; construct F
     Am = eye(nmp);
     for ii=1:nmp
       Am(:,ii) = zgfmul(a,b,c,d,Am(:,ii));
     endfor
 
diff --git a/scripts/control/zgsgiv.m b/scripts/control/zgsgiv.m
--- a/scripts/control/zgsgiv.m
+++ b/scripts/control/zgsgiv.m
@@ -1,30 +1,30 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[a ,b ] =} zgsgiv(@var{c},@var{s},@var{a},@var{b})
+## @deftypefn {Function File} {[a, b] =} zgsgiv (@var{c}, @var{s}, @var{a}, @var{b})
 ## apply givens rotation c,s to row vectors @var{a},@var{b}
-## No longer used in zero-balancing (zgpbal); kept for backward compatibility
+## No longer used in zero-balancing (zgpbal); kept for backward compatibility.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 29, 1992
 ## Convertion to Octave by R. Bruce Tenison July 3, 1994
 
 function [a, b] = zgsgiv (c, s, a, b)
 
diff --git a/scripts/control/zgshsr.m b/scripts/control/zgshsr.m
--- a/scripts/control/zgshsr.m
+++ b/scripts/control/zgshsr.m
@@ -1,29 +1,29 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{x} =} zgshsr( @var{y})
-## apply householder vector based on @math{e^(m)} to 
+## @deftypefn {Function File} {@var{x} =} zgshsr (@var{y})
+## apply householder vector based on @math{e^(m)} to
 ## (column vector) y.
 ## Called by zgfslv
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
diff --git a/scripts/control/zp2ss.m b/scripts/control/zp2ss.m
--- a/scripts/control/zp2ss.m
+++ b/scripts/control/zp2ss.m
@@ -1,28 +1,28 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{A}, @var{B}, @var{C}, @var{D}] =} zp2ss (@var{zer}, @var{pol}, @var{k})
+## @deftypefn {Function File} {[@var{A}, @var{B}, @var{C}, @var{D}] =} zp2ss (@var{zer}, @var{pol}, @var{k})
 ## Conversion from zero / pole to state space.
 ## @strong{Inputs}
 ## @table @var
 ## @item zer
 ## @itemx pol
 ## vectors of (possibly) complex poles and zeros of a transfer
 ## function.  Complex values must come in conjugate pairs
 ## (i.e., x+jy in zer means that x-jy is also in zer)
@@ -33,45 +33,45 @@
 ##  @var{A}, @var{B}, @var{C}, @var{D}
 ## The state space system
 ## @example
 ## .
 ## x = Ax + Bu
 ## y = Cx + Du
 ## @end example
 ## is obtained from a vector of zeros and a vector of poles via the
-## function call @code{[a,b,c,d] = zp2ss(zer,pol,k)}.  
-## The vectors @samp{zer} and 
+## function call @code{[a,b,c,d] = zp2ss(zer,pol,k)}.
+## The vectors @samp{zer} and
 ## @samp{pol} may either be row or column vectors.  Each zero and pole that
 ## has an imaginary part must have a conjugate in the list.
 ## The number of zeros must not exceed the number of poles.
 ## @samp{k} is @code{zp}-form leading coefficient.
 ## @end deftypefn
- 
+
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function [a, b, c, d] = zp2ss (zer, pol, k)
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin != 3)
     error("Incorrect number of input arguments");
   endif
- 
+
   if(! (is_vector(zer) | isempty(zer)) )
     error(["zer(",num2str(rows(zer)),",",num2str(columns(zer)), ...
-	") should be a vector"]);
+        ") should be a vector"]);
   elseif(! (is_vector(pol) | isempty(pol) ) )
     error(["pol(",num2str(rows(pol)),",",num2str(columns(pol)), ...
-	") should be a vector"]);
+        ") should be a vector"]);
   elseif(! is_scalar(k))
     error(["k(",num2str(rows(k)),",",num2str(columns(k)), ...
-	") should be a scalar"]);
+        ") should be a scalar"]);
   elseif( k != real(k))
     warning("zp2ss: k is complex")
   endif
 
   zpsys = ss2sys([],[],[],k);
 
   ## Find the number of zeros and the number of poles
   nzer=length(zer);
@@ -86,53 +86,53 @@ function [a, b, c, d] = zp2ss (zer, pol,
   pol=sortcom(pol);
 
   ## construct the system as a series connection of poles and zeros
   ## problem: poles and zeros may come in conjugate pairs, and not
   ## matched up!
 
   ## approach: remove poles/zeros from the list as they are included in
   ## the ss system
- 
+
   while(length(pol))
 
     ## search for complex poles, zeros
     cpol=[];    czer = [];
     if(!isempty(pol))
       cpol = find(imag(pol) != 0);
     endif
     if(!isempty(zer))
       czer = find(imag(zer) != 0);
     endif
 
     if(isempty(cpol) & isempty(czer))
       pcnt = 1;
-    else 
+    else
       pcnt = 2;
     endif
 
-    num=1;	# assume no zeros left.
+    num=1;      # assume no zeros left.
     switch(pcnt)
     case(1)
       ## real pole/zero combination
       if(length(zer))
-        num = [1, -zer(1)];  
+        num = [1, -zer(1)];
         zer = zer(2:length(zer));
       endif
       den = [1, -pol(1)];
       pol = pol(2:length(pol));
     case(2)
       ## got a complex pole or zero, need two roots (if available)
       if(length(zer) > 1)
-        [num,zer] = zp2ssg2(zer);	# get two zeros
+        [num,zer] = zp2ssg2(zer);       # get two zeros
       elseif(length(zer) == 1)
-        num = [1, -zer];		# use last zero (better be real!)
+        num = [1, -zer];                # use last zero (better be real!)
         zer = [];
       endif
-      [den,pol] = zp2ssg2(pol);		# get two poles
+      [den,pol] = zp2ssg2(pol);         # get two poles
     otherwise
       error(["pcnt = ",num2str(pcnt)])
     endswitch
 
     ## pack tf into system form and put in series with earlier realization
     zpsys1 = tf2sys(num,den,0,"u","yy");
 
     ## change names to avoid warning messages from sysgroup
@@ -140,15 +140,15 @@ function [a, b, c, d] = zp2ss (zer, pol,
     zpsys1 = sysupdate(zpsys1,"ss");
     nn     = sysdimensions(zpsys);        # working with continuous system
     zpsys  = syssetsignals(zpsys,"st", sysdefioname(nn,"x"));
     nn1    = sysdimensions(zpsys1);
     zpsys1 = syssetsignals(zpsys1,"st",sysdefioname(nn1,"xx"));
 
     zpsys = sysmult(zpsys,zpsys1);
 
-  endwhile 
+  endwhile
 
   [a,b,c,d] = sys2ss(zpsys);
 
   empty_list_elements_ok = sav_val;
 endfunction
 
diff --git a/scripts/control/zp2ssg2.m b/scripts/control/zp2ssg2.m
--- a/scripts/control/zp2ssg2.m
+++ b/scripts/control/zp2ssg2.m
@@ -1,31 +1,31 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { [@var{poly}, @var{rvals}] =} zp2ssg2 (@var{rvals})
+## @deftypefn {Function File} {[@var{poly}, @var{rvals}] =} zp2ssg2 (@var{rvals})
 ## Used internally in @code{zp2ss}
 ## Extract 2 values from @var{rvals} (if possible) and construct
-##  a polynomial with those roots.
+## a polynomial with those roots.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1996
 
 function [poly, rvals] = zp2ssg2 (rvals)
 
   ## locate imaginary roots (if any)
@@ -42,17 +42,17 @@ function [poly, rvals] = zp2ssg2 (rvals)
     c2i = find(err == minerr);
     r2i = cidx(c2i);
     r2 = rvals(r2i);
     cidx = complement(r2i,cidx);
 
     ## don't check for divide by zero, since 0 is not complex.
     if(abs(r2 - r1')/abs(r1) > 1e-12)
       error(sprintf("r1=(%f,%f); r2=(%f,%f), not conjugates.", ...
-	real(r1),imag(r1),real(r2),imag(r2)));
+        real(r1),imag(r1),real(r2),imag(r2)));
     endif
 
     ## complex conjugate pair
     poly = [1, -2*real(r1), real(r1)^2+imag(r1)^2];
   else
     ## select two roots (they're all real)
     r1 = rvals(1);
     r2 = rvals(2);
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -1,122 +1,122 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{sys} =} zp2sys (@var{zer},@var{pol},@var{k}@{,@var{tsam},@var{inname},@var{outname}@})
-##  Create system data structure from zero-pole data
-## 
+## @deftypefn {Function File} {@var{sys} =} zp2sys (@var{zer},@var{pol},@var{k}@{,@var{tsam},@var{inname},@var{outname}@})
+## Create system data structure from zero-pole data.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item   zer
-##  vector of system zeros
+## vector of system zeros
 ## @item   pol
-##  vector of system poles
+## vector of system poles
 ## @item   k
-##  scalar leading coefficient
+## scalar leading coefficient
 ## @item   tsam
-##  sampling period. default: 0 (continuous system)
+## sampling period. default: 0 (continuous system)
 ## @item   inname
 ## @itemx  outname
-##  input/output signal names (lists of strings)
+## input/output signal names (lists of strings)
 ## @end table
-## 
+##
 ## @strong{Outputs}
-##  sys: system data structure
-## 
+## sys: system data structure
+##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=zp2sys([1 -1],[-2 -2 0],1);
 ## octave:2> sysout(sys)
 ## Input(s)
 ##         1: u_1
 ## Output(s):
 ##         1: y_1
 ## zero-pole form:
 ## 1 (s - 1) (s + 1)
 ## -----------------
 ## s (s + 2) (s + 2)
 ## @end example
 ## @end deftypefn
- 
-## Modified by John Ingram  July 20, 1996  
+
+## Modified by John Ingram  July 20, 1996
 
 function outsys = zp2sys (zer, pol, k, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
     usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
   endif
 
-  ## check input format 
+  ## check input format
   if( ! (is_vector(zer) | isempty(zer) ) )
     error("zer must be a vector or empty");
   endif
   if(!isempty(zer))
-    zer = reshape(zer,1,length(zer));		# make it a row vector
+    zer = reshape(zer,1,length(zer));           # make it a row vector
   endif
 
   if( ! (is_vector(pol) | isempty(pol)))
     error("pol must be a vector");
   endif
   if(!isempty(pol))
     pol = reshape(pol,1,length(pol));
   endif
 
   if (! is_scalar(k))
      error("k must be a scalar");
   endif
 
-  ## Test proper numbers of poles and zeros.  The number of poles must be 
+  ## Test proper numbers of poles and zeros.  The number of poles must be
   ## greater than or equal to the number of zeros.
   if (length(zer) >  length(pol))
     error(["number of poles (", num2str(length(pol)), ...
-	") < number of zeros (", num2str(length(zer)),")"]);
+        ") < number of zeros (", num2str(length(zer)),")"]);
   endif
 
   ## Set the system transfer function
   outsys.zer = zer;
   outsys.pol = pol;
   outsys.k = k;
 
   ## Set the system vector:  active = 1, updated = [0 1 0];
   outsys.sys = [1, 0, 1, 0];
 
   ## Set defaults
   outsys.tsam = 0;
   outsys.n = length(pol);
   outsys.nz = 0;
-  outsys.yd = 0;	# assume (for now) continuous time outputs
+  outsys.yd = 0;        # assume (for now) continuous time outputs
 
   ## Set the type of system
   if (nargin > 3)
     if( !is_scalar(tsam) )
       error("tsam must be a nonnegative scalar");
     endif
     if (tsam < 0)
       error("sampling time must be positve")
     elseif (tsam > 0)
       [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
-      outsys.yd = 1;		# discrete-time output
+      outsys.yd = 1;            # discrete-time output
     endif
 
     outsys.tsam = tsam;
   endif
 
   outsys.inname = sysdefioname(1,"u");
   outsys.outname = sysdefioname(1,"y");
   outsys.stname = sysdefstname(outsys.n,outsys.nz);
@@ -137,11 +137,11 @@ function outsys = zp2sys (zer, pol, k, t
   if (nargin > 5)
     if(!isempty(outname))
       if(!is_list(outname))        outname = list(outname);    endif
       if(!is_signal_list(outname))
         error("outname must be a single signal name");
       endif
       outsys.outname = outname(1);
     endif
-  endif 
+  endif
 
 endfunction
diff --git a/scripts/control/zp2tf.m b/scripts/control/zp2tf.m
--- a/scripts/control/zp2tf.m
+++ b/scripts/control/zp2tf.m
@@ -1,39 +1,39 @@
 ## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{num}, @var{den}] =} zp2tf (@var{zer}, @var{pol}, @var{k})
-##  Converts zeros / poles to a transfer function.
+## @deftypefn {Function File} {[@var{num}, @var{den}] =} zp2tf (@var{zer}, @var{pol}, @var{k})
+## Converts zeros / poles to a transfer function.
 ## @strong{Inputs}
 ## @table @var
 ## @item zer
 ## @itemx pol
 ## vectors of (possibly complex) poles and zeros of a transfer
 ## function.  Complex values should appear in conjugate pairs
 ## @item k
 ## real scalar (leading coefficient)
 ## @end table
-## @code{[num,den] = zp2tf(zer,pol,k)} forms the transfer function 
+## @code{[num,den] = zp2tf(zer,pol,k)} forms the transfer function
 ## @code{num/den} from the vectors of poles and zeros.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## (With help from students Ingram, McGowan.)
 
 function [num, den] = zp2tf (zer, pol, k)
 
@@ -55,21 +55,21 @@ function [num, den] = zp2tf (zer, pol, k
 
   num = k;  den = 1;
 
   ## call zp2ssg2 if there are complex conjugate pairs left, otherwise
   ## construct real zeros one by one.  Repeat for poles.
 
   while(!isempty(zer))
     if( max(abs(imag(zer))) )     [poly,zer] = zp2ssg2(zer);
-    else                          poly = [1, -zer(1)];  
+    else                          poly = [1, -zer(1)];
                                   zer = zer(2:length(zer));      endif
     num = conv(num,poly);
   endwhile
 
   while(!isempty(pol))
     if( max(abs(imag(pol))) )     [poly,pol] = zp2ssg2(pol);
-    else                          poly = [1, -pol(1)];  
+    else                          poly = [1, -pol(1)];
                                   pol = pol(2:length(pol));      endif
     den = conv(den,poly);
   endwhile
 
 endfunction
diff --git a/scripts/control/zpout.m b/scripts/control/zpout.m
--- a/scripts/control/zpout.m
+++ b/scripts/control/zpout.m
@@ -1,60 +1,60 @@
 ## Copyright (C) 1996 Auburn University.  All rights reserved.
 ##
-## This file is part of Octave. 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
 ##
-## Octave is free software; you can redistribute it and/or modify it 
-## under the terms of the GNU General Public License as published by the 
-## Free Software Foundation; either version 2, or (at your option) any 
-## later version. 
-## 
-## Octave is distributed in the hope that it will be useful, but WITHOUT 
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
-## You should have received a copy of the GNU General Public License 
-## along with Octave; see the file COPYING.  If not, write to the Free 
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { } zpout (@var{zer}, @var{pol}, @var{k}@{, @var{x}@})
-##  print formatted zero-pole form to the screen.  
+## @deftypefn {Function File} {} zpout (@var{zer}, @var{pol}, @var{k}@{, @var{x}@})
+## print formatted zero-pole form to the screen.
 ## @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue, 
-## filter, polyderiv, polyinteg, and polyout} 
+## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
+## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function zpout (zer, pol, k, x)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
     usage("zpout(zer,pol,k[,x])");
   endif
- 
+
   if( !(is_vector(zer) | isempty(zer)) | !(is_vector(pol) | isempty(pol)) )
     error("zer, pol must be vectors or empty");
   endif
 
   if(!is_scalar(k))
     error("zpout: argument k must be a scalar.")
   endif
- 
+
   if (nargin == 3)
     x = "s";
   elseif( ! isstr(x) )
     error("zpout: third argument must be a string");
   endif
- 
+
   numstring = num2str(k);
 
   if(length(zer))
     ## find roots at z,s = 0
     nzr = sum(zer == 0);
     if(nzr)
       if(nzr > 1)
         numstring = [numstring,sprintf(" %s^%d",x,nzr)];
